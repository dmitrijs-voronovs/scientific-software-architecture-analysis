quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Deployability,"useAxisBinning is set and if the selected distribution fits into a root histogram (1,2,3 dimensions) then return a histogram with the proper binning on each axis. Otherwise, return a 1D histogram with equidistant binning. If the histogram title is zero, a title is assigned automatically.; The axisSteering is defines as follows: ""axis[mode];axis[mode];..."" where: . axis = name of an axis or * . mode = any combination of the letters CUO0123456789 . C collapse axis into one bin (add up results). If any of the numbers 0-9 are given in addition, only these bins are added up. Here bins are counted from zero, whereas in root, bins are counted from 1. Obviously, this only works for up to 10 bins. . U discarde underflow bin . O discarde overflow bin . examples: imagine the binning has two axis, named x and y. . ""*[UO]"" exclude underflow and overflow bins for all axis. So here a TH2 is returned but all undeflow and overflow bins are empty . ""x[UOC123]"" integrate over the variable x but only using the bins 1,2,3 and not the underflow and overflow in x. Here a TH1 is returned, the axis is labelled ""y"" and the underflow and overflow (in y) are filled. However only the x-bins 1,2,3 are used to determine the content. . ""x[C];y[UO]"" integrate over the variable x, including underflow and overflow but exclude underflow and overflow in y. Here a TH1 is returned, the axis is labelled ""y"". The underflow and overflow in y are empty. . Definition at line 654 of file TUnfoldDensity.cxx. ◆ GetOutputBinName(). TString TUnfoldDensity::GetOutputBinName ; (; Int_t ; iBinX); const. overrideprotectedvirtual . Get bin name of an outpt bin. ; Parameters. [in]iBinXbin number. Return value: name of the bin. The name is constructed from the entries in the binning scheme and includes information about the bin borders etc. ; Reimplemented from TUnfold.; Definition at line 311 of file TUnfoldDensity.cxx. ◆ GetOutputBinning(). const TUnfoldBinning * TUnfoldDensity::GetOutputBinning ; (; const char * ; dist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:59156,integrat,integrate,59156,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,1,['integrat'],['integrate']
Deployability,"useX and fMouseY when user move a mouse over viewer and hides ToolTip. ;  ; void LevelDistValueSetSlot (Long_t dist);  Emmited when user changes distance between levels. ;  ; void MouseOverSlot (TGLPhysicalShape *shape);  MouseOver slot. ;  ; void RedoButtonSlot ();  Activated when user click Redo button. Repeat last Undo action. ;  ; void ResetButtonSlot ();  Resets camera. ;  ; void ScaleByChangedSlot ();  Activated when user press radio button. ;  ; void SetLinksVisibility (Bool_t val);  Sets links visibility to ""visible"". ;  ; void SetNodePtr (TStructNode *val);  Sets top node pointer and updates view. ;  ; void SetPointerButtonSlot ();  Sets pointer given in fPointerTestEntry to the main pointer. ;  ; void ShowLinksToggled (Bool_t on);  Changes links visibility and refresh view. ;  ; void UndoButtonSlot ();  UndoButton Slot. Activated when user press Undo button. Restore last top node pointer. ;  ; void Update (Bool_t resetCamera=false);  Updates view. Clear all the nodes, call draw function and update scene. Doesn't reset camera. ;  ; void UpdateButtonSlot ();  Update button slot. Updates scene. ;  ;  Public Member Functions inherited from TGMainFrame;  TGMainFrame (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=kVerticalFrame);  Create a top level main frame. ;  ;  ~TGMainFrame () override;  TGMainFrame destructor. ;  ; virtual Bool_t BindKey (const TGWindow *w, Int_t keycode, Int_t modifier) const;  Bind key to a window. ;  ; void DontCallClose ();  Typically call this method in the slot connected to the CloseWindow() signal to prevent the calling of the default or any derived CloseWindow() methods to prevent premature or double deletion of this window. ;  ; TList * GetBindList () const;  ; void GetClassHints (const char *&className, const char *&resourceName) const;  ; const char * GetIconName () const override;  Returns mime type name of object. ;  ; const char * GetIconPixmap () const;  ; void GetMWMHints (UInt_t &value, UInt_t &funcs, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStructViewerGUI.html:2623,update,update,2623,doc/master/classTStructViewerGUI.html,https://root.cern,https://root.cern/doc/master/classTStructViewerGUI.html,1,['update'],['update']
Deployability,"used for suppression of signals; TGButtonGroup*fTypeButtons; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLClipSetSubEditor(const TGWindow* p); Constructor. void SetModel(TGLClipSet* m); Set model object. void Changed(); Emit Changed signal. void ClipValueChanged(); One of number entries was changed. void ClipTypeChanged(Int_t ); Clip type radio button changed - update viewer. void UpdateViewerClip(); Change clipping volume. void ResetViewerClip(); Reset transformation of the current clip. TGLClipSetSubEditor(const TGLClipSetSubEditor& ). TGLClipSetSubEditor& operator=(const TGLClipSetSubEditor& ). virtual ~TGLClipSetSubEditor(); {}. » Author: Matevz Tadel, Jun 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLClipSetEditor.h 32338 2010-02-12 17:11:34Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLClipSetSubEditor.html:19303,update,update,19303,root/html528/TGLClipSetSubEditor.html,https://root.cern,https://root.cern/root/html528/TGLClipSetSubEditor.html,1,['update'],['update']
Deployability,"used for suppression of signals; TGButtonGroup*fTypeButtons; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLClipSetSubEditor(const TGWindow* p); Constructor. void SetModel(TGLClipSet* m); Set model object. void Changed(); Emit Changed signal. void ClipValueChanged(); One of number entries was changed. void ClipTypeChanged(Int_t ); Clip type radio button changed - update viewer. void UpdateViewerClip(); Change clipping volume. void ResetViewerClip(); Reset transformation of the current clip. TGLClipSetSubEditor(const TGLClipSetSubEditor& ). TGLClipSetSubEditor& operator=(const TGLClipSetSubEditor& ). virtual ~TGLClipSetSubEditor(); {}. » Author: Matevz Tadel, Jun 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLClipSetEditor.h 32338 2010-02-12 17:11:34Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLClipSetSubEditor.html:19403,update,update,19403,root/html530/TGLClipSetSubEditor.html,https://root.cern,https://root.cern/root/html530/TGLClipSetSubEditor.html,1,['update'],['update']
Deployability,"used for suppression of signals; TGButtonGroup*fTypeButtons; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLClipSetSubEditor(const TGWindow* p); Constructor. void SetModel(TGLClipSet* m); Set model object. void Changed(); Emit Changed signal. void ClipValueChanged(); One of number entries was changed. void ClipTypeChanged(Int_t ); Clip type radio button changed - update viewer. void UpdateViewerClip(); Change clipping volume. void ResetViewerClip(); Reset transformation of the current clip. TGLClipSetSubEditor(const TGLClipSetSubEditor& ). TGLClipSetSubEditor& operator=(const TGLClipSetSubEditor& ). virtual ~TGLClipSetSubEditor(); {}. » Author: Matevz Tadel, Jun 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLClipSetEditor.h 32338 2010-02-12 17:11:34Z matevz $ » Last generated: 2011-11-03 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLClipSetSubEditor.html:19403,update,update,19403,root/html532/TGLClipSetSubEditor.html,https://root.cern,https://root.cern/root/html532/TGLClipSetSubEditor.html,3,"['Update', 'update']","['UpdateViewerClip', 'update']"
Deployability,"user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library. * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function. * GSLDerivator of MathMore based on GSL.; 13.10 Numerical Minimization; The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes TMinuitMinimizer implemented using TMinuit, TFumiliMinimizer implemented using TFumili for least square or likelihood minimizations. We encourage the use of the GSL algorithms for one dimensional minimization and Minuit2 (or the old versionMinuit) for multi dimensional minimization. Numerical Minimization classes. 13.10.1 One-Dimensional Minimization; These algorithms are for finding the mini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:713464,integrat,integration,713464,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['integrat'],['integration']
Deployability,"user-defined extension to the material. The material ""grabs"" a copy, so; the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for user extensions and is guaranteed not; to be used by TGeo. void SetFWExtension(TGeoExtension* ext); Connect framework defined extension to the material. The material ""grabs"" a copy,; so the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for the use by TGeo and the users should; NOT connect extensions using this method. TGeoExtension * GrabUserExtension() const; Get a copy of the user extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). TGeoExtension * GrabFWExtension() const; Get a copy of the framework extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). char * GetPointerName() const; Provide a pointer name containing uid. void SetRadLen(Double_t radlen, Double_t intlen = 0.); Set radiation/absorbtion lengths. If the values are negative, their absolute value; is taken, otherwise radlen is recomputed using G3 formula. Double_t Coulomb(Double_t z); static function; Compute Coulomb correction for pair production and Brem; REFERENCE : EGS MANUAL SLAC 210 - UC32 - JUNE 78; FORMULA 2.7.17. Bool_t IsEq(const TGeoMaterial* other) const; return true if the other material has the same physical properties. void Print(Option_t* option = """") const; print characteristics of this material. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". Int_t GetDefaultColor() const; Get some default color related to this material. TGeoElement * GetElement(Int_t i = 0) const; Get a pointer to the element this material is made of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoMaterial.html:10768,Release,Release,10768,root/html534/TGeoMaterial.html,https://root.cern,https://root.cern/root/html534/TGeoMaterial.html,1,['Release'],['Release']
Deployability,"user-defined extension to the material. The material ""grabs"" a copy, so; the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for user extensions and is guaranteed not; to be used by TGeo. void SetFWExtension(TGeoExtension* ext); Connect framework defined extension to the material. The material ""grabs"" a copy,; so the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for the use by TGeo and the users should; NOT connect extensions using this method. TGeoExtension * GrabUserExtension() const; Get a copy of the user extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). TGeoExtension * GrabFWExtension() const; Get a copy of the framework extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). char * GetPointerName() const; Provide a pointer name containing uid. void SetRadLen(Double_t radlen, Double_t intlen = 0.); Set radiation/absorbtion lengths. If the values are negative, their absolute value; is taken, otherwise radlen is recomputed using G3 formula. Double_t Coulomb(Double_t z); static function; Compute Coulomb correction for pair production and Brem; REFERENCE : EGS MANUAL SLAC 210 - UC32 - JUNE 78; FORMULA 2.7.17. Bool_t IsEq(const TGeoMaterial* other) const; return true if the other material has the same physical properties. void Print(const Option_t* option = """") const; print characteristics of this material. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". Int_t GetDefaultColor() const; Get some default color related to this material. TGeoElement * GetElement(Int_t i = 0) const; Get a pointer to the element this material is m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoMaterial.html:11400,Release,Release,11400,root/html602/TGeoMaterial.html,https://root.cern,https://root.cern/root/html602/TGeoMaterial.html,2,['Release'],['Release']
Deployability,"ush origin vX-YY-ZZ. Tag ROOTTEST repository. Artifacts. Produce binary tarfiles. start the procedure root-release-6.20 (or whichever branch) in Jenkins; tarfiles and other artifacts are copied to final destination. Install binaries to CVMFS. Install release binaries to CVMFS with the Jenkins procedure root-release-CVMFS. Documentation. Update the release pages. Generate the release notes with the Jenkins procedure called root-releasenotes; Update the releases xml with the Jenkins procedure called root-release-makeReleasesXml; Once authenticated, import the releases xml in the site clicking import here (Be reminded: this works for authenticated users only!).; Eventually edit the 'highlights' section, which is currently commented, in the generated release page.; If this applies, mark the release as Pro or Old and remove the attribute to the one previously holding it. There are radio buttons exposed by Drupal when editing a release's page.; If not a patch release edit reference-guide page to add the new reference guide for the release. Announcements. send mail to the following mailing lists: root-planning@cern.ch, root-dev@cern.ch, roottalk@cern.ch, root-godparents@cern.ch, root-ambassadors@cern.ch; write announcement in RootTalk forum news. Quick Links; Jenkins Service; Jenkins How To; CDash; Coverity; Github; GitWeb; LXR; Jira; Conventions Violations; ROOT Logos; Upgrade of ROOTbinder. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxyge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/release-checklist.html:4274,patch,patch,4274,d/release-checklist.html,https://root.cern,https://root.cern/d/release-checklist.html,3,"['patch', 'release']","['patch', 'release']"
Deployability,"using Monte Carlo. ; In the main algorithm, new points in the parameter space are proposed and then visited based on their relative likelihoods. This class can use any implementation of the ProposalFunction, including non-symmetric proposal functions, to propose parameter points and still maintain detailed balance when constructing the chain.; The ""Likelihood"" function that is sampled when deciding what steps to take in the chain has been given a very generic implementation. The user can create any RooAbsReal based on the parameters and pass it to a MetropolisHastings object with the method SetFunction(RooAbsReal&). Be sure to tell MetropolisHastings whether your RooAbsReal is on a (+/-) regular or log scale, so that it knows what logic to use when sampling your RooAbsReal. For example, a common use is to sample from a -log(Likelihood) distribution (NLL), for which the appropriate configuration calls are SetType(MetropolisHastings::kLog); SetSign(MetropolisHastings::kNegative); If you're using a traditional likelihood function: SetType(MetropolisHastings::kRegular); SetSign(MetropolisHastings::kPositive); You must set these type and sign flags or MetropolisHastings will not construct a MarkovChain.; Also note that in ConstructChain(), the values of the variables are randomized uniformly over their intervals before construction of the MarkovChain begins. ; Definition at line 24 of file MetropolisHastings.h. Public Types; enum  FunctionSign { kNegative; , kPositive; , kSignUnset; };  ; enum  FunctionType { kRegular; , kLog; , kTypeUnset; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1MetropolisHastings.html:1363,configurat,configuration,1363,doc/master/classRooStats_1_1MetropolisHastings.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1MetropolisHastings.html,1,['configurat'],['configuration']
Deployability,"usly defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:8804,integrat,integration,8804,root/html534/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html,6,['integrat'],['integration']
Deployability,"ussian(const char *name, const char *title,					 const RooArgList& xvec, const TVectorD& mu, const TMatrixDSym& cov). RooMultiVarGaussian(const char *name, const char *title,					 const RooArgList& xvec, const TMatrixDSym& cov). RooMultiVarGaussian(const RooMultiVarGaussian& other, const char* name = 0). void syncMuVec() const. Double_t evaluate() const; Represent observables as vector. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Analytical integral known over all observables. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Handle full integral here. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Special case: generate all observables. void initGenerator(Int_t code); Clear the GenData cache as its content is not invariant under changes in; the mu vector. void generateEvent(Int_t code); Retrieve generator config from cache. void decodeCode(Int_t code, vector<int>& map1, vector<int>& map2) const; Decode analytical integration/generation code into index map of integrated/generated (map2); and non-integrated/generated observables (map1). void blockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); Block decomposition of covI according to given maps of observables. RooMultiVarGaussian(); {}. void setAnaIntZ(Double_t z); { _z = z ; }. TObject* clone(const char* newname) const; { return new RooMultiVarGaussian(*this,newname); }. virtual ~RooMultiVarGaussian(); { }. const TMatrixDSym& covarianceMatrix() const; { return _cov ; }. AnaIntData& anaIntData(Int_t code) const. GenData& genData(Int_t code) const. » Last changed: Mon Dec 7 13:48:21 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMultiVarGaussian.html:41614,integrat,integration,41614,root/html526/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html526/RooMultiVarGaussian.html,3,['integrat'],"['integrated', 'integration']"
Deployability,"ust be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UpdateFormulaLeaves(); this function is called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. TTreePlayer(const TTreePlayer& ). TTreePlayer& operator=(const TTreePlayer& ). void TakeAction(Int_t nfill, Int_t& npoints, Int_t& action, TObject* obj, Option_t* option). void TakeEstimate(Int_t nfill, Int_t& npoints, Int_t action, TObject* obj, Option_t* option). Int_t GetDimension() const; {return fDimension;}. TH1 * GetHistogram() const; {return fHistogram;}. Int_t GetNfill() const; {return fSelector->GetNfill();}. const char * GetScanFileName() const; {return fScanFileName;}. TTreeFormula * GetSelect() const; {return fSelector->GetSelect();}. Long64_t GetSelectedRows() const; {return fSelectedRows;}. TSelector * GetSelector() const; {return fSelector;}. TSelector * GetSelectorFromFile() const; See TSelectorDraw::GetVar. {return fSelectorFromFile;}. TTreeFormula * GetVar(Int_t i) const; See ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreePlayer.html:32141,Update,UpdateFormulaLeaves,32141,root/html532/TTreePlayer.html,https://root.cern,https://root.cern/root/html532/TTreePlayer.html,4,['Update'],['UpdateFormulaLeaves']
Deployability,"ust be specified with the above syntax.Lines in the input file starting with “#” are ignored. A TBranch object is created for each variable in the expression. The total number of rows read from the file is returned.; 12.19 Trees in Analysis; The methods TTree::Draw, TTree::MakeClass and TTree::MakeSelector are available for data analysis using trees. The TTree::Draw method is a powerful yet simple way to look and draw the trees contents. It enables you to plot a variable (a leaf) with just one line of code. However, the Draw method falls short once you want to look at each entry and design more sophisticated acceptance criteria for your analysis. For these cases, you can use TTree::MakeClass. It creates a class that loops over the trees entries one by one. You can then expand it to do the logic of your analysis.; The TTree::MakeSelector is the recommended method for ROOT data analysis. It is especially important for large data set in a parallel processing configuration where the analysis is distributed over several processors and you can specify which entries to send to each processor. With MakeClass the user has control over the event loop, with MakeSelectorthe tree is in control of the event loop.; 12.20 Simple Analysis Using TTree::Draw; We will use the tree in cernstaff.root that was made by the macro in $ROOTSYS/tutorials/tree/staff.C.; First, open the file and lists its contents.; root[] TFile f (""cernstaff.root""); root[] f.ls(); TFile** cernstaff.root; TFile* cernstaff.root; KEY: TTree T;1 staff data from ascii file; We can see the TTree“T” in the file. We will use it to experiment with the TTree::Draw method, so let’s create a pointer to it:; root[] TTree *MyTree = T; Cling allows us to get simply the object by using it. Here we define a pointer to a TTree object and assign it the value of “T”, the TTree in the file. Cling looks for an object named “T” in the current ROOT file and returns it (this assumes that “T” has not previously been used to declare a va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:584616,configurat,configuration,584616,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['configurat'],['configuration']
Deployability,"ut = 128 , Width = 128 ) Output = ( 1 , 100 , 128 ) Activation Function = Tanh Dropout prob. = 0.5; Layer 3 DENSE Layer: ( Input = 128 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity Dropout prob. = 0.5; : Using 1600 events for training and 400 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.01 regularization 0 minimum error = 0.699892; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.548477 0.466013 0.191275 0.014698 9061.23 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.431501 0.379356 0.191981 0.0145985 9020.06 0; : 3 | 0.40241 0.379482 0.19151 0.014162 9021.8 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.408996 0.379041 0.192713 0.0146534 8985.76 0; : 5 | 0.41143 0.414316 0.191728 0.014237 9014.55 1; : 6 | 0.385066 0.478603 0.19226 0.0142608 8988.82 2; : 7 | 0.404168 0.388159 0.192259 0.0142353 8987.58 3; : 8 Minimum Test error found - save the configuration ; : 8 | 0.394387 0.377539 0.19273 0.0147168 8988.1 0; : 9 Minimum Test error found - save the configuration ; : 9 | 0.386834 0.375541 0.192946 0.014741 8978.44 0; : 10 | 0.381359 0.385778 0.195351 0.0142527 8835 1; : 11 | 0.391916 0.415129 0.193961 0.0143386 8907.56 2; : 12 | 0.390755 0.379468 0.194376 0.0145555 8897.75 3; : 13 | 0.409355 0.396515 0.195082 0.0144231 8856.49 4; : 14 | 0.400917 0.375809 0.194321 0.0142902 8887.36 5; : 15 | 0.384495 0.401588 0.194138 0.0144019 8901.96 6; : 16 | 0.400658 0.401489 0.198047 0.014311 8708.13 7; : 17 Minimum Test error found - save the configuration ; : 17 | 0.386851 0.371455 0.194859 0.0148291 8887.42 0; : 18 | 0.389253 0.376491 0.196282 0.0143574 8794.87",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:47688,configurat,configuration,47688,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['configurat'],['configuration']
Deployability,"ut = 7 , Width = 64 ) Output = ( 1 , 128 , 64 ) Activation Function = Tanh; Layer 1 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 128 , 64 ) Activation Function = Tanh; Layer 2 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 128 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 128 , 64 ) Activation Function = Tanh; Layer 4 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 128 , 1 ) Activation Function = Identity; : Using 11200 events for training and 2800 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.868652; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.659892 0.620582 0.589558 0.0469541 20523.3 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.604286 0.594787 0.586926 0.0471912 20632.4 0; : 3 | 0.58117 0.603906 0.587335 0.047007 20609.7 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.57382 0.588714 0.592175 0.0469679 20425.3 0; : 5 | 0.569519 0.59535 0.590168 0.0468081 20494.7 1; : 6 | 0.567869 0.590023 0.589038 0.0469022 20541 2; : 7 Minimum Test error found - save the configuration ; : 7 | 0.561012 0.586993 0.590467 0.0471223 20495.3 0; : 8 | 0.559195 0.590522 0.590271 0.0471869 20505.1 1; : 9 | 0.558998 0.588766 0.598449 0.0469787 20193.3 2; : 10 | 0.555383 0.590075 0.591595 0.0470733 20451 3; : 11 Minimum Test error found - save the configuration ; : 11 | 0.555591 0.582449 0.595129 0.047292 20327.2 0; : 12 Minimum Test error found - save the configuration ; : 12 | 0.550993 0.581236 0.592181 0.0472746 20436.5 0; : 13 | 0.548186 0.58351 0.592876 0.0471057 20404.2 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:24284,configurat,configuration,24284,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['configurat'],['configuration']
Deployability,"ut limits. In other cases (which should be more common, since otherwise you wouldn’t need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless. On the other hand, the \(\mbox{MINOS}\) analysis is still meaningful, at least in principle, as long as \(\mbox{MIGRAD}\) (which is called internally by \(\mbox{MINOS}\)) does not get blocked at a limit. Unfortunately, the user has no control over this aspect of the \(\mbox{MINOS}\) calculation, although it is possible to get enough printout from the \(\mbox{MINOS}\) result to be able to determine whether the results are reliable or not.; 6.4 Fixing and releasing parameters; When M needs to be guided to the “right” minimum, often the best way to do this is with the methods e.g. MnMigrad::fix(…) and MnMigrad::release(…). That is, suppose you have a problem with ten free parameters, and when you minimize with respect to all at once, M goes to an unphysical solution characterized by an unphysical or unwanted value of parameter number four. One way to avoid this is to fix parameter four at a “good” value (not necessarily the best, since you presumably don’t know that yet), and minimize with respect to the others. Then release parameter four and minimize again. If the problem admits a “good” physical solution, you will normally find it this way. If it doesn’t work, you may see what is wrong by the following sequence (where \(\mbox{xxx}\) is the expected physical value for parameter four):; MnMigrad migrad(...);; migrad.setValue(4, xxx);; migrad.fix(4);; FunctionMinimum min = migrad();; migrad.release(4);; MnScan scan(...);; std::vector<std::pair<double, double> > points = scan(4);; where \(\mbox{SCAN}\) gives you a picture of \(\mbox{FCN}\) as a function of parameter four alone, the o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:71741,release,release,71741,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,4,['release'],['release']
Deployability,"ut of all interpreter frames.; 9612 // Here we are entering one, so ++.; 9613 ++fInitialMutex.fRecurseCount;; 9614}; 9615 ; 9616////////////////////////////////////////////////////////////////////////////////; 9617 ; 9618void TCling::ForgetMutexState(); 9619{; 9620 if (!fInitialMutex); 9621 return;; 9622 if (fInitialMutex.fRecurseCount == 0) {; 9623 Error(""ForgetMutexState"", ""mutex state's recurse count already 0!"");; 9624 }; 9625 else if (--fInitialMutex.fRecurseCount == 0) {; 9626 // We have returned from all interpreter frames. Reset the initial lock state.; 9627 fInitialMutex.fState.reset();; 9628 }; 9629}; 9630 ; 9631////////////////////////////////////////////////////////////////////////////////; 9632/// Re-apply the lock count delta that TCling__ResetInterpreterMutex() caused.; 9633 ; 9634void TCling::ApplyToInterpreterMutex(void *delta); 9635{; 9636 if (gInterpreterMutex) {; 9637 if (delta) {; 9638 auto typedDelta = static_cast<MutexStateAndRecurseCountDelta *>(delta);; 9639 std::unique_ptr<MutexStateAndRecurseCountDelta> uniqueP{typedDelta};; 9640 gCoreMutex->Apply(std::move(typedDelta->fDelta));; 9641 // Now that we have the lock, update the global; 9642 R__ASSERT(fInitialMutex.fRecurseCount == 0 && ""Inconsistent state of fInitialMutex! Another thread within Interpreter critical section."");; 9643 std::swap(fInitialMutex, typedDelta->fInitialState);; 9644 } else {; 9645 // This case happens when EnableThreadSafety is first called from; 9646 // the interpreter function we just handled.; 9647 // Since thread safety was not enabled at the time we rewound, there was; 9648 // no lock taken and even-though we should be locking the rest of this; 9649 // interpreter handling/modifying code (since there might be threads in; 9650 // flight), we can't because there would not be any lock guard to release the; 9651 // locks; 9652 if (fInitialMutex || fInitialMutex.fRecurseCount !=0); 9653 Error(""ApplyToInterpreterMutex"",; 9654 ""After returning from user code that turned ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:372541,update,update,372541,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['update'],['update']
Deployability,"ut visual parameters for this object.; This is a virtual function and all sub-classes are required to; first call the base-element version.; The name of the element pointer is 'x%03d', due to cint limitations.; Three spaces should be used for indentation, same as in; SavePrimitive() methods. void VizDB_Apply(const char* tag); Set visual parameters for this object for given tag. void VizDB_Reapply(); Reset visual parameters for this object from VizDB.; The model object must be already set. void VizDB_UpdateModel(Bool_t update = kTRUE); Copy visual parameters from this element to viz-db model.; If update is set, all clients of the model will be updated to; the new value.; A warning is printed if the model-element fVizModel is not set. void VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE); Create a replica of element and insert it into VizDB with given tag.; If replace is true an existing element with the same tag will be replaced.; If update is true, existing client of tag will be updated. TEveElement* GetMaster(); Returns the master element - that is:; - master of projectable, if this is a projected;; - master of compound, if fCompound is set;; - master of first compound parent, if kSCBTakeAnyParentAsMaster bit is set;; If non of the above is true, *this* is returned. void AddParent(TEveElement* re); Add re into the list parents.; Adding parent is subordinate to adding an element.; This is an internal function. void RemoveParent(TEveElement* re); Remove re from the list of parents.; Removing parent is subordinate to removing an element.; This is an internal function. void CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); Check external references to this and eventually auto-destruct; the render-element. void CollectSceneParents(TEveElement::List_t& scenes); Collect all parents of class TEveScene. This is needed to; automatically detect which scenes need to be updated. Overriden in TEveScene to include itse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveElement.html:16762,update,update,16762,root/html528/TEveElement.html,https://root.cern,https://root.cern/root/html528/TEveElement.html,20,['update'],"['update', 'updated']"
Deployability,"ut, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidSavePrimitive(ostream& out, Option_t* option = """"); virtual voidTAttPad::SetAfile(Float_t afile); virtual voidTAttPad::SetAstat(Float_t astat); virtual voidTPad::SetAttFillPS(Color_t color, Style_t style); virtual voidTPad::SetAttLinePS(Color_t color, Style_t style, Width_t lwidth); virtual voidTPad::SetAttMarkerPS(Color_t color, Style_t style, Size_t msize); virtual voidTPad::SetAttTextPS(Int_t align, Float_t angle, Color_t color, Style_t font, Float_t tsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTPad::SetBorderMode(Short_t bordermode)MENU ; virtual voidTPad::SetBorderSize(Short_t bordersize)MENU ; virtual voidTAttPad::SetBottomMargin(Float_t bottommargin); virtual voidTPad::SetCanvas(TCanvas* c); virtual voidTPad::SetCanvasSize(UInt_t ww, UInt_t wh); virtual voidTPad::SetCopyGLDevice(Bool_t copy); virtual voidTPad::SetCrosshair(Int_t crhair = 1)TOGGLE ; virtual voidTPad::SetCursor(ECursor cursor); virtual voidTPad::SetDoubleBuffer(Int_t mode = 1); virtual voidTPad::SetDrawOption(Option_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidTPad::SetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); virtual voidTPad::SetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSlider.html:19192,TOGGLE,TOGGLE,19192,root/html532/TSlider.html,https://root.cern,https://root.cern/root/html532/TSlider.html,1,['TOGGLE'],['TOGGLE']
Deployability,"utHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGTextEditor(const char* filename = 0, const TGWindow* p = 0, UInt_t w = 900, UInt_t h = 600); TGTextEditor constructor with file name as first argument. TGTextEditor(TMacro* macro, const TGWindow* p = 0, UInt_t w = 0, UInt_t h = 0); TGTextEditor constructor with pointer to a TMacro as first argument. ~TGTextEditor(); TGTextEditor destructor. void DeleteWindow(); Delete TGTextEditor Window. void Build(); Build TGTextEditor widget. void DataDropped(char* fname); Update file information when receiving the signal; DataDropped from TGTextEdit widget. void LoadFile(const char* fname = 0); Load a file into the editor. If fname is 0, a TGFileDialog will popup. void SaveFile(const char* fname); Save the edited text in the file ""fname"". Bool_t SaveFileAs(); Save the edited text in a file selected with TGFileDialog.; Shouldn't we create a backup file?. Int_t IsSaved(); Check if file has to be saved in case of modifications. void PrintText(); Open the print dialog and send current buffer to printer. void CloseWindow(); Close TGTextEditor window. Bool_t HandleKey(Event_t* event); Keyboard event handler. void ClearText(); Clear text edit widget. void Search(Bool_t ret); Invokes search dialog, or just search previous string if again is true. void Goto(); Invokes goto dialog, and go to the specified line. void CompileMacro(); Save the edited text in a temporary macro, then compile it. void ExecuteMacro(); Save the edited text in a temporary macro, execute it, and then delete; the tem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGTextEditor.html:27647,Update,Update,27647,root/html534/TGTextEditor.html,https://root.cern,https://root.cern/root/html534/TGTextEditor.html,1,['Update'],['Update']
Deployability,"utHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGTextEditor(const char* filename = 0, const TGWindow* p = 0, UInt_t w = 900, UInt_t h = 600); TGTextEditor constructor with file name as first argument. TGTextEditor(TMacro* macro, const TGWindow* p = 0, UInt_t w = 0, UInt_t h = 0); TGTextEditor constructor with pointer to a TMacro as first argument. ~TGTextEditor(); TGTextEditor destructor. void DeleteWindow(); Delete TGTextEditor Window. void Build(); Build TGTextEditor widget. void DataDropped(char* fname); Update file informations when receiving the signal; DataDropped from TGTextEdit widget. void LoadFile(char* fname = 0); Load a file into the editor. If fname is 0, a TGFileDialog will popup. void SaveFile(const char* fname); Save the edited text in the file ""fname"". Bool_t SaveFileAs(); Save the edited text in a file selected with TGFileDialog.; Shouldn't we create a backup file?. Int_t IsSaved(); Check if file has to be saved in case of modifications. void PrintText(); Open the print dialog and send current buffer to printer. void CloseWindow(); Close TGTextEditor window. Bool_t HandleKey(Event_t* event); Keyboard event handler. void ClearText(); Clear text edit widget. void Search(Bool_t ret); Invokes search dialog, or just search previous string if again is true. void Goto(); Invokes goto dialog, and go to the specified line. void CompileMacro(); Save the edited text in a temporary macro, then compile it. void ExecuteMacro(); Save the edited text in a temporary macro, execute it, and then delete; the temporary",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGTextEditor.html:27622,Update,Update,27622,root/html532/TGTextEditor.html,https://root.cern,https://root.cern/root/html532/TGTextEditor.html,1,['Update'],['Update']
Deployability,"ute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library. * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function. * GSLDerivator of MathMore based on GSL.; 13.10 Numerical Minimization; The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:712858,integrat,integration,712858,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,['integrat'],['integration']
Deployability,"uted in pixels units.; In case of a filled ellipse the distance returned is 0 if the point (px,py) is inside the ellipse, and is huge if the point is outside. ; Reimplemented from TObject.; Definition at line 133 of file TEllipse.cxx. ◆ Draw(). void TEllipse::Draw ; (; Option_t * ; option = """"). overridevirtual . Draw this ellipse with its current attributes. ; Reimplemented from TObject.; Definition at line 169 of file TEllipse.cxx. ◆ DrawEllipse(). TEllipse * TEllipse::DrawEllipse ; (; Double_t ; x1, . Double_t ; y1, . Double_t ; r1, . Double_t ; r2, . Double_t ; phimin, . Double_t ; phimax, . Double_t ; theta, . Option_t * ; option = """" . ). virtual . Draw this ellipse with new coordinates. ; Definition at line 177 of file TEllipse.cxx. ◆ ExecuteEvent(). void TEllipse::ExecuteEvent ; (; Int_t ; event, . Int_t ; px, . Int_t ; py . ). overridevirtual . Execute action corresponding to one event. ; This member function is called when a line is clicked with the locator; If Left button clicked on one of the line end points, this point follows the cursor until button is released.; if Middle button clicked, the line is moved parallel to itself until the button is released.; NOTE that support for log scale is not implemented ; Reimplemented from TObject.; Definition at line 201 of file TEllipse.cxx. ◆ GetBBox(). Rectangle_t TEllipse::GetBBox ; (; ). overridevirtual . Return the bounding Box of the Ellipse, currently not taking into account the rotating angle. ; Implements TAttBBox2D.; Definition at line 698 of file TEllipse.cxx. ◆ GetBBoxCenter(). TPoint TEllipse::GetBBoxCenter ; (; ). overridevirtual . Return the center of the Ellipse as TPoint in pixels. ; Implements TAttBBox2D.; Definition at line 713 of file TEllipse.cxx. ◆ GetNoEdges(). Bool_t TEllipse::GetNoEdges ; (; ); const. Return kTRUE if kNoEdges bit is set, kFALSE otherwise. ; Definition at line 646 of file TEllipse.cxx. ◆ GetPhimax(). Double_t TEllipse::GetPhimax ; (; ); const. inline . Definition at line 54",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEllipse.html:21288,release,released,21288,doc/master/classTEllipse.html,https://root.cern,https://root.cern/doc/master/classTEllipse.html,1,['release'],['released']
Deployability,"utes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_compCIter! do not persist; RooListProxy_compCSet; TIterator*_compRIter! do not persist; RooListProxy_compRSet; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProduct.html:33650,integrat,integration,33650,root/html534/RooProduct.html,https://root.cern,https://root.cern/root/html534/RooProduct.html,2,['integrat'],['integration']
Deployability,"utine; 3661 RecalculateRange();; 3662 }; 3663 if (opaque && dimension ==2) {; 3664 if (zoombox) {; 3665 Double_t x1 = TMath::Min(zoombox->GetX1(), zoombox->GetX2());; 3666 Double_t x2 = TMath::Max(zoombox->GetX1(), zoombox->GetX2());; 3667 Double_t y1 = TMath::Min(zoombox->GetY1(), zoombox->GetY2());; 3668 Double_t y2 = TMath::Max(zoombox->GetY1(), zoombox->GetY2());; 3669 x1 = TMath::Max(x1,xaxis->GetXmin());; 3670 x2 = TMath::Min(x2,xaxis->GetXmax());; 3671 y1 = TMath::Max(y1,yaxis->GetXmin());; 3672 y2 = TMath::Min(y2,yaxis->GetXmax());; 3673 if (x1<x2 && y1<y2) {; 3674 xaxis->SetRangeUser(x1, x2);; 3675 yaxis->SetRangeUser(y1, y2);; 3676 }; 3677 zoombox.reset();; 3678 }; 3679 }; 3680 gPad->Modified(kTRUE);; 3681 if (opaque) gVirtualX->SetLineColor(-1);; 3682 ; 3683 break;; 3684 ; 3685 case kButton1Locate:; 3686 ; 3687 ExecuteEvent(kButton1Down, px, py);; 3688 ; 3689 while (true) {; 3690 px = py = 0;; 3691 event = gVirtualX->RequestLocator(1, 1, px, py);; 3692 ; 3693 ExecuteEvent(kButton1Motion, px, py);; 3694 ; 3695 if (event != -1) { // button is released; 3696 ExecuteEvent(kButton1Up, px, py);; 3697 return;; 3698 }; 3699 }; 3700 }; 3701}; 3702 ; 3703////////////////////////////////////////////////////////////////////////////////; 3704/// Get a contour (as a list of TGraphs) using the Delaunay triangulation.; 3705 ; 3706TList *THistPainter::GetContourList(Double_t contour) const; 3707{; 3708 // Check if fH contains a TGraphDelaunay2D; 3709 TList *hl = fH->GetListOfFunctions();; 3710 TGraphDelaunay2D *dt = (TGraphDelaunay2D*)hl->FindObject(""TGraphDelaunay2D"");; 3711 // try with the old painter; 3712 TGraphDelaunay *dtOld = nullptr;; 3713 if (!dt) dtOld = (TGraphDelaunay*)hl->FindObject(""TGraphDelaunay"");; 3714 ; 3715 if (!dt && !dtOld) return nullptr;; 3716 ; 3717 gCurrentHist = fH;; 3718 ; 3719 if (!fGraph2DPainter); 3720 ((THistPainter*)this)->fGraph2DPainter = dt ? std::make_unique<TGraph2DPainter>(dt) : std::make_unique<TGraph2DPainter>(dtOld);; 3721 ; 3722 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:143810,release,released,143810,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['release'],['released']
Deployability,"ution. ;  ; bool Init (const TUnuranDiscrDist &distr, const std::string &method=""auto"");  Initialize method for continuous one-dimensional discrete distribution. ;  ; bool Init (const TUnuranEmpDist &distr, const std::string &method=""empk"");  Initialize method for continuous empirical distribution. ;  ; bool Init (const TUnuranMultiContDist &distr, const std::string &method=""vnrou"");  Initialize method for continuous multi-dimensional distribution. ;  ; bool InitBinomial (unsigned int ntot, double prob, const std::string &method=""dstd"");  Initialize method for the Binomial distribution. ;  ; bool InitPoisson (double mu, const std::string &method=""dstd"");  Initialize method for the Poisson distribution. ;  ; bool IsDistCont () const;  Return true for a univariate continuous distribution. ;  ; bool IsDistDiscrete () const;  Return true for a discrete distribution. ;  ; bool IsDistEmpirical () const;  Return true for an empirical distribution. ;  ; bool IsDistMultiCont () const;  Return true for a multivariate continuous distribution. ;  ; const std::string & MethodName () const;  used Unuran method ;  ; TUnuran & operator= (const TUnuran &rhs)=delete;  ; TUnuran & operator= (TUnuran &&rhs)=delete;  ; bool ReInitDiscrDist (unsigned int npar, double *params);  Reinitialize UNURAN by changing the distribution parameters but maintaining same distribution and method. ;  ; double Sample ();  Sample 1D distribution. ;  ; int SampleDiscr ();  Sample discrete distributions. ;  ; bool SampleMulti (double *x);  Sample multidimensional distributions. ;  ; bool SetLogLevel (unsigned int iflag=1);  set log level ;  ; bool SetLogStream ();  set stream for log and error (not yet implemented) ;  ; void SetRandom (TRandom *r);  Set the random engine. ;  ; void SetSeed (unsigned int seed);  set the seed for the random number generator ;  . Protected Member Functions; bool SetContDistribution (const TUnuranContDist &dist);  ; bool SetDiscreteDistribution (const TUnuranDiscrDist &dist);  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnuran.html:3745,continuous,continuous,3745,doc/master/classTUnuran.html,https://root.cern,https://root.cern/doc/master/classTUnuran.html,1,['continuous'],['continuous']
Deployability,"uto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static Int_t _cacheAllNDim;  ! Cache all integrals with given numeric dimension ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions; void addNumIntDep (RooAbsArg const &arg);  Sort numeric integration variables in summation and integration lists. ;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:61094,integrat,integration,61094,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,2,['integrat'],['integration']
Deployability,"utoExec(). void TCanvas::ToggleAutoExec ; (; ). virtual . Toggle pad auto execution of list of TExecs. ; Definition at line 2409 of file TCanvas.cxx. ◆ ToggleEditor(). void TCanvas::ToggleEditor ; (; ). virtual . Toggle editor. ; Definition at line 2440 of file TCanvas.cxx. ◆ ToggleEventStatus(). void TCanvas::ToggleEventStatus ; (; ). virtual . Toggle event statusbar. ; Definition at line 2418 of file TCanvas.cxx. ◆ ToggleToolBar(). void TCanvas::ToggleToolBar ; (; ). virtual . Toggle toolbar. ; Definition at line 2429 of file TCanvas.cxx. ◆ ToggleToolTips(). void TCanvas::ToggleToolTips ; (; ). virtual . Toggle tooltip display. ; Definition at line 2451 of file TCanvas.cxx. ◆ Update(). void TCanvas::Update ; (; ). overridevirtual . Update canvas pad buffers. ; Implements TVirtualPad.; Definition at line 2476 of file TCanvas.cxx. ◆ UpdateAsync(). void TCanvas::UpdateAsync ; (; ). overridevirtual . Asynchronous pad update. ; In case of web-based canvas triggers update of the canvas on the client side, but does not wait that real update is completed. Avoids blocking of caller thread. Have to be used if called from other web-based widget to avoid logical dead-locks. In case of normal canvas just canvas->Update() is performed. ; Implements TVirtualPad.; Definition at line 2532 of file TCanvas.cxx. ◆ UseCurrentStyle(). void TCanvas::UseCurrentStyle ; (; ). overridevirtual . Force a copy of current style for all objects in canvas. ; Reimplemented from TObject.; Definition at line 1183 of file TCanvas.cxx. ◆ UseGL(). Bool_t TCanvas::UseGL ; (; ); const. inline . Definition at line 228 of file TCanvas.h. Friends And Related Symbol Documentation. ◆ TCanvasImp. friend class TCanvasImp. friend . Definition at line 25 of file TCanvas.h. ◆ TInterpreter. friend class TInterpreter. friend . Definition at line 28 of file TCanvas.h. ◆ TThread. friend class TThread. friend . Definition at line 27 of file TCanvas.h. ◆ TWebCanvas. friend class TWebCanvas. friend . Definition at line 26",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCanvas.html:93260,update,update,93260,doc/v632/classTCanvas.html,https://root.cern,https://root.cern/doc/v632/classTCanvas.html,2,['update'],['update']
Deployability,"utoExec(). void TCanvas::ToggleAutoExec ; (; ). virtual . Toggle pad auto execution of list of TExecs. ; Definition at line 2422 of file TCanvas.cxx. ◆ ToggleEditor(). void TCanvas::ToggleEditor ; (; ). virtual . Toggle editor. ; Definition at line 2453 of file TCanvas.cxx. ◆ ToggleEventStatus(). void TCanvas::ToggleEventStatus ; (; ). virtual . Toggle event statusbar. ; Definition at line 2431 of file TCanvas.cxx. ◆ ToggleToolBar(). void TCanvas::ToggleToolBar ; (; ). virtual . Toggle toolbar. ; Definition at line 2442 of file TCanvas.cxx. ◆ ToggleToolTips(). void TCanvas::ToggleToolTips ; (; ). virtual . Toggle tooltip display. ; Definition at line 2464 of file TCanvas.cxx. ◆ Update(). void TCanvas::Update ; (; ). overridevirtual . Update canvas pad buffers. ; Implements TVirtualPad.; Definition at line 2489 of file TCanvas.cxx. ◆ UpdateAsync(). void TCanvas::UpdateAsync ; (; ). overridevirtual . Asynchronous pad update. ; In case of web-based canvas triggers update of the canvas on the client side, but does not wait that real update is completed. Avoids blocking of caller thread. Have to be used if called from other web-based widget to avoid logical dead-locks. In case of normal canvas just canvas->Update() is performed. ; Implements TVirtualPad.; Definition at line 2545 of file TCanvas.cxx. ◆ UseCurrentStyle(). void TCanvas::UseCurrentStyle ; (; ). overridevirtual . Force a copy of current style for all objects in canvas. ; Reimplemented from TObject.; Definition at line 1185 of file TCanvas.cxx. ◆ UseGL(). Bool_t TCanvas::UseGL ; (; ); const. inline . Definition at line 228 of file TCanvas.h. Friends And Related Symbol Documentation. ◆ TCanvasImp. friend class TCanvasImp. friend . Definition at line 25 of file TCanvas.h. ◆ TInterpreter. friend class TInterpreter. friend . Definition at line 28 of file TCanvas.h. ◆ TThread. friend class TThread. friend . Definition at line 27 of file TCanvas.h. ◆ TWebCanvas. friend class TWebCanvas. friend . Definition at line 26",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCanvas.html:93705,update,update,93705,doc/master/classTCanvas.html,https://root.cern,https://root.cern/doc/master/classTCanvas.html,2,['update'],['update']
Deployability,"utor p1; // will use 2 threads; ROOT::TThreadExecutor p2(/*nThreads=*/8); // will still use 2 threads; Note that the preferred way to steer ROOT’s concurrency level is still through ROOT::EnableImplicitMT or by passing the appropriate parameter to executors’ constructors, as in TThreadExecutor::TThreadExecutor.; See the discussion at ROOT-11014 for more context.; Dynamic Path: ROOT_LIBRARY_PATH; A new way to set ROOT’s “Dynamic Path” was added: the environment variable ROOT_LIBRARY_PATH. On Unix it should contain a colon separated list of paths, on Windows a semicolon separated list. It is intended to be cross platform and to be specific to ROOT (and thus not interfere with the system’s shared linker). The final “Dynamic Path” is now composed of these sources in order:. ROOT_LIBRARY_PATH environment variable; System specific shared linker environment variables like LD_LIBRARY_PATH, LIBPATH, or PATH.; Setting from rootrc; ROOT’s builtin library directory. Interpreter. cling’s LLVM is upgraded to version 9.0; New interface to enable/disable optional cling features. Currently, it can be used to enable/disable support for redefinitions. See this issue for more information. Multithreading. Fix an uninitialized variable in global read-write lock which could have caused deadlocks or crashes in some rare cases.; Default global read-write lock transitioned to new implementation based on TBB thread local storage when TBB is available on supported platforms (all except Windows). This gives an O(10%) performance improvement for some typical RDataFrame scenarios with 256 threads due to reduced lock contention. I/O Libraries. Exclusive use of the global lock is reduced or migrated to finer grained read and write locks in a few hotspots that occur during file opening/closing or task initialization in RDataFrame. This can lead to O(100x) improvements for some typical RDataFrame scenarios with 256 threads due to massively reduced lock contention. TTree Libraries. TTree now supports t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:4827,upgrade,upgraded,4827,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['upgrade'],['upgraded']
Deployability,"utos = -300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidSetCacheSize(Long64_t cacheSize); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* elist, Option_t* opt = """"); virtual voidSetEntryListFile(const char* filename = """", Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidSetEventList(TEventList* evlist); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TChain.html:16646,update,updateExisting,16646,root/html534/TChain.html,https://root.cern,https://root.cern/root/html534/TChain.html,2,['update'],['updateExisting']
Deployability,"utput = ( 1 , 100 , 10 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 10 , Width = 4 ) Output = ( 1 , 100 , 4 ) Activation Function = Identity; : Using 3200 events for training and 800 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.691476; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.605916 0.542204 0.0761789 0.00657979 45977.6 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.512732 0.499825 0.0771995 0.00657724 45311.5 0; : 3 Minimum Test error found - save the configuration ; : 3 | 0.477495 0.458718 0.0776312 0.00665553 45085.9 0; : 4 Minimum Test error found - save the configuration ; : 4 | 0.438338 0.418147 0.0780597 0.00669006 44837 0; : 5 Minimum Test error found - save the configuration ; : 5 | 0.407569 0.391703 0.0786075 0.00678976 44557.2 0; : 6 Minimum Test error found - save the configuration ; : 6 | 0.387736 0.373696 0.0792581 0.00678916 44156.9 0; : 7 Minimum Test error found - save the configuration ; : 7 | 0.373399 0.360485 0.0791536 0.00677002 44208.9 0; : 8 Minimum Test error found - save the configuration ; : 8 | 0.362792 0.352336 0.0796639 0.00682572 43933 0; : 9 Minimum Test error found - save the configuration ; : 9 | 0.353594 0.340526 0.0805399 0.00700876 43519 0; : 10 Minimum Test error found - save the configuration ; : 10 | 0.345712 0.336826 0.080966 0.0069933 43259.2 0; : 11 Minimum Test error found - save the configuration ; : 11 | 0.338399 0.329567 0.0802544 0.00691181 43630.9 0; : 12 Minimum Test error found - save the configuration ; : 12 | 0.333122 0.322325 0.0804981 0.00689735 43477.8 0; : 13 Minimum Test error ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:15173,configurat,configuration,15173,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['configurat'],['configuration']
Deployability,"utputFilePrefix ();  retrieve prefix for output files ;  ; std::map< std::string, double > & GetParamValues ();  get map: parameter name <--> parameter value ;  ; std::string GetPOI (unsigned int i=0);  get name of PoI at given index ;  ; std::vector< std::string > & GetPOIList ();  get vector of PoI names ;  ; std::vector< std::string > GetPreprocessFunctions () const;  Returns a list of defined preprocess function expressions. ;  ; void SetBinHigh (int BinHigh);  ; void SetBinLow (int BinLow);  ; void SetExportOnly (bool ExportOnly) R__DEPRECATED(6;  Do not produce any plots or tables, just save the model. ;  ; void SetFunctionObjects (std::vector< RooStats::HistFactory::PreprocessFunction > objects);  ; void SetLumi (double Lumi);  set integrated luminosity used to normalise histograms (if NormalizeByTheory is true for this sample) ;  ; void SetLumiRelErr (double RelErr);  set relative uncertainty on luminosity ;  ; void SetOutputFilePrefix (const std::string &prefix);  set output prefix ;  ; void SetParamValue (const std::string &param, double value);  Set a parameter to a specific value (And optionally fix it) ;  ; void SetPOI (const std::string &POI);  insert PoI at beginning of vector of PoIs ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1Measurement.html:3026,integrat,integrated,3026,doc/master/classRooStats_1_1HistFactory_1_1Measurement.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1Measurement.html,1,['integrat'],['integrated']
Deployability,"utput ; itOutputBegin, . ItOutput ; itOutputEnd, . ItTruth ; itTruthBegin, . ItTruth ; , . ItDelta ; itDelta, . ItDelta ; itDeltaEnd, . InvFnc ; invFnc, . double ; patternWeight . ). sum of squares error function ; Definition at line 382 of file NeuralNet.icc. ◆ uniformDouble() [1/2]. template<typename Container , typename T > . void TMVA::DNN::uniformDouble ; (; Container & ; container, . T ; maxValue . ). Definition at line 42 of file NeuralNet.icc. ◆ uniformDouble() [2/2]. double TMVA::DNN::uniformDouble ; (; double ; minValue, . double ; maxValue . ). Definition at line 43 of file NeuralNet.cxx. ◆ uniformFromTo(). template<typename T > . T TMVA::DNN::uniformFromTo ; (; T ; from, . T ; to . ). Definition at line 34 of file NeuralNet.icc. ◆ update() [1/3]. template<typename LAYERDATA > . void TMVA::DNN::update ; (; const LAYERDATA & ; prevLayerData, . LAYERDATA & ; currLayerData, . double ; factorWeightDecay, . EnumRegularization ; regularization . ). update the node values ; Definition at line 600 of file NeuralNet.icc. ◆ update() [2/3]. template<typename ItSource , typename ItDelta , typename ItTargetGradient , typename ItGradient > . void TMVA::DNN::update ; (; ItSource ; itSource, . ItSource ; itSourceEnd, . ItDelta ; itTargetDeltaBegin, . ItDelta ; itTargetDeltaEnd, . ItTargetGradient ; itTargetGradientBegin, . ItGradient ; itGradient . ). update the gradients ; Definition at line 183 of file NeuralNet.icc. ◆ update() [3/3]. template<EnumRegularization Regularization, typename ItSource , typename ItDelta , typename ItTargetGradient , typename ItGradient , typename ItWeight > . void TMVA::DNN::update ; (; ItSource ; itSource, . ItSource ; itSourceEnd, . ItDelta ; itTargetDeltaBegin, . ItDelta ; itTargetDeltaEnd, . ItTargetGradient ; itTargetGradientBegin, . ItGradient ; itGradient, . ItWeight ; itWeight, . double ; weightDecay . ). update the gradients, using regularization ; Definition at line 237 of file NeuralNet.icc. ◆ weightDecay(). template<typename ItWei",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html:34521,update,update,34521,doc/master/namespaceTMVA_1_1DNN.html,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html,2,['update'],['update']
Deployability,"utton group to the frame f. TGComboBox * AddDateFormatEntry(TGCompositeFrame* f, Int_t id); Add a date format combo box to the frame f. TGCheckButton * AddCheckButton(TGCompositeFrame* f, const char* s, Int_t id, Int_t e1 = 0, Int_t e2 = 2); Add a check button to the frame f. TGTextEntry * AddTextEntry(TGCompositeFrame* f, const char* s, Int_t id); Add a text entry to the frame f. A caption can be added. TGComboBox * AddPaperSizeEntry(TGCompositeFrame* f, Int_t id); Add a prefered paper size combo box to the frame f. void DoMenu(Int_t menuID); Slot called when an item of the menu is selected. void DoImportMacro(Bool_t create); Slot called to import a style from a C++ macro file. If create=kTRUE,; a new style is created. Otherwise, the current style is reseted. void DoListSelect(); Slot called when the user select an item in the available styles' list.; Update the preview, the editor, the status bar. The current selected; style is changed. void DoRealTime(Bool_t b); Slot called when the user click on the run time update check button.; If b=kTRUE, the user asks for a real time preview. void DoPreview(Bool_t b); Slot called when the user click on the preview check button. If b=kTRUE,; the user asks for a preview, otherwise he wants to close it. void DoPreviewClosed(); Slot called to close the preview, via the preview check button, or; when the preview window is closed via the window manager. void DoMakeDefault(); Slot called to make the current selected style (in the ComboBox); become gStyle. void DoApplyOnSelect(Int_t i); Slot called to choose on which object(s) the 'Apply' button will; have an effect. void DoApplyOn(); Slot called when the user clicks on the 'Apply' button. Apply the; current selected style to the specified object(s). void DoMoreLess(); Slot called when the user try to show or hide the editor part of the; style manager. void DoEditionUpdatePreview(); Slot called when the user clicks on the 'Update preview' button. void DoChangeTab(Int_t i); Slot call",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyleManager.html:59921,update,update,59921,root/html528/TStyleManager.html,https://root.cern,https://root.cern/root/html528/TStyleManager.html,6,['update'],['update']
Deployability,"utton group to the frame f. TGComboBox * AddDateFormatEntry(TGCompositeFrame* f, Int_t id); Add a date format combo box to the frame f. TGCheckButton * AddCheckButton(TGCompositeFrame* f, const char* s, Int_t id, Int_t e1 = 0, Int_t e2 = 2); Add a check button to the frame f. TGTextEntry * AddTextEntry(TGCompositeFrame* f, const char* s, Int_t id); Add a text entry to the frame f. A caption can be added. TGComboBox * AddPaperSizeEntry(TGCompositeFrame* f, Int_t id); Add a prefered paper size combo box to the frame f. void DoMenu(Int_t menuID); Slot called when an item of the menu is selected. void DoImportMacro(Bool_t create); Slot called to import a style from a C++ macro file. If create=kTRUE,; a new style is created. Otherwise, the current style is reseted. void DoListSelect(); Slot called when the user select an item in the available styles' list.; Update the preview, the editor, the status bar. The current selected; style is changed. void DoRealTime(Bool_t b); Slot called when the user click on the run time update check button.; If b=kTRUE, the user asks for a real time preview. void DoPreview(Bool_t b); Slot called when the user click on the preview check button. If b=kTRUE,; the user asks for a preview, otherwise they want to close it. void DoPreviewClosed(); Slot called to close the preview, via the preview check button, or; when the preview window is closed via the window manager. void DoMakeDefault(); Slot called to make the current selected style (in the ComboBox); become gStyle. void DoApplyOnSelect(Int_t i); Slot called to choose on which object(s) the 'Apply' button will; have an effect. void DoApplyOn(); Slot called when the user clicks on the 'Apply' button. Apply the; current selected style to the specified object(s). void DoMoreLess(); Slot called when the user try to show or hide the editor part of the; style manager. void DoEditionUpdatePreview(); Slot called when the user clicks on the 'Update preview' button. void DoChangeTab(Int_t i); Slot cal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStyleManager.html:61061,update,update,61061,root/html602/TStyleManager.html,https://root.cern,https://root.cern/root/html602/TStyleManager.html,4,['update'],['update']
Deployability,"utton* button) const; Finds and returns the id of the button.; Returns -1 if the button is not a member of this group. void ButtonPressed(); This slot is activated when one of the buttons in the group emits the; Pressed() signal. void ButtonReleased(); This slot is activated when one of the buttons in the group emits the; Released() signal. void ButtonClicked(); This slot is activated when one of the buttons in the group emits the; Clicked() signal. void ReleaseButtons(); This slot is activated when one of the buttons in the; exclusive group emits the Pressed() signal. void Show(); Show group of buttons. void Hide(); Hide group of buttons. void SetTitle(TGString* title); Set or change title. void SetTitle(const char* title); Set or change title. void SetLayoutHints(TGLayoutHints* l, TGButton* button = 0); Set layout hints for the specified button or if button=0 for all; buttons. void SavePrimitive(ostream& out, Option_t* option = """"); Save a button group widget as a C++ statement(s) on output stream out. TGButtonGroup(const TGButtonGroup& ). TGButtonGroup& operator=(const TGButtonGroup& ). void Pressed(Int_t id); { Emit(""Pressed(Int_t)"",id); }. void Released(Int_t id); { Emit(""Released(Int_t)"",id);}. void Clicked(Int_t id); { Emit(""Clicked(Int_t)"",id); }. Bool_t IsEnabled() const; { return fState; }. Bool_t IsExclusive() const; { return fExclGroup; }. Bool_t IsRadioButtonExclusive() const; { return fRadioExcl; }. Bool_t IsBorderDrawn() const; { return fDrawBorder; }. Int_t GetCount() const; { return fMapOfButtons->GetSize(); }. TGButton * GetButton(Int_t id) const; { return Find(id); }. » Author: Valeriy Onuchin & Fons Rademakers 16/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGButtonGroup.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGButtonGroup.html:28053,Release,Released,28053,root/html532/TGButtonGroup.html,https://root.cern,https://root.cern/root/html532/TGButtonGroup.html,2,['Release'],['Released']
Deployability,"utton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGSlider(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t type = kSlider1 | kScaleBoth, Int_t id = -1, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Slider constructor. void CreateDisabledPicture(); Creates disabled picture. void SetState(Bool_t state); Set state of widget. If kTRUE=enabled, kFALSE=disabled. TString GetTypeString() const; Returns the slider type as a string - used in SavePrimitive(). TGSlider(const TGSlider& ). TGSlider& operator=(const TGSlider& ). virtual ~TGSlider(); { }. Bool_t HandleButton(Event_t* event). Bool_t HandleConfigureNotify(Event_t* event). Bool_t HandleMotion(Event_t* event). void SetEnabled(Bool_t flag = kTRUE); { SetState( flag ); }. void SetScale(Int_t scale); { fScale = scale; }. void SetRange(Int_t min, Int_t max); { fVmin = min; fVmax = max; }. void SetPosition(Int_t pos); { fPos = pos; fClient->NeedRedraw(this); }. Int_t GetPosition() const; { return fPos; }. Int_t GetMinPosition() const; { return fVmin; }. Int_t GetMaxPosition() const; { return fVmax; }. Int_t GetScale() const; { return fScale; }. void MapSubwindows(); { TGWindow::MapSubwindows(); }. void ChangeSliderPic(const char* name). void PositionChanged(Int_t pos); { Emit(""PositionChanged(Int_t)"", pos); }. void Pressed(); { Emit(""Pressed()""); }. void Released(); { Emit(""Released()""); }. » Author: Fons Rademakers 14/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 15:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGSlider.html:21526,Release,Released,21526,root/html604/TGSlider.html,https://root.cern,https://root.cern/root/html604/TGSlider.html,2,['Release'],['Released']
Deployability,"utton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGSlider(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t type = kSlider1 | kScaleBoth, Int_t id = -1, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Slider constructor. void CreateDisabledPicture(); Creates disabled picture. void SetState(Bool_t state); Set state of widget. If kTRUE=enabled, kFALSE=disabled. TString GetTypeString() const; Returns the slider type as a string - used in SavePrimitive(). TGSlider(const TGSlider& ). TGSlider& operator=(const TGSlider& ). virtual ~TGSlider(); { }. Bool_t HandleButton(Event_t* event). Bool_t HandleConfigureNotify(Event_t* event). Bool_t HandleMotion(Event_t* event). void SetEnabled(Bool_t flag = kTRUE); { SetState( flag ); }. void SetScale(Int_t scale); { fScale = scale; }. void SetRange(Int_t min, Int_t max); { fVmin = min; fVmax = max; }. void SetPosition(Int_t pos); { fPos = pos; fClient->NeedRedraw(this); }. Int_t GetPosition() const; { return fPos; }. Int_t GetMinPosition() const; { return fVmin; }. Int_t GetMaxPosition() const; { return fVmax; }. Int_t GetScale() const; { return fScale; }. void MapSubwindows(); { TGWindow::MapSubwindows(); }. void ChangeSliderPic(const char* name). void PositionChanged(Int_t pos); { Emit(""PositionChanged(Int_t)"", pos); }. void Pressed(); { Emit(""Pressed()""); }. void Released(); { Emit(""Released()""); }. » Author: Fons Rademakers 14/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGSlider.html:21526,Release,Released,21526,root/html602/TGSlider.html,https://root.cern,https://root.cern/root/html602/TGSlider.html,2,['Release'],['Released']
Deployability,"v/www/htdocs” is root directory for web server. Than one should be able to open address:; http://apache_host_name/root.app/; 1.5.2 Configure fastcgi with lighttpd; An example of configuration file for lighttpd server is:; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); Be aware, that with lighttpd one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following:; http://lighttpd_host_name/root.app/; 1.6 Integration with existing applications; In many practical cases no change of existing code is required. Opened files (and all objects inside), existing canvas and histograms are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a THttpServer::Register() call.; Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the gSystem->ProcessEvents() call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session.; If an application runs in compiled code and does not contain gSystem->ProcessEvents() calls, two method are available.; 1.6.1 Asynchronous timer; The first method is to configure an asynchronous timer for the server, like for example:; serv->SetTimer(100, kFALSE);; Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of TH1::Fill() calls and an histogram object may be incomplete. Therefore such method is not recommended.; 1.6.2 Regular calls of THttpServer::ProcessRequests() metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:7885,integrat,integration,7885,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,2,['integrat'],['integration']
Deployability,"vNode ; (; void ; ); const. inline . previous sister node ; Definition at line 111 of file TUnfoldBinning.h. ◆ GetRootNode() [1/2]. TUnfoldBinning * TUnfoldBinning::GetRootNode ; (; void ; ). protected . return root node ; Definition at line 546 of file TUnfoldBinning.cxx. ◆ GetRootNode() [2/2]. TUnfoldBinning const * TUnfoldBinning::GetRootNode ; (; void ; ); const. return root node of the binnig scheme ; Definition at line 555 of file TUnfoldBinning.cxx. ◆ GetStartBin(). Int_t TUnfoldBinning::GetStartBin ; (; void ; ); const. inline . first bin of this node ; Definition at line 147 of file TUnfoldBinning.h. ◆ GetTH1xNumberOfBins(). Int_t TUnfoldBinning::GetTH1xNumberOfBins ; (; Bool_t ; originalAxisBinning = kTRUE, . const char * ; axisSteering = nullptr . ); const. return the number of histogram bins required when storing this binning in a one-dimensional histogram ; Parameters. [in]originalAxisBinningif true, try to have the histogram axis reflect precisely the relevant axis of the binnnig scheme ; [in]axisSteeringsteering to integrate over axis and/or skip underflow and overflow bins. returns the number of bins of the TH1, where the underflow/overflow are not used, unless the distribution has only one axis and originalAxisBinning=true) ; axisSteering is a string as follows: ""axis[options];axis[options];..."" where: axis = name or * is an identifier of an axis (* matches all) and: options is any combination of the letters C,U,O (other letters are ignored). ; The letter C means that the corresponding axis is collapsed into one bin, i.e. one dimension is removed from the counting. The letters U,O remove for the matching axis the underflow.overflow bins from the counting ; Definition at line 667 of file TUnfoldBinning.cxx. ◆ GetTHxxBinning(). Int_t TUnfoldBinning::GetTHxxBinning ; (; Int_t ; maxDim, . Int_t * ; axisBins, . Int_t * ; axisList, . const char * ; axisSteering . ); const. protected . calculate properties of a THxx histogram to store this binning ; Parame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldBinning.html:50669,integrat,integrate,50669,doc/master/classTUnfoldBinning.html,https://root.cern,https://root.cern/doc/master/classTUnfoldBinning.html,1,['integrat'],['integrate']
Deployability,"va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Attributes; SeparationBase * fSepType;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Attributes inherited from TMVA::PDEFoamDiscriminant; UInt_t fClass;  ;  Protected Attributes inherited from TMVA::PDEFoam; Double_t * fAlpha;  [fDim] Internal parameters of the hyperrectangle ;  ; PDEFoamCell ** fCells;  [fNCells] Array of ALL cells ;  ; Int_t fDim;  Dimension of the integration/simulation space. ;  ; PDEFoamDensityBase * fDistr;  ! distribution of training events ;  ; EDTSeparation fDTSeparation;  BACKWARDS COMPATIBILITY: split cells according to decision tree logic. ;  ; Int_t fEvPerBin;  Maximum number of effective (wt=1) events per bin. ;  ; Bool_t fFillFoamWithOrigWeights;  BACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights. ;  ; EFoamType fFoamType;  BACKWARDS COMPATIBILITY: type of foam. ;  ; TObjArray * fHistEdg;  Histograms of wt, one for each cell edge. ;  ; Int_t * fInhiDiv;  ! [fDim] Flags for inhibiting cell division ;  ; Int_t fLastCe;  Index of the last cell. ;  ; MsgLogger * fLogger;  ! message logger ;  ; Int_t * fMaskDiv;  ! [fDim] Dynamic Mask for cell division ;  ; UInt_t fMaxDepth;  maximum depth of cell tree ;  ; TString fName;  Name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDEFoamDecisionTree.html:17904,integrat,integration,17904,doc/master/classTMVA_1_1PDEFoamDecisionTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDEFoamDecisionTree.html,1,['integrat'],['integration']
Deployability,"vable. Make sure that this binning is the same as the one of the dataset that should be fit. Use RooRealVar::setBinning() to adapt it. Instruct test statistics to carry out this wrapping automatically: pdf.fitTo(data, IntegrateBins(<precision>));; RooAbsPdf::fitToRooFit::OwningPtr< RooFitResult > fitTo(RooAbsData &data, CmdArgs_t const &... cmdArgs)Fit PDF to given dataset.Definition RooAbsPdf.h:157; RooBinSamplingPdf::pdfconst RooAbsPdf & pdf() constDefinition RooBinSamplingPdf.h:110; This method is especially useful when used with a simultaneous PDF, since each component will automatically be wrapped, depending on the value of precision:; precision < 0.: None of the PDFs are touched, bin sampling is off.; precision = 0.: Continuous PDFs that are fit to a RooDataHist are wrapped into a RooBinSamplingPdf. The target precision forwarded to the integrator is 1.E-4 (the default argument of the constructor).; precision > 0.: All continuous PDFs are automatically wrapped into a RooBinSamplingPdf, regardless of what data they are fit to (see next paragraph). The same ‘'precision’` is used for all integrators. Simulating a binned fit using RooDataSet; Some frameworks use unbinned data (RooDataSet) to simulate binned datasets. By adding one entry for each bin centre with the appropriate weight, one can achieve the same result as fitting with RooDataHist. In this case, however, RooFit cannot auto-detect that a binned fit is running, and that an integration over the bin is desired (note that there are no bins to integrate over in this kind of dataset).; In this case, IntegrateBins(>0.) needs to be used, and the desired binning needs to be assigned to the observable of the dataset: RooRealVar x(""x"", ""x"", 0., 5.);; x.setBins(10);; ; // <create dataset and model>; ; model.fitTo(data, IntegrateBins(>0.));; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; xDouble_t x[n]Definition legend1.C:17; See alsoRooAbsPdf::fitTo() . IntegrateBins(); NoteThis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:3303,continuous,continuous,3303,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['continuous'],['continuous']
Deployability,"vable; configurations simultaneously. RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedPdf(const RooCachedPdf& other, const char* name = 0); Copy constructor. ~RooCachedPdf(); Destructor. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cachePdf) const; Update contents of cache histogram by resampling the input p.d.f. Note that; the cache is filled with normalized p.d.f values so that the RooHistPdf; that represents the cache contents can be explicitly declared as self normalized; eliminating the need for superfluous numeric calculations of unit normalization.s. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Defer preferred scan order to cached pdf prefernece. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedPdf.html:46403,Update,Update,46403,root/html534/RooCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooCachedPdf.html,3,['Update'],['Update']
Deployability,"vables listed in iset. ; If no nset argument is given the c.d.f normalization is constructed over the integrated observables, so that its maximum value is precisely 1. It is also possible to choose a different normalization for multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can construct a partial cdf c(x,y) that only when integrated itself over z results in a maximum value of 1. To construct such a cdf pass z as argument to the optional nset argument ; Definition at line 2468 of file RooAbsPdf.cxx. ◆ createCdf() [2/2]. RooAbsPdf::createCdf ; (; const RooArgSet & ; iset, . const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). Create an object that represents the integral of the function over one or more observables listed in iset. ; The actual integration calculation is only performed when the return object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over; The following named arguments are accepted . Type of CmdArg Effect on CDF . SupNormSet(const RooArgSet&) Observables over which should be normalized in addition to the integration observables . ScanNumCdf() Apply scanning technique if cdf integral involves numeric integration [ default ] . ScanAllCdf() Always apply scanning technique . ScanNoCdf() Never apply scanning technique . ScanParameters(Int_t nbins, Int_t intOrder) Parameters for scanning technique of making CDF: number of sampled bins and order of interpolation applied on numeric cdf . PyROOT; The RooAbsPdf::createCdf() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 2490 of file RooAbsPdf.cxx. ◆ createExpectedEventsFunc(). std::u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:85169,integrat,integration,85169,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['integrat'],['integration']
Deployability,"val (eg. 0.95 for a 95% Confidence Interval). { SetTestSize(1.-cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). { return fSize; }. Double_t ConfidenceLevel() const; Get the Confidence level for the test. { return 1.-fSize; }. void SetLeftSideTailFraction(Double_t leftSideFraction); set the fraction of probability content on the left tail; Central limits use 0.5 (default case); for upper limits it is 0 and 1 for lower limit; For shortest intervals a negative value (i.e. -1) must be given. {fLeftSideFraction = leftSideFraction;}. void SetShortestInterval(); set the Bayesian calculator to compute the shorest interval (default is central interval); to switch off SetLeftSideTailFraction to the rght value. { fLeftSideFraction = -1; }. void SetBrfPrecision(double precision); set the precision of the Root Finder. { fBrfPrecision = precision; }. void SetScanOfPosterior(int nbin = 100); use directly the approximate posterior function obtained by binning it in nbins; by default the cdf is used by integrating the posterior; if a value of nbin <= 0 the cdf function will be used. { fNScanBins = nbin; }. void SetNumIters(Int_t numIters); set the number of iterations when running a MC integration algorithm; If not set use default algorithmic values; In case of ToyMC sampling of the nuisance the value is 100; In case of using the GSL MCintegrations types the default value is; defined in ROOT::Math::IntegratorMultiDimOptions::DefaultNCalls(). { fNumIterations = numIters; }. void ForceNuisancePdf(RooAbsPdf& pdf); force the nuisance pdf when using the toy mc sampling. { fNuisancePdf = &pdf; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: BayesianCalculator.h 39975 2011-06-26 22:49:46Z moneta $ » Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__BayesianCalculator.html:17086,integrat,integrating,17086,root/html532/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html532/RooStats__BayesianCalculator.html,2,['integrat'],['integrating']
Deployability,"val (eg. 0.95 for a 95% Confidence Interval). { SetTestSize(1.-cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). { return fSize; }. Double_t ConfidenceLevel() const; Get the Confidence level for the test. { return 1.-fSize; }. void SetLeftSideTailFraction(Double_t leftSideFraction); set the fraction of probability content on the left tail; Central limits use 0.5 (default case); for upper limits it is 0 and 1 for lower limit; For shortest intervals a negative value (i.e. -1) must be given. {fLeftSideFraction = leftSideFraction;}. void SetShortestInterval(); set the Bayesian calculator to compute the shorest interval (default is central interval); to switch off SetLeftSideTailFraction to the rght value. { fLeftSideFraction = -1; }. void SetBrfPrecision(double precision); set the precision of the Root Finder. { fBrfPrecision = precision; }. void SetScanOfPosterior(int nbin = 100); use directly the approximate posterior function obtained by binning it in nbins; by default the cdf is used by integrating the posterior; if a value of nbin <= 0 the cdf function will be used. { fNScanBins = nbin; }. void SetNumIters(Int_t numIters); set the number of iterations when running a MC integration algorithm; If not set use default algorithmic values; In case of ToyMC sampling of the nuisance the value is 100; In case of using the GSL MCintegrations types the default value is; defined in ROOT::Math::IntegratorMultiDimOptions::DefaultNCalls(). { fNumIterations = numIters; }. void ForceNuisancePdf(RooAbsPdf& pdf); force the nuisance pdf when using the toy mc sampling. { fNuisancePdf = &pdf; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: BayesianCalculator.h 39977 2011-06-26 22:57:52Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__BayesianCalculator.html:17086,integrat,integrating,17086,root/html530/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html530/RooStats__BayesianCalculator.html,1,['integrat'],['integrating']
Deployability,"value (i.e. ; -1) must be given ; Definition at line 114 of file BayesianCalculator.h. ◆ SetModel(). void RooStats::BayesianCalculator::SetModel ; (; const ModelConfig & ; model). overridevirtual . set the model via the ModelConfig ; set the model to use The model pdf, prior pdf, parameter of interest and nuisances will be taken according to the model ; Implements RooStats::IntervalCalculator.; Definition at line 738 of file BayesianCalculator.cxx. ◆ SetNuisanceParameters(). virtual void RooStats::BayesianCalculator::SetNuisanceParameters ; (; const RooArgSet & ; set). inlinevirtual . specify the nuisance parameters (eg. the rest of the parameters) ; Definition at line 85 of file BayesianCalculator.h. ◆ SetNumIters(). virtual void RooStats::BayesianCalculator::SetNumIters ; (; Int_t ; numIters). inlinevirtual . set the number of iterations when running a MC integration algorithm If not set use default algorithmic values In case of ToyMC sampling of the nuisance the value is 100 In case of using the GSL MCintegrations types the default value is defined in ROOT::Math::IntegratorMultiDimOptions::DefaultNCalls() ; Definition at line 133 of file BayesianCalculator.h. ◆ SetParameters(). virtual void RooStats::BayesianCalculator::SetParameters ; (; const RooArgSet & ; set). inlinevirtual . specify the parameters of interest in the interval ; Definition at line 82 of file BayesianCalculator.h. ◆ SetPriorPdf(). virtual void RooStats::BayesianCalculator::SetPriorPdf ; (; RooAbsPdf & ; pdf). inlinevirtual . Set only the Prior Pdf. ; Definition at line 88 of file BayesianCalculator.h. ◆ SetScanOfPosterior(). void RooStats::BayesianCalculator::SetScanOfPosterior ; (; int ; nbin = 100). inline . use directly the approximate posterior function obtained by binning it in nbins by default the cdf is used by integrating the posterior if a value of nbin <= 0 the cdf function will be used ; Definition at line 126 of file BayesianCalculator.h. ◆ SetShortestInterval(). void RooStats::Baye",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html:33278,integrat,integration,33278,doc/master/classRooStats_1_1BayesianCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html,1,['integrat'],['integration']
Deployability,"value for this object.; This default implementation considers all values valid. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Create a RooProfileLL object that eliminates all nuisance parameters in the; present function. The nuisance parameters are defined as all parameters; of the function except the stated paramsOfInterest. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is reque",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:35871,integrat,integrates,35871,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,18,['integrat'],['integrates']
Deployability,"value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; virtual bool selfNormalized () const;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRoo2DKeysPdf.html:13846,integrat,integrator,13846,doc/master/classRoo2DKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRoo2DKeysPdf.html,6,"['configurat', 'integrat']","['configuration', 'integrator']"
Deployability,"value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; virtual bool selfNormalized () const;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and paramete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBreitWigner.html:12827,integrat,integrator,12827,doc/master/classRooBreitWigner.html,https://root.cern,https://root.cern/doc/master/classRooBreitWigner.html,54,"['configurat', 'integrat']","['configuration', 'integrator']"
Deployability,"value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; virtual bool selfNormalized () const;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:17483,integrat,integrator,17483,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,40,"['configurat', 'integrat']","['configuration', 'integrator']"
Deployability,"value of the integral of a function f over the defined interval (a,b) with a singularity at c; 402 ; 403 */; 404 double IntegralCauchy(double a, double b, double c) {; 405 return !fIntegrator ? 0 : fIntegrator->IntegralCauchy(a,b,c);; 406 }; 407 ; 408 /**; 409 return the Result of the last Integral calculation; 410 */; 411 double Result() const { return !fIntegrator ? 0 : fIntegrator->Result(); }; 412 ; 413 /**; 414 return the estimate of the absolute Error of the last Integral calculation; 415 */; 416 double Error() const { return !fIntegrator ? 0 : fIntegrator->Error(); }; 417 ; 418 /**; 419 return the Error Status of the last Integral calculation; 420 */; 421 int Status() const { return !fIntegrator ? -1 : fIntegrator->Status(); }; 422 ; 423 /**; 424 return number of function evaluations in calculating the integral; 425 (if integrator do not implement this function returns -1); 426 */; 427 int NEval() const { return !fIntegrator ? -1 : fIntegrator->NEval(); }; 428 ; 429 ; 430 // setter for control Parameters (getters are not needed so far ); 431 ; 432 /**; 433 set the desired relative Error; 434 */; 435 void SetRelTolerance(double relTolerance) { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance); }; 436 ; 437 ; 438 /**; 439 set the desired absolute Error; 440 */; 441 void SetAbsTolerance(double absTolerance) { if (fIntegrator) fIntegrator->SetAbsTolerance(absTolerance); }; 442 ; 443 /**; 444 return a pointer to integrator object; 445 */; 446 VirtualIntegratorOneDim * GetIntegrator() { return fIntegrator; }; 447 ; 448 /**; 449 set the options; 450 */; 451 void SetOptions(const ROOT::Math::IntegratorOneDimOptions & opt) { if (fIntegrator) fIntegrator->SetOptions(opt); }; 452 ; 453 /**; 454 retrieve the options; 455 */; 456 ROOT::Math::IntegratorOneDimOptions Options() const { return (fIntegrator) ? fIntegrator->Options() : IntegratorOneDimOptions(); }; 457 ; 458 /// return name of integrator; 459 std::string Name() const { return (fIntegrator) ? Options().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Integrator_8h_source.html:17653,integrat,integrator,17653,doc/master/Integrator_8h_source.html,https://root.cern,https://root.cern/doc/master/Integrator_8h_source.html,2,['integrat'],['integrator']
Deployability,"value of the integration interval . Implements ROOT::Math::VirtualIntegratorOneDim.; Definition at line 290 of file GSLIntegrator.cxx. ◆ IntegralUp() [3/3]. double ROOT::Math::GSLIntegrator::IntegralUp ; (; GSLFuncPointer ; f, . void * ; p, . double ; a . ). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer ; Definition at line 368 of file GSLIntegrator.cxx. ◆ NEval(). int ROOT::Math::GSLIntegrator::NEval ; (; ); const. inlineoverridevirtual . return number of function evaluations in calculating the integral ; Reimplemented from ROOT::Math::VirtualIntegrator.; Definition at line 333 of file GSLIntegrator.h. ◆ operator=(). GSLIntegrator & ROOT::Math::GSLIntegrator::operator= ; (; const GSLIntegrator & ; rhs). private . Definition at line 164 of file GSLIntegrator.cxx. ◆ Options(). ROOT::Math::IntegratorOneDimOptions ROOT::Math::GSLIntegrator::Options ; (; ); const. overridevirtual . get the option used for the integration ; Implements ROOT::Math::VirtualIntegratorOneDim.; Definition at line 442 of file GSLIntegrator.cxx. ◆ Result(). double ROOT::Math::GSLIntegrator::Result ; (; ); const. overridevirtual . return the Result of the last Integral calculation ; Implements ROOT::Math::VirtualIntegrator.; Definition at line 388 of file GSLIntegrator.cxx. ◆ SetAbsTolerance(). void ROOT::Math::GSLIntegrator::SetAbsTolerance ; (; double ; absTolerance). overridevirtual . set the desired absolute Error ; Implements ROOT::Math::VirtualIntegrator.; Definition at line 399 of file GSLIntegrator.cxx. ◆ SetFunction() [1/2]. void ROOT::Math::GSLIntegrator::SetFunction ; (; const IGenFunction & ; f). overridevirtual . method to set the a generic integration function ; Parameters. fintegration function. The function type must implement the assignment operator, double operator() ( double x ) . Implements ROOT::Math::VirtualIntegratorOneDim.; Definition at line 182 of file GSLIntegrator.cxx. ◆ SetFunction() [2/2]. void ROOT::Ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLIntegrator.html:18770,integrat,integration,18770,doc/master/classROOT_1_1Math_1_1GSLIntegrator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLIntegrator.html,1,['integrat'],['integration']
Deployability,"value. bool CheckMinuitInstance() const; check instance of fMinuit. bool CheckVarIndex(unsigned int ivar) const; check index of Variable (assume fMinuit exists). bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. bool SetVariableStepSize(unsigned int , double ); set the step-size of an existing variable; parameter must exist or return false. bool SetVariableLowerLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableUpperLimit(unsigned int , double ); set the limits of an existing variable; parameter must exist or return false. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an existing variable; parameter must exist or return false. bool FixVariable(unsigned int ); Fix an existing variable. bool ReleaseVariable(unsigned int ); Fix an existing variable. bool IsFixedVariable(unsigned int ) const; query if variable is fixed. bool GetVariableSettings(unsigned int , ROOT::Fit::ParameterSettings& ) const; retrieve variable settings (all set info on the variable). std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMinuitMinimizer.html:9821,Release,ReleaseVariable,9821,root/html602/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html602/TMinuitMinimizer.html,2,['Release'],['ReleaseVariable']
Deployability,"value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* nset); Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:42719,integrat,integration,42719,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['integrat'],['integration']
Deployability,"value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optional",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:43332,integrat,integration,43332,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,2,['integrat'],['integration']
Deployability,"value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A: lower end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralLow(double b); Returns Integral of function on a lower semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - B: upper end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. void SetFunction(const ROOT::Math::IGenFunction& ); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations. double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, double b, double c); This method is not implemented. . void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Derived class (like GaussLegendreIntegrator) can re-implement this method to modify to use; an improved algorithm. » Last changed: root/mathcore:$Id: GaussIntegrator.h 36764 2010-11-19 10:02:00Z moneta $ » Last generated: 2010-11-19 17:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__GaussIntegrator.html:6103,integrat,integration,6103,root/html528/ROOT__Math__GaussIntegrator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__GaussIntegrator.html,1,['integrat'],['integration']
Deployability,"value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A: lower end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralLow(double b); Returns Integral of function on a lower semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - B: upper end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. void SetFunction(const ROOT::Math::IGenFunction& ); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations. double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, double b, double c); This method is not implemented. . void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Derived class (like GaussLegendreIntegrator) can re-implement this method to modify to use; an improved algorithm. » Last changed: root/mathcore:$Id: GaussIntegrator.h 36764 2010-11-19 10:02:00Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__GaussIntegrator.html:6105,integrat,integration,6105,root/html530/ROOT__Math__GaussIntegrator.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__GaussIntegrator.html,1,['integrat'],['integration']
Deployability,"value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A: lower end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralLow(double b); Returns Integral of function on a lower semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - B: upper end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. void SetFunction(const ROOT::Math::IGenFunction& ); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations. double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, double b, double c); This method is not implemented. . void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Derived class (like GaussLegendreIntegrator) can re-implement this method to modify to use; an improved algorithm. » Last changed: root/mathcore:$Id: GaussIntegrator.h 36764 2010-11-19 10:02:00Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:6105,integrat,integration,6105,root/html532/ROOT__Math__GaussIntegrator.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html,4,"['Integrat', 'integrat']","['Integration', 'IntegratorOneDimOptions', 'integration']"
Deployability,"valued object ;  CRooRealVarSharedPropertiesClass RooRealVarSharedProperties is an implementation of RooSharedProperties that stores the properties of a RooRealVar that are shared among clones ;  CRooRecursiveFractionClass RooRecursiveFraction is a RooAbsReal implementation that calculates the plain fraction of sum of RooAddPdf components from a set of recursive fractions: for a given set of input fractions a_i it returns a_0 * Prod_i (1 - a_i) ;  CRooRefArray;  CRooRefCountListA RooRefCountList is a RooLinkedList that keeps a reference counter with each added node ;  CRooResolutionModel;  CRooScaledFuncLightweight RooAbsFunction implementation that applies a constant scale factor to another RooAbsFunc ;  CRooSecondMomentRooSecondMoment represents the first, second, or third order derivative of any RooAbsReal as calculated (numerically) by the MathCore Richardson derivator class ;  CRooSegmentedIntegrator1DRooSegmentedIntegrator1D implements an adaptive one-dimensional numerical integration algorithm ;  CRooSegmentedIntegrator2DRooSegmentedIntegrator2D implements an adaptive one-dimensional numerical integration algorithm ;  CRooSentinelRooSentinel is a special purposes singleton class that terminates all other RooFit singleton services when the process exists ;  CRooSetPairRooSetPair is a utility class that stores a pair of RooArgSets ;  CRooSetProxyRooSetProxy is the concrete proxy for RooArgSet objects ;  CRooSharedPropertiesClass RooSharedProperties is the base class for shared properties that can be stored in RooSharedPropertiesList ;  CRooSharedPropertiesListClass RooSharedPropertiesList maintains the properties of RooRealVars and RooCategories that are clones of each other ;  CRooSimGenContextRooSimGenContext is an efficient implementation of the generator context specific for RooSimultaneous PDFs when generating more than one of the component pdfs ;  CRooSimPdfBuilder;  CRooSimSplitGenContextRooSimSplitGenContext is an efficient implementation of the generat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:103923,integrat,integration,103923,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,5,['integrat'],['integration']
Deployability,"valued object that can be used by RooRealIntegral to integrate over ;  CRooLinkedListRooLinkedList is an collection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list ;  CRooLinkedListElemRooLinkedListElem is an link element for the RooLinkedList class ;  CRooLinkedListIterRooLinkedListIter is the TIterator implementation for RooLinkedList ;  CRooLinTransBinningRooLinTransBinning is a special binning implementation for RooLinearVar that transforms the binning of the RooLinearVar input variable in the same way that RooLinearVar does ;  CRooListA RooList is a TList with extra support for working with options that are associated with each node ;  CRooListProxyRooListProxy is the concrete proxy for RooArgList objects ;  CRooLognormalRooFit Lognormal PDF ;  CRooMapCatEntry;  ►CRooMappedCategory;  CEntry;  CRooMath;  CRooMathCoreReg;  CRooMathMoreReg;  CRooMCIntegratorRooMCIntegrator implements an adaptive multi-dimensional Monte Carlo numerical integration, following the VEGAS algorithm originally described in G ;  CRooMCStudyRooMCStudy is a help class to facilitate Monte Carlo studies such as 'goodness-of-fit' studies, that involve fitting a PDF to multiple toy Monte Carlo sets generated from the same PDF or another PDF ;  CRooMinimizerRooMinimizer is a wrapper class around ROOT::Fit:Fitter that provides a seamless interface between the minimizer functionality and the native RooFit interface ;  CRooMinimizerFcn;  CRooMinuitRooMinuit is a wrapper class around TFitter/TMinuit that provides a seamless interface between the MINUIT functionality and the native RooFit interface ;  CRooMomentRooMoment represents the first, second, or third order derivative of any RooAbsReal as calculated (numerically) by the MathCore Richardson derivator class ;  ►CRooMomentMorph;  CCacheElem;  ►CRooMomentMorphFunc;  CCacheElem;  ►CRooMomentMorphFuncND;  CCacheElem;  CDigits;  CGrid2;  ►CRooMomentMorphND;  CCacheElem;  CGrid;  CRooMPSentinelRooMPSentinel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:118872,integrat,integration,118872,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['integrat'],['integration']
Deployability,"values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,unsigned int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction2Binding_double_unsigned_int_double_.html:32352,integrat,integrator,32352,root/html526/RooCFunction2Binding_double_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html526/RooCFunction2Binding_double_unsigned_int_double_.html,4,"['configurat', 'integrat']","['configuration', 'integrator']"
Deployability,"values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). tem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html:7104,integrat,integration,7104,root/html528/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html,8,['integrat'],['integration']
Deployability,"variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj). find the contour points (xi, xj) of the function for parameter ivar and jvar around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names); return an empty string if variable is not found. int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fOptions.PrintLevel(); }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fOptions.MaxFunctionCalls(); }. unsigned int MaxIterations() const; max iterations. { return fOptions.MaxIterations(); }. double Tolerance() const; absolute tolerance. { return fOptions.Tolerance(); }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fOptions.Precision(); }. int Strategy() const; strategy. { return fOptions.Strategy(); }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 for Chi2 and 0.5 for likelihood minimization. { return fOptions.ErrorDef(); }. bool IsValidError() const; return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit). { return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__Minimizer.html:11898,configurat,configuration,11898,root/html534/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__Minimizer.html,6,['configurat'],['configuration']
Deployability,"variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf704__amplitudefit_8C.html:10608,integrat,integrator,10608,doc/master/rf704__amplitudefit_8C.html,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html,6,['integrat'],"['integrates', 'integrator']"
Deployability,"vars); const. inlineoverridevirtual . Advertise capability to determine maximum value of function for given set of observables. ; If no direct generator method is provided, this information will assist the accept/reject generator to operate more efficiently as it can skip the initial trial sampling phase to empirically find the function maximum ; Reimplemented from RooAbsReal.; Definition at line 95 of file RooBinSamplingPdf.h. ◆ initGenerator(). void RooBinSamplingPdf::initGenerator ; (; Int_t ; code). inlineoverridevirtual . Forwards to the PDF's implementation. ; Reimplemented from RooAbsPdf.; Definition at line 87 of file RooBinSamplingPdf.h. ◆ integrate(). double RooBinSamplingPdf::integrate ; (; const RooArgSet * ; normSet, . double ; low, . double ; high . ); const. private . Integrate the wrapped PDF using our current integrator, with given norm set and limits. ; Definition at line 302 of file RooBinSamplingPdf.cxx. ◆ integrator(). std::unique_ptr< ROOT::Math::IntegratorOneDim > & RooBinSamplingPdf::integrator ; (; ); const. Direct access to the unique_ptr holding the integrator that's used to sample the bins. ; This can be used to change options such as sampling accuracy or to entirely exchange the integrator.; Example: Use the 61-point Gauss-Kronrod integration rule; ROOT::Math::IntegratorOneDimOptions intOptions = pdf.integrator()->Options();; intOptions.SetNPoints(6); // 61-point integration rule; intOptions.SetRelTolerance(1.E-9); // Smaller tolerance -> more subdivisions; pdf.integrator()->SetOptions(intOptions);; ROOT::Math::BaseIntegratorOptions::SetRelTolerancevoid SetRelTolerance(double tol)set the relative toleranceDefinition IntegratorOptions.h:80; ROOT::Math::IntegratorOneDimOptionsNumerical one dimensional integration options.Definition IntegratorOptions.h:113; ROOT::Math::IntegratorOneDimOptions::SetNPointsvoid SetNPoints(unsigned int n)Set number of points for active integration rule.Definition IntegratorOptions.h:140; See alsoROOT::Math::Inte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:86615,integrat,integrator,86615,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['integrat'],['integrator']
Deployability,"vas (if exist); TClassMenuItem*fSelectedMenuItemselected class menu item; TFunction*fSelectedMethodselected method; TObject*fSelectedObjectselected object; TVirtualPad*fSelectedPadselected pad (if exist); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TContextMenu(const char* name, const char* title = ""Context sensitive popup menu""); Create a context menu. ~TContextMenu(); Destroy a context menu. void Action(TObject* object, TMethod* method); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TClassMenuItem* classmenuitem); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TObject* object, TToggle* toggle); Action to be performed when this toggle menu item is selected. const char * CreateArgumentTitle(TMethodArg* argument); Create string describing argument (for use in dialog box). const char * CreateDialogTitle(TObject* object, TFunction* method); Create title for dialog box retrieving argument values. const char * CreatePopupTitle(TObject* object); Create title for popup menu. void Execute(TObject* object, TFunction* method, const char* params); Execute method with specified arguments for specified object. void Execute(TObject* object, TFunction* method, TObjArray* params); Execute method with specified arguments for specified object. void Popup(Int_t x, Int_t y, TObject* obj, TVirtualPad* c = 0, TVirtualPad* p = 0); Popup context menu at given location in canvas c and pad p for selected; object. void Popup(Int_t x, Int_t y, TObject* obj, TBrowser* b); Popup context menu at given location in browser b for selected object. TContextMenu(const TContextMenu& ). TContextMenu& operator=(const TConte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TContextMenu.html:8522,toggle,toggle,8522,root/html528/TContextMenu.html,https://root.cern,https://root.cern/root/html528/TContextMenu.html,20,['toggle'],['toggle']
Deployability,"vas(""cw"",""cw"",0,0,400,400);; 227 cw->GetCanvas()->SetGrayscale();; 228 w->SetCanvas(cw);; 229 w->Draw();; 230}; 231End_Macro; 232 ; 233\anchor C05; 234## Color palettes; 235It is often very useful to represent a variable with a color map. The concept; 236of ""color palette"" allows to do that. One color palette is active at any time.; 237This ""current palette"" is set using:; 238 ; 239~~~ {.cpp}; 240gStyle->SetPalette(...);; 241~~~; 242 ; 243This function has two parameters: the number of colors in the palette and an; 244array of containing the indices of colors in the palette. The following small; 245example demonstrates how to define and use the color palette:; 246 ; 247Begin_Macro(source); 248{; 249 auto c1 = new TCanvas(""c1"",""c1"",0,0,600,400);; 250 TF2 *f1 = new TF2(""f1"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; 251 Int_t palette[5];; 252 palette[0] = 15;; 253 palette[1] = 20;; 254 palette[2] = 23;; 255 palette[3] = 30;; 256 palette[4] = 32;; 257 gStyle->SetPalette(5,palette);; 258 f1->Draw(""colz"");; 259 return c1;; 260}; 261End_Macro; 262 ; 263To define more a complex palette with a continuous gradient of color, one; 264should use the static function `TColor::CreateGradientColorTable()`.; 265The following example demonstrates how to proceed:; 266 ; 267Begin_Macro(source); 268{; 269 auto c2 = new TCanvas(""c2"",""c2"",0,0,600,400);; 270 auto f2 = new TF2(""f2"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; 271 const Int_t Number = 3;; 272 Double_t Red[Number] = { 1.00, 0.00, 0.00};; 273 Double_t Green[Number] = { 0.00, 1.00, 0.00};; 274 Double_t Blue[Number] = { 1.00, 0.00, 1.00};; 275 Double_t Length[Number] = { 0.00, 0.50, 1.00 };; 276 Int_t nb=50;; 277 TColor::CreateGradientColorTable(Number,Length,Red,Green,Blue,nb);; 278 f2->SetContour(nb);; 279 f2->SetLineWidth(1);; 280 f2->SetLineColor(kBlack);; 281 f2->Draw(""surf1z"");; 282 return c2;; 283}; 284End_Macro; 285 ; 286The function `TColor::CreateGradientColorTable()` automatically; 287calls `gStyle->SetPalett",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:9426,continuous,continuous,9426,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['continuous'],['continuous']
Deployability,"vas(""rf302_utilfuncs"", ""rf302_utilfuncs"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.20); hh_model_1.GetZaxis().SetTitleOffset(2.5); hh_model_1.Draw(""surf""); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh_model_2.GetZaxis().SetTitleOffset(2.5); hh_model_2.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.20); hh_model_3.GetZaxis().SetTitleOffset(2.5); hh_model_3.Draw(""surf""); c.cd(4); ROOT.gPad.SetLeftMargin(0.20); hh_model_4.GetZaxis().SetTitleOffset(2.5); hh_model_4.Draw(""surf""); ; c.SaveAs(""rf302_utilfuncs.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_2' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_3' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'model_4' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_1_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_2_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_3_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_4_Int[x,y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf302_utilfuncs.py. tutorialsroofitrf302_utilfuncs.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf302__utilfuncs_8py.html:4053,integrat,integrator,4053,doc/master/rf302__utilfuncs_8py.html,https://root.cern,https://root.cern/doc/master/rf302__utilfuncs_8py.html,4,['integrat'],['integrator']
Deployability,"vas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar; static TSessionQueryFrame::EQueryStatuskAborted; static TSessionQueryFrame::EQueryStatuskDone; static TSessionQueryFrame::EQueryStatuskRunning; static TSessionQueryFrame::EQueryStatuskStopped. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TSessionQueryFrame. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query information frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSessionQueryFrame.html:22496,Update,UpdateHistos,22496,root/html602/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html602/TSessionQueryFrame.html,4,['Update'],"['Update', 'UpdateHistos']"
Deployability,"vas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TGeoNode**fArray![fMaxLevel+1] Array of nodes; Int_tfLevelBranch depth; TGeoHMatrixfMatrixGlobal matrix (owned); Int_tfMaxLevelArray length; TGeoNode*fRealArray[1]Beginning address of the array of nodes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBranchArray(Int_t level); Constructor. Alocates the array with a size given by level. TGeoBranchArray * MakeInstance(size_t maxlevel); Make an instance of the class which allocates the node array. To be; released using ReleaseInstance. If addr is non-zero, the user promised that; addr contains at least that many bytes: size_t needed = SizeOf(maxlevel);. TGeoBranchArray * MakeInstanceAt(size_t maxlevel, void* addr); Make an instance of the class which allocates the node array. To be; released using ReleaseInstance. If addr is non-zero, the user promised that; addr contains at least that many bytes: size_t needed = SizeOf(maxlevel);. TGeoBranchArray * MakeCopy(const TGeoBranchArray& other); Make a copy of a branch array at the location (if indicated). TGeoBranchArray * MakeCopyAt(const TGeoBranchArray& other, void* addr); Make a copy of a branch array at the location (if indicated). void CopyTo(TGeoBranchArray* dest); Raw memcpy of the branch array content to an existing destination. void ReleaseInstance(TGeoBranchArray* obj); Releases the space allocated for the object. void UpdateArray(size_t nobj); Updates the internal addresses for n contiguous objects which have the same; fMaxLevel; Updates the internal addresses for n contiguous objects which have the same fMaxLevel. TGeoBranchArray(const TGeoBranchArray& ); Copy constructor. Not callable anymore. Use TGeoBranchArray::MakeCopy instead. TGeoBranchArray& operator=(const TGeoBranchArray& ); Assignment. Not valid anymore. Use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBranchArray.html:7835,release,released,7835,root/html534/TGeoBranchArray.html,https://root.cern,https://root.cern/root/html534/TGeoBranchArray.html,3,"['Release', 'release']","['ReleaseInstance', 'released']"
Deployability,"vate:. TStopwatch_cumulTimer; TMatrixDSym*_extV; RooMinimizerFcn*_fcn; RooAbsReal*_func; string_minimizerType; Bool_t_optConst; Int_t_printLevel; Bool_t_profile; Bool_t_profileStart; Int_t_status; vector<std::pair<std::string,int> >_statusHistory; static ROOT::Fit::Fitter*_theFitter; TStopwatch_timer; Bool_t_verbose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Cleanup method called by atexit handler installed by RooSentinel; to delete all global heap objects when the program is terminated. RooMinimizer(RooAbsReal& function); Construct MINUIT interface to given function. Function can be anything,; but is typically a -log(likelihood) implemented by RooNLLVar or a chi^2; (implemented by RooChi2Var). Other frequent use cases are a RooAddition; of a RooNLLVar plus a penalty or constraint term. This class propagates; all RooFit information (floating parameters, their values and errors); to MINUIT before each MINUIT call and propagates all MINUIT information; back to the RooFit object at the end of each call (updated parameter; values, their (asymmetric errors) etc. The default MINUIT error level; for HESSE and MINOS error analysis is taken from the defaultErrorLevel(); value of the input function. ~RooMinimizer(); Destructor. void setStrategy(Int_t strat); Change MINUIT strategy to istrat. Accepted codes; are 0,1,2 and represent MINUIT strategies for dealing; most efficiently with fast FCNs (0), expensive FCNs (2); and 'intermediate' FCNs (1). void setMaxIterations(Int_t n); Change maximum number of MINUIT iterations; (RooMinimizer default 500 * #parameters). void setMaxFunctionCalls(Int_t n); Change maximum number of likelihood function calss from MINUIT; (RooMinimizer default 500 * #parameters). void setErrorLevel(Double_t level); Set the level for MINUIT error analysis to the given; value. This function overrides the default value; that is taken in the RooMinimizer constructor from; the defaultErrorLevel() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMinimizer.html:8727,update,updated,8727,root/html534/RooMinimizer.html,https://root.cern,https://root.cern/root/html534/RooMinimizer.html,2,['update'],['updated']
Deployability,"ve Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html:5796,integrat,integration,5796,root/html528/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html,10,['integrat'],['integration']
Deployability,"ve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ). const Event* Transform(const TMVA::Event *const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event *const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNormalise(Bool_t n); { fNormalise = n; }. Bool_t IsEnabled() const; { return fEnabled; }. Bool_t IsCreated() const; { return fCreated; }. Bool_t IsNormalised() const; { return fNormalise; }. void ToggleInputSortOrder(Bool_t sortOrder); { fSortGet = sortOrder; }. void SetOu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__VariableTransformBase.html:10098,update,update,10098,root/html530/TMVA__VariableTransformBase.html,https://root.cern,https://root.cern/root/html530/TMVA__VariableTransformBase.html,4,"['Update', 'update']","['UpdateNorm', 'update']"
Deployability,ve components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genFlavFrac!; Double_t_genFlavFracMix!; Double_t_genFlavFracUnmix!; Double_t_genMixFrac! do not persist; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooRealProxy_mistag; RooCategoryProxy_mixState; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbs,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBMixDecay.html:39218,integrat,integrated,39218,root/html526/RooBMixDecay.html,https://root.cern,https://root.cern/root/html526/RooBMixDecay.html,1,['integrat'],['integrated']
Deployability,ve components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genFlavFrac!; Double_t_genFlavFracMix!; Double_t_genFlavFracUnmix!; Double_t_genMixFrac! do not persist; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooRealProxy_mistag; RooCategoryProxy_mixState; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBMixDecay.html:39792,integrat,integrated,39792,root/html528/RooBMixDecay.html,https://root.cern,https://root.cern/root/html528/RooBMixDecay.html,2,['integrat'],['integrated']
Deployability,ve components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genFlavFrac!; Double_t_genFlavFracMix!; Double_t_genFlavFracUnmix!; Double_t_genMixFrac! do not persist; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooRealProxy_mistag; RooCategoryProxy_mixState; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of prox,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBMixDecay.html:40472,integrat,integrated,40472,root/html532/RooBMixDecay.html,https://root.cern,https://root.cern/root/html532/RooBMixDecay.html,1,['integrat'],['integrated']
Deployability,"ve proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; value_type _defCat {NoCatIdx};  Default (unmapped) output type. ;  ; RooCategoryProxy _inputCat;  Input category. ;  ; std::map< std::string, RooMappedCategory::Entry > _mapArray;  List of mapping rules. ;  ; std::unique_ptr< RooMappedCategoryCache > _mapcache;  ! transient member: cache the mapping ;  ;  Protected Attributes inherited from RooAbsCategory; value_type _currentIndex {std::numeric_limits<int>::min()};  Current category state. ;  ; std::vector< std::string > _insertionOrder;  Keeps track in which order state numbers have been inserted. Make sure this is updated in recomputeShape(). ;  ; std::map< value_type, std::unique_ptr< RooCatType, std::function< void(RooCatType *)> > > _legacyStates;  ! Map holding pointers to RooCatType instances. Only for legacy interface. Don't use if possible. ;  ; std::map< std::string, value_type > _stateNames;  Map state names to index numbers. Make sure state names are updated in recomputeShape(). ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMappedCategory.html:40581,update,updated,40581,doc/master/classRooMappedCategory.html,https://root.cern,https://root.cern/doc/master/classRooMappedCategory.html,1,['update'],['updated']
Deployability,"ve proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; const ROOT::Math::IBaseFunctionOneDim * func;  ; RooRealProxy var;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFunctor1DPdfBinding.html:67802,configurat,configuration,67802,doc/master/classRooFunctor1DPdfBinding.html,https://root.cern,https://root.cern/doc/master/classRooFunctor1DPdfBinding.html,1,['configurat'],['configuration']
Deployability,ve the configuration ; : 15 | 27781.4 26354.5 0.0197825 0.0017915 44466.6 0; : 16 Minimum Test error found - save the configuration ; : 16 | 27524.2 26104.3 0.0196926 0.00175551 44600.3 0; : 17 Minimum Test error found - save the configuration ; : 17 | 27271.4 25860.7 0.0197778 0.00177907 44447.7 0; : 18 Minimum Test error found - save the configuration ; : 18 | 27023.6 25622.6 0.0197311 0.00176281 44522.9 0; : 19 Minimum Test error found - save the configuration ; : 19 | 26780.6 25388.8 0.0197339 0.00176163 44513.1 0; : 20 Minimum Test error found - save the configuration ; : 20 | 26542.7 25157.4 0.0198818 0.0018763 44431 0; : 21 Minimum Test error found - save the configuration ; : 21 | 26311 24925.1 0.0199584 0.00175652 43951.6 0; : 22 Minimum Test error found - save the configuration ; : 22 | 26076.9 24700.5 0.0197873 0.00176359 44385.9 0; : 23 Minimum Test error found - save the configuration ; : 23 | 25845.4 24483.8 0.0196702 0.00176161 44671.3 0; : 24 Minimum Test error found - save the configuration ; : 24 | 25624.1 24264.1 0.0196853 0.00176075 44631.5 0; : 25 Minimum Test error found - save the configuration ; : 25 | 25402.4 24046.8 0.0199052 0.00182376 44244.2 0; : 26 Minimum Test error found - save the configuration ; : 26 | 25181.1 23835.2 0.0199605 0.00176778 43973.7 0; : 27 Minimum Test error found - save the configuration ; : 27 | 24965.1 23625.2 0.0197673 0.00175956 44425.4 0; : 28 Minimum Test error found - save the configuration ; : 28 | 24751.3 23417.4 0.0197715 0.00178318 44473.3 0; : 29 Minimum Test error found - save the configuration ; : 29 | 24538.1 23214.7 0.019691 0.0017711 44643.2 0; : 30 Minimum Test error found - save the configuration ; : 30 | 24332.4 23009.4 0.0197207 0.00177726 44584.5 0; : 31 Minimum Test error found - save the configuration ; : 31 | 24122.8 22810.9 0.0196876 0.00176879 44645.9 0; : 32 Minimum Test error found - save the configuration ; : 32 | 23919.8 22612.5 0.01973 0.00178692 44585.4 0; : 33 Minimum Test error found,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:13779,configurat,configuration,13779,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['configurat'],['configuration']
Deployability,ve the configuration ; : 34 | 23516.3 22222.5 0.0206631 0.00186547 42558.4 0; : 35 Minimum Test error found - save the configuration ; : 35 | 23322.1 22028.2 0.0200826 0.00177554 43698.9 0; : 36 Minimum Test error found - save the configuration ; : 36 | 23123.9 21840 0.0197735 0.00177073 44437.6 0; : 37 Minimum Test error found - save the configuration ; : 37 | 22932.1 21651.2 0.0197273 0.00177446 44561.1 0; : 38 Minimum Test error found - save the configuration ; : 38 | 22740.7 21464.4 0.0197166 0.00177193 44581.5 0; : 39 Minimum Test error found - save the configuration ; : 39 | 22549.1 21282.9 0.0197213 0.00177445 44576 0; : 40 Minimum Test error found - save the configuration ; : 40 | 22363.6 21100 0.0197729 0.00177445 44448.2 0; : 41 Minimum Test error found - save the configuration ; : 41 | 22176.6 20921.1 0.0197131 0.00176514 44573.2 0; : 42 Minimum Test error found - save the configuration ; : 42 | 21994.9 20740.9 0.0197264 0.00176834 44548.1 0; : 43 Minimum Test error found - save the configuration ; : 43 | 21811.7 20564.6 0.0197476 0.00176764 44494 0; : 44 Minimum Test error found - save the configuration ; : 44 | 21631.5 20390.5 0.0198172 0.00177793 44347.7 0; : 45 Minimum Test error found - save the configuration ; : 45 | 21453.9 20217 0.0197313 0.00176795 44535.1 0; : 46 Minimum Test error found - save the configuration ; : 46 | 21277.2 20045.6 0.0197489 0.00176953 44495.5 0; : 47 Minimum Test error found - save the configuration ; : 47 | 21102.5 19876.1 0.0197499 0.00176859 44490.7 0; : 48 Minimum Test error found - save the configuration ; : 48 | 20931.2 19705.9 0.0197403 0.00176149 44496.7 0; : 49 Minimum Test error found - save the configuration ; : 49 | 20758.9 19539.2 0.0199993 0.00178715 43926.8 0; : 50 Minimum Test error found - save the configuration ; : 50 | 20589.8 19373.7 0.0199739 0.00177216 43951.9 0; : 51 Minimum Test error found - save the configuration ; : 51 | 20419.5 19213.6 0.0197688 0.0017747 44459 0; : 52 Minimum Test error found - ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:15896,configurat,configuration,15896,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['configurat'],['configuration']
Deployability,ve the configuration ; : 40 | 22363.6 21100 0.0197729 0.00177445 44448.2 0; : 41 Minimum Test error found - save the configuration ; : 41 | 22176.6 20921.1 0.0197131 0.00176514 44573.2 0; : 42 Minimum Test error found - save the configuration ; : 42 | 21994.9 20740.9 0.0197264 0.00176834 44548.1 0; : 43 Minimum Test error found - save the configuration ; : 43 | 21811.7 20564.6 0.0197476 0.00176764 44494 0; : 44 Minimum Test error found - save the configuration ; : 44 | 21631.5 20390.5 0.0198172 0.00177793 44347.7 0; : 45 Minimum Test error found - save the configuration ; : 45 | 21453.9 20217 0.0197313 0.00176795 44535.1 0; : 46 Minimum Test error found - save the configuration ; : 46 | 21277.2 20045.6 0.0197489 0.00176953 44495.5 0; : 47 Minimum Test error found - save the configuration ; : 47 | 21102.5 19876.1 0.0197499 0.00176859 44490.7 0; : 48 Minimum Test error found - save the configuration ; : 48 | 20931.2 19705.9 0.0197403 0.00176149 44496.7 0; : 49 Minimum Test error found - save the configuration ; : 49 | 20758.9 19539.2 0.0199993 0.00178715 43926.8 0; : 50 Minimum Test error found - save the configuration ; : 50 | 20589.8 19373.7 0.0199739 0.00177216 43951.9 0; : 51 Minimum Test error found - save the configuration ; : 51 | 20419.5 19213.6 0.0197688 0.0017747 44459 0; : 52 Minimum Test error found - save the configuration ; : 52 | 20255.7 19051.4 0.0197679 0.00177721 44467.5 0; : 53 Minimum Test error found - save the configuration ; : 53 | 20090.6 18891.7 0.0197461 0.00177488 44515.6 0; : 54 Minimum Test error found - save the configuration ; : 54 | 19926.4 18735.4 0.0197628 0.00177559 44476 0; : 55 Minimum Test error found - save the configuration ; : 55 | 19766 18579 0.0197479 0.00177128 44502.3 0; : 56 Minimum Test error found - save the configuration ; : 56 | 19606.6 18423 0.0198259 0.00178958 44354.9 0; : 57 Minimum Test error found - save the configuration ; : 57 | 19448.2 18266.7 0.0197832 0.00177932 44434.9 0; : 58 Minimum Test error found - save,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:16564,configurat,configuration,16564,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['configurat'],['configuration']
Deployability,ve the configuration ; : 60 | 18976.4 17813.4 0.0198417 0.00178241 44298.6 0; : 61 Minimum Test error found - save the configuration ; : 61 | 18829.3 17664.6 0.0197742 0.00177192 44438.7 0; : 62 Minimum Test error found - save the configuration ; : 62 | 18675.1 17508.4 0.0197937 0.00177252 44392.2 0; : 63 Minimum Test error found - save the configuration ; : 63 | 18512.9 17340.5 0.019822 0.0017786 44337.4 0; : 64 Minimum Test error found - save the configuration ; : 64 | 18353.5 17179.2 0.0198469 0.00178029 44280.6 0; : 65 Minimum Test error found - save the configuration ; : 65 | 18201.3 17035.2 0.0198777 0.00178599 44219.2 0; : 66 Minimum Test error found - save the configuration ; : 66 | 18048.3 16883.1 0.019869 0.0017844 44236.5 0; : 67 Minimum Test error found - save the configuration ; : 67 | 17898.4 16736.1 0.0198962 0.00180855 44229.1 0; : 68 Minimum Test error found - save the configuration ; : 68 | 17745 16589.7 0.0198886 0.00178724 44195.6 0; : 69 Minimum Test error found - save the configuration ; : 69 | 17598.1 16441.7 0.0198822 0.00177929 44191.7 0; : 70 Minimum Test error found - save the configuration ; : 70 | 17446.3 16297.7 0.0199037 0.00178336 44149.4 0; : 71 Minimum Test error found - save the configuration ; : 71 | 17299.3 16156.1 0.0199217 0.00177946 44096 0; : 72 Minimum Test error found - save the configuration ; : 72 | 17155.5 16013.3 0.0198893 0.00178782 44195.4 0; : 73 Minimum Test error found - save the configuration ; : 73 | 17008.7 15875.5 0.0199043 0.00178745 44157.9 0; : 74 Minimum Test error found - save the configuration ; : 74 | 16868.3 15734.7 0.0199692 0.00179417 44016.4 0; : 75 Minimum Test error found - save the configuration ; : 75 | 16724.2 15597.7 0.0199149 0.00178949 44136.9 0; : 76 Minimum Test error found - save the configuration ; : 76 | 16584 15460 0.0199224 0.00178826 44115.8 0; : 77 Minimum Test error found - save the configuration ; : 77 | 16444.4 15323.6 0.0199118 0.00178921 44143.8 0; : 78 Minimum Test error found -,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:18787,configurat,configuration,18787,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['configurat'],['configuration']
Deployability,ve the configuration ; : 61 | 18829.3 17664.6 0.0197742 0.00177192 44438.7 0; : 62 Minimum Test error found - save the configuration ; : 62 | 18675.1 17508.4 0.0197937 0.00177252 44392.2 0; : 63 Minimum Test error found - save the configuration ; : 63 | 18512.9 17340.5 0.019822 0.0017786 44337.4 0; : 64 Minimum Test error found - save the configuration ; : 64 | 18353.5 17179.2 0.0198469 0.00178029 44280.6 0; : 65 Minimum Test error found - save the configuration ; : 65 | 18201.3 17035.2 0.0198777 0.00178599 44219.2 0; : 66 Minimum Test error found - save the configuration ; : 66 | 18048.3 16883.1 0.019869 0.0017844 44236.5 0; : 67 Minimum Test error found - save the configuration ; : 67 | 17898.4 16736.1 0.0198962 0.00180855 44229.1 0; : 68 Minimum Test error found - save the configuration ; : 68 | 17745 16589.7 0.0198886 0.00178724 44195.6 0; : 69 Minimum Test error found - save the configuration ; : 69 | 17598.1 16441.7 0.0198822 0.00177929 44191.7 0; : 70 Minimum Test error found - save the configuration ; : 70 | 17446.3 16297.7 0.0199037 0.00178336 44149.4 0; : 71 Minimum Test error found - save the configuration ; : 71 | 17299.3 16156.1 0.0199217 0.00177946 44096 0; : 72 Minimum Test error found - save the configuration ; : 72 | 17155.5 16013.3 0.0198893 0.00178782 44195.4 0; : 73 Minimum Test error found - save the configuration ; : 73 | 17008.7 15875.5 0.0199043 0.00178745 44157.9 0; : 74 Minimum Test error found - save the configuration ; : 74 | 16868.3 15734.7 0.0199692 0.00179417 44016.4 0; : 75 Minimum Test error found - save the configuration ; : 75 | 16724.2 15597.7 0.0199149 0.00178949 44136.9 0; : 76 Minimum Test error found - save the configuration ; : 76 | 16584 15460 0.0199224 0.00178826 44115.8 0; : 77 Minimum Test error found - save the configuration ; : 77 | 16444.4 15323.6 0.0199118 0.00178921 44143.8 0; : 78 Minimum Test error found - save the configuration ; : 78 | 16305.9 15188.8 0.0201885 0.00179593 43495.8 0; : 79 Minimum Test error found -,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:18899,configurat,configuration,18899,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['configurat'],['configuration']
Deployability,ve the configuration ; : 62 | 18675.1 17508.4 0.0197937 0.00177252 44392.2 0; : 63 Minimum Test error found - save the configuration ; : 63 | 18512.9 17340.5 0.019822 0.0017786 44337.4 0; : 64 Minimum Test error found - save the configuration ; : 64 | 18353.5 17179.2 0.0198469 0.00178029 44280.6 0; : 65 Minimum Test error found - save the configuration ; : 65 | 18201.3 17035.2 0.0198777 0.00178599 44219.2 0; : 66 Minimum Test error found - save the configuration ; : 66 | 18048.3 16883.1 0.019869 0.0017844 44236.5 0; : 67 Minimum Test error found - save the configuration ; : 67 | 17898.4 16736.1 0.0198962 0.00180855 44229.1 0; : 68 Minimum Test error found - save the configuration ; : 68 | 17745 16589.7 0.0198886 0.00178724 44195.6 0; : 69 Minimum Test error found - save the configuration ; : 69 | 17598.1 16441.7 0.0198822 0.00177929 44191.7 0; : 70 Minimum Test error found - save the configuration ; : 70 | 17446.3 16297.7 0.0199037 0.00178336 44149.4 0; : 71 Minimum Test error found - save the configuration ; : 71 | 17299.3 16156.1 0.0199217 0.00177946 44096 0; : 72 Minimum Test error found - save the configuration ; : 72 | 17155.5 16013.3 0.0198893 0.00178782 44195.4 0; : 73 Minimum Test error found - save the configuration ; : 73 | 17008.7 15875.5 0.0199043 0.00178745 44157.9 0; : 74 Minimum Test error found - save the configuration ; : 74 | 16868.3 15734.7 0.0199692 0.00179417 44016.4 0; : 75 Minimum Test error found - save the configuration ; : 75 | 16724.2 15597.7 0.0199149 0.00178949 44136.9 0; : 76 Minimum Test error found - save the configuration ; : 76 | 16584 15460 0.0199224 0.00178826 44115.8 0; : 77 Minimum Test error found - save the configuration ; : 77 | 16444.4 15323.6 0.0199118 0.00178921 44143.8 0; : 78 Minimum Test error found - save the configuration ; : 78 | 16305.9 15188.8 0.0201885 0.00179593 43495.8 0; : 79 Minimum Test error found - save the configuration ; : 79 | 16166.6 15057.4 0.0199259 0.00179169 44115.6 0; : 80 Minimum Test error found -,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:19011,configurat,configuration,19011,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['configurat'],['configuration']
Deployability,ve the configuration ; : 64 | 18353.5 17179.2 0.0198469 0.00178029 44280.6 0; : 65 Minimum Test error found - save the configuration ; : 65 | 18201.3 17035.2 0.0198777 0.00178599 44219.2 0; : 66 Minimum Test error found - save the configuration ; : 66 | 18048.3 16883.1 0.019869 0.0017844 44236.5 0; : 67 Minimum Test error found - save the configuration ; : 67 | 17898.4 16736.1 0.0198962 0.00180855 44229.1 0; : 68 Minimum Test error found - save the configuration ; : 68 | 17745 16589.7 0.0198886 0.00178724 44195.6 0; : 69 Minimum Test error found - save the configuration ; : 69 | 17598.1 16441.7 0.0198822 0.00177929 44191.7 0; : 70 Minimum Test error found - save the configuration ; : 70 | 17446.3 16297.7 0.0199037 0.00178336 44149.4 0; : 71 Minimum Test error found - save the configuration ; : 71 | 17299.3 16156.1 0.0199217 0.00177946 44096 0; : 72 Minimum Test error found - save the configuration ; : 72 | 17155.5 16013.3 0.0198893 0.00178782 44195.4 0; : 73 Minimum Test error found - save the configuration ; : 73 | 17008.7 15875.5 0.0199043 0.00178745 44157.9 0; : 74 Minimum Test error found - save the configuration ; : 74 | 16868.3 15734.7 0.0199692 0.00179417 44016.4 0; : 75 Minimum Test error found - save the configuration ; : 75 | 16724.2 15597.7 0.0199149 0.00178949 44136.9 0; : 76 Minimum Test error found - save the configuration ; : 76 | 16584 15460 0.0199224 0.00178826 44115.8 0; : 77 Minimum Test error found - save the configuration ; : 77 | 16444.4 15323.6 0.0199118 0.00178921 44143.8 0; : 78 Minimum Test error found - save the configuration ; : 78 | 16305.9 15188.8 0.0201885 0.00179593 43495.8 0; : 79 Minimum Test error found - save the configuration ; : 79 | 16166.6 15057.4 0.0199259 0.00179169 44115.6 0; : 80 Minimum Test error found - save the configuration ; : 80 | 16031 14926.5 0.0199332 0.00179406 44103.6 0; : 81 Minimum Test error found - save the configuration ; : 81 | 15897.7 14793.4 0.0199416 0.00179024 44073.9 0; : 82 Minimum Test error found -,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:19233,configurat,configuration,19233,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['configurat'],['configuration']
Deployability,ve the configuration ; : 65 | 18201.3 17035.2 0.0198777 0.00178599 44219.2 0; : 66 Minimum Test error found - save the configuration ; : 66 | 18048.3 16883.1 0.019869 0.0017844 44236.5 0; : 67 Minimum Test error found - save the configuration ; : 67 | 17898.4 16736.1 0.0198962 0.00180855 44229.1 0; : 68 Minimum Test error found - save the configuration ; : 68 | 17745 16589.7 0.0198886 0.00178724 44195.6 0; : 69 Minimum Test error found - save the configuration ; : 69 | 17598.1 16441.7 0.0198822 0.00177929 44191.7 0; : 70 Minimum Test error found - save the configuration ; : 70 | 17446.3 16297.7 0.0199037 0.00178336 44149.4 0; : 71 Minimum Test error found - save the configuration ; : 71 | 17299.3 16156.1 0.0199217 0.00177946 44096 0; : 72 Minimum Test error found - save the configuration ; : 72 | 17155.5 16013.3 0.0198893 0.00178782 44195.4 0; : 73 Minimum Test error found - save the configuration ; : 73 | 17008.7 15875.5 0.0199043 0.00178745 44157.9 0; : 74 Minimum Test error found - save the configuration ; : 74 | 16868.3 15734.7 0.0199692 0.00179417 44016.4 0; : 75 Minimum Test error found - save the configuration ; : 75 | 16724.2 15597.7 0.0199149 0.00178949 44136.9 0; : 76 Minimum Test error found - save the configuration ; : 76 | 16584 15460 0.0199224 0.00178826 44115.8 0; : 77 Minimum Test error found - save the configuration ; : 77 | 16444.4 15323.6 0.0199118 0.00178921 44143.8 0; : 78 Minimum Test error found - save the configuration ; : 78 | 16305.9 15188.8 0.0201885 0.00179593 43495.8 0; : 79 Minimum Test error found - save the configuration ; : 79 | 16166.6 15057.4 0.0199259 0.00179169 44115.6 0; : 80 Minimum Test error found - save the configuration ; : 80 | 16031 14926.5 0.0199332 0.00179406 44103.6 0; : 81 Minimum Test error found - save the configuration ; : 81 | 15897.7 14793.4 0.0199416 0.00179024 44073.9 0; : 82 Minimum Test error found - save the configuration ; : 82 | 15763.4 14662.5 0.0199481 0.00178931 44055.8 0; : 83 Minimum Test error found -,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:19345,configurat,configuration,19345,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['configurat'],['configuration']
Deployability,ve the configuration ; : 66 | 18048.3 16883.1 0.019869 0.0017844 44236.5 0; : 67 Minimum Test error found - save the configuration ; : 67 | 17898.4 16736.1 0.0198962 0.00180855 44229.1 0; : 68 Minimum Test error found - save the configuration ; : 68 | 17745 16589.7 0.0198886 0.00178724 44195.6 0; : 69 Minimum Test error found - save the configuration ; : 69 | 17598.1 16441.7 0.0198822 0.00177929 44191.7 0; : 70 Minimum Test error found - save the configuration ; : 70 | 17446.3 16297.7 0.0199037 0.00178336 44149.4 0; : 71 Minimum Test error found - save the configuration ; : 71 | 17299.3 16156.1 0.0199217 0.00177946 44096 0; : 72 Minimum Test error found - save the configuration ; : 72 | 17155.5 16013.3 0.0198893 0.00178782 44195.4 0; : 73 Minimum Test error found - save the configuration ; : 73 | 17008.7 15875.5 0.0199043 0.00178745 44157.9 0; : 74 Minimum Test error found - save the configuration ; : 74 | 16868.3 15734.7 0.0199692 0.00179417 44016.4 0; : 75 Minimum Test error found - save the configuration ; : 75 | 16724.2 15597.7 0.0199149 0.00178949 44136.9 0; : 76 Minimum Test error found - save the configuration ; : 76 | 16584 15460 0.0199224 0.00178826 44115.8 0; : 77 Minimum Test error found - save the configuration ; : 77 | 16444.4 15323.6 0.0199118 0.00178921 44143.8 0; : 78 Minimum Test error found - save the configuration ; : 78 | 16305.9 15188.8 0.0201885 0.00179593 43495.8 0; : 79 Minimum Test error found - save the configuration ; : 79 | 16166.6 15057.4 0.0199259 0.00179169 44115.6 0; : 80 Minimum Test error found - save the configuration ; : 80 | 16031 14926.5 0.0199332 0.00179406 44103.6 0; : 81 Minimum Test error found - save the configuration ; : 81 | 15897.7 14793.4 0.0199416 0.00179024 44073.9 0; : 82 Minimum Test error found - save the configuration ; : 82 | 15763.4 14662.5 0.0199481 0.00178931 44055.8 0; : 83 Minimum Test error found - save the configuration ; : 83 | 15630.7 14533.2 0.019931 0.00179081 44101 0; : 84 Minimum Test error found - sa,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:19457,configurat,configuration,19457,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['configurat'],['configuration']
Deployability,ve the configuration ; : 69 | 17598.1 16441.7 0.0198822 0.00177929 44191.7 0; : 70 Minimum Test error found - save the configuration ; : 70 | 17446.3 16297.7 0.0199037 0.00178336 44149.4 0; : 71 Minimum Test error found - save the configuration ; : 71 | 17299.3 16156.1 0.0199217 0.00177946 44096 0; : 72 Minimum Test error found - save the configuration ; : 72 | 17155.5 16013.3 0.0198893 0.00178782 44195.4 0; : 73 Minimum Test error found - save the configuration ; : 73 | 17008.7 15875.5 0.0199043 0.00178745 44157.9 0; : 74 Minimum Test error found - save the configuration ; : 74 | 16868.3 15734.7 0.0199692 0.00179417 44016.4 0; : 75 Minimum Test error found - save the configuration ; : 75 | 16724.2 15597.7 0.0199149 0.00178949 44136.9 0; : 76 Minimum Test error found - save the configuration ; : 76 | 16584 15460 0.0199224 0.00178826 44115.8 0; : 77 Minimum Test error found - save the configuration ; : 77 | 16444.4 15323.6 0.0199118 0.00178921 44143.8 0; : 78 Minimum Test error found - save the configuration ; : 78 | 16305.9 15188.8 0.0201885 0.00179593 43495.8 0; : 79 Minimum Test error found - save the configuration ; : 79 | 16166.6 15057.4 0.0199259 0.00179169 44115.6 0; : 80 Minimum Test error found - save the configuration ; : 80 | 16031 14926.5 0.0199332 0.00179406 44103.6 0; : 81 Minimum Test error found - save the configuration ; : 81 | 15897.7 14793.4 0.0199416 0.00179024 44073.9 0; : 82 Minimum Test error found - save the configuration ; : 82 | 15763.4 14662.5 0.0199481 0.00178931 44055.8 0; : 83 Minimum Test error found - save the configuration ; : 83 | 15630.7 14533.2 0.019931 0.00179081 44101 0; : 84 Minimum Test error found - save the configuration ; : 84 | 15500.1 14404.7 0.0199524 0.00179281 44053.8 0; : 85 Minimum Test error found - save the configuration ; : 85 | 15368.8 14279.5 0.0199675 0.00179204 44015.4 0; : 86 Minimum Test error found - save the configuration ; : 86 | 15239.7 14153.7 0.0199843 0.00181623 44033.3 0; : 87 Minimum Test error found ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:19789,configurat,configuration,19789,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['configurat'],['configuration']
Deployability,ve the configuration ; : 70 | 17446.3 16297.7 0.0199037 0.00178336 44149.4 0; : 71 Minimum Test error found - save the configuration ; : 71 | 17299.3 16156.1 0.0199217 0.00177946 44096 0; : 72 Minimum Test error found - save the configuration ; : 72 | 17155.5 16013.3 0.0198893 0.00178782 44195.4 0; : 73 Minimum Test error found - save the configuration ; : 73 | 17008.7 15875.5 0.0199043 0.00178745 44157.9 0; : 74 Minimum Test error found - save the configuration ; : 74 | 16868.3 15734.7 0.0199692 0.00179417 44016.4 0; : 75 Minimum Test error found - save the configuration ; : 75 | 16724.2 15597.7 0.0199149 0.00178949 44136.9 0; : 76 Minimum Test error found - save the configuration ; : 76 | 16584 15460 0.0199224 0.00178826 44115.8 0; : 77 Minimum Test error found - save the configuration ; : 77 | 16444.4 15323.6 0.0199118 0.00178921 44143.8 0; : 78 Minimum Test error found - save the configuration ; : 78 | 16305.9 15188.8 0.0201885 0.00179593 43495.8 0; : 79 Minimum Test error found - save the configuration ; : 79 | 16166.6 15057.4 0.0199259 0.00179169 44115.6 0; : 80 Minimum Test error found - save the configuration ; : 80 | 16031 14926.5 0.0199332 0.00179406 44103.6 0; : 81 Minimum Test error found - save the configuration ; : 81 | 15897.7 14793.4 0.0199416 0.00179024 44073.9 0; : 82 Minimum Test error found - save the configuration ; : 82 | 15763.4 14662.5 0.0199481 0.00178931 44055.8 0; : 83 Minimum Test error found - save the configuration ; : 83 | 15630.7 14533.2 0.019931 0.00179081 44101 0; : 84 Minimum Test error found - save the configuration ; : 84 | 15500.1 14404.7 0.0199524 0.00179281 44053.8 0; : 85 Minimum Test error found - save the configuration ; : 85 | 15368.8 14279.5 0.0199675 0.00179204 44015.4 0; : 86 Minimum Test error found - save the configuration ; : 86 | 15239.7 14153.7 0.0199843 0.00181623 44033.3 0; : 87 Minimum Test error found - save the configuration ; : 87 | 15114.3 14026.9 0.0199836 0.00180455 44006.8 0; : 88 Minimum Test error found ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:19901,configurat,configuration,19901,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['configurat'],['configuration']
Deployability,ve the configuration ; : 72 | 17155.5 16013.3 0.0198893 0.00178782 44195.4 0; : 73 Minimum Test error found - save the configuration ; : 73 | 17008.7 15875.5 0.0199043 0.00178745 44157.9 0; : 74 Minimum Test error found - save the configuration ; : 74 | 16868.3 15734.7 0.0199692 0.00179417 44016.4 0; : 75 Minimum Test error found - save the configuration ; : 75 | 16724.2 15597.7 0.0199149 0.00178949 44136.9 0; : 76 Minimum Test error found - save the configuration ; : 76 | 16584 15460 0.0199224 0.00178826 44115.8 0; : 77 Minimum Test error found - save the configuration ; : 77 | 16444.4 15323.6 0.0199118 0.00178921 44143.8 0; : 78 Minimum Test error found - save the configuration ; : 78 | 16305.9 15188.8 0.0201885 0.00179593 43495.8 0; : 79 Minimum Test error found - save the configuration ; : 79 | 16166.6 15057.4 0.0199259 0.00179169 44115.6 0; : 80 Minimum Test error found - save the configuration ; : 80 | 16031 14926.5 0.0199332 0.00179406 44103.6 0; : 81 Minimum Test error found - save the configuration ; : 81 | 15897.7 14793.4 0.0199416 0.00179024 44073.9 0; : 82 Minimum Test error found - save the configuration ; : 82 | 15763.4 14662.5 0.0199481 0.00178931 44055.8 0; : 83 Minimum Test error found - save the configuration ; : 83 | 15630.7 14533.2 0.019931 0.00179081 44101 0; : 84 Minimum Test error found - save the configuration ; : 84 | 15500.1 14404.7 0.0199524 0.00179281 44053.8 0; : 85 Minimum Test error found - save the configuration ; : 85 | 15368.8 14279.5 0.0199675 0.00179204 44015.4 0; : 86 Minimum Test error found - save the configuration ; : 86 | 15239.7 14153.7 0.0199843 0.00181623 44033.3 0; : 87 Minimum Test error found - save the configuration ; : 87 | 15114.3 14026.9 0.0199836 0.00180455 44006.8 0; : 88 Minimum Test error found - save the configuration ; : 88 | 14984.6 13906.4 0.01996 0.00179383 44038 0; : 89 Minimum Test error found - save the configuration ; : 89 | 14861.1 13782.6 0.0200963 0.00185792 43863.5 0; : 90 Minimum Test error found - ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:20123,configurat,configuration,20123,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['configurat'],['configuration']
Deployability,ve the configuration ; : 73 | 17008.7 15875.5 0.0199043 0.00178745 44157.9 0; : 74 Minimum Test error found - save the configuration ; : 74 | 16868.3 15734.7 0.0199692 0.00179417 44016.4 0; : 75 Minimum Test error found - save the configuration ; : 75 | 16724.2 15597.7 0.0199149 0.00178949 44136.9 0; : 76 Minimum Test error found - save the configuration ; : 76 | 16584 15460 0.0199224 0.00178826 44115.8 0; : 77 Minimum Test error found - save the configuration ; : 77 | 16444.4 15323.6 0.0199118 0.00178921 44143.8 0; : 78 Minimum Test error found - save the configuration ; : 78 | 16305.9 15188.8 0.0201885 0.00179593 43495.8 0; : 79 Minimum Test error found - save the configuration ; : 79 | 16166.6 15057.4 0.0199259 0.00179169 44115.6 0; : 80 Minimum Test error found - save the configuration ; : 80 | 16031 14926.5 0.0199332 0.00179406 44103.6 0; : 81 Minimum Test error found - save the configuration ; : 81 | 15897.7 14793.4 0.0199416 0.00179024 44073.9 0; : 82 Minimum Test error found - save the configuration ; : 82 | 15763.4 14662.5 0.0199481 0.00178931 44055.8 0; : 83 Minimum Test error found - save the configuration ; : 83 | 15630.7 14533.2 0.019931 0.00179081 44101 0; : 84 Minimum Test error found - save the configuration ; : 84 | 15500.1 14404.7 0.0199524 0.00179281 44053.8 0; : 85 Minimum Test error found - save the configuration ; : 85 | 15368.8 14279.5 0.0199675 0.00179204 44015.4 0; : 86 Minimum Test error found - save the configuration ; : 86 | 15239.7 14153.7 0.0199843 0.00181623 44033.3 0; : 87 Minimum Test error found - save the configuration ; : 87 | 15114.3 14026.9 0.0199836 0.00180455 44006.8 0; : 88 Minimum Test error found - save the configuration ; : 88 | 14984.6 13906.4 0.01996 0.00179383 44038 0; : 89 Minimum Test error found - save the configuration ; : 89 | 14861.1 13782.6 0.0200963 0.00185792 43863.5 0; : 90 Minimum Test error found - save the configuration ; : 90 | 14737.4 13659.4 0.0204557 0.00186757 43038.2 0; : 91 Minimum Test error found - ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:20235,configurat,configuration,20235,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['configurat'],['configuration']
Deployability,ve the configuration ; : 74 | 16868.3 15734.7 0.0199692 0.00179417 44016.4 0; : 75 Minimum Test error found - save the configuration ; : 75 | 16724.2 15597.7 0.0199149 0.00178949 44136.9 0; : 76 Minimum Test error found - save the configuration ; : 76 | 16584 15460 0.0199224 0.00178826 44115.8 0; : 77 Minimum Test error found - save the configuration ; : 77 | 16444.4 15323.6 0.0199118 0.00178921 44143.8 0; : 78 Minimum Test error found - save the configuration ; : 78 | 16305.9 15188.8 0.0201885 0.00179593 43495.8 0; : 79 Minimum Test error found - save the configuration ; : 79 | 16166.6 15057.4 0.0199259 0.00179169 44115.6 0; : 80 Minimum Test error found - save the configuration ; : 80 | 16031 14926.5 0.0199332 0.00179406 44103.6 0; : 81 Minimum Test error found - save the configuration ; : 81 | 15897.7 14793.4 0.0199416 0.00179024 44073.9 0; : 82 Minimum Test error found - save the configuration ; : 82 | 15763.4 14662.5 0.0199481 0.00178931 44055.8 0; : 83 Minimum Test error found - save the configuration ; : 83 | 15630.7 14533.2 0.019931 0.00179081 44101 0; : 84 Minimum Test error found - save the configuration ; : 84 | 15500.1 14404.7 0.0199524 0.00179281 44053.8 0; : 85 Minimum Test error found - save the configuration ; : 85 | 15368.8 14279.5 0.0199675 0.00179204 44015.4 0; : 86 Minimum Test error found - save the configuration ; : 86 | 15239.7 14153.7 0.0199843 0.00181623 44033.3 0; : 87 Minimum Test error found - save the configuration ; : 87 | 15114.3 14026.9 0.0199836 0.00180455 44006.8 0; : 88 Minimum Test error found - save the configuration ; : 88 | 14984.6 13906.4 0.01996 0.00179383 44038 0; : 89 Minimum Test error found - save the configuration ; : 89 | 14861.1 13782.6 0.0200963 0.00185792 43863.5 0; : 90 Minimum Test error found - save the configuration ; : 90 | 14737.4 13659.4 0.0204557 0.00186757 43038.2 0; : 91 Minimum Test error found - save the configuration ; : 91 | 14612.9 13539.6 0.0208154 0.00188863 42268.3 0; : 92 Minimum Test error found - ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:20347,configurat,configuration,20347,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['configurat'],['configuration']
Deployability,ve the configuration ; : 8 | 29852.4 28319.6 0.0206438 0.00186969 42611.9 0; : 9 Minimum Test error found - save the configuration ; : 9 | 29498.2 28000.3 0.0204359 0.0018446 43030.8 0; : 10 Minimum Test error found - save the configuration ; : 10 | 29182.7 27696.8 0.0202998 0.00181461 43277.8 0; : 11 Minimum Test error found - save the configuration ; : 11 | 28878.3 27413.2 0.0196838 0.00176755 44652.2 0; : 12 Minimum Test error found - save the configuration ; : 12 | 28593.7 27134.7 0.0196593 0.00176089 44696.8 0; : 13 Minimum Test error found - save the configuration ; : 13 | 28310.5 26871.8 0.0196662 0.00176724 44695.4 0; : 14 Minimum Test error found - save the configuration ; : 14 | 28043.7 26610.8 0.019761 0.00176915 44464.7 0; : 15 Minimum Test error found - save the configuration ; : 15 | 27781.4 26354.5 0.0197825 0.0017915 44466.6 0; : 16 Minimum Test error found - save the configuration ; : 16 | 27524.2 26104.3 0.0196926 0.00175551 44600.3 0; : 17 Minimum Test error found - save the configuration ; : 17 | 27271.4 25860.7 0.0197778 0.00177907 44447.7 0; : 18 Minimum Test error found - save the configuration ; : 18 | 27023.6 25622.6 0.0197311 0.00176281 44522.9 0; : 19 Minimum Test error found - save the configuration ; : 19 | 26780.6 25388.8 0.0197339 0.00176163 44513.1 0; : 20 Minimum Test error found - save the configuration ; : 20 | 26542.7 25157.4 0.0198818 0.0018763 44431 0; : 21 Minimum Test error found - save the configuration ; : 21 | 26311 24925.1 0.0199584 0.00175652 43951.6 0; : 22 Minimum Test error found - save the configuration ; : 22 | 26076.9 24700.5 0.0197873 0.00176359 44385.9 0; : 23 Minimum Test error found - save the configuration ; : 23 | 25845.4 24483.8 0.0196702 0.00176161 44671.3 0; : 24 Minimum Test error found - save the configuration ; : 24 | 25624.1 24264.1 0.0196853 0.00176075 44631.5 0; : 25 Minimum Test error found - save the configuration ; : 25 | 25402.4 24046.8 0.0199052 0.00182376 44244.2 0; : 26 Minimum Test error found ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:13000,configurat,configuration,13000,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['configurat'],['configuration']
Deployability,ve the configuration ; : 85 | 15368.8 14279.5 0.0199675 0.00179204 44015.4 0; : 86 Minimum Test error found - save the configuration ; : 86 | 15239.7 14153.7 0.0199843 0.00181623 44033.3 0; : 87 Minimum Test error found - save the configuration ; : 87 | 15114.3 14026.9 0.0199836 0.00180455 44006.8 0; : 88 Minimum Test error found - save the configuration ; : 88 | 14984.6 13906.4 0.01996 0.00179383 44038 0; : 89 Minimum Test error found - save the configuration ; : 89 | 14861.1 13782.6 0.0200963 0.00185792 43863.5 0; : 90 Minimum Test error found - save the configuration ; : 90 | 14737.4 13659.4 0.0204557 0.00186757 43038.2 0; : 91 Minimum Test error found - save the configuration ; : 91 | 14612.9 13539.6 0.0208154 0.00188863 42268.3 0; : 92 Minimum Test error found - save the configuration ; : 92 | 14490.4 13421.6 0.0202522 0.00182164 43406.2 0; : 93 Minimum Test error found - save the configuration ; : 93 | 14371 13301.8 0.0200599 0.00180046 43813.1 0; : 94 Minimum Test error found - save the configuration ; : 94 | 14248.9 13186.1 0.0201736 0.00184165 43639.6 0; : 95 Minimum Test error found - save the configuration ; : 95 | 14131.5 13069.6 0.020175 0.00181418 43571 0; : 96 Minimum Test error found - save the configuration ; : 96 | 14014.5 12952.5 0.0201885 0.00182372 43561.6 0; : 97 Minimum Test error found - save the configuration ; : 97 | 13896.7 12838.4 0.0200385 0.00180689 43879.7 0; : 98 Minimum Test error found - save the configuration ; : 98 | 13782 12723.6 0.020062 0.00182418 43864.8 0; : 99 Minimum Test error found - save the configuration ; : 99 | 13666.4 12611.1 0.0200618 0.00180714 43824.4 0; : 100 Minimum Test error found - save the configuration ; : 100 | 13550.9 12502.3 0.0200464 0.00180511 43856.6 0; : 101 Minimum Test error found - save the configuration ; : 101 | 13439.7 12392 0.0201571 0.00185957 43721.7 0; : 102 Minimum Test error found - save the configuration ; : 102 | 13328.8 12281.3 0.0202143 0.00181888 43489.1 0; : 103 Minimum Test error fo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:21570,configurat,configuration,21570,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['configurat'],['configuration']
Deployability,ve the configuration ; : 86 | 15239.7 14153.7 0.0199843 0.00181623 44033.3 0; : 87 Minimum Test error found - save the configuration ; : 87 | 15114.3 14026.9 0.0199836 0.00180455 44006.8 0; : 88 Minimum Test error found - save the configuration ; : 88 | 14984.6 13906.4 0.01996 0.00179383 44038 0; : 89 Minimum Test error found - save the configuration ; : 89 | 14861.1 13782.6 0.0200963 0.00185792 43863.5 0; : 90 Minimum Test error found - save the configuration ; : 90 | 14737.4 13659.4 0.0204557 0.00186757 43038.2 0; : 91 Minimum Test error found - save the configuration ; : 91 | 14612.9 13539.6 0.0208154 0.00188863 42268.3 0; : 92 Minimum Test error found - save the configuration ; : 92 | 14490.4 13421.6 0.0202522 0.00182164 43406.2 0; : 93 Minimum Test error found - save the configuration ; : 93 | 14371 13301.8 0.0200599 0.00180046 43813.1 0; : 94 Minimum Test error found - save the configuration ; : 94 | 14248.9 13186.1 0.0201736 0.00184165 43639.6 0; : 95 Minimum Test error found - save the configuration ; : 95 | 14131.5 13069.6 0.020175 0.00181418 43571 0; : 96 Minimum Test error found - save the configuration ; : 96 | 14014.5 12952.5 0.0201885 0.00182372 43561.6 0; : 97 Minimum Test error found - save the configuration ; : 97 | 13896.7 12838.4 0.0200385 0.00180689 43879.7 0; : 98 Minimum Test error found - save the configuration ; : 98 | 13782 12723.6 0.020062 0.00182418 43864.8 0; : 99 Minimum Test error found - save the configuration ; : 99 | 13666.4 12611.1 0.0200618 0.00180714 43824.4 0; : 100 Minimum Test error found - save the configuration ; : 100 | 13550.9 12502.3 0.0200464 0.00180511 43856.6 0; : 101 Minimum Test error found - save the configuration ; : 101 | 13439.7 12392 0.0201571 0.00185957 43721.7 0; : 102 Minimum Test error found - save the configuration ; : 102 | 13328.8 12281.3 0.0202143 0.00181888 43489.1 0; : 103 Minimum Test error found - save the configuration ; : 103 | 13217 12173.3 0.0200026 0.0018059 43964.1 0; : 104 Minimum Test error fou,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:21682,configurat,configuration,21682,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['configurat'],['configuration']
Deployability,"ve tree header every fAutoSave bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; If fAutoSave is negative, AutoSave is automatically called by; TTree::Fill when the number of bytes generated since the previous; AutoSave is greater than -fAutoSave bytes.; If fAutoSave is positive, AutoSave is automatically called by; TTree::Fill every N entries.; This function may also be invoked by the user.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The follo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:42104,UPDATE,UPDATE,42104,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['UPDATE'],['UPDATE']
Deployability,"veCalo3DGL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tAlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidDrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* ps, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveCalo3DGL.html:2327,Update,UpdateBoundingBox,2327,root/html532/TEveCalo3DGL.html,https://root.cern,https://root.cern/root/html532/TEveCalo3DGL.html,2,['Update'],"['UpdateBoundingBox', 'UpdateBoundingBoxesOfPhysicals']"
Deployability,"veElement::SetRnrChildren(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelf(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelfChildren(Bool_t rnr_self, Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidTEveElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); voidSetTubeR(Float_t x); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector& insp); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; virtual voidTAtt3D::Sizeof3D() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveArrow.html:14991,update,update,14991,root/html528/TEveArrow.html,https://root.cern,https://root.cern/root/html528/TEveArrow.html,8,['update'],['update']
Deployability,"veElement::SetRnrState(Bool_t rnr); voidTEveCaloData::SetSliceColor(Int_t slice, Color_t col); voidTEveCaloData::SetSliceThreshold(Int_t slice, Float_t threshold); voidTEveCaloData::SetSliceTransparency(Int_t slice, Char_t t); voidTEveElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); voidTEveCaloData::SetWrapTwoPi(Bool_t w); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveCaloData::UnHighlighted(); virtual voidTEveCaloData::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveCaloDataHist.html:16620,update,update,16620,root/html534/TEveCaloDataHist.html,https://root.cern,https://root.cern/root/html534/TEveCaloDataHist.html,8,['update'],['update']
Deployability,"veElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTEveWindow::SwapWindow(TEveWindow* w); static voidTEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2); voidTEveWindow::SwapWindowWithCurrent()MENU ; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; voidTEveWindow::TitleBarClicked(); voidTEveWindow::UndockWindow()MENU ; voidTEveWindow::UndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveWindowFrame.html:17493,update,update,17493,root/html534/TEveWindowFrame.html,https://root.cern,https://root.cern/root/html534/TEveWindowFrame.html,8,['update'],['update']
Deployability,"veIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.0000000000000001E-9, double relTol = 1.0000000000000001E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options. » Author: M. Slawinska 08/2007 » Copyright (c) 2007 , LCG ROOT MathLib Team *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:21; This page has been automatically generated. For comments or suggestions rega",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__AdaptiveIntegratorMultiDim.html:7096,integrat,integration,7096,root/html602/ROOT__Math__AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__AdaptiveIntegratorMultiDim.html,2,['integrat'],['integration']
Deployability,"veIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.0000000000000001E-9, double relTol = 1.0000000000000001E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options. » Author: M. Slawinska 08/2007 » Copyright (c) 2007 , LCG ROOT MathLib Team *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:33; This page has been automatically generated. For comments or suggestions rega",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__AdaptiveIntegratorMultiDim.html:7096,integrat,integration,7096,root/html604/ROOT__Math__AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__AdaptiveIntegratorMultiDim.html,2,['integrat'],['integration']
Deployability,"vePoint(Int_t ipoint); virtual voidTAttFill::ResetAttFill(Option_t* option = """"); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); virtual voidTAttMarker::ResetAttMarker(Option_t* toption = """"); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTAttMarker::SaveMarkerAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t sizdef = 1); virtual voidTGraphErrors::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTGraph::Set(Int_t n); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTGraph::SetEditable(Bool_t editable = kTRUE)TOGGLE GETTER ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTGraph::SetHistogram(TH1F* h); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTAttMarker::SetMarkerAttributes()MENU ; virtual voidTAttMarker::SetMarkerColor(Color_t mcolor = 1); virtual voidTAttMarker::SetMarkerColorAlpha(Color_t mcolor, Float_t malpha); virtual voidTAttMarker::SetMarkerSize(Size_t msize = 1); virtual voidTAttMarker::SetMarkerStyle(Style_t mstyle = 1); virtual voidSetMaximum(Double_t maximum = 1); voidSetMaxPolar(Double_t maximum = 6.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraphPolar.html:10346,TOGGLE,TOGGLE,10346,root/html534/TGraphPolar.html,https://root.cern,https://root.cern/root/html534/TGraphPolar.html,3,['TOGGLE'],['TOGGLE']
Deployability,"vePointSelectorConsumer::ETreeVarType_e cs); voidTEveElement::SetSourceObject(TObject* o); virtual voidTEvePointSet::SetTitle(const char* t); virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTPolyMarker3D::Size() const; virtual voidTAtt3D::Sizeof3D() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTEvePointSet::TakeAction(TEvePointSelector*); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveProjected::UnRefProjectable(TEveProjectable* assumed_parent, bool notifyParent = true); virtual voidTEveElement::UnSelected(); virtual voidUpdateProjection(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveLine::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveLineProjected.html:22645,update,update,22645,root/html534/TEveLineProjected.html,https://root.cern,https://root.cern/root/html534/TEveLineProjected.html,4,['update'],['update']
Deployability,"vePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetExitStatus(TVirtualProofPlayer::EExitStatus st); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTProofPlayer::SetOutputFilePath(const char* fp); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofPlayerLite(TProof* proof = 0); TProofPlayerLite(const TProofPlayerLite&); virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTProofPlayer::UpdateProgressInfo(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerLite.html:11706,Update,UpdateAutoBin,11706,root/html602/TProofPlayerLite.html,https://root.cern,https://root.cern/root/html602/TProofPlayerLite.html,2,['Update'],"['UpdateAutoBin', 'UpdateProgressInfo']"
Deployability,"veProjectionManager (TEveProjection::EPType_e type=TEveProjection::kPT_Unknown);  Constructor. ;  ;  ~TEveProjectionManager () override;  Destructor. ;  ; void AddDependent (TEveElement *el);  Add el as dependent element. ;  ; void ComputeBBox () override;  Virtual from TAttBBox; fill bounding-box information. ;  ; TEveVector & GetCenter ();  ; Float_t GetCurrentDepth () const;  ; Bool_t GetImportEmpty () const;  ; TEveProjection * GetProjection ();  ; Bool_t HandleElementPaste (TEveElement *el) override;  React to element being pasted or dnd-ed. ;  ; virtual TEveElement * ImportElements (TEveElement *el, TEveElement *ext_list=nullptr);  Recursively import elements and apply projection to the newly imported objects. ;  ; virtual TEveElement * ImportElementsRecurse (TEveElement *el, TEveElement *parent);  If el is TEveProjectable add projected instance else add plain TEveElementList to parent. ;  ; TClass * IsA () const override;  ; virtual void ProjectChildren ();  Project all children recursively, update bounding-box and notify TEveManger about the scenes that have been changed. ;  ; virtual void ProjectChildrenRecurse (TEveElement *el);  Project el (via TEveProjected::UpdateProjection()) and recurse through el's children. ;  ; void RemoveDependent (TEveElement *el);  Remove el as dependent element. ;  ; void SetCenter (Float_t x, Float_t y, Float_t z);  Set projection center and rebuild projected scene. ;  ; void SetCurrentDepth (Float_t d);  ; void SetImportEmpty (Bool_t ie);  ; void SetProjection (TEveProjection::EPType_e type);  Set projection type and distortion. ;  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual Int_t SubImportChildren (TEveElement *el, TEveElement *proj_parent);  Recursively import children elements of el and apply projection to the newly imported objects. ;  ; virtual TEveElement * SubImportElements (TEveElement *el, TEveElement *proj_parent);  Recursively import elements and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveProjectionManager.html:1743,update,update,1743,doc/master/classTEveProjectionManager.html,https://root.cern,https://root.cern/doc/master/classTEveProjectionManager.html,1,['update'],['update']
Deployability,"vector for this node must have been computed.; This is automatically done by the Paint functions.; Otherwise TNode::UpdateMatrix should be called before. void Node(const char* name, const char* title, const char* shapename, Double_t x = 0, Double_t y = 0, Double_t z = 0, const char* matrixname = """", Option_t* option = """"); Add a node to the current node in this geometry. void RecursiveRemove(TObject* obj); Recursively remove object from a Geometry list. void Streamer(TBuffer& ); Stream a class object. void UpdateMatrix(TNode* node); Update global rotation matrix/translation vector for this node; this function must be called before invoking Local2Master. void UpdateTempMatrix(Double_t x = 0, Double_t y = 0, Double_t z = 0, TRotMatrix* matrix = 0); Update temp matrix. void UpdateTempMatrix(Double_t x, Double_t y, Double_t z, Double_t* matrix, Bool_t isReflection = kFALSE); Update temp matrix. void UpdateTempMatrix(Double_t* dx1, Double_t* rmat1, Double_t x, Double_t y, Double_t z, Double_t* matrix, Double_t* dxnew, Double_t* rmatnew); Compute new translation vector and global matrix. dx old translation vector; rmat old global matrix; x,y,z offset of new local system with respect to mother; dxnew new translation vector; rmatnew new global rotation matrix. TRotMatrix * GetCurrentMatrix() const. TRotMatrix * GetCurrentPosition(Double_t* x, Double_t* y, Double_t* z) const. TRotMatrix * GetCurrentPosition(Float_t* x, Float_t* y, Float_t* z) const. Bool_t GetCurrentReflection() const. void SetPosition(Double_t x, Double_t y, Double_t z). void SetPosition(Float_t x, Float_t y, Float_t z). void SetPosition(TRotMatrix* matrix, Double_t x = 0, Double_t y = 0, Double_t z = 0). void SetPosition(TRotMatrix* matrix, Float_t x, Float_t y, Float_t z). Float_t GetBomb() const; {return fBomb;}. Int_t GeomLevel() const; {return fGeomLevel;}. THashList * GetListOfShapes() const; {return fShapes;}. TList * GetListOfNodes() const; {return fNodes;}. THashList * GetListOfMaterials() const; {r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeometry.html:14047,Update,UpdateTempMatrix,14047,root/html534/TGeometry.html,https://root.cern,https://root.cern/root/html534/TGeometry.html,3,['Update'],['UpdateTempMatrix']
Deployability,"vector of events from the ROOT training tree. void PreProcessNegativeEventWeights(); o.k. you know there are events with negative event weights. This routine will remove; them by pairing them with the closest event(s) of the same event class with positive; weights; A first attempt is ""brute force"", I dont' try to be clever using search trees etc,; just quick and dirty to see if the result is any good. std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument. void Train(); BDT training. void GetRandomSubSample(); fills fEventSample with fSampleFraction*NEvents random training events. Double_t GetGradBoostMVA(TMVA::Event& e, UInt_t nTrees); returns MVA value: -1 for background, 1 for signal. void UpdateTargets(vector<TMVA::Event*> , UInt_t cls = 0); Calculate residua for all events;. void UpdateTargetsRegression(vector<TMVA::Event*> , Bool_t first = kFALSE); Calculate current residuals for all events and update targets for next iteration. Double_t GetWeightedQuantile(vector<std::pair<Double_t,Double_t> > vec, const Double_t quantile, const Double_t SumOfWeights = 0.0); calculates the quantile of the distribution of the first pair entries weighted with the values in the second pair entries. Double_t GradBoost(vector<TMVA::Event*> , TMVA::DecisionTree* dt, UInt_t cls = 0); Calculate the desired response value for each region. Double_t GradBoostRegression(vector<TMVA::Event*> , TMVA::DecisionTree* dt); Implementation of M_TreeBoost using a Huber loss function as desribed by Friedman 1999. void InitGradBoost(vector<TMVA::Event*> ); initialize targets for first tree. Double_t TestTreeQuality(TMVA::DecisionTree* dt); test the tree quality.. in terms of Miscalssification. Double_t Boost(vector<TMVA::Event*> , TMVA::DecisionT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodBDT.html:29847,Update,UpdateTargets,29847,root/html532/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodBDT.html,1,['Update'],['UpdateTargets']
Deployability,"vector< ShapeDescr > fShapes! shapes with created descriptionsDefinition RGeomData.hxx:253; ROOT::RGeomDescription::GetSearchstd::string GetSearch() constDefinition RGeomData.hxx:383; ROOT::RGeomDescription::fJsonCompint fJsonComp! default JSON compressionDefinition RGeomData.hxx:261; ROOT::RGeomDescription::ChangeNodeVisibilitybool ChangeNodeVisibility(const std::vector< std::string > &path, bool on)Change visibility for specified element Returns true if changes was performed.Definition RGeomData.cxx:1850; ROOT::RGeomDescription::SetMutexvoid SetMutex(TVirtualMutex *mutex)Set mutex, it must be recursive one.Definition RGeomData.hxx:312; ROOT::RGeomDescription::RGeomDescriptionRGeomDescription()=default; ROOT::RGeomDescription::fSearchstd::string fSearch! search string in hierarchyDefinition RGeomData.hxx:255; ROOT::RGeomDescription::fSearchJsonstd::string fSearchJson! drawing json for searchDefinition RGeomData.hxx:256; ROOT::RGeomDescription::SavePrimitivevoid SavePrimitive(std::ostream &fs, const std::string &name)Save geometry configuration as C++ macro.Definition RGeomData.cxx:2143; ROOT::RGeomDescription::fHighlightedStackstd::vector< int > fHighlightedStack! highlighted element by stackDefinition RGeomData.hxx:249; ROOT::RGeomDescription::ClearAllPhysVisibilitybool ClearAllPhysVisibility()Reset all custom visibility settings.Definition RGeomData.cxx:2089; ROOT::RGeomDescription::MakeDrawingJsonstd::string MakeDrawingJson(RGeomDrawing &drawing, bool has_shapes=false)Produce JSON for the drawing If TGeoShape appears in the drawing, one has to keep typeinfo But in thi...Definition RGeomData.cxx:1826; ROOT::RGeomDescription::fActualLevelint fActualLevel! level can be reduced when selecting nodesDefinition RGeomData.hxx:259; ROOT::RGeomDescription::GetVolumeTGeoVolume * GetVolume(int nodeid)Get volume for specified nodeid If specific volume was configured, it will be returned for nodeid==0.Definition RGeomData.cxx:583; ROOT::RGeomDescription::SetActiveItembool Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RGeomData_8hxx_source.html:27755,configurat,configuration,27755,doc/v632/RGeomData_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RGeomData_8hxx_source.html,1,['configurat'],['configuration']
Deployability,"vector< ShapeDescr > fShapes! shapes with created descriptionsDefinition RGeomData.hxx:253; ROOT::RGeomDescription::GetSearchstd::string GetSearch() constDefinition RGeomData.hxx:385; ROOT::RGeomDescription::fJsonCompint fJsonComp! default JSON compressionDefinition RGeomData.hxx:261; ROOT::RGeomDescription::ChangeNodeVisibilitybool ChangeNodeVisibility(const std::vector< std::string > &path, bool on)Change visibility for specified element Returns true if changes was performed.Definition RGeomData.cxx:1850; ROOT::RGeomDescription::SetMutexvoid SetMutex(TVirtualMutex *mutex)Set mutex, it must be recursive one.Definition RGeomData.hxx:312; ROOT::RGeomDescription::RGeomDescriptionRGeomDescription()=default; ROOT::RGeomDescription::fSearchstd::string fSearch! search string in hierarchyDefinition RGeomData.hxx:255; ROOT::RGeomDescription::fSearchJsonstd::string fSearchJson! drawing json for searchDefinition RGeomData.hxx:256; ROOT::RGeomDescription::SavePrimitivevoid SavePrimitive(std::ostream &fs, const std::string &name)Save geometry configuration as C++ macro.Definition RGeomData.cxx:2143; ROOT::RGeomDescription::fHighlightedStackstd::vector< int > fHighlightedStack! highlighted element by stackDefinition RGeomData.hxx:249; ROOT::RGeomDescription::ClearAllPhysVisibilitybool ClearAllPhysVisibility()Reset all custom visibility settings.Definition RGeomData.cxx:2089; ROOT::RGeomDescription::MakeDrawingJsonstd::string MakeDrawingJson(RGeomDrawing &drawing, bool has_shapes=false)Produce JSON for the drawing If TGeoShape appears in the drawing, one has to keep typeinfo But in thi...Definition RGeomData.cxx:1826; ROOT::RGeomDescription::fActualLevelint fActualLevel! level can be reduced when selecting nodesDefinition RGeomData.hxx:259; ROOT::RGeomDescription::GetVolumeTGeoVolume * GetVolume(int nodeid)Get volume for specified nodeid If specific volume was configured, it will be returned for nodeid==0.Definition RGeomData.cxx:583; ROOT::RGeomDescription::SetActiveItembool Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8hxx_source.html:28006,configurat,configuration,28006,doc/master/RGeomData_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8hxx_source.html,1,['configurat'],['configuration']
Deployability,"vector<THit>, vector<THit*>, TClonesArray(TObjHit) not split TClonesArray(TObjHit) split.; The next graphs show the two columns on the right which represent the split and non-split TClonesArray, are significantly lower than the vectors. The most significant difference is in reading a file without compression.; The file size with compression, write times with and without compression and the read times with and without compression all favor the TClonesArray.; 12.23 Impact of Compression on I/O; This benchmark illustrates the pros and cons of the compression option. We recommend using compression when the time spent in I/O is small compared to the total processing time. In this case, if the I/O operation is increased by a factor of 5 it is still a small percentage of the total time and it may very well save a factor of 10 on disk space. On the other hand if the time spend on I/O is large, compression may slow down the program’s performance. The standard test program $ROOTSYS/test/Event was used in various configurations with 400 events. The data file contains a TTree. The program was invoked with:; Event 400 comp split. comp = 0 means: no compression at all.; comp = 1 means: compress everything if split = 0.; comp = 1 means: compress only the tree branches with integers if split = 1.; comp = 2 means: compress everything if split=1.; split = 0 : the full event is serialized into one single buffer.; split = 1 : the event is split into branches. One branch for each data member of the Event class. The list of tracks (a TClonesArray) has the data members of the Track class also split into individual buffers. These tests were run on Pentium III CPU with 650 MHz. Event Parameters; File Size; Total Time to Write (MB/sec); Effective Time to Write (MB/sec); Total Time to Read All (MB/sec); Total Time to Read Sample (MB/sec). Comp = 0; Split = 1; 19.75 MB; 6.84 s.(2.8 MB/s); 3.56 s.(5.4 MB/s); 0.79s.(24.2 MB/s); 0.79 s.(24.2 MB/s). Comp = 1; Split = 1; 17.73 MB; 6.44 s.(3.0 MB/s)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:648250,configurat,configurations,648250,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['configurat'],['configurations']
Deployability,"vector<double>& par, unsigned int nrow, const vector<double>& cov, unsigned int stra = 1); const char*ROOT::Minuit2::MnApplication::Name(unsigned int) const; unsigned intROOT::Minuit2::MnApplication::NumOfCalls() const; virtual ROOT::Minuit2::FunctionMinimumoperator()(unsigned int = 0, double = 0.1); const ROOT::Minuit2::MinuitParameter&ROOT::Minuit2::MnApplication::Parameter(unsigned int i) const; const ROOT::Minuit2::MnUserParameters&ROOT::Minuit2::MnApplication::Parameters() const; vector<double>ROOT::Minuit2::MnApplication::Params() const; const ROOT::Minuit2::MnMachinePrecision&ROOT::Minuit2::MnApplication::Precision() const; voidROOT::Minuit2::MnApplication::Release(unsigned int); voidROOT::Minuit2::MnApplication::Release(const char*); voidROOT::Minuit2::MnApplication::RemoveLimits(unsigned int); voidROOT::Minuit2::MnApplication::RemoveLimits(const char*); voidROOT::Minuit2::MnApplication::SetError(unsigned int, double); voidROOT::Minuit2::MnApplication::SetError(const char*, double); voidROOT::Minuit2::MnApplication::SetLimits(unsigned int, double, double); voidROOT::Minuit2::MnApplication::SetLimits(const char*, double, double); voidROOT::Minuit2::MnApplication::SetPrecision(double); voidROOT::Minuit2::MnApplication::SetValue(unsigned int, double); voidROOT::Minuit2::MnApplication::SetValue(const char*, double); const ROOT::Minuit2::MnUserParameterState&ROOT::Minuit2::MnApplication::State() const; const ROOT::Minuit2::MnStrategy&ROOT::Minuit2::MnApplication::Strategy() const; doubleROOT::Minuit2::MnApplication::Value(unsigned int) const; doubleROOT::Minuit2::MnApplication::Value(const char*) const; unsigned intROOT::Minuit2::MnApplication::VariableParameters() const. private:. ROOT::Minuit2::MnFumiliMinimize&operator=(const ROOT::Minuit2::MnFumiliMinimize&). Data Members; protected:. const ROOT::Minuit2::FCNBase&ROOT::Minuit2::MnApplication::fFCN; unsigned intROOT::Minuit2::MnApplication::fNumCall; ROOT::Minuit2::MnUserParameterStateROOT::Minuit2::MnApplicati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Minuit2__MnFumiliMinimize.html:3571,Release,Release,3571,root/html532/ROOT__Minuit2__MnFumiliMinimize.html,https://root.cern,https://root.cern/root/html532/ROOT__Minuit2__MnFumiliMinimize.html,4,['Release'],['Release']
Deployability,"ved between successive switches, and string based cross calls can nest as long as shared resources are properly handled.; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; 19.1.4 Installation; There are several ways of obtaining PyROOT, and which is best depends on your specific situation. If you work at CERN, you can use the installation available on afs. Otherwise, you will want to build from source, as PyROOT is not build by default in the binaries distributed from the ROOT project site. If you download the ROOT binaries, take care to download and install the Python distribution from http://www.python.org/ against which they were built.; 19.1.4.1 Environment Settings; ROOT installations with the build of PyROOT enabled are available from the CERN afs cell /afs/cern.ch/sw/root/<version>/<platform>. To use them, simply modify your shell environment accordingly. For Unix:; export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH; export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH; export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH; For Windows:; set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%; set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%; where $ROOTSYS should be set to /afs/cern.ch/sw/root/<version>/<platform>, and PYTHONDIR to /afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform> with <version> and <platform> as appropriate. Note that the latest version of Python is 2.4.1.; 19.1.4.2 Building from Source; The standard installation instructions for building ROOT from source apply, with the addition that the build of PyROOT needs to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1046810,install,install,1046810,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['install'],['install']
Deployability,"vely. ; [in]maxptsMaximum number of function evaluations to be allowed. maxpts >= 2^n +2*n*(n+1) +1 if maxpts<minpts, maxpts is set to 10*minpts ; [in]epsrelSpecified relative accuracy. ; [in]epsabsSpecified absolute accuracy. The integration algorithm will attempt to reach either the relative or the absolute accuracy. In case the maximum function called is reached the algorithm will stop earlier without having reached the desired accuracy; [out]relerrContains, on exit, an estimation of the relative accuracy of the result. ; [out]nfnevlnumber of function evaluations performed. ; [out]ifail0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the specified value of maxpts.; 3 n<2 or n>15 . Method:; The default method used is the Genz-Mallik adaptive multidimensional algorithm using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator() to different integrators. Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class Possible methods are : Vegas, Miser or Plain IN case of MC integration the accuracy is determined by the number of function calls, one should be careful not to use a too large value of maxpts ; Definition at line 2851 of file TF1.cxx. ◆ IntegralMultiple() [3/3]. virtual Double_t TF1::IntegralMultiple ; (; Int_t ; n, . const Double_t * ; a, . const Double_t * ; b, . Int_t ; , . Int_t ; maxpts, . Double_t ; epsrel, . Double_t & ; relerr, . Int_t & ; nfnevl, . Int_t & ; ifail . ). inlinevirtual . Definition at line 616 of file TF1.h. ◆ IntegralOneDim(). Double_t TF1::IntegralOneDim ; (; Double_t ; a, . Double_t ; b, . Double_t ; epsrel, . Double_t ; epsabs, . Double_t & ; error . ). virtual . Return Integral of function between a and b using",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:100626,integrat,integrators,100626,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['integrat'],['integrators']
Deployability,"ven if IMT is on, some branches might need to be processed first and in a sequential fashion: in the parallelization of GetEntry, those are the branches that store the size of another branch for every entry (e.g. the size of an array branch). If such branches were processed in parallel with the rest, there could be two threads invoking TBranch::GetEntry on one of them at the same time, since a branch that depends on a size (or count) branch will also invoke GetEntry on the latter. This method can be invoked several times during the event loop if the TTree is being written, for example when adding new branches. In these cases, the checkLeafCount parameter is false. Parameters. [in]checkLeafCountTrue if we need to check whether some branches are count leaves. . Definition at line 5781 of file TTree.cxx. ◆ InPlaceClone(). bool TTree::InPlaceClone ; (; TDirectory * ; newdirectory, . const char * ; options = """" . ). virtual . Copy the content to a new new file, update this TTree with the new location information and attach this TTree to the new directory. ; options: Indicates a basket sorting method, see TTreeCloner::TTreeCloner for details; If new and old directory are in the same file, the data is untouched, this ""just"" does a call to SetDirectory. Equivalent to an ""in place"" cloning of the TTree. ; Reimplemented in TChain.; Definition at line 7012 of file TTree.cxx. ◆ IsA(). TClass * TTree::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 659 of file TTree.h. ◆ IsFolder(). bool TTree::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 547 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ Loa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:169443,update,update,169443,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['update'],['update']
Deployability,"ven if IMT is on, some branches might need to be processed first and in a sequential fashion: in the parallelization of GetEntry, those are the branches that store the size of another branch for every entry (e.g. the size of an array branch). If such branches were processed in parallel with the rest, there could be two threads invoking TBranch::GetEntry on one of them at the same time, since a branch that depends on a size (or count) branch will also invoke GetEntry on the latter. This method can be invoked several times during the event loop if the TTree is being written, for example when adding new branches. In these cases, the checkLeafCount parameter is false. Parameters. [in]checkLeafCountTrue if we need to check whether some branches are count leaves. . Definition at line 5781 of file TTree.cxx. ◆ InPlaceClone(). bool TTree::InPlaceClone ; (; TDirectory * ; newdirectory, . const char * ; options = """" . ). virtual . Copy the content to a new new file, update this TTree with the new location information and attach this TTree to the new directory. ; options: Indicates a basket sorting method, see TTreeCloner::TTreeCloner for details; If new and old directory are in the same file, the data is untouched, this ""just"" does a call to SetDirectory. Equivalent to an ""in place"" cloning of the TTree. ; Reimplemented in TChain.; Definition at line 7012 of file TTree.cxx. ◆ IsA(). TClass * TTree::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 705 of file TTree.h. ◆ IsFolder(). bool TTree::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 587 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ Loa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:171631,update,update,171631,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['update'],['update']
Deployability,"ven variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName). void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ). const Event* Transform(const TMVA::Event*const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event*const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNormalise(Bool_t n); { fNormalise = n; }. Bool_t IsEnabled() const; { return fEnabled; }. Bool_t IsCreated() const; { return fCreated; }. Bool_t IsNormalised() const; { return fNormalise; }. void ToggleInputSortOrder(Bool_t sortOrder); { fSortGet = sortOrder; }. void SetOutputDataSetInfo(TMVA::DataSetInfo* outputDsi); { fDsiOutput = outputDsi; }. void SetUseSignalTransform(Bool_t e = kTRUE); { fUseSignalTransform = e; }. Bool_t UseSignalTransform() const; { return fUseSignalTransform; }. const char* GetName() const; { return fTransformName.Data(); }. TString GetShortName() const; { TString a(fTransformName); a.ReplaceAll(""Transform"",""""); return a; }. void WriteTransformationToStream(ostream& o) const. void ReadTransformationFromStream(istream& istr, const TString& classname = """"). Types::EVariableTransform GetVariableTransform() const; { return fVariableTransform; }. void PrintTransformation(ostream& ); {}. const std::vector<TMVA::VariableInfo>& Variables() const; { return fVariables; }. const std::vector<TMVA::VariableInfo>& Targets() const; { return fTargets; }. const std::vector<TMVA::VariableInfo>& Spectators() const; { return fSpectators; }. void SetTMVAVersion(TMVA::TMVAVersion_t v); { fTMVAVersion = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__VariableTransformBase.html:11885,Toggle,ToggleInputSortOrder,11885,root/html602/TMVA__VariableTransformBase.html,https://root.cern,https://root.cern/root/html602/TMVA__VariableTransformBase.html,2,['Toggle'],['ToggleInputSortOrder']
Deployability,"vent* ev, UInt_t index = 0). void BackPropagationMinimize(Int_t nEpochs); minimize estimator / train network with backpropagation algorithm. void TrainOneEpoch(); train network over a single epoch/cyle of events. void Shuffle(Int_t* index, Int_t n); Input:; index: the array to shuffle; n: the size of the array; Output:; index: the shuffled indexes; This method is used for sequential training. void DecaySynapseWeights(Bool_t lateEpoch); decay synapse weights; in last 10 epochs, lower learning rate even more to find a good minimum. void TrainOneEventFast(Int_t ievt, Float_t*& branchVar, Int_t& type); fast per-event training. void TrainOneEvent(Int_t ievt); train network over a single event; this uses the new event model. Double_t GetDesiredOutput(const TMVA::Event* ev); get the desired output of this event. void UpdateNetwork(Double_t desired, Double_t eventWeight = 1.0); update the network based on how closely; the output matched the desired output. void UpdateNetwork(const vector<Float_t>& desired, Double_t eventWeight = 1.0); update the network based on how closely; the output matched the desired output. void CalculateNeuronDeltas(); have each neuron calculate its delta by backpropagation. void GeneticMinimize(); create genetics class similar to GeneticCut; give it vector of parameter ranges (parameters = weights); link fitness function of this class to ComputeEstimator; instantiate GA (see MethodCuts); run it; then this should exist for GA, Minuit and random sampling. Double_t EstimatorFunction(vector<Double_t>& parameters); interface to the estimate. Double_t ComputeEstimator(vector<Double_t>& parameters); this function is called by GeneticANN for GA optimization. void UpdateSynapses(); update synapse error fields and adjust the weights (if in sequential mode). void AdjustSynapseWeights(); just adjust the synapse weights (should be called in batch mode). void UpdatePriors(). void UpdateRegulators(). void GetApproxInvHessian(TMatrixD& InvHessian, bool regulate = tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodMLP.html:25825,Update,UpdateNetwork,25825,root/html534/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodMLP.html,1,['Update'],['UpdateNetwork']
Deployability,"vent*); virtual voidEmitCanvasPainted(); virtual voidQWidget::enabledChange(bool); virtual voidenterEvent(QEvent*); virtual boolQWidget::event(QEvent*); virtual voidexitSizeEvent(); virtual voidfocusInEvent(QFocusEvent*); boolQWidget::focusNextChild(); virtual boolQWidget::focusNextPrevChild(bool next); virtual voidfocusOutEvent(QFocusEvent*); boolQWidget::focusPreviousChild(); virtual voidQWidget::fontChange(const QFont&); QWidget*GetRootID() const; virtual voidQWidget::hideEvent(QHideEvent*); voidInit(); virtual voidQWidget::inputMethodEvent(QInputMethodEvent*); virtual voidkeyPressEvent(QKeyEvent*); virtual voidkeyReleaseEvent(QKeyEvent*); virtual voidQWidget::languageChange(); virtual voidleaveEvent(QEvent*); virtual intQWidget::metric(QPaintDevice::PaintDeviceMetric) const; virtual voidmouseDoubleClickEvent(QMouseEvent*); virtual voidmouseMoveEvent(QMouseEvent*); virtual voidmousePressEvent(QMouseEvent*); virtual voidmouseReleaseEvent(QMouseEvent*); virtual voidQWidget::moveEvent(QMoveEvent*); virtual voidpaintEvent(QPaintEvent*); boolpaintFlag(bool mode = true); boolPaintingActive() const; virtual voidQWidget::paletteChange(const QPalette&); intQObject::receivers(const char* signal) const; voidRefreshCB(); voidResetCanvas(); voidQWidget::resetInputContext(); virtual voidresizeEvent(QResizeEvent*); voidRootEventProcessed(TObject* selected, unsigned int event, TCanvas* c); voidSaved(bool ok); QObject*QObject::sender() const; intQObject::senderSignalIndex() const; voidSetIgnoreLeaveEnter(int ignoreLE = 1); voidSetRootID(QWidget* wrapper); virtual voidSetSizeHint(const QSize& size); virtual voidshowEvent(QShowEvent*); virtual voidstretchWidget(QResizeEvent* e); virtual voidQWidget::styleChange(QStyle&); virtual voidQWidget::tabletEvent(QTabletEvent*); virtual voidQObject::timerEvent(QTimerEvent*); voidQWidget::updateMicroFocus(); virtual voidQWidget::wheelEvent(QWheelEvent*); virtual voidQWidget::windowActivationChange(bool); virtual boolQWidget::x11Event(XEvent*).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQtWidget.html:21255,update,updateMicroFocus,21255,root/html602/TQtWidget.html,https://root.cern,https://root.cern/root/html602/TQtWidget.html,4,['update'],['updateMicroFocus']
Deployability,"vention (as compared to the RooDataHist convention, which is used internally and one must map between the two).; All indices include '0':; \( \gamma_{i,j} \) = paramSet[ size(i)*j + i ]; ie assuming the dimensions are 5*5:; \( \gamma_{2,1} \) = paramSet[ 5*1 + 2 ] = paramSet[7] ; Definition at line 24 of file ParamHistFunc.h. Classes; class  CacheElem;  ; struct  NumBins;  . Public Member Functions;  ParamHistFunc ();  ;  ParamHistFunc (const char *name, const char *title, const RooArgList &vars, const RooArgList &paramSet);  Create a function which returns binewise-values This class contains N RooAbsReals's, one for each bin from the given RooRealVar. ;  ;  ParamHistFunc (const char *name, const char *title, const RooArgList &vars, const RooArgList &paramSet, const TH1 *hist);  Create a function which returns bin-wise values. ;  ;  ParamHistFunc (const ParamHistFunc &other, const char *name=nullptr);  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Implement analytical integrations by doing appropriate weighting from component integrals functions to integrators of components. ;  ; std::list< double > * binBoundaries (RooAbsRealLValue &, double, double) const override;  Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ;  ; double binVolume () const;  ; TObject * clone (const char *newname) const override;  ; bool forceAnalyticalInt (const RooAbsArg &) const override;  ; const RooArgSet * get (const RooArgSet &coord) const;  ; const RooArgSet * get (Int_t masterIdx) const;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise that all integrals can be handled internally. ;  ; RooAbsReal & getParameter () const;  ; RooAbsReal & getParame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classParamHistFunc.html:1930,integrat,integrations,1930,doc/master/classParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html,2,['integrat'],"['integrations', 'integrators']"
Deployability,"ver range (-6,6) did not converge after 20 steps; [1] h = 1 , s = 0; [2] h = 0.25 , s = 6; [3] h = 0.0625 , s = 3; [4] h = 0.015625 , s = 4.5; [5] h = 0.00390625 , s = 3.75; [6] h = 0.000976562 , s = 4.125; [7] h = 0.000244141 , s = 3.9375; [8] h = 6.10352e-05 , s = 4.03125; [9] h = 1.52588e-05 , s = 3.98438; [10] h = 3.8147e-06 , s = 4.00781; [11] h = 9.53674e-07 , s = 3.99609; [12] h = 2.38419e-07 , s = 4.00195; [13] h = 5.96046e-08 , s = 3.99902; [14] h = 1.49012e-08 , s = 4.00049; [15] h = 3.72529e-09 , s = 3.99976; [16] h = 9.31323e-10 , s = 4.00012; [17] h = 2.32831e-10 , s = 3.99994; [18] h = 5.82077e-11 , s = 4.00003; [19] h = 1.45519e-11 , s = 3.99998; [20] h = 3.63798e-12 , s = 4.00001; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(model) creating new cache 0x56161c4fa860 with pdf gx_CONV_model_mean_CACHE_Obs[mean] for nset () with code 2; [#1] INFO:NumericIntegration -- RooRealIntegral::init(gx_Int[mean,x]) using numeric integrator RooIntegrator1D to calculate Int(mean); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_mean_Int[mean]) using numeric integrator RooIntegrator1D to calculate Int(mean); [#0] WARNING:Integration -- RooRombergIntegrator::integral: integral of model_mean over range (-6,6) did not converge after 20 steps; [1] h = 1 , s = 0; [2] h = 0.25 , s = 6; [3] h = 0.0625 , s = 3; [4] h = 0.015625 , s = 4.5; [5] h = 0.00390625 , s = 3.75; [6] h = 0.000976562 , s = 4.125; [7] h = 0.000244141 , s = 3.9375; [8] h = 6.10352e-05 , s = 4.03125; [9] h = 1.52588e-05 , s = 3.98438; [10] h = 3.8147e-06 , s = 4.00781; [11] h = 9.53674e-07 , s = 3.99609; [12] h = 2.38419e-07 , s = 4.00195; [13] h = 5.96046e-08 , s = 3.99902; [14] h = 1.49012e-08 , s = 4.00049; [15] h = 3.72529e-09 , s = 3.99976; [16] h = 9.31323e-10 , s = 4.00012; [17] h = 2.32831e-10 , s = 3.99994; [18] h = 5.82077e-11 , s = 4.00003; [19] h = 1.45519e-11 , s = 3.99998; [20] h = 3.63798e-12 , s = 4.00001; ; prevFCN = 2171.275755 a=2.017, ; prevFCN = 2171.275755 a=1.983, ; prev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf211__paramconv_8C.html:11668,integrat,integrator,11668,doc/master/rf211__paramconv_8C.html,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8C.html,2,['integrat'],['integrator']
Deployability,"vergence of its training; : (at least 10k training cycles are required to achieve approximately; : competitive results).; : ; : ␛[1mOvertraining: ␛[0monly the TMlpANN performs an explicit separation of the; : full training sample into independent training and validation samples.; : We have found that in most high-energy physics applications the ; : available degrees of freedom (training events) are sufficient to ; : constrain the weights of the relatively simple architectures required; : to achieve good performance. Hence no overtraining should occur, and ; : the use of validation samples would only reduce the available training; : information. However, if the performance on the training sample is ; : found to be significantly better than the one found with the inde-; : pendent test sample, caution is needed. The results for these samples ; : are printed to standard output at the end of each training job.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The hidden layer architecture for all ANNs is defined by the option; : ""HiddenLayers=N+1,N,..."", where here the first hidden layer has N+1; : neurons and the second N neurons (and so on), and where N is the number ; : of input variables. Excessive numbers of hidden layers should be avoided,; : in favour of more neurons in the first hidden layer.; : ; : The number of cycles should be above 500. As said, if the number of; : adjustable weights is small compared to the training sample size,; : using a large number of training samples should not lead to overtraining.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; TFHandler_MLPBNN : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.089214 0.20183 [ -1.0000 1.0000 ]; : myvar2: -0.090751 0.29609 [ -1.0000 1.0000 ]; : var3: 0.059878 0.21436 [ -1.0000 1.0000 ]; : var4: 0.11587 0.24261 [ -1.0000 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:43708,configurat,configuration,43708,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['configurat'],['configuration']
Deployability,"verride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxysigmaL; RooRealProxysigmaR; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBifurGauss.html:39333,configurat,configuration,39333,root/html530/RooBifurGauss.html,https://root.cern,https://root.cern/root/html530/RooBifurGauss.html,3,"['configurat', 'integrat']","['configuration', 'integrator']"
Deployability,"verride;  Return unique name, used in SavePrimitive methods. ;  ; Int_t GetPortNumber () const;  ; const char * GetUserName () const;  ; Bool_t HandleExpose (Event_t *event) override;  Handle expose event in server frame. ;  ; TClass * IsA () const override;  ; Bool_t IsSync () const;  ; void OnBtnAddClicked ();  Add newly created session configuration in the list of sessions. ;  ; void OnBtnConnectClicked ();  Connect to selected server. ;  ; void OnBtnDeleteClicked ();  Delete selected session configuration (remove it from the list). ;  ; void OnBtnNewServerClicked ();  Reset server configuration fields. ;  ; void OnConfigFileClicked ();  Browse configuration files. ;  ; Bool_t ProcessMessage (Longptr_t msg, Longptr_t parm1, Longptr_t parm2) override;  Process messages for session server frame. ;  ; void SetAddEnabled (Bool_t on=kTRUE);  ; void SetAddress (const char *str);  ; void SetConfigText (const char *str);  ; void SetConnectEnabled (Bool_t on=kTRUE);  ; void SetLogLevel (Int_t log);  ; void SetName (const char *str) override;  ; void SetPortNumber (Int_t port);  ; void SetSync (Bool_t sync);  ; void SettingsChanged ();  Settings have changed, update GUI accordingly. ;  ; void SetUserName (const char *str);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Update (TSessionDescription *desc);  Update fields with values from session description desc. ;  ;  Public Member Functions inherited from TGCompositeFrame;  TGCompositeFrame (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=0, Pixel_t back=GetDefaultFrameBackground());  Create a composite frame. ;  ;  TGCompositeFrame (TGClient *c, Window_t id, const TGWindow *parent=nullptr);  Create a frame using an externally created window. ;  ;  ~TGCompositeFrame () override;  Delete a composite frame. ;  ; virtual void AddFrame (TGFrame *f, TGLayoutHints *l=nullptr);  Add frame to the composite frame ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionServerFrame.html:1882,update,update,1882,doc/master/classTSessionServerFrame.html,https://root.cern,https://root.cern/doc/master/classTSessionServerFrame.html,1,['update'],['update']
Deployability,"verrideprotectedvirtual . (De)Activate associated tree branch ; Implements RooAbsArg.; Definition at line 3116 of file RooAbsReal.cxx. ◆ setUnit(). void RooAbsReal::setUnit ; (; const char * ; unit). inline . Definition at line 147 of file RooAbsReal.h. ◆ sigma() [1/2]. RooAbsMoment * RooAbsReal::sigma ; (; RooRealVar & ; obs). inline . Definition at line 361 of file RooAbsReal.h. ◆ sigma() [2/2]. RooAbsMoment * RooAbsReal::sigma ; (; RooRealVar & ; obs, . const RooArgSet & ; nset . ). inline . Definition at line 362 of file RooAbsReal.h. ◆ specialIntegratorConfig() [1/2]. RooNumIntConfig * RooAbsReal::specialIntegratorConfig ; (; ); const. Returns the specialized integrator configuration for this RooAbsReal. ; If this object has no specialized configuration, a null pointer is returned. ; Definition at line 3282 of file RooAbsReal.cxx. ◆ specialIntegratorConfig() [2/2]. RooNumIntConfig * RooAbsReal::specialIntegratorConfig ; (; bool ; createOnTheFly). Returns the specialized integrator configuration for this RooAbsReal. ; If this object has no specialized configuration, a null pointer is returned, unless createOnTheFly is true in which case a clone of the default integrator configuration is created, installed as specialized configuration, and returned ; Definition at line 3294 of file RooAbsReal.cxx. ◆ Streamer(). void RooAbsReal::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in RooStats::HistFactory::RooBarlowBeestonLL, RooArgusBG, RooBCPEffDecay, RooBCPGenDecay, RooBDecay, RooBernstein, RooBifurGauss, RooBMixDecay, RooBreitWigner, RooBukinPdf, RooCBShape, RooCFunction1Binding< VO, VI >, RooCFunction1PdfBinding< VO, VI >, RooCFunction2Binding< VO, VI1, VI2 >, RooCFunction2PdfBinding< VO, VI1, VI2 >, RooCFunction3Binding< VO, VI1, VI2, VI3 >, RooCFunction3PdfBinding< VO, VI1, VI2, VI3 >, RooCFunction4Binding< VO, VI1, VI2, VI3, VI4 >, RooCFunction4PdfBinding< VO, VI1, VI2, VI3, VI4 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:147909,integrat,integrator,147909,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,2,"['configurat', 'integrat']","['configuration', 'integrator']"
Deployability,"verrideprotectedvirtual . (De)Activate associated tree branch ; Implements RooAbsArg.; Definition at line 3198 of file RooAbsReal.cxx. ◆ setUnit(). void RooAbsReal::setUnit ; (; const char * ; unit). inline . Definition at line 147 of file RooAbsReal.h. ◆ sigma() [1/2]. RooAbsMoment * RooAbsReal::sigma ; (; RooRealVar & ; obs). inline . Definition at line 368 of file RooAbsReal.h. ◆ sigma() [2/2]. RooAbsMoment * RooAbsReal::sigma ; (; RooRealVar & ; obs, . const RooArgSet & ; nset . ). inline . Definition at line 369 of file RooAbsReal.h. ◆ specialIntegratorConfig() [1/2]. RooNumIntConfig * RooAbsReal::specialIntegratorConfig ; (; ); const. Returns the specialized integrator configuration for this RooAbsReal. ; If this object has no specialized configuration, a null pointer is returned. ; Definition at line 3364 of file RooAbsReal.cxx. ◆ specialIntegratorConfig() [2/2]. RooNumIntConfig * RooAbsReal::specialIntegratorConfig ; (; bool ; createOnTheFly). Returns the specialized integrator configuration for this RooAbsReal. ; If this object has no specialized configuration, a null pointer is returned, unless createOnTheFly is true in which case a clone of the default integrator configuration is created, installed as specialized configuration, and returned ; Definition at line 3376 of file RooAbsReal.cxx. ◆ Streamer(). void RooAbsReal::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in RooStats::HistFactory::RooBarlowBeestonLL, RooArgusBG, RooBCPEffDecay, RooBCPGenDecay, RooBDecay, RooBernstein, RooBifurGauss, RooBMixDecay, RooBreitWigner, RooBukinPdf, RooCBShape, RooCFunction1Binding< VO, VI >, RooCFunction1PdfBinding< VO, VI >, RooCFunction2Binding< VO, VI1, VI2 >, RooCFunction2PdfBinding< VO, VI1, VI2 >, RooCFunction3Binding< VO, VI1, VI2, VI3 >, RooCFunction3PdfBinding< VO, VI1, VI2, VI3 >, RooCFunction4Binding< VO, VI1, VI2, VI3, VI4 >, RooCFunction4PdfBinding< VO, VI1, VI2, VI3, VI4 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:149746,integrat,integrator,149746,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,2,"['configurat', 'integrat']","['configuration', 'integrator']"
Deployability,"verse of the _cdf_c functions, the upper tail integral of the probability density function \(D^{-1}(z) \) where. \[ D(x) = \int_{x}^{+\infty} p(x') dx' \]. These functions are defined in the header file Math/ProbFunc.h or in the global one including all statistical functions Math/DistFunc.h; NOTE: In the old releases (< 5.14) the _quantile functions were called _quant_inv and the _quantile_c functions were called _prob_inv. These names are currently kept for backward compatibility, but their usage is deprecated.; The functions with the extension _quantile calculate the inverse of the _cdf function, the lower tail integral of the probability density function \(D^{-1}(z)\) where. \[ D(x) = \int_{-\infty}^{x} p(x') dx' \]. while those with the _quantile_c extension calculate the inverse of the _cdf_c functions, the upper tail integral of the probability density function \(D^{-1}(z) \) where. \[ D(x) = \int_{x}^{+\infty} p(x') dx' \]. The implementation used is that of GSL.; NOTE: In the old releases (< 5.14) the _quantile functions were called _quant_inv and the _quantile_c functions were called _prob_inv. These names are currently kept for backward compatibility, but their usage is deprecated. . Functions; double ROOT::MathMore::chisquared_quantile (double z, double r);  Re-implementation in MathMore of the Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the \(\chi^2\) distribution with \(r\) degrees of freedom (ROOT::Math::chisquared_cdf). ;  ; double ROOT::MathMore::gamma_quantile (double z, double alpha, double theta);  Re-implementation in MathMore of the Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the gamma distribution (ROOT::Math::gamma_cdf). ;  ; double ROOT::Math::vavilov_accurate_quantile (double z, double kappa, double beta2);  The inverse of the Vavilov cumulative probability density function. ;  ; double ROOT::Math::vavilov_accurate_quantile_c (double z, double kappa, double be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__QuantFunc.html:1636,release,releases,1636,doc/master/group__QuantFunc.html,https://root.cern,https://root.cern/doc/master/group__QuantFunc.html,1,['release'],['releases']
Deployability,"vertices if own=true, the class will own the operators template <class Base> ; Definition at line 1839 of file RooLagrangianMorphFunc.cxx. ◆ setupObservable(). RooRealVar * RooLagrangianMorphFunc::setupObservable ; (; const char * ; obsname, . TClass * ; mode, . TObject * ; inputExample . ). private . setup observable, recycle existing observable if defined ; Definition at line 1620 of file RooLagrangianMorphFunc.cxx. ◆ Streamer(). void RooLagrangianMorphFunc::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooLagrangianMorphFunc::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 257 of file RooLagrangianMorphFunc.h. ◆ updateCoefficients(). bool RooLagrangianMorphFunc::updateCoefficients ; (; ). Retrieve the new physics objects and update the weights in the morphing function. ; Definition at line 2236 of file RooLagrangianMorphFunc.cxx. ◆ updateSampleWeights(). void RooLagrangianMorphFunc::updateSampleWeights ; (; ). inlineprivate . update sample weight (-?-) ; Definition at line 1683 of file RooLagrangianMorphFunc.cxx. ◆ useCoefficients() [1/2]. bool RooLagrangianMorphFunc::useCoefficients ; (; const char * ; filename). Definition at line 2298 of file RooLagrangianMorphFunc.cxx. ◆ useCoefficients() [2/2]. bool RooLagrangianMorphFunc::useCoefficients ; (; const TMatrixD & ; inverse). setup the morphing function with a predefined inverse matrix call this function before any other after creating the object ; Definition at line 2263 of file RooLagrangianMorphFunc.cxx. ◆ writeCoefficients(). bool RooLagrangianMorphFunc::writeCoefficients ; (; const char * ; filename). write the inverse matrix to a file ; Definition at line 2315 of file RooLagrangianMorphFunc.cxx. ◆ writeMatrixToFile(). void RooLagrangianMorphFunc::writeMatrixToFile ; (; const TMatrixD & ; matrix, . const char * ; fname . ). write a matrix to a file ; Definition at li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLagrangianMorphFunc.html:94213,update,updateSampleWeights,94213,doc/master/classRooLagrangianMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooLagrangianMorphFunc.html,1,['update'],['updateSampleWeights']
Deployability,"verwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Static Public Member Functions inherited from RooProjectedPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooNumGenConfig * defaultGeneratorConfig ();  Returns the default numeric MC generator configuration for all RooAbsReals. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::Eval",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classxRooProjectedPdf.html:66446,configurat,configuration,66446,doc/master/classxRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classxRooProjectedPdf.html,1,['configurat'],['configuration']
Deployability,"ves the correlation between the i-th parameter and that linear combination of all other parameters which is most strongly correlated with i. ;  ; virtual bool Hesse ();  perform a full calculation of the Hessian matrix for error calculation ;  ; bool IsValidError () const;  return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit) ;  ; unsigned int MaxFunctionCalls () const;  max number of function calls ;  ; unsigned int MaxIterations () const;  max iterations ;  ; virtual const double * MinGradient () const;  return pointer to gradient values at the minimum ;  ; virtual int MinosStatus () const;  status code of Minos (to be re-implemented by the minimizers supporting Minos) ;  ; virtual unsigned int NIterations () const;  number of iterations to reach the minimum ;  ; Minimizer & operator= (Minimizer &&)=delete;  ; Minimizer & operator= (Minimizer const &)=delete;  ; virtual MinimizerOptions Options () const;  retrieve the minimizer options (implement derived class if needed) ;  ; double Precision () const;  precision of minimizer in the evaluation of the objective function ( a value <=0 corresponds to the let the minimizer choose its default one) ;  ; int PrintLevel () const;  minimizer configuration parameters ;  ; virtual void PrintResults ();  return reference to the objective function virtual const ROOT::Math::IGenFunction & Function() const = 0; ;  ; virtual bool ProvidesError () const;  minimizer provides error and error matrix ;  ; virtual bool Scan (unsigned int ivar, unsigned int &nstep, double *x, double *y, double xmin=0, double xmax=0);  scan function minimum for variable i. ;  ; virtual bool SetCovariance (std::span< const double > cov, unsigned int nrow);  set initial covariance matrix ;  ; virtual bool SetCovarianceDiag (std::span< const double > d2, unsigned int n);  set initial second derivatives ;  ; void SetDefaultOptions ();  reset the default options (defined in MinimizerOptions) ;  ; void SetErrorDef (dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLSimAnMinimizer.html:9462,configurat,configuration,9462,doc/master/classROOT_1_1Math_1_1GSLSimAnMinimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLSimAnMinimizer.html,1,['configurat'],['configuration']
Deployability,"view). void SetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv); Set viewing window. void SetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view parameters. void ResizePad(); Recompute window for perspective view. void ResetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view direction (in spherical coordinates). Input PHI - longitude; THETA - latitude (angle between +Z and view direction); PSI - rotation in screen plane. Output: IREP - reply (-1 if error in min-max). Errors: error in min-max scope. void WCtoNDC(const Float_t* pw, Float_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void WCtoNDC(const Double_t* pw, Double_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void AdjustPad(TVirtualPad* pad = 0); Force the current pad to be updated. void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0); API to rotate view and adjust the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void AdjustScales(TVirtualPad* pad = 0); Adjust all sides of view in respect of the biggest one. void Centered3DImages(TVirtualPad* pad = 0); Move view into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TView3D.html:20872,update,updated,20872,root/html530/TView3D.html,https://root.cern,https://root.cern/root/html530/TView3D.html,9,['update'],['updated']
Deployability,"view). void SetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv); Set viewing window. void SetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); set view parameters. void ResizePad(); Recompute window for perspective view. void ResetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view direction (in spherical coordinates). Input PHI - longitude; THETA - latitude (angle between +Z and view direction); PSI - rotation in screen plane. Output: IREP - reply (-1 if error in min-max). Errors: error in min-max scope. void WCtoNDC(const Float_t* pw, Float_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void WCtoNDC(const Double_t* pw, Double_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void AdjustPad(TVirtualPad* pad = 0); Force the current pad to be updated. void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0); API to rotate view and adjust the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void AdjustScales(TVirtualPad* pad = 0); Adjust all sides of view in respect of the biggest one. void Centered3DImages(TVirtualPad* pad = 0); Move view into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TView3D.html:20801,update,updated,20801,root/html528/TView3D.html,https://root.cern,https://root.cern/root/html528/TView3D.html,1,['update'],['updated']
Deployability,"virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGTable::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGTable::Expand(UInt_t nrows, UInt_t ncolumns); virtual voidTGTable::ExpandColumns(UInt_t ncolumns); virtual voidTGTable::ExpandRows(UInt_t nrows); virtual UInt_tTGTable::GetCHdrWidth() const; static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual UInt_tTGTable::GetRHdrHeight() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTGTable::Init(); voidTObject::MakeZombie(); TGWindow&TGWindow::operator=(const TGWindow& tgw); virtual voidTGTable::ResizeTable(UInt_t nrows, UInt_t ncolumns); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGTable::SetInterface(TVirtualTableInterface* interface, UInt_t nrows = 50, UInt_t ncolumns = 20); virtual voidTGTable::Shrink(UInt_t nrows, UInt_t ncolumns); virtual voidTGTable::ShrinkColumns(UInt_t ncolumns); virtual voidTGTable::ShrinkRows(UInt_t nrows); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE); virtual voidTGTable::UpdateHeaders(EHeaderType type); virtual voidTGTable::UpdateRangeFrame(). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGSimpleTable.html:19012,Update,UpdateHeaders,19012,root/html532/TGSimpleTable.html,https://root.cern,https://root.cern/root/html532/TGSimpleTable.html,8,['Update'],"['UpdateHeaders', 'UpdateRangeFrame']"
Deployability,"virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TOrdCollection*fToggleslist of TToggle objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TToggleGroup(); Constructor. TToggleGroup(const TToggleGroup& ); Copy constructor. TToggleGroup & operator=(const TToggleGroup& ); Assignment operator. ~TToggleGroup(); Deletes togglegroup but does not disposes toggled objects!. Int_t Add(TToggle* t, Bool_t select = 1); Add a new toggle. Int_t InsertAt(TToggle* t, Int_t pos, Bool_t select = 1); Add a new toggle at a specific position. void Select(Int_t idx); Select a toggle. void Select(TToggle* t); Selector a toggle. void DeleteAll(); Disposes of all objects and clears array. Int_t GetTogglesCount(); {return fToggles->GetSize();}. TToggle * At(Int_t idx); {return (TToggle*)fToggles->At(idx);}. void Remove(TToggle* t); {fToggles->Remove(t);}. void Remove(Int_t pos); {fToggles->RemoveAt(pos);}. TToggle * First(); {return (TToggle*)fToggles->First();}. TToggle * Last(); {return (TToggle*)fToggles->Last();}. Int_t IndexOf(TToggle* t); {return fToggles->IndexOf(t);}. » Author: Piotr Golonka 31/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TToggleGroup.h 26606 2008-12-02 20:36:09Z pcanal $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TToggleGroup.html:6395,toggle,toggle,6395,root/html532/TToggleGroup.html,https://root.cern,https://root.cern/root/html532/TToggleGroup.html,2,['toggle'],['toggle']
Deployability,"virtual TClass*IsA() const; Bool_tIsDrawOrSelectLock() const; Bool_tIsLocked() const; virtual const char*LockIdStr() const; static const char*LockName(TGLLockable::ELock lock); static Bool_tLockValid(TGLLockable::ELock lock); Bool_tReleaseLock(TGLLockable::ELock lock) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Bool_tTakeLock(TGLLockable::ELock lock) const. private:. TGLLockable(const TGLLockable&); TGLLockable&operator=(const TGLLockable&). Data Members; public:. enum ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. TGLLockable::ELockfLockLock state. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLockable(); Constructor. Bool_t TakeLock(TGLLockable::ELock lock) const; Lock the object in mode 'lock'. Return TRUE if successful, FALSE; if the object is already locked. Bool_t ReleaseLock(TGLLockable::ELock lock) const; Release current lock, make sure it the same as the 'lock' argument.; Returns TRUE on success, FALSE on failure. const char* LockName(TGLLockable::ELock lock); Return name-string for given lock-type. Bool_t LockValid(TGLLockable::ELock lock); Test if lock is a valid type to take/release.; kUnlocked is never valid in these cases. TGLLockable(const TGLLockable& ). TGLLockable& operator=(const TGLLockable& ). virtual ~TGLLockable(); {}. const char* LockIdStr() const; { return ""<unknown>""; }. Bool_t IsLocked() const; { return (fLock != kUnlocked); }. ELock CurrentLock() const; { return fLock; }. Bool_t IsDrawOrSelectLock() const; { return fLock == kDrawLock || fLock == kSelectLock; }. » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-03-13 19:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLLockable.html:1755,release,release,1755,root/html534/TGLLockable.html,https://root.cern,https://root.cern/root/html534/TGLLockable.html,4,"['Release', 'release']","['Release', 'ReleaseLock', 'release']"
Deployability,"virtual voidSetBBoxCenter(const TPoint& p); virtual voidSetBBoxCenterX(const Int_t x); virtual voidSetBBoxCenterY(const Int_t y); virtual voidSetBBoxX1(const Int_t x); virtual voidSetBBoxX2(const Int_t x); virtual voidSetBBoxY1(const Int_t y); virtual voidSetBBoxY2(const Int_t y); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetNoEdges(Bool_t noEdges = kTRUE)TOGGLE GETTER ; static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPhimax(Double_t phi = 360)MENU ; virtual voidSetPhimin(Double_t phi = 0)MENU ; virtual voidSetR1(Double_t r1)MENU ; virtual voidSetR2(Double_t r2)MENU ; virtual voidSetTheta(Double_t theta = 0)MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetX1(Double_t x1)MENU ; virtual voidSetY1(Double_t y1)MENU ; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEllipse.html:7645,TOGGLE,TOGGLE,7645,root/html534/TEllipse.html,https://root.cern,https://root.cern/root/html534/TEllipse.html,1,['TOGGLE'],['TOGGLE']
Deployability,"virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector& insp) const; virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTEveWindow::SwapWindow(TEveWindow* w); static voidTEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2); voidTEveWindow::SwapWindowWithCurrent()MENU ; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; TEveWindowFrame(TGFrame* frame, const char* n = ""TEveWindowFrame"", const char* t = """"); voidTEveWindow::TitleBarClicked(); voidTEveWindow::UndockWindow()MENU ; voidTEveWindow::UndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveWindowFrame.html:17476,update,update,17476,root/html602/TEveWindowFrame.html,https://root.cern,https://root.cern/root/html602/TEveWindowFrame.html,8,['update'],['update']
Deployability,"virtual voidTGFrame::SetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGedFrame::SetGedEditor(TGedEditor* ed); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidSetModel(TObject* obj); voidTGedFrame::SetModelClass(TClass* mcl); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TEveParamListEditor(const TGWindow* p = 0, Int_t width = 170, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTGedFrame::Update(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveParamListEditor.html:15519,Update,Update,15519,root/html602/TEveParamListEditor.html,https://root.cern,https://root.cern/root/html602/TEveParamListEditor.html,2,['Update'],['Update']
Deployability,"virtual voidTGFrame::SetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGedFrame::SetGedEditor(TGedEditor* ed); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidSetModel(TObject* obj); voidTGedFrame::SetModelClass(TClass* mcl); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TEveTrackListEditor(const TGWindow* p = 0, Int_t width = 170, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTGedFrame::Update(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveTrackListEditor.html:15112,Update,Update,15112,root/html602/TEveTrackListEditor.html,https://root.cern,https://root.cern/root/html602/TEveTrackListEditor.html,2,['Update'],['Update']
Deployability,"virtual voidTGWidget::SetCommand(const char* command); voidTGFrame::SetDNDSource(Bool_t onoff); voidTGFrame::SetDNDTarget(Bool_t onoff); virtual voidTGFrame::SetDragType(Int_t type); virtual voidTGFrame::SetDrawOption(Option_t* = """"); virtual voidTGFrame::SetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidTGCompositeFrame::SetEditable(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetEditDisabled(UInt_t on = 1); virtual voidTGFrame::SetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidSetLayoutManager(TGLayoutManager*); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidSetMultipleSelections(Bool_t multi = kTRUE)TOGGLE GETTER ; virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidSetTopEntry(Int_t id = -1); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSortByName(Bool_t ascend = kTRUE)MENU ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TGListBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kSunkenFrame | kDoubleBorder, Pixel_t back = GetWhitePixel()); virtual Bool_tTGCompositeFrame::TranslateCoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGListBox.html:15695,TOGGLE,TOGGLE,15695,root/html602/TGListBox.html,https://root.cern,https://root.cern/root/html602/TGListBox.html,2,['TOGGLE'],['TOGGLE']
Deployability,"virtual voidTGWidget::SetCommand(const char* command); voidTGFrame::SetDNDSource(Bool_t onoff); voidTGFrame::SetDNDTarget(Bool_t onoff); virtual voidTGFrame::SetDragType(Int_t type); virtual voidTGFrame::SetDrawOption(Option_t* = """"); virtual voidTGFrame::SetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidTGCompositeFrame::SetEditable(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetEditDisabled(UInt_t on = 1); virtual voidTGFrame::SetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidSetLayoutManager(TGLayoutManager*); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidSetMultipleSelections(Bool_t multi = kTRUE)TOGGLE GETTER ; virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidSetTopEntry(Int_t id = -1); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp); virtual voidSortByName(Bool_t ascend = kTRUE)MENU ; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGListBox.html:15886,TOGGLE,TOGGLE,15886,root/html532/TGListBox.html,https://root.cern,https://root.cern/root/html532/TGListBox.html,1,['TOGGLE'],['TOGGLE']
Deployability,"virtual voidTGWidget::SetCommand(const char* command); voidTGFrame::SetDNDSource(Bool_t onoff); voidTGFrame::SetDNDTarget(Bool_t onoff); virtual voidTGFrame::SetDragType(Int_t type); virtual voidTGFrame::SetDrawOption(Option_t* = """"); virtual voidTGFrame::SetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidTGCompositeFrame::SetEditable(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetEditDisabled(UInt_t on = 1); virtual voidTGFrame::SetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidSetLayoutManager(TGLayoutManager*); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidSetMultipleSelections(Bool_t multi = kTRUE)TOGGLE GETTER ; virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidSetTopEntry(Int_t id = -1); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector&); virtual voidSortByName(Bool_t ascend = kTRUE)MENU ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGListBox.html:15886,TOGGLE,TOGGLE,15886,root/html534/TGListBox.html,https://root.cern,https://root.cern/root/html534/TGListBox.html,1,['TOGGLE'],['TOGGLE']
Deployability,"virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGButton::SetOn(Bool_t on = kTRUE, Bool_t emit = kFALSE); virtual voidTGTextButton::SetRightMargin(Int_t val); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTGCheckButton::SetState(EButtonState state, Bool_t emit = kFALSE); virtual voidTGButton::SetStyle(UInt_t newstyle); virtual voidTGButton::SetStyle(const char* style); virtual voidTGTextButton::SetText(TGHotString* new_label); virtual voidTGTextButton::SetText(const TString& new_label); virtual voidTGTextButton::SetTextColor(Pixel_t color, Bool_t global = kFALSE); virtual voidTGTextButton::SetTextJustify(Int_t tmode); virtual voidTGTextButton::SetTitle(const char* label); virtual voidTGButton::SetToolTipText(const char* text, Long_t delayms = 400)MENU ; virtual voidTGTextButton::SetTopMargin(Int_t val); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGButton::SetUserData(void* userData); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); voidTGTextButton::SetWrapLength(Int_t wl); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTGButton::Toggle(Bool_t emit = kFALSE); virtual voidTGButton::Toggled(Bool_t on)SIGNAL ; virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGColorSelect.html:16858,Toggle,Toggle,16858,root/html534/TGColorSelect.html,https://root.cern,https://root.cern/root/html534/TGColorSelect.html,2,['Toggle'],"['Toggle', 'Toggled']"
Deployability,"virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooLinkedList_configSetsList of configuration sets for individual integration methods; static RooNumIntConfig*_default; Double_t_epsAbsAbsolute precision; Double_t_epsRelRelative precision; RooCategory_method1DSelects integration method for 1D integrals; RooCategory_method1DOpenSelects integration method for open ended 1D integrals; RooCategory_method2DSelects integration method for 2D integrals; RooCategory_method2DOpenSelects integration method for open ended 2D integrals; RooCategory_methodNDSelects integration method for ND integrals; RooCategory_methodNDOpenSelects integration method for open ended ND integrals; static Int_tRooPrintable::_nameLength; Bool_t_printEvalCounterFlag to control printing of function evaluation counter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Function called by atexit() handler installed by RooSentinel to; cleanup global objects at end of job. RooNumIntConfig& defaultConfig(); Return reference to instance of default numeric integrator configuration object. RooNumIntConfig(); Constructor. ~RooNumIntConfig(); Destructor. RooNumIntConfig(const RooNumIntConfig& other); Copy constructor. RooNumIntConfig& operator=(const RooNumIntConfig& other); Assignment operator from other RooNumIntConfig. Bool_t addConfigSection(const RooAbsIntegrator* proto, const RooArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumIntConfig.html:7352,configurat,configuration,7352,root/html526/RooNumIntConfig.html,https://root.cern,https://root.cern/root/html526/RooNumIntConfig.html,56,"['configurat', 'integrat']","['configuration', 'integration']"
Deployability,"virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTFormula::SetMaxima(Int_t maxop = 1000, Int_t maxpar = 1000, Int_t maxconst = 1000); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTFormula::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFormula::SetParameter(const char* name, Double_t parvalue); virtual voidTFormula::SetParameter(Int_t ipar, Double_t parvalue); virtual voidTFormula::SetParameters(const Double_t* params); virtual voidTFormula::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidTFormula::SetParName(Int_t ipar, const char* name); virtual voidTFormula::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTFormula::Update(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFormula.html:8708,Update,Update,8708,root/html534/RooFormula.html,https://root.cern,https://root.cern/root/html534/RooFormula.html,1,['Update'],['Update']
Deployability,"virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTPad::SetVertical(Bool_t vert = kTRUE); virtual voidTPad::SetView(TView* view = 0); virtual voidTPad::SetViewer3D(TVirtualViewer3D* viewer3d); voidTCanvas::SetWindowPosition(Int_t x, Int_t y); voidTCanvas::SetWindowSize(UInt_t ww, UInt_t wh); virtual voidTAttPad::SetXfile(Float_t xfile); virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); voidTCanvas::Show(); virtual voidShowMembers(TMemberInspector& insp); virtual voidTCanvas::Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); virtual voidTPad::StartEditing()SIGNAL ; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTCanvas::ToggleAutoExec(); virtual voidTCanvas::ToggleEditor(); virtual voidTCanvas::ToggleEventStatus(); virtual voidTCanvas::ToggleToolBar(); virtual voidTCanvas::ToggleToolTips(); virtual voidTCanvas::Update(); virtual voidTCanvas::UseCurrentStyle()MENU ; Bool_tTCanvas::UseGL() const; virtual Int_tTPad::UtoAbsPixel(Double_t u) const; virtual Int_tTPad::UtoPixel(Double_t u) const; virtual Int_tTPad::VtoAbsPixel(Double_t v) const; virtual Int_tTPad::VtoPixel(Double_t v) const; virtual TObject*TPad::WaitPrimitive(const char* pname = """", const char* emode = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidx3d(Option_t* option = """"); virtual Int_tTPad::XtoAbsPixel(Double_t x) const; virtual Double_tTPad::XtoPad(Double_t x) const; virtual Int_tTPad::XtoPixel(Double_t x) const; virtual voidTPad::XYtoAbsPixel(Double_t x, Double_t y, Int_t& xpixel, Int_t& ypixel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDialogCanvas.html:24768,Toggle,ToggleEventStatus,24768,root/html532/TDialogCanvas.html,https://root.cern,https://root.cern/root/html532/TDialogCanvas.html,2,['Toggle'],['ToggleEventStatus']
Deployability,"virtual voidTTable::Reset(Int_t c = 0); voidTObject::ResetBit(UInt_t f); virtual voidTTable::ResetMap(Bool_t wipe = kTRUE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTTable::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTTable::Set(Int_t n); virtual voidTTable::Set(Int_t n, Char_t* array); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTDataSet::SetMother(TDataSet* parent = 0); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTTable::SetNRows(Int_t n); virtual voidTDataSet::SetObject(TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTDataSet::SetParent(TDataSet* parent = 0); voidSetResponse(int track, int* nvl, float* response); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDataSet::SetWrite(); virtual voidShowMembers(TMemberInspector& insp); virtual voidTDataSet::Shunt(TDataSet* newParent = 0); virtual Int_tTNamed::Sizeof() const; virtual voidTDataSet::Sort(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; static const char*TTable::TableDictionary(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTDataSet::UnMark()MENU ; voidTDataSet::UnMarkAll()MENU ; virtual voidTTable::Update(); virtual voidTTable::Update(TDataSet* set, UInt_t opt = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTDataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTDataSet::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TResponseTable.html:11193,Update,Update,11193,root/html532/TResponseTable.html,https://root.cern,https://root.cern/root/html532/TResponseTable.html,2,['Update'],['Update']
Deployability,"virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidreset(); RooCacheManager<RooAbsCacheElement>(Int_t maxSize = 2); RooCacheManager<RooAbsCacheElement>(RooAbsArg* owner, Int_t maxSize = 2); RooCacheManager<RooAbsCacheElement>(const RooCacheManager<RooAbsCacheElement>& other, RooAbsArg* owner = 0); Int_tsetObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidsterilize(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. Int_t_lastIndex! Last slot accessed; Int_t_maxSize! Maximum size; vector<RooNormSetCache>_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_size! Actual use; Bool_t_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCacheManager<T> reset(); Clear the cache. void RooCacheManager<T> sterilize(); Clear the cache payload but retain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCacheManager_RooAbsCacheElement_.html:3165,Integrat,Integration,3165,root/html602/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html602/RooCacheManager_RooAbsCacheElement_.html,2,['Integrat'],['Integration']
Deployability,"virtual void fixAddCoefRange (const char *rangeName=nullptr, bool force=true);  Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by this object to the given set of observables. ;  ; virtual bool forceAnalyticalInt (const RooAbsArg &) const;  ; virtual void forceNumInt (bool flag=true);  ; RooFunctor * functor (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a RooFunctor object bound to this RooAbsReal with given definition of observables and parameters. ;  ; virtual Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; bool getForceNumInt () const;  ; RooNumIntConfig * getIntegratorConfig ();  Return the numeric integration configuration used for this object. ;  ; const RooNumIntConfig * getIntegratorConfig () const;  Return the numeric integration configuration used for this object. ;  ; virtual Int_t getMaxVal (const RooArgSet &vars) const;  Advertise capability to determine maximum value of function for given set of observables. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual double getValV (const RooArgSet *normalisationSet=nullptr) const;  Return value of object. ;  ; virtual void gradient (double *) const;  ; virtual bool h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classPiecewiseInterpolation.html:14493,integrat,integration,14493,doc/master/classPiecewiseInterpolation.html,https://root.cern,https://root.cern/doc/master/classPiecewiseInterpolation.html,2,"['configurat', 'integrat']","['configuration', 'integration']"
Deployability,"void RewindDictionary(); Rewind CINT dictionary to the point where it was before executing; the current macro. This function is typically called after SEGV or; ctlr-C after doing a longjmp back to the prompt. Int_t DeleteGlobal(void* obj); Delete obj from CINT symbol table so it cannot be accessed anymore.; Returns 1 in case of success and 0 in case object was not in table. Int_t DeleteVariable(const char* name); Delete obj from CINT symbol table so it cannot be accessed anymore.; Returns 1 in case of success and 0 in case object was not in table. void SaveContext(); Save the current CINT state. void SaveGlobalsContext(); Save the current CINT state of global objects. void UpdateListOfGlobals(); Update the list of pointers to global variables. This function; is called by TROOT::GetListOfGlobals(). void UpdateListOfGlobalFunctions(); Update the list of pointers to global functions. This function; is called by TROOT::GetListOfGlobalFunctions(). void UpdateListOfTypes(); Update the list of pointers to Datatype (typedef) definitions. This; function is called by TROOT::GetListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE); Set pointer to CINT's G__ClassInfo in TClass. Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE); Checks if a class with the specified name is defined in CINT.; Returns kFALSE is class is not defined. void CreateListOfBaseClasses(TClass* cl); Create list of pointers to base class(es) for TClass cl. void CreateListOfDataMembers(TClass* cl); Create list of pointers to data members for TClass cl. void CreateListOfMethods(TClass* cl); Create list of pointers to methods for TClass cl. void UpdateListOfMethods(TClass* cl); Update the list of pointers to method for TClass cl, if necessary. void CreateListOfMethodArgs(TFunction* m); Create list of pointers to method arguments for TMethod m. Int_t GenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0); Generate the dictionary for the C++ classes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCint.html:23900,Update,UpdateListOfTypes,23900,root/html534/TCint.html,https://root.cern,https://root.cern/root/html534/TCint.html,2,['Update'],"['Update', 'UpdateListOfTypes']"
Deployability,"void RooSimGenContext::printMultiline ; (; std::ostream & ; os, . Int_t ; content, . bool ; verbose = false, . TString ; indent = """" . ); const. overridevirtual . Detailed printing interface. ; Reimplemented from RooAbsGenContext.; Definition at line 291 of file RooSimGenContext.cxx. ◆ setProtoDataOrder(). void RooSimGenContext::setProtoDataOrder ; (; Int_t * ; lut). overridevirtual . Set the traversal order of the prototype data to that in the given lookup table. ; This information is passed to all component generator contexts ; Reimplemented from RooAbsGenContext.; Definition at line 278 of file RooSimGenContext.cxx. ◆ Streamer(). void RooSimGenContext::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsGenContext. ◆ StreamerNVirtual(). void RooSimGenContext::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 63 of file RooSimGenContext.h. ◆ updateFractions(). void RooSimGenContext::updateFractions ; (; ). protected . No action needed if we have a proto index. ; Definition at line 249 of file RooSimGenContext.cxx. Member Data Documentation. ◆ _allVarsPdf. RooArgSet RooSimGenContext::_allVarsPdf {}. protected . All pdf variables. ; Definition at line 61 of file RooSimGenContext.h. ◆ _fracThresh. std::vector<double> RooSimGenContext::_fracThresh. protected . [_numPdf] Fraction threshold array ; Definition at line 58 of file RooSimGenContext.h. ◆ _gcIndex. std::vector<int> RooSimGenContext::_gcIndex. protected . Index value corresponding to component. ; Definition at line 54 of file RooSimGenContext.h. ◆ _gcList. std::vector<std::unique_ptr<RooAbsGenContext> > RooSimGenContext::_gcList. protected . List of component generator contexts. ; Definition at line 53 of file RooSimGenContext.h. ◆ _haveIdxProto. bool RooSimGenContext::_haveIdxProto {false}. protected . Flag set if generation of index is requested. ; Definition at line 55 of file RooSimGenContext.h. ◆ _idxCat.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimGenContext.html:21946,update,updateFractions,21946,doc/master/classRooSimGenContext.html,https://root.cern,https://root.cern/doc/master/classRooSimGenContext.html,1,['update'],['updateFractions']
Deployability,"void SetForeground(GContext_t gc, ULong_t foreground); Sets the foreground color for the specified GC (shortcut for ChangeGC; with only foreground mask set). gc - specifies the GC; foreground - the foreground you want to set; (see also the GCValues_t structure). void SetClipRectangles(GContext_t gc, Int_t x, Int_t y, Rectangle_t* recs, Int_t n); Sets clipping rectangles in graphics context. [x,y] specify the origin; of the rectangles. ""recs"" specifies an array of rectangles that define; the clipping mask and ""n"" is the number of rectangles.; (see also the GCValues_t structure). void Update(Int_t mode = 0); Flushes (mode = 0, default) or synchronizes (mode = 1) X output buffer.; Flush flushes output buffer. Sync flushes buffer and waits till all; requests have been processed by X server. Region_t CreateRegion(); Creates a new empty region. void DestroyRegion(Region_t reg); Destroys the region ""reg"". void UnionRectWithRegion(Rectangle_t* rect, Region_t src, Region_t dest); Updates the destination region from a union of the specified rectangle; and the specified source region. rect - specifies the rectangle; src - specifies the source region to be used; dest - returns the destination region. Region_t PolygonRegion(Point_t* points, Int_t np, Bool_t winding); Returns a region for the polygon defined by the points array. points - specifies an array of points; np - specifies the number of points in the polygon; winding - specifies the winding-rule is set (kTRUE) or not(kFALSE). void UnionRegion(Region_t rega, Region_t regb, Region_t result); Computes the union of two regions. rega, regb - specify the two regions with which you want to perform; the computation; result - returns the result of the computation. void IntersectRegion(Region_t rega, Region_t regb, Region_t result); Computes the intersection of two regions. rega, regb - specify the two regions with which you want to perform; the computation; result - returns the result of the computation. void SubtractRegion(Region",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualX.html:60353,Update,Updates,60353,root/html532/TVirtualX.html,https://root.cern,https://root.cern/root/html532/TVirtualX.html,4,['Update'],['Updates']
Deployability,"void TGeoVolume::SaveAs(const char *filename, Option_t *option) const; 1448{; 1449 if (!filename); 1450 return;; 1451 std::ofstream out;; 1452 out.open(filename, std::ios::out);; 1453 if (out.bad()) {; 1454 Error(""SavePrimitive"", ""Bad file name: %s"", filename);; 1455 return;; 1456 }; 1457 if (fGeoManager->GetTopVolume() != this); 1458 fGeoManager->SetTopVolume((TGeoVolume *)this);; 1459 ; 1460 TString fname(filename);; 1461 Int_t ind = fname.Index(""."");; 1462 if (ind > 0); 1463 fname.Remove(ind);; 1464 out << ""void "" << fname << ""() {"" << std::endl;; 1465 out << "" gSystem->Load(\""libGeom\"");"" << std::endl;; 1466 const UInt_t prec = TGeoManager::GetExportPrecision();; 1467 out << std::setprecision(prec);; 1468 ((TGeoVolume *)this)->SavePrimitive(out, option);; 1469 out << ""}"" << std::endl;; 1470}; 1471 ; 1472////////////////////////////////////////////////////////////////////////////////; 1473/// Connect user-defined extension to the volume. The volume ""grabs"" a copy, so; 1474/// the original object can be released by the producer. Release the previously; 1475/// connected extension if any.; 1476///; 1477/// NOTE: This interface is intended for user extensions and is guaranteed not; 1478/// to be used by TGeo; 1479 ; 1480void TGeoVolume::SetUserExtension(TGeoExtension *ext); 1481{; 1482 TGeoExtension* tmp = fUserExtension;; 1483 fUserExtension = nullptr;; 1484 if (ext); 1485 fUserExtension = ext->Grab();; 1486 if (tmp); 1487 tmp->Release();; 1488}; 1489 ; 1490////////////////////////////////////////////////////////////////////////////////; 1491/// Connect framework defined extension to the volume. The volume ""grabs"" a copy,; 1492/// so the original object can be released by the producer. Release the previously; 1493/// connected extension if any.; 1494///; 1495/// NOTE: This interface is intended for the use by TGeo and the users should; 1496/// NOT connect extensions using this method; 1497 ; 1498void TGeoVolume::SetFWExtension(TGeoExtension *ext); 1499{; 1500 TGeoE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:56683,release,released,56683,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['release'],['released']
Deployability,"void TMVA::DNN::ClassificationSettings::endTrainCycle ; (; double ; ). virtual . action to be done when the training cycle is ended (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 296 of file NeuralNet.cxx. ◆ setResultComputation(). void TMVA::DNN::ClassificationSettings::setResultComputation ; (; std::string ; _fileNameNetConfig, . std::string ; _fileNameResult, . std::vector< Pattern > * ; _resultPatternContainer . ). preparation for monitoring output ; Definition at line 520 of file NeuralNet.cxx. ◆ setWeightSums(). void TMVA::DNN::ClassificationSettings::setWeightSums ; (; double ; sumOfSigWeights, . double ; sumOfBkgWeights . ). set the weight sums to be scaled to (preparations for monitoring output) ; Definition at line 512 of file NeuralNet.cxx. ◆ startTestCycle(). void TMVA::DNN::ClassificationSettings::startTestCycle ; (; ). virtual . action to be done when the test cycle is started (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 316 of file NeuralNet.cxx. ◆ startTrainCycle(). void TMVA::DNN::ClassificationSettings::startTrainCycle ; (; ). virtual . action to be done when the training cycle is started (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 281 of file NeuralNet.cxx. ◆ testIteration(). void TMVA::DNN::ClassificationSettings::testIteration ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented from TMVA::DNN::Settings.; Definition at line 930 of file NeuralNet.h. ◆ testSample(). void TMVA::DNN::ClassificationSettings::testSample ; (; double ; error, . double ; output, . double ; target, . double ; weight . ). virtual . action to be done after the computation of a test sample (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 304 of file NeuralNet.cxx. Member Data Documentation. ◆ m_ams. std::vector<double> TMVA::DNN::Classif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html:8563,update,update,8563,doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,1,['update'],['update']
Deployability,"voidGradient(const double* x, double* g) const; ROOT::Math::IBaseFunctionMultiDimROOT::Math::IBaseFunctionMultiDim::IBaseFunctionMultiDim(); ROOT::Math::IBaseFunctionMultiDimROOT::Math::IBaseFunctionMultiDim::IBaseFunctionMultiDim(const ROOT::Math::IBaseFunctionMultiDim&); ROOT::Math::IGradientFunctionMultiDimROOT::Math::IGradientFunctionMultiDim::IGradientFunctionMultiDim(); ROOT::Math::IGradientFunctionMultiDimROOT::Math::IGradientFunctionMultiDim::IGradientFunctionMultiDim(const ROOT::Math::IGradientFunctionMultiDim&); ROOT::Math::IGradientMultiDimROOT::Math::IGradientMultiDim::IGradientMultiDim(); ROOT::Math::IGradientMultiDimROOT::Math::IGradientMultiDim::IGradientMultiDim(const ROOT::Math::IGradientMultiDim&); boolIsWeighted() const; virtual const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::BinData& data, const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = true); virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeights(); voidUseSumOfWeightSquare(bool on = true).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:3663,Update,UpdateNCalls,3663,root/html602/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,https://root.cern,https://root.cern/root/html602/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,1,['Update'],['UpdateNCalls']
Deployability,"voidROOT::Math::BaseIntegratorOptions::SetWKSize(unsigned int size); unsigned intROOT::Math::BaseIntegratorOptions::WKSize() const. protected:. voidROOT::Math::BaseIntegratorOptions::ClearExtra(). Data Members; protected:. doubleROOT::Math::BaseIntegratorOptions::fAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::fExtraOptionsextra options ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorMultiDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size). std::string DefaultIntegrator(). IntegrationOneDim::Type DefaultIntegratorType(). double DefaultAbsTolerance(). double DefaultRelTolerance(). unsigned int DefaultWKSize(). ROOT::Math::IOptions & Default(const char* name); retrieve specific options - if not existing create a IOptions. ROOT::Math::IOptions * FindDefault(const char* name); find specific options - return 0 if not existing. void PrintDefault(const char* name = 0, ostream& os = std::cout); print only the specified default options. IntegratorMultiDimOptions(IOptions * extr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorMultiDimOptions.html:3295,integrat,integrator,3295,root/html528/ROOT__Math__IntegratorMultiDimOptions.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorMultiDimOptions.html,10,"['Integrat', 'integrat']","['IntegrationOneDim', 'IntegratorType', 'integrator']"
Deployability,"voidResetCSCBits(UChar_t f); voidSaveVizParams(ostream& out, const TString& tag, const TString& var); virtual voidSelectElement(Bool_t state); voidSetCompound(TEveCompound* c); voidSetCSCBits(UChar_t f); voidSetDestroyOnZeroRefCnt(Bool_t d); voidSetEditMainColor(Bool_t x); voidSetEditMainTransparency(Bool_t x); virtual voidSetElementName(const char* name); virtual voidSetElementNameTitle(const char* name, const char* title); virtual voidSetElementTitle(const char* title); voidSetMainAlpha(Float_t alpha); virtual voidSetMainColor(Color_t color); voidSetMainColorPixel(Pixel_t pixel); voidSetMainColorPtr(Color_t* color); voidSetMainColorRGB(UChar_t r, UChar_t g, UChar_t b); voidSetMainColorRGB(Float_t r, Float_t g, Float_t b); virtual voidSetMainTransparency(Char_t t); voidSetPickable(Bool_t p); voidSetPickableRecursively(Bool_t p); virtual Bool_tSetRnrChildren(Bool_t rnr); virtual Bool_tSetRnrSelf(Bool_t rnr); virtual Bool_tSetRnrSelfChildren(Bool_t rnr_self, Bool_t rnr_children); virtual Bool_tSetRnrState(Bool_t rnr); voidSetSourceObject(TObject* o); virtual voidSetTransMatrix(Double_t* carr); virtual voidSetTransMatrix(const TGeoMatrix& mat); voidSetUserData(void* ud); voidSetVizModel(TEveElement* model); voidSetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector& insp) const; virtual Bool_tSingleRnrState() const; voidSpawnEditor()MENU ; voidStampColorSelection(); voidStampObjProps(); voidStampTransBBox(); voidStampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Bool_tTestCSCBits(UChar_t f) const; TEveElement(); TEveElement(Color_t& main_color); TEveElement(const TEveElement& e); virtual voidUnHighlighted(); virtual voidUnSelected(); voidVizDB_Apply(const char* tag)MENU ; voidVizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidVizDB_Reapply()MENU ; voidVizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidWriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveElement.html:8451,update,update,8451,root/html602/TEveElement.html,https://root.cern,https://root.cern/root/html602/TEveElement.html,8,['update'],['update']
Deployability,"voidRooCacheManager<RooAbsCacheElement>::reset(); voidsetClearOnRedirect(Bool_t flag); Int_tRooCacheManager<RooAbsCacheElement>::setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tRooCacheManager<RooAbsCacheElement>::setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector&); virtual voidsterilize(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidRooCacheManager<RooAbsCacheElement>::wireCache(). Data Members; protected:. Bool_t_allowOptimize; static Bool_t_clearObsListClear obslist on sterilize?; Bool_t_clearOnRedirect; Int_tRooCacheManager<RooAbsCacheElement>::_lastIndex! Last slot accessed; Int_tRooCacheManager<RooAbsCacheElement>::_maxSize! Maximum size; vector<RooNormSetCache>RooCacheManager<RooAbsCacheElement>::_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen! ; RooArgSet*_optCacheObservables! current optCacheObservables ; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_size! Actual use; Bool_tRooCacheManager<RooAbsCacheElement>::_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 2, Bool_t clearCacheOnServerRedirect = kTRUE, Bool_t allowOptimize = kFALSE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooObjCacheManager.html:3513,Integrat,Integration,3513,root/html534/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html534/RooObjCacheManager.html,1,['Integrat'],['Integration']
Deployability,"voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra(). » Author: L. Moneta Fri Aug 15 2008 » Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IntegratorOptions.h 36806 2010-11-20 11:09:14Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:2682,Integrat,IntegratorOptions,2682,root/html532/ROOT__Math__BaseIntegratorOptions.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html,1,['Integrat'],['IntegratorOptions']
Deployability,"voidSetAxisHistogramLineWidth(Int_t lw = 2)MENU ; voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCandleChart(Bool_t can)TOGGLE GETTER ; voidSetCurrentEntries(TEntryList* entries); voidSetCurrentFirst(Long64_t); voidSetCurrentN(Long64_t); TParallelCoordSelect*SetCurrentSelection(const char* title); voidSetCurrentSelection(TParallelCoordSelect* sel); virtual voidSetCurveDisplay(Bool_t curve = 1)TOGGLE GETTER ; voidSetDotsSpacing(Int_t s = 0)MENU ; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidSetEntryList(TParallelCoord* para, TEntryList* enlist); voidSetGlobalLogScale(Bool_t)TOGGLE GETTER ; voidSetGlobalMax(Double_t max); voidSetGlobalMin(Double_t min); voidSetGlobalScale(Bool_t gl)TOGGLE GETTER ; voidSetInitEntries(TEntryList* entries); voidSetLineColor(Color_t col); voidSetLineWidth(Width_t wid); voidSetLiveRangesUpdate(Bool_t); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidSetNentries(Long64_t n); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidSetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetVertDisplay(Bool_t vert = kTRUE)TOGGLE GETTER ; voidSetWeightCut(Int_t w = 0)MENU ; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidUnzoomAll()MENU ; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TParallelCoord.html:10608,TOGGLE,TOGGLE,10608,root/html532/TParallelCoord.html,https://root.cern,https://root.cern/root/html532/TParallelCoord.html,1,['TOGGLE'],['TOGGLE']
Deployability,"voidSetCurrentEntries(TEntryList* entries); voidSetCurrentFirst(Long64_t); voidSetCurrentN(Long64_t); TParallelCoordSelect*SetCurrentSelection(const char* title); voidSetCurrentSelection(TParallelCoordSelect* sel); virtual voidSetCurveDisplay(Bool_t curve = 1)TOGGLE GETTER ; voidSetDotsSpacing(Int_t s = 0)MENU ; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidSetEntryList(TParallelCoord* para, TEntryList* enlist); voidSetGlobalLogScale(Bool_t)TOGGLE GETTER ; voidSetGlobalMax(Double_t max); voidSetGlobalMin(Double_t min); voidSetGlobalScale(Bool_t gl)TOGGLE GETTER ; voidSetInitEntries(TEntryList* entries); voidSetLineColor(Color_t col); voidSetLineWidth(Width_t wid); voidSetLiveRangesUpdate(Bool_t); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidSetNentries(Long64_t n); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidSetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetVertDisplay(Bool_t vert = kTRUE)TOGGLE GETTER ; voidSetWeightCut(Int_t w = 0)MENU ; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TParallelCoord(); TParallelCoord(Long64_t nentries); TParallelCoord(const TParallelCoord&); TParallelCoord(TTree* tree, Long64_t nentries); voidUnzoomAll()MENU ; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TParallelCoord.html:10416,TOGGLE,TOGGLE,10416,root/html602/TParallelCoord.html,https://root.cern,https://root.cern/root/html602/TParallelCoord.html,2,['TOGGLE'],['TOGGLE']
Deployability,"voidSetLimits(Double_t xmin, Double_t xmax); virtual voidSetMoreLogLabels(Bool_t more = kTRUE)TOGGLE GETTER ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTAttAxis::SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE)MENU ; virtual voidTAttAxis::SetNdivisions(Int_t n1, Int_t n2, Int_t n3, Bool_t optim = kTRUE); virtual voidSetNoExponent(Bool_t noExponent = kTRUE)TOGGLE GETTER ; static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetParent(TObject* obj); virtual voidSetRange(Int_t first = 0, Int_t last = 0)MENU ; virtual voidSetRangeUser(Double_t ufirst, Double_t ulast)MENU ; virtual voidTAttAxis::SetTickLength(Float_t length = 0.03)MENU ; virtual voidSetTicks(Option_t* option = ""+"")MENU ; virtual voidSetTimeDisplay(Int_t value)TOGGLE ; virtual voidSetTimeFormat(const char* format = """")MENU ; virtual voidSetTimeOffset(Double_t toffset, Option_t* option = ""local""); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTAttAxis::SetTitleColor(Color_t color = 1)MENU ; virtual voidTAttAxis::SetTitleFont(Style_t font = 62)MENU ; virtual voidTAttAxis::SetTitleOffset(Float_t offset = 1)MENU ; virtual voidTAttAxis::SetTitleSize(Float_t size = 0.04)MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUnZoom()MENU ; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidZoomOut(Double_t factor = 0, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TAxis.html:7833,TOGGLE,TOGGLE,7833,root/html532/TAxis.html,https://root.cern,https://root.cern/root/html532/TAxis.html,1,['TOGGLE'],['TOGGLE']
Deployability,"voidSetPlot(TObject* obj, const TString& opt); virtual Bool_tTEveElement::SetRnrChildren(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelf(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelfChildren(Bool_t rnr_self, Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidTEveElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector& insp); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEvePlot3D.html:15635,update,update,15635,root/html528/TEvePlot3D.html,https://root.cern,https://root.cern/root/html528/TEvePlot3D.html,8,['update'],['update']
Deployability,"voidSetType(ROOT::Math::IntegrationMultiDim::Type type); doubleSigma(); virtual intStatus() const. protected:. boolCheckFunction(); voidDoInitialize(). private:. ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const ROOT::Math::GSLMCIntegrator&); ROOT::Math::GSLMCIntegrator&operator=(const ROOT::Math::GSLMCIntegrator&). Data Members; private:. doublefAbsTol; unsigned intfCalls; unsigned intfDim; doublefError; ROOT::Math::GSLMonteFunctionWrapper*fFunction; ROOT::Math::MCIntegration::ModefMode; doublefRelTol; doublefResult; ROOT::Math::GSLRngWrapper*fRng; intfStatus; ROOT::Math::IntegrationMultiDim::TypefType; ROOT::Math::GSLMCIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMCIntegrator(MCIntegration::Type type = MCIntegration::kVEGAS, double absTol = 1.E-6, double relTol = 1E-4, unsigned int calls = 500000); constructors; constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. GSLMCIntegrator(const char * type, double absTol, double relTol, unsigned int calls); constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration using a char * (required by plug-in manager); @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GSLMCIntegrator.html:3076,integrat,integration,3076,root/html526/ROOT__Math__GSLMCIntegrator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GSLMCIntegrator.html,1,['integrat'],['integration']
Deployability,"voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidSetGLDevice(Int_t dev); virtual voidSetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidSetGridx(Int_t value = 1)TOGGLE ; virtual voidSetGridy(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetLogx(Int_t value = 1)TOGGLE ; virtual voidSetLogy(Int_t value = 1)TOGGLE ; virtual voidSetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidSetMaxPickDistance(Int_t maxPick = 5); virtual voidSetName(const char* name)MENU ; virtual voidSetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidSetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidSetPhi(Double_t phi = 30); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidSetSelected(TObject* obj); virtual voidSetTheta(Double_t theta = 30); virtual voidSetTicks(Int_t valuex = 1, Int_t valuey = 1); virtual voidSetTickx(Int_t value = 1)TOGGLE ; virtual voidSetTicky(Int_t value = 1)TOGGLE ; virtual voidSetTitle(const char* title = """"); virtual voidSetToolTipText(const char* text, Long_t delayms = 1000); virtual voidTAttPad:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPad.html:19895,TOGGLE,TOGGLE,19895,root/html534/TPad.html,https://root.cern,https://root.cern/root/html534/TPad.html,3,['TOGGLE'],['TOGGLE']
Deployability,"voidTEveElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector& insp) const; virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; virtual voidTAtt3D::Sizeof3D() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; TEvePolygonSetProjected(const char* n = ""TEvePolygonSetProjected"", const char* t = """"); virtual voidTEveElement::UnHighlighted(); virtual voidTEveProjected::UnRefProjectable(TEveProjectable* assumed_parent, bool notifyParent = true); virtual voidTEveElement::UnSelected(); virtual voidUpdateProjection(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveShape::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEvePolygonSetProjected.html:17636,update,update,17636,root/html602/TEvePolygonSetProjected.html,https://root.cern,https://root.cern/root/html602/TEvePolygonSetProjected.html,8,['update'],['update']
Deployability,"voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); voidSetTransparency(Char_t tr)MENU ; voidSetTriangle(Int_t i, Int_t v0, Int_t v1, Int_t v2); voidSetTriangleColor(Int_t i, UChar_t r, UChar_t g, UChar_t b, UChar_t a = 255); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidSetVertex(Int_t i, Float_t x, Float_t y, Float_t z); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; virtual voidTAtt3D::Sizeof3D() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; Int_t*Triangle(Int_t i); UChar_t*TriangleColor(Int_t i); Float_t*TriangleNormal(Int_t i); virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); Float_t*Vertex(Int_t i); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveTriangleSet.html:16768,update,update,16768,root/html534/TEveTriangleSet.html,https://root.cern,https://root.cern/root/html534/TEveTriangleSet.html,4,['update'],['update']
Deployability,"voidTEvePointSelectorConsumer::SetSourceCS(TEvePointSelectorConsumer::ETreeVarType_e cs); voidTEveElement::SetSourceObject(TObject* o); virtual voidTEvePointSet::SetTitle(const char* t); virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector& insp); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTPolyMarker3D::Size() const; virtual voidTAtt3D::Sizeof3D() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTEvePointSet::TakeAction(TEvePointSelector*); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveProjected::UnRefProjectable(TEveProjectable* assumed_parent); virtual voidTEveElement::UnSelected(); virtual voidUpdateProjection(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveLine::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveLineProjected.html:22104,update,update,22104,root/html528/TEveLineProjected.html,https://root.cern,https://root.cern/root/html528/TEveLineProjected.html,2,['update'],['update']
Deployability,"voidTGFrame::SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); virtual voidTGFrame::SetBackgroundColor(Pixel_t back); virtual voidTGWindow::SetBackgroundPixmap(Pixmap_t pixmap); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTGTextButton::SetBottomMargin(Int_t val); virtual voidTGFrame::SetCleanup(Int_t = kLocalCleanup); virtual voidTGWidget::SetCommand(const char* command); virtual voidTGCheckButton::SetDisabledAndSelected(Bool_t); voidTGFrame::SetDNDSource(Bool_t onoff); voidTGFrame::SetDNDTarget(Bool_t onoff); virtual voidTGButton::SetDown(Bool_t on = kTRUE, Bool_t emit = kFALSE); virtual voidTGFrame::SetDragType(Int_t type); virtual voidTGFrame::SetDrawOption(Option_t* = """"); virtual voidTGFrame::SetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidTGFrame::SetEditable(Bool_t); virtual voidTGWindow::SetEditDisabled(UInt_t on = kEditDisable); virtual voidTGButton::SetEnabled(Bool_t e = kTRUE)TOGGLE GETTER ; virtual voidTGTextButton::SetFont(FontStruct_t font, Bool_t global = kFALSE); virtual voidTGTextButton::SetFont(const char* fontName, Bool_t global = kFALSE); virtual voidTGTextButton::SetForegroundColor(Pixel_t fore); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGButton::SetGroup(TGButtonGroup* gr); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGFrame::SetLayoutBroken(Bool_t = kTRUE); virtual voidTGTextButton::SetLeftMargin(Int_t val); virtual voidTGWindow::SetMapSubwindows(Bool_t); voidTGTextButton::SetMargins(Int_t left = 0, Int_t right = 0, Int_t top = 0, Int_t bottom = 0); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGButton::SetOn(Bool_t on = kTRUE, Bool_t emit = kFALSE); virtual voidSetPopup(TGedPopup*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGedSelect.html:14302,TOGGLE,TOGGLE,14302,root/html532/TGedSelect.html,https://root.cern,https://root.cern/root/html532/TGedSelect.html,4,['TOGGLE'],['TOGGLE']
Deployability,"voidTGFrame::SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); virtual voidTGFrame::SetBackgroundColor(Pixel_t back); virtual voidTGWindow::SetBackgroundPixmap(Pixmap_t pixmap); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTGTextButton::SetBottomMargin(Int_t val); virtual voidTGFrame::SetCleanup(Int_t = kLocalCleanup); virtual voidTGWidget::SetCommand(const char* command); virtual voidTGCheckButton::SetDisabledAndSelected(Bool_t); voidTGFrame::SetDNDSource(Bool_t onoff); voidTGFrame::SetDNDTarget(Bool_t onoff); virtual voidTGButton::SetDown(Bool_t on = kTRUE, Bool_t emit = kFALSE); virtual voidTGFrame::SetDragType(Int_t type); virtual voidTGFrame::SetDrawOption(Option_t* = """"); virtual voidTGFrame::SetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidTGFrame::SetEditable(Bool_t); virtual voidTGWindow::SetEditDisabled(UInt_t on = kEditDisable); virtual voidTGButton::SetEnabled(Bool_t e = kTRUE)TOGGLE GETTER ; virtual voidTGTextButton::SetFont(FontStruct_t font, Bool_t global = kFALSE); virtual voidTGTextButton::SetFont(const char* fontName, Bool_t global = kFALSE); virtual voidTGTextButton::SetForegroundColor(Pixel_t fore); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGButton::SetGroup(TGButtonGroup* gr); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGFrame::SetLayoutBroken(Bool_t = kTRUE); virtual voidTGTextButton::SetLeftMargin(Int_t val); virtual voidTGWindow::SetMapSubwindows(Bool_t); voidTGTextButton::SetMargins(Int_t left = 0, Int_t right = 0, Int_t top = 0, Int_t bottom = 0); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGButton::SetOn(Bool_t on = kTRUE, Bool_t emit = kFALSE); voidSetPattern(Style_t pattern,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGedPatternSelect.html:14441,TOGGLE,TOGGLE,14441,root/html532/TGedPatternSelect.html,https://root.cern,https://root.cern/root/html532/TGedPatternSelect.html,4,['TOGGLE'],['TOGGLE']
Deployability,"voidTGFrame::SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); virtual voidTGFrame::SetBackgroundColor(Pixel_t back); virtual voidTGWindow::SetBackgroundPixmap(Pixmap_t pixmap); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTGTextButton::SetBottomMargin(Int_t val); virtual voidTGFrame::SetCleanup(Int_t = kLocalCleanup); virtual voidTGWidget::SetCommand(const char* command); virtual voidTGCheckButton::SetDisabledAndSelected(Bool_t); voidTGFrame::SetDNDSource(Bool_t onoff); voidTGFrame::SetDNDTarget(Bool_t onoff); virtual voidTGButton::SetDown(Bool_t on = kTRUE, Bool_t emit = kFALSE); virtual voidTGFrame::SetDragType(Int_t type); virtual voidTGFrame::SetDrawOption(Option_t* = """"); virtual voidTGFrame::SetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidTGFrame::SetEditable(Bool_t); virtual voidTGWindow::SetEditDisabled(UInt_t on = kEditDisable); virtual voidTGButton::SetEnabled(Bool_t e = kTRUE)TOGGLE GETTER ; virtual voidTGTextButton::SetFont(FontStruct_t font, Bool_t global = kFALSE); virtual voidTGTextButton::SetFont(const char* fontName, Bool_t global = kFALSE); virtual voidTGTextButton::SetForegroundColor(Pixel_t fore); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGButton::SetGroup(TGButtonGroup* gr); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGFrame::SetLayoutBroken(Bool_t = kTRUE); virtual voidTGTextButton::SetLeftMargin(Int_t val); virtual voidTGWindow::SetMapSubwindows(Bool_t); voidTGTextButton::SetMargins(Int_t left = 0, Int_t right = 0, Int_t top = 0, Int_t bottom = 0); voidSetMarkerStyle(Style_t pattern); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGButton::SetOn(Bool_t on = kTRUE, Bool_t emit = kFA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGedMarkerSelect.html:14133,TOGGLE,TOGGLE,14133,root/html532/TGedMarkerSelect.html,https://root.cern,https://root.cern/root/html532/TGedMarkerSelect.html,4,['TOGGLE'],['TOGGLE']
Deployability,"voidTGFrame::SetDNDTarget(Bool_t onoff); virtual voidTGFrame::SetDragType(Int_t type); virtual voidTGFrame::SetDrawOption(Option_t* = """"); virtual voidTGFrame::SetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidTGFrame::SetEditable(Bool_t); virtual voidTGWindow::SetEditDisabled(UInt_t on = kEditDisable); virtual voidTGFrame::SetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGFrame::SetLayoutBroken(Bool_t = kTRUE); virtual voidSetLineStyle(Style_t style); virtual voidSetLineWidth(Int_t width); virtual voidTGWindow::SetMapSubwindows(Bool_t); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); voidTGTextLBEntry::SetText(TGString* new_text); virtual voidTGTextLBEntry::SetTitle(const char* text); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTGLBEntry::Toggle(); virtual voidTGFrame::UnmapWindow(); virtual voidUpdate(TGLBEntry* e); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLineLBEntry.html:14137,Toggle,Toggle,14137,root/html534/TGLineLBEntry.html,https://root.cern,https://root.cern/root/html534/TGLineLBEntry.html,1,['Toggle'],['Toggle']
Deployability,"voidTGFrame::SetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGedFrame::SetGedEditor(TGedEditor* ed); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidSetModel(TObject* obj); voidTGedFrame::SetModelClass(TClass* mcl); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TEveProjectionManagerEditor(const TGWindow* p = 0, Int_t width = 170, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTGedFrame::Update(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveProjectionManagerEditor.html:15227,Update,Update,15227,root/html602/TEveProjectionManagerEditor.html,https://root.cern,https://root.cern/root/html602/TEveProjectionManagerEditor.html,2,['Update'],['Update']
Deployability,"voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGMainFrame::SetWindowName(const char* name = 0); voidTGMainFrame::SetWMPosition(Int_t x, Int_t y); voidTGMainFrame::SetWMSize(UInt_t w, UInt_t h); voidTGMainFrame::SetWMSizeHints(UInt_t wmin, UInt_t hmin, UInt_t wmax, UInt_t hmax, UInt_t winc, UInt_t hinc); voidTGMainFrame::SetWMState(EInitialState state); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidShow(); static voidTVirtualPadEditor::ShowEditor(); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; static voidTVirtualPadEditor::Terminate(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTVirtualPadEditor::TextAttributes(Int_t, Float_t, Int_t, Int_t, Float_t); TGedEditor(TCanvas* canvas = 0, UInt_t width = 175, UInt_t height = 20); virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidUpdate(TGedFrame* frame = 0); static voidTVirtualPadEditor::UpdateFillAttributes(Int_t col, Int_t sty); static voidTVirtualPadEditor::UpdateLineAttributes(Int_t col, Int_t sty, Int_t width); static voidTVirtualPadEditor::UpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); static voidTVirtualPadEditor::UpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGedEditor.html:19673,Update,UpdateFillAttributes,19673,root/html602/TGedEditor.html,https://root.cern,https://root.cern/root/html602/TGedEditor.html,8,['Update'],"['UpdateFillAttributes', 'UpdateLineAttributes', 'UpdateMarkerAttributes', 'UpdateTextAttributes']"
Deployability,"voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; TGLPolyMarker&operator=(const TGLPolyMarker&); TGLPolyMarker&operator=(TGLPolyMarker&&); virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TGLPolyMarker(const TBuffer3D& buffer); TGLPolyMarker(const TGLPolyMarker&); TGLPolyMarker(TGLPolyMarker&&); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPolyMarker.html:2655,Update,UpdateBoundingBox,2655,root/html602/TGLPolyMarker.html,https://root.cern,https://root.cern/root/html602/TGLPolyMarker.html,4,['Update'],"['UpdateBoundingBox', 'UpdateBoundingBoxesOfPhysicals']"
Deployability,"voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidTGLObject::SetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLObject::SetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLPlot3D.html:2912,Update,UpdateBoundingBox,2912,root/html534/TGLPlot3D.html,https://root.cern,https://root.cern/root/html534/TGLPlot3D.html,2,['Update'],"['UpdateBoundingBox', 'UpdateBoundingBoxesOfPhysicals']"
Deployability,"voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTAttAxis::ResetAttAxis(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidRotateTitle(Bool_t rotate = kTRUE)TOGGLE GETTER ; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSaveAttributes(ostream& out, const char* name, const char* subname); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSet(Int_t nbins, const Float_t* xbins); virtual voidSet(Int_t nbins, const Double_t* xbins); virtual voidSet(Int_t nbins, Double_t xmin, Double_t xmax); virtual voidTAttAxis::SetAxisColor(Color_t color = 1, Float_t alpha = 1.)MENU ; virtual voidSetBinLabel(Int_t bin, const char* label); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetDecimals(Bool_t dot = kTRUE)TOGGLE GETTER ; virtual voidSetDefaults(); virtual voidSetDrawOption(Option_t* = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTAttAxis::SetLabelColor(Color_t color = 1, Float_t alpha = 1.)MENU ; virtual voidTAttAxis::SetLabelFont(Style_t font = 62)MENU ; virtual voidTAttAxis::SetLabelOffset(Float_t offset = 0.005)MENU ; virtual voidTAttAxis::SetLabelSize(Float_t size = 0.04)MENU ; virtual voidSetLimits(Double_t xmin, Double_t xmax); virtual voidSetMoreLogLabels(Bool_t more = kTRUE)TOGGLE GETTER ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTAttAxis::SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE)MENU ; virtual voidTAttAxis::SetNdivisions(Int_t n1, Int_t n2, Int_t n3, Bool_t optim = kTRUE); virtual voidSetNoExponent(Bool_t noExponent = kTRUE)TOGGLE GETTER ; static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetParent(TObject* obj); virtual voidSetRange(Int_t first = 0, Int_t last =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TAxis.html:6663,TOGGLE,TOGGLE,6663,root/html534/TAxis.html,https://root.cern,https://root.cern/root/html534/TAxis.html,1,['TOGGLE'],['TOGGLE']
Deployability,"voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTStreamerElement::SetArrayDim(Int_t dim); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCtype(Int_t t); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTStreamerElement::SetMaxIndex(Int_t dim, Int_t max); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTStreamerElement::SetNewClass(TClass* cl); virtual voidTStreamerElement::SetNewType(Int_t dtype); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTStreamerElement::SetOffset(Int_t offset); virtual voidTStreamerElement::SetSize(Int_t dsize); voidSetSTLtype(Int_t t); virtual voidSetStreamer(TMemberStreamer* streamer); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTStreamerElement::SetTObjectOffset(Int_t tobjoffset); virtual voidTStreamerElement::SetType(Int_t dtype); virtual voidTStreamerElement::SetTypeName(const char* name); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTStreamerElement::Update(const TClass* oldClass, TClass* newClass); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStreamerSTL.html:6672,Update,Update,6672,root/html532/TStreamerSTL.html,https://root.cern,https://root.cern/root/html532/TStreamerSTL.html,1,['Update'],['Update']
Deployability,"voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTFormula::SetMaxima(Int_t maxop = 1000, Int_t maxpar = 1000, Int_t maxconst = 1000); virtual voidTFormula::SetName(const char* name); virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTFormula::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFormula::SetParameter(const char* name, Double_t parvalue); virtual voidTFormula::SetParameter(Int_t ipar, Double_t parvalue); virtual voidTFormula::SetParameters(const Double_t* params); virtual voidTFormula::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidTFormula::SetParName(Int_t ipar, const char* name); virtual voidTFormula::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTFormula::Update(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFormula.html:8778,Update,Update,8778,root/html602/RooFormula.html,https://root.cern,https://root.cern/root/html602/RooFormula.html,1,['Update'],['Update']
Deployability,"voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::VariableTransformBase::SetEnabled(Bool_t e); voidTMVA::VariableTransformBase::SetNormalise(Bool_t n); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTMVA::VariableTransformBase::SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; voidTMVA::VariableTransformBase::SetOutputDataSetInfo(TMVA::DataSetInfo* outputDsi); voidTMVA::VariableTransformBase::SetTMVAVersion(TMVA::TMVAVersion_t v); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::VariableTransformBase::SetUseSignalTransform(Bool_t e = kTRUE); virtual voidShowMembers(TMemberInspector&); const vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Spectators() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; const vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Targets() const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTMVA::VariableTransformBase::ToggleInputSortOrder(Bool_t sortOrder); virtual const TMVA::Event*Transform(const TMVA::Event *const, Int_t cls) const; virtual voidTObject::UseCurrentStyle(); Bool_tTMVA::VariableTransformBase::UseSignalTransform() const; TMVA::VariableDecorrTransformVariableDecorrTransform(TMVA::DataSetInfo& dsi); TMVA::VariableDecorrTransformVariableDecorrTransform(const TMVA::VariableDecorrTransform&); const vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Variables() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidWriteTransformationToStream(ostream&) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__VariableDecorrTransform.html:6485,Toggle,ToggleInputSortOrder,6485,root/html534/TMVA__VariableDecorrTransform.html,https://root.cern,https://root.cern/root/html534/TMVA__VariableDecorrTransform.html,1,['Toggle'],['ToggleInputSortOrder']
Deployability,"voidTObject::SetDtorOnly(void* obj); virtual voidTGCompositeFrame::SetEditable(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetEditDisabled(UInt_t on = 1); virtual voidTGFrame::SetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGedFrame::SetGedEditor(TGedEditor* ed); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidSetModel(TObject* obj); voidTGedFrame::SetModelClass(TClass* mcl); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTGeoGedFrame::Update(); voidUpdateElements(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoMixtureEditor.html:15702,Update,Update,15702,root/html532/TGeoMixtureEditor.html,https://root.cern,https://root.cern/root/html532/TGeoMixtureEditor.html,1,['Update'],['Update']
Deployability,"voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTask&operator=(const TTask& tt); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetActive(Bool_t active = kTRUE)TOGGLE ; voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBreakin(Int_t breakin = 1)TOGGLE ; voidSetBreakout(Int_t breakout = 1)TOGGLE ; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTask.html:7173,TOGGLE,TOGGLE,7173,root/html532/TTask.html,https://root.cern,https://root.cern/root/html532/TTask.html,1,['TOGGLE'],['TOGGLE']
Deployability,"voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidPadPaint(TVirtualPad* pad); virtual voidPadPaintFromViewer(TGLViewer* viewer); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTGLScene::PostDraw(TGLRnrCtx& rnrCtx); virtual voidTGLSceneBase::PostRender(TGLRnrCtx& rnrCtx); virtual voidTGLScene::PreDraw(TGLRnrCtx& rnrCtx); virtual Bool_tPreferLocalFrame() const; virtual voidTGLSceneBase::PreRender(TGLRnrCtx& rnrCtx); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTVirtualViewer3D::PrintObjects(); virtual Int_tTObject::Read(const char* name); virtual voidTGLScene::RebuildSceneInfo(TGLRnrCtx& rnrCtx); virtual voidTObject::RecursiveRemove(TObject* obj); TGLScene::LogicalShapeMap_t&TGLScene::RefLogicalShapes(); Bool_tTGLLockable::ReleaseLock(TGLLockable::ELock lock) const; voidTGLSceneBase::RemoveViewer(TGLViewerBase* viewer); virtual voidTGLSceneBase::Render(TGLRnrCtx& rnrCtx); virtual voidTGLScene::RenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); virtual voidTGLScene::RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); virtual voidTGLScene::RenderHighlight(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec); virtual voidTGLScene::RenderOpaque(TGLRnrCtx& rnrCtx); virtual voidTGLScene::RenderSelOpaque(TGLRnrCtx& rnrCtx); virtual voidTGLScene::RenderSelOpaqueForHighlight(TGLRnrCtx& rnrCtx); virtual voidTGLScene::RenderSelTransp(TGLRnrCtx& rnrCtx); virtual voidTGLScene::RenderSelTranspForHighlight(TGLRnrCtx& rnrCtx); virtual voidTGLScene::RenderTransp(TGLRnrCtx& rnrCtx); voidTObject::ResetBit(UInt_t f); virtual voidTVirtualViewer3D::ResetCameras(); virtual voidTVirtualViewer3D::ResetCamera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLScenePad.html:6834,Release,ReleaseLock,6834,root/html534/TGLScenePad.html,https://root.cern,https://root.cern/root/html534/TGLScenePad.html,3,['Release'],['ReleaseLock']
Deployability,"voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidPadPaint(TVirtualPad* pad); virtual voidPadPaintFromViewer(TGLViewer* viewer); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTGLScene::PostDraw(TGLRnrCtx& rnrCtx); virtual voidTGLSceneBase::PostRender(TGLRnrCtx& rnrCtx); virtual voidTGLScene::PreDraw(TGLRnrCtx& rnrCtx); virtual Bool_tPreferLocalFrame() const; virtual voidTGLSceneBase::PreRender(TGLRnrCtx& rnrCtx); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTVirtualViewer3D::PrintObjects(); virtual Int_tTObject::Read(const char* name); virtual voidTGLScene::RebuildSceneInfo(TGLRnrCtx& rnrCtx); virtual voidTObject::RecursiveRemove(TObject* obj); TGLScene::LogicalShapeMap_t&TGLScene::RefLogicalShapes(); Bool_tTGLLockable::ReleaseLock(TGLLockable::ELock lock) const; voidTGLSceneBase::RemoveViewer(TGLViewerBase* viewer); virtual voidTGLSceneBase::Render(TGLRnrCtx& rnrCtx); virtual voidTGLScene::RenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); virtual voidTGLScene::RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); virtual voidTGLScene::RenderOpaque(TGLRnrCtx& rnrCtx); virtual voidTGLScene::RenderSelOpaque(TGLRnrCtx& rnrCtx); virtual voidTGLScene::RenderSelTransp(TGLRnrCtx& rnrCtx); virtual voidTGLScene::RenderTransp(TGLRnrCtx& rnrCtx); voidTObject::ResetBit(UInt_t f); virtual voidTVirtualViewer3D::ResetCameras(); virtual voidTVirtualViewer3D::ResetCamerasAfterNextUpdate(); virtual Bool_tTGLScene::ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); static voidTGLScene::RGBAFromColorIdx(Float_t* rgba, Color_t ci, Char_t transp = 0); virtual voidTObject::SaveAs(const char* filename =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLScenePad.html:6834,Release,ReleaseLock,6834,root/html532/TGLScenePad.html,https://root.cern,https://root.cern/root/html532/TGLScenePad.html,1,['Release'],['ReleaseLock']
Deployability,"voidTPad::SetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); virtual voidTPad::SetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTPad::SetLogx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogy(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidTPad::SetName(const char* name)MENU ; virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidTPad::SetPhi(Double_t phi = 30); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidTPad::SetSelected(TObject* obj); virtual voidTPad::SetTheta(Double_t theta = 30); virtual voidTPad::SetTicks(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetTickx(Int_t value = 1)TOGGLE ; virtual voidTPad::S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEvePad.html:19120,TOGGLE,TOGGLE,19120,root/html534/TEvePad.html,https://root.cern,https://root.cern/root/html534/TEvePad.html,3,['TOGGLE'],['TOGGLE']
Deployability,"voidTPad::SetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); virtual voidTPad::SetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTPad::SetLogx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogy(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); virtual voidSetMaximum(Double_t max = 1); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidSetMethod(const char* method)MENU ; virtual voidSetMinimum(Double_t min = 0); virtual voidTPad::SetName(const char* name)MENU ; virtual voidTPad::SetNumber(Int_t number); voidSetObject(TObject* obj = 0); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidTPad::SetPhi(Double_t phi = 30); virtual voidSetRange(Double_t xmin = 0, Double_t xmax = 1); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSlider.html:21336,TOGGLE,TOGGLE,21336,root/html534/TSlider.html,https://root.cern,https://root.cern/root/html534/TSlider.html,3,['TOGGLE'],['TOGGLE']
Deployability,"voidUpdateProjection(). protected:. voidSetDepthCommon(Float_t d, TEveElement* el, Float_t* bbox); virtual voidSetDepthLocal(Float_t d). private:. TEveProjected&operator=(const TEveProjected&). Data Members; protected:. Float_tfDepthz coordinate; TEveProjectionManager*fManagermanager; TEveProjectable*fProjectablelink to original object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TEveProjected(); Destructor.; If fProjectable is non-null, *this is removed from its list of; projected replicas. TEveElement* GetProjectedAsElement(); Returns this projected dynamic-casted to TEveElement.; This is needed as class TEveProjected is used as secondary; inheritance. void SetProjection(TEveProjectionManager* mng, TEveProjectable* model); Sets projection manager and reference in the projectable object. Method called; immediately after default constructor.; See also TEveProjectionManager::ImportElements(). void UnRefProjectable(TEveProjectable* assumed_parent, bool notifyParent = true); Remove reference to projectable. void SetDepth(Float_t d); Set depth coordinate for the element.; Bounding-box should also be updated.; If projection type is 3D, this only sets fDepth member. void SetDepthCommon(Float_t d, TEveElement* el, Float_t* bbox); Utility function to update the z-values of the bounding-box.; As this is an abstract interface, the element and bbox pointers; must be passed from outside. void SetDepthLocal(Float_t d); Base-class implementation -- just sets fDepth. TEveProjectable& operator=(const TEveProjected& ). TEveProjectionManager* GetManager() const; { return fManager; }. TEveProjectable* GetProjectable() const; { return fProjectable; }. Float_t GetDepth() const; { return fDepth; }. void UpdateProjection(). » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveProjected.html:2376,update,updated,2376,root/html534/TEveProjected.html,https://root.cern,https://root.cern/root/html534/TEveProjected.html,5,"['Update', 'update']","['UpdateProjection', 'update', 'updated']"
Deployability,"void ClearAll () const;  clear all cached pdf objects ;  ; void ComputeIntervalFromApproxPosterior (double c1, double c2) const;  compute the interval using the approximate posterior function ;  ; void ComputeIntervalFromCdf (double c1, double c2) const;  internal function compute the interval using Cdf integration ;  ; void ComputeIntervalUsingRooFit (double c1, double c2) const;  internal function compute the interval using RooFit ;  ; void ComputeShortestInterval () const;  compute the shortest interval from the histogram representing the posterior ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Attributes; TF1 * fApproxPosterior;  TF1 representing the scanned posterior function. ;  ; double fBrfPrecision;  root finder precision ;  ; RooArgSet fConditionalObs;  conditional observables ;  ; RooAbsData * fData;  data set ;  ; RooArgSet fGlobalObs;  global observables ;  ; RooAbsReal * fIntegratedLikelihood;  integrated likelihood function, i.e - unnormalized posterior function ;  ; TString fIntegrationType;  ; double fLeftSideFraction;  fraction of probability content on left side of interval ;  ; RooAbsReal * fLikelihood;  internal pointer to likelihood function ;  ; std::unique_ptr< RooAbsReal > fLogLike;  internal pointer to log likelihood function ;  ; double fLower;  computer lower interval bound ;  ; double fNLLMin;  minimum value of Nll ;  ; int fNScanBins;  number of bins to scan, if = -1 no scan is done (default) ;  ; RooArgSet fNuisanceParameters;  nuisance parameters ;  ; RooAbsPdf * fNuisancePdf;  nuisance pdf (needed when using nuisance sampling technique) ;  ; int fNumIterations;  number of iterations (when using ToyMC) ;  ; RooAbsPdf * fPdf;  model pdf (could contain the nuisance pdf as constraint term) ;  ; RooArgSet fPOI;  POI. ;  ; ROOT::Math::IGenFunction * fPosteriorFuncti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html:18402,integrat,integrated,18402,doc/master/classRooStats_1_1BayesianCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html,1,['integrat'],['integrated']
Deployability,"void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooRealProxy mean;  ; RooRealProxy sigma;  ; RooRealProxy width;  ; RooRealProxy x;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVoigtian.html:69062,integrat,integration,69062,doc/master/classRooVoigtian.html,https://root.cern,https://root.cern/doc/master/classRooVoigtian.html,1,['integrat'],['integration']
Deployability,"void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Attributes; RooLinkedList _configSets;  List of configuration sets for individual integration methods. ;  ; RooCategory _method1D;  Selects integration method for 1D p.d.f.s. ;  ; RooCategory _method1DCat;  Selects integration method for 1D p.d.f.s with categories. ;  ; RooCategory _method1DCond;  Selects integration method for 1D conditional p.d.f.s. ;  ; RooCategory _method1DCondCat;  Selects integration method for 1D conditional p.d.f.s with categories. ;  ; RooCategory _method2D;  Selects integration method for 2D p.d.f.s. ;  ; RooCategory _method2DCat;  Selects integration method for 2D p.d.f.s with categories. ;  ; RooCategory _method2DCond;  Selects integration method for 2D conditional p.d.f.s. ;  ; RooCategory _method2DCondCat;  Selects integration method for 2D conditional p.d.f.s with categories. ;  ; RooCategory _methodND;  Selects integration method for ND p.d.f.s. ;  ; RooCategory _methodNDCat;  Selects integration method for ND p.d.f.s with categories. ;  ; RooCategory _methodNDCond;  Selects integration method for ND conditional p.d.f.s. ;  ; RooCategory _methodNDCondCat;  Selects integration method for ND conditional p.d.f.s with categories. ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumGenConfig.html:12566,integrat,integration,12566,doc/master/classRooNumGenConfig.html,https://root.cern,https://root.cern/doc/master/classRooNumGenConfig.html,1,['integrat'],['integration']
Deployability,"void SetPoint (Int_t i, Double_t x, Double_t y);  Set x and y values for point number i. ;  ; virtual void SetPointX (Int_t i, Double_t x);  Set x value for point i. ;  ; virtual void SetPointY (Int_t i, Double_t y);  Set y value for point i. ;  ; virtual void SetStats (Bool_t stats=kTRUE);  Set statistics option on/off. ;  ; void SetTitle (const char *title="""") override;  Change (i.e. ;  ; virtual void Sort (Bool_t(*greater)(const TGraph *, Int_t, Int_t)=&TGraph::CompareX, Bool_t ascending=kTRUE, Int_t low=0, Int_t high=-1111);  Sorts the points of this TGraph using in-place quicksort (see e.g. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TGraph. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UseCurrentStyle () override;  Set current style settings in this graph This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; void Zero (Int_t &k, Double_t AZ, Double_t BZ, Double_t E2, Double_t &X, Double_t &Y, Int_t maxiterations);  Find zero of a continuous function. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCurve.html:18089,continuous,continuous,18089,doc/master/classRooCurve.html,https://root.cern,https://root.cern/doc/master/classRooCurve.html,4,['continuous'],['continuous']
Deployability,"void setFitConfig (const char *pdfName, const char *obsName, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={});  ; void setGenConfig (const char *pdfName, const char *obsName, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={});  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsStudy;  RooAbsStudy ()=default;  ;  RooAbsStudy (const char *name, const char *title);  Constructor. ;  ;  RooAbsStudy (const RooAbsStudy &other);  Copy constructor. ;  ;  ~RooAbsStudy () override;  Destructor. ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; RooLinkedList * detailedData ();  ; virtual void dump ();  ; void releaseDetailData ();  ; void storeDetailedOutput (bool flag);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; RooDataSet * summaryData ();  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGenFitStudy.html:2141,release,releaseDetailData,2141,doc/master/classRooGenFitStudy.html,https://root.cern,https://root.cern/doc/master/classRooGenFitStudy.html,1,['release'],['releaseDetailData']
Deployability,"void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; double _eps = 1e-7;  Precision. ;  ; std::unique_ptr< RooFunctor > _ftor;  ! Functor binding of RooAbsReal ;  ; RooRealProxy _func;  Input function. ;  ; RooSetProxy _nset;  Normalization set (optional) ;  ; Int_t _order = 1;  Derivation order. ;  ; std::unique_ptr< ROOT::Math::RichardsonDerivator > _rd;  ! Derivator ;  ; RooRealProxy _x;  Observable. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDerivative.html:55201,integrat,integration,55201,doc/master/classRooDerivative.html,https://root.cern,https://root.cern/doc/master/classRooDerivative.html,1,['integrat'],['integration']
Deployability,"void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooRealProxy _eff;  Efficiency function. ;  ; RooRealProxy _pdf;  Probability Density function. ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooEffProd.html:68222,configurat,configuration,68222,doc/master/classRooEffProd.html,https://root.cern,https://root.cern/doc/master/classRooEffProd.html,1,['configurat'],['configuration']
Deployability,"vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoVolumeAssembly&operator=(const TGeoVolumeAssembly&); Bool_tTGeoVolume::OptimizeVoxels()MENU ; virtual voidTGeoVolume::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTGeoVolume::Print(Option_t* option = """") constMENU ; voidTGeoVolume::PrintNodes() const; voidTGeoVolume::PrintVoxels() constMENU ; voidTGeoVolume::RandomPoints(Int_t npoints = 1000000, Option_t* option = """")MENU ; voidTGeoVolume::RandomRays(Int_t nrays = 10000, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0, const char* target_vol = 0, Bool_t check_norm = kFALSE)MENU ; voidTGeoVolume::Raytrace(Bool_t flag = kTRUE)TOGGLE GETTER ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTGeoVolume::RegisterYourself(Option_t* option = """"); voidTGeoVolume::Release(); voidTGeoVolume::RemoveNode(TGeoNode* node); TGeoNode*TGeoVolume::ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); voidTGeoVolume::ReplayCreation(const TGeoVolume* other); voidTGeoAtt::ResetAttBit(UInt_t f); virtual voidTAttFill::ResetAttFill(Option_t* option = """"); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidTGeoVolume::SaveAs(const char* filename, Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTAttLine::SaveLineAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1, Int_t widdef = 1); virtual voidTGeoVolume::SavePrimitive(ostream& out, Option_t* option = """"); voidTGeoVolume::SelectVolume(Bool_t clear = kFALSE); voidTGeoVolume::SetActiveDaughters(Bool_t flag = kTRUE); voidTGeoVolume::SetActivity(Bool_t flag = kTRUE); voidTGeoVolum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoVolumeAssembly.html:26578,Release,Release,26578,root/html602/TGeoVolumeAssembly.html,https://root.cern,https://root.cern/root/html602/TGeoVolumeAssembly.html,2,['Release'],['Release']
Deployability,"w (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters; kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the painting should be forced using gPad->Update(); in order to make sure the statistics box is created:. h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");. Without gPad->Update() the line h->FindObject(""stats""); returns a null pointer.; When a histogram is drawn with the option ""SAME"", the statistics box; is not drawn. To force the statistics box drawing with the option; ""SAME"", the option ""SAMES"" must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (""h"" being the pointer to the histogram):. Root > TPaveStats *st ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:16856,update,updated,16856,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,8,['update'],['updated']
Deployability,"w PDF of the form. . \[ f(x) = \mathcal{N} \cdot \sum_{i} a_{i} * x^{b_i} \]. Definition at line 20 of file RooPowerSum.h. Public Member Functions;  RooPowerSum ();  ;  RooPowerSum (const char *name, const char *title, RooAbsReal &x, const RooArgList &coefList, const RooArgList &expList);  Create a power law in the variable x. ;  ;  RooPowerSum (const RooPowerSum &other, const char *name=nullptr);  Copy constructor. ;  ; double analyticalIntegral (int code, const char *rangeName=nullptr) const override;  Do the analytical integral according to the code that was returned by getAnalyticalIntegral(). ;  ; RooAbsReal const & base () const;  Get the base of the exponentiated terms (aka. x variable). ;  ; TObject * clone (const char *newname) const override;  ; RooArgList const & coefList () const;  Get the list of coefficients. ;  ; RooArgList const & expList () const;  Get the list of exponents. ;  ; int getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const override;  Advertise to RooFit that this function can be analytically integrated. ;  ; std::string getFormulaExpression (bool expand) const;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPowerSum.html:1442,integrat,integrated,1442,doc/master/classRooPowerSum.html,https://root.cern,https://root.cern/doc/master/classRooPowerSum.html,1,['integrat'],['integrated']
Deployability,w Slider range. void DoSliderPressed(); Slot connected to the x-axis Range slider for initialising the; values of the slider movement. void DoSliderReleased(); Slot connected to the x-axis Range slider for finalizing the; values of the slider movement. void DoAxisRange(); Slot connected to the number entry fields containing the Max/Min; value of the x-axis. void DoBinReleased(); Slot connected to the rebin slider in case of a not ntuple histogram; Updates some other widgets which are related to the rebin slider. void DoBinMoved(Int_t number); Slot connected to the rebin slider in case of a not ntuple histogram; (does the Rebinning of the histogram). void DoBinPressed(); Slot connected to the rebin slider in case of a not ntuple histogram. void DoBinReleased1(); Slot connected to the BinNumber Slider in case of a ntuple histogram; (does the Rebinning of the histogram). void DoBinMoved1(); Slot connected to the rebin slider in case of an ntuple histogram.; It updates the BinNumberEntryField during the BinSlider movement. void DoBinLabel(); Slot connected to the Bin number entry of the Rebinning tab. void DoBinLabel1(); Slot connected to the Bin number entry of the Rebinning tab. void DoOffsetPressed(); Slot connected to the OffSetSlider that saves the OldBinOffset; (nessesary for delay draw mode). void DoOffsetReleased(); Slot connected to the OffSetSlider.; It changes the origin of the histogram inbetween a binwidth and; rebin the histogram with the new Offset given by the Slider. void DoOffsetMoved(Int_t num); Slot connected to the OffSetSlider.; It changes the origin of the histogram inbetween a binwidth and; rebin the histogram with the new offset given by the Slider. void DoBinOffset(); Slot connected to the OffSetNumberEntry which is related to the; OffSetSlider changes the origin of the histogram inbetween a binwidth. void DoApply(); Slot connected to the Apply button of the Binning tab. void DoCancel(); Slot connected to the Cancel button of the Binning tab. TS,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1Editor.html:30516,update,updates,30516,root/html528/TH1Editor.html,https://root.cern,https://root.cern/root/html528/TH1Editor.html,10,['update'],['updates']
Deployability,"w into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); Move focus to a different box position and extent in nsteps. Perform; rotation with dlat,dlong,dpsi at each step. void MoveViewCommand(Char_t chCode, Int_t count = 1); 'a' increase scale factor (clip cube borders); 's' decrease scale factor (clip cube borders). void MoveWindow(Char_t option); Move view window :; l,L - left; h,H - right; u,U - down; i,I - up. void ZoomIn(); Zoom in. void ZoomOut(); Zoom out. void Streamer(TBuffer& b); Stream an object of class TView3D. void Centered(); {Centered3DImages();}. void Front(); {FrontView();}. void ShowAxis(); {ToggleRulers(); }. void Side(); {SideView();}. void Top(); {TopView();}. void ZoomMove(); {ToggleZoom();}. void Zoom(); {ZoomView();}. void UnZoom(); {UnzoomView();}. Double_t GetDview() const; {return fDview;}. Double_t GetDproj() const; {return fDproj;}. Bool_t GetAutoRange(); {return fAutoRange;}. Double_t GetLatitude(); {return fLatitude;}. Double_t GetLongitude(); {return fLongitude;}. Double_t GetPsi(); {return fPsi;}. Double_t * GetRmax(); {return fRmax;}. Double_t * GetRmin(); {return fRmin;}. TSeqCollection * GetOutline(); {return fOutline; }. Double_t * GetTback(); {return fTback;}. Double_t * GetTN(); {return fTN;}. Double_t * GetTnorm(); {return fTnorm;}. Int_t GetSystem(); {return fSystem;}. Double_t GetWindowWidth() const; {return 0.5*(fUVcoord[1]-fUVcoord[0]);}. Double_t GetWindowHeight() const; {return 0.5*(fUVcoord[3]-fUVcoord[2]);}. Bool_t IsPerspective() const; {return TestBit(kPerspective);}. Bool_t IsViewChanged() const; {return fChanged;}. void SetAutoRange(Bool_t autorange = kTRUE); {fAutoRange=autorange;}. void SetDview(Double_t dview); {fDview=dvie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TView3D.html:22541,Toggle,ToggleZoom,22541,root/html532/TView3D.html,https://root.cern,https://root.cern/root/html532/TView3D.html,1,['Toggle'],['ToggleZoom']
Deployability,"w such action, one could either grant generic access for all or one could allow to execute only special method:; root [8] serv->Restrict(""/Folder/histo1"", ""allow=all"");; root [9] serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle"");; One could provide several options for the same item, separating them with ‘&’ sign:; root [10] serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle&hide=guest"");; Complete list of supported options could be found in TRootSniffer:Restrict() method documentation.; 1.5 Using FastCGI interface; FastCGI is a protocol for interfacing interactive programs with a web server like Apache, lighttpd, Microsoft ISS and many others.; When starting THttpServer, one could specify:; serv = new THttpServer(""fastcgi:9000"");; In fact, the FastCGI interface can run in parallel to http server. One can just call:; serv = new THttpServer(""http:8080"");; serv->CreateEngine(""fastcgi:9000"");; One could specify a debug parameter to be able to adjust the FastCGI configuration on the web server:; serv->CreateEngine(""fastcgi:9000?debug=1"");; All user access will be ruled by the main web server - for the moment one cannot restrict access with fastcgi engine.; 1.5.1 Configure fastcgi with Apcahe2; First of all, one should compile and install mod_fastcgi module. Then mod_fastcgi should be specified in httpd.conf to load it when Apache server is started. Finally in host configuration file one should have following lines:; <IfModule mod_fastcgi.c>; FastCgiExternalServer ""/srv/www/htdocs/root.app"" -host rootapp_host_name:9000; </IfModule>; Here is supposed that directory “/srv/www/htdocs” is root directory for web server. Than one should be able to open address:; http://apache_host_name/root.app/; 1.5.2 Configure fastcgi with lighttpd; An example of configuration file for lighttpd server is:; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); Be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:6301,configurat,configuration,6301,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,2,['configurat'],['configuration']
Deployability,"w the object communication mechanism can be used for handling the TCanvas’s mouse/key events in an interpreted class. With this demo you can fill histograms by hand:. Click the left button or move mouse with button pressed to fill histograms.; Use the right button of the mouse to reset the histograms. 26.6.4 Complex GUI Using Signals and Slots (guitest.C); Based on $ROOTSYS/test/guitest.cxx this example demonstrates:. All features of the original compiled guitest.cxx program.; Sophisticated use of signals and slots to build a complete user interface that can be executed either in the interpreter or as a compiled program. 27 Automatic HTML Documentation. THtml is ROOT’s documentation engine. It can be used to document your classes in a reference guide, and to convert your text or source files to HTML.; 27.1 Reference Guide; The Reference Guide for the ROOT classes at http://root.cern.ch/root/html/ has been generated by ROOT’s THtml class. Just as for ROOT’s classes, it can generate (and update) a reference guide for your classes, too. You document your classes using source code comments. All comments will be automatically put into a <pre></pre> environment to keep the indentation and line length. You can write “raw” HTML by enclosing comments in the keywords Begin_Html and End_Html.; To generate documentation for the class TObject you could run the following commands:; root[] THtml h; root[] h.SetInputDir(""$(ROOTSYS)"");; root[] h.MakeClass(""TObject"");; root[] h.CreateJavascript();; root[] h.CreateStylesheet();; The comments following the first comment of the form //____________________, before any method, is assumed to be the class description. As with any other documentation part, it has to be a continuous block of comments.; Any documented class will have an class index entry in the ClassIndex.html, showing their name with a link to their documentation page and a miniature description. This description for e.g. the class MyClass has to be given in MyClass's header ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1240216,update,update,1240216,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['update'],['update']
Deployability,"w(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriendconnects the trees in the chain. When a chain is deleted, its friend elements are also deleted. The number of entries in the friend must be equal or greater to the number of entries of the original chain. If the friend has fewer entries a warning is given and the resulting histogram will have missing entries. For additional information see TTree::AddFriends(). A full example of a tree and friends is in Example #3 ($ROOTSYS/tutorials/tree/tree3.C) in the Trees section above.; 13 Math Libraries in ROOT; The aim of Math libraries in ROOT is to provide and to support a coherent set of mathematical and statistical functions. The latest developments have been concentrated in providing first versions of the MathCore and MathMore libraries, included in ROOT v5.08. Other recent developments include the new version of MINUIT, which has been re-designed and re-implemented in the C++ language. It is integrated in ROOT. In addition, an optimized package for describing small matrices and vector with fixed sizes and their operation has been developed (SMatrix). The structure is shown in the following picture. Math libraries and packages. 13.1 MathCore Library; MathCore provides a collection of functions and C++ classes for numerical computing. This library includes only the basic mathematical functions and algorithms and not all the functionality required by the physics community. A more advanced mathematical functionality is provided by the MathMore library. The current set of included classes, which are provided in the ROOT::Math namespace are:. Basic special functions like the gamma, beta and error function.; Mathematical functions used in statistics, such as the probability density functions and the cumulative distributions functions (lower and upper integral of the pdf’s).; Generic function classes and interfaces for evaluating one-dimensional (ROOT::Math::IBaseFunctiononeDim) and mul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:655636,integrat,integrated,655636,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['integrat'],['integrated']
Deployability,"w(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidTGLObject::SetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLObject::SetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TGLPlot3D(); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPlot3D.html:2954,Update,UpdateBoundingBox,2954,root/html602/TGLPlot3D.html,https://root.cern,https://root.cern/root/html602/TGLPlot3D.html,4,['Update'],"['UpdateBoundingBox', 'UpdateBoundingBoxesOfPhysicals']"
Deployability,"w, x, 10000); ; # Again, if you do a vanilla fit, you'll get a bias; fit3 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit3.Print(); ; # This time, the bias is not the same factor in each bin! This means our; # trick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by integrating the pdf in each bin. So if; # you know your per-bin bias variations are small or performance is an; # issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins()); fit4 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the general case, one can use the; # IntegrateBins() command argument. Now, the pdf is not evaluated at the; # bin centers, but numerically integrated over each bin and divided by the; # bin width. The parameter for IntegrateBins() is the required precision; # for the numeric integrals. This is computationally expensive, but the; # bias is now not a problem anymore.; fit5 = powerlaw.fitTo(powerlaw_data, IntegrateBins=1e-3, Save=True, PrintLevel=-1, SumW2Error=False); fit5.Print(); ; # Improving numerical stability; # -----------------------------; ; # There is one more problem with binned fits that is related to the binning; # effects because often, a binned fit is affected by both problems.; #; # The issue is numerical stability for fits with a greatly different number; # of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; # the NLL, where \f[n\f] is the number of observations in the bin, and; # \f[p\f] the predicted probability to have an event in that bin. The; # difference in the logarithms for each bin is small, but the difference in; # \f[n\f] can be orders of magnitudes! Therefore, when sum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:5143,integrat,integrated,5143,doc/master/rf614__binned__fit__problems_8py.html,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html,1,['integrat'],['integrated']
Deployability,"w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. Int_t setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Setter function without integration set. Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. void insertObjectHook(RooAbsCacheElement& ); Interface function to perform post-insert operations on cached object. » Last changed: Mon Jul 4 15:22:21 2011 » Last generated: 2011-07-04 15:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCacheManager_RooAbsCacheElement_.html:4517,integrat,integration,4517,root/html530/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html530/RooCacheManager_RooAbsCacheElement_.html,1,['integrat'],['integration']
Deployability,"w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. Int_t setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Setter function without integration set. Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. void insertObjectHook(RooAbsCacheElement& ); Interface function to perform post-insert operations on cached object. » Last changed: Thu Nov 3 20:07:39 2011 » Last generated: 2011-11-03 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCacheManager_RooAbsCacheElement_.html:4517,integrat,integration,4517,root/html532/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html532/RooCacheManager_RooAbsCacheElement_.html,1,['integrat'],['integration']
Deployability,"w::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPconEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPconEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a given pcon. void CreateSections(Int_t inew); Change dynamically the number of sections. Bool_t CheckSections(Bool_t change = kFALSE); Check validity of sections. void UpdateSections(); Update sections according fShape. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoSectionChange(Int_t i); Change parameters of section isect;. void DoNz(); Change number of sections. void DoPhi(); Change phi range. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); {;}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoPconEditor.h 21425 2007-12-17 15:59:27Z brun $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPconEditor.html:21658,Update,UpdateSections,21658,root/html532/TGeoPconEditor.html,https://root.cern,https://root.cern/root/html532/TGeoPconEditor.html,2,['Update'],"['Update', 'UpdateSections']"
Deployability,"wID) override;  Makes context ctx current OpenGL context. ;  ; void MapRaised (Window_t wid) override;  Maps the window ""id"" and all of its subwindows that have had map requests on the screen and put this window on the top of of the stack of all windows. ;  ; void MapSubwindows (Window_t wid) override;  Maps all subwindows for the specified window ""id"" in top-to-bottom stacking order. ;  ; void MapWindow (Window_t wid) override;  Maps the window ""id"" and all of its subwindows that have had map requests. ;  ; void MoveResizeWindow (Window_t wid, Int_t x, Int_t y, UInt_t w, UInt_t h) override;  Changes the size and location of the specified window ""id"" without raising it. ;  ; void MoveWindow (Int_t wid, Int_t x, Int_t y) override;  Moves the window ""wid"" to the specified x and y coordinates. ;  ; void MoveWindow (Window_t wid, Int_t x, Int_t y) override;  Moves the specified window to the specified x and y coordinates. ;  ; Bool_t NeedRedraw (ULong_t tgwindow, Bool_t force) override;  Notify the low level GUI layer ROOT requires ""tgwindow"" to be updated. ;  ; void NextEvent (Event_t &event) override;  The ""event"" is set to default event. ;  ; Int_t OpenDisplay (const char *displayName) override;  Opens connection to display server (if such a thing exist on the current platform). ;  ; Int_t OpenPixmap (UInt_t w, UInt_t h) override;  Creates a pixmap of the width ""w"" and height ""h"" you specified. ;  ; Bool_t ParseColor (Colormap_t cmap, const char *cname, ColorStruct_t &color) override;  Looks up the string name of a color ""cname"" with respect to the screen associated with the specified colormap. ;  ; Bool_t PointInRegion (Int_t x, Int_t y, Region_t reg) override;  Returns kTRUE if the point [x, y] is contained in the region reg. ;  ; Region_t PolygonRegion (Point_t *points, Int_t np, Bool_t winding) override;  Returns a region for the polygon defined by the points array. ;  ; void PutImage (Drawable_t wid, GContext_t gc, Drawable_t img, Int_t dx, Int_t dy, Int_t x, In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:18584,update,updated,18584,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,2,['update'],['updated']
Deployability,"wOption(Option_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidSetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; static voidSetFolder(Bool_t isfolder = kTRUE); voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); voidSetGrayscale(Bool_t set = kTRUE)TOGGLE GETTER ; virtual voidTPad::SetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; voidSetHighLightColor(Color_t col); virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTPad::SetLogx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogy(Int_t value = 1)TOGGLE ; virtual voidTPad::SetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidTPad::SetMaxPickDistance(Int_t maxPick = 5); virtual voidTPad::SetName(const char* name)MENU ; virtual voidTPad::SetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTPad::SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidTPad::SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCanvas.html:22120,TOGGLE,TOGGLE,22120,root/html532/TCanvas.html,https://root.cern,https://root.cern/root/html532/TCanvas.html,1,['TOGGLE'],['TOGGLE']
Deployability,"w[i]^2 in the bin corresponding to x[i].; if w is NULL each entry is assumed a weight=1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void FillRandom(const char* fname, Int_t ntimes = 5000); -*-*-*-*-*Fill histogram following distribution in function fname*-*-*-*. The distribution contained in the function fname (TF1) is integrated; over the channel contents for the bin range of this histogram.; It is normalized to 1.; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Fill histogram channel; ntimes random numbers are generated. One can also call TF1::GetRandom to get a random variate from a function. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**-*-*-*-*-*-*-*. void FillRandom(TH1* h, Int_t ntimes = 5000); -*-*-*-*-*Fill histogram following distribution in histogram h*-*-*-*. The distribution contained in the histogram h (TH1) is integrated; over the channel contents for the bin range of this histogram.; It is normalized to 1.; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Fill histogram channel; ntimes random numbers are generated. SPECIAL CASE when the target histogram has the same binning as the source.; in this case we simply use a poisson distribution where; the mean value per bin = bincontent/integral. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**-*-*-*-*-*-*-*. Int_t FindBin(Double_t x, Double_t y = 0, Double_t z = 0); Return Global bin number corresponding to x,y,z. 2-D and 3-D histograms are represented with a one dimensional; structure. This function tries to rebin the axis if the given point; belongs to an under-/overflow bin.; This has the advantage that all existing functions, such as; GetBinContent, GetBinError, GetBinFunction work for all dimensions.; See also TH1::GetBin, TAxis::Fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:68496,integrat,integrated,68496,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,4,['integrat'],['integrated']
Deployability,"w_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TGraph.h; TH1D.h; THStack.h; TInterpreter.h; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; TLatex.h; TLegend.h; TProfile.h; gROOT#define gROOTDefinition TROOT.h:406; TStyle.h; Vector4D.h; ROOT::Math::LorentzVectorClass describing a generic LorentzVector in the 4D space-time, using the specified coordinate system ...Definition LorentzVector.h:59; ROOT::RDF::RInterface::DefinePerSampleRInterface< Proxied, DS_t > DefinePerSample(std::string_view name, F expression)Define a new column that is updated when the input sample changes.Definition RInterface.hxx:735; ROOT::RDF::RSampleInfoThis type represents a sample identifier, to be used in conjunction with RDataFrame features such as ...Definition RSampleInfo.hxx:35; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::VecOps::RVec< float >; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this +",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:14917,update,updated,14917,doc/master/df106__HiggsToFourLeptons_8C.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html,1,['update'],['updated']
Deployability,"w_t id); method to restore (dynamic cast) the QWidget object pointer (if any) from ROOT windows ""id"". void PrintEvent(Event_t& ); Dump trhe ROOT Event_t structure to debug the code. int CoinFlag(); return the Coin/QGL viewer flag safely. void SetCoinFlag(int flag); Set the Coin/QGL viewer flag safely. void SetCoinLoaded(); { fgCoinLoaded = 1; }. Int_t IsCoinLoaded(); { return fgCoinLoaded;}. QString RootFileFormat(const char* selector); { return RootFileFormat(QString(selector)); }. QString RootFileFormat(const QString& selector); Define whether the input string contains any pattern; that matches the ROOT image formats; those Qt library can not provide. QString QtFileFormat(const char* selector); { return QtFileFormat(QString(selector)); }. QString QtFileFormat(const QString& selector); returns Qt file format. if no suitable format found and the selector is empty; the default PNG format is returned. a special treatment of the ""gif"" format.; If ""gif"" is not provided with the local Qt installation; replace ""gif"" format with ""png"" one. TQtApplication * CreateQtApplicationImp(); The method to instantiate the QApplication if needed. void PostQtEvent(QObject* receiver, QEvent* event); Qt announced that QThread::postEvent to become obsolete and; we have to switch to the QAppication instead. TGQt(); Default Constructor *-*-*-; *-* ===================. TGQt(const char* name, const char* title); Normal Constructor*-*-*-. ~TGQt(); Default Destructor*-*-*-*-; *-* ==================. Bool_t Init(void* display = 0); Qt GUI initialization-. Int_t CreatROOTThread(); dummy*-*-*-*-; -. Int_t RegisterWid(QPaintDevice* wid); register QWidget for the embedded TCanvas. Int_t UnRegisterWid(QPaintDevice* wid); unregister QWidget to the TCanvas; return = Root registration Id or zero if the wd was not registered. Bool_t IsRegistered(QPaintDevice* wid); Check whether the object has been registered. Int_t InitWindow(ULong_t window); -; *-* if window == 0 InitWindow creates its own instance of T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGQt.html:28714,install,installation,28714,root/html602/TGQt.html,https://root.cern,https://root.cern/root/html602/TGQt.html,4,['install'],['installation']
Deployability,"wable);  Set newest version to specified drawable. ;  ; void Remove ();  Remove canvas from global canvas lists, will be destroyed when shared_ptr will be removed. ;  ; void ResolveSharedPtrs ();  To resolve problem with storing of shared pointers Call this method when reading canvas from the file Can be called many times - after reinitialization of shared pointers no changes will be performed. ;  ; void Run (double tm=0.);  Run canvas functionality for given time (in seconds) ;  ; bool SaveAs (const std::string &filename);  Save canvas in image file. ;  ; void SetHeight (int height);  Set canvas height. ;  ; void SetSize (int width, int height);  Set canvas pixel size - width and height. ;  ; RCanvas & SetTitle (const std::string &title);  Set the canvas's title. ;  ; void SetWidth (int width);  Set canvas width. ;  ; void Show (const std::string &where="""");  Display the canvas. ;  ; void Update (bool async=false, CanvasCallback_t callback=nullptr);  update drawing ;  ;  Public Member Functions inherited from ROOT::Experimental::RPadBase;  ~RPadBase () override;  ; template<class T , class... ARGS> ; std::shared_ptr< T > Add (ARGS... args);  Add drawable of specified class T. ;  ; std::shared_ptr< RFrame > AddFrame ();  Add a frame object for the pad. ;  ; std::shared_ptr< RPad > AddPad (const RPadPos &, const RPadExtent &);  Add subpad. ;  ; std::vector< std::vector< std::shared_ptr< RPad > > > Divide (int nHoriz, int nVert, const RPadExtent &padding={});  Divide this pad into a grid of subpads with padding in between. ;  ; template<class T , class... ARGS> ; std::shared_ptr< T > Draw (ARGS... args);  Create drawable of specified class T. ;  ; template<class T , class... ARGS> ; auto Draw (const std::shared_ptr< T > &what, ARGS... args);  Add object to be painted. ;  ; std::shared_ptr< RDrawable > Draw (std::shared_ptr< RDrawable > &&drawable);  Add existing drawable instance to canvas. ;  ; const RPadBase * FindPadForPrimitiveWithDisplayId (const std::string &dis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvas.html:3295,update,update,3295,doc/master/classROOT_1_1Experimental_1_1RCanvas.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvas.html,1,['update'],['update']
Deployability,"ward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; double integrate (const RooArgSet *normSet, double low, double high) const;  Integrate the wrapped PDF using our current integrator, with given norm set and limits. ;  ; double operator() (double x) const;  Binding used by the integrator to evaluate the PDF. ;  . Private Attributes; std::vector< double > _binBoundaries;  ! Workspace to store data for bin sampling ;  ; std::unique_ptr< ROOT::Math::IntegratorOneDim > _integrator {nullptr};  ! Integrator used to sample bins. ;  ; RooTemplateProxy< RooAbsRealLValue > _observable;  ; RooTemplateProxy< RooAbsPdf > _pdf;  ; double _relEpsilon {1.E-4};  Default integrator precision. ;  . Friends; template<typename Func > ; class ROOT::Math::WrappedFunction;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:71196,integrat,integrator,71196,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['integrat'],['integrator']
Deployability,ways validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooRealProxyRooLegendre::_ctheta; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; intRooLegendre::_l1; intRooLegendre::_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tre,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooSpHarmonic.html:32119,integrat,integration,32119,root/html528/RooSpHarmonic.html,https://root.cern,https://root.cern/root/html528/RooSpHarmonic.html,2,['integrat'],['integration']
Deployability,ways validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooRealProxyRooLegendre::_ctheta; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; intRooLegendre::_l1; intRooLegendre::_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooSpHarmonic.html:32619,integrat,integration,32619,root/html532/RooSpHarmonic.html,https://root.cern,https://root.cern/root/html532/RooSpHarmonic.html,2,['integrat'],['integration']
Deployability,"waysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLPolyMarker.html:2479,Update,UpdateBoundingBox,2479,root/html534/TGLPolyMarker.html,https://root.cern,https://root.cern/root/html534/TGLPolyMarker.html,2,['Update'],"['UpdateBoundingBox', 'UpdateBoundingBoxesOfPhysicals']"
Deployability,"we cannot generate any of the directVars (in this case, nothing should be added to generatedVars). Any non-zero codes will be passed to our generateEvent() implementation, but otherwise its value is arbitrary. The default implementation of this method returns zero. Subclasses will usually implement this method using the matchArgs() methods to advertise the algorithms they provide. ; Reimplemented in RooBCPEffDecay, RooBCPGenDecay, RooBDecay, RooBMixDecay, RooDecay, RooGamma, RooGaussian, RooGaussModel, RooGExpModel, RooJohnson, RooLandau, RooLognormal, RooNonCPEigenDecay, RooPoisson, RooUniform, RooAddModel, RooBinSamplingPdf, RooMultiVarGaussian, RooProdPdf, and RooTruthModel.; Definition at line 1522 of file RooAbsPdf.cxx. ◆ getGeneratorConfig(). const RooNumGenConfig * RooAbsPdf::getGeneratorConfig ; (; ); const. Return the numeric MC generator configuration used for this object. ; If a specialized configuration was associated with this object, that configuration is returned, otherwise the default configuration for all RooAbsReals is returned ; Definition at line 2651 of file RooAbsPdf.cxx. ◆ getLogProbabilities(). void RooAbsPdf::getLogProbabilities ; (; std::span< const double > ; pdfValues, . double * ; output . ); const. Definition at line 671 of file RooAbsPdf.cxx. ◆ getLogVal(). double RooAbsPdf::getLogVal ; (; const RooArgSet * ; set = nullptr); const. virtual . Return the log of the current value with given normalization An error message is printed if the argument of the log is negative. ; Reimplemented in RooLegacyExpPoly, and RooHistConstraint.; Definition at line 620 of file RooAbsPdf.cxx. ◆ getNorm() [1/2]. double RooAbsPdf::getNorm ; (; const RooArgSet & ; nset); const. inline . Get normalisation term needed to normalise the raw values returned by getVal(). ; Note that getVal(normalisationVariables) will automatically apply the normalisation term returned here. Parameters. nsetSet of variables to normalise over. . Definition at line 195 of file RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:127657,configurat,configuration,127657,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,3,['configurat'],['configuration']
Deployability,"whenever distribution parameters have been changed.; 122 Note that the method string can contain in addition to the method name all the specific method; 123 parameters specified using the UNURAN method string API.; 124 For example a valid string can be `""method=arou; max_segments=1000; max_sqhratio = 0.9""`; 125 */; 126 bool Init(const TUnuranContDist & distr, const std::string & method = ""auto"");; 127 ; 128 /**; 129 Initialize method for continuous multi-dimensional distribution.; 130 User must provide a distribution object (which is copied inside) and a string for a method.; 131 For the list of available method for multivariate cont. distribution see the; 132 <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCVEC"">UnuRan doc</A>; 133 A re-initialization is needed whenever distribution parameters have been changed.; 134 ; 135 The default method used for multi-dimensional distributions is ""vnrou""; 136 Note that some of the multi-dimensional continuous distribution methods like ""hitro"" are based on Markov-CHain sampler and; 137 they are much faster for sampling but require more time to converge. Furthermore, since they are Markov-Chain methods their; 138 generated sample values are correlated and cannot be used as i.i.d., one can instead use the obtained sample distribution.; 139 (see also the ROOT issue: #10222 ).; 140 ; 141 */; 142 bool Init(const TUnuranMultiContDist & distr, const std::string & method = ""vnrou"");; 143 ; 144 ; 145 /**; 146 Initialize method for continuous one-dimensional discrete distribution.; 147 User must provide a distribution object (which is copied inside) and a string for a method.; 148 For the list of available method for 1D discrete distribution see the; 149 <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fDISCR"">UnuRan doc</A>; 150 A re-initialization is needed whenever distribution parameters have been changed.; 151 ; 152 */; 153 bool Init(const TUnuranDiscrDist & distr, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnuran_8h_source.html:5135,continuous,continuous,5135,doc/master/TUnuran_8h_source.html,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html,1,['continuous'],['continuous']
Deployability,"which have one additional level of sub-branches). The only other way the depth increases is when the top-level branch has a split class data member, in that case the constructor will create a sub-branch for it. In other words, the interior nodes of the branch tree are all either: base class nodes; split class nodes which are direct sub-branches of top-level nodes (created by TClass::Bronch usually); or TClonesArray or STL container master nodes.; Note: The exception to the above is for the top-level branches, Tree::Bronch creates nodes for everything in that case, except for a TObject base class of a class which has the can ignore tobject streamer flag set. ; Definition at line 6212 of file TBranchElement.cxx. ◆ UpdateFile(). void TBranchElement::UpdateFile ; (; ). overridevirtual . Refresh the value of fDirectory (i.e. ; where this branch writes/reads its buffers) with the current value of fTree->GetCurrentFile unless this branch has been redirected to a different file. Also update the sub-branches. ; Reimplemented from TBranch.; Definition at line 6424 of file TBranchElement.cxx. ◆ ValidateAddress(). void TBranchElement::ValidateAddress ; (; ); const. inlineprotected . Definition at line 264 of file TBranchElement.h. Friends And Related Symbol Documentation. ◆ TLeafElement. friend class TLeafElement. friend . Definition at line 43 of file TBranchElement.h. ◆ TTreeCloner. friend class TTreeCloner. friend . Definition at line 42 of file TBranchElement.h. Member Data Documentation. ◆ fBranchClass. TClassRef TBranchElement::fBranchClass. protected . ! Reference to class definition in fClassName ; Definition at line 94 of file TBranchElement.h. ◆ fBranchCount. TBranchElement* TBranchElement::fBranchCount. protected . pointer to primary branchcount branch ; Definition at line 83 of file TBranchElement.h. ◆ fBranchCount2. TBranchElement* TBranchElement::fBranchCount2. protected . pointer to secondary branchcount branch ; Definition at line 84 of file TBranchElement.h. ◆ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:78134,update,update,78134,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['update'],['update']
Deployability,"widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. Pixel_t GetCurrentColor() const. void ColorSelected(Pixel_t col = 0); { Emit(""ColorSelected(Pixel_t)"", col ? col : GetCurrentColor()); }. » Author: Bertrand Bellenot + Fons Rademakers 22/08/02 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-05 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGColorPick.html:20282,Update,UpdateCurrentColor,20282,root/html534/TGColorPick.html,https://root.cern,https://root.cern/root/html534/TGColorPick.html,1,['Update'],['UpdateCurrentColor']
Deployability,winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; TVirtualRWMutex.h; R__WRITE_LOCKGUARD#define R__WRITE_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:157; R__READ_LOCKGUARD#define R__READ_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:154; ROOT::Math::GenAlgoOptions::PrintAllDefaultstatic void PrintAllDefault(std::ostream &os=std::cout)print all the default optionsDefinition GenAlgoOptions.cxx:67; ROOT::Math::GenAlgoOptions::Defaultstatic IOptions & Default(const char *algoname)Definition GenAlgoOptions.cxx:55; ROOT::Math::GenAlgoOptions::FindDefaultstatic IOptions * FindDefault(const char *algoname)Definition GenAlgoOptions.cxx:48; ROOT::Math::IOptionsGeneric interface for defining configuration options of a numerical algorithm.Definition IOptions.h:28; ROOT::Math::IOptions::Clonevirtual IOptions * Clone() const =0; ROOT::Math::IOptions::Printvirtual void Print(std::ostream &=std::cout) constprint optionsDefinition IOptions.cxx:56; ROOT::Math::MinimizerOptionsMinimizer options.Definition MinimizerOptions.h:40; ROOT::Math::MinimizerOptions::operator=MinimizerOptions & operator=(const MinimizerOptions &opt)assignment operatorsDefinition MinimizerOptions.cxx:151; ROOT::Math::MinimizerOptions::DefaultPrintLevelstatic int DefaultPrintLevel()Definition MinimizerOptions.cxx:97; ROOT::Math::MinimizerOptions::DefaultPrecisionstatic double DefaultPrecision()Definition MinimizerOptions.cxx:93; ROOT::Math::MinimizerOptions::Defaultstatic ROOT::Math::IOptions & Default(const char *name)Retrieve extra options for a given minimizer name.Definition MinimizerOptions.cxx:234; ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCallsstatic void SetDefaultMaxFunctionCalls(int m,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MinimizerOptions_8cxx_source.html:11383,configurat,configuration,11383,doc/master/MinimizerOptions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MinimizerOptions_8cxx_source.html,1,['configurat'],['configuration']
Deployability,window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveGedNameTextButton.html:21181,release,released,21181,root/html528/TEveGedNameTextButton.html,https://root.cern,https://root.cern/root/html528/TEveGedNameTextButton.html,1,['release'],['released']
Deployability,"wise he wants to close it. void DoPreviewClosed(); Slot called to close the preview, via the preview check button, or; when the preview window is closed via the window manager. void DoMakeDefault(); Slot called to make the current selected style (in the ComboBox); become gStyle. void DoApplyOnSelect(Int_t i); Slot called to choose on which object(s) the 'Apply' button will; have an effect. void DoApplyOn(); Slot called when the user clicks on the 'Apply' button. Apply the; current selected style to the specified object(s). void DoMoreLess(); Slot called when the user try to show or hide the editor part of the; style manager. void DoEditionUpdatePreview(); Slot called when the user clicks on the 'Update preview' button. void DoChangeTab(Int_t i); Slot called when the user changes the current tab. void DoChangeAxisTab(Int_t i); Slot called when the user changes the current axis tab. void DoSelectNoCanvas(); Slot called when the user close a TCanvas. Update the labels and the; pointers to the current pad and the current object. void DoSelectCanvas(TVirtualPad* pad, TObject* obj, Int_t mouseButton); Slot called when the user clicks on a TCanvas or on any object inside; a TCanvas. Update the pointers to the current pad and the current object. void CloseWindow(); Slot called to close the style manager via the window manager. void ModFillColor(); Slot called whenever the fill color is modified by the user. void ModFillStyle(); Slot called whenever the fill style is modified by the user. void ModHatchesLineWidth(); Slot called whenever the hatches line width is modified by the user. void ModHatchesSpacing(); Slot called whenever the hatches spacing is modified by the user. void ModMarkerColor(); Slot called whenever the marker color is modified by the user. void ModMarkerStyle(); Slot called whenever the marker style is modified by the user. void ModMarkerSize(); Slot called whenever the marker size is modified by the user. void ModScreenFactor(); Slot called whenever the sc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStyleManager.html:61243,Update,Update,61243,root/html532/TStyleManager.html,https://root.cern,https://root.cern/root/html532/TStyleManager.html,2,['Update'],['Update']
Deployability,"with __attribute__((unused)).; 302 * On the other hand, if the function is marked with this attribute,; 303 * but is used, the compiler raises a completely idiotic; 304 * ""used-but-marked-unused"" warning - and; 305 * #pragma GCC diagnostic ignored ""-Wused-but-marked-unused""; 306 * raises error: unknown option after ""#pragma GCC diagnostic"".; 307 * Disable this warning completely, until the GCC guys sober up; 308 * again.; 309 */; 310 ; 311#pragma GCC diagnostic ignored ""-Wunused-function""; 312 ; 313#define FUNCTION_MAY_BE_UNUSED /* __attribute__((unused)) */; 314 ; 315#else; 316#define FUNCTION_MAY_BE_UNUSED; 317#endif; 318 ; 319 ; 320/* Some ANSI #includes are not available on Windows CE and Zephyr */; 321#if !defined(_WIN32_WCE) && !defined(__ZEPHYR__); 322#include <errno.h>; 323#include <fcntl.h>; 324#include <signal.h>; 325#include <stdlib.h>; 326#include <sys/stat.h>; 327#include <sys/types.h>; 328#endif /* !_WIN32_WCE */; 329 ; 330 ; 331#if defined(__clang__); 332/* When using -Weverything, clang does not accept it's own headers; 333 * in a release build configuration. Disable what is too much in; 334 * -Weverything. */; 335#pragma clang diagnostic ignored ""-Wdisabled-macro-expansion""; 336#endif; 337 ; 338#if defined(__GNUC__) || defined(__MINGW32__); 339/* Who on earth came to the conclusion, using __DATE__ should rise; 340 * an ""expansion of date or time macro is not reproducible""; 341 * warning. That's exactly what was intended by using this macro.; 342 * Just disable this nonsense warning. */; 343 ; 344/* And disabling them does not work either:; 345 * #pragma clang diagnostic ignored ""-Wno-error=date-time""; 346 * #pragma clang diagnostic ignored ""-Wdate-time""; 347 * So we just have to disable ALL warnings for some lines; 348 * of code.; 349 * This seems to be a known GCC bug, not resolved since 2012:; 350 * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53431; 351 */; 352#endif; 353 ; 354 ; 355#if defined(__MACH__) /* Apple OSX section */; 356 ; 357#if defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:12075,release,release,12075,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,4,"['configurat', 'release']","['configuration', 'release']"
Deployability,"with an array x and weights w. ; Parameters. [in]ntimesnumber of entries in arrays x and w (array size must be ntimes*stride) ; [in]xarray of values to be histogrammed ; [in]warray of weighs ; [in]stridestep size through arrays x and w. If the weight is not equal to 1, the storage of the sum of squares of weights is automatically triggered and the sum of the squares of weights is incremented by \( w^2 \) in the bin corresponding to x. if w is NULL each entry is assumed a weight=1 ; Reimplemented from TH1.; Reimplemented in TH2Poly.; Definition at line 84 of file TH2.h. ◆ FillRandom() [1/2]. void TH2::FillRandom ; (; const char * ; fname, . Int_t ; ntimes = 5000, . TRandom * ; rng = nullptr . ). overridevirtual . Fill histogram following distribution in function fname. ; Parameters. fname: Function name used for filling the histogram ; ntimes: number of times the histogram is filled ; rng: (optional) Random number generator used to sample. The distribution contained in the function fname (TF2) is integrated over the channel contents. It is normalized to 1. Getting one random number implies:; Generating a random number between 0 and 1 (say r1); Look in which bin in the normalized integral r1 corresponds to; Fill histogram channel ntimes random numbers are generated. One can also call TF2::GetRandom2 to get a random variate from a function. ; Reimplemented from TH1.; Definition at line 714 of file TH2.cxx. ◆ FillRandom() [2/2]. void TH2::FillRandom ; (; TH1 * ; h, . Int_t ; ntimes = 5000, . TRandom * ; rng = nullptr . ). overridevirtual . Fill histogram following distribution in histogram h. ; Parameters. h: Histogram pointer used for sampling random number ; ntimes: number of times the histogram is filled ; rng: (optional) Random number generator used for sampling. The distribution contained in the histogram h (TH2) is integrated over the channel contents. It is normalized to 1. Getting one random number implies:; Generating a random number between 0 and 1 (say r1); L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:72990,integrat,integrated,72990,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,1,['integrat'],['integrated']
Deployability,"with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,bool>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction4PdfBinding_double_double_double_double_bool_.html:42679,integrat,integrator,42679,root/html534/RooCFunction4PdfBinding_double_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html534/RooCFunction4PdfBinding_double_double_double_double_bool_.html,4,"['configurat', 'integrat']","['configuration', 'integrator']"
Deployability,"with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the given include file correspond to a class that has; been loaded through a compiled dictionnary. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:25564,update,update,25564,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['update'],['update']
Deployability,"with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the name of the given include file corresponds to a class that; is known to ROOT, e.g. ""TLorentzVector.h"" versus TLorentzVector. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used on",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TROOT.html:26100,update,update,26100,root/html530/TROOT.html,https://root.cern,https://root.cern/root/html530/TROOT.html,5,['update'],['update']
Deployability,"with optimised PDFs speed up between 4x and 16x.; The fast BatchMode now also works in combination with multi processing (NumCPU) and with binned data (RooDataHist).; See Demo notebook in SWAN, EPJ Web Conf. 245 (2020) 06007, arxiv:2012.02746.; RooBatchCompute Library; The library that contains the optimised computation functions is called RooBatchCompute. The PDFs contained in this library are highly optimized, and there is currently work in progress for further optimization using CUDA and multi-threaded computations. If you use PDFs that are not part of the official RooFit, you are very well invited to add them to RooFit by submitting a ticket or a pull request.; Benefiting from batch computations by overriding evaluateSpan(); For PDFs that are not part of RooFit, it is possible to benefit from batch computations without vector extensions. To do so, consult the RooBatchCompute readme.; Migrating PDFs that override the deprecated evaluateBatch(); In case you have created a custom PDF which overrides evaluateBatch(), please follow these steps to update your code to the newest version:. Change the signature of the function both in the source and header file:. - RooSpan<double> RooGaussian::evaluateBatch(std::size_t begin, std::size_t batchSize) const; + RooSpan<double> evaluateSpan(RooBatchCompute::RunContext& evalData, const RooArgSet* normSet) const. Include RunContext.h and BracketAdapter.h.; Use getValues() instead of getValBatch() to retrieve a RooSpan for the data of every value. - auto xData = x.getValBatch(begin, batchSize);; + auto xData = x->getValues(evalData,normSet);. Retrieve the number of events by getting the maximum size of the input spans. size_t nEvents=0;; for (auto& i:{xData,meanData,sigmaData}); nEvents = std::max(nEvents,i.size());. Create the output batch by calling RunContext::makeBatch(). - auto output = _batchData.makeWritableBatchUnInit(begin, batchSize);; + auto output = evalData.makeBatch(this, nEvents);. DO NOT use RooSpan::isBatch() and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:19267,update,update,19267,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['update'],['update']
Deployability,"with reading old files - as you correctly pointed out this is one of the most crucial ingredients of this project.; Cheers, Axel. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:50 Permalink . Thank you for clarifying a . Thank you for clarifying a transition plan, it is quite a reasonable approach. I just want to add a personal request to your wish list. Would it be possible to improve IO speed for reading? Very often analysis code is constrained by CPU/disk access limits when reading ntuples. The speed varies from ~100kHz for a tree with few float branches to ~200 Hz for complex data structure. A factor of few improvement for complex data can be a difference between requiring just one machine or a small farm. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:51 Permalink . Re: I/O Performance . Hi ROOT User,; We have dramatically improved the I/O performance over the last two years. If you use the latest production release also for writing data you might be able to see a performance improvement of an order of magnitude compared to e.g. 5.26, both in real and CPU time! See e.g. this blog entry.; We have been comparing the performance of ROOT I/O with competitors like Google ProtoBuf; we know exactly where we spend extra time and why, e.g. for schema evolution, proper C++ type support, introspection, pointers.; On the other hand, are you sure you make use of all the performance features ROOT offers? Did you enable the tree cache (on by default for PROOF and one tree per file, off - for now, still - otherwise)? Do you only read the branches you need? I am working on a new TTree read access class that should simplify all of that considerably (and is type safe - no more void*&!); maybe I should take your comment as an invitation to speed up :-); Cheers, Axel. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:51 Permalink . Re: Interpreters . Hi ROOT user,; Thanks for your comments - they are excellent!; Your scenario would probably",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:15319,release,release,15319,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['release'],['release']
Deployability,"wkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLBEntry(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame, Pixel_t back = GetWhitePixel()); Base class entry constructor. void Activate(Bool_t a); Toggle active state of listbox entry. void Toggle(); Toggle active state of listbox entry. void DoRedraw(); { }. void Update(TGLBEntry* ); { }. Int_t EntryId() const; { return fEntryId; }. Bool_t IsActive() const; { return fActive; }. void SetBackgroundColor(Pixel_t col); { TGFrame::SetBackgroundColor(col); fBkcolor = col; }. » Author: Fons Rademakers 12/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGListBox.h 36119 2010-10-06 14:10:03Z rdm $ » Last generated: 2011-11-03 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLBEntry.html:17689,Toggle,Toggle,17689,root/html532/TGLBEntry.html,https://root.cern,https://root.cern/root/html532/TGLBEntry.html,4,"['Toggle', 'Update']","['Toggle', 'Update']"
Deployability,"wmat contains the number of atoms; of a given kind into the molecule of the compound.; In this case, wmat in output is changed to relative; weights. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf); The same as previous but in double precision; Define a medium.; kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field:; - ifield = 0 if no magnetic field;; - ifield = -1 if user decision in guswim;; - ifield = 1 if tracking performed with g3rkuta;; - ifield = 2 if tracking; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm); ubuf pointer to an array of user words; nbuf number of user words; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ); The same as previous but in double precision; Define a rotation matrix; krot rotation matrix number assigned; thetaX polar angle for axis X; phiX azimuthal angle for axis X; thetaY polar angle for axis Y; phiY azimuthal angle for axis Y; thetaZ polar angle for axis Z; phiZ azimuthal angle for axis Z. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t np). functions from GGEOM. Create a new volume; name Volume name; shape Volume type; nmed Tracking medium number; np Number of shape parameters; upar Vector containing shape parameters; The same as previous but in double precision. void Gsdvn2(const char* name, const char* mother, Int_t ndiv, Int_t iaxis, Double_t c0i, Int_t numed); Create a new volume by dividing an existing one.; It divides a previ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMCGeometry.html:10884,continuous,continuous,10884,root/html528/TVirtualMCGeometry.html,https://root.cern,https://root.cern/root/html528/TVirtualMCGeometry.html,10,['continuous'],['continuous']
Deployability,"wmode=Extended, Int_t nEvalError=-1, Int_t doEEVal=false, double eeVal=0.0);  Create a 1-dim curve of the value of the specified real-valued expression as a function of x. ;  ;  RooCurve (const char *name, const char *title, const RooCurve &c1, const RooCurve &c2, double scale1=1., double scale2=1.);  Constructor of a curve as sum of two other curves. ;  ;  RooCurve (const RooAbsReal &func, RooAbsRealLValue &x, double xlo, double xhi, Int_t xbins, double scaleFactor=1, const RooArgSet *normVars=nullptr, double prec=1e-3, double resolution=1e-3, bool shiftToZero=false, WingMode wmode=Extended, Int_t nEvalError=-1, Int_t doEEVal=false, double eeVal=0.0, bool showProgress=false);  Create a 1-dim curve of the value of the specified real-valued expression as a function of x. ;  ;  ~RooCurve () override;  ; void addPoint (double x, double y);  Add a point with the specified coordinates. Update our y-axis limits. ;  ; double average (double lo, double hi) const;  Return average curve value in [xFirst,xLast] by integrating curve between points and dividing by xLast-xFirst. ;  ; double chiSquare (const RooHist &hist, int nFitParam) const;  Calculate the chi^2/NDOF of this curve with respect to the histogram 'hist' accounting nFitParam floating parameters in case the curve was the result of a fit. ;  ; Int_t findPoint (double value, double tolerance=1e-10) const;  Find the nearest point to xvalue. ;  ; double getFitRangeBinW () const override;  Get the bin width associated with this plotable object. ;  ; double getFitRangeNEvt () const override;  Return the number of events associated with the plotable object, it is always 1 for curves. ;  ; double getFitRangeNEvt (double xlo, double xhi) const override;  Return the number of events associated with the plotable object, in the given range. ;  ; double interpolate (double x, double tolerance=1e-10) const;  Return linearly interpolated value of curve at xvalue. ;  ; TClass * IsA () const override;  ; bool isIdentical (const RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCurve.html:3947,integrat,integrating,3947,doc/master/classRooCurve.html,https://root.cern,https://root.cern/doc/master/classRooCurve.html,1,['integrat'],['integrating']
Deployability,"wned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyxDependent/convolution variable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooResolutionModel.html:40576,configurat,configuration,40576,root/html526/RooResolutionModel.html,https://root.cern,https://root.cern/root/html526/RooResolutionModel.html,3,"['configurat', 'integrat']","['configuration', 'integrator']"
Deployability,"wningPtr< RooAbsReal > RooAbsReal::createScanRI ; (; const RooArgSet & ; iset, . const RooArgSet & ; nset, . Int_t ; numScanBins, . Int_t ; intOrder . ). Utility function for createRunningIntegral that construct an object implementing the numeric scanning technique for calculating the running integral. ; Definition at line 3810 of file RooAbsReal.cxx. ◆ DeclFileName(). static const char * RooAbsReal::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 548 of file RooAbsReal.h. ◆ defaultErrorLevel(). virtual double RooAbsReal::defaultErrorLevel ; (; ); const. inlinevirtual . Reimplemented in RooAddition, RooFit::TestStatistics::RooRealL, RooFormulaVar, RooFit::Experimental::RooFuncWrapper, RooChi2Var, RooNLLVar, RooXYChi2Var, and ProgressMonitor.; Definition at line 248 of file RooAbsReal.h. ◆ defaultIntegratorConfig(). RooNumIntConfig * RooAbsReal::defaultIntegratorConfig ; (; ). static . Returns the default numeric integration configuration for all RooAbsReals. ; Definition at line 3272 of file RooAbsReal.cxx. ◆ derivative() [1/2]. RooDerivative * RooAbsReal::derivative ; (; RooRealVar & ; obs, . const RooArgSet & ; normSet, . Int_t ; order, . double ; eps = 0.001 . ). Return function representing first, second or third order derivative of this function. ; Definition at line 3999 of file RooAbsReal.cxx. ◆ derivative() [2/2]. RooDerivative * RooAbsReal::derivative ; (; RooRealVar & ; obs, . Int_t ; order = 1, . double ; eps = 0.001 . ). Return function representing first, second or third order derivative of this function. ; Definition at line 3987 of file RooAbsReal.cxx. ◆ doEval(). void RooAbsReal::doEval ; (; RooFit::EvalContext & ; ctx); const. virtual . Base function for computing multiple values of a RooAbsReal. ; Parameters. ctxAn evaluation context object . Reimplemented in RooStats::HistFactory::FlexibleInterpVar, ParamHistFunc, PiecewiseInterpolation, RooArgusBG, RooBernstein, RooBifurGauss, RooBM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:96987,integrat,integration,96987,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,2,"['configurat', 'integrat']","['configuration', 'integration']"
Deployability,"wningPtr< RooAbsReal > RooAbsReal::createScanRI ; (; const RooArgSet & ; iset, . const RooArgSet & ; nset, . Int_t ; numScanBins, . Int_t ; intOrder . ). Utility function for createRunningIntegral that construct an object implementing the numeric scanning technique for calculating the running integral. ; Definition at line 3886 of file RooAbsReal.cxx. ◆ DeclFileName(). static const char * RooAbsReal::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 558 of file RooAbsReal.h. ◆ defaultErrorLevel(). virtual double RooAbsReal::defaultErrorLevel ; (; ); const. inlinevirtual . Reimplemented in RooAddition, RooChi2Var, RooFit::TestStatistics::RooRealL, RooFormulaVar, RooFit::Experimental::RooFuncWrapper, RooNLLVar, RooXYChi2Var, and ProgressMonitor.; Definition at line 248 of file RooAbsReal.h. ◆ defaultIntegratorConfig(). RooNumIntConfig * RooAbsReal::defaultIntegratorConfig ; (; ). static . Returns the default numeric integration configuration for all RooAbsReals. ; Definition at line 3354 of file RooAbsReal.cxx. ◆ derivative() [1/2]. RooDerivative * RooAbsReal::derivative ; (; RooRealVar & ; obs, . const RooArgSet & ; normSet, . Int_t ; order, . double ; eps = 0.001 . ). Return function representing first, second or third order derivative of this function. ; Definition at line 4075 of file RooAbsReal.cxx. ◆ derivative() [2/2]. RooDerivative * RooAbsReal::derivative ; (; RooRealVar & ; obs, . Int_t ; order = 1, . double ; eps = 0.001 . ). Return function representing first, second or third order derivative of this function. ; Definition at line 4063 of file RooAbsReal.cxx. ◆ doEval(). void RooAbsReal::doEval ; (; RooFit::EvalContext & ; ctx); const. virtual . Base function for computing multiple values of a RooAbsReal. ; Parameters. ctxAn evaluation context object . Reimplemented in RooStats::HistFactory::FlexibleInterpVar, ParamHistFunc, PiecewiseInterpolation, RooArgusBG, RooBernstein, RooBifurGauss, RooBM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:98255,integrat,integration,98255,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,2,"['configurat', 'integrat']","['configuration', 'integration']"
Deployability,"ws in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAttTextEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of text attributes GUI. ~TAttTextEditor(); Destructor of text editor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Pick up the values of used text attributes. void DoTextColor(Pixel_t color); Slot connected to the marker color. void DoTextAlphaColor(ULong_t p); Slot connected to the color with alpha. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process message. TGComboBox* BuildFontSizeComboBox(TGFrame* parent, Int_t id); Create text size combo box. TGComboBox* BuildTextAlignComboBox(TGFrame* parent, Int_t id); Create text align combo box. void DoAlphaField(); Slot to set the alpha value from the entry field. void DoAlpha(); Slot to set the alpha value. void DoLiveAlpha(Int_t a); Slot to set alpha value online. void GetCurAlpha(); Slot to update alpha value on click on Slider. » Author: Ilka Antcheva 11/05/04 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-03-12 16:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TAttTextEditor.html:21395,update,update,21395,root/html534/TAttTextEditor.html,https://root.cern,https://root.cern/root/html534/TAttTextEditor.html,2,['update'],['update']
Deployability,"wsable. void SetSelected(TObject* obj); Set selected canvas. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& b); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Dele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCanvas.html:44127,Toggle,ToggleAutoExec,44127,root/html532/TCanvas.html,https://root.cern,https://root.cern/root/html532/TCanvas.html,2,['Toggle'],"['Toggle', 'ToggleAutoExec']"
Deployability,"wser is reloaded; load of widgets code only when really required (shorter startup time for RBrowser). JavaScript ROOT; Major JSROOT update to version 6. update all used libraries d3.js, three.js, MathJax.js, openui5; change to Promise based interface for all async methods, remove call-back arguments; change scripts names, core scripts name now JSRoot.core.js; unify function/methods naming conventions, many changes in method names; provide central code loader via JSROOT.require, supporting 4 different loading engines; many nice features and many bug fixes; see JSROOT v6 release notes. Class Reference Guide; One can now select a class’s documentation for a specific version. If a class does not exist in a given version, that version is grayed out, see for instance the documentation for ROOT::Experimental::RNTupleReader.; Build, Configuration and Testing Infrastructure. a new cmake variable, CMAKE_INSTALL_PYTHONDIR, has been added: it allows customization of the installation directory of ROOT’s python modules; the developer build option asserts is introduced to enable/disable asserts via the NDEBUG C/CXX flag. Asserts are always enabled for CMAKE_BUILD_TYPE=Debug and dev=ON. The previous behavior of the builds set via the CMAKE_BUILD_TYPE variable has not changed.; CMAKE_CXX_STANDARD, i.e. the C++ standard ROOT is built with, now defaults to the compiler default (or C++11 if the compiler default is older than that) rather than always defaulting to C++11. In turn this means that v6.24 is the first ROOT release for which ROOT’s pre-compiled binaries are not compiled with C++11 but with the default standard in use by the default system compiler. On Ubuntu 20.04, for example, the v6.24 pre-compiled binaries are now compiled with C++14 rather than C++11 as it happened for previous ROOT versions. Also see ROOT-10692. The following builtins have been updated:. VecCore 0.7.0; LZ4 1.9.3; openui5; Xrootd 4.12.8; Zstd 1.4.8. PyROOT. Deprecate TTree.AsMatrix in this release and mark",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:29443,install,installation,29443,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['install'],['installation']
Deployability,"x = px - gPad->XtoAbsPixel(gPad->XtoPad(fX[i]));; 2052 Int_t dpy = py - gPad->YtoAbsPixel(gPad->YtoPad(fY[i]));; 2053 if (dpx * dpx + dpy * dpy < 100) {; 2054 ipoint = i;; 2055 break;; 2056 }; 2057 }; 2058 return RemovePoint(ipoint);; 2059}; 2060 ; 2061////////////////////////////////////////////////////////////////////////////////; 2062/// Delete point number ipoint; 2063/// Returns index of removed point (or -1 if nothing was changed); 2064 ; 2065Int_t TGraph::RemovePoint(Int_t ipoint); 2066{; 2067 if ((ipoint < 0) || (ipoint >= fNpoints)); 2068 return -1;; 2069 ; 2070 Double_t **ps = ShrinkAndCopy(fNpoints - 1, ipoint);; 2071 CopyAndRelease(ps, ipoint + 1, fNpoints--, ipoint);; 2072 if (gPad) gPad->Modified();; 2073 return ipoint;; 2074}; 2075 ; 2076////////////////////////////////////////////////////////////////////////////////; 2077/// Save the graph as .csv, .tsv or .txt. In case of any other extension, fall; 2078/// back to TObject::SaveAs; 2079///; 2080/// The result can be immediately imported into Excel, gnuplot, Python or whatever,; 2081/// without the needing to install pyroot, etc.; 2082///; 2083/// \param filename the name of the file where to store the graph; 2084/// \param option some tuning options; 2085///; 2086/// The file extension defines the delimiter used:; 2087/// - `.csv` : comma; 2088/// - `.tsv` : tab; 2089/// - `.txt` : space; 2090///; 2091/// If option = ""title"" a title line is generated with the axis titles.; 2092 ; 2093void TGraph::SaveAs(const char *filename, Option_t *option) const; 2094{; 2095 char del = '\0';; 2096 TString ext = """";; 2097 TString fname = filename;; 2098 TString opt = option;; 2099 ; 2100 if (filename) {; 2101 if (fname.EndsWith("".csv"")) {del = ','; ext = ""csv"";}; 2102 else if (fname.EndsWith("".tsv"")) {del = '\t'; ext = ""tsv"";}; 2103 else if (fname.EndsWith("".txt"")) {del = ' '; ext = ""txt"";}; 2104 }; 2105 if (del) {; 2106 std::ofstream out;; 2107 out.open(filename, std::ios::out);; 2108 if (!out.good ()) {; 2109 Erro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:74402,install,install,74402,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['install'],['install']
Deployability,"x of the polyline is found to be closer than 10; pixels. Thus the return value may depend on the ordering of points; in the polyline. Then looks for distances to the lines of the polyline. There is no; arbitrary cutoff; any distance may be found. Finally checks whether (px, py) is inside a closed and filled polyline.; (Must be EXACTLY closed. ""Filled"" means fill color and fill style are; both non-zero.) If so, returns zero. Returns 9999 if the polyline has no points. void Draw(Option_t* option = """"); Draw this polyline with its current attributes. void DrawPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Draw this polyline with new coordinates. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a polyline is clicked with the locator. If Left button clicked on one of the line end points, this point; follows the cursor until button is released. if Middle button clicked, the line is moved parallel to itself; until the button is released. void ls(Option_t* option = """") const; List this polyline with its attributes.; The option string is ignored. Int_t Merge(TCollection* list); Merge polylines in the collection in this polyline. void Paint(Option_t* option = """"); Paint this polyline with its current attributes. void PaintPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Draw this polyline with new coordinates. If option = 'f' or 'F' the fill area is drawn.; The default is to draw the lines only. void PaintPolyLineNDC(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Draw this polyline with new coordinates in NDC. void Print(Option_t* option = """") const; Dump this polyline with its attributes.; The option string is ignored. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetNDC(Bool_t isNDC = kTRUE); Set NDC mode on if isNDC = kTRUE, off otherwise. Int_t SetNextPoint(Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPolyLine.html:10010,release,released,10010,root/html528/TPolyLine.html,https://root.cern,https://root.cern/root/html528/TPolyLine.html,10,['release'],['released']
Deployability,"x) coef_k * Int(dy) [ basis_k (x) ResModel ].; _; where x is the set of coefficient dependents to be integrated; and y the set of basis function dependents to be integrated. For normalized integrals this becomes. sum_k Int(dx) coef_k * Int(dy) [ basis_k (x) ResModel ].; PDF = --------------------------------------------------------; sum_k Int(dv) coef_k * Int(dw) [ basis_k (x) ResModel ]. where x is the set of coefficient dependents to be integrated,; y the set of basis function dependents to be integrated,; v is the set of coefficient dependents over which is normalized and; w is the set of basis function dependents over which is normalized. Set x must be contained in v and set y must be contained in w. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset = 0, const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsAnaConvPdf.html:46435,integrat,integration,46435,root/html528/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsAnaConvPdf.html,3,['integrat'],['integration']
Deployability,"x) coef_k * Int(dy) [ basis_k (x) ResModel ].; _; where x is the set of coefficient dependents to be integrated; and y the set of basis function dependents to be integrated. For normalized integrals this becomes. sum_k Int(dx) coef_k * Int(dy) [ basis_k (x) ResModel ].; PDF = --------------------------------------------------------; sum_k Int(dv) coef_k * Int(dw) [ basis_k (x) ResModel ]. where x is the set of coefficient dependents to be integrated,; y the set of basis function dependents to be integrated,; v is the set of coefficient dependents over which is normalized and; w is the set of basis function dependents over which is normalized. Set x must be contained in v and set y must be contained in w. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsAnaConvPdf.html:49823,integrat,integration,49823,root/html534/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html,6,['integrat'],['integration']
Deployability,"x) coef_k * Int(dy) [ basis_k (x) ResModel ].; _; where x is the set of coefficient dependents to be integrated; and y the set of basis function dependents to be integrated. For normalized integrals this becomes. sum_k Int(dx) coef_k * Int(dy) [ basis_k (x) ResModel ].; PDF = --------------------------------------------------------; sum_k Int(dv) coef_k * Int(dw) [ basis_k (x) ResModel ]. where x is the set of coefficient dependents to be integrated,; y the set of basis function dependents to be integrated,; v is the set of coefficient dependents over which is normalized and; w is the set of basis function dependents over which is normalized. Set x must be contained in v and set y must be contained in w. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const char* ra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsAnaConvPdf.html:45959,integrat,integration,45959,root/html526/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsAnaConvPdf.html,1,['integrat'],['integration']
Deployability,"x) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, char *src);  Unzips a ROOT specific buffer... by reading the header at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; void UpdateBranches (TTree *tree) override;  update pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited from TTreeCache;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:4219,update,update,4219,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,2,['update'],['update']
Deployability,"x. ◆ OnMouseOver(). void TEveViewerList::OnMouseOver ; (; TObject * ; obj, . UInt_t ; state . ). Slot for global TGLViewer::MouseOver() signal. ; The attempt is made to determine the TEveElement being represented by the physical shape and global highlight is updated accordingly.; If TEveElement::IsPickable() returns false, the element is not highlighted.; Highlight is always in single-selection mode. ; Definition at line 539 of file TEveViewer.cxx. ◆ OnReClicked(). void TEveViewerList::OnReClicked ; (; TObject * ; obj, . UInt_t ; button, . UInt_t ; state . ). Slot for global TGLViewer::ReClicked(). ; The obj is dyn-casted to the TEveElement and global selection is updated accordingly.; If TEveElement::IsPickable() returns false, the element is not selected. ; Definition at line 622 of file TEveViewer.cxx. ◆ OnReMouseOver(). void TEveViewerList::OnReMouseOver ; (; TObject * ; obj, . UInt_t ; state . ). Slot for global TGLViewer::ReMouseOver(). ; The obj is dyn-casted to the TEveElement and global selection is updated accordingly.; If TEveElement::IsPickable() returns false, the element is not selected. ; Definition at line 561 of file TEveViewer.cxx. ◆ OnUnClicked(). void TEveViewerList::OnUnClicked ; (; TObject * ; obj, . UInt_t ; button, . UInt_t ; state . ). Slot for global TGLViewer::UnClicked(). ; The obj is dyn-casted to the TEveElement and global selection is updated accordingly.; If TEveElement::IsPickable() returns false, the element is not selected. ; Definition at line 639 of file TEveViewer.cxx. ◆ OnUnMouseOver(). void TEveViewerList::OnUnMouseOver ; (; TObject * ; obj, . UInt_t ; state . ). Slot for global TGLViewer::UnMouseOver(). ; The obj is dyn-casted to the TEveElement and global selection is updated accordingly.; If TEveElement::IsPickable() returns false, the element is not selected. ; Definition at line 583 of file TEveViewer.cxx. ◆ operator=(). TEveViewerList & TEveViewerList::operator= ; (; const TEveViewerList & ; ). private . ◆ RemoveElementL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveViewerList.html:38722,update,updated,38722,doc/master/classTEveViewerList.html,https://root.cern,https://root.cern/doc/master/classTEveViewerList.html,1,['update'],['updated']
Deployability,"x.Draw(); ; c.SaveAs(""rf903_numintcache.png""); ; # Make workspace available on command line after macro finishes; ROOT.gDirectory.Add(w); Drawth1 Draw(); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y,z]) using numeric integrator RooAdaptiveIntegratorND to calculate Int(x,y,z); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_over_model_Int[x,y,z]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_over_model_Int[x,y,z]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a: using 1; ; prevFCN = 1659.930708 a=0.02833, [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y,z]) using numeric integrator RooAdaptiveIntegratorND to calculate Int(x,y,z); ; prevFCN = 1675.611563 a=-0.02833, ; prevFCN = 1673.217894 a=0.002833, ; prevFCN = 1660.205177 a=-0.002833, ; prevFCN = 1659.94939 a=0.0002833, ; prevFCN = 1659.944972 a=-0.0002833, ; prevFCN = 1659.919376 a=-0.001237, ; prevFCN = 1659.902781 a=-0.001089, ; prevFCN = 1659.903175 a=-0.001384, ; prevFCN = 1659.90318 a=-0.001237, ; prevFCN = 1659.902781 a=-0.001089, ; prevFCN = 1659.903175 a=-0.001384, ; prevFCN = 1659.90318 a=-0.001207, ; prevFCN = 1659.902797 a=-0.001266, ; prevFCN = 1659.902798 [#1] INFO:Minimization -- Command timer: Real time 0:00:02, CP time 2.710; [#1] INFO:Minimization -- Session timer: Real time 0:00:02, CP time 2.710; a=-0.001237, ; prevFCN = 1659.902781 a=-0.001207, ; prevFCN = 1659.902797 a=-0.001266, ; prevFCN = 1659.902798 a=-0.001231, ; prevFCN = 1659.902782 a=-0.001243, ; prevFCN = 1659.902782 [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.960; [#1] INFO:Minimizatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf903__numintcache_8py.html:4428,integrat,integrator,4428,doc/master/rf903__numintcache_8py.html,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8py.html,1,['integrat'],['integrator']
Deployability,"x:1035; TROOT::fGeometriesTSeqCollection * fGeometriesList of geometries.Definition TROOT.h:154; TROOT::fCutClassNameTString fCutClassNameName of default CutG class in graphics editor.Definition TROOT.h:170; TROOT::fInterpreterTInterpreter * fInterpreterCommand interpreter.Definition TROOT.h:125; TROOT::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TROOT.h:187; TROOT::fVersionTimeInt_t fVersionTimeTime of ROOT version (ex 1152)Definition TROOT.h:117; TROOT::EndOfProcessCleanupsvoid EndOfProcessCleanups()Execute the cleanups necessary at the end of the process, in particular those that must be executed b...Definition TROOT.cxx:1248; TROOT::fBatchBool_t fBatchTrue if session without graphics.Definition TROOT.h:126; TROOT::GetListOfFilesTSeqCollection * GetListOfFiles() constDefinition TROOT.h:237; TROOT::fEscapeBool_t fEscapeTrue if ESC has been pressed.Definition TROOT.h:135; TROOT::GetBinDirstatic const TString & GetBinDir()Get the binary directory in the installation. Static utility function.Definition TROOT.cxx:2989; TROOT::fVersionIntInt_t fVersionIntROOT version in integer format (501)Definition TROOT.h:114; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3042; TROOT::fFromPopUpBool_t fFromPopUpTrue if command executed from a popup menu.Definition TROOT.h:131; TROOT::Idlevoid Idle(UInt_t idleTimeInSec, const char *command=nullptr)Execute command when system has been idle for idleTimeInSec seconds.Definition TROOT.cxx:1892; TROOT::fSocketsTSeqCollection * fSocketsList of network sockets.Definition TROOT.h:148; TROOT::lsvoid ls(Option_t *option="""") const overrideTo list all objects of the application.Definition TROOT.cxx:2250; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::fFunctionsTCollection * fFunctionsList ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:146431,install,installation,146431,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['install'],['installation']
Deployability,"x:1035; TROOT::fGeometriesTSeqCollection * fGeometriesList of geometries.Definition TROOT.h:154; TROOT::fCutClassNameTString fCutClassNameName of default CutG class in graphics editor.Definition TROOT.h:170; TROOT::fInterpreterTInterpreter * fInterpreterCommand interpreter.Definition TROOT.h:125; TROOT::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TROOT.h:187; TROOT::fVersionTimeInt_t fVersionTimeTime of ROOT version (ex 1152)Definition TROOT.h:117; TROOT::EndOfProcessCleanupsvoid EndOfProcessCleanups()Execute the cleanups necessary at the end of the process, in particular those that must be executed b...Definition TROOT.cxx:1248; TROOT::fBatchBool_t fBatchTrue if session without graphics.Definition TROOT.h:126; TROOT::GetListOfFilesTSeqCollection * GetListOfFiles() constDefinition TROOT.h:237; TROOT::fEscapeBool_t fEscapeTrue if ESC has been pressed.Definition TROOT.h:135; TROOT::GetBinDirstatic const TString & GetBinDir()Get the binary directory in the installation. Static utility function.Definition TROOT.cxx:2993; TROOT::fVersionIntInt_t fVersionIntROOT version in integer format (501)Definition TROOT.h:114; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::fFromPopUpBool_t fFromPopUpTrue if command executed from a popup menu.Definition TROOT.h:131; TROOT::Idlevoid Idle(UInt_t idleTimeInSec, const char *command=nullptr)Execute command when system has been idle for idleTimeInSec seconds.Definition TROOT.cxx:1892; TROOT::fSocketsTSeqCollection * fSocketsList of network sockets.Definition TROOT.h:148; TROOT::lsvoid ls(Option_t *option="""") const overrideTo list all objects of the application.Definition TROOT.cxx:2250; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::fFunctionsTCollection * fFunctionsList ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:146607,install,installation,146607,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['install'],['installation']
Deployability,"x:368; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; int; should return the analytical integrals that are supported. integSet is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet, and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. Second,; double analyticalIntegral(Int_t code); RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:394; implements the actual analytical integral(s) advertised by getAnalyticalIntegral(). This function will only be called with codes returned by getAnalyticalIntegral(), except code zero.; The integration range for each dependent to be integrated can be obtained from the dependent's proxy functions min() and max(). Never call these proxy functions for any proxy not known to be a dependent via the integration code. Doing so may be ill-defined, e.g., in case the proxy holds a function, and will trigger an assert. Integrated category dependents should always be summed over all of their states. Direct generation of observables; Distributions for any PDF can be generated with the accept/reject method, but for certain PDFs, more efficient methods may be implemented. To implement direct generation of one or more observables, two functions need to be implemented, similar to those for analytical integrals:; Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars); RooAbsPdf::getGeneratorvirtual Int_t getGenerator(const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) constLoad generatedVars with the subset of directVars that we can generate events for, and return a code t...Definition RooAbsPdf.cxx:1522",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:4122,integrat,integration,4122,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,2,['integrat'],"['integrated', 'integration']"
Deployability,x::PrivateClass ; Reflex::PrivateEnum ; Reflex::PrivateStruct ; Reflex::PrivateUnion ; Reflex::ProtectedClass ; Reflex::ProtectedEnum ; Reflex::ProtectedStruct ; Reflex::ProtectedUnion ; Reflex::RuntimeError ; Reflex::Scope ; Reflex::Selection::AUTOSELECT ; Reflex::Selection::NODEFAULT ; Reflex::Selection::NO_SELF_AUTOSELECT ; Reflex::Selection::TRANSIENT ; Reflex::Tools ; Reflex::Type ; Reflex::TypeTemplate ; Reflex::TypedefBuilderImpl ; Reflex::UnionBuilderImpl ; Reflex::UnknownType ; Reflex::UnnamedClass ; Reflex::UnnamedEnum ; Reflex::UnnamedNamespace ; Reflex::UnnamedStruct ; Reflex::UnnamedUnion ; Reflex::VariableBuilder ; Reflex::VariableBuilderImpl ; Rgl ; Roo1DMomentMorphFunction Your description goes here...; Roo1DTable 1-dimensional table; Roo2DKeysPdf Two-dimensional kernel estimation p.d.f.; Roo2DMomentMorphFunction ; RooAICRegistry Registry for analytical integration codes; RooAbsAnaConvPdf Abstract Composite Convoluted PDF; RooAbsArg Abstract variable; RooAbsBinning Abstract base class for binning specification; RooAbsCache Base class for cache managers ; RooAbsCacheElement Base class for cache elements; RooAbsCachedPdf Abstract base class for cached p.d.f.s; RooAbsCachedReal Abstract base class for cached p.d.f.s; RooAbsCategory Abstract discrete variable; RooAbsCategoryLValue Abstract modifiable index variable ; RooAbsCollection Collection of RooAbsArg objects; RooAbsData Abstract data collection; RooAbsDataStore Abstract Data Storage class; RooAbsFunc Abstract real-valued function interface; RooAbsGenContext Abstract context for generating a dataset from a PDF; RooAbsHiddenReal Abstract hidden real-valued variable; RooAbsIntegrator Abstract interface for real-valued function integrators; RooAbsLValue Abstract variable; RooAbsMCStudyModule Monte Carlo study manager add-on module; RooAbsMoment Abstract representation of moment in a RooAbsReal in a given RooRealVar; RooAbsNumGenerator Abstract base class for numeric event generator algorithms; RooAbsO,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:25018,integrat,integration,25018,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,2,['integrat'],['integration']
Deployability,x::PrivateClass ; Reflex::PrivateEnum ; Reflex::PrivateStruct ; Reflex::PrivateUnion ; Reflex::ProtectedClass ; Reflex::ProtectedEnum ; Reflex::ProtectedStruct ; Reflex::ProtectedUnion ; Reflex::RuntimeError ; Reflex::Scope ; Reflex::Selection::AUTOSELECT ; Reflex::Selection::NODEFAULT ; Reflex::Selection::NO_SELF_AUTOSELECT ; Reflex::Selection::TRANSIENT ; Reflex::Tools ; Reflex::Type ; Reflex::TypeTemplate ; Reflex::TypedefBuilderImpl ; Reflex::UnionBuilderImpl ; Reflex::UnknownType ; Reflex::UnnamedClass ; Reflex::UnnamedEnum ; Reflex::UnnamedNamespace ; Reflex::UnnamedStruct ; Reflex::UnnamedUnion ; Reflex::VariableBuilder ; Reflex::VariableBuilderImpl ; Rgl ; Roo1DMomentMorphFunction Your description goes here...; Roo1DTable 1-dimensional table; Roo2DKeysPdf Two-dimensional kernel estimation p.d.f.; Roo2DMomentMorphFunction ; RooAICRegistry Registry for analytical integration codes; RooAbsAnaConvPdf Abstract Composite Convoluted PDF; RooAbsArg Abstract variable; RooAbsBinning Abstract base class for binning specification; RooAbsCache Base class for cache managers ; RooAbsCacheElement Base class for cache elements; RooAbsCachedPdf Abstract base class for cached p.d.f.s; RooAbsCachedReal Abstract base class for cached p.d.f.s; RooAbsCategory Abstract discrete variable; RooAbsCategoryLValue Abstract modifiable index variable ; RooAbsCollection Collection of RooAbsArg objects; RooAbsData Abstract data collection; RooAbsDataStore Abstract Data Storage class; RooAbsFunc Abstract real-valued function interface; RooAbsGenContext Abstract context for generating a dataset from a PDF; RooAbsHiddenReal Abstract hidden real-valued variable; RooAbsIntegrator Abstract interface for real-valued function integrators; RooAbsLValue Abstract variable; RooAbsMCStudyModule Monte Carlo study manager add-on module; RooAbsNumGenerator Abstract base class for numeric event generator algorithms; RooAbsOptTestStatistic Abstract base class for optimized test statistics; RooAbsPdf Abstract ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:24686,integrat,integration,24686,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,1,['integrat'],['integration']
Deployability,"x;  Convolution observable. ;  ; RooRealProxy _xprime;  Input function representing value of convolution observable. ;  ;  Protected Attributes inherited from RooAbsCachedPdf; std::map< Int_t, AnaIntConfig > _anaIntMap;  ! Map for analytical integration codes ;  ; RooAICRegistry _anaReg;  ! Registry for analytical integration codes ;  ; RooObjCacheManager _cacheMgr;  ; Int_t _ipOrder;  The cache manager. ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:80209,configurat,configuration,80209,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['configurat'],['configuration']
Deployability,x;  coordinates4D.cxx;  CoordinateTraits.h;  rotationApplication.cxx;  RotationTraits.h;  stress2D.cxx;  stress3D.cxx;  testBoost.cxx;  testGenVector.cxx;  testIterator.cxx;  testVectorIO.cxx;  Track.h;  TrackLinkDef.h;  vectorOperation.cxx;  ► mathcore;  ► inc;  ► Fit;  BasicFCN.h;  BinData.h;  BinPoint.h;  Chi2FCN.h;  DataOptions.h;  DataRange.h;  DataVector.h;  DataVectorfwd.h;  FcnAdapter.h;  FitConfig.h;  FitResult.h;  Fitter.h;  FitUtil.h;  FitUtilParallel.h;  LogLikelihoodFCN.h;  ParameterSettings.h;  PoissonLikelihoodFCN.h;  SparseData.h;  UnBinData.h;  ► Math;  AdaptiveIntegratorMultiDim.h;  AllIntegrationTypes.h;  BasicMinimizer.h;  BrentMethods.h;  BrentMinimizer1D.h;  BrentRootFinder.h;  ChebyshevPol.h;  Delaunay2D.h;  DistFunc.h;  DistFuncMathCore.h;  DistSampler.h;  DistSamplerOptions.h;  Error.h;  Factory.h;  FitMethodFunction.h;  Functor.h;  GaussIntegrator.h;  GaussLegendreIntegrator.h;  GenAlgoOptions.h;  GoFTest.h;  IFunction.h;  IFunctionfwd.h;  IMinimizer1D.h;  Integrator.h;  IntegratorMultiDim.h;  IntegratorOptions.h;  IOptions.h;  IParamFunction.h;  IParamFunctionfwd.h;  IRootFinderMethod.h;  KDTree.h;  KDTree.icc;  Math.h;  MersenneTwisterEngine.h;  Minimizer.h;  MinimizerOptions.h;  MinimizerVariableTransformation.h;  MinimTransformFunction.h;  MinimTransformVariable.h;  MixMaxEngine.h;  MultiDimParamFunctionAdapter.h;  OneDimFunctionAdapter.h;  ParamFunctor.h;  PdfFunc.h;  PdfFuncMathCore.h;  ProbFunc.h;  ProbFuncMathCore.h;  QuantFunc.h;  QuantFuncMathCore.h;  Random.h;  RandomFunctions.h;  RichardsonDerivator.h;  RootFinder.h;  SpecFunc.h;  SpecFuncMathCore.h;  StdRandomEngines.h;  TDataPoint.h;  TDataPoint.icc;  TDataPointN.h;  TDataPointN.icc;  TRandomEngine.h;  Util.h;  VirtualIntegrator.h;  WrappedFunction.h;  WrappedParamFunction.h;  LinkDef.h;  LinkDef1.h;  LinkDef2.h;  LinkDef3.h;  LinkDef_Func.h;  TComplex.h;  TKDTree.h;  TKDTreeBinning.h;  TMath.h;  TRandom.h;  TRandom1.h;  TRandom2.h;  TRandom3.h;  TStatistic.h;  ► src;  Adaptive,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:43652,Integrat,Integrator,43652,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['Integrat'],['Integrator']
Deployability,"xCenter(const TPoint& p); virtual voidTPad::SetBBoxCenterX(const Int_t x); virtual voidTPad::SetBBoxCenterY(const Int_t y); virtual voidTPad::SetBBoxX1(const Int_t x); virtual voidTPad::SetBBoxX2(const Int_t x); virtual voidTPad::SetBBoxY1(const Int_t y); virtual voidTPad::SetBBoxY2(const Int_t y); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTPad::SetBorderMode(Short_t bordermode)MENU ; virtual voidTPad::SetBorderSize(Short_t bordersize)MENU ; virtual voidTAttPad::SetBottomMargin(Float_t bottommargin); virtual voidTPad::SetCanvas(TCanvas* c); virtual voidTPad::SetCanvasSize(UInt_t ww, UInt_t wh); virtual voidTPad::SetCopyGLDevice(Bool_t copy); virtual voidTPad::SetCrosshair(Int_t crhair = 1)TOGGLE ; virtual voidTPad::SetCursor(ECursor cursor); virtual voidTPad::SetDoubleBuffer(Int_t mode = 1); virtual voidTPad::SetDrawOption(Option_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidTPad::SetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidTPad::SetGLDevice(Int_t dev); virtual voidTPad::SetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t value = 1)TOGGLE ; virtual voidTPad::SetGridy(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEvePad.html:17885,TOGGLE,TOGGLE,17885,root/html534/TEvePad.html,https://root.cern,https://root.cern/root/html534/TEvePad.html,6,['TOGGLE'],['TOGGLE']
Deployability,"xedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidSetGLDevice(Int_t dev); virtual voidSetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidSetGridx(Int_t value = 1)TOGGLE ; virtual voidSetGridy(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetLogx(Int_t value = 1)TOGGLE ; virtual voidSetLogy(Int_t value = 1)TOGGLE ; virtual voidSetLogz(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetMargin(Float_t left, Float_t right, Float_t bottom, Float_t top); static voidSetMaxPickDistance(Int_t maxPick = 5); virtual voidSetName(const char* name)MENU ; virtual voidSetNumber(Int_t number); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); virtual voidSetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidSetPhi(Double_t phi = 30); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidSetSelected(TObject* obj); virtual voidSetTheta(Double_t theta = 30); virtual voidSetTicks(Int_t valuex = 1, Int_t valuey = 1); virtual voidSetTickx(Int_t value = 1)TOGGLE ; virtual voidSetTicky(Int_t value = 1)TOGGLE ; virtual voidSetTitle(const char* title = """"); virtual voidSetToolTipText(const char* text,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPad.html:19850,TOGGLE,TOGGLE,19850,root/html534/TPad.html,https://root.cern,https://root.cern/root/html534/TPad.html,3,['TOGGLE'],['TOGGLE']
Deployability,"xel_t back = GetDefaultFrameBackground()); Constructor of TGLPhysicalShape editor GUI. ~TGLPShapeObjEditor(); Destroy color editor GUI component.; Done automatically. void SetPShape(TGLPhysicalShape* shape); Shape has changed.; Check if set to zero and make sure we're no longer in editor. void PShapeModified(); Shape has been modified.; Update editor if we're still shown. Otherwise unref. void SetModel(TObject* obj); Sets model or disables/hides viewer. void SetCenter(const Double_t* center); Set internal center data from 3 component 'c'. void SetScale(const Double_t* scale); Set internal scale data from 3 component 'c'. void DoGeoButton(); Process 'Apply' - update the viewer object from GUI. void GetObjectData(Double_t* shift, Double_t* scale); Extract the GUI object data, return center in 3 component 'center'; scale in 3 component 'scale'. void GeoValueSet(Long_t unusedVal); Process setting of value in edit box - activate 'Apply' button. void CreateGeoControls(); Create GUI for setting scale and position. void SetRGBA(const Float_t* rgba); Set color sliders from 17 component 'rgba'. void DoColorSlider(Int_t val); Process slider movement. void DoColorButton(); Process button action. void CreateColorRadioButtons(); Create Diffuse/Ambient/Specular/Emissive radio buttons and sub-frames. void CreateColorSliders(); Create GUI for setting light color. void SetColorSlidersPos(); Update GUI sliders from internal data. void DoRedraw(); Redraw widget. Render sphere and pass to base-class. void DrawSphere() const; Draw local sphere reflecting current color options. void CreateColorControls(); Create widgets to chhos colors componnet and its RGBA values on fGedEditor; model or family it belongs to. const Float_t * GetRGBA() const; color slots. {return fRGBA;}. » Last changed: root/gl:$Id$ » Last generated: 2015-03-13 19:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLPShapeObjEditor.html:22993,Update,Update,22993,root/html534/TGLPShapeObjEditor.html,https://root.cern,https://root.cern/root/html534/TGLPShapeObjEditor.html,1,['Update'],['Update']
Deployability,"xes in log scale. void SetGlobalScale(Bool_t gl); Constraint all axes to the same scale. void SetAxisHistogramLineWidth(Int_t lw = 2); Set the same histogram axis line width for all axis. void SetCandleChart(Bool_t can); Set a candle chart display. void SetCurrentFirst(Long64_t ); Set the first entry to be dispayed. void SetCurrentN(Long64_t ); Set the number of entry to be displayed. TParallelCoordSelect* SetCurrentSelection(const char* title); Set the selection beeing edited. void SetCurrentSelection(TParallelCoordSelect* sel); Set the selection beeing edited. void SetDotsSpacing(Int_t s = 0); Set dots spacing. Modify the line style 11.; If the canvas support transparency dot spacing is ignored. void SetEntryList(TParallelCoord* para, TEntryList* enlist); Set the entry lists of ""para"". void SetGlobalMax(Double_t max); Force all variables to adopt the same max. void SetGlobalMin(Double_t min); Force all variables to adopt the same min. void SetLiveRangesUpdate(Bool_t ); If true, the pad is updated while the motion of a dragged range. void SetVertDisplay(Bool_t vert = kTRUE); Set the vertical or horizontal display. void UnzoomAll(); Unzoom all variables. TParallelCoord(). Bool_t GetCandleChart(); {return TestBit(kCandleChart);}. Long64_t GetCurrentFirst(); {return fCurrentFirst;}. Long64_t GetCurrentN(); {return fCurrentN;}. Bool_t GetCurveDisplay() const; {return TestBit(kCurveDisplay);}. Int_t GetDotsSpacing() const; {return fDotsSpacing;}. Bool_t GetGlobalScale(); {return TestBit(kGlobalScale);}. Bool_t GetGlobalLogScale(); {return TestBit(kGlobalLogScale);}. Color_t GetLineColor(); {return fLineColor;}. Width_t GetLineWidth(); {return fLineWidth;}. UInt_t GetNvar(); {return fNvar;}. Long64_t GetNentries(); {return fNentries;}. TList * GetSelectList(); {return fSelectList;}. TList * GetVarList(); {return fVarList;}. Bool_t GetVertDisplay() const; {return TestBit(kVertDisplay);}. Int_t GetWeightCut() const; {return fWeightCut;}. void SetCurveDisplay(Bool_t curve =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TParallelCoord.html:17094,update,updated,17094,root/html534/TParallelCoord.html,https://root.cern,https://root.cern/root/html534/TParallelCoord.html,6,['update'],['updated']
Deployability,"xies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooArgSet _paramSet;  Set of parameters to which constraints apply. ;  ; RooListProxy _set1;  Set of constraint terms. ;  ; const bool _takeGlobalObservablesFromData = false;  If the global observable values are taken from data. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooConstraintSum.html:55549,integrat,integration,55549,doc/master/classRooConstraintSum.html,https://root.cern,https://root.cern/doc/master/classRooConstraintSum.html,1,['integrat'],['integration']
Deployability,"ximum number of sub-intervals ; ruleGauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When no values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions ; Definition at line 142 of file Integrator.h. ◆ IntegratorOneDim() [3/4]. template<class Function > . ROOT::Math::IntegratorOneDim::IntegratorOneDim ; (; Function & ; f, . IntegrationOneDim::Type ; type = IntegrationOneDim::kDEFAULT, . double ; absTol = -1, . double ; relTol = -1, . unsigned int ; size = 0, . int ; rule = 0 . ). inlineexplicit . Template Constructor of one dimensional Integrator passing a generic function object. ; Parameters. fintegration function (any C++ callable object implementing operator()(double x) ; typeintegration type (adaptive, non-adaptive, etc..) ; absToldesired absolute tolerance. The algorithm will stop when either the absolute OR the relative tolerance are satisfied. ; relToldesired relative tolerance ; sizemaximum number of sub-intervals ; ruleGauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When no values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions ; Definition at line 165 of file Integrator.h. ◆ ~IntegratorOneDim(). virtual ROOT::Math::IntegratorOneDim::~IntegratorOneDim ; (; ). inlinevirtual . destructor (will delete contained pointers) ; Definition at line 173 of file Integrator.h. ◆ IntegratorOneDim() [4/4]. ROOT::Math::IntegratorOneDim::IntegratorOneDim ; (; const IntegratorOneDim & ; ). inlineprivate . Definition at line 181 of file Integrator.h. Member Function Documentation. ◆ CreateIntegrator(). VirtualIntegratorOneDim * ROOT::Math::IntegratorOneDim::CreateIntegrator ; (; IntegrationOneDim::Type ; type, . double ; absTol, . double ; relTol, . unsigned int ; size, . int ; rule . ). protected . Definition at line 114 of file Integrator.cxx. ◆ Error(). double ROOT::Math::IntegratorOneDim::Error ; (; ); const. inline . return the esti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html:10401,integrat,integration,10401,doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,1,['integrat'],['integration']
Deployability,"xis descriptor; TAxisTH1::fYaxisY axis descriptor; TAxisTH1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH1D(); Constructor. TH1D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup); Create a 1-Dim histogram with fix bins of type double; (see TH1::TH1 for explanation of parameters). TH1D(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins); Create a 1-Dim histogram with variable bins of type double; (see TH1::TH1 for explanation of parameters). TH1D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins); Create a 1-Dim histogram with variable bins of type double; (see TH1::TH1 for explanation of parameters). TH1D(const TVectorD& v); Create a histogram from a TVectorD; by default the histogram name is ""TVectorD"" and title = """". ~TH1D(); Destructor. TH1D(const TH1D& h1d); Constructor. void Copy(TObject& hnew) const; Copy this to newth1. void Reset(Option_t* option = """"); Reset. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. TH1D& operator=(const TH1D& h1); Operator =. void AddBinContent(Int_t bin). void AddBinContent(Int_t bin, Double_t w). Double_t RetrieveBinContent(Int_t bin) const. void UpdateBinContent(Int_t bin, Double_t content). » Author: Rene Brun 26/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-30 15:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1D.html:26550,Update,UpdateBinContent,26550,root/html602/TH1D.html,https://root.cern,https://root.cern/root/html602/TH1D.html,1,['Update'],['UpdateBinContent']
Deployability,"xis descriptor; TAxisTH1::fYaxisY axis descriptor; TAxisTH1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH1D(); Constructor. TH1D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup); Create a 1-Dim histogram with fix bins of type double; (see TH1::TH1 for explanation of parameters). TH1D(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins); Create a 1-Dim histogram with variable bins of type double; (see TH1::TH1 for explanation of parameters). TH1D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins); Create a 1-Dim histogram with variable bins of type double; (see TH1::TH1 for explanation of parameters). TH1D(const TVectorD& v); Create a histogram from a TVectorD; by default the histogram name is ""TVectorD"" and title = """". ~TH1D(); Destructor. TH1D(const TH1D& h1d); Constructor. void Copy(TObject& hnew) const; Copy this to newth1. void Reset(Option_t* option = """"); Reset. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. TH1D& operator=(const TH1D& h1); Operator =. void AddBinContent(Int_t bin). void AddBinContent(Int_t bin, Double_t w). Double_t RetrieveBinContent(Int_t bin) const. void UpdateBinContent(Int_t bin, Double_t content). » Author: Rene Brun 26/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-07-01 17:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TH1D.html:26511,Update,UpdateBinContent,26511,root/html604/TH1D.html,https://root.cern,https://root.cern/root/html604/TH1D.html,1,['Update'],['UpdateBinContent']
Deployability,"xis when constructing the interval ; Definition at line 178 of file MCMCCalculator.h. ◆ fNumBurnInSteps. Int_t RooStats::MCMCCalculator::fNumBurnInSteps = 0. protected . number of iterations to discard as burn-in, starting from the first ; Definition at line 177 of file MCMCCalculator.h. ◆ fNumIters. Int_t RooStats::MCMCCalculator::fNumIters = 0. protected . number of iterations to run metropolis algorithm ; Definition at line 176 of file MCMCCalculator.h. ◆ fPdf. RooAbsPdf* RooStats::MCMCCalculator::fPdf. protected . pointer to common PDF (owned by the workspace) ; Definition at line 173 of file MCMCCalculator.h. ◆ fPOI. RooArgSet RooStats::MCMCCalculator::fPOI. protected . parameters of interest for interval ; Definition at line 167 of file MCMCCalculator.h. ◆ fPriorPdf. RooAbsPdf* RooStats::MCMCCalculator::fPriorPdf. protected . pointer to prior PDF (owned by the workspace) ; Definition at line 174 of file MCMCCalculator.h. ◆ fPropFunc. ProposalFunction* RooStats::MCMCCalculator::fPropFunc. mutableprotected . Proposal function for MCMC integration. ; Definition at line 172 of file MCMCCalculator.h. ◆ fSize. double RooStats::MCMCCalculator::fSize = -1. protected . size of the test (eg. specified rate of Type I error) ; Definition at line 166 of file MCMCCalculator.h. ◆ fUseKeys. bool RooStats::MCMCCalculator::fUseKeys = false. protected . whether to use kernel estimation to determine interval ; Definition at line 181 of file MCMCCalculator.h. ◆ fUseSparseHist. bool RooStats::MCMCCalculator::fUseSparseHist = false. protected . whether to use sparse histogram (if using hist at all) ; Definition at line 182 of file MCMCCalculator.h. Libraries for RooStats::MCMCCalculator:. [legend]; The documentation for this class was generated from the following files:; roofit/roostats/inc/RooStats/MCMCCalculator.h; roofit/roostats/src/MCMCCalculator.cxx. RooStatsMCMCCalculator. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:55 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1MCMCCalculator.html:31093,integrat,integration,31093,doc/master/classRooStats_1_1MCMCCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1MCMCCalculator.html,1,['integrat'],['integration']
Deployability,"xis::SetAxisColor(Color_t color = 1, Float_t alpha = 1.)MENU ; virtual voidSetBinLabel(Int_t bin, const char* label); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetDecimals(Bool_t dot = kTRUE)TOGGLE GETTER ; virtual voidSetDefaults(); virtual voidSetDrawOption(Option_t* = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTAttAxis::SetLabelColor(Color_t color = 1, Float_t alpha = 1.)MENU ; virtual voidTAttAxis::SetLabelFont(Style_t font = 62)MENU ; virtual voidTAttAxis::SetLabelOffset(Float_t offset = 0.005)MENU ; virtual voidTAttAxis::SetLabelSize(Float_t size = 0.04)MENU ; virtual voidSetLimits(Double_t xmin, Double_t xmax); virtual voidSetMoreLogLabels(Bool_t more = kTRUE)TOGGLE GETTER ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTAttAxis::SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE)MENU ; virtual voidTAttAxis::SetNdivisions(Int_t n1, Int_t n2, Int_t n3, Bool_t optim = kTRUE); virtual voidSetNoExponent(Bool_t noExponent = kTRUE)TOGGLE GETTER ; static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetParent(TObject* obj); virtual voidSetRange(Int_t first = 0, Int_t last = 0)MENU ; virtual voidSetRangeUser(Double_t ufirst, Double_t ulast)MENU ; virtual voidTAttAxis::SetTickLength(Float_t length = 0.03)MENU ; virtual voidSetTicks(Option_t* option = ""+"")MENU ; virtual voidTAttAxis::SetTickSize(Float_t size = 0.03); virtual voidSetTimeDisplay(Int_t value)TOGGLE ; virtual voidSetTimeFormat(const char* format = """")MENU ; virtual voidSetTimeOffset(Double_t toffset, Option_t* option = ""local""); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTAttAxis::SetTitleColor(Color_t color = 1)MENU ; virtual voidTAttAxis::SetTitleFont(Style_t font = 62)MENU ; virtual voidTAttAxis::SetTitleOffset(Float_t offset = 1)MENU ; virtual voidTAttAxis::SetTitleSize(Float_t size = 0.04)MENU ; virtual voidTObject::SetU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TAxis.html:7165,TOGGLE,TOGGLE,7165,root/html534/TAxis.html,https://root.cern,https://root.cern/root/html534/TAxis.html,2,['TOGGLE'],['TOGGLE']
Deployability,"xist = ROOT.gSystem.AccessPathName(inputFileName); ; # if file does not exists create it; if fileDoesNotExist:; MakeTimeData(nTotEvts, ntime, ninput); ; ; inputFile = TFile.Open(inputFileName); if inputFile is None:; raise ROOT.Error(""Error opening input file %s - exit"", inputFileName.Data()); ; ; print(""--- RNNClassification : Using input file: {}"".format(inputFile.GetName())); ; # Create a ROOT output file where TMVA will store ntuples, histograms, etc.; outfileName = ""data_RNN_"" + archString + "".root""; outputFile = None; ; ; if writeOutputFile:; outputFile = TFile.Open(outfileName, ""RECREATE""); ; ; ## Declare Factory; ; # Create the Factory class. Later you can choose the methods; # whose performance you'd like to investigate.; ; # The factory is the major TMVA object you have to interact with. Here is the list of parameters you need to; # pass; ; # - The first argument is the base of the name of all the output; # weightfiles in the directory weight/ that will be created with the; # method parameters; ; # - The second argument is the output file for the training results; #; # - The third argument is a string option defining some general configuration for the TMVA session.; # For example all TMVA output can be suppressed by removing the ""!"" (not) in front of the ""Silent"" argument in; # the option string; ; ; # // Creating the factory object; factory = TMVA.Factory(; ""TMVAClassification"",; outputFile,; V=False,; Silent=False,; Color=True,; DrawProgressBar=True,; Transformations=None,; Correlations=False,; AnalysisType=""Classification"",; ModelPersistence=True,; ); dataloader = TMVA.DataLoader(""dataset""); ; signalTree = inputFile.Get(""sgn""); background = inputFile.Get(""bkg""); ; nvar = ninput * ntime; ; ## add variables - use new AddVariablesArray function; for i in range(ntime):; dataloader.AddVariablesArray(""vars_time"" + str(i), ninput); ; ; dataloader.AddSignalTree(signalTree, 1.0); dataloader.AddBackgroundTree(background, 1.0); ; # check given input; datainfo = dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:54709,configurat,configuration,54709,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['configurat'],['configuration']
Deployability,"xisting entry in NameFilters. ;  ; const EDialogTypes & GetType () const;  ; std::string GetWorkingPath () const;  Returns current working path. ;  ; void Hide ();  Hide ROOT Browser. ;  ; bool IsCompleted () const;  ; void SetCallback (RFileDialogCallback_t callback);  Assign callback. ;  ; void SetCanChangePath (bool on=true);  Configure if working path in dialog can be changed via gui elements. ;  ; void SetNameFilters (const std::vector< std::string > &arr);  Set array of name filters like ""Text files (*.txt)"", ""Any files (*)"", ""Image files (*png *.jpg)"" Should be specified before starting dialog. ;  ; void SetSelectedFilter (const std::string &name);  Configure selected filter Has to be one of the string from NameFilters entry. ;  ; void SetWorkingPath (const std::string &);  Change current working path of file dialog If dialog already shown, change will be immediately applied. ;  ; void Show (const RWebDisplayArgs &args="""");  Show or update RFileDialog in web window If web window already started - just refresh it like ""reload"" button does Reset result of file selection (if any) ;  . Static Public Member Functions; static std::shared_ptr< RFileDialog > Embed (const std::shared_ptr< RWebWindow > &window, unsigned connid, const std::string &args);  Create dialog instance to use as embedded dialog inside other widget Embedded dialog started on the client side where FileDialogController.SaveAs() method called Such method immediately send message with ""FILEDIALOG:"" prefix On the server side widget should detect such message and call RFileDialog::Embed() providing received string as second argument. ;  ; static bool IsMessageToStartDialog (const std::string &msg);  Check if this could be the message send by client to start new file dialog If returns true, one can call RFileDialog::Embedded() to really create file dialog instance inside existing widget. ;  ; static std::string NewFile (const std::string &title="""", const std::string &fname="""");  Start NewFile dialog. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RFileDialog.html:2169,update,update,2169,doc/v632/classROOT_1_1RFileDialog.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RFileDialog.html,2,['update'],['update']
Deployability,"xpensive geometries. In future there will be a limitation on the maximum number of nodes to be visualized. opt=2; only the clicked volume is visualized. This is automatically set by TGeoVolume::DrawOnly() method; opt=3 - only a given path is visualized. This is automatically set by; TGeoVolume::DrawPath(const char *path) method; The current view can be exploded in cartesian, cylindrical or spherical coordinates : TGeoManager::SetExplodedView(Int_t opt). Options may be :; 0 - default (no bombing); 1 - cartesian coordinates. The bomb factor on each axis can be set with TGeoManager::SetBombX(Double_t bomb) and corresponding Y and Z.; 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R are considered . 3 - bomb in radial spherical coordinate : TGeoManager::SetBombR(). Volumes themselves support different visualization settings :; TGeoVolume::SetVisibility() : set volume visibility.; TGeoVolume::VisibleDaughters() : set daughters visibility. All these actions automatically updates the current view if any. Checking the geometry; Several checking methods are accessible from the volume context menu. They generally apply only to the visible parts of the drawn geometry in order to ease geometry checking, and their implementation is in the TGeoChecker class from the painting package.; Checking a given point.; Can be called from TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z). This method is drawing the daughters of the volume containing the point one level down, printing the path to the deepest physical node holding this point. It also computes the closest distance to any boundary. The point will be drawn in red, as well as a sphere having this closest distance as radius. In case a non-zero distance is given by the user as fifth argument of CheckPoint, this distance will be used as radius of the safety sphere. Shooting random points.; Can be called from TGeoVolume::RandomPoints() (context menu function) and it will draw this volume with current vis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:17803,update,updates,17803,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['update'],['updates']
Deployability,"xpression. void SyncFormulas(); Sync the formulas using the TTreeFormulaManager. void InitEntries(); Initialise the TEntryList with the entries that match the; selection criterium. Double_t GetValue(UInt_t row, UInt_t column); Return the value of row,column. If the position does not exist; or does not contain a number, 0 is returned. const char * GetValueAsString(UInt_t row, UInt_t column); Return the content of row,column as string to use in a; TGTableCell label. const char * GetRowHeader(UInt_t row); Return a string to use as a label for rowheader at column. const char * GetColumnHeader(UInt_t column); Return a string to use as a label for columnheader at column. UInt_t GetNColumns(); Return the amount of column available. UInt_t GetNRows(); Return the amount of rows in the Tree. void AddColumn(const char* expression, UInt_t position); Add column according ot expression at position,; TGTable->Update() is needed afterwards to apply the change to; the TGTable. void AddColumn(TTreeFormula* formula, UInt_t position); Add column with formula at position, TGTable->Update() is needed; afterwards to apply the change to the TGTable. void RemoveColumn(UInt_t position); Remove column at position, TGTable->Update() is needed; afterwards to apply the change to the TGTable. void SetFormula(TTreeFormula* formula, UInt_t position); Set the TTreeFormula of position to formula. void SetEntryList(TEntryList* entrylist = 0); Set the currently active entrylist. TTreeTableInterface(TTree* tree = 0, const char* varexp = 0, const char* selection = 0, Option_t* option = 0, Long64_t nentries = 0, Long64_t firstentry = 0). TEntryList * GetEntryList(); { return fEntries; }. » Author: Roel Aaij 21/07/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: Thu Nov 3 20:23:57 2011 » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeTableInterface.html:4467,Update,Update,4467,root/html532/TTreeTableInterface.html,https://root.cern,https://root.cern/root/html532/TTreeTableInterface.html,2,['Update'],['Update']
Deployability,"xpression. void SyncFormulas(); Sync the formulas using the TTreeFormulaManager. void InitEntries(); Initialise the TEntryList with the entries that match the; selection criterium. Double_t GetValue(UInt_t row, UInt_t column); Return the value of row,column. If the position does not exist; or does not contain a number, 0 is returned. const char * GetValueAsString(UInt_t row, UInt_t column); Return the content of row,column as string to use in a; TGTableCell label. const char * GetRowHeader(UInt_t row); Return a string to use as a label for rowheader at column. const char * GetColumnHeader(UInt_t column); Return a string to use as a label for columnheader at column. UInt_t GetNColumns(); Return the amount of column available. UInt_t GetNRows(); Return the amount of rows in the Tree. void AddColumn(const char* expression, UInt_t position); Add column according ot expression at position,; TGTable->Update() is needed afterwards to apply the change to; the TGTable. void AddColumn(TTreeFormula* formula, UInt_t position); Add column with formula at position, TGTable->Update() is needed; afterwards to apply the change to the TGTable. void RemoveColumn(UInt_t position); Remove column at position, TGTable->Update() is needed; afterwards to apply the change to the TGTable. void SetFormula(TTreeFormula* formula, UInt_t position); Set the TTreeFormula of position to formula. void SetEntryList(TEntryList* entrylist = 0); Set the currently active entrylist. TTreeTableInterface(TTree* tree = 0, const char* varexp = 0, const char* selection = 0, Option_t* option = 0, Long64_t nentries = 0, Long64_t firstentry = 0). TEntryList * GetEntryList(); { return fEntries; }. » Author: Roel Aaij 21/07/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: Tue Jun 2 16:35:07 2015 » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeTableInterface.html:4536,Update,Update,4536,root/html604/TTreeTableInterface.html,https://root.cern,https://root.cern/root/html604/TTreeTableInterface.html,2,['Update'],['Update']
Deployability,"xt files will first be run through; THtml::Convert().; You can see an example here;; the part between ""Index of HIST classes"" and ""Jump to"" is created by parsing; the module's doc directory.; VI. Auxiliary files: style sheet, JavaScript, help page; The documentation pages share a common set of javascript and CSS files. They; are generated automatically when running MakeAll();; they can be generated on; demand by calling CreateAuxiliaryFiles().; VII. Class Charts; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged ontop of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies.; These graphs are generated using the Graphviz; package. You can install it from http://www.graphviz.org.; You can either put it into your $PATH, or tell THtml where to find it by calling; SetDotDir().; VIII. Configuration variables; Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; TEnv. Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; Root.Html.Root (default: ) - URL of Root's class documentation; Root.Html.SearchEngine (default: ) - link to the search engine; Root.Html.Search (defualt: ) - link to search by replacing ""%s"" with user input; Root.Html.ViewCVS (default: ) - URL of ViewCVS base; Root.Html.XWho (default: http://consult.cern.ch/xwho/peopl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THtml.html:15815,configurat,configuration,15815,root/html528/THtml.html,https://root.cern,https://root.cern/root/html528/THtml.html,26,"['Configurat', 'configurat']","['Configuration', 'configuration']"
Deployability,"xt(). void ResetAll(); Reset the CINT state to its initial state. void ResetGlobals(); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void ResetGlobalVar(void* obj); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void RewindDictionary(); Rewind CINT dictionary to the point where it was before executing; the current macro. This function is typically called after SEGV or; ctlr-C after doing a longjmp back to the prompt. Int_t DeleteGlobal(void* obj); Delete obj from CINT symbol table so it cannot be accessed anymore.; Returns 1 in case of success and 0 in case object was not in table. void SaveContext(); Save the current CINT state. void SaveGlobalsContext(); Save the current CINT state of global objects. void UpdateListOfGlobals(); Update the list of pointers to global variables. This function; is called by TROOT::GetListOfGlobals(). void UpdateListOfGlobalFunctions(); Update the list of pointers to global functions. This function; is called by TROOT::GetListOfGlobalFunctions(). void UpdateListOfTypes(); Update the list of pointers to Datatype (typedef) definitions. This; function is called by TROOT::GetListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE); Set pointer to CINT's G__ClassInfo in TClass. Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE); Checks if a class with the specified name is defined in CINT.; Returns kFALSE is class is not defined. void CreateListOfBaseClasses(TClass* cl); Create list of pointers to base class(es) for TClass cl. void CreateListOfDataMembers(TClass* cl); Create list of pointers to data members for TClass cl. void CreateListOfMethods(TClass* cl); Create list of pointers to methods for TClass cl. void UpdateListOfMethods(TClass* cl); Update the list of pointers to method for TClass cl, if necessary. void CreateListOfMethodArgs(TFunction* m); Create list of pointers to method arguments for TM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCint.html:23068,Update,UpdateListOfGlobalFunctions,23068,root/html532/TCint.html,https://root.cern,https://root.cern/root/html532/TCint.html,2,['Update'],"['Update', 'UpdateListOfGlobalFunctions']"
Deployability,"xt->fDirectoryWait = false;; 287 }; 288 fContext = next;; 289 }; 290 ; 291 // Now loop through the set of thread local 'gDirectory' that; 292 // have a one point or another pointed to this directory.; 293 for (auto &ptr : fGDirectories) {; 294 // If the thread local gDirectory still point to this directory; 295 // we need to reset it using the following sematic:; 296 // we fall back to the mother/owner of this directory or gROOTLocal; 297 // if there is no parent or nullptr if the current object is gROOTLocal.; 298 if (ptr->load() == this) {; 299 TDirectory *next = GetMotherDir();; 300 if (!next || next == this) {; 301 if (this == ROOT::Internal::gROOTLocal) { /// in that case next == this.; 302 next = nullptr;; 303 } else {; 304 next = ROOT::Internal::gROOTLocal;; 305 }; 306 } else {; 307 // We can not use 'cd' as this would access the current thread; 308 // rather than the thread corresponding to that gDirectory.; 309 next->RegisterGDirectory(ptr);; 310 }; 311 // Actually do the update of the thread local gDirectory; 312 // using its object specific lock.; 313 auto This = this;; 314 ptr->compare_exchange_strong(This, next);; 315 }; 316 }; 317 }; 318 for(auto &&context : extraWait) {; 319 // Wait until the TContext is done spinning; 320 // over the lock.; 321 while(context->fActiveDestructor);; 322 // And now let the TContext destructor finish.; 323 context->fDirectoryWait = false;; 324 }; 325 ; 326 // Wait until all register attempts are done.; 327 while(fContextPeg) {}; 328 ; 329}; 330 ; 331////////////////////////////////////////////////////////////////////////////////; 332/// Fast execution of 'new TBufferFile(TBuffer::kWrite,10000), without having; 333/// a compile time circular dependency ... alternatively we could (should?); 334/// introduce yet another abstract interface.; 335 ; 336static TBuffer* R__CreateBuffer(); 337{; 338 typedef void (*tcling_callfunc_Wrapper_t)(void*, int, void**, void*);; 339 static tcling_callfunc_Wrapper_t creator = nullptr;; 340 if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:10501,update,update,10501,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,1,['update'],['update']
Deployability,"xt::SaveTextAttributes(ostream& out, const char* name, Int_t alidef = 12, Float_t angdef = 0, Int_t coldef = 1, Int_t fondef = 61, Float_t sizdef = 1); virtual voidTAttPad::SetAfile(Float_t afile); virtual voidTAttPad::SetAstat(Float_t astat); virtual voidTPad::SetAttFillPS(Color_t color, Style_t style); virtual voidTPad::SetAttLinePS(Color_t color, Style_t style, Width_t lwidth); virtual voidTPad::SetAttMarkerPS(Color_t color, Style_t style, Size_t msize); virtual voidTPad::SetAttTextPS(Int_t align, Float_t angle, Color_t color, Style_t font, Float_t tsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBorderMode(Short_t bordermode); virtual voidTPad::SetBorderSize(Short_t bordersize)MENU ; virtual voidTAttPad::SetBottomMargin(Float_t bottommargin); virtual voidTPad::SetCanvas(TCanvas* c); virtual voidTPad::SetCanvasSize(UInt_t ww, UInt_t wh); virtual voidTPad::SetCopyGLDevice(Bool_t copy); virtual voidTPad::SetCrosshair(Int_t crhair = 1)TOGGLE ; virtual voidTPad::SetCursor(ECursor cursor); virtual voidTPad::SetDoubleBuffer(Int_t mode = 1); virtual voidTPad::SetDrawOption(Option_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidTPad::SetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTPad::SetFillStyle(Style_t fstyle); virtual voidTPad::SetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidSetFraming(Bool_t f = 1); virtual voidTPad::SetGLDevice(Int_t dev); virtual voidSetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidTPad::SetGridx(Int_t v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TButton.html:19605,TOGGLE,TOGGLE,19605,root/html532/TButton.html,https://root.cern,https://root.cern/root/html532/TButton.html,1,['TOGGLE'],['TOGGLE']
Deployability,"xt::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; TIterator*_uniIterIterator over uniform observables; RooArgSet_uniObsObservable to be generated with flat distribution; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProdGenContext(const RooProdPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). ~RooProdGenContext(); Destructor. Delete all owned subgenerator contexts. void attach(const RooArgSet& params); Attach generator to given event buffer. void initGenerator(const RooArgSet& theEvent); One-time initialization of generator context, forward to component generators. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate a single event of the product by generating the components; of the products sequentially. The subcontext have been order such; that all conditional dependencies are correctly taken into account; when processed in sequential order. void setProtoDataOrder(Int_t* lut); Set the traversal order of the prototype dataset by the; given lookup table. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. RooProdGenContext(const RooProdPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). void updateCCDTable(). » Last changed: Mon Dec 7 13:48:42 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProdGenContext.html:10097,update,updateCCDTable,10097,root/html526/RooProdGenContext.html,https://root.cern,https://root.cern/root/html526/RooProdGenContext.html,1,['update'],['updateCCDTable']
Deployability,"xt::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; TIterator*_uniIterIterator over uniform observables; RooArgSet_uniObsObservable to be generated with flat distribution; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProdGenContext(const RooProdPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). ~RooProdGenContext(); Destructor. Delete all owned subgenerator contexts. void attach(const RooArgSet& params); Attach generator to given event buffer. void initGenerator(const RooArgSet& theEvent); One-time initialization of generator context, forward to component generators. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate a single event of the product by generating the components; of the products sequentially. The subcontext have been order such; that all conditional dependencies are correctly taken into account; when processed in sequential order. void setProtoDataOrder(Int_t* lut); Set the traversal order of the prototype dataset by the; given lookup table. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. RooProdGenContext(const RooProdPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). void updateCCDTable(). » Last changed: Mon Jul 4 15:23:42 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooProdGenContext.html:10326,update,updateCCDTable,10326,root/html530/RooProdGenContext.html,https://root.cern,https://root.cern/root/html530/RooProdGenContext.html,1,['update'],['updateCCDTable']
Deployability,"xt::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; TIterator*_uniIterIterator over uniform observables; RooArgSet_uniObsObservable to be generated with flat distribution; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProdGenContext(const RooProdPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). ~RooProdGenContext(); Destructor. Delete all owned subgenerator contexts. void attach(const RooArgSet& params); Attach generator to given event buffer. void initGenerator(const RooArgSet& theEvent); One-time initialization of generator context, forward to component generators. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate a single event of the product by generating the components; of the products sequentially. The subcontext have been order such; that all conditional dependencies are correctly taken into account; when processed in sequential order. void setProtoDataOrder(Int_t* lut); Set the traversal order of the prototype dataset by the; given lookup table. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. RooProdGenContext(const RooProdPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). void updateCCDTable(). » Last changed: Sat Oct 9 20:48:32 2010 » Last generated: 2010-10-09 20:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProdGenContext.html:10146,update,updateCCDTable,10146,root/html528/RooProdGenContext.html,https://root.cern,https://root.cern/root/html528/RooProdGenContext.html,1,['update'],['updateCCDTable']
Deployability,"xt::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; TIterator*_uniIterIterator over uniform observables; RooArgSet_uniObsObservable to be generated with flat distribution; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProdGenContext(const RooProdPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). ~RooProdGenContext(); Destructor. Delete all owned subgenerator contexts. void attach(const RooArgSet& params); Attach generator to given event buffer. void initGenerator(const RooArgSet& theEvent); One-time initialization of generator context, forward to component generators. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate a single event of the product by generating the components; of the products sequentially. The subcontext have been order such; that all conditional dependencies are correctly taken into account; when processed in sequential order. void setProtoDataOrder(Int_t* lut); Set the traversal order of the prototype dataset by the; given lookup table. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. RooProdGenContext(const RooProdPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). void updateCCDTable(). » Last changed: Thu Nov 3 20:08:59 2011 » Last generated: 2011-11-03 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProdGenContext.html:10329,update,updateCCDTable,10329,root/html532/RooProdGenContext.html,https://root.cern,https://root.cern/root/html532/RooProdGenContext.html,2,['update'],['updateCCDTable']
Deployability,"xt::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; TIterator*_uniIterIterator over uniform observables; RooArgSet_uniObsObservable to be generated with flat distribution; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProdGenContext(const RooProdPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). ~RooProdGenContext(); Destructor. Delete all owned subgenerator contexts. void attach(const RooArgSet& params); Attach generator to given event buffer. void initGenerator(const RooArgSet& theEvent); One-time initialization of generator context, forward to component generators. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate a single event of the product by generating the components; of the products sequentially. The subcontext have been order such; that all conditional dependencies are correctly taken into account; when processed in sequential order. void setProtoDataOrder(Int_t* lut); Set the traversal order of the prototype dataset by the; given lookup table. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Detailed printing interface. RooProdGenContext(const RooProdPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). void updateCCDTable(). » Last changed: Tue Jun 2 15:33:02 2015 » Last generated: 2015-06-02 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooProdGenContext.html:11460,update,updateCCDTable,11460,root/html604/RooProdGenContext.html,https://root.cern,https://root.cern/root/html604/RooProdGenContext.html,2,['update'],['updateCCDTable']
Deployability,"xtButton::SetText(const TString& new_label); virtual voidTGTextButton::SetTextColor(Pixel_t color, Bool_t global = kFALSE); virtual voidTGTextButton::SetTextJustify(Int_t tmode); virtual voidTGTextButton::SetTitle(const char* label); virtual voidTGButton::SetToolTipText(const char* text, Long_t delayms = 400)MENU ; virtual voidTGTextButton::SetTopMargin(Int_t val); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGButton::SetUserData(void* userData); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); voidTGTextButton::SetWrapLength(Int_t wl); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TGCheckButton(const TGWindow* p, TGHotString* s, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t option = 0); TGCheckButton(const TGWindow* p = 0, const char* s = 0, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t option = 0); TGCheckButton(const TGWindow* p, const char* s, const char* cmd, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t option = 0); virtual voidTGButton::Toggle(Bool_t emit = kFALSE); virtual voidTGButton::Toggled(Bool_t on)SIGNAL ; virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGCheckButton.html:18761,Toggle,Toggle,18761,root/html602/TGCheckButton.html,https://root.cern,https://root.cern/root/html602/TGCheckButton.html,4,['Toggle'],"['Toggle', 'Toggled']"
Deployability,"xtButton::SetText(const TString& new_label); virtual voidTGTextButton::SetTextColor(Pixel_t color, Bool_t global = kFALSE); virtual voidTGTextButton::SetTextJustify(Int_t tmode); virtual voidTGTextButton::SetTitle(const char* label); virtual voidTGButton::SetToolTipText(const char* text, Long_t delayms = 400)MENU ; virtual voidTGTextButton::SetTopMargin(Int_t val); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGButton::SetUserData(void* userData); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); voidTGTextButton::SetWrapLength(Int_t wl); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TGRadioButton(const TGWindow* p, TGHotString* s, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t option = 0); TGRadioButton(const TGWindow* p = 0, const char* s = 0, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t option = 0); TGRadioButton(const TGWindow* p, const char* s, const char* cmd, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t option = 0); virtual voidTGButton::Toggle(Bool_t emit = kFALSE); virtual voidTGButton::Toggled(Bool_t on)SIGNAL ; virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGRadioButton.html:18751,Toggle,Toggle,18751,root/html602/TGRadioButton.html,https://root.cern,https://root.cern/root/html602/TGRadioButton.html,4,['Toggle'],"['Toggle', 'Toggled']"
Deployability,"xtEntry*fTxtSelectorselector name text entry; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNewQueryDlg(TSessionViewer* gui, Int_t Width, Int_t Height, TQueryDescription* query = 0, Bool_t editmode = kFALSE); Create a new Query dialog, used by the Session Viewer, to Edit a Query if; the editmode flag is set, or to create a new one if not set. ~TNewQueryDlg(); Delete query dialog. void Build(TSessionViewer* gui); Build the ""new query"" dialog. void CloseWindow(); Called when window is closed via the window manager. void OnNewQueryMore(); Show/hide options frame and update button text accordingly. void OnBrowseChain(); Call new chain dialog. void OnElementSelected(TObject* obj); Handle OnElementSelected signal coming from new chain dialog. void OnBrowseSelector(); Open file browser to choose selector macro. void OnBrowseEventList(); Browse event list. void OnBtnSaveClicked(); Save current settings in main session viewer. void OnBtnSubmitClicked(); Save and submit query description. void OnBtnCloseClicked(); Close dialog. void Popup(); Display dialog and set focus to query name text entry. void SettingsChanged(); Settings have changed, update GUI accordingly. void UpdateFields(TQueryDescription* desc); Update entry fields with query description values. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for new query dialog.; Essentially used to navigate between text entry fields. TNewQueryDlg(TSessionViewer* gui, Int_t Width, Int_t Height, TQueryDescription* query = 0, Bool_t editmode = kFALSE). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-06-02 16:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TNewQueryDlg.html:25430,update,update,25430,root/html604/TNewQueryDlg.html,https://root.cern,https://root.cern/root/html604/TNewQueryDlg.html,4,"['Update', 'update']","['Update', 'UpdateFields', 'update']"
Deployability,"xtEntry*fTxtSelectorselector name text entry; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNewQueryDlg(TSessionViewer* gui, Int_t Width, Int_t Height, TQueryDescription* query = 0, Bool_t editmode = kFALSE); Create a new Query dialog, used by the Session Viewer, to Edit a Query if; the editmode flag is set, or to create a new one if not set. ~TNewQueryDlg(); Delete query dialog. void Build(TSessionViewer* gui); Build the ""new query"" dialog. void CloseWindow(); Called when window is closed via the window manager. void OnNewQueryMore(); Show/hide options frame and update button text accordingly. void OnBrowseChain(); Call new chain dialog. void OnElementSelected(TObject* obj); Handle OnElementSelected signal coming from new chain dialog. void OnBrowseSelector(); Open file browser to choose selector macro. void OnBrowseEventList(); Browse event list. void OnBtnSaveClicked(); Save current settings in main session viewer. void OnBtnSubmitClicked(); Save and submit query description. void OnBtnCloseClicked(); Close dialog. void Popup(); Display dialog and set focus to query name text entry. void SettingsChanged(); Settings have changed, update GUI accordingly. void UpdateFields(TQueryDescription* desc); Update entry fields with query description values. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for new query dialog.; Essentially used to navigate between text entry fields. TNewQueryDlg(TSessionViewer* gui, Int_t Width, Int_t Height, TQueryDescription* query = 0, Bool_t editmode = kFALSE). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-06-30 15:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNewQueryDlg.html:25430,update,update,25430,root/html602/TNewQueryDlg.html,https://root.cern,https://root.cern/root/html602/TNewQueryDlg.html,4,"['Update', 'update']","['Update', 'UpdateFields', 'update']"
Deployability,"xtIdentity*GetDefaultIdentity(); TGLFontManager*GetFontManager(); Int_tGetRefCnt() const; virtual TClass*IsA() const; Bool_tIsValid() const; TGLContextIdentity&operator=(const TGLContextIdentity&); voidRegisterDLNameRangeToWipe(UInt_t base, Int_t size); voidRelease(TGLContext* ctx); voidReleaseClient(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. voidCheckDestroy(). Data Members; protected:. TGLFontManager*fFontManagerFreeType font manager. private:. Int_tfClientCnt; Int_tfCnt; list<TGLContext*>fCtxs; list<pair<unsigned int,int>,allocator<pair<unsigned int,int> > >fDLTrash; static TGLContextIdentity*fgDefaultIdentity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLContextIdentity(); Constructor. ~TGLContextIdentity(); Destructor. void AddRef(TGLContext* ctx); Add context ctx to the list of references. void Release(TGLContext* ctx); Remove context ctx from the list of references. void RegisterDLNameRangeToWipe(UInt_t base, Int_t size); Remember dl range for deletion in next MakeCurrent or dtor execution. void DeleteGLResources(); Delete GL resources registered for destruction. TGLContextIdentity* GetCurrent(); Find identitfy of current context. Static. TGLContextIdentity* GetDefaultIdentity(); Get identity of a default Gl context. Static. TGLContext* GetDefaultContextAny(); Get the first GL context with the default identity.; Can return zero, but that's OK, too. Static. TGLFontManager* GetFontManager(); Get the free-type font-manager associated with this context-identity. void CheckDestroy(); Private function called when reference count is reduced. Bool_t IsValid() const; { return fValid; }. TGLContextIdentity(). void AddClientRef(); { ++fClientCnt; }. void ReleaseClient(); { --fClientCnt; CheckDestroy(); }. Int_t GetRefCnt() const; { return fCnt; }. Int_t GetClientRefCnt() const; { return fClientCnt; }. » Author: Timur P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLContextIdentity.html:1768,Release,Release,1768,root/html534/TGLContextIdentity.html,https://root.cern,https://root.cern/root/html534/TGLContextIdentity.html,1,['Release'],['Release']
Deployability,"xtMenu*TEveCompositeFrame::fgCtxMenu; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static TList*TEveCompositeFrame::fgFrameList; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static const TStringTEveCompositeFrame::fgkEmptyFrameName. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveCompositeFrameInMainFrame(TGCompositeFrame* parent, TEveWindow* eve_parent, TGMainFrame* mf); Constructor. ~TEveCompositeFrameInMainFrame(); Destructor. void WindowNameChanged(const TString& name); Update widgets using window's name or title. void Destroy(); Virtual function called from eve side when the frame should be; destroyed. This means we expect that fEveWindow is null. We simply call CloseWindow() on the main-frame which will in; turn generate the ""CloseWindow()"" signal.; This is then handled in MainFrameClosed(). void SetOriginalSlotAndContainer(TEveWindow* slot, TEveWindow* container); Set the container where to return the contained window on destruction. void SomeWindowClosed(TEveWindow* w); Slot called when a window is closed ... we check that this was; not our original container. void MainFrameClosed(); Slot for main-frame's ""CloseWindow()"" signal.; If an eve window is still present, it will be put into:; - original-container, if it is set;; - into window-managers default-container. TEveCompositeFrame& operator=(const TEveCompositeFrameInMainFrame& ). TEveCompositeFrameInMainFrame(const TEveCompositeFrameInMainFrame& ). TEveWindow* GetOriginalSlot() const; { return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveCompositeFrameInMainFrame.html:20743,Update,Update,20743,root/html532/TEveCompositeFrameInMainFrame.html,https://root.cern,https://root.cern/root/html532/TEveCompositeFrameInMainFrame.html,2,['Update'],['Update']
Deployability,"xtPS(Int_t align, Float_t angle, Color_t color, Style_t font, Float_t tsize); virtual voidSetBBoxCenter(const TPoint& p); virtual voidSetBBoxCenterX(const Int_t x); virtual voidSetBBoxCenterY(const Int_t y); virtual voidSetBBoxX1(const Int_t x); virtual voidSetBBoxX2(const Int_t x); virtual voidSetBBoxY1(const Int_t y); virtual voidSetBBoxY2(const Int_t y); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBorderMode(Short_t bordermode)MENU ; virtual voidSetBorderSize(Short_t bordersize)MENU ; virtual voidTAttPad::SetBottomMargin(Float_t bottommargin); virtual voidSetCanvas(TCanvas* c); virtual voidSetCanvasSize(UInt_t ww, UInt_t wh); virtual voidSetCopyGLDevice(Bool_t copy); virtual voidSetCrosshair(Int_t crhair = 1)TOGGLE ; virtual voidSetCursor(ECursor cursor); virtual voidSetDoubleBuffer(Int_t mode = 1); virtual voidSetDrawOption(Option_t* option = """"); static voidTObject::SetDtorOnly(void* obj); virtual voidSetEditable(Bool_t mode = kTRUE)TOGGLE ; virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidSetFillStyle(Style_t fstyle); virtual voidSetFixedAspectRatio(Bool_t fixed = kTRUE)TOGGLE ; voidTAttPad::SetFrameBorderMode(Int_t mode = 1); voidTAttPad::SetFrameBorderSize(Width_t size = 1); voidTAttPad::SetFrameFillColor(Color_t color = 1); voidTAttPad::SetFrameFillStyle(Style_t styl = 0); voidTAttPad::SetFrameLineColor(Color_t color = 1); voidTAttPad::SetFrameLineStyle(Style_t styl = 0); voidTAttPad::SetFrameLineWidth(Width_t width = 1); virtual voidSetGLDevice(Int_t dev); virtual voidSetGrid(Int_t valuex = 1, Int_t valuey = 1); virtual voidSetGridx(Int_t value = 1)TOGGLE ; virtual voidSetGridy(Int_t value = 1)TOGGLE ; virtual voidTAttPad::SetLeftMargin(Float_t leftmargin); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPad.html:18612,TOGGLE,TOGGLE,18612,root/html534/TPad.html,https://root.cern,https://root.cern/root/html534/TPad.html,3,['TOGGLE'],['TOGGLE']
Deployability,"xt_t *value);  Associate string 'value' to this object under key 'key'. ;  ; void setTransientAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setWorkspace (RooWorkspace &ws);  ; const std::map< std::string, std::string > & stringAttributes () const;  ; const std::set< std::string > & transientAttributes () const;  ; virtual void translate (RooFit::Detail::CodeSquashContext &ctx) const;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ; RooWorkspace * workspace () const;  ; virtual void writeToStream (std::ostream &os, bool compact) const =0;  ; Client-Server Interface; These functions allow RooFit to figure out who is serving values to whom. . const RefCountList_t & clients () const;  List of all clients of this object. ;  ; const RefCountList_t & valueClients () const;  List of all value clients of this object. Value clients receive value updates. ;  ; const RefCountList_t & shapeClients () const;  List of all shape clients of this object. ;  ; const RefCountList_t & servers () const;  List of all servers of this object. ;  ; RooAbsArg * findServer (const char *name) const;  Return server of this with name name. Returns nullptr if not found. ;  ; RooAbsArg * findServer (const RooAbsArg &arg) const;  Return server of this that has the same name as arg. Returns nullptr if not found. ;  ; RooAbsArg * findServer (Int_t index) const;  Return i-th server from server list. ;  ; bool isValueServer (const RooAbsArg &arg) const;  Check if this is serving values to arg. ;  ; bool isValueServer (const char *name) const;  Check if this is serving values to an object with name name. ;  ; bool isShapeServer (const RooAbsArg &arg) const;  Check if this is serving shape to arg. ;  ; bool isShapeServer (const char *name) const;  Check if this is serving shape to an object with name name. ;  ; void leafNodeServerList (RooAbsColl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:16632,update,updates,16632,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['update'],['updates']
Deployability,"xtraForProblem; Maximum; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. RooArgList*_constParamList; TStopwatch_cumulTimer; Bool_t_doEvalErrorWall; Int_t_evalCounter; TMatrixDSym*_extV; RooArgList*_floatParamList; RooAbsReal*_func; Bool_t_handleLocalErrors; RooArgList*_initConstParamList; RooArgList*_initFloatParamList; ofstream*_logfile; Int_t_maxEvalMult; Double_t_maxFCN; Int_t_nPar; Int_t_numBadNLL; Int_t_optConst; Int_t_printEvalErrors; Int_t_printLevel; Bool_t_profile; Int_t_status; vector<std::pair<std::string,int> >_statusHistory; static TVirtualFitter*_theFitter; TStopwatch_timer; Bool_t_verbose; Int_t_warnLevel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Cleanup method called by atexit handler installed by RooSentinel; to delete all global heap objects when the program is terminated. RooMinuit(RooAbsReal& function); Construct MINUIT interface to given function. Function can be anything,; but is typically a -log(likelihood) implemented by RooNLLVar or a chi^2; (implemented by RooChi2Var). Other frequent use cases are a RooAddition; of a RooNLLVar plus a penalty or constraint term. This class propagates; all RooFit information (floating parameters, their values and errors); to MINUIT before each MINUIT call and propagates all MINUIT information; back to the RooFit object at the end of each call (updated parameter; values, their (asymmetric errors) etc. The default MINUIT error level; for HESSE and MINOS error analysis is taken from the defaultErrorLevel(); value of the input function. ~RooMinuit(); Destructor. void setStrategy(Int_t strat); Change MINUIT strategy to istrat. Accepted codes; are 0,1,2 and represent MINUIT strategies for dealing; most efficiently with fast FCNs (0), e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMinuit.html:8247,install,installed,8247,root/html532/RooMinuit.html,https://root.cern,https://root.cern/root/html532/RooMinuit.html,2,['install'],['installed']
Deployability,"xtract the relevant meta-information.; Return 0 if OK, -2 if the file cannot be open, -1 if it is corrupted. Int_t FillMetaData(TFileInfo* fi, TDirectory* d, const char* rdir = ""/""); Navigate the directory 'd' (and its subdirectories) looking for TTree objects.; Fill in the relevant metadata information in 'fi'. The name of the TFileInfoMeta; metadata entry will be ""/dir1/dir2/.../tree_name"".; Return 0 on success, -1 if any problem happens (object found in keys cannot be read,; for example). TList * ParseDataSetSrvMaps(const TString& srvmaps); Create a server mapping list from the content of 'srvmaps'; Return the list (owned by the caller) or 0 if no valid info could be found). TList * GetDataSetSrvMaps(); Static getter for server mapping list. Bool_t CheckDataSetSrvMaps(TUrl* furl, TString& fn, TList* srvmaplist = 0); Check if the dataset server mappings apply to the url defined by 'furl'.; Use srvmaplist if defined, else use the default list.; If yes, resolve the mapping into file1 and return kTRUE.; Otherwise return kFALSE. void SetScanCounters(Int_t t = -1, Int_t o = -1, Int_t d = -1); Update scan counters. TDataSetManager(const TDataSetManager& ). TDataSetManager& operator=(const TDataSetManager& ). TMap * GetGroupUsedMap(); for dataset files (init from DataSet.SrvMap). { return &fGroupUsed; }. TMap * GetUserUsedMap(); { return &fUserUsed; }. Int_t GetNTouchedFiles() const; { return fNTouchedFiles; }. Int_t GetNOpenedFiles() const; { return fNOpenedFiles; }. Int_t GetNDisapparedFiles() const; { return fNDisappearedFiles; }. Long64_t GetAvgFileSize() const; { return fAvgFileSize; }. TMap * GetGroupQuotaMap(); { return &fGroupQuota; }. » Author: Jan Fiete Grosse-Oetringhaus, 08.08.07 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-03-12 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDataSetManager.html:23805,Update,Update,23805,root/html534/TDataSetManager.html,https://root.cern,https://root.cern/root/html534/TDataSetManager.html,1,['Update'],['Update']
Deployability,"xtract the relevant meta-information.; Return 0 if OK, -2 if the file cannot be open, -1 if it is corrupted. Int_t FillMetaData(TFileInfo* fi, TDirectory* d, const char* rdir = ""/""); Navigate the directory 'd' (and its subdirectories) looking for TTree objects.; Fill in the relevant metadata information in 'fi'. The name of the TFileInfoMeta; metadata entry will be ""/dir1/dir2/.../tree_name"".; Return 0 on success, -1 if any problem happens (object found in keys cannot be read,; for example). TList * ParseDataSetSrvMaps(const TString& srvmaps); Create a server mapping list from the content of 'srvmaps'; Return the list (owned by the caller) or 0 if no valid info could be found). TList * GetDataSetSrvMaps(); Static getter for server mapping list. Bool_t CheckDataSetSrvMaps(TUrl* furl, TString& fn, TList* srvmaplist = 0); Check if the dataset server mappings apply to the url defined by 'furl'.; Use srvmaplist if defined, else use the default list.; If yes, resolve the mapping into file1 and return kTRUE.; Otherwise return kFALSE. void SetScanCounters(Int_t t = -1, Int_t o = -1, Int_t d = -1); Update scan counters. TDataSetManager(const TDataSetManager& ). TDataSetManager& operator=(const TDataSetManager& ). TMap * GetGroupUsedMap(); for dataset files (init from DataSet.SrvMap). { return &fGroupUsed; }. TMap * GetUserUsedMap(); { return &fUserUsed; }. Int_t GetNTouchedFiles() const; { return fNTouchedFiles; }. Int_t GetNOpenedFiles() const; { return fNOpenedFiles; }. Int_t GetNDisapparedFiles() const; { return fNDisappearedFiles; }. Long64_t GetAvgFileSize() const; { return fAvgFileSize; }. TMap * GetGroupQuotaMap(); { return &fGroupQuota; }. » Author: Jan Fiete Grosse-Oetringhaus, 08.08.07 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-02 15:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TDataSetManager.html:25386,Update,Update,25386,root/html604/TDataSetManager.html,https://root.cern,https://root.cern/root/html604/TDataSetManager.html,1,['Update'],['Update']
Deployability,"xtract the relevant meta-information.; Return 0 if OK, -2 if the file cannot be open, -1 if it is corrupted. Int_t FillMetaData(TFileInfo* fi, TDirectory* d, const char* rdir = ""/""); Navigate the directory 'd' (and its subdirectories) looking for TTree objects.; Fill in the relevant metadata information in 'fi'. The name of the TFileInfoMeta; metadata entry will be ""/dir1/dir2/.../tree_name"".; Return 0 on success, -1 if any problem happens (object found in keys cannot be read,; for example). TList * ParseDataSetSrvMaps(const TString& srvmaps); Create a server mapping list from the content of 'srvmaps'; Return the list (owned by the caller) or 0 if no valid info could be found). TList * GetDataSetSrvMaps(); Static getter for server mapping list. Bool_t CheckDataSetSrvMaps(TUrl* furl, TString& fn, TList* srvmaplist = 0); Check if the dataset server mappings apply to the url defined by 'furl'.; Use srvmaplist if defined, else use the default list.; If yes, resolve the mapping into file1 and return kTRUE.; Otherwise return kFALSE. void SetScanCounters(Int_t t = -1, Int_t o = -1, Int_t d = -1); Update scan counters. TDataSetManager(const TDataSetManager& ). TDataSetManager& operator=(const TDataSetManager& ). TMap * GetGroupUsedMap(); for dataset files (init from DataSet.SrvMap). { return &fGroupUsed; }. TMap * GetUserUsedMap(); { return &fUserUsed; }. Int_t GetNTouchedFiles() const; { return fNTouchedFiles; }. Int_t GetNOpenedFiles() const; { return fNOpenedFiles; }. Int_t GetNDisapparedFiles() const; { return fNDisappearedFiles; }. Long64_t GetAvgFileSize() const; { return fAvgFileSize; }. TMap * GetGroupQuotaMap(); { return &fGroupQuota; }. » Author: Jan Fiete Grosse-Oetringhaus, 08.08.07 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-30 14:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDataSetManager.html:25386,Update,Update,25386,root/html602/TDataSetManager.html,https://root.cern,https://root.cern/root/html602/TDataSetManager.html,1,['Update'],['Update']
Deployability,"xx. Member Data Documentation. ◆ _anaList. RooSetProxy RooRealIntegral::_anaList. protected . Set of observables over which is integrated/summed analytically. ; Definition at line 119 of file RooRealIntegral.h. ◆ _cacheAllNDim. Int_t RooRealIntegral::_cacheAllNDim. staticprotected . ! Cache all integrals with given numeric dimension ; Definition at line 145 of file RooRealIntegral.h. ◆ _cacheNum. bool RooRealIntegral::_cacheNum = false. protected . Cache integral if numeric. ; Definition at line 144 of file RooRealIntegral.h. ◆ _facList. RooSetProxy RooRealIntegral::_facList. protected . Set of observables on which function does not depends, which are integrated nevertheless. ; Definition at line 121 of file RooRealIntegral.h. ◆ _funcNormSet. std::unique_ptr<RooArgSet> RooRealIntegral::_funcNormSet. protected . Optional normalization set passed to function. ; Definition at line 124 of file RooRealIntegral.h. ◆ _function. RooRealProxy RooRealIntegral::_function. protected . Function being integrated. ; Definition at line 123 of file RooRealIntegral.h. ◆ _iconfig. RooNumIntConfig* RooRealIntegral::_iconfig = nullptr. protected . Definition at line 129 of file RooRealIntegral.h. ◆ _intList. RooSetProxy RooRealIntegral::_intList. protected . Set of continuous observables over which is integrated numerically. ; Definition at line 118 of file RooRealIntegral.h. ◆ _intOperMode. IntOperMode RooRealIntegral::_intOperMode = Hybrid. protected . integration operation mode ; Definition at line 134 of file RooRealIntegral.h. ◆ _jacList. RooSetProxy RooRealIntegral::_jacList. protected . Set of lvalue observables over which is analytically integration that have a non-unit Jacobian. ; Definition at line 120 of file RooRealIntegral.h. ◆ _mode. Int_t RooRealIntegral::_mode = 0. protected . Definition at line 133 of file RooRealIntegral.h. ◆ _numIntegrand. std::unique_ptr<RooAbsFunc> RooRealIntegral::_numIntegrand. mutableprotected . ! ; Definition at line 138 of file RooRealIntegral.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:76403,integrat,integrated,76403,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['integrat'],['integrated']
Deployability,"xx. ◆ DoCameraCenterExt(). void TGLViewerEditor::DoCameraCenterExt ; (; ). Set external camera center. ; Definition at line 354 of file TGLViewerEditor.cxx. ◆ DoCameraHome(). void TGLViewerEditor::DoCameraHome ; (; ). CameraHome was clicked. ; Definition at line 302 of file TGLViewerEditor.cxx. ◆ DoCameraOverlay(). void TGLViewerEditor::DoCameraOverlay ; (; ). Update viewer with GUI state. ; Definition at line 334 of file TGLViewerEditor.cxx. ◆ DoCaptureCenter(). void TGLViewerEditor::DoCaptureCenter ; (; ). Capture camera-center via picking. ; Definition at line 369 of file TGLViewerEditor.cxx. ◆ DoClearColor(). void TGLViewerEditor::DoClearColor ; (; Pixel_t ; color). Clear-color was changed. ; Definition at line 267 of file TGLViewerEditor.cxx. ◆ DoDrawCameraCenter(). void TGLViewerEditor::DoDrawCameraCenter ; (; ). Draw camera center. ; Definition at line 378 of file TGLViewerEditor.cxx. ◆ DoIgnoreSizesOnUpdate(). void TGLViewerEditor::DoIgnoreSizesOnUpdate ; (; ). ResetCamerasOnUpdate was toggled. ; Definition at line 276 of file TGLViewerEditor.cxx. ◆ DoResetCamerasOnUpdate(). void TGLViewerEditor::DoResetCamerasOnUpdate ; (; ). ResetCamerasOnUpdate was toggled. ; Definition at line 286 of file TGLViewerEditor.cxx. ◆ DoRotatorStart(). void TGLViewerEditor::DoRotatorStart ; (; ). Start auto-rotator. ; Definition at line 810 of file TGLViewerEditor.cxx. ◆ DoRotatorStop(). void TGLViewerEditor::DoRotatorStop ; (; ). Stop auto-rotator. ; Definition at line 822 of file TGLViewerEditor.cxx. ◆ DoUpdateScene(). void TGLViewerEditor::DoUpdateScene ; (; ). UpdateScene was clicked. ; Definition at line 294 of file TGLViewerEditor.cxx. ◆ IsA(). TClass * TGLViewerEditor::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGCompositeFrame.; Definition at line 164 of file TGLViewerEditor.h. ◆ MakeLabeledNEntry(). TGNumberEntry * TGLViewerEditor::MakeLabeledNEntry ; (; TGCompositeFrame * ; p, . const char * ; name, . Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLViewerEditor.html:40747,toggle,toggled,40747,doc/master/classTGLViewerEditor.html,https://root.cern,https://root.cern/doc/master/classTGLViewerEditor.html,1,['toggle'],['toggled']
Deployability,"xx. ◆ RooNumRunningInt() [2/2]. RooNumRunningInt::RooNumRunningInt ; (; const RooNumRunningInt & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 66 of file RooNumRunningInt.cxx. ◆ ~RooNumRunningInt(). RooNumRunningInt::~RooNumRunningInt ; (; ). override . Destructor. ; Definition at line 79 of file RooNumRunningInt.cxx. Member Function Documentation. ◆ actualObservables(). RooFit::OwningPtr< RooArgSet > RooNumRunningInt::actualObservables ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Return observable in nset to be cached by RooAbsCachedPdf this is always the x observable that is integrated. ; Implements RooAbsCachedReal.; Definition at line 260 of file RooNumRunningInt.cxx. ◆ actualParameters(). RooFit::OwningPtr< RooArgSet > RooNumRunningInt::actualParameters ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Return the parameters of the cache created by RooAbsCachedPdf. ; These are always the input functions parameter, but never the integrated variable x. ; Implements RooAbsCachedReal.; Definition at line 274 of file RooNumRunningInt.cxx. ◆ binningName(). const char * RooNumRunningInt::binningName ; (; ); const. inlineoverrideprotectedvirtual . Reimplemented from RooAbsCachedReal.; Definition at line 47 of file RooNumRunningInt.h. ◆ Class(). static TClass * RooNumRunningInt::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooNumRunningInt::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooNumRunningInt::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 63 of file RooNumRunningInt.h. ◆ clone(). TObject * RooNumRunningInt::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 26 of file RooNumRunningInt.h. ◆ createCache(). RooAbsCachedReal::FuncCacheElem * RooNumRunningInt::createCache ; (; con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumRunningInt.html:64732,integrat,integrated,64732,doc/master/classRooNumRunningInt.html,https://root.cern,https://root.cern/doc/master/classRooNumRunningInt.html,1,['integrat'],['integrated']
Deployability,xx. ◆ setVerbose(). void RooMinimizer::setVerbose ; (; bool ; flag = true). inline . Definition at line 153 of file RooMinimizer.h. ◆ simplex(). int RooMinimizer::simplex ; (; ). Execute SIMPLEX. ; Changes in parameter values and calculated errors are automatically propagated back the RooRealVars representing the floating parameters in the MINUIT operation. ; Definition at line 453 of file RooMinimizer.cxx. ◆ Streamer(). void RooMinimizer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void RooMinimizer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 247 of file RooMinimizer.h. ◆ update(). bool RooMinimizer::update ; (; bool ; isValid). private . Definition at line 1100 of file RooMinimizer.cxx. ◆ updateErrors(). void RooMinimizer::updateErrors ; (; ). private . Definition at line 1129 of file RooMinimizer.cxx. ◆ updateFitConfig(). void RooMinimizer::updateFitConfig ; (; ). private . Definition at line 1013 of file RooMinimizer.cxx. ◆ updateMinimizerOptions(). bool RooMinimizer::updateMinimizerOptions ; (; bool ; canDifferentMinim = true). private . Definition at line 984 of file RooMinimizer.cxx. ◆ zeroEvalCount(). void RooMinimizer::zeroEvalCount ; (; ). Definition at line 817 of file RooMinimizer.cxx. Friends And Related Symbol Documentation. ◆ RooAbsMinimizerFcn. friend class RooAbsMinimizerFcn. friend . Definition at line 197 of file RooMinimizer.h. ◆ RooFit::TestStatistics::LikelihoodGradientJob. friend class RooFit::TestStatistics::LikelihoodGradientJob. friend . Definition at line 199 of file RooMinimizer.h. ◆ RooMinimizerFcn. friend class RooMinimizerFcn. friend . Definition at line 198 of file RooMinimizer.h. Member Data Documentation. ◆ _cfg. RooMinimizer::Config RooMinimizer::_cfg. private . Definition at line 245 of file RooMinimizer.h. ◆ _config. ROOT::Fit::FitConfig RooMinimizer::_config. private . fitter configuration,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMinimizer.html:30417,update,updateFitConfig,30417,doc/master/classRooMinimizer.html,https://root.cern,https://root.cern/doc/master/classRooMinimizer.html,1,['update'],['updateFitConfig']
Deployability,xx;  CoordinateTraits.h;  rotationApplication.cxx;  RotationTraits.h;  stress2D.cxx;  stress3D.cxx;  testBoost.cxx;  testGenVector.cxx;  testIterator.cxx;  testVectorIO.cxx;  Track.h;  TrackLinkDef.h;  vectorOperation.cxx;  ► mathcore;  ► inc;  ► Fit;  BasicFCN.h;  BinData.h;  BinPoint.h;  Chi2FCN.h;  DataOptions.h;  DataRange.h;  DataVector.h;  DataVectorfwd.h;  FcnAdapter.h;  FitConfig.h;  FitResult.h;  Fitter.h;  FitUtil.h;  FitUtilParallel.h;  LogLikelihoodFCN.h;  ParameterSettings.h;  PoissonLikelihoodFCN.h;  SparseData.h;  UnBinData.h;  ► Math;  AdaptiveIntegratorMultiDim.h;  AllIntegrationTypes.h;  BasicMinimizer.h;  BrentMethods.h;  BrentMinimizer1D.h;  BrentRootFinder.h;  ChebyshevPol.h;  Delaunay2D.h;  DistFunc.h;  DistFuncMathCore.h;  DistSampler.h;  DistSamplerOptions.h;  Error.h;  Factory.h;  FitMethodFunction.h;  Functor.h;  GaussIntegrator.h;  GaussLegendreIntegrator.h;  GenAlgoOptions.h;  GoFTest.h;  IFunction.h;  IFunctionfwd.h;  IMinimizer1D.h;  Integrator.h;  IntegratorMultiDim.h;  IntegratorOptions.h;  IOptions.h;  IParamFunction.h;  IParamFunctionfwd.h;  IRootFinderMethod.h;  KDTree.h;  KDTree.icc;  Math.h;  MersenneTwisterEngine.h;  Minimizer.h;  MinimizerOptions.h;  MinimizerVariableTransformation.h;  MinimTransformFunction.h;  MinimTransformVariable.h;  MixMaxEngine.h;  MultiDimParamFunctionAdapter.h;  OneDimFunctionAdapter.h;  ParamFunctor.h;  PdfFunc.h;  PdfFuncMathCore.h;  ProbFunc.h;  ProbFuncMathCore.h;  QuantFunc.h;  QuantFuncMathCore.h;  Random.h;  RandomFunctions.h;  RichardsonDerivator.h;  RootFinder.h;  SpecFunc.h;  SpecFuncMathCore.h;  StdRandomEngines.h;  TDataPoint.h;  TDataPoint.icc;  TDataPointN.h;  TDataPointN.icc;  TRandomEngine.h;  Util.h;  VirtualIntegrator.h;  WrappedFunction.h;  WrappedParamFunction.h;  LinkDef.h;  LinkDef1.h;  LinkDef2.h;  LinkDef3.h;  LinkDef_Func.h;  TComplex.h;  TKDTree.h;  TKDTreeBinning.h;  TMath.h;  TRandom.h;  TRandom1.h;  TRandom2.h;  TRandom3.h;  TStatistic.h;  ► src;  AdaptiveIntegratorMultiDim.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:43667,Integrat,IntegratorMultiDim,43667,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['Integrat'],['IntegratorMultiDim']
Deployability,xx;  testRooFit.cxx;  WrapperRooPdf.h;  binarySearchTime.cxx;  kDTreeTest.cxx;  newKDTreeTest.cxx;  stdsort.cxx;  stressGoFTest.cxx;  stressTF1.cxx;  stressTMath.cxx;  testAnalyticalIntegrals.cxx;  testBinarySearch.cxx;  testDistSampler.cxx;  testIntegration.cxx;  testIntegrationMultiDim.cxx;  testkdTreeBinning.cxx;  testMathRandom.cxx;  testRootFinder.cxx;  testSampleQuantiles.cxx;  testSortOrder.cxx;  testSpecFuncBeta.cxx;  testSpecFuncBetaI.cxx;  testSpecFuncErf.cxx;  testSpecFuncGamma.cxx;  testSpecFuncSiCi.cxx;  testTMath.cxx;  testTStatistic.cxx;  ► v7;  ► inc;  ► ROOT;  TFit.h;  ► mathmore;  ► inc;  ► Math;  ChebyshevApprox.h;  Derivator.h;  DistFuncMathMore.h;  GSLFunctionAdapter.h;  GSLIntegrator.h;  GSLMCIntegrator.h;  GSLMinimizer.h;  GSLMinimizer1D.h;  GSLMultiRootFinder.h;  GSLNLSMinimizer.h;  GSLQuasiRandom.h;  GSLRandom.h;  GSLRandomFunctions.h;  GSLRndmEngines.h;  GSLRootFinder.h;  GSLRootFinderDeriv.h;  GSLRootHelper.h;  GSLSimAnMinimizer.h;  GSLSimAnnealing.h;  IntegrationTypes.h;  InterpolationTypes.h;  Interpolator.h;  KelvinFunctions.h;  LinkDef.h;  LinkDef_Func.h;  LinkDef_RootFinding.h;  MCIntegrationTypes.h;  MCParameters.h;  MultiNumGradFunction.h;  MultiRootFinder.h;  ParamFunction.h;  PdfFuncMathMore.h;  Polynomial.h;  QuantFuncMathMore.h;  QuasiRandom.h;  RootFinderAlgorithms.h;  SpecFuncMathMore.h;  Vavilov.h;  VavilovAccurate.h;  VavilovAccurateCdf.h;  VavilovAccuratePdf.h;  VavilovAccurateQuantile.h;  VavilovFast.h;  ► src;  cblas.cxx;  ChebyshevApprox.cxx;  complex_quartic.h;  Derivator.cxx;  GSL1DMinimizerWrapper.h;  GSLChebSeries.h;  GSLDerivator.cxx;  GSLDerivator.h;  GSLError.h;  GSLFunctionWrapper.h;  GSLIntegrationWorkspace.h;  GSLIntegrator.cxx;  GSLInterpolator.cxx;  GSLInterpolator.h;  GSLMCIntegrationWorkspace.h;  GSLMCIntegrator.cxx;  GSLMinimizer.cxx;  GSLMinimizer1D.cxx;  GSLMonteFunctionAdapter.h;  GSLMonteFunctionWrapper.h;  GSLMultiFit.h;  GSLMultiFitFunctionAdapter.h;  GSLMultiFitFunctionWrapper.h;  GSLMultiMinFunction,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:46943,Integrat,IntegrationTypes,46943,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['Integrat'],['IntegrationTypes']
Deployability,"xy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; std::map< Int_t, AnaIntConfig > _anaIntMap;  ! Map for analytical integration codes ;  ; RooAICRegistry _anaReg;  ! Registry for analytical integration codes ;  ; RooObjCacheManager _cacheMgr;  ; Int_t _ipOrder;  The cache manager. ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:72060,integrat,integration,72060,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,2,['integrat'],['integration']
Deployability,"xy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; std::vector< double > _high;  ; std::vector< double > _low;  ; double _nominal = 0;  ; RooListProxy _paramList;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1LinInterpVar.html:54983,integrat,integration,54983,doc/master/classRooStats_1_1HistFactory_1_1LinInterpVar.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1LinInterpVar.html,1,['integrat'],['integration']
Deployability,"xy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TH2 * _callHist;  ! Histogram recording number of calls per convolution integral calculation ;  ; RooAbsReal * _cloneModel;  Pointer to cloned model. ;  ; RooAbsReal * _clonePdf;  Pointer to cloned PDF. ;  ; RooAbsReal * _cloneVar;  Pointer to cloned convolution variable. ;  ; RooNumIntConfig _convIntConfig;  Configuration of numeric convolution integral ;. ;  ; bool _doProf;  Switch to activate profiling option. ;  ; bool _init;  ; RooConvIntegrandBinding * _integrand;  ! Binding of Convolution Integrand function ;  ; std::unique_ptr< RooAbsIntegrator > _integrator;  ! Numeric integrator of convolution integrand ;  ; RooRealProxy _origModel;  Original resolution model. ;  ; RooRealProxy _origPdf;  Original input PDF. ;  ; RooRealProxy _origVar;  Original convolution variable. ;  ; RooArgSet _ownedClonedModelSet;  Owning set of cloned model components. ;  ; RooArgSet _ownedClonedPdfSet;  Owning set of cloned PDF components. ;  ; bool _useWindow;  Switch to activate window convolution. ;  ; Int_t _verboseThresh;  Call count threshold for verbose printing. ;  ; RooListProxy _windowParam;  Holder for optional convolution integration window scaling parameter. ;  ; double _windowScale;  Scale factor for window parameter. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvolution.html:58588,integrat,integrator,58588,doc/master/classRooNumConvolution.html,https://root.cern,https://root.cern/doc/master/classRooNumConvolution.html,1,['integrat'],['integrator']
Deployability,"xy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooCategoryProxy _state;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsHiddenReal.html:55817,integrat,integration,55817,doc/master/classRooAbsHiddenReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsHiddenReal.html,1,['integrat'],['integration']
Deployability,"xy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooRealProxy mean;  ; RooRealProxy sigma;  ; RooRealProxy width;  ; RooRealProxy x;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVoigtian.html:68859,configurat,configuration,68859,doc/master/classRooVoigtian.html,https://root.cern,https://root.cern/doc/master/classRooVoigtian.html,1,['configurat'],['configuration']
Deployability,"xy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooCFunction4Ref< VO, VI1, VI2, VI3, VI4 > func;  ; RooRealProxy w;  ; RooRealProxy x;  ; RooRealProxy y;  ; RooRealProxy z;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCFunction4Binding.html:55480,integrat,integration,55480,doc/master/classRooCFunction4Binding.html,https://root.cern,https://root.cern/doc/master/classRooCFunction4Binding.html,1,['integrat'],['integration']
Deployability,"xy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooSetProxy _cacheObs;  Variables to be cached. ;  ; bool _cacheSource;  Keep an attached clone of the source in the cache for fast operation. ;  ; bool _useCdfBoundaries;  Are c.d.f boundary conditions used by the RooHistFuncs? ;  ; RooRealProxy func;  Proxy to function being cached. ;  ;  Protected Attributes inherited from RooAbsCachedReal; std::map< Int_t, std::pair< const RooArgSet *, const RooArgSet * > > _anaIntMap;  ! Map for analytical integration codes ;  ; RooObjCacheManager _cacheMgr;  ! The cache manager ;  ; Int_t _ipOrder;  Interpolation order for cache histograms. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:58048,integrat,integration,58048,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,1,['integrat'],['integration']
Deployability,"xyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); Construct running integral of function '_func' over x_print from; the lower bound on _x to the present value of _x using a numeric; sampling technique. The sampling frequency is controlled by the; binning named 'bname' and a default second order interpolation; is applied to smooth the histogram-based c.d.f. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); Copy constructor. ~RooNumRunningInt(); Destructor. const char* inputBaseName() const; Return unique name for RooAbsCachedPdf cache components; constructed from input function name. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill the cache object by calling its calculate() method. RooArgSet* actualObservables(const RooArgSet& nset) const; Return observable in nset to be cached by RooAbsCachedPdf; this is always the x observable that is integrated. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters of the cache created by RooAbsCachedPdf.; These are always the input functions parameter, but never the; integrated variable x. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Create custom cache element for running integral calculations. Double_t evaluate() const; Dummy function that is never called. TObject* clone(const char* newname) const; { return new RooNumRunningInt(*this,newname); }. const char* binningName() const; { return _binningName.c_str() ; }. const char* payloadUniqueSuffix() const; { return func.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Thu Sep 23 20:00:25 2010 » Last generated: 2010-09-23 20:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumRunningInt.html:35332,integrat,integrated,35332,root/html528/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html528/RooNumRunningInt.html,2,['integrat'],['integrated']
Deployability,"xyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); Construct running integral of function '_func' over x_print from; the lower bound on _x to the present value of _x using a numeric; sampling technique. The sampling frequency is controlled by the; binning named 'bname' and a default second order interpolation; is applied to smooth the histogram-based c.d.f. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); Copy constructor. ~RooNumRunningInt(); Destructor. const char* inputBaseName() const; Return unique name for RooAbsCachedPdf cache components; constructed from input function name. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill the cache object by calling its calculate() method. RooArgSet* actualObservables(const RooArgSet& nset) const; Return observable in nset to be cached by RooAbsCachedPdf; this is always the x observable that is integrated. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters of the cache created by RooAbsCachedPdf.; These are always the input functions parameter, but never the; integrated variable x. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Create custom cache element for running integral calculations. Double_t evaluate() const; Dummy function that is never called. TObject* clone(const char* newname) const; { return new RooNumRunningInt(*this,newname); }. const char* binningName() const; { return _binningName.c_str() ; }. const char* payloadUniqueSuffix() const; { return func.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Tue Jun 30 14:34:41 2015 » Last generated: 2015-06-30 14:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumRunningInt.html:39963,integrat,integrated,39963,root/html602/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html602/RooNumRunningInt.html,4,['integrat'],['integrated']
Deployability,"xyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); Construct running integral of function '_func' over x_print from; the lower bound on _x to the present value of _x using a numeric; sampling technique. The sampling frequency is controlled by the; binning named 'bname' and a default second order interpolation; is applied to smooth the histogram-based c.d.f. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); Copy constructor. ~RooNumRunningInt(); Destructor. const char* inputBaseName() const; Return unique name for RooAbsCachedPdf cache components; constructed from input function name. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill the cache object by calling its calculate() method. RooArgSet* actualObservables(const RooArgSet& nset) const; Return observable in nset to be cached by RooAbsCachedPdf; this is always the x observable that is integrated. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters of the cache created by RooAbsCachedPdf.; These are always the input functions parameter, but never the; integrated variable x. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Create custom cache element for running integral calculations. Double_t evaluate() const; Dummy function that is never called. TObject* clone(const char* newname) const; { return new RooNumRunningInt(*this,newname); }. const char* binningName() const; { return _binningName.c_str() ; }. const char* payloadUniqueSuffix() const; { return func.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Tue Mar 10 17:18:18 2015 » Last generated: 2015-03-10 17:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumRunningInt.html:38459,integrat,integrated,38459,root/html534/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html534/RooNumRunningInt.html,4,['integrat'],['integrated']
Deployability,"y &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooListProxy _set1;  Set of input fractions. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFracRemainder.html:54895,integrat,integration,54895,doc/master/classRooFracRemainder.html,https://root.cern,https://root.cern/doc/master/classRooFracRemainder.html,1,['integrat'],['integration']
Deployability,"y &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooRealProxy _if;  Int(F(x))dx ;. ;  ; RooRealProxy _ixf;  Int((X-offset)*F(X))dx ;. ;  ; RooRealProxy _xf;  (X-offset)*F ;  ; double _xfOffset;  offset ;  ;  Protected Attributes inherited from RooAbsMoment; RooRealProxy _func;  Input function. ;  ; RooRealProxy _mean;  Mean (if calculated for central moment) ;  ; RooSetProxy _nset;  Normalization set (optional) ;  ; Int_t _order = 1;  Moment order. ;  ; Int_t _takeRoot = false;  Return n-order root of moment. ;  ; RooRealProxy _x;  Observable. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSecondMoment.html:55936,integrat,integration,55936,doc/master/classRooSecondMoment.html,https://root.cern,https://root.cern/doc/master/classRooSecondMoment.html,1,['integrat'],['integration']
Deployability,"y &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static Int_t GetNumBins (const RooArgSet &vars);  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  . Protected Attributes; RooDataHist _dataSet;  ; RooListProxy _dataVars;  The RooRealVars. ;  ; RooObjCacheManager _normIntMgr;  ! The integration cache manager ;  ; Int_t _numBins = 0;  ; NumBins _numBinsPerDim;  ; RooListProxy _paramSet;  interpolation parameters ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classParamHistFunc.html:57820,integrat,integration,57820,doc/master/classParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html,2,['integrat'],['integration']
Deployability,"y Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooParamHistFunc() [1/3]. RooParamHistFunc::RooParamHistFunc ; (; ). inline . Definition at line 26 of file RooParamHistFunc.h. ◆ RooParamHistFunc() [2/3]. RooParamHistFunc::RooParamHistFunc ; (; const char * ; name, . const char * ; title, . RooDataHist & ; dh, . const RooAbsArg & ; x, . const RooParamHistFunc * ; paramSource = nullptr, . bool ; paramRelative = true . ). Definition at line 32 of file RooParamHistFunc.cxx. ◆ RooParamHistFunc() [3/3]. RooParamHistFunc::RooParamHistFunc ; (; const RooParamHistFunc & ; other, . const char * ; name = nullptr . ). Definition at line 62 of file RooParamHistFunc.cxx. Member Function Documentation. ◆ analyticalIntegralWN(). double RooParamHistFunc::analyticalIntegralWN ; (; Int_t ; code, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Implement analytical integrations by doing appropriate weighting from component integrals functions to integrators of components. ; Reimplemented from RooAbsReal.; Definition at line 212 of file RooParamHistFunc.cxx. ◆ binBoundaries(). std::list< double > * RooParamHistFunc::binBoundaries ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ; Reimplemented from RooAbsReal.; Definition at line 167 of file RooParamHistFunc.cxx. ◆ Class(). static TClass * RooParamHistFunc::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooParamHistFunc::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooParamHistFunc::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 63 of f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooParamHistFunc.html:61632,integrat,integrations,61632,doc/master/classRooParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooParamHistFunc.html,2,['integrat'],"['integrations', 'integrators']"
Deployability,"y PDF parameter error by ordinal index (needed by MINUIT). void ClearPdfParamAsymErr(Int_t index); Modify PDF parameter error by ordinal index (needed by MINUIT). void SetPdfParamErr(Int_t index, Double_t loVal, Double_t hiVal); Modify PDF parameter error by ordinal index (needed by MINUIT). void BackProp(const ROOT::Fit::FitResult& results); Transfer MINUIT fit results back into RooFit objects. Bool_t SetLogFile(const char* inLogfile); Change the file name for logging of a RooMinimizer of all MINUIT steppings; through the parameter space. If inLogfile is null, the current log file; is closed and logging is stopped. void ApplyCovarianceMatrix(TMatrixDSym& V); Apply results of given external covariance matrix. i.e. propagate its errors; to all RRV parameter representations and give this matrix instead of the; HESSE matrix at the next save() call. Bool_t SetPdfParamVal(const Int_t& index, const Double_t& value) const; RooRealVar* par = (RooRealVar*)_floatParamList->at(index);. void updateFloatVec(). double DoEval(const double* x) const. unsigned int NDim() const; { return _nDim; }. RooArgList* GetFloatParamList(); { return _floatParamList; }. RooArgList* GetConstParamList(); { return _constParamList; }. RooArgList* GetInitFloatParamList(); { return _initFloatParamList; }. RooArgList* GetInitConstParamList(); { return _initConstParamList; }. void SetEvalErrorWall(Bool_t flag); { _doEvalErrorWall = flag ; }. void SetPrintEvalErrors(Int_t numEvalErrors); { _printEvalErrors = numEvalErrors ; }. std::ofstream* GetLogFile(); { return _logfile; }. void SetVerbose(Bool_t flag = kTRUE); { _verbose = flag ; }. Double_t& GetMaxFCN(); { return _maxFCN; }. Int_t GetNumInvalidNLL(); { return _numBadNLL; }. Int_t evalCounter() const; { return _evalCounter ; }. void zeroEvalCount(); { _evalCounter = 0 ; }. » Last changed: Tue Jun 30 14:34:00 2015 » Last generated: 2015-06-30 14:34; This page has been automatically generated. For comments or suggestions regarding the documentation or R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMinimizerFcn.html:4114,update,updateFloatVec,4114,root/html602/RooMinimizerFcn.html,https://root.cern,https://root.cern/root/html602/RooMinimizerFcn.html,2,['update'],['updateFloatVec']
Deployability,"y PDF parameter error by ordinal index (needed by MINUIT). void ClearPdfParamAsymErr(Int_t index); Modify PDF parameter error by ordinal index (needed by MINUIT). void SetPdfParamErr(Int_t index, Double_t loVal, Double_t hiVal); Modify PDF parameter error by ordinal index (needed by MINUIT). void BackProp(const ROOT::Fit::FitResult& results); Transfer MINUIT fit results back into RooFit objects. Bool_t SetLogFile(const char* inLogfile); Change the file name for logging of a RooMinimizer of all MINUIT steppings; through the parameter space. If inLogfile is null, the current log file; is closed and logging is stopped. void ApplyCovarianceMatrix(TMatrixDSym& V); Apply results of given external covariance matrix. i.e. propagate its errors; to all RRV parameter representations and give this matrix instead of the; HESSE matrix at the next save() call. Bool_t SetPdfParamVal(const Int_t& index, const Double_t& value) const; RooRealVar* par = (RooRealVar*)_floatParamList->at(index);. void updateFloatVec(). double DoEval(const double* x) const. unsigned int NDim() const; { return _nDim; }. RooArgList* GetFloatParamList(); { return _floatParamList; }. RooArgList* GetConstParamList(); { return _constParamList; }. RooArgList* GetInitFloatParamList(); { return _initFloatParamList; }. RooArgList* GetInitConstParamList(); { return _initConstParamList; }. void SetEvalErrorWall(Bool_t flag); { _doEvalErrorWall = flag ; }. void SetPrintEvalErrors(Int_t numEvalErrors); { _printEvalErrors = numEvalErrors ; }. std::ofstream* GetLogFile(); { return _logfile; }. void SetVerbose(Bool_t flag = kTRUE); { _verbose = flag ; }. Double_t& GetMaxFCN(); { return _maxFCN; }. Int_t GetNumInvalidNLL(); { return _numBadNLL; }. Int_t evalCounter() const; { return _evalCounter ; }. void zeroEvalCount(); { _evalCounter = 0 ; }. » Last changed: Tue Sep 8 17:42:18 2015 » Last generated: 2015-09-08 17:42; This page has been automatically generated. For comments or suggestions regarding the documentation or RO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooMinimizerFcn.html:4114,update,updateFloatVec,4114,root/html604/RooMinimizerFcn.html,https://root.cern,https://root.cern/root/html604/RooMinimizerFcn.html,2,['update'],['updateFloatVec']
Deployability,"y and TUnfoldBinning ;  testUnfold5c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5d.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold6.C Test program for the class TUnfoldBinning ;  testUnfold7a.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7b.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  ► unuran;  unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  box.cxxThis ROOT 7 example demonstrates how to create a ROOT 7 canvas (RCanvas) and draw ROOT 7 boxes in it (RBox) ;  concurrentfill.cxx;  draw.cxx;  draw_mt.cxxThis macro demonstrate usage of ROOT7 graphics from many threads Three different canvases in three different threads are started and regularly updated ;  draw_rh1.cxxThis macro generates a small V7 TH1D, fills it and draw it in a V7 canvas ;  draw_subpads.cxx;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  line.cxxThis ROOT 7 example demonstrates how to create a ROOT 7 canvas (RCanvas) and draw ROOT 7 lines in it (RLine) ;  lineStyle.cxx;  lineWidth.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  vo004",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:171637,update,updated,171637,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['update'],['updated']
Deployability,"y copy is deleted and the object is again read from the file. If opt==""dirs"", only subdirectories will be read If opt==""dirs*"" complete directory tree will be read ; Reimplemented from TDirectory.; Definition at line 1326 of file TDirectoryFile.cxx. ◆ ReadKeys(). Int_t TDirectoryFile::ReadKeys ; (; Bool_t ; forceRead = kTRUE). overridevirtual . Read the linked list of keys. ; Every directory has a linked list (fKeys). This linked list has been written on the file via WriteKeys as a single data record.; It is interesting to call this function in the following situation. Assume another process1 is connecting this directory in Update mode; Process1 is adding/updating objects in this directory; You want to see the latest status from process1. Example Process1: obj1.Write();; obj2.Write();; gDirectory->SaveSelf();; gDirectory#define gDirectoryDefinition TDirectory.h:384. Example Process2: gDirectory->ReadKeys();; obj1->Draw();; This is an efficient way (without opening/closing files) to view the latest updates of a file being modified by another process as it is typically the case in a data acquisition system. ; Reimplemented from TDirectory.; Definition at line 1379 of file TDirectoryFile.cxx. ◆ ReadTObject(). Int_t TDirectoryFile::ReadTObject ; (; TObject * ; obj, . const char * ; keyname . ). overridevirtual . Read object with keyname from the current directory. ; Read contents of object with specified name from the current directory. First the key with keyname is searched in the current directory, next the key buffer is deserialized into the object. The object must have been created before via the default constructor. See TObject::Write(). ; Reimplemented from TDirectory.; Definition at line 1465 of file TDirectoryFile.cxx. ◆ ResetAfterMerge(). void TDirectoryFile::ResetAfterMerge ; (; TFileMergeInfo * ; info). virtual . Reset the TDirectory after its content has been merged into another Directory. ; This returns the TDirectoryFile object back to its state before any",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDirectoryFile.html:44220,update,updates,44220,doc/master/classTDirectoryFile.html,https://root.cern,https://root.cern/doc/master/classTDirectoryFile.html,1,['update'],['updates']
Deployability,"y dir locker; TPMERegexp*fReInvalidRegular expression matching invalid dataset URIs; TStringfSandboxPROOF sandbox root dir; TStringfSelectionInternal variable to pass drawing options; TServerSocket*fServSockServer socket to accept call backs; TStringfSockPathUNIX socket path for communication with workers; TStringfVarExpInternal variable to pass drawing options; static Int_tfgWrksMaxMax number of workers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofLite(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Create a PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). Masterurl is of; the form: [proof[s]://]host[:port]. Conffile is the name of the config; file describing the remote PROOF cluster (this argument alows you to; describe different cluster configurations).; The default is proof.conf. Confdir is the directory where the config; file and other PROOF related files are (like motd and noproof files).; Loglevel is the log level (default = 1). User specified custom config; files will be first looked for in $HOME/.conffile. Int_t Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); Start the PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). For a description; of the arguments see the TProof ctor. Returns the number of started; master or slave servers, returns 0 in case of error, in which case; fValid remains false. ~TProofLite(); Destructor. Int_t GetNumberOfWorkers(const char* url = 0); Static method to determine the number of workers giving priority to users request.; Otherwise",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:28371,configurat,configurations,28371,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,6,['configurat'],['configurations']
Deployability,"y from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooRealProxy c;  ; RooRealProxy m;  ; RooRealProxy m0;  ; RooRealProxy p;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooArgusBG.html:68289,configurat,configuration,68289,doc/master/classRooArgusBG.html,https://root.cern,https://root.cern/doc/master/classRooArgusBG.html,1,['configurat'],['configuration']
Deployability,"y list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; bool _cdfBoundaries = false;  Use boundary conditions for CDFs. ;  ; RooAICRegistry _codeReg;  ! Auxiliary class keeping tracking of analytical integration code ;  ; RooDataHist * _dataHist = nullptr;  Unowned pointer to underlying histogram. ;  ; RooArgSet _histObsList;  List of observables defining dimensions of histogram. ;  ; Int_t _intOrder = 0;  Interpolation order. ;  ; std::unique_ptr< RooDataHist > _ownedDataHist;  ! Owned pointer to underlying histogram ;  ; RooSetProxy _pdfObsList;  List of observables mapped onto histogram observables. ;  ; double _totVolume = 0.0;  ! Total volume of space (product of ranges of observables) ;  ; bool _unitNorm = false;  Assume contents is unit normalized (for use as pdf cache) ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistPdf.html:68897,integrat,integration,68897,doc/master/classRooHistPdf.html,https://root.cern,https://root.cern/doc/master/classRooHistPdf.html,1,['integrat'],['integration']
Deployability,"y list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; bool _cdfBoundaries = false;  Use boundary conditions for CDFs. ;  ; RooAICRegistry _codeReg;  ! Auxiliary class keeping tracking of analytical integration code ;  ; RooDataHist * _dataHist = nullptr;  Unowned pointer to underlying histogram. ;  ; RooSetProxy _depList;  List of observables mapped onto histogram observables. ;  ; RooArgSet _histObsList;  List of observables defining dimensions of histogram. ;  ; Int_t _intOrder = 0;  Interpolation order. ;  ; std::unique_ptr< RooDataHist > _ownedDataHist;  ! Owned pointer to underlying histogram ;  ; double _totVolume = 0.0;  ! Total volume of space (product of ranges of observables) ;  ; bool _unitNorm = false;  ! Assume contents is unit normalized (for use as pdf cache) ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:56679,integrat,integration,56679,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,1,['integrat'],['integration']
Deployability,"y list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooListProxy _coefList;  ; TArrayD _limits;  ; Int_t _nBins = 0;  ; RooRealProxy _x;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooParametricStepFunction.html:71965,configurat,configuration,71965,doc/master/classRooParametricStepFunction.html,https://root.cern,https://root.cern/doc/master/classRooParametricStepFunction.html,1,['configurat'],['configuration']
Deployability,"y of ROOT’s python modules; the developer build option asserts is introduced to enable/disable asserts via the NDEBUG C/CXX flag. Asserts are always enabled for CMAKE_BUILD_TYPE=Debug and dev=ON. The previous behavior of the builds set via the CMAKE_BUILD_TYPE variable has not changed.; CMAKE_CXX_STANDARD, i.e. the C++ standard ROOT is built with, now defaults to the compiler default (or C++11 if the compiler default is older than that) rather than always defaulting to C++11. In turn this means that v6.24 is the first ROOT release for which ROOT’s pre-compiled binaries are not compiled with C++11 but with the default standard in use by the default system compiler. On Ubuntu 20.04, for example, the v6.24 pre-compiled binaries are now compiled with C++14 rather than C++11 as it happened for previous ROOT versions. Also see ROOT-10692. The following builtins have been updated:. VecCore 0.7.0; LZ4 1.9.3; openui5; Xrootd 4.12.8; Zstd 1.4.8. PyROOT. Deprecate TTree.AsMatrix in this release and mark for removal in v6.26. Please use instead RDataFrame.AsNumpy. Bugs and Issues fixed in this release. [ROOT-9790] - [DF] Lazy jitting of Cache and Snapshot; [ROOT-3579] - RooTreeDataStore not Cloning the tree properly (and const correctness); [ROOT-3635] - integration for PDF value in binned fit; [ROOT-3874] - problem with binned likelihood fit in RooFit; [ROOT-5334] - RooFit RooAbsPdf::getLogVal() returns log((double)0) (==inf !). [ROOT-5380] - 2D fit not converging when using RooProdPDF and RooFFTConvPdf; [ROOT-5464] - GetEntries reports warning when friend chain with index; [ROOT-6505] - ROOT fails to read a file with particular branch names interactively; [ROOT-6892] - Memory leak in TSocket::SendProcessIDs; [ROOT-7182] - gSystem->cd has negative effect on TFile with relative path; [ROOT-7199] - Clang error dumping Expr originated by a typo at the prompt; [ROOT-7506] - Problem with axis in TMVAMultiClassGui when showing “Classifier Output Distributions”; [ROOT-7507] - Setting",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:30455,release,release,30455,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['release'],['release']
Deployability,"y of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(Option_t* option = """") const; Dump this function with its attributes. void ReleaseParameter(Int_t ipar); Release parameter number ipar If used in a fit, the parameter; can vary freely. The parameter limits are reset to 0,0. void Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); Save values of function in array fSave. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetCurrent(TF1* f1); Static function setting the current function.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:58925,integrat,integration,58925,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,6,['integrat'],['integration']
Deployability,"y only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. double Result() const; return result of last integration. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const; return integration error. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const; return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. void SetRelTolerance(double relTol); return number of function evaluations in calculating the integral; unsigned int NEval() const { return fNEval; }; set the relative tolerance. { if (fIntegrator) fIntegrator->SetRelTolerance(relTol); }. void SetAbsTolerance(double absTol); set absolute tolerance. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTol); }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. VirtualIntegratorMultiDim * GetIntegrator(); return a pointer to integrator object. { return fIntegrator; }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationMultiDim::Type GetType(const char* name); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorMultiDim.html:5145,integrat,integration,5145,root/html528/ROOT__Math__IntegratorMultiDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorMultiDim.html,10,['integrat'],['integration']
Deployability,"y owned proxies upon creation. After registration, this arg will forward pointer changes from serverRedirects and updates in cached normalization sets to the proxies immediately after they occur. The proxied argument is also added as value and/or shape server ; Definition at line 1329 of file RooAbsArg.cxx. ◆ registerProxy() [2/3]. void RooAbsArg::registerProxy ; (; RooListProxy & ; proxy). protected . Register an RooListProxy in the proxy list. ; This function is called by owned proxies upon creation. After registration, this arg will forward pointer changes from serverRedirects and updates in cached normalization sets to the proxies immediately after they occur. ; Definition at line 1408 of file RooAbsArg.cxx. ◆ registerProxy() [3/3]. void RooAbsArg::registerProxy ; (; RooSetProxy & ; proxy). protected . Register an RooSetProxy in the proxy list. ; This function is called by owned proxies upon creation. After registration, this arg will forward pointer changes from serverRedirects and updates in cached normalization sets to the proxies immediately after they occur. ; Definition at line 1373 of file RooAbsArg.cxx. ◆ removeServer(). void RooAbsArg::removeServer ; (; RooAbsArg & ; server, . bool ; force = false . ). Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ; Definition at line 378 of file RooAbsArg.cxx. ◆ removeStringAttribute(). void RooAbsArg::removeStringAttribute ; (; const Text_t * ; key). Delete a string attribute with a given key. ; Definition at line 266 of file RooAbsArg.cxx. ◆ replaceServer(). void RooAbsArg::replaceServer ; (; RooAbsArg & ; oldServer, . RooAbsArg & ; newServer, . bool ; propValue, . bool ; propShape . ). Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ; WarningThis function should not be used! This method is quite unsafe for many reasons. For once, the new server will be put at the end of the server list, no matt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:93505,update,updates,93505,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['update'],['updates']
Deployability,"y pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool; TNamed*RooAbsCollection::_structureTag! Structure tag; TNamed*RooAbsCollection::_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooArgSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void* operator new(size_t bytes, void* ptr); Overloaded new operator with placement does not guarante that all; RooArgSets allocated with new have a unique address, but uses the global; operator. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooArgSet(); Default constructor. RooArgSet(const RooArgList& list); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const RooArgList& list, const RooAbsArg* var1); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const char* name); Empty set constructor. RooArgSet(const RooArgSet& set1, const RooArgSet& set2, const char* name = """"); Construct a set from two existing sets. RooArgSet(const RooAbsArg& var1, const char* name = """"); Constructor for set containing 1 initial object. RooArgSet(const RooAbsArg& var1, const RooAbsArg& var2, const char* name = """"); Constructor for set containing 2 initial objects. RooArgSet(const RooAbsArg& var1, const RooAbsArg& var2, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooArgSet.html:16250,release,release,16250,root/html602/RooArgSet.html,https://root.cern,https://root.cern/root/html602/RooArgSet.html,4,['release'],['release']
Deployability,"y stored.; 2739 // and if the AddDirectoryStatus() is false it will not be added to; 2740 // any directory (fDirectory = nullptr); 2741 if (fgAddDirectory && gDirectory) {; 2742 gDirectory->Append(&obj);; 2743 ((TH1&)obj).fFunctions->UseRWLock();; 2744 ((TH1&)obj).fDirectory = gDirectory;; 2745 } else; 2746 ((TH1&)obj).fDirectory = nullptr;; 2747 ; 2748}; 2749 ; 2750////////////////////////////////////////////////////////////////////////////////; 2751/// Make a complete copy of the underlying object. If 'newname' is set,; 2752/// the copy's name will be set to that name.; 2753 ; 2754TObject* TH1::Clone(const char* newname) const; 2755{; 2756 TH1* obj = (TH1*)IsA()->GetNew()(nullptr);; 2757 Copy(*obj);; 2758 ; 2759 // Now handle the parts that Copy doesn't do; 2760 if(fFunctions) {; 2761 // The Copy above might have published 'obj' to the ListOfCleanups.; 2762 // Clone can call RecursiveRemove, for example via TCheckHashRecursiveRemoveConsistency; 2763 // when dictionary information is initialized, so we need to; 2764 // keep obj->fFunction valid during its execution and; 2765 // protect the update with the write lock.; 2766 ; 2767 // Reset stats parent - else cloning the stats will clone this histogram, too.; 2768 auto oldstats = dynamic_cast<TVirtualPaveStats*>(fFunctions->FindObject(""stats""));; 2769 TObject *oldparent = nullptr;; 2770 if (oldstats) {; 2771 oldparent = oldstats->GetParent();; 2772 oldstats->SetParent(nullptr);; 2773 }; 2774 ; 2775 auto newlist = (TList*)fFunctions->Clone();; 2776 ; 2777 if (oldstats); 2778 oldstats->SetParent(oldparent);; 2779 auto newstats = dynamic_cast<TVirtualPaveStats*>(obj->fFunctions->FindObject(""stats""));; 2780 if (newstats); 2781 newstats->SetParent(obj);; 2782 ; 2783 auto oldlist = obj->fFunctions;; 2784 {; 2785 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2786 obj->fFunctions = newlist;; 2787 }; 2788 delete oldlist;; 2789 }; 2790 if(newname && strlen(newname) ) {; 2791 obj->SetName(newname);; 2792 }; 2793 return obj;; 2794}; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:110256,update,update,110256,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['update'],['update']
Deployability,"y text string; Bool_tTGTextLBEntry::fTextChangedtrue if text has been changed; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGTextLBEntry::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGTextLBEntry::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DoRedraw(); { }. void Update(TGLBEntry* e); { }. TGTextLBEntry & operator=(const TGIconLBEntry& ). TGDimension GetDefaultSize() const; { return TGDimension(fTWidth, fTHeight+1); }. void DrawCopy(Handle_t id, Int_t x, Int_t y). TGIconLBEntry(const TGIconLBEntry& ). TGIconLBEntry(const TGWindow* p = 0, Int_t id = -1, const char* str = 0, const TGPicture* pic = 0, UInt_t w = 0, Style_t s = 0, UInt_t options = kHorizontalFrame, Pixel_t back = GetWhitePixel()). const TGPicture * GetPicture() const; { return fPicture; }. void SetPicture(const TGPicture* pic = 0). » Author: Fons Rademakers 12/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGIconLBEntry.html:18653,Update,Update,18653,root/html534/TGIconLBEntry.html,https://root.cern,https://root.cern/root/html534/TGIconLBEntry.html,1,['Update'],['Update']
Deployability,"y this object. ;  ; virtual void SetVsbPosition (Long_t newPos);  Set position of vertical scrollbar. ;  ; virtual void ShowBottom ();  Show bottom of the page. ;  ; virtual void ShowTop ();  Show top of the page. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual Long_t ToObjXCoord (Long_t xCoord, Long_t line);  Convert x screen coordinate to column in specified line. ;  ; virtual Long_t ToObjYCoord (Long_t yCoord);  Convert y screen coordinate to line number. ;  ; virtual Long_t ToScrXCoord (Long_t xCoord, Long_t line);  Convert column number in specified line to screen coordinate. ;  ; virtual Long_t ToScrYCoord (Long_t yCoord);  Convert line number to screen coordinate. ;  ; virtual void Update ();  update the whole window of text view ;  ;  Public Member Functions inherited from TGView;  TGView (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, Int_t id=-1, UInt_t xMargin=0, UInt_t yMargin=0, UInt_t options=kSunkenFrame|kDoubleBorder, UInt_t sboptions=0, Pixel_t back=GetWhitePixel());  Create an editor view, containing an TGEditorFrame and (optionally) a horizontal and vertical scrollbar. ;  ;  ~TGView () override;  Delete view. ;  ; void ChangeBackground (Pixel_t) override;  Change background color of the canvas frame. ;  ; void Clear (Option_t *="""") override;  Clear view. ;  ; void DrawBorder () override;  Draw the border of the text edit widget. ;  ; TGViewFrame * GetCanvas () const;  ; TGDimension GetDefaultSize () const override;  std::cout << fWidth << ""x"" << fHeight << std::endl; ;  ; TGLongPosition GetScrollPosition () const;  ; TGLongPosition GetScrollValue () const;  ; const TGGC & GetViewWhiteGC ();  ; TGDimension GetVirtualSize () const;  ; Bool_t HandleButton (Event_t *event) override;  handle button ;  ; Bool_t HandleExpose (Event_t *event) override;  Handle expose events. ;  ; TClass * IsA () const override;  ; void Layout () override;  layout ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEdit.html:11384,update,update,11384,doc/master/classTGTextEdit.html,https://root.cern,https://root.cern/doc/master/classTGTextEdit.html,2,['update'],['update']
Deployability,"y to instantiate numeric integrators from a given function binding and a given configuration ;  CRooNumIntConfigRooNumIntConfig holds the configuration parameters of the various numeric integrators used by RooRealIntegral ;  CRooNumIntFactoryRooNumIntFactory is a factory to instantiate numeric integrators from a given function binding and a given configuration ;  ►CRooNumRunningIntClass RooNumRunningInt is an implementation of RooAbsCachedReal that represents a running integral ; \[ RI(f(x)) = \int_{xlow}^{x} f(x') dx' \]. that is calculated internally with a numeric technique: The input function is first sampled into a histogram, which is then numerically integrated ;  CRICacheElem;  CRooObjCacheManagerClass RooObjCacheManager is an implementation of class RooCacheManager<RooAbsCacheElement> and specializes in the storage of cache elements that contain RooAbsArg objects ;  CRooParamBinningClass RooParamBinning is an implementation of RooAbsBinning that constructs a binning with a range definition that depends on external RooAbsReal objects ;  CRooParametricStepFunction;  CRooParamHistFunc;  ►CRooPlotA RooPlot is a plot frame and a container for graphics objects within that frame ;  CDrawOpt;  CRooPlotableClass RooPotable is a base class for objects that can be inserted into RooPlots and take advantage of its internal normalization and axis range adjustment features ;  CRooPoissonPoisson pdf ;  CRooPolynomialRooPolynomial implements a polynomial p.d.f of the form ; \[ f(x) = \sum_{i} a_{i} * x^i \]. By default coefficient a_0 is chosen to be 1, as polynomial probability density functions have one degree of freedome less than polynomial functions due to the normalization condition ;  CRooPolyVarClass RooPolyVar is a RooAbsReal implementing a polynomial in terms of a list of RooAbsReal coefficients ; \[f(x) = \sum_{i} a_{i}x \]. Class RooPolyvar implements analytical integrals of all polynomials it can define ;  CRooPrintableRooPlotable is a 'mix-in' base class that d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:98793,integrat,integrated,98793,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['integrat'],['integrated']
Deployability,"y with FCN only fits, when fFitFunc=0); vector<double>fParamsparameter values. Size is total number of parameters; intfStatusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const ROOT::Fit::FitResult& ). Copy constructor. ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const; True if fit successful, otherwise false. { return fValid; }. bool IsEmpty() const; True if a fit result does not exist (even invalid) with parameter values. { return (fParams.size() == 0); }. double MinFcnValue() const; Return value of the objective function (chi2 or likelihood) used in the fit. { return fVal; }. unsigned int NCalls() const; Number of function calls to find minimum. { return fNCalls; }. double Edm() const; Expected distance from minimum. { return fEdm; }. unsigned int NTotalParameters() const; get total number of parameters. { return fParams.size(); }. unsigned int NPar() const; total number of parameters (abbreviation). { return NTotalParameters(); }. unsigned int NFreeParameters() const; get total",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__FitResult.html:5335,configurat,configuration,5335,root/html528/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__FitResult.html,1,['configurat'],['configuration']
Deployability,"y(y); model = ROOT.RooProdPdf(""model"", ""gaussx(x|y)*gaussy(y)"", {gaussy}, Conditional=({gaussx}, {x})); ; # Sample, fit and plot product pdf; # ---------------------------------------------------------------; ; # Generate 1000 events in x and y from model; data = model.generate({x, y}, 10000); ; # Plot x distribution of data and projection of model x = Int(dy); # model(x,y); xframe = x.frame(); data.plotOn(xframe); model.plotOn(xframe); ; # Plot x distribution of data and projection of model y = Int(dx); # model(x,y); yframe = y.frame(); data.plotOn(yframe); model.plotOn(yframe); ; # Make two-dimensional plot in x vs y; hh_model = model.createHistogram(""hh_model"", x, ROOT.RooFit.Binning(50), ROOT.RooFit.YVar(y, ROOT.RooFit.Binning(50))); hh_model.SetLineColor(ROOT.kBlue); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf305_condcorrprod"", ""rf05_condcorrprod"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.6); xframe.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); yframe.GetYaxis().SetTitleOffset(1.6); yframe.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.20); hh_model.GetZaxis().SetTitleOffset(2.5); hh_model.Draw(""surf""); ; c.SaveAs(""rf305_condcorrprod.png""); [#0] WARNING:InputArguments -- The parameter 'sigma' with range [-inf, inf] of the RooGaussian 'gaussx' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y); [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on y integrates over variables (x); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf305_condcorrprod.py. tutorialsroofitrf305_condcorrprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf305__condcorrprod_8py.html:2741,integrat,integrates,2741,doc/master/rf305__condcorrprod_8py.html,https://root.cern,https://root.cern/doc/master/rf305__condcorrprod_8py.html,3,['integrat'],"['integrates', 'integrator']"
Deployability,"y);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooSetProxy _anaList;  Set of observables over which is integrated/summed analytically. ;  ; bool _cacheNum = false;  Cache integral if numeric. ;  ; RooSetProxy _facList;  Set of observables on which function does not depends, which are integrated nevertheless. ;  ; std::unique_ptr< RooArgSet > _funcNormSet;  Optional normalization set passed to function. ;  ; RooRealProxy _function;  Function being integrated. ;  ; RooNumIntConfig * _iconfig = nullptr;  ; RooSetProxy _intList;  Set of continuous observables over which is integrated numerically. ;  ; IntOperMode _intOperMode = Hybrid;  integration operation mode ;  ; RooSetProxy _jacList;  Set of lvalue observables over which is analytically integration that have a non-unit Jacobian. ;  ; Int_t _mode = 0;  ; std::unique_ptr< RooAbsFunc > _numIntegrand;  ! ;  ; std::unique_ptr< RooAbsIntegrator > _numIntEngine;  ! ;  ; std::unique_ptr< RooArgSet > _params;  ! cache for set of parameters ;  ; TNamed * _rangeName = nullptr;  ; bool _respectCompSelect = true;  ; bool _restartNumIntEngine = false;  ! ;  ; RooArgSet _saveInt;  ! ;  ; RooArgSet _saveSum;  ! ;  ; RooListProxy _sumCat;  ! ;  ; RooSetProxy _sumList;  Set of discrete observable over which is summed numerically. ;  ; bool _valid = false;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:57688,integrat,integration,57688,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,2,['integrat'],['integration']
Deployability,"y*fTxtConfigconfiguration file text entry; TGTextEntry*fTxtNameconnection name text entry; TGTextEntry*fTxtUsrNameuser name text entry; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionServerFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionServerFrame(); Destructor. void Build(TSessionViewer* gui); Build server configuration frame. void SettingsChanged(); Settings have changed, update GUI accordingly. Bool_t HandleExpose(Event_t* event); Handle expose event in server frame. void OnConfigFileClicked(); Browse configuration files. void OnBtnDeleteClicked(); Delete selected session configuration (remove it from the list). void OnBtnConnectClicked(); Connect to selected server. void OnBtnNewServerClicked(); Reset server configuration fields. void OnBtnAddClicked(); Add newly created session configuration in the list of sessions. void Update(TSessionDescription* desc); Update fields with values from session description desc. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for session server frame.; Used to navigate between text entry fields. const char * GetName() const; { return fQueryName; }. const char * GetAddress() const; { return fTxtAddress->GetText(); }. Int_t GetPortNumber() const; { return fNumPort->GetIntNumber(); }. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. const char * GetConfigText() const; { return fTxtConfig->GetText(); }. const char * GetUserName() const; { return fTxtUsrName->GetText(); }. Bool_t IsSync() const; { return (Bool_t)(fSync->GetState() == kButtonDown); }. void SetAddEnabled(Bool_t on = kTRUE). void SetConnectEnabled(Bool_t on = kTRUE). void SetName(const char* str); { fTxtName->SetText(str); }. void SetAddress(const char* str); { fTxtAddress->SetText(str); }. void SetPortNumber(Int_t port); { fNumPort->SetIntNumber(port); }. void SetLogLevel(Int_t log); { fLogLevel->SetIntN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSessionServerFrame.html:20546,Update,Update,20546,root/html532/TSessionServerFrame.html,https://root.cern,https://root.cern/root/html532/TSessionServerFrame.html,4,['Update'],['Update']
Deployability,"y2, const Double_t* z1, const Double_t* z2). void SetDefaultWindow(). void SetDview(Double_t dview). void SetDproj(Double_t dproj). void SetLatitude(Double_t latitude). void SetLongitude(Double_t longitude). void SetPsi(Double_t psi). void SetOutlineToCube(). void SetParallel(). void SetPerspective(). void SetRange(const Double_t* min, const Double_t* max). void SetRange(Double_t x0, Double_t y0, Double_t z0, Double_t x1, Double_t y1, Double_t z1, Int_t flag = 0). void SetSystem(Int_t system). void SetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep). void SetViewChanged(Bool_t flag = kTRUE). void SetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv). void WCtoNDC(const Float_t* pw, Float_t* pn). void WCtoNDC(const Double_t* pw, Double_t* pn). void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); --. void MoveWindow(Char_t option). void AdjustScales(TVirtualPad* pad = 0). void Centered3DImages(TVirtualPad* pad = 0). void Centered(). void FrontView(TVirtualPad* pad = 0). void Front(). void ZoomIn(). void ZoomOut(). void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25). void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25). void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0). void SideView(TVirtualPad* pad = 0). void Side(). void TopView(TVirtualPad* pad = 0). void Top(). void ToggleRulers(TVirtualPad* pad = 0). void ShowAxis(). void ToggleZoom(TVirtualPad* pad = 0). void ZoomMove(). void Zoom(). void UnZoom(). » Author: Rene Brun, Nenad Buncic, Evgueni Tcherniaev, Olivier Couet 18/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gpad:$Id: TView.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TView.html:13777,Toggle,ToggleRulers,13777,root/html532/TView.html,https://root.cern,https://root.cern/root/html532/TView.html,2,['Toggle'],"['ToggleRulers', 'ToggleZoom']"
Deployability,y::ShapeFactor ; RooStats::HistFactory::ShapeSys ; RooStats::HistFactory::StatError ; RooStats::HistFactory::StatErrorConfig ; RooStats::HybridCalculator ; RooStats::HybridCalculatorOriginal Hypothesis test calculator using a Bayesian-frequentist hybrid method; RooStats::HybridPlot Provides the plots for an HybridResult; RooStats::HybridResult Class containing the results of the HybridCalculator; RooStats::HypoTestCalculator Interface for tools doing hypothesis tests; RooStats::HypoTestCalculatorGeneric ; RooStats::HypoTestInverter HypoTestInverter class; RooStats::HypoTestInverterOriginal HypoTestInverterOriginal class; RooStats::HypoTestInverterPlot HypoTestInverterPlot class; RooStats::HypoTestInverterResult HypoTestInverterResult class ; RooStats::HypoTestPlot ; RooStats::HypoTestResult Base class to represent results of a hypothesis test; RooStats::IntervalCalculator Interface for tools setting limits (producing confidence intervals); RooStats::LikelihoodInterval Concrete implementation of a ConfInterval based on a likelihood ratio; RooStats::LikelihoodIntervalPlot Class containing the results of the IntervalCalculator; RooStats::MCMCCalculator Markov Chain Monte Carlo calculator for Bayesian credible intervals; RooStats::MCMCInterval Concrete implementation of a ConfInterval based on MCMC calculation; RooStats::MCMCIntervalPlot Class containing the results of the MCMCCalculator; RooStats::MarkovChain ; RooStats::MaxLikelihoodEstimateTestStat ; RooStats::MetropolisHastings Markov Chain Monte Carlo calculator for Bayesian credible intervals; RooStats::MinNLLTestStat implements the minimum NLL as a test statistic to be used with several tools; RooStats::ModelConfig A class that holds configuration information for a model using a workspace as a store; RooStats::NeymanConstruction Interface for tools setting limits (producing confidence intervals); RooStats::NumEventsTestStat ; RooStats::NumberCountingPdfFactory A factory specific to common number counting problems.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:48665,configurat,configuration,48665,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,2,['configurat'],['configuration']
Deployability,"y; the output matched the desired output. void UpdateNetwork(const vector<Float_t>& desired, Double_t eventWeight = 1.); update the network based on how closely; the output matched the desired output. void CalculateNeuronDeltas(); have each neuron calculate its delta by backpropagation. void GeneticMinimize(); create genetics class similar to GeneticCut; give it vector of parameter ranges (parameters = weights); link fitness function of this class to ComputeEstimator; instantiate GA (see MethodCuts); run it; then this should exist for GA, Minuit and random sampling. Double_t EstimatorFunction(vector<Double_t>& parameters); interface to the estimate. Double_t ComputeEstimator(vector<Double_t>& parameters); this function is called by GeneticANN for GA optimization. void UpdateSynapses(); update synapse error fields and adjust the weights (if in sequential mode). void AdjustSynapseWeights(); just adjust the synapse weights (should be called in batch mode). void UpdatePriors(). void UpdateRegulators(). void GetApproxInvHessian(TMatrixD& InvHessian, bool regulate = true). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodMLP(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructors. void Train(); { Train(NumCycles()); }. bool HasInverseHessian(); { return fCalculateErrors; }. » Author: Krzysztof Danielowski, Andreas Hoecker, Matt Jachowski, Kamil Kraszewski, Maciej Kruk, Peter Speckmayer, Joerg Stelzer, Eckhard von Toerne, Jan Therhaag, Jiahang Zhong » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggesti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodMLP.html:29476,Update,UpdateRegulators,29476,root/html604/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodMLP.html,1,['Update'],['UpdateRegulators']
Deployability,"y; the output matched the desired output. void UpdateNetwork(const vector<Float_t>& desired, Double_t eventWeight = 1.); update the network based on how closely; the output matched the desired output. void CalculateNeuronDeltas(); have each neuron calculate its delta by backpropagation. void GeneticMinimize(); create genetics class similar to GeneticCut; give it vector of parameter ranges (parameters = weights); link fitness function of this class to ComputeEstimator; instantiate GA (see MethodCuts); run it; then this should exist for GA, Minuit and random sampling. Double_t EstimatorFunction(vector<Double_t>& parameters); interface to the estimate. Double_t ComputeEstimator(vector<Double_t>& parameters); this function is called by GeneticANN for GA optimization. void UpdateSynapses(); update synapse error fields and adjust the weights (if in sequential mode). void AdjustSynapseWeights(); just adjust the synapse weights (should be called in batch mode). void UpdatePriors(). void UpdateRegulators(). void GetApproxInvHessian(TMatrixD& InvHessian, bool regulate = true). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodMLP(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructors. void Train(); { Train(NumCycles()); }. bool HasInverseHessian(); { return fCalculateErrors; }. » Author: Krzysztof Danielowski, Andreas Hoecker, Matt Jachowski, Kamil Kraszewski, Maciej Kruk, Peter Speckmayer, Joerg Stelzer, Eckhard von Toerne, Jan Therhaag, Jiahang Zhong » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:16; This page has been automatically generated. For comments or suggesti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodMLP.html:29468,Update,UpdateRegulators,29468,root/html602/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodMLP.html,1,['Update'],['UpdateRegulators']
Deployability,"y;  Base class for the proxy around object in TClonesArray. More...;  ; struct  TClassGetClassHelper;  ; struct  TClassGetClassHelper< std::pair< F, S > >;  ; class  TDefaultInitBehavior;  ; struct  TDirectoryAtomicAdapter;  Internal class used in the implementation of gDirectory The objects of type TDirectoryAtomicAdapter should only be used inside the thread that created them. More...;  ; class  TExecutor;  This class implements the interface to execute the same task multiple times, sequentially or in parallel depending on the execution policy passed as a first parameter on construction, and possibly with different arguments every time. More...;  ; struct  TF1Builder;  Internal class used by TF1 for defining template specialization for different TF1 constructors More...;  ; struct  TF1Builder< const char * >;  TF1 building from a string used to build a TFormula based on a lambda function. More...;  ; struct  TF1Builder< Func * >;  ; class  TFriendProxy;  ; class  TFriendProxyDescriptor;  ; class  TGILRAII;  Class to acquire and release the Python GIL where it applies, i.e. More...;  ; struct  THashConsistencyHolder;  ; class  THnBaseBinIter;  Iterator over THnBase bins (internal implementation). More...;  ; class  THnBaseBrowsable;  TBrowser helper for THnBase. More...;  ; class  TImpProxy;  Template of the proxy around objects. More...;  ; class  TInitBehavior;  ; struct  TMultiArrayType;  Helper class for proxy around multi dimension array. More...;  ; class  TNamedBranchProxy;  ; class  TObjProxy;  ; class  TOperatorNewHelper;  ; class  TParBranchProcessingRAII;  ; class  TQObjectInitBehavior;  ; class  TROOTAllocator;  ; struct  TSchemaHelper;  ; class  TSchemaRuleProcessor;  ; struct  TSchemaType;  ; class  TSpinLockGuard;  A spin mutex-as-code-guard class. More...;  ; class  TStdBitsetHelper;  ; class  TStlArrayProxy;  Template of the Concrete Implementation of the branch proxy around an stl container of array of T. More...;  ; class  TStlImpProxy;  Template",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html:4833,release,release,4833,doc/v632/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html,1,['release'],['release']
Deployability,"yEntries or hadd interfaces. The new cache is enabled by default, to update the size of the cache or disable it from TTreeCloner use: TTreeCloner::SetCacheSize. To do the same from TTree::CopyEntries add to the option string “cachesize=SIZE”. To update the size of the cache or disable it from hadd, use the command line option -cachesize SIZE. SIZE shouyld be given in number bytes and can be expressed in ‘human readable form’ (number followed by size unit like MB, MiB, GB or GiB, etc. or SIZE can be set zero to disable the cache. Histogram Libraries. Protect access to TROOT::GetListOfGlobalFunctions in TFormula. Math. Update MixMax random number generator for 32 bit architectures. TColor. Import TColor from master to make sure the high quality palettes are defined only ones. This was requested here. PyROOT. Fix case where c++ exception in a constructor were not propagated to python ROOT-7864; Fix case where PyROOT was unable to call copy constructor ROOT-7783; Fix handling of vector<enums> ROOT-7916; Fix the wrong return value when calling a c++ function returning short, or when retuning a char with a negative value ROOT-7872; Added a new configuration option (ROOT.PyConfig.DisableRootLogon) to disable processing of the rootlogon[.py|C] macro in addition to the -n option in the command arguments. Bug Fixes and Tasks. [ROOT-7426] - Cannot print elements of vector on Mac; [ROOT-7739] - TVectorD times double returns a TH1 on ROOT command line; [ROOT-7825] - wrong value passed to function expecting “const T*&""; [ROOT-7830] - Cling automatic RooFit objects always reloaded from file; [ROOT-7862] - CMake Error: CMake can not determine linker language for target: g2root; [ROOT-7864] - Segfault in __cf_15 and FastCall (c++ exception in a constructor is not propagated to python); [ROOT-7865] - root commandline tools are not executable after installation; [ROOT-7872] - PyROOT: wrong return value when calling a c++ function returning short; [ROOT-7879] - Autoloader (parser?) tri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:26893,configurat,configuration,26893,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['configurat'],['configuration']
Deployability,"yGSL method key; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_useIntegrandLimits; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; void*_workspaceGSL workspace ; Double_t*_x! Current coordinate; Double_t_xmax! Upper integration bound; Double_t_xmin! Lower integration bound. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register this class with RooNumIntConfig as a possible choice of numeric; integrator for one-dimensional integrals over finite and infinite domains. RooAdaptiveGaussKronrodIntegrator1D(); coverity[UNINIT_CTOR]; Default constructor. RooAdaptiveGaussKronrodIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor taking a function binding and a configuration object. RooAdaptiveGaussKronrodIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor taking a function binding, an integration range and a configuration object. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor. Bool_t initialize(); Initialize integrator allocate buffers and setup GSL workspace. ~RooAdaptiveGaussKronrodIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Calculate and return integral at at given parameter values. RooAdaptiveGaussKronrodIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t flag); If flag is true, intergr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAdaptiveGaussKronrodIntegrator1D.html:8836,integrat,integration,8836,root/html530/RooAdaptiveGaussKronrodIntegrator1D.html,https://root.cern,https://root.cern/root/html530/RooAdaptiveGaussKronrodIntegrator1D.html,8,"['configurat', 'integrat']","['configuration', 'integration']"
Deployability,"yI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return fMultiplicity;}. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }. » Author: Philippe Canal 20/03/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeFormulaManager.html:7546,update,update,7546,root/html534/TTreeFormulaManager.html,https://root.cern,https://root.cern/root/html534/TTreeFormulaManager.html,6,"['Update', 'update']","['UpdateFormulaLeaves', 'UpdateUsedSize', 'update']"
Deployability,"yLine(const TBuffer3D& buffer); ~TGLPolyLine(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLPolyLine.html:2325,Update,UpdateBoundingBox,2325,root/html532/TGLPolyLine.html,https://root.cern,https://root.cern/root/html532/TGLPolyLine.html,2,['Update'],"['UpdateBoundingBox', 'UpdateBoundingBoxesOfPhysicals']"
Deployability,"yListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealVar*_yvarY variable if so designated; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooXYChi2Var(). RooXYChi2Var(const char *name, const char* title, RooAbsReal& func, RooDataSet& xydata, Bool_t integrate). RooXYChi2Var constructor with function and X-Y values dataset. An X-Y dataset is a weighted dataset with one or more observables X where the weight is interpreted; as the Y value and the weight error is interpreted as the Y value error. The weight must have an; non-zero error defined at each point for the chi^2 calcul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooXYChi2Var.html:35406,integrat,integrator,35406,root/html526/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html526/RooXYChi2Var.html,2,"['configurat', 'integrat']","['configuration', 'integrator']"
Deployability,"yListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealVar*_yvarY variable if so designated; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooXYChi2Var(); coverity[UNINIT_CTOR]. RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, Bool_t integrate = kFALSE). RooXYChi2Var constructor with function and X-Y values dataset. An X-Y dataset is a weighted dataset with one or more observables X where the weight is interpreted; as the Y value and the weight error is interpreted as the Y value error. The weight must have an; non-zero error defined at e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooXYChi2Var.html:35672,integrat,integrator,35672,root/html528/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html528/RooXYChi2Var.html,2,"['configurat', 'integrat']","['configuration', 'integrator']"
Deployability,"y_pdfListList of PDF components; RooLinkedList_pdfNSetListList of PDF component normalization sets; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; TNamed*_refRangeNameReference range name for interpretation of conditional products; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; Bool_t_selfNormIs self-normalized; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useDefaultGenUse default or distributed event generator; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProdPdf.html:44650,configurat,configuration,44650,root/html532/RooProdPdf.html,https://root.cern,https://root.cern/root/html532/RooProdPdf.html,6,"['configurat', 'integrat']","['configuration', 'integrator']"
Deployability,"yer class ;  CVOptimizerGeneric Optimizer class ;  ►NExperimental;  CClassification;  CClassificationResult;  ►NkNN;  CEvent;  CModulekNN;  CNodeThis file contains binary tree and global function template that searches tree for k-nearest neigbors ;  CAbsoluteDeviationLossFunctionAbsolute Deviation Loss Function ;  CAbsoluteDeviationLossFunctionBDTAbsolute Deviation BDT Loss Function ;  CAbsValue;  CBDTEventWrapper;  CBinarySearchTreeA simple Binary search tree including a volume search method ;  CBinarySearchTreeNodeNode for the BinarySearch or Decision Trees ;  CBinaryTreeBase class for BinarySearch and Decision Trees ;  CCCPrunerA helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) ;  ►CCCTreeWrapper;  CCCTreeNode;  CClassifierFactoryThis is the MVA factory ;  CClassInfoClass that contains all the information of a class ;  Ccompose_binary_t;  Ccompose_unary_t;  ►CConfigSingleton class for global configuration settings used by TMVA ;  CIONames;  CVariablePlotting;  CConfigurable;  CConvergenceTestCheck for convergence ;  CCostComplexityPruneToolA class to prune a decision tree using the Cost Complexity method ;  CCrossEntropyImplementation of the CrossEntropy as separation criterion ;  CCrossValidationClass to perform cross validation, splitting the dataloader into folds ;  CCrossValidationFoldResult;  CCrossValidationResultClass to save the results of cross validation, the metric for the classification ins ROC and you can ROC curves ROC integrals, ROC average and ROC standard deviation ;  CCvSplit;  CCvSplitKFolds;  CCvSplitKFoldsExpr;  CDataInputHandlerClass that contains all the data information ;  CDataLoader;  CDataSetClass that contains all the data information ;  ►CDataSetFactoryClass that contains all the data information ;  CEventStats;  CDataSetInfoClass that contains all the data information ;  CDataSetManagerClass that contains all the data information ;  CDecisionTreeImpl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:83381,configurat,configuration,83381,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['configurat'],['configuration']
Deployability,"yer::ReinitSelector(TQueryResult* qr); virtual voidTProofPlayer::RemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidTProofPlayer::RestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofPlayerLite.html:11241,Update,UpdateAutoBin,11241,root/html532/TProofPlayerLite.html,https://root.cern,https://root.cern/root/html532/TProofPlayerLite.html,1,['Update'],['UpdateAutoBin']
Deployability,"yerPerceptron.h. ◆ IsA(). TClass * TMultiLayerPerceptron::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 151 of file TMultiLayerPerceptron.h. ◆ LineSearch(). bool TMultiLayerPerceptron::LineSearch ; (; Double_t * ; direction, . Double_t * ; buffer . ). protected . Search along the line defined by direction. ; buffer is not used but is updated with the new dw so that it can be used by a later stochastic step. It returns true if the line search fails. ; Definition at line 2274 of file TMultiLayerPerceptron.cxx. ◆ LoadWeights(). Bool_t TMultiLayerPerceptron::LoadWeights ; (; Option_t * ; filename = """"). Loads the weights from a text file conforming to the format defined by DumpWeights. ; Definition at line 1657 of file TMultiLayerPerceptron.cxx. ◆ MLP_Batch(). void TMultiLayerPerceptron::MLP_Batch ; (; Double_t * ; buffer). protected . One step for the batch (stochastic) method. ; DEDw should have been updated before calling this. ; Definition at line 2203 of file TMultiLayerPerceptron.cxx. ◆ MLP_Line(). void TMultiLayerPerceptron::MLP_Line ; (; Double_t * ; origin, . Double_t * ; dir, . Double_t ; dist . ). private . Sets the weights to a point along a line Weights are set to [origin + (dist * dir)]. ; Definition at line 2231 of file TMultiLayerPerceptron.cxx. ◆ MLP_Stochastic(). void TMultiLayerPerceptron::MLP_Stochastic ; (; Double_t * ; buffer). protected . One step for the stochastic method buffer should contain the previous dw vector and will be updated. ; Definition at line 2158 of file TMultiLayerPerceptron.cxx. ◆ operator=(). TMultiLayerPerceptron & TMultiLayerPerceptron::operator= ; (; const TMultiLayerPerceptron & ; ). private . ◆ Randomize(). void TMultiLayerPerceptron::Randomize ; (; ); const. Randomize the weights. ; Definition at line 1239 of file TMultiLayerPerceptron.cxx. ◆ Result(). Double_t TMultiLayerPerceptron::Result ; (; Int_t ; event, . Int_t ; index = 0 . ); co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:43206,update,updated,43206,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['update'],['updated']
Deployability,"yle(Style_t fstyle); virtual voidTGraph::SetHistogram(TH1F* h); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTAttMarker::SetMarkerAttributes()MENU ; virtual voidTAttMarker::SetMarkerColor(Color_t tcolor = 1); virtual voidTAttMarker::SetMarkerSize(Size_t msize = 1); virtual voidTAttMarker::SetMarkerStyle(Style_t mstyle = 1); virtual voidTGraph::SetMaximum(Double_t maximum = -1111)MENU ; virtual voidTGraph::SetMinimum(Double_t minimum = -1111)MENU ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGraph::SetPoint(Int_t i, Double_t x, Double_t y); virtual voidTGraph::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); voidRooPlotable::setYAxisLabel(const char* label); voidRooPlotable::setYAxisLimits(Double_t ymin, Double_t ymax); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidTGraph::Sort(Bool_t (*)(const TGraph*, Int_t, Int_t) greater = &TGraph::CompareX, Bool_t ascending = kTRUE, Int_t low = 0, Int_t high = -1111); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidRooPlotable::updateYAxisLimits(Double_t y); virtual voidTGraph::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidTGraph::Zero(Int_t& k, Double_t AZ, Double_t BZ, Double_t E2, Double_t& X, Double_t& Y, Int_t maxiterations).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCurve.html:13909,update,updateYAxisLimits,13909,root/html530/RooCurve.html,https://root.cern,https://root.cern/root/html530/RooCurve.html,6,['update'],['updateYAxisLimits']
Deployability,"ymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction ;  CNuisanceParametersSamplerHelper class for ToyMCSampler ;  CNumberCountingPdfFactory;  CNumEventsTestStatNumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspector;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset ;  CProofConfigHolds configuration options for proof and proof-lite ;  CProposalFunctionProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ;  CSamplingDistPlotThis class provides simple and straightforward utilities to plot SamplingDistribution objects ;  CSamplingDistributionThis class simply holds a sampling distribution of some test statistic ;  CSamplingSummary;  CSamplingSummaryLookup;  CSequentialProposalClass implementing a proposal function that samples the parameter space by moving only in one coordinate (choosen randomly) at each step ;  CSimpleInterval;  CSimpleLikelihoodRatioTestStatTestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood ;  CSPlotThis class calculates sWeights used to create an sPlot ;  CTestStatisticTestStatistic is an interface class to provide a facility for construction t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:8303,configurat,configuration,8303,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,3,['configurat'],['configuration']
Deployability,"ymore.; CINT objects are always on the heap. void Reset(); Reset the CINT state to the state saved by the last call to; TCint::SaveContext(). void ResetAll(); Reset the CINT state to its initial state. void ResetGlobals(); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void ResetGlobalVar(void* obj); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void RewindDictionary(); Rewind CINT dictionary to the point where it was before executing; the current macro. This function is typically called after SEGV or; ctlr-C after doing a longjmp back to the prompt. Int_t DeleteGlobal(void* obj); Delete obj from CINT symbol table so it cannot be accessed anymore.; Returns 1 in case of success and 0 in case object was not in table. void SaveContext(); Save the current CINT state. void SaveGlobalsContext(); Save the current CINT state of global objects. void UpdateListOfGlobals(); Update the list of pointers to global variables. This function; is called by TROOT::GetListOfGlobals(). void UpdateListOfGlobalFunctions(); Update the list of pointers to global functions. This function; is called by TROOT::GetListOfGlobalFunctions(). void UpdateListOfTypes(); Update the list of pointers to Datatype (typedef) definitions. This; function is called by TROOT::GetListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE); Set pointer to CINT's G__ClassInfo in TClass. Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE); Checks if a class with the specified name is defined in CINT.; Returns kFALSE is class is not defined. void CreateListOfBaseClasses(TClass* cl); Create list of pointers to base class(es) for TClass cl. void CreateListOfDataMembers(TClass* cl); Create list of pointers to data members for TClass cl. void CreateListOfMethods(TClass* cl); Create list of pointers to methods for TClass cl. void UpdateListOfMethods(TClass* cl); Update the list of point",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCint.html:22936,Update,UpdateListOfGlobals,22936,root/html532/TCint.html,https://root.cern,https://root.cern/root/html532/TCint.html,2,['Update'],"['Update', 'UpdateListOfGlobals']"
Deployability,"ymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooLinkedList_configSetsList of configuration sets for individual integration methods; static RooNumIntConfig*_default; Double_t_epsAbsAbsolute precision; Double_t_epsRelRelative precision; RooCategory_method1DSelects integration method for 1D integrals; RooCategory_method1DOpenSelects integration method for open ended 1D integrals; RooCategory_method2DSelects integration method for 2D integrals; RooCategory_method2DOpenSelects integration method for open ended 2D integrals; RooCategory_methodNDSelects integration method for ND integrals; RooCategory_methodNDOpenSelects integration method for open ended ND integrals; static Int_tRooPrintable::_nameLength; Bool_t_printEvalCounterFlag to control printing of function evaluation counter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Function called by atexit() handler installed by RooSentinel to; cleanup global objects at end of job. RooNumIntConfig& defaultConfig(); Return reference to instance of default numeric integrator configuration object. RooNumIntConfig(); Constructor. ~RooNumIntConfig(); Destructor. RooNumIntConfig(const RooNumIntConfig& other); Copy constructor. RooNumIntConfig& operator=(const RooNumIntConfig& other); Assignment operator from other RooNumIntConfig. Bool_t addConfigSection(const RooAbsIntegrator* proto, const RooArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumIntConfig.html:8432,configurat,configuration,8432,root/html602/RooNumIntConfig.html,https://root.cern,https://root.cern/root/html602/RooNumIntConfig.html,32,"['configurat', 'integrat']","['configuration', 'integration']"
Deployability,"ynopsis on the first line of a log message and putting more detailed information on subsequent lines. You can omit the -m option entirely and an editor (as specified with VISUAL or EDITOR) will be started.; This command is extremely versatile. You may want to have a couple of aliases defined in your .gitconfig file (see attached gitconfig for ideas). Working in your local repository. Obtain differences with; git status. Move files from one part of your directory tree to another:; git mv <old-path> <new-path>. Delete unwanted tracked files:; git rm <path>. Add un-tracked files:; git add <un-tracked-file>. Stage a modified file for commit:; git add <file>. Commit currently-staged files:; git commit -m <log-message>. Commit only specific files (regardless of what is staged):; git commit -m <log-message>. Commit all modified files:; git commit -a -m <log-message>. Un-stage a previously staged (but not yet committed) file:; git reset HEAD <file>. Examine a representation of your change tree with log files and patch descriptions:; gitk. Get differences with respect to the committed (or staged) version of a file:; git diff <file>. Get differences between local file and committed version:; git diff --cached <file>. Basic interaction with local branches. Create (but do not switch to) a new local branch based on the current branch:; git branch <new-branch>. Create and switch to a local branch based on the current branch:; git checkout -b <new-branch>. Change to an existing local branch:; git checkout <branch>. Examine the list of commits in the current branch not reflected in another branch:; git cherry -v <branch>. Merge another branch into the current one:; git merge <branch>. Delete a local branch (eg after merging):; git branch -d <branch>. OR (if changes have not been completely merged but you're sure you want to delete anyway):; git branch -D <branch>. Basic interaction with a remote branch; Assuming you created your local repository with git clone, there is already one ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:8108,patch,patch,8108,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['patch'],['patch']
Deployability,"youtHints::SetPadBottom(Int_t v); virtual voidTGLayoutHints::SetPadLeft(Int_t v); virtual voidTGLayoutHints::SetPadRight(Int_t v); virtual voidTGLayoutHints::SetPadTop(Int_t v); voidTRefCnt::SetRefCount(UInt_t r); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetW(Double_t w); voidSetX(Double_t x); voidSetY(Double_t y); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidTGLayoutHints::UpdateFrameElements(TGLayoutHints* l). Data Members; public:. enum ERubberFlag { kLRubberX; kLRubberY; kLRubberW; kLRubberH; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum TRefCnt::EReferenceFlag { kStaticInit; };. protected:. UInt_tfFlagrubber flag; Double_tfHheight of widget; ULong_tTGLayoutHints::fLayoutHintslayout hints (combination of ELayoutHints); Int_tTGLayoutHints::fPadbottomamount of bottom padding; Int_tTGLayoutHints::fPadleftamount of left padding; Int_tTGLayoutHints::fPadrightamount of right padding; Int_tTGLayoutHints::fPadtopamount of top padding; UInt_tTRefCnt::fRefs(1 less than) number of references; Double_tfWwidth of widget; Double_tfXx - position of widget; Double_tfYy - position of widget. Class Charts",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGXYLayoutHints.html:8360,Update,UpdateFrameElements,8360,root/html532/TGXYLayoutHints.html,https://root.cern,https://root.cern/root/html532/TGXYLayoutHints.html,1,['Update'],['UpdateFrameElements']
Deployability,"ype name of data member; Double_tTStreamerElement::fXmax!Maximum of data member if a range is specified [xmin,xmax,nbits]; Double_tTStreamerElement::fXmin!Minimum of data member if a range is specified [xmin,xmax,nbits]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStreamerBase(); Default ctor. TStreamerBase(const char* name, const char* title, Int_t offset); Create a TStreamerBase object. ~TStreamerBase(); TStreamerBase dtor. TClass * GetClassPointer() const; Returns a pointer to the TClass of this element. Int_t GetSize() const; Returns size of baseclass in bytes. void Init(TObject* obj = 0); Setup the element. Bool_t IsBase() const; Return kTRUE if the element represent a base class. const char * GetInclude() const; Return the proper include for this element. void ls(Option_t* option = """") const; Print the content of the element. Int_t ReadBuffer(TBuffer& b, char* pointer); Read the content of the buffer. void Streamer(TBuffer& b); Stream an object of class TStreamerBase. void Update(const TClass* oldClass, TClass* newClass); Function called by the TClass constructor when replacing an emulated class; by the real class. Int_t WriteBuffer(TBuffer& b, char* pointer); Write the base class into the buffer. TStreamerElement& operator=(const TStreamerBase& ). ULong_t GetMethod() const; {return ULong_t(fStreamer);}. TStreamerBase(const TStreamerBase& ). Int_t GetBaseVersion(); {return fBaseVersion;}. TClass * GetNewBaseClass(); { return fNewBaseClass; }. void SetNewBaseClass(TClass* cl); { fNewBaseClass = cl; }. void SetBaseVersion(Int_t v); {fBaseVersion = v;}. » Author: Rene Brun 12/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TStreamerElement.h 36543 2010-11-08 17:51:01Z pcanal $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStreamerBase.html:10105,Update,Update,10105,root/html532/TStreamerBase.html,https://root.cern,https://root.cern/root/html532/TStreamerBase.html,1,['Update'],['Update']
Deployability,"ype values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html:5993,integrat,integration,5993,root/html528/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html,10,['integrat'],['integration']
Deployability,"ype(Int_t type); virtual voidTGFrame::SetDrawOption(Option_t* = """"); virtual voidTGFrame::SetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidTGCompositeFrame::SetEditable(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetEditDisabled(UInt_t on = 1); virtual voidSetFont(FontStruct_t font); virtual voidSetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidSetHsbPosition(Long_t newPos); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGView::SetLayoutManager(TGLayoutManager*); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetReadOnly(Bool_t on = kTRUE)TOGGLE GETTER ; virtual voidSetSBRange(Int_t direction); virtual voidSetSelectBack(Pixel_t p); virtual voidSetSelectFore(Pixel_t p); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidSetText(TGText* text); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGView::SetVisibleStart(Int_t newTop, Int_t direction); virtual voidSetVsbPosition(Long_t newPos); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidShowBottom(); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidShowTop(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TGTextView(const TGWindow* parent = 0, UInt_t w =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTextView.html:15277,TOGGLE,TOGGLE,15277,root/html602/TGTextView.html,https://root.cern,https://root.cern/root/html602/TGTextView.html,2,['TOGGLE'],['TOGGLE']
Deployability,"ype(Int_t type); virtual voidTGFrame::SetDrawOption(Option_t* = """"); virtual voidTGFrame::SetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidTGCompositeFrame::SetEditable(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetEditDisabled(UInt_t on = 1); virtual voidSetFont(FontStruct_t font); virtual voidSetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidSetHsbPosition(Long_t newPos); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGView::SetLayoutManager(TGLayoutManager*); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetReadOnly(Bool_t on = kTRUE)TOGGLE GETTER ; virtual voidSetSBRange(Int_t direction); virtual voidSetSelectBack(Pixel_t p); virtual voidSetSelectFore(Pixel_t p); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidSetText(TGText* text); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGView::SetVisibleStart(Int_t newTop, Int_t direction); virtual voidSetVsbPosition(Long_t newPos); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidShowBottom(); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp); virtual voidShowTop(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Long_tToObjXCoord(Long_t xCoord, Long_t line); virtual Long_tToObjYCoor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGTextView.html:15763,TOGGLE,TOGGLE,15763,root/html532/TGTextView.html,https://root.cern,https://root.cern/root/html532/TGTextView.html,1,['TOGGLE'],['TOGGLE']
Deployability,"ype(Int_t type); virtual voidTGFrame::SetDrawOption(Option_t* = """"); virtual voidTGFrame::SetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidTGCompositeFrame::SetEditable(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetEditDisabled(UInt_t on = 1); virtual voidSetFont(FontStruct_t font); virtual voidSetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidSetHsbPosition(Long_t newPos); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGView::SetLayoutManager(TGLayoutManager*); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetReadOnly(Bool_t on = kTRUE)TOGGLE GETTER ; virtual voidSetSBRange(Int_t direction); virtual voidSetSelectBack(Pixel_t p); virtual voidSetSelectFore(Pixel_t p); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidSetText(TGText* text); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGView::SetVisibleStart(Int_t newTop, Int_t direction); virtual voidSetVsbPosition(Long_t newPos); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidShowBottom(); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector&); virtual voidShowTop(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Long_tToObjXCoord(Long_t xCoord, Long_t line); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGTextView.html:15763,TOGGLE,TOGGLE,15763,root/html534/TGTextView.html,https://root.cern,https://root.cern/root/html534/TGTextView.html,1,['TOGGLE'],['TOGGLE']
Deployability,"ypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. boolCheckFunction(); voidDoInitialize(). private:. ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const ROOT::Math::GSLMCIntegrator&); ROOT::Math::GSLMCIntegrator&operator=(const ROOT::Math::GSLMCIntegrator&). Data Members; private:. doublefAbsTol; unsigned intfCalls; unsigned intfDim; doublefError; ROOT::Math::GSLMonteFunctionWrapper*fFunction; doublefRelTol; doublefResult; ROOT::Math::GSLRngWrapper*fRng; intfStatus; ROOT::Math::IntegrationMultiDim::TypefType; ROOT::Math::GSLMCIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMCIntegrator(MCIntegration::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0 ); constructors; /**; constructor of GSL MCIntegrator using all the default options; *; GSLMCIntegrator( );; constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration. The possible types are defined in the MCIntegration::Type enumeration; Default is VEGAS; @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. NOTE: When the default values are used , the options are taken from teh static method of ROOT::Math::IntegratorMultiDimOptions. GSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration using a char * (required by plug-in manager); @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); template methods for generic functors. met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__GSLMCIntegrator.html:3535,integrat,integration,3535,root/html528/ROOT__Math__GSLMCIntegrator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__GSLMCIntegrator.html,6,['integrat'],['integration']
Deployability,"ypename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fPastSquaredWeightGradients. protected . The sum of the square of the past weight gradients associated with the deep net. ; Definition at line 55 of file RMSProp.h. ◆ fRho. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . Scalar_t TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fRho. protected . The Rho constant used by the optimizer. ; Definition at line 52 of file RMSProp.h. ◆ fWeightUpdates. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fWeightUpdates. protected . The accumulation of the past Weights for performing updates. ; Definition at line 59 of file RMSProp.h. ◆ fWorkBiasTensor1. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fWorkBiasTensor1. protected . working tensor used to keep a temporary copy of bias or bias gradients ; Definition at line 64 of file RMSProp.h. ◆ fWorkBiasTensor2. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . std::vector<std::vector<Matrix_t> > TMVA::DNN::TRMSProp< Architecture_t, Layer_t, DeepNet_t >::fWorkBiasTensor2. protected . working tensor used to keep a temporary copy of bias or bias gradients ; Definition at line 68 of file RMSProp.h. ◆ fWorkWeightTensor1. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html:13342,update,updates,13342,doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TRMSProp.html,1,['update'],['updates']
Deployability,"ys mytracks,pions and muons may be written separately.; 11.5 Schema Evolution; Schema evolution is a problem faced by long-lived data. When a schema changes, existing persistent data can become inaccessible unless the system provides a mechanism to access data created with previous versions of the schema. In the lifetime of collaboration, the class definitions (i.e. the schema) are likely to change frequently. Not only can the class itself change, but any of its parent classes or data member classes can change also. This makes the support for schema evolution necessary.; ROOT fully supports schema evolution. The next figure below illustrates some of the scenarios. The ROOT schema evolution. The top half represents different versions of the shared library with the class definitions. These are the in-memory class versions. The bottom half represents data files that contain different versions of the classes. An old version of a shared library and a file with new class definitions - this can be the case when someone has not updated the library and is reading a new file.; Reading a file with a shared library that is missing a class definition (i.e. missing class D).; Reading a file without any class definitions. This can be the case where the class definition is lost, or unavailable.; The current version of a shared library and an old file with old class versions (backward compatibility). This is often the case when reading old data.; Reading a file with a shared library built with MakeProject. This is the case when someone has already read the data without a shared library and has used ROOT MakeProject feature to reconstruct the class definitions and shared library (MakeProject is explained in detail later on). In case of a mismatch between the in-memory version and the persistent version of a class, ROOT maps the persistent one to the one in memory. This allows you to change the class definition at will, for example:. Change the order of data members in the class.; Add",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:490318,update,updated,490318,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['update'],['updated']
Deployability,"ys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTEveJetConeGL::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveJetConeProjectedGL.html:2453,Update,UpdateBoundingBox,2453,root/html532/TEveJetConeProjectedGL.html,https://root.cern,https://root.cern/root/html532/TEveJetConeProjectedGL.html,2,['Update'],"['UpdateBoundingBox', 'UpdateBoundingBoxesOfPhysicals']"
Deployability,"ys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTPointSet3DGL::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTPointSet3DGL::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidTPointSet3DGL::SetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTPointSet3DGL::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveTrackGL.html:2380,Update,UpdateBoundingBox,2380,root/html532/TEveTrackGL.html,https://root.cern,https://root.cern/root/html532/TEveTrackGL.html,2,['Update'],"['UpdateBoundingBox', 'UpdateBoundingBoxesOfPhysicals']"
Deployability,"ysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidDLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveJetConeGL.html:2380,Update,UpdateBoundingBox,2380,root/html532/TEveJetConeGL.html,https://root.cern,https://root.cern/root/html532/TEveJetConeGL.html,2,['Update'],"['UpdateBoundingBox', 'UpdateBoundingBoxesOfPhysicals']"
Deployability,"ysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveBoxGL.html:2356,Update,UpdateBoundingBox,2356,root/html532/TEveBoxGL.html,https://root.cern,https://root.cern/root/html532/TEveBoxGL.html,6,['Update'],"['UpdateBoundingBox', 'UpdateBoundingBoxesOfPhysicals']"
Deployability,"ysicalShape* shape1, const TGLPhysicalShape* shape2); static Bool_tComparePhysicalVolumes(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); TGLScene&operator=(const TGLScene&). Data Members; public:. enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. Bool_tTGLSceneBase::fAutoDestruct; TGLBoundingBoxTGLSceneBase::fBoundingBoxbounding box for scene (axis aligned) - lazy update - use BoundingBox() to access; Bool_tTGLSceneBase::fBoundingBoxValidbounding box valid?; TGLClip*TGLSceneBase::fClipScene clipping-plane.; Bool_tTGLSceneBase::fDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tTGLSceneBase::fDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); TGLContextIdentity*fGLCtxIdentity; Bool_tfInSmartRefresh!; Short_tTGLSceneBase::fLODScene-lod.; Float_tfLastLineWidthScale; Float_tfLastPointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; map<TObject*,TGLLogicalShape*>fLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; Float_tTGLSceneBase::fOLLineWScene outline line-width.; map<unsigned int,TGLPhysicalShape*>fPhysicalShapes!; UInt_tTGLSceneBase::fSceneIDUnique scene id.; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; map<TObject*,TGLLogicalShape*>fSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneBase::fTimeStampCounter increased on every update.; TStringTGLSceneBase::fTitleObject title.; list<TGLViewerBase*>TGLSceneBase::fViewers; Float_tTGLSceneBase::fWFLineWScene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScene(); {}. ~TGLScene(); Destroy scene objects. void ReleaseGLCtxIdentity(); Release all GL resources for current context identity.; Requires iteration over all logical shapes. Bool_t ComparePhysicalVolumes(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLScene.html:6890,update,update,6890,root/html528/TGLScene.html,https://root.cern,https://root.cern/root/html528/TGLScene.html,6,['update'],['update']
Deployability,"ystems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent* ); Map the Qt mouse press button event to the ROOT TCanvas events; Mouse events occur when a mouse button is pressed or released inside; a widget or when the mouse cursor is moved. void mouseMoveEvent(QMouseEvent* ); Map the Qt mouse move pointer event to the ROOT TCanvas events; kMouseMotion = 51,; kButton1Motion = 21, kButton2Motion = 22, kButton3Motion = 23, kKeyPress = 24. void mouseReleaseEvent(QMouseEvent* ); Map the Qt mouse button release event to the ROOT TCanvas events; kButton1Up = 11, kButton2Up = 12, kButton3Up = 13. void mouseDoubleClickEvent(QMouseEvent* ); Map the Qt mouse double click button event to the ROOT TCanvas events; kButton1Double = 61, kButton2Double = 62, kButton3Double = 63. void keyPressEvent(QKeyEvent* ); Map the Qt key press event to the ROOT TCanvas events; kKeyDown = 4. void keyReleaseEvent(QKeyEvent* ); Map the Qt key release event to the ROOT TCanvas events; kKeyUp = 14. void enterEvent(QEvent* ); Map the Qt mouse enters widget event to the ROOT TCanvas events; kMouseEnter = 52. void leaveEvent(QEvent* ); Map the Qt mouse leaves widget event to the ROOT TCanvas events; kMouseLeave = 53. void resizeEvent(QResizeEvent* ); The widget will be erased and receive a paint event immediately after; processing the resize event.; No drawing need be (or should be) done inside this handler. void SetSaveFormat(const char* format); Set the default save format for the widget. bool Save(const char* fileName) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQtWidget.html:9763,release,release,9763,root/html528/TQtWidget.html,https://root.cern,https://root.cern/root/html528/TQtWidget.html,9,['release'],['release']
Deployability,"z file). If you have root access to your machine and want to make a system installation of FFTW. 2) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory; and type './configure' followed by 'make install'.; This will install fftw in /usr/local/bin,lib etc... 3) Start from a source installation of ROOT. If you now have a binary distribution,; first download a source tar ball from root.cern.ch for your ROOT version and untar it.; Run 'configure', following the instruction from 'configure --help' but be sure run 'configure'; with additional flags '--enable-fftw3' and '--enable-roofit', then run 'make'. If you do not have root access and want to make a private installation of FFTW. 2) Make a private install area for FFTW, e.g. /home/myself/fftw. 3) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory; and type './configure --prefix=/home/myself/fftw' followed by 'make install'.; Substitute /home/myself/fftw with a directory of your choice. This; procedure will install FFTW in the location designated by you. 4) Start from a source installation of ROOT. If you now have a binary distribution,; first download a source tar ball from root.cern.ch for your ROOT version and untar it.; Run 'configure', following the instruction from 'configure --help' but be sure run 'configure'; with additional flags; '--enable-fftw3',; '--with-fftw3-incdir=/home/myself/fftw/include',; '--width-fftw3-libdir=/home/myself/fftw/lib' and; '--enable-roofit'; Then run 'make'. Function Members (Methods); public:. RooFFTConvPdf(); RooFFTConvPdf(const RooFFTConvPdf& other, const char* name = 0); RooFFTConvPdf(const char* name, const char* title, RooRealVar& convVar, RooAbsPdf& pdf1, RooAbsPdf& pdf2, Int_t ipOrder = 2); RooFFTConvPdf(const char* name, const char* title, RooAbsReal& pdfConvVar, RooRealVar& convVar, RooAbsPdf& pdf1, RooAbsPdf& pdf2, Int_t ipOrder = 2); virtual~RooFFTConvPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:4304,install,install,4304,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,7,['install'],['install']
Deployability,"z file). If you have root access to your machine and want to make a system installation of FFTW. 2) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory; and type './configure' followed by 'make install'.; This will install fftw in /usr/local/bin,lib etc... 3) Start from a source installation of ROOT. If you now have a binary distribution,; first download a source tar ball from root.cern.ch for your ROOT version and untar it.; Run 'configure', following the instruction from 'configure --help' but be sure run 'configure'; with additional flags '--enable-fftw3' and '--enable-roofit', then run 'make'. If you do not have root access and want to make a private installation of FFTW. 2) Make a private install area for FFTW, e.g. /home/myself/fftw. 3) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory; and type './configure --prefix=/home/myself/fftw' followed by 'make install'.; Substitute /home/myself/fftw with a directory of your choice. This; procedure will install FFTW in the location designated by you. 4) Start from a source installation of ROOT. If you now have a binary distribution,; first download a source tar ball from root.cern.ch for your ROOT version and untar it.; Run 'configure', following the instruction from 'configure --help' but be sure run 'configure'; with additional flags; '--enable-fftw3',; '--with-fftw3-incdir=/home/myself/fftw/include',; '--width-fftw3-libdir=/home/myself/fftw/lib' and; '--enable-roofit'; Then run 'make'. Function Members (Methods); public:. virtual~RooFFTConvPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFFTConvPdf.html:4304,install,install,4304,root/html602/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html602/RooFFTConvPdf.html,4,['install'],['install']
Deployability,"zable C++ type or a container for a collection of sub fields. The RFieldBase and its type-safe descendants provide the object to column mapper. They map C++ objects to primitive columns. The mapping is trivial for simple types such as 'double'. Complex types resolve to multiple primitive columns. The field knows based on its type and the field name the type(s) and name(s) of the columns.; Note: the class hierarchy starting at RFieldBase is not meant to be extended by user-provided child classes. This is and can only be partially enforced through C++. ; Definition at line 67 of file RFieldBase.hxx. Classes; class  RBulk;  Similar to RValue but manages an array of consecutive values. More...;  ; struct  RBulkSpec;  ; struct  RCheckResult;  Used in the return value of the Check() method. More...;  ; class  RColumnRepresentations;  Some fields have multiple possible column representations, e.g. More...;  ; struct  RCreateObjectDeleter;  ; struct  RCreateObjectDeleter< void >;  ; class  RDeleter;  A functor to release the memory acquired by CreateValue (memory and constructor). More...;  ; class  RSchemaIteratorTemplate;  Iterates over the sub tree of fields in depth-first search order. More...;  ; struct  RSharedPtrDeleter;  ; class  RTypedDeleter;  A deleter for templated RFieldBase descendents where the value type is known. More...;  ; class  RValue;  Points to an object with RNTuple I/O support and keeps a pointer to the corresponding field. More...;  . Public Types; using ColumnRepresentation_t = std::vector< EColumnType >;  ; enum class  EState { kUnconnected; , kConnectedToSink; , kConnectedToSource; };  During its lifetime, a field undergoes the following possible state transitions: More...;  ; using RConstSchemaIterator = RSchemaIteratorTemplate< true >;  ; using RSchemaIterator = RSchemaIteratorTemplate< false >;  . Public Member Functions;  RFieldBase (const RFieldBase &)=delete;  ;  RFieldBase (RFieldBase &&)=default;  ;  RFieldBase (std::string_view name, st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html:1678,release,release,1678,doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,1,['release'],['release']
Deployability,"ze ; (; Int_t ; iBin = 0); const. virtual . returns the step size between the numbers of a ""discrete Interval"" ; Reimplemented in TMVA::LogInterval.; Definition at line 135 of file Interval.cxx. ◆ GetWidth(). Double_t TMVA::Interval::GetWidth ; (; ); const. virtual . Reimplemented in TMVA::LogInterval.; Definition at line 155 of file Interval.cxx. ◆ IsA(). virtual TClass * TMVA::Interval::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented in TMVA::LogInterval.; Definition at line 93 of file Interval.h. ◆ Log(). TMVA::MsgLogger & TMVA::Interval::Log ; (; ); const. private . Definition at line 171 of file Interval.cxx. ◆ Print(). void TMVA::Interval::Print ; (; std::ostream & ; os); const. virtual . Definition at line 164 of file Interval.cxx. ◆ SetMax(). void TMVA::Interval::SetMax ; (; Double_t ; m). inline . Definition at line 80 of file Interval.h. ◆ SetMin(). void TMVA::Interval::SetMin ; (; Double_t ; m). inline . Definition at line 81 of file Interval.h. ◆ Streamer(). virtual void TMVA::Interval::Streamer ; (; TBuffer & ; ). virtual . Reimplemented in TMVA::LogInterval. ◆ StreamerNVirtual(). void TMVA::Interval::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 93 of file Interval.h. Member Data Documentation. ◆ fMax. Double_t TMVA::Interval::fMax. protected . the constraints of the Interval ; Definition at line 87 of file Interval.h. ◆ fMin. Double_t TMVA::Interval::fMin. protected . Definition at line 87 of file Interval.h. ◆ fNbins. Int_t TMVA::Interval::fNbins. protected . when >0 : number of bins (discrete interval); when ==0 continuous interval ; Definition at line 88 of file Interval.h. Libraries for TMVA::Interval:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/Interval.h; tmva/tmva/src/Interval.cxx. TMVAInterval. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Interval.html:6931,continuous,continuous,6931,doc/master/classTMVA_1_1Interval.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Interval.html,1,['continuous'],['continuous']
Deployability,"ze estimator / train network with backpropagation algorithm. void TrainOneEpoch(); train network over a single epoch/cyle of events. void Shuffle(Int_t* index, Int_t n); Input:; index: the array to shuffle; n: the size of the array; Output:; index: the shuffled indexes; This method is used for sequential training. void DecaySynapseWeights(Bool_t lateEpoch); decay synapse weights; in last 10 epochs, lower learning rate even more to find a good minimum. void TrainOneEventFast(Int_t ievt, Float_t*& branchVar, Int_t& type); fast per-event training. void TrainOneEvent(Int_t ievt); train network over a single event; this uses the new event model. Double_t GetDesiredOutput(const TMVA::Event* ev); get the desired output of this event. void UpdateNetwork(Double_t desired, Double_t eventWeight = 1.0); update the network based on how closely; the output matched the desired output. void UpdateNetwork(const vector<Float_t>& desired, Double_t eventWeight = 1.0); update the network based on how closely; the output matched the desired output. void CalculateNeuronDeltas(); have each neuron calculate its delta by backpropagation. void GeneticMinimize(); create genetics class similar to GeneticCut; give it vector of parameter ranges (parameters = weights); link fitness function of this class to ComputeEstimator; instantiate GA (see MethodCuts); run it; then this should exist for GA, Minuit and random sampling. Double_t EstimatorFunction(vector<Double_t>& parameters); interface to the estimate. Double_t ComputeEstimator(vector<Double_t>& parameters); this function is called by GeneticANN for GA optimization. void UpdateSynapses(); update synapse error fields and adjust the weights (if in sequential mode). void AdjustSynapseWeights(); just adjust the synapse weights (should be called in batch mode). void UpdatePriors(). void UpdateRegulators(). void GetApproxInvHessian(TMatrixD& InvHessian, bool regulate = true). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0). void MakeC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodMLP.html:25900,update,update,25900,root/html534/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodMLP.html,2,['update'],['update']
Deployability,"ze of memory mapped region; Double_tfSum2BufferSum of squares of buffer sizes of objects written so far; Double_tfSumBufferSum of buffer sizes of objects written sofar; char*fTitleTitle of mapped file; Int_tfVersionROOT version (or -1 for shadow map file); Bool_tfWritableTRUE if mapped file opened in RDWR mode; Int_tfWrittenNumber of objects written sofar; static Long_tfgMapAddressMap to this address, set address via SetMapAddress(); static void*fgMmallocDescUsed in Close() and operator delete(); ULong_tfhSemaphoreHANDLE of WIN32 Mutex object to implement semaphore. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMapFile(); Default ctor. Does not much except setting some basic values. TMapFile(const char* name, const char* title, Option_t* option, Int_t size, TMapFile*& newMapFile); Create a memory mapped file. This opens a file (to which the; memory will be mapped) and attaches a memory region to it.; Option can be either: ""NEW"", ""CREATE"", ""RECREATE"", ""UPDATE"" or; ""READ"" (see TFile). The default open mode is ""READ"". The size; argument specifies the maximum size of shared memory file in bytes.; This protected ctor is called via the static Create() method. TMapFile(const TMapFile& f, Long_t offset = 0); Private copy ctor. Used by the the ctor to create a new version; of TMapFile in the memory mapped heap. It's main purpose is to; correctly create the string data members. ~TMapFile(); TMapFiles may not be deleted, since we want to keep the complete; TMapFile object in the mapped file for later re-use. To enforce this; the delete operator has been made private. Use Close() to properly; terminate a TMapFile (also done via the TROOT dtor). void InitDirectory(); Create the directory associated to this mapfile. void Add(const TObject* obj, const char* name = """"); Add an object to the list of objects to be stored in shared memory.; To place the object actually into shared memory call Update(). void Update(TObject* obj = 0); Update ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMapFile.html:9990,UPDATE,UPDATE,9990,root/html532/TMapFile.html,https://root.cern,https://root.cern/root/html532/TMapFile.html,4,['UPDATE'],['UPDATE']
Deployability,"ze+sizeof(Int_t)];; 513 }; 514 char *buffer = fBuffer+nsize;; 515 Int_t nbytesleft = -fLeft; // set header of remaining record; 516 tobuf(buffer, nbytesleft);; 517 bestfree->SetFirst(fSeekKey+nsize);; 518 }; 519 ; 520 fSeekPdir = externFile ? externFile->GetSeekDir() : fMotherDir->GetSeekDir();; 521}; 522 ; 523////////////////////////////////////////////////////////////////////////////////; 524/// TKey default destructor.; 525 ; 526TKey::~TKey(); 527{; 528 if (fMotherDir && fMotherDir->GetListOfKeys()); 529 fMotherDir->GetListOfKeys()->Remove(this);; 530 TKey::DeleteBuffer();; 531}; 532 ; 533////////////////////////////////////////////////////////////////////////////////; 534/// Delete an object from the file.; 535///; 536/// Note: the key is not deleted. You still have to call ""delete key"".; 537/// This is different from the behaviour of TObject::Delete()!; 538 ; 539void TKey::Delete(Option_t *option); 540{; 541 if (TestBit(kIsDirectoryFile)) {; 542 // TDirectoryFile assumes that its location on file never change (for example updates are partial); 543 // and never checks if the space might have been released and thus over-write any data that might; 544 // have been written there.; 545 if (option && option[0] == 'v'); 546 printf(""Rejected attempt to delete TDirectoryFile key: %s at address %lld, nbytes = %d\n"",; 547 GetName(), fSeekKey, fNbytes);; 548 return;; 549 }; 550 if (option && option[0] == 'v') printf(""Deleting key: %s at address %lld, nbytes = %d\n"",GetName(),fSeekKey,fNbytes);; 551 Long64_t first = fSeekKey;; 552 Long64_t last = fSeekKey + fNbytes -1;; 553 if (GetFile()) GetFile()->MakeFree(first, last); // release space used by this key; 554 fMotherDir->GetListOfKeys()->Remove(this);; 555}; 556 ; 557////////////////////////////////////////////////////////////////////////////////; 558/// Delete key buffer(s).; 559 ; 560void TKey::DeleteBuffer(); 561{; 562 if (fBufferRef) {; 563 delete fBufferRef;; 564 fBufferRef = 0;; 565 } else {; 566 // We only need to de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TKey_8cxx_source.html:19293,update,updates,19293,doc/master/TKey_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html,2,"['release', 'update']","['released', 'updates']"
Deployability,"zed configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3308 ; 3309const RooNumIntConfig* RooAbsReal::getIntegratorConfig() const; 3310{; 3311 const RooNumIntConfig* config = specialIntegratorConfig() ;; 3312 if (config) return config ;; 3313 return defaultIntegratorConfig() ;; 3314}; 3315 ; 3316 ; 3317////////////////////////////////////////////////////////////////////////////////; 3318/// Return the numeric integration configuration used for this object. If; 3319/// a specialized configuration was associated with this object, that configuration; 3320/// is returned, otherwise the default configuration for all RooAbsReals is returned; 3321 ; 3322RooNumIntConfig* RooAbsReal::getIntegratorConfig(); 3323{; 3324 RooNumIntConfig* config = specialIntegratorConfig() ;; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:142639,integrat,integration,142639,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,2,"['configurat', 'integrat']","['configuration', 'integration']"
Deployability,"zer.; Definition at line 121 of file BasicMinimizer.h. ◆ NFree(). unsigned int ROOT::Math::BasicMinimizer::NFree ; (; ); const. overridevirtual . number of free variables (real dimension of the problem) ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 330 of file BasicMinimizer.cxx. ◆ NPar(). virtual unsigned int ROOT::Math::BasicMinimizer::NPar ; (; ); const. inlinevirtual . total number of parameter defined ; Definition at line 127 of file BasicMinimizer.h. ◆ ObjFunction(). const ROOT::Math::IMultiGenFunction * ROOT::Math::BasicMinimizer::ObjFunction ; (; ); const. inline . return pointer to used objective function ; Definition at line 130 of file BasicMinimizer.h. ◆ PrintResult(). void ROOT::Math::BasicMinimizer::PrintResult ; (; ); const. print result of minimization ; Definition at line 313 of file BasicMinimizer.cxx. ◆ ReleaseVariable(). bool ROOT::Math::BasicMinimizer::ReleaseVariable ; (; unsigned int ; ivar). overridevirtual . release an existing variable ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 189 of file BasicMinimizer.cxx. ◆ SetFinalValues(). void ROOT::Math::BasicMinimizer::SetFinalValues ; (; const double * ; x, . const MinimTransformFunction * ; func = nullptr . ). protected . Definition at line 300 of file BasicMinimizer.cxx. ◆ SetFixedVariable(). bool ROOT::Math::BasicMinimizer::SetFixedVariable ; (; unsigned int ; ivar, . const std::string & ; name, . double ; val . ). overridevirtual . set fixed variable (override if minimizer supports them ) ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 116 of file BasicMinimizer.cxx. ◆ SetFunction(). void ROOT::Math::BasicMinimizer::SetFunction ; (; const ROOT::Math::IMultiGenFunction & ; func). overridevirtual . set the function to minimize ; Implements ROOT::Math::Minimizer.; Reimplemented in ROOT::Math::GSLMinimizer, and ROOT::Math::GSLNLSMinimizer.; Definition at line 240 of file BasicMinimizer.cxx. ◆ SetLimitedVariable(). bool ROOT::Math::BasicMinimize",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1BasicMinimizer.html:15526,release,release,15526,doc/master/classROOT_1_1Math_1_1BasicMinimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1BasicMinimizer.html,1,['release'],['release']
Deployability,"zero errors (empty bins);; 3971/// - the full range of the histogram is used;; 3972/// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; 3973/// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; 3974/// - only the status of the fit is returned;; 3975/// - the fit is performed in Multithread whenever is enabled in ROOT;; 3976/// - only the last fitted function is saved in the histogram;; 3977/// - the histogram is drawn after fitting overalyed with the resulting fitting function; 3978///; 3979/// \anchor HFitMinimizer; 3980/// ### Minimizer Configuration; 3981///; 3982/// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; 3983/// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1::Fit`):; 3984/// - `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(minimizerName, minimizerAgorithm)` for changing the minmizer and/or the corresponding algorithm.; 3985/// For example `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization; 3986/// The current defaults are (""Minuit"",""Migrad"").; 3987/// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; 3988/// - `ROOT::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance value for the minimization.; 3989/// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; 3990/// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; 3991///; 3992/// Other options are possible dependi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:160654,configurat,configuration,160654,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['configurat'],['configuration']
Deployability,"zeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCanvas.html:46280,Toggle,ToggleEditor,46280,root/html602/TCanvas.html,https://root.cern,https://root.cern/root/html602/TCanvas.html,4,['Toggle'],"['Toggle', 'ToggleEditor']"
Deployability,"zeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported.; gPad must exist (otherwise this call has no sense), and; either it's a gl-pad or we are on OS X with --enable-cocoa. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == fals",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCanvas.html:45393,Toggle,ToggleEditor,45393,root/html534/TCanvas.html,https://root.cern,https://root.cern/root/html534/TCanvas.html,2,['Toggle'],"['Toggle', 'ToggleEditor']"
Deployability,"{; 2420 return _verboseEval ;; 2421}; 2422 ; 2423 ; 2424 ; 2425////////////////////////////////////////////////////////////////////////////////; 2426/// Destructor of normalization cache element. If this element; 2427/// provides the 'current' normalization stored in RooAbsPdf::_norm; 2428/// zero _norm pointer here before object pointed to is deleted here; 2429 ; 2430RooAbsPdf::CacheElem::~CacheElem(); 2431{; 2432 // Zero _norm pointer in RooAbsPdf if it is points to our cache payload; 2433 if (_owner) {; 2434 RooAbsPdf* pdfOwner = static_cast<RooAbsPdf*>(_owner) ;; 2435 if (pdfOwner->_norm == _norm.get()) {; 2436 pdfOwner->_norm = nullptr ;; 2437 }; 2438 }; 2439}; 2440 ; 2441 ; 2442 ; 2443////////////////////////////////////////////////////////////////////////////////; 2444/// Return a p.d.f that represent a projection of this p.d.f integrated over given observables; 2445 ; 2446RooAbsPdf* RooAbsPdf::createProjection(const RooArgSet& iset); 2447{; 2448 // Construct name for new object; 2449 std::string name = std::string{GetName()} + ""_Proj["" + RooHelpers::getColonSeparatedNameString(iset, ',') + ""]"";; 2450 ; 2451 // Return projected p.d.f.; 2452 return new RooProjectedPdf(name.c_str(),name.c_str(),*this,iset) ;; 2453}; 2454 ; 2455 ; 2456 ; 2457////////////////////////////////////////////////////////////////////////////////; 2458/// Create a cumulative distribution function of this p.d.f in terms; 2459/// of the observables listed in iset. If no nset argument is given; 2460/// the c.d.f normalization is constructed over the integrated; 2461/// observables, so that its maximum value is precisely 1. It is also; 2462/// possible to choose a different normalization for; 2463/// multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; 2464/// construct a partial cdf c(x,y) that only when integrated itself; 2465/// over z results in a maximum value of 1. To construct such a cdf pass; 2466/// z as argument to the optional nset argument; 2467 ; 2468RooFit::OwningPtr<RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:117253,integrat,integrated,117253,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['integrat'],['integrated']
Deployability,"{; 934 // We are in a directory, which may possibly be a file.; 935 if (fDirectory->GetList()) {; 936 // Remove us from the directory listing.; 937 fDirectory->Remove(this);; 938 }; 939 //delete the file cache if it points to this Tree; 940 TFile *file = fDirectory->GetFile();; 941 MoveReadCache(file,nullptr);; 942 }; 943 ; 944 // Remove the TTree from any list (linked to to the list of Cleanups) to avoid the unnecessary call to; 945 // this RecursiveRemove while we delete our content.; 946 ROOT::CallRecursiveRemoveIfNeeded(*this);; 947 ResetBit(kMustCleanup); // Don't redo it.; 948 ; 949 // We don't own the leaves in fLeaves, the branches do.; 950 fLeaves.Clear();; 951 // I'm ready to destroy any objects allocated by; 952 // SetAddress() by my branches. If I have clones,; 953 // tell them to zero their pointers to this shared; 954 // memory.; 955 if (fClones && fClones->GetEntries()) {; 956 // I have clones.; 957 // I am about to delete the objects created by; 958 // SetAddress() which we are sharing, so tell; 959 // the clones to release their pointers to them.; 960 for (TObjLink* lnk = fClones->FirstLink(); lnk; lnk = lnk->Next()) {; 961 TTree* clone = (TTree*) lnk->GetObject();; 962 // clone->ResetBranchAddresses();; 963 ; 964 // Reset only the branch we have set the address of.; 965 CopyAddresses(clone,true);; 966 }; 967 }; 968 // Get rid of our branches, note that this will also release; 969 // any memory allocated by TBranchElement::SetAddress().; 970 fBranches.Delete();; 971 ; 972 // The TBranch destructor is using fDirectory to detect whether it; 973 // owns the TFile that contains its data (See TBranch::~TBranch); 974 fDirectory = nullptr;; 975 ; 976 // FIXME: We must consider what to do with the reset of these if we are a clone.; 977 delete fPlayer;; 978 fPlayer = nullptr;; 979 if (fExternalFriends) {; 980 using namespace ROOT::Detail;; 981 for(auto fetree : TRangeStaticCast<TFriendElement>(*fExternalFriends)); 982 fetree->Reset();; 983 fExternalFriends->C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:34729,release,release,34729,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['release'],['release']
Deployability,"{});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with give",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:16298,integrat,integrator,16298,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,2,"['configurat', 'integrat']","['configuration', 'integrator']"
Deployability,"}. MnUserParameterState operator()(const FCNBase&, const std::vector<double>&, const std::vector<double>&, unsigned int maxcalls=0). low-level API. FCN + parameters + errors. MnUserParameterState operator()(const ROOT::Minuit2::FCNBase& , const vector<double>& , unsigned int nrow, const vector<double>& , unsigned int maxcalls = 0) const; FCN + parameters + covariance. MnUserParameterState operator()(const FCNBase&, const std::vector<double>&, const MnUserCovariance&, unsigned int maxcalls=0); FCN + parameters + MnUserCovariance. MnUserParameterState operator()(const FCNBase&, const MnUserParameters&, unsigned int maxcalls=0). high-level API. FCN + MnUserParameters. MnUserParameterState operator()(const FCNBase&, const MnUserParameters&, const MnUserCovariance&, unsigned int maxcalls=0); FCN + MnUserParameters + MnUserCovariance. MnUserParameterState operator()(const FCNBase&, const MnUserParameterState&, unsigned int maxcalls=0); FCN + MnUserParameterState. void operator()(const ROOT::Minuit2::FCNBase& , ROOT::Minuit2::FunctionMinimum& , unsigned int maxcalls = 0) const. API to use MnHesse after minimization when function mimimum is avalilable, otherwise information on the last state will be; lost. (It would be needed to re-call the gradient and spend extra useless function calls); The Function Minimum is updated (modified) by adding the Hesse results as last state of minimization. MinimumState operator()(const MnFcn&, const MinimumState&, const MnUserTransformation&, unsigned int maxcalls=0); internal interface. unsigned int Ncycles() const; forward interface of MnStrategy. {return fStrategy.HessianNCycles();}. double Tolerstp() const; {return fStrategy.HessianStepTolerance();}. double TolerG2() const; {return fStrategy.HessianG2Tolerance();}. » Last changed: root/minuit2:$Id$ » Last generated: 2015-06-30 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Minuit2__MnHesse.html:3849,update,updated,3849,root/html602/ROOT__Minuit2__MnHesse.html,https://root.cern,https://root.cern/root/html602/ROOT__Minuit2__MnHesse.html,2,['update'],['updated']
Deployability,"}. MnUserParameterState operator()(const FCNBase&, const std::vector<double>&, const std::vector<double>&, unsigned int maxcalls=0). low-level API. FCN + parameters + errors. MnUserParameterState operator()(const ROOT::Minuit2::FCNBase& , const vector<double>& , unsigned int nrow, const vector<double>& , unsigned int maxcalls = 0) const; FCN + parameters + covariance. MnUserParameterState operator()(const FCNBase&, const std::vector<double>&, const MnUserCovariance&, unsigned int maxcalls=0); FCN + parameters + MnUserCovariance. MnUserParameterState operator()(const FCNBase&, const MnUserParameters&, unsigned int maxcalls=0). high-level API. FCN + MnUserParameters. MnUserParameterState operator()(const FCNBase&, const MnUserParameters&, const MnUserCovariance&, unsigned int maxcalls=0); FCN + MnUserParameters + MnUserCovariance. MnUserParameterState operator()(const FCNBase&, const MnUserParameterState&, unsigned int maxcalls=0); FCN + MnUserParameterState. void operator()(const ROOT::Minuit2::FCNBase& , ROOT::Minuit2::FunctionMinimum& , unsigned int maxcalls = 0) const. API to use MnHesse after minimization when function mimimum is avalilable, otherwise information on the last state will be; lost. (It would be needed to re-call the gradient and spend extra useless function calls); The Function Minimum is updated (modified) by adding the Hesse results as last state of minimization. MinimumState operator()(const MnFcn&, const MinimumState&, const MnUserTransformation&, unsigned int maxcalls=0); internal interface. unsigned int Ncycles() const; forward interface of MnStrategy. {return fStrategy.HessianNCycles();}. double Tolerstp() const; {return fStrategy.HessianStepTolerance();}. double TolerG2() const; {return fStrategy.HessianG2Tolerance();}. » Last changed: root/minuit2:$Id$ » Last generated: 2015-09-08 17:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Minuit2__MnHesse.html:3849,update,updated,3849,root/html534/ROOT__Minuit2__MnHesse.html,https://root.cern,https://root.cern/root/html534/ROOT__Minuit2__MnHesse.html,2,['update'],['updated']
Deployability,"}. MnUserParameterState operator()(const FCNBase&, const std::vector<double>&, const std::vector<double>&, unsigned int maxcalls=0). low-level API. FCN + parameters + errors. MnUserParameterState operator()(const ROOT::Minuit2::FCNBase& , const vector<double>& , unsigned int nrow, const vector<double>& , unsigned int maxcalls = 0) const; FCN + parameters + covariance. MnUserParameterState operator()(const FCNBase&, const std::vector<double>&, const MnUserCovariance&, unsigned int maxcalls=0); FCN + parameters + MnUserCovariance. MnUserParameterState operator()(const FCNBase&, const MnUserParameters&, unsigned int maxcalls=0). high-level API. FCN + MnUserParameters. MnUserParameterState operator()(const FCNBase&, const MnUserParameters&, const MnUserCovariance&, unsigned int maxcalls=0); FCN + MnUserParameters + MnUserCovariance. MnUserParameterState operator()(const FCNBase&, const MnUserParameterState&, unsigned int maxcalls=0); FCN + MnUserParameterState. void operator()(const ROOT::Minuit2::FCNBase& , ROOT::Minuit2::FunctionMinimum& , unsigned int maxcalls = 0) const. API to use MnHesse after minimization when function mimimum is avalilable, otherwise information on the last state will be; lost. (It would be needed to re-call the gradient and spend extra useless function calls); The Function Minimum is updated (modified) by adding the Hesse results as last state of minimization. MinimumState operator()(const MnFcn&, const MinimumState&, const MnUserTransformation&, unsigned int maxcalls=0); internal interface. unsigned int Ncycles() const; forward interface of MnStrategy. {return fStrategy.HessianNCycles();}. double Tolerstp() const; {return fStrategy.HessianStepTolerance();}. double TolerG2() const; {return fStrategy.HessianG2Tolerance();}. » Last changed: root/minuit2:$Id$ » Last generated: 2015-09-08 17:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Minuit2__MnHesse.html:3849,update,updated,3849,root/html604/ROOT__Minuit2__MnHesse.html,https://root.cern,https://root.cern/root/html604/ROOT__Minuit2__MnHesse.html,2,['update'],['updated']
Deployability,"}. unsigned int NumOfCalls() const; {return fNumCall;}. const std::vector<ROOT::Minuit2::MinuitParameter>& MinuitParameters() const; facade: forward interface of MnUserParameters and MnUserTransformation; via MnUserParameterState; access to parameters (row-wise). std::vector<double> Params() const; access to parameters and errors in column-wise representation. std::vector<double> Errors() const. void Add(const char* Name, double val, double err); add free Parameter. void Add(const char* Name, double val, double err, double , double ); add limited Parameter. void Add(const char* , double ); add const Parameter. void Fix(unsigned int ); interaction via external number of Parameter. void Release(unsigned int ). void SetValue(unsigned int , double ). void SetError(unsigned int , double ). void SetLimits(unsigned int , double , double ). void RemoveLimits(unsigned int ). double Value(unsigned int ) const. double Error(unsigned int ) const. void Fix(const char* ); interaction via Name of Parameter. void Release(const char* ). void SetValue(const char* , double ). void SetError(const char* , double ). void SetLimits(const char* , double , double ). void RemoveLimits(const char* ). void SetPrecision(double ). double Value(const char* ) const. double Error(const char* ) const. unsigned int Index(const char* ) const; convert Name into external number of Parameter. const char* Name(unsigned int ) const; convert external number into Name of Parameter. double Int2ext(unsigned int , double ) const; transformation internal <-> external. double Ext2int(unsigned int , double ) const. unsigned int IntOfExt(unsigned int ) const. unsigned int ExtOfInt(unsigned int ) const. unsigned int VariableParameters() const. » Last changed: root/minuit2:$Id: MnApplication.h 25486 2008-09-22 12:43:03Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Minuit2__MnApplication.html:4213,Release,Release,4213,root/html532/ROOT__Minuit2__MnApplication.html,https://root.cern,https://root.cern/root/html532/ROOT__Minuit2__MnApplication.html,1,['Release'],['Release']
Deployability,"}; 497 recreate = kFALSE;; 498 create = kTRUE;; 499 fOption = ""CREATE"";; 500 }; 501 if (create && !devnull && !gSystem->AccessPathName(fname.Data(), kFileExists)) {; 502 Error(""TFile"", ""file %s already exists"", fname.Data());; 503 zombify();; 504 return;; 505 }; 506 if (update) {; 507 if (gSystem->AccessPathName(fname.Data(), kFileExists)) {; 508 update = kFALSE;; 509 create = kTRUE;; 510 }; 511 if (update && gSystem->AccessPathName(fname.Data(), kWritePermission)) {; 512 Error(""TFile"", ""no write permission, could not open file %s"", fname.Data());; 513 zombify();; 514 return;; 515 }; 516 }; 517 if (read) {; 518 if (gSystem->AccessPathName(fname.Data(), kFileExists)) {; 519 Error(""TFile"", ""file %s does not exist"", fname.Data());; 520 zombify();; 521 return;; 522 }; 523 if (gSystem->AccessPathName(fname.Data(), kReadPermission)) {; 524 Error(""TFile"", ""no read permission, could not open file %s"", fname.Data());; 525 zombify();; 526 return;; 527 }; 528 }; 529 ; 530 // Connect to file system stream; 531 if (create || update) {; 532#ifndef WIN32; 533 fD = TFile::SysOpen(fname.Data(), O_RDWR | O_CREAT, 0644);; 534#else; 535 fD = TFile::SysOpen(fname.Data(), O_RDWR | O_CREAT | O_BINARY, S_IREAD | S_IWRITE);; 536#endif; 537 if (fD == -1) {; 538 SysError(""TFile"", ""file %s can not be opened"", fname.Data());; 539 zombify();; 540 return;; 541 }; 542 fWritable = kTRUE;; 543 } else {; 544#ifndef WIN32; 545 fD = TFile::SysOpen(fname.Data(), O_RDONLY, 0644);; 546#else; 547 fD = TFile::SysOpen(fname.Data(), O_RDONLY | O_BINARY, S_IREAD | S_IWRITE);; 548#endif; 549 if (fD == -1) {; 550 SysError(""TFile"", ""file %s can not be opened for reading"", fname.Data());; 551 zombify();; 552 return;; 553 }; 554 fWritable = kFALSE;; 555 }; 556 ; 557 // calling virtual methods from constructor not a good idea, but it is how code was developed; 558 TFile::Init(create); // NOLINT: silence clang-tidy warnings; 559}; 560 ; 561//////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:20211,update,update,20211,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['update'],['update']
Deployability,"};; ; // P r o j e c t p d f a n d d a t a o n x; // -------------------------------------------------; ; // Make plain projection of data and pdf on x observable; RooPlot *frame = x.frame(Title(""Projection of 3D data and pdf on X""), Bins(40));; data->plotOn(frame);; model.plotOn(frame);; ; // P r o j e c t p d f a n d d a t a o n x i n s i g n a l r a n g e; // ----------------------------------------------------------------------------------; ; // Define signal region in y and z observables; y.setRange(""sigRegion"", -1, 1);; z.setRange(""sigRegion"", -1, 1);; ; // Make plot frame; RooPlot *frame2 = x.frame(Title(""Same projection on X in signal range of (Y,Z)""), Bins(40));; ; // Plot subset of data in which all observables are inside ""sigRegion""; // For observables that do not have an explicit ""sigRegion"" range defined (e.g. observable); // an implicit definition is used that is identical to the full range (i.e. [-5,5] for x); data->plotOn(frame2, CutRange(""sigRegion""));; ; // Project model on x, integrating projected observables (y,z) only in ""sigRegion""; model.plotOn(frame2, ProjectionRange(""sigRegion""));; ; TCanvas *c = new TCanvas(""rf311_rangeplot"", ""rf310_rangeplot"", 800, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.4);; frame2->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooAddPdf.h; RooConstVar.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooPolynomial.h; RooProdPdf.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf311__rangeplot_8C.html:2539,integrat,integrating,2539,doc/master/rf311__rangeplot_8C.html,https://root.cern,https://root.cern/doc/master/rf311__rangeplot_8C.html,1,['integrat'],['integrating']
Deployability,"};; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooAbsData*fData; RooAbsReal*fIntegratedLikelihood; RooStats::SimpleInterval*fIntervalcached pointer to resulting interval; RooAbsReal*fLikelihood; RooAbsReal*fLogLike; RooArgSetfNuisanceParameters; RooArgSetfPOI; RooAbsPdf*fPdf; RooAbsPdf*fPosteriorPdf; RooAbsPdf*fPriorPOI; RooAbsPdf*fProductPdf; doublefSizesize used for getting the interval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BayesianCalculator(); default constructor. Need to call the Setter methods afterwards. BayesianCalculator( /* const char* name, const char* title, */ RooAbsData& data, RooAbsPdf& pdf,						 const RooArgSet& POI,						 RooAbsPdf& priorPOI,						 const RooArgSet* nuisanceParameters ); TNamed( TString(name), TString(title) ),; constructor from data set, model pdf, set with the parameter of interest; (must contain only one parameter for the moment) and prior pdf; Optionally an additional set of parameters can be specified (nuisance parameters); which will be integrated (marginalized) when creating the posterior pdf.; A default size of 0.05 is used (for 95% CL interval). BayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); Same constructor but from data and a ModelConfig describing the model pdf and the prior, the parameter; of interest and the nuisance parameters. ~BayesianCalculator(); destructor cleaning all managed objects. void ClearAll() const; clear cached pdf objects (posterior pdf, Likelihood, NLL, etc.). void SetModel(const RooStats::ModelConfig& model); set the model configuration. RooArgSet* GetMode(RooArgSet* parameters) const; return the mode (not yet implemented) but can be easly obtained from; GetPosteriorPdf()->asTF(poi)->GetMaximumX();. RooAbsPdf* GetPosteriorPdf() const; get the posterior pdf as a RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__BayesianCalculator.html:8086,integrat,integrated,8086,root/html526/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__BayesianCalculator.html,1,['integrat'],['integrated']
Deployability,"};; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. _xmlParserCtxt*TXMLParser::fContextparse the xml file; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTXMLParser::fParseCodeto keep track of the errorcodes; Bool_tTXMLParser::fReplaceEntitiesreplace entities; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTXMLParser::fStopErrorstop when parse error occurs; Bool_tTXMLParser::fValidateto validate the parse context; TStringTXMLParser::fValidateErrorparse error; TStringTXMLParser::fValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TXMLDocument*fTXMLDocxmlDoc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDOMParser(); TDOMParser constructor. ~TDOMParser(); TDOMParser destructor, it calls ReleaseUnderlying(). void ReleaseUnderlying(); Release any existing document. Int_t ParseFile(const char* filename); Parse the XML file where filename is the XML file name.; It will create a TXMLDocument if the file is parsed without; any error. It returns parse code error in case of parse error,; see TXMLParser. Int_t ParseBuffer(const char* buffer, Int_t len); It parses a buffer, much like ParseFile(). Int_t ParseContext(); Creates a XML document for the parser.; It returns 0 on success, and; -1 if no XML document was created,; -5 if the document is not well formated,; -6 if document is not valid. TXMLDocument * GetXMLDocument() const; Returns the TXMLDocument. TDOMParser(const TDOMParser& ). TDOMParser& operator=(const TDOMParser& ). » Author: Jose Lo 12/4/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/xmlparser:$Id$ » Last generated: 2015-03-12 16:38; This page has been automatically generated. For comments or suggestions regard",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDOMParser.html:10551,Release,ReleaseUnderlying,10551,root/html534/TDOMParser.html,https://root.cern,https://root.cern/root/html534/TDOMParser.html,1,['Release'],['ReleaseUnderlying']
Deployability,"};; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. _xmlParserCtxt*TXMLParser::fContextparse the xml file; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTXMLParser::fParseCodeto keep track of the errorcodes; Bool_tTXMLParser::fReplaceEntitiesreplace entities; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTXMLParser::fStopErrorstop when parse error occurs; Bool_tTXMLParser::fValidateto validate the parse context; TStringTXMLParser::fValidateErrorparse error; TStringTXMLParser::fValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TXMLDocument*fTXMLDocxmlDoc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDOMParser(); TDOMParser constructor. ~TDOMParser(); TDOMParser destructor, it calls ReleaseUnderlying(). void ReleaseUnderlying(); Release any existing document. Int_t ParseFile(const char* filename); Parse the XML file where filename is the XML file name.; It will create a TXMLDocument if the file is parsed without; any error. It returns parse code error in case of parse error,; see TXMLParser. Int_t ParseBuffer(const char* buffer, Int_t len); It parses a buffer, much like ParseFile(). Int_t ParseContext(); Creates a XML document for the parser.; It returns 0 on success, and; -1 if no XML document was created,; -5 if the document is not well formated,; -6 if document is not valid. TXMLDocument * GetXMLDocument() const; Returns the TXMLDocument. TDOMParser(const TDOMParser& ). TDOMParser& operator=(const TDOMParser& ). » Author: Jose Lo 12/4/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/xmlparser:$Id: TDOMParser.h 23637 2008-05-02 11:12:04Z rdm $ » Last generated: 2011-11-03 20:11; This page has been automatically",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDOMParser.html:10532,Release,ReleaseUnderlying,10532,root/html532/TDOMParser.html,https://root.cern,https://root.cern/root/html532/TDOMParser.html,1,['Release'],['ReleaseUnderlying']
Deployability,"~~; 6674/// ""option"" can be used select some of the optional features during; 6675/// the code generation. The possible options are:; 6676///; 6677/// - nohist : indicates that the generated ProcessFill should not fill the histogram.; 6678///; 6679/// 'maxUnrolling' controls how deep in the class hierarchy does the; 6680/// system 'unroll' classes that are not split. Unrolling a class; 6681/// allows direct access to its data members (this emulates the behavior; 6682/// of TTreeFormula).; 6683///; 6684/// The main features of this skeleton are:; 6685///; 6686/// * on-demand loading of branches; 6687/// * ability to use the 'branchname' as if it was a data member; 6688/// * protection against array out-of-bounds errors; 6689/// * ability to use the branch data as an object (when the user code is available); 6690///; 6691/// For example with Event.root, if; 6692/// ~~~ {.cpp}; 6693/// Double_t somePx = fTracks.fPx[2];; 6694/// ~~~; 6695/// is executed by one of the method of the skeleton,; 6696/// somePx will updated with the current value of fPx of the 3rd track.; 6697///; 6698/// Both macrofilename and the optional cutfilename are expected to be; 6699/// the name of source files which contain at least a free standing; 6700/// function with the signature:; 6701/// ~~~ {.cpp}; 6702/// x_t macrofilename(); // i.e function with the same name as the file; 6703/// ~~~; 6704/// and; 6705/// ~~~ {.cpp}; 6706/// y_t cutfilename(); // i.e function with the same name as the file; 6707/// ~~~; 6708/// x_t and y_t needs to be types that can convert respectively to a double; 6709/// and a bool (because the skeleton uses:; 6710///; 6711/// if (cutfilename()) htemp->Fill(macrofilename());; 6712///; 6713/// These two functions are run in a context such that the branch names are; 6714/// available as local variables of the correct (read-only) type.; 6715///; 6716/// Note that if you use the same 'variable' twice, it is more efficient; 6717/// to 'cache' the value. For example:; 6718/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:261596,update,updated,261596,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['update'],['updated']
Deployability," ; , . Int_t ; , . Int_t ; , . Double_t ;  . ). inlineoverrideprotectedvirtual . NOT IMPLEMENTED for TH2Poly. ; Reimplemented from TH1.; Definition at line 152 of file TH2Poly.h. ◆ SetFloat(). void TH2Poly::SetFloat ; (; Bool_t ; flag = true). When set to kTRUE, allows the histogram to expand if a bin outside the limits is added. ; Definition at line 1424 of file TH2Poly.cxx. ◆ SetNewBinAdded(). void TH2Poly::SetNewBinAdded ; (; Bool_t ; flag). inline . Definition at line 124 of file TH2Poly.h. ◆ Streamer(). void TH2Poly::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TH2. ; Reimplemented from TH2.; Reimplemented in TProfile2Poly. ◆ StreamerNVirtual(). void TH2Poly::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 184 of file TH2Poly.h. ◆ UpdateBinContent(). void TH2Poly::UpdateBinContent ; (; Int_t ; bin, . Double_t ; content . ). inlineoverrideprotectedvirtual . Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ; Reimplemented from TH1.; Definition at line 180 of file TH2Poly.h. Member Data Documentation. ◆ fBinContentChanged. Bool_t TH2Poly::fBinContentChanged. protected . !For the 3D Painter ; Definition at line 169 of file TH2Poly.h. ◆ fBins. TList* TH2Poly::fBins. protected . List of bins. The list owns the contained objects. ; Definition at line 170 of file TH2Poly.h. ◆ fCells. TList* TH2Poly::fCells. protected . [fNCells] The array of TLists that store the bins that intersect with each cell. List do not own the contained objects ; Definition at line 163 of file TH2Poly.h. ◆ fCellX. Int_t TH2Poly::fCellX. protected . Number of partition cells in the x-direction of the histogram. ; Definition at line 160 of file TH2Poly.h. ◆ fCellY. Int_t TH2Poly::fCellY. protected . Number of partition cells in the y-direction of the histogram. ; Definition at line 161 of file TH2Poly.h. ◆ fCompletelyInside. Bool_t* TH2Poly::fCompletelyInside. protected",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2Poly.html:87494,update,update,87494,doc/master/classTH2Poly.html,https://root.cern,https://root.cern/doc/master/classTH2Poly.html,1,['update'],['update']
Deployability," ; class  Vavilov;  Base class describing a Vavilov distribution. More...;  ; class  VavilovAccurate;  Class describing a Vavilov distribution. More...;  ; class  VavilovAccurateCdf;  Class describing the Vavilov cdf. More...;  ; class  VavilovAccuratePdf;  Class describing the Vavilov pdf. More...;  ; class  VavilovAccurateQuantile;  Class describing the Vavilov quantile function. More...;  ; class  VavilovFast;  Class describing a Vavilov distribution. More...;  ; class  VecExpr;  Expression wrapper class for Vector objects. More...;  ; class  VectorMatrixColOp;  Class for Vector-Matrix multiplication. More...;  ; class  VectorMatrixRowOp;  ; struct  VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  ; class  VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  ; class  WrappedFunction;  Template class to wrap any C++ callable object which takes one argument i.e. More...;  ; class  WrappedMemFunction;  Template class to wrap any member function of a class taking a double and returning a double in a 1D function interface For example, if you have a class like: struct X { double Eval(double x); }; you can wrapped in the following way: WrappedMemFunction<X, double ( X::* ) (double) > f;. More...;  ; class  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:32675,integrat,integration,32675,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,6,['integrat'],"['integration', 'integrator']"
Deployability," ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Fatal("""", kAssertMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); _QUOTE_#define _QUOTE_(name)Definition RConfig.hxx:446; R__unlikely#define R__unlikely(expr)Definition RConfig.hxx:586; e#define e(i)Definition RSha256.hxx:103; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35. Checks condition e and reports a fatal error if it's false. ; Warning; this check is NOT stripped in release mode, so it should not be used for hot paths. For those cases, prefer a regular assert();; depending on gErrorIgnoreLevel, this might not terminate the program, . See alsoFatal. ; Definition at line 125 of file TError.h. ◆ R__CHECK. #define R__CHECK; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Warning("""", kCheckMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36. Checks condition e and reports a warning message if it's false. ; Warningthis check is NOT stripped in release mode, so it should not be used for hot paths. ; Definition at line 134 of file TError.h. Typedef Documentation. ◆ ErrorHandlerFunc_t. typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg). Definition at line 71 of file TError.h. Function Documentation. ◆ AbstractMethod(). void AbstractMethod ; (; const char * ; method). This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ; If this function is called it will warn the user that the function should have been overridden. ; Definition at line 159 of file TError.cxx. ◆ Break(). void Break ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 207 of file TError.cxx. ◆ DefaultErrorHandler(). void DefaultErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const char * ; location, . const char * ; msg . ). The default error handler function. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8h.html:4834,release,release,4834,doc/master/TError_8h.html,https://root.cern,https://root.cern/doc/master/TError_8h.html,1,['release'],['release']
Deployability," ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealMPFE.html:59320,integrat,integration,59320,doc/master/classRooRealMPFE.html,https://root.cern,https://root.cern/doc/master/classRooRealMPFE.html,2,"['configurat', 'integrat']","['configuration', 'integration']"
Deployability," ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 95 of file RooBCPEffDecay.cxx. Member Function Documentation. ◆ Class(). static TClass * RooBCPEffDecay::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooBCPEffDecay::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooBCPEffDecay::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 69 of file RooBCPEffDecay.h. ◆ clone(). TObject * RooBCPEffDecay::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 39 of file RooBCPEffDecay.h. ◆ coefAnalyticalIntegral(). double RooBCPEffDecay::coefAnalyticalIntegral ; (; Int_t ; coef, . Int_t ; code, . const char * ; rangeName = nullptr . ); const. overridevirtual . Default implementation of function implementing advertised integrals. ; Only the pass-through scenario (no integration) is implemented. ; Reimplemented from RooAbsAnaConvPdf.; Definition at line 156 of file RooBCPEffDecay.cxx. ◆ coefficient(). double RooBCPEffDecay::coefficient ; (; Int_t ; basisIndex); const. overridevirtual . B0 : _tag = +1. ; B0bar : _tag = -1 Parameters. [in]basisIndex. Implements RooAbsAnaConvPdf.; Definition at line 121 of file RooBCPEffDecay.cxx. ◆ DeclFileName(). static const char * RooBCPEffDecay::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 69 of file RooBCPEffDecay.h. ◆ generateEvent(). void RooBCPEffDecay::generateEvent ; (; Int_t ; code). overridevirtual . Generates mix-state dependent. ; Parameters. [in]code. Reimplemented from RooAbsPdf.; Definition at line 208 of file RooBCPEffDecay.cxx. ◆ getCoefAnalyticalIntegral(). Int_t RooBCPEffDecay::getCoefAnalyticalIntegral ; (; Int_t ; coef, . RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBCPEffDecay.html:80176,integrat,integration,80176,doc/master/classRooBCPEffDecay.html,https://root.cern,https://root.cern/doc/master/classRooBCPEffDecay.html,1,['integrat'],['integration']
Deployability," ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 95 of file RooBCPGenDecay.cxx. Member Function Documentation. ◆ Class(). static TClass * RooBCPGenDecay::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooBCPGenDecay::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooBCPGenDecay::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 69 of file RooBCPGenDecay.h. ◆ clone(). TObject * RooBCPGenDecay::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 40 of file RooBCPGenDecay.h. ◆ coefAnalyticalIntegral(). double RooBCPGenDecay::coefAnalyticalIntegral ; (; Int_t ; coef, . Int_t ; code, . const char * ; rangeName = nullptr . ); const. overridevirtual . Default implementation of function implementing advertised integrals. ; Only the pass-through scenario (no integration) is implemented. ; Reimplemented from RooAbsAnaConvPdf.; Definition at line 152 of file RooBCPGenDecay.cxx. ◆ coefficient(). double RooBCPGenDecay::coefficient ; (; Int_t ; basisIndex); const. overridevirtual . B0 : _tag = +1 B0bar : _tag = -1. ; Implements RooAbsAnaConvPdf.; Definition at line 118 of file RooBCPGenDecay.cxx. ◆ DeclFileName(). static const char * RooBCPGenDecay::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 69 of file RooBCPGenDecay.h. ◆ generateEvent(). void RooBCPGenDecay::generateEvent ; (; Int_t ; code). overridevirtual . Generate mix-state dependent. ; Reimplemented from RooAbsPdf.; Definition at line 206 of file RooBCPGenDecay.cxx. ◆ getCoefAnalyticalIntegral(). Int_t RooBCPGenDecay::getCoefAnalyticalIntegral ; (; Int_t ; coef, . RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Default implementation of function a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBCPGenDecay.html:79901,integrat,integration,79901,doc/master/classRooBCPGenDecay.html,https://root.cern,https://root.cern/doc/master/classRooBCPGenDecay.html,1,['integrat'],['integration']
Deployability," ; theGraph, . Int_t ; px, . Int_t ; py . ). overridevirtual . Compute distance from point px,py to a graph. ; Compute the closest distance of approach from point px,py to this line. The distance is computed in pixels units. ; Implements TVirtualGraphPainter.; Definition at line 717 of file TGraphPainter.cxx. ◆ DrawPanelHelper(). void TGraphPainter::DrawPanelHelper ; (; TGraph * ; theGraph). overridevirtual . Display a panel with all histogram drawing options. ; Implements TVirtualGraphPainter.; Definition at line 796 of file TGraphPainter.cxx. ◆ ExecuteEventHelper(). void TGraphPainter::ExecuteEventHelper ; (; TGraph * ; theGraph, . Int_t ; event, . Int_t ; px, . Int_t ; py . ). overridevirtual . Execute action corresponding to one event. ; This member function is called when a graph is clicked with the locator.; If the left mouse button is clicked on one of the line end points, this point follows the cursor until button is released.; If the middle mouse button clicked, the line is moved parallel to itself until the button is released. ; Implements TVirtualGraphPainter.; Definition at line 821 of file TGraphPainter.cxx. ◆ GetHighlightPoint(). Int_t TGraphPainter::GetHighlightPoint ; (; TGraph * ; theGraph); const. virtual . Return the highlighted point for theGraph. ; Definition at line 1110 of file TGraphPainter.cxx. ◆ GetObjectInfoHelper(). char * TGraphPainter::GetObjectInfoHelper ; (; TGraph * ; theGraph, . Int_t ; px, . Int_t ; py . ); const. overridevirtual . Implements TVirtualGraphPainter.; Definition at line 1101 of file TGraphPainter.cxx. ◆ HighlightPoint(). void TGraphPainter::HighlightPoint ; (; TGraph * ; theGraph, . Int_t ; hpoint, . Int_t ; distance . ). virtual . Check on highlight point. ; Definition at line 1136 of file TGraphPainter.cxx. ◆ IsA(). TClass * TGraphPainter::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 71 of file TGraphPainter.h. ◆ PaintGraph(). vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphPainter.html:43530,release,released,43530,doc/master/classTGraphPainter.html,https://root.cern,https://root.cern/doc/master/classTGraphPainter.html,1,['release'],['released']
Deployability," ; virtual Int_t GetFontAscent (const char *mess) const;  Default version is noop, but in principle what ROOT understands as ascent is text related. ;  ; virtual Int_t GetFontDescent () const;  Returns the descent of the current font (in pixels. ;  ; virtual Int_t GetFontDescent (const char *mess) const;  Default version is noop, but in principle what ROOT understands as descent requires a certain text. ;  ; virtual FontStruct_t GetGCFont (GContext_t gc);  Return the font associated with the graphics context gc. ;  ; virtual Double_t GetOpenGLScalingFactor ();  On a HiDPI resolution it can be > 1., this means glViewport should use scaled width and height. ;  ; TClass * IsA () const override;  ; virtual Bool_t MakeOpenGLContextCurrent (Handle_t ctx, Window_t windowID);  Makes context ctx current OpenGL context. ;  ; virtual void MapGCFont (GContext_t, FontStruct_t);  Map the XftFont with the Graphics Context using it. ;  ; virtual Bool_t NeedRedraw (ULongptr_t tgwindow, Bool_t force);  Notify the low level GUI layer ROOT requires ""tgwindow"" to be updated. ;  ; virtual Pixmap_t ReadGIF (Int_t x0, Int_t y0, const char *file, Window_t id=0);  If id is NULL - loads the specified gif file at position [x0,y0] in the current window. ;  ; virtual UInt_t ScreenWidthMM () const;  Returns the width of the screen in millimeters. ;  ; virtual void SelectPixmap (Int_t qpixid);  Selects the pixmap ""qpixid"". ;  ; void SetFillColor (Color_t cindex) override;  Sets color index ""cindex"" for fill areas. ;  ; void SetFillStyle (Style_t style) override;  Sets fill area style. ;  ; void SetLineColor (Color_t cindex) override;  Sets color index ""cindex"" for drawing lines. ;  ; void SetLineStyle (Style_t linestyle) override;  Sets the line style. ;  ; void SetLineWidth (Width_t width) override;  Sets the line width. ;  ; void SetMarkerColor (Color_t cindex) override;  Sets color index ""cindex"" for markers. ;  ; void SetMarkerSize (Float_t markersize) override;  Sets marker size index. ;  ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32VirtualXProxy.html:31679,update,updated,31679,doc/master/classTGWin32VirtualXProxy.html,https://root.cern,https://root.cern/doc/master/classTGWin32VirtualXProxy.html,1,['update'],['updated']
Deployability," ; virtual void RemoveEntries (Int_t from_ID, Int_t to_ID);  ; virtual void RemoveEntry (Int_t id=-1);  Remove entry. If id == -1, the currently selected entry is removed. ;  ; virtual void ReturnPressed ();  Add new entry to combo box when return key pressed inside text entry ReturnPressed signal is emitted. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a combo box widget as a C++ statement(s) on output stream out. ;  ; virtual void Select (Int_t id, Bool_t emit=kTRUE);  Make the selected item visible in the combo box window and emit signals according to the second parameter. ;  ; virtual void Selected (const char *txt);  ; virtual void Selected (Int_t id);  ; virtual void Selected (Int_t widgetId, Int_t id);  Emit signal, done only when selected entry changed. ;  ; virtual void SetEnabled (Bool_t on=kTRUE);  Set state of combo box. If kTRUE=enabled, kFALSE=disabled. ;  ; virtual void SetTopEntry (TGLBEntry *e, TGLayoutHints *lh);  Set a new combo box value (normally update of text string in fSelEntry is done via fSelEntry::Update()). ;  ; virtual void SortByName (Bool_t ascend=kTRUE);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGCompositeFrame;  TGCompositeFrame (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=0, Pixel_t back=GetDefaultFrameBackground());  Create a composite frame. ;  ;  TGCompositeFrame (TGClient *c, Window_t id, const TGWindow *parent=nullptr);  Create a frame using an externally created window. ;  ;  ~TGCompositeFrame () override;  Delete a composite frame. ;  ; virtual void AddFrame (TGFrame *f, TGLayoutHints *l=nullptr);  Add frame to the composite frame using the specified layout hints. ;  ; void ChangeOptions (UInt_t options) override;  Change composite frame options. Options is an OR of the EFrameTypes. ;  ; virtual void ChangeSubframesBackground (P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGComboBox.html:4288,update,update,4288,doc/master/classTGComboBox.html,https://root.cern,https://root.cern/doc/master/classTGComboBox.html,1,['update'],['update']
Deployability," ; virtual void RemoveEntries (Int_t from_ID, Int_t to_ID);  ; virtual void RemoveEntry (Int_t id=-1);  Remove entry. If id == -1, the currently selected entry is removed. ;  ; virtual void ReturnPressed ();  Add new entry to combo box when return key pressed inside text entry ReturnPressed signal is emitted. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a combo box widget as a C++ statement(s) on output stream out. ;  ; virtual void Select (Int_t id, Bool_t emit=kTRUE);  Make the selected item visible in the combo box window and emit signals according to the second parameter. ;  ; virtual void Selected (const char *txt);  ; virtual void Selected (Int_t id);  ; virtual void Selected (Int_t widgetId, Int_t id);  Emit signal, done only when selected entry changed. ;  ; virtual void SetEnabled (Bool_t on=kTRUE);  Set state of combo box. If kTRUE=enabled, kFALSE=disabled. ;  ; virtual void SetTopEntry (TGLBEntry *e, TGLayoutHints *lh);  Set a new combo box value (normally update of text string in fSelEntry is done via fSelEntry::Update()). ;  ; virtual void SortByName (Bool_t ascend=kTRUE);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGCompositeFrame;  TGCompositeFrame (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=0, Pixel_t back=GetDefaultFrameBackground());  Create a composite frame. ;  ;  TGCompositeFrame (TGClient *c, Window_t id, const TGWindow *parent=nullptr);  Create a frame using an externally created window. ;  ;  ~TGCompositeFrame () override;  Delete a composite frame. ;  ; virtual void AddFrame (TGFrame *f, TGLayoutHints *l=nullptr);  Add frame to the composite frame using the specified layout hints. ;  ; void ChangeOptions (UInt_t options) override;  Change composite frame options. Options is an OR of the EFrameTypes. ;  ; virtual void ChangeSubframesBackground (Pixel_t back);  Change background color for this frame and all subframes. ;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGFontTypeComboBox.html:4311,update,update,4311,doc/master/classTGFontTypeComboBox.html,https://root.cern,https://root.cern/doc/master/classTGFontTypeComboBox.html,1,['update'],['update']
Deployability," ; void SetClearColor (Color_t col);  Set background method. ;  ; void SetClipAutoUpdate (Bool_t x);  ; void SetCurrentCamera (ECameraType camera);  Set current active camera - 'cameraType' one of: kCameraPerspX, kCameraPerspY, kCameraPerspZ, kCameraOrthoXOY, kCameraOrthoXOZ, kCameraOrthoZOY, kCameraOrthoXnOY, kCameraOrthoXnOZ, kCameraOrthoZnOY. ;  ; void SetDrawCameraCenter (Bool_t x);  Draw camera look at and rotation point. ;  ; virtual void SetEventHandler (TGEventHandler *handler);  Set the event-handler. ;  ; void SetFader (Float_t x);  ; virtual void SetGedEditor (TGedEditor *ed);  ; void SetGuideState (Int_t axesType, Bool_t axesDepthTest, Bool_t referenceOn, const Double_t *referencePos);  Set the state of guides (axes & reference markers) from arguments. ;  ; void SetIgnoreSizesOnUpdate (Bool_t v);  ; void SetLineScale (Float_t s);  ; void SetMaxSceneDrawTimeHQ (Float_t t);  ; void SetMaxSceneDrawTimeLQ (Float_t t);  ; void SetOrthoCamera (ECameraType camera, Double_t zoom, Double_t dolly, Double_t center[3], Double_t hRotate, Double_t vRotate);  Set an orthographic camera to supplied configuration - note this does not need to be the current camera - though you will not see the effect if it is not. ;  ; void SetPerspectiveCamera (ECameraType camera, Double_t fov, Double_t dolly, Double_t center[3], Double_t hRotate, Double_t vRotate);  Set a perspective camera to supplied configuration - note this does not need to be the current camera - though you will not see the effect if it is not. ;  ; void SetPictureFileName (const TString &f);  ; void SetPointScale (Float_t s);  ; void SetResetCamerasOnUpdate (Bool_t v);  ; void SetSmartRefresh (Bool_t smart_ref);  ; void SetSmoothLines (Bool_t s);  ; void SetSmoothPoints (Bool_t s);  ; void SetStereo (Bool_t stereo, Bool_t quad_buf=kTRUE);  Enable stereo rendering. ;  ; void SetStereoEyeOffsetFac (Float_t f);  ; void SetStereoFrustumAsymFac (Float_t f);  ; void SetStereoZeroParallax (Float_t f);  ; void Streamer (TB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLEmbeddedViewer.html:10854,configurat,configuration,10854,doc/master/classTGLEmbeddedViewer.html,https://root.cern,https://root.cern/doc/master/classTGLEmbeddedViewer.html,3,['configurat'],['configuration']
Deployability," ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; double integrate (const RooArgSet *normSet, double low, double high) const;  Integrate the wrapped PDF using our current integrator, with given norm set and limits. ;  ; double operator() (double x) const;  Binding used by the integrator to evaluate the PDF. ;  . Private Attributes; std::vector< double > _binBoundaries;  ! Workspace to store data for bin sampling ;  ; std::unique_ptr< ROOT::Math::IntegratorOneDim > _integrator {nullptr};  ! Integrator used to sample bins. ;  ; RooTemplateProxy< RooAbsRealLValue > _observable;  ; RooTemplateProxy< RooAbsPdf > _pdf;  ; double _relEpsilon {1.E-4};  Default integrator precision. ;  . Friends; template<typename Func > ; class ROOT::Math::WrappedFunction;  . Additional Inherited Members;  Public Types inherited from RooAbsPdf; enum  ExtendMode { CanNotBeExtended; , CanBeExtended; , MustBeExtended; };  ;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using val",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:70976,integrat,integrate,70976,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,2,['integrat'],"['integrate', 'integrator']"
Deployability," ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooRealProxy A;  ; RooRealProxy B;  ; RooRealProxy C;  ; RooRealProxy dm;  ; RooRealProxy dm0;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDstD0BG.html:68027,configurat,configuration,68027,doc/master/classRooDstD0BG.html,https://root.cern,https://root.cern/doc/master/classRooDstD0BG.html,1,['configurat'],['configuration']
Deployability," ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; bool _useStandardParametrization = false;  ; RooRealProxy k;  the shape parameter, exp(sigma) ;  ; RooRealProxy m0;  the median, exp(mu) ;  ; RooRealProxy x;  the variable ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLognormal.html:68705,configurat,configuration,68705,doc/master/classRooLognormal.html,https://root.cern,https://root.cern/doc/master/classRooLognormal.html,1,['configurat'],['configuration']
Deployability," ;  TKeySQL (TDirectory *mother, const void *obj, const TClass *cl, const char *name, const char *title=nullptr);  Creates TKeySQL and convert obj data to TSQLStructure via TBufferSQL2. ;  ;  TKeySQL (TDirectory *mother, Long64_t keyid, Long64_t objid, const char *name, const char *title, const char *keydatetime, Int_t cycle, const char *classname);  Create TKeySQL object, which corresponds to single entry in keys table. ;  ;  ~TKeySQL () override=default;  ; void Delete (Option_t *option="""") final;  Removes key from current directory Note: TKeySQL object is not deleted. ;  ; void DeleteBuffer () final;  Delete key buffer(s). ;  ; void FillBuffer (char *&) final;  Encode key header into output buffer. ;  ; char * GetBuffer () const final;  ; Long64_t GetDBDirId () const;  return sql id of parent directory ;  ; Long64_t GetDBKeyId () const;  ; Long64_t GetDBObjId () const;  ; Long64_t GetSeekKey () const final;  ; Long64_t GetSeekPdir () const final;  ; TClass * IsA () const override;  ; Bool_t IsKeyModified (const char *keyname, const char *keytitle, const char *keydatime, Int_t cycle, const char *classname);  Compares keydata with provided and return kTRUE if key was modified Used in TFile::StreamKeysForDirectory() method to verify data for that keys should be updated. ;  ; void Keep () final;  Set the ""KEEP"" status. ;  ; Int_t Read (TObject *obj) final;  To read an object from the file. ;  ; void ReadBuffer (char *&) final;  Decode input buffer. ;  ; Bool_t ReadFile () final;  Read the key structure from the file. ;  ; TObject * ReadObj () final;  Read object derived from TObject class If it is not TObject or in case of error, return 0. ;  ; void * ReadObjectAny (const TClass *expectedClass) final;  Read object of any type from SQL database. ;  ; TObject * ReadObjWithBuffer (char *bufferRead) final;  Read object derived from TObject class If it is not TObject or in case of error, return 0. ;  ; void SetBuffer () final;  ; void Streamer (TBuffer &) override;  Strea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKeySQL.html:2036,update,updated,2036,doc/master/classTKeySQL.html,https://root.cern,https://root.cern/doc/master/classTKeySQL.html,1,['update'],['updated']
Deployability," ;  ~GaussIntegrator () override;  Destructor. ;  ; void AbsValue (bool flag);  Static function: set the fgAbsValue flag. ;  ; double Error () const override;  Return the estimate of the absolute Error of the last Integral calculation. ;  ; double Integral () override;  Returns Integral of function on an infinite interval. ;  ; double Integral (const std::vector< double > &pts) override;  This method is not implemented. ;  ; double Integral (double a, double b) override;  Returns Integral of function between a and b. ;  ; double IntegralCauchy (double a, double b, double c) override;  This method is not implemented. ;  ; double IntegralLow (double b) override;  Returns Integral of function on a lower semi-infinite interval. ;  ; double IntegralUp (double a) override;  Returns Integral of function on an upper semi-infinite interval. ;  ; double Result () const override;  Returns the result of the last Integral calculation. ;  ; void SetFunction (const IGenFunction &) override;  Set integration function (flag control if function must be copied inside). ;  ; int Status () const override;  return the status of the last integration - 0 in case of success ;  ;  Public Member Functions inherited from ROOT::Math::VirtualIntegratorOneDim;  ~VirtualIntegratorOneDim () override;  destructor: no operation ;  ; virtual ROOT::Math::IntegrationOneDim::Type Type () const;  return type of integrator ;  ;  Public Member Functions inherited from ROOT::Math::VirtualIntegrator; virtual ~VirtualIntegrator ();  destructor: no operation ;  . Protected Attributes; int fNum;  Number of points used in the estimation of the integral. ;  ; double * fW;  Weights of the points used. ;  ; double * fX;  Abscisa of the points used. ;  ;  Protected Attributes inherited from ROOT::Math::GaussIntegrator; double fEpsAbs;  Absolute error. ;  ; double fEpsRel;  Relative error. ;  ; const IGenFunction * fFunction;  Pointer to function used. ;  ; double fLastError;  Error from the last estimation. ;  ; doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GaussLegendreIntegrator.html:2881,integrat,integration,2881,doc/master/classROOT_1_1Math_1_1GaussLegendreIntegrator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GaussLegendreIntegrator.html,1,['integrat'],['integration']
Deployability," Base class for TEveUtil visualization elements, providing hierarchy management, rendering control and list-tree item management. More...;  ; class  TEveElementEditor;  Editor for TEveElement class. More...;  ; class  TEveElementList;  A list of TEveElements. More...;  ; class  TEveElementListProjected;  A projected element list – required for proper propagation of render state to projected views. More...;  ; class  TEveEventManager;  Base class for event management and navigation. More...;  ; class  TEveException;  Exception class thrown by TEve classes and macros. More...;  ; class  TEveFrameBox;  Description of a 2D or 3D frame that can be used to visually group a set of objects. More...;  ; class  TEveFrameBoxGL;  A class encapsulating GL rendering of TEveFrameBox via a static member function. More...;  ; class  TEveGDoubleValuator;  Composite GUI element for selection of range (label, two number-entries and double-slider). More...;  ; class  TEveGedEditor;  Specialization of TGedEditor for proper update propagation to TEveManager. More...;  ; class  TEveGedNameFrame;  Specialization of TGedNameFrame used in EVE. More...;  ; class  TEveGedNameTextButton;  Specialization of TGTextButton for EVE name frame. More...;  ; class  TEveGeoManagerHolder;  Exception safe wrapper for setting gGeoManager. More...;  ; class  TEveGeoNode;  Wrapper for TGeoNode that allows it to be shown in GUI and controlled as a TEveElement. More...;  ; class  TEveGeoNodeEditor;  Editor for TEveGeoNode class. More...;  ; class  TEveGeoPolyShape;  Description of TEveGeoPolyShape. More...;  ; class  TEveGeoShape;  Wrapper for TGeoShape with absolute positioning and color attributes allowing display of extracted TGeoShape's (without an active TGeoManager) and simplified geometries (needed for non-linear projections). More...;  ; class  TEveGeoShapeExtract;  Globally positioned TGeoShape with rendering attributes and an optional list of daughter shape-extracts. More...;  ; class  TEveGeoShapePro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__TEve.html:6749,update,update,6749,doc/master/group__TEve.html,https://root.cern,https://root.cern/doc/master/group__TEve.html,1,['update'],['update']
Deployability," CPyint3_t;  CPyint4_t;  CPyint5_t;  CPyint6_t;  CPyint7_t;  CPyint8_t;  CPyint9_t;  CPyints_t;  CPyjets_t;  CPymssm_t;  CPypars_t;  CPyssmt_t;  CPysubs_t;  CQuartzImage;  CQuartzPixmap;  CQuartzView;  CQuartzWindow;  CRectangle_t;  CRedirectHandle_t;  Credirguard;  Crng_state_st;  CRoo1DMomentMorphFunction1-dimensional morph function between a list of input functions (varlist) as a function of one input parameter (m) ;  CRoo1DTable;  CRoo2DKeysPdfTwo-dimensional kernel estimation PDF ;  ►CRoo2DMomentMorphFunction2-dimensional morph function between a list of function-numbers as a function of two input parameters (m1 and m2) ;  CSorterL2H;  ►CRooAbsAnaConvPdf;  CCacheElemIterator over _convNormSet ;  CRooAbsArgRooAbsArg is the common abstract base class for objects that represent a value (of arbitrary type) and ""shape"" that in general depends on (is a client of) other RooAbsArg subclasses ;  CRooAbsBinning;  CRooAbsCache;  ►CRooAbsCachedPdf;  CAnaIntConfigRegistry for analytical integration codes ;  CPdfCacheElem;  ►CRooAbsCachedReal;  CFuncCacheElem;  CRooAbsCacheElement;  CRooAbsCategory;  CRooAbsCategoryLValue;  CRooAbsCollection;  ►CRooAbsData;  CPlotOpt;  CRooAbsDataStore;  CRooAbsFunc;  CRooAbsGenContext;  CRooAbsHiddenReal;  CRooAbsIntegrator;  CRooAbsLValue;  CRooAbsMCStudyModule;  CRooAbsMoment;  CRooAbsNumGenerator;  CRooAbsOptTestStatistic;  ►CRooAbsPdfRooAbsPdf is the abstract interface for all probability density functions The class provides hybrid analytical/numerical normalization for its implementations, error tracing and a MC generator interface ;  CCacheElemNormalization set with for above integral ;  CGenSpec;  CRooAbsProxy;  ►CRooAbsRealRooAbsReal is the common abstract base class for objects that represent a real value and implements functionality common to all real-valued objects such as the ability to plot them, to construct integrals of them, the ability to advertise (partial) analytical integrals etc ;  CEvalError;  CPlotOpt;  CRooAbsRealLVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:79858,integrat,integration,79858,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,2,['integrat'],['integration']
Deployability," CVOptimizerGeneric Optimizer class ;  ►NExperimental;  CClassification;  CClassificationResult;  ►NkNN;  CEvent;  CModulekNN;  CNodeThis file contains binary tree and global function template that searches tree for k-nearest neigbors ;  NTMVAGlob;  CAbsoluteDeviationLossFunctionAbsolute Deviation Loss Function ;  CAbsoluteDeviationLossFunctionBDTAbsolute Deviation BDT Loss Function ;  CAbsValue;  CBDTEventWrapper;  CBinarySearchTreeA simple Binary search tree including a volume search method ;  CBinarySearchTreeNodeNode for the BinarySearch or Decision Trees ;  CBinaryTreeBase class for BinarySearch and Decision Trees ;  CCCPrunerA helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) ;  ►CCCTreeWrapper;  CCCTreeNode;  CClassifierFactoryThis is the MVA factory ;  CClassInfoClass that contains all the information of a class ;  Ccompose_binary_t;  Ccompose_unary_t;  ►CConfigSingleton class for global configuration settings used by TMVA ;  CIONames;  CVariablePlotting;  CConfigurable;  CConvergenceTestCheck for convergence ;  CCostComplexityPruneToolA class to prune a decision tree using the Cost Complexity method ;  CCrossEntropyImplementation of the CrossEntropy as separation criterion ;  CCrossValidationClass to perform cross validation, splitting the dataloader into folds ;  CCrossValidationFoldResult;  CCrossValidationResultClass to save the results of cross validation, the metric for the classification ins ROC and you can ROC curves ROC integrals, ROC average and ROC standard deviation ;  CCvSplit;  CCvSplitKFolds;  CCvSplitKFoldsExpr;  CDataInputHandlerClass that contains all the data information ;  CDataLoader;  CDataSetClass that contains all the data information ;  ►CDataSetFactoryClass that contains all the data information ;  CEventStats;  CDataSetInfoClass that contains all the data information ;  CDataSetManagerClass that contains all the data information ;  CDecisionTreeImpl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/namespaces.html:87277,configurat,configuration,87277,doc/v616/namespaces.html,https://root.cern,https://root.cern/doc/v616/namespaces.html,1,['configurat'],['configuration']
Deployability," Class_Version(). static constexpr Version_t RooMultiVarGaussian::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 112 of file RooMultiVarGaussian.h. ◆ clone(). TObject * RooMultiVarGaussian::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 42 of file RooMultiVarGaussian.h. ◆ covarianceMatrix(). const TMatrixDSym & RooMultiVarGaussian::covarianceMatrix ; (; ); const. inline . Definition at line 51 of file RooMultiVarGaussian.h. ◆ DeclFileName(). static const char * RooMultiVarGaussian::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 112 of file RooMultiVarGaussian.h. ◆ decodeCode(). void RooMultiVarGaussian::decodeCode ; (; Int_t ; code, . std::vector< int > & ; map1, . std::vector< int > & ; map2 . ); const. protected . Decode analytical integration/generation code into index map of integrated/generated (map2) and non-integrated/generated observables (map1) ; Definition at line 600 of file RooMultiVarGaussian.cxx. ◆ evaluate(). double RooMultiVarGaussian::evaluate ; (; ); const. overrideprotectedvirtual . Do not persist. ; Represent observables as vector. ; Implements RooAbsReal.; Definition at line 175 of file RooMultiVarGaussian.cxx. ◆ genData(). RooMultiVarGaussian::GenData & RooMultiVarGaussian::genData ; (; Int_t ; code); const. protected . WVE – CHECK THAT GENDATA IS VALID GIVEN CURRENT VALUES OF _MU. ; Definition at line 501 of file RooMultiVarGaussian.cxx. ◆ generateEvent(). void RooMultiVarGaussian::generateEvent ; (; Int_t ; code). overridevirtual . Retrieve generator config from cache. ; Reimplemented from RooAbsPdf.; Definition at line 434 of file RooMultiVarGaussian.cxx. ◆ getAnalyticalIntegral(). Int_t RooMultiVarGaussian::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMultiVarGaussian.html:78206,integrat,integration,78206,doc/master/classRooMultiVarGaussian.html,https://root.cern,https://root.cern/doc/master/classRooMultiVarGaussian.html,3,['integrat'],"['integrated', 'integration']"
Deployability," DoDialogCancel ();  Process dialog Cancel button pressed. ;  ; void DoDialogOK ();  Process dialog OK button pressed. ;  ; Bool_t GetDropStatus () const;  ; Int_t GetEndDragX () const override;  Return the current X coordinate of the dragged frame. ;  ; Int_t GetEndDragY () const override;  Returns the current Y coordinate of the dragged frame. ;  ; UInt_t GetGridStep ();  Return the grid step. ;  ; TGFrame * GetSelected () const;  Return the current grabbed/selected frame. ;  ; Int_t GetStrartDragX () const override;  Return the X coordinate where drag started. ;  ; Int_t GetStrartDragY () const override;  Return the Y coordinate where drag started. ;  ; TGFrame * GetTarget () const;  ; void HandleAction (Int_t act);  Main handler of actions. ;  ; Bool_t HandleKey (Event_t *) override;  Handle key event. ;  ; Bool_t HandleTimerEvent (Event_t *ev, TTimer *t) override;  Handle timer events or events coming from the recorder. ;  ; void HandleUpdateSelected (TGFrame *);  When selected frame was changed by guibuilder editor -> update its appearance. ;  ; Bool_t IsStopped () const;  ; void SelectFrame (TGFrame *frame, Bool_t add=kFALSE);  Grab/Select frame. ;  ; void SetBuilder (TRootGuiBuilder *b);  ; void SetEditable (Bool_t on=kTRUE) override;  Grab server. ;  ; void SetGridStep (UInt_t step);  Set the grid step. ;  ; void Snap2Grid ();  Draw grid on editable frame and restore background on previously edited one. ;  ; void TimerEvent (Event_t *ev);  ;  Public Member Functions inherited from TVirtualDragManager;  TVirtualDragManager ();  Constructor. ;  ; virtual ~TVirtualDragManager ();  ; EDragType GetEDragType () const;  ; TGFrame * GetFrameUnder () const;  ; TGFrame * GetPasteFrame () const;  ; TGFrame * GetSource () const;  ; TGFrame * GetTarget () const;  ; virtual TClass * IsA () const;  ; Bool_t IsDragging () const;  ; Bool_t IsDropping () const;  ; Bool_t IsMoveWaiting () const;  ; Bool_t IsPasting () const;  ; virtual void SetPasteFrame (TGFrame *f);  ; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGuiBldDragManager.html:3323,update,update,3323,doc/master/classTGuiBldDragManager.html,https://root.cern,https://root.cern/doc/master/classTGuiBldDragManager.html,1,['update'],['update']
Deployability," Editor for TEveLine class. More...;  ; class  TEveLineGL;  GL-renderer for TEveLine class. More...;  ; class  TEveLineProjected;  Projected copy of a TEveLine. More...;  ; class  TEveElement::TEveListTreeInfo;  Structure holding information about TGListTree and TGListTreeItem that represents given TEveElement. More...;  ; class  TEveListTreeItem;  Special list-tree-item for Eve. More...;  ; class  TEveMacro;  Sub-class of TMacro, overriding Exec to unload the previous version and cleanup after the execution. More...;  ; class  TEveMagField;  Abstract base-class for interfacing to magnetic field needed by the TEveTrackPropagator. More...;  ; class  TEveMagFieldConst;  Implements constant magnetic field, given by a vector fB. More...;  ; class  TEveMagFieldDuo;  Implements constant magnetic filed that switches on given axial radius fR2 from vector fBIn to fBOut. More...;  ; class  TEveManager;  Central application manager for Eve. More...;  ; class  TEvePad;  This was intended as a TPad wrapper to allow smart updates of groups of pads. More...;  ; class  TEvePadHolder;  Exception safe wrapper for setting gPad. More...;  ; class  TEveParamList;  Collection of named parameters. More...;  ; class  TEveParamListEditor;  GUI editor for TEveParamList. More...;  ; class  TEvePathMarkT< TT >;  Special-point on track: More...;  ; class  TEvePlot3D;  Description of TEvePlot3D. More...;  ; class  TEvePlot3DGL;  OpenGL renderer class for TEvePlot3D. More...;  ; class  TEvePointSelector;  TEvePointSelector is a sub-class of TSelectorDraw for direct extraction of point-like data from a Tree. More...;  ; class  TEvePointSelectorConsumer;  TEvePointSelectorConsumer is a virtual base for classes that can be filled from TTree data via the TEvePointSelector class. More...;  ; class  TEvePointSet;  TEvePointSet is a render-element holding a collection of 3D points with optional per-point TRef and an arbitrary number of integer ids (to be used for signal, volume-id, track-id, etc). More..",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__TEve.html:10394,update,updates,10394,doc/master/group__TEve.html,https://root.cern,https://root.cern/doc/master/group__TEve.html,1,['update'],['updates']
Deployability," HandleTooltip(). void TEveViewerList::HandleTooltip ; (; ). protected . Show / hide tooltip for various MouseOver events. ; Must be called from slots where sender is TGLEventHandler. ; Definition at line 508 of file TEveViewer.cxx. ◆ IsA(). TClass * TEveViewerList::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TEveElementList.; Definition at line 132 of file TEveViewer.h. ◆ OnClicked(). void TEveViewerList::OnClicked ; (; TObject * ; obj, . UInt_t ; button, . UInt_t ; state . ). Slot for global TGLViewer::Clicked(). ; The obj is dyn-casted to the TEveElement and global selection is updated accordingly.; If TEveElement::IsPickable() returns false, the element is not selected. ; Definition at line 605 of file TEveViewer.cxx. ◆ OnMouseOver(). void TEveViewerList::OnMouseOver ; (; TObject * ; obj, . UInt_t ; state . ). Slot for global TGLViewer::MouseOver() signal. ; The attempt is made to determine the TEveElement being represented by the physical shape and global highlight is updated accordingly.; If TEveElement::IsPickable() returns false, the element is not highlighted.; Highlight is always in single-selection mode. ; Definition at line 539 of file TEveViewer.cxx. ◆ OnReClicked(). void TEveViewerList::OnReClicked ; (; TObject * ; obj, . UInt_t ; button, . UInt_t ; state . ). Slot for global TGLViewer::ReClicked(). ; The obj is dyn-casted to the TEveElement and global selection is updated accordingly.; If TEveElement::IsPickable() returns false, the element is not selected. ; Definition at line 622 of file TEveViewer.cxx. ◆ OnReMouseOver(). void TEveViewerList::OnReMouseOver ; (; TObject * ; obj, . UInt_t ; state . ). Slot for global TGLViewer::ReMouseOver(). ; The obj is dyn-casted to the TEveElement and global selection is updated accordingly.; If TEveElement::IsPickable() returns false, the element is not selected. ; Definition at line 561 of file TEveViewer.cxx. ◆ OnUnClicked(). void TEveViewerList::OnUnC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveViewerList.html:37957,update,updated,37957,doc/master/classTEveViewerList.html,https://root.cern,https://root.cern/doc/master/classTEveViewerList.html,1,['update'],['updated']
Deployability," Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  ;  Static Public Member Functions inherited from TArrayC; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TArray; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TArray * ReadArray (TBuffer &b, const TClass *clReq);  Read TArray object from buffer. ;  ; static void WriteArray (TBuffer &b, const TArray *a);  Write TArray object to buffer. ;  . Protected Member Functions; Double_t RetrieveBinContent (Int_t bin) const override;  Raw retrieval of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ; void UpdateBinContent (Int_t bin, Double_t content) override;  Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ;  Protected Member Functions inherited from TH1;  TH1 ();  Histogram default constructor. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins);  Constructor for variable bin size histograms using an input array of type double. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins);  Constructor for variable bin size histograms using an input array of type float. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup);  Constructor for fix bin size histograms. ;  ; virtual Int_t AutoP2FindLimits (Double_t min, Double_t max);  Buffer-based estimate of the histogram range using the power of 2 algorithm. ;  ; Int_t AxisChoice (Option_t *axis) const;  Choose an axis according to ""axis"". ;  ; virtual Int_t BufferFill (Double_t x, Double_t w);  accumulate arguments in buffer. ;  ; virtual void DoFillN (Int_t n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1C.html:42564,update,update,42564,doc/master/classTH1C.html,https://root.cern,https://root.cern/doc/master/classTH1C.html,1,['update'],['update']
Deployability," Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  ;  Static Public Member Functions inherited from TArrayC; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TArray; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TArray * ReadArray (TBuffer &b, const TClass *clReq);  Read TArray object from buffer. ;  ; static void WriteArray (TBuffer &b, const TArray *a);  Write TArray object to buffer. ;  . Protected Member Functions; Double_t RetrieveBinContent (Int_t bin) const override;  Raw retrieval of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ; void UpdateBinContent (Int_t bin, Double_t content) override;  Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ;  Protected Member Functions inherited from TH2;  TH2 ();  2-D histogram default constructor. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins, Int_t nbinsy, const Double_t *ybins);  Constructor for Double_t variable bin size 2-D histograms. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins, Int_t nbinsy, Double_t ylow, Double_t yup);  Constructor for variable bin size (along X axis) 2-D histograms using an input array of type double. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins, Int_t nbinsy, const Float_t *ybins);  Constructor for variable bin size (along X and Y axis) 2-D histograms using input arrays of type float. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, const Double_t *ybins);  Constructor for Double_t variable bin size (al",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2C.html:48558,update,update,48558,doc/master/classTH2C.html,https://root.cern,https://root.cern/doc/master/classTH2C.html,1,['update'],['update']
Deployability," Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  ;  Static Public Member Functions inherited from TArrayD; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TArray; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TArray * ReadArray (TBuffer &b, const TClass *clReq);  Read TArray object from buffer. ;  ; static void WriteArray (TBuffer &b, const TArray *a);  Write TArray object to buffer. ;  . Protected Member Functions; Double_t RetrieveBinContent (Int_t bin) const override;  Raw retrieval of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ; void UpdateBinContent (Int_t bin, Double_t content) override;  Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ;  Protected Member Functions inherited from TH1;  TH1 ();  Histogram default constructor. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins);  Constructor for variable bin size histograms using an input array of type double. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins);  Constructor for variable bin size histograms using an input array of type float. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup);  Constructor for fix bin size histograms. ;  ; virtual Int_t AutoP2FindLimits (Double_t min, Double_t max);  Buffer-based estimate of the histogram range using the power of 2 algorithm. ;  ; Int_t AxisChoice (Option_t *axis) const;  Choose an axis according to ""axis"". ;  ; virtual Int_t BufferFill (Double_t x, Double_t w);  accumulate arguments in buffer. ;  ; virtual void DoFillN (Int_t n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1D.html:42804,update,update,42804,doc/master/classTH1D.html,https://root.cern,https://root.cern/doc/master/classTH1D.html,1,['update'],['update']
Deployability," Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  ;  Static Public Member Functions inherited from TArrayD; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TArray; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TArray * ReadArray (TBuffer &b, const TClass *clReq);  Read TArray object from buffer. ;  ; static void WriteArray (TBuffer &b, const TArray *a);  Write TArray object to buffer. ;  . Protected Member Functions; Double_t RetrieveBinContent (Int_t bin) const override;  Raw retrieval of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ; void UpdateBinContent (Int_t bin, Double_t content) override;  Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ;  Protected Member Functions inherited from TH2;  TH2 ();  2-D histogram default constructor. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins, Int_t nbinsy, const Double_t *ybins);  Constructor for Double_t variable bin size 2-D histograms. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins, Int_t nbinsy, Double_t ylow, Double_t yup);  Constructor for variable bin size (along X axis) 2-D histograms using an input array of type double. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins, Int_t nbinsy, const Float_t *ybins);  Constructor for variable bin size (along X and Y axis) 2-D histograms using input arrays of type float. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, const Double_t *ybins);  Constructor for Double_t variable bin size (al",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2D.html:48834,update,update,48834,doc/master/classTH2D.html,https://root.cern,https://root.cern/doc/master/classTH2D.html,1,['update'],['update']
Deployability," Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  ;  Static Public Member Functions inherited from TArrayF; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TArray; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TArray * ReadArray (TBuffer &b, const TClass *clReq);  Read TArray object from buffer. ;  ; static void WriteArray (TBuffer &b, const TArray *a);  Write TArray object to buffer. ;  . Protected Member Functions; Double_t RetrieveBinContent (Int_t bin) const override;  Raw retrieval of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ; void UpdateBinContent (Int_t bin, Double_t content) override;  Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ;  Protected Member Functions inherited from TH1;  TH1 ();  Histogram default constructor. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins);  Constructor for variable bin size histograms using an input array of type double. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins);  Constructor for variable bin size histograms using an input array of type float. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup);  Constructor for fix bin size histograms. ;  ; virtual Int_t AutoP2FindLimits (Double_t min, Double_t max);  Buffer-based estimate of the histogram range using the power of 2 algorithm. ;  ; Int_t AxisChoice (Option_t *axis) const;  Choose an axis according to ""axis"". ;  ; virtual Int_t BufferFill (Double_t x, Double_t w);  accumulate arguments in buffer. ;  ; virtual void DoFillN (Int_t n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1F.html:42666,update,update,42666,doc/master/classTH1F.html,https://root.cern,https://root.cern/doc/master/classTH1F.html,1,['update'],['update']
Deployability," Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  ;  Static Public Member Functions inherited from TArrayF; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TArray; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TArray * ReadArray (TBuffer &b, const TClass *clReq);  Read TArray object from buffer. ;  ; static void WriteArray (TBuffer &b, const TArray *a);  Write TArray object to buffer. ;  . Protected Member Functions; Double_t RetrieveBinContent (Int_t bin) const override;  Raw retrieval of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ; void UpdateBinContent (Int_t bin, Double_t content) override;  Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ;  Protected Member Functions inherited from TH2;  TH2 ();  2-D histogram default constructor. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins, Int_t nbinsy, const Double_t *ybins);  Constructor for Double_t variable bin size 2-D histograms. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins, Int_t nbinsy, Double_t ylow, Double_t yup);  Constructor for variable bin size (along X axis) 2-D histograms using an input array of type double. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins, Int_t nbinsy, const Float_t *ybins);  Constructor for variable bin size (along X and Y axis) 2-D histograms using input arrays of type float. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, const Double_t *ybins);  Constructor for Double_t variable bin size (al",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2F.html:48648,update,update,48648,doc/master/classTH2F.html,https://root.cern,https://root.cern/doc/master/classTH2F.html,1,['update'],['update']
Deployability," Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  ;  Static Public Member Functions inherited from TArrayI; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TArray; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TArray * ReadArray (TBuffer &b, const TClass *clReq);  Read TArray object from buffer. ;  ; static void WriteArray (TBuffer &b, const TArray *a);  Write TArray object to buffer. ;  . Protected Member Functions; Double_t RetrieveBinContent (Int_t bin) const override;  Raw retrieval of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ; void UpdateBinContent (Int_t bin, Double_t content) override;  Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ;  Protected Member Functions inherited from TH1;  TH1 ();  Histogram default constructor. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins);  Constructor for variable bin size histograms using an input array of type double. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins);  Constructor for variable bin size histograms using an input array of type float. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup);  Constructor for fix bin size histograms. ;  ; virtual Int_t AutoP2FindLimits (Double_t min, Double_t max);  Buffer-based estimate of the histogram range using the power of 2 algorithm. ;  ; Int_t AxisChoice (Option_t *axis) const;  Choose an axis according to ""axis"". ;  ; virtual Int_t BufferFill (Double_t x, Double_t w);  accumulate arguments in buffer. ;  ; virtual void DoFillN (Int_t n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1I.html:42512,update,update,42512,doc/master/classTH1I.html,https://root.cern,https://root.cern/doc/master/classTH1I.html,1,['update'],['update']
Deployability," Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  ;  Static Public Member Functions inherited from TArrayI; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TArray; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TArray * ReadArray (TBuffer &b, const TClass *clReq);  Read TArray object from buffer. ;  ; static void WriteArray (TBuffer &b, const TArray *a);  Write TArray object to buffer. ;  . Protected Member Functions; Double_t RetrieveBinContent (Int_t bin) const override;  Raw retrieval of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ; void UpdateBinContent (Int_t bin, Double_t content) override;  Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ;  Protected Member Functions inherited from TH2;  TH2 ();  2-D histogram default constructor. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins, Int_t nbinsy, const Double_t *ybins);  Constructor for Double_t variable bin size 2-D histograms. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins, Int_t nbinsy, Double_t ylow, Double_t yup);  Constructor for variable bin size (along X axis) 2-D histograms using an input array of type double. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins, Int_t nbinsy, const Float_t *ybins);  Constructor for variable bin size (along X and Y axis) 2-D histograms using input arrays of type float. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, const Double_t *ybins);  Constructor for Double_t variable bin size (al",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2I.html:48565,update,update,48565,doc/master/classTH2I.html,https://root.cern,https://root.cern/doc/master/classTH2I.html,1,['update'],['update']
Deployability," Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  ;  Static Public Member Functions inherited from TArrayS; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TArray; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TArray * ReadArray (TBuffer &b, const TClass *clReq);  Read TArray object from buffer. ;  ; static void WriteArray (TBuffer &b, const TArray *a);  Write TArray object to buffer. ;  . Protected Member Functions; Double_t RetrieveBinContent (Int_t bin) const override;  Raw retrieval of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ; void UpdateBinContent (Int_t bin, Double_t content) override;  Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ;  Protected Member Functions inherited from TH1;  TH1 ();  Histogram default constructor. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins);  Constructor for variable bin size histograms using an input array of type double. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins);  Constructor for variable bin size histograms using an input array of type float. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup);  Constructor for fix bin size histograms. ;  ; virtual Int_t AutoP2FindLimits (Double_t min, Double_t max);  Buffer-based estimate of the histogram range using the power of 2 algorithm. ;  ; Int_t AxisChoice (Option_t *axis) const;  Choose an axis according to ""axis"". ;  ; virtual Int_t BufferFill (Double_t x, Double_t w);  accumulate arguments in buffer. ;  ; virtual void DoFillN (Int_t n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1S.html:42529,update,update,42529,doc/master/classTH1S.html,https://root.cern,https://root.cern/doc/master/classTH1S.html,1,['update'],['update']
Deployability," Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  ;  Static Public Member Functions inherited from TArrayS; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TArray; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TArray * ReadArray (TBuffer &b, const TClass *clReq);  Read TArray object from buffer. ;  ; static void WriteArray (TBuffer &b, const TArray *a);  Write TArray object to buffer. ;  . Protected Member Functions; Double_t RetrieveBinContent (Int_t bin) const override;  Raw retrieval of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ; void UpdateBinContent (Int_t bin, Double_t content) override;  Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ;  Protected Member Functions inherited from TH2;  TH2 ();  2-D histogram default constructor. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins, Int_t nbinsy, const Double_t *ybins);  Constructor for Double_t variable bin size 2-D histograms. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins, Int_t nbinsy, Double_t ylow, Double_t yup);  Constructor for variable bin size (along X axis) 2-D histograms using an input array of type double. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins, Int_t nbinsy, const Float_t *ybins);  Constructor for variable bin size (along X and Y axis) 2-D histograms using input arrays of type float. ;  ;  TH2 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, const Double_t *ybins);  Constructor for Double_t variable bin size (al",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2S.html:48625,update,update,48625,doc/master/classTH2S.html,https://root.cern,https://root.cern/doc/master/classTH2S.html,1,['update'],['update']
Deployability," MakeZombie ();  . Static Protected Member Functions; static const decltype(_stateNames) ::value_type & invalidCategory ();  A category state to signify an invalid category. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  . Protected Attributes; value_type _currentIndex {std::numeric_limits<int>::min()};  Current category state. ;  ; std::vector< std::string > _insertionOrder;  Keeps track in which order state numbers have been inserted. Make sure this is updated in recomputeShape(). ;  ; std::map< value_type, std::unique_ptr< RooCatType, std::function< void(RooCatType *)> > > _legacyStates;  ! Map holding pointers to RooCatType instances. Only for legacy interface. Don't use if possible. ;  ; std::map< std::string, value_type > _stateNames;  Map state names to index numbers. Make sure state names are updated in recomputeShape(). ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategory.html:41600,update,updated,41600,doc/master/classRooAbsCategory.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategory.html,1,['update'],['updated']
Deployability, PdfProposal;  PdfProposal is a concrete implementation of the ProposalFunction interface. More...;  ; class  PointSetInterval;  PointSetInterval is a concrete implementation of the ConfInterval interface. More...;  ; class  PosteriorCdfFunction;  ; class  PosteriorFunction;  ; class  PosteriorFunctionFromToyMC;  Posterior function obtaining sampling toy MC for the nuisance according to their pdf. More...;  ; class  ProfileInspector;  Utility class to plot conditional MLE of nuisance parameters vs. More...;  ; class  ProfileLikelihoodCalculator;  The ProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for tools which can produce both a RooStats HypoTestResult and ConfInterval). More...;  ; class  ProfileLikelihoodTestStat;  ProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset. More...;  ; class  ProofConfig;  Holds configuration options for proof and proof-lite. More...;  ; class  ProposalFunction;  ProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm. More...;  ; class  ProposalHelper;  ; class  RatioOfProfiledLikelihoodsTestStat;  TestStatistic that returns the ratio of profiled likelihoods. More...;  ; struct  RooStatsConfig;  ; class  SamplingDistPlot;  This class provides simple and straightforward utilities to plot SamplingDistribution objects. More...;  ; class  SamplingDistribution;  This class simply holds a sampling distribution of some test statistic. More...;  ; class  SamplingSummary;  ; class  SamplingSummaryLookup;  ; class  SequentialProposal;  Class implementing a proposal function that samples the parameter space by moving only in one coordinate (chosen randomly) at each step. More...;  ; class  SimpleInterval;  SimpleInterval is a concrete implementation of the ConfInterval interface. More...;  ; class  SimpleLikelihoo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooStats.html:6614,configurat,configuration,6614,doc/master/namespaceRooStats.html,https://root.cern,https://root.cern/doc/master/namespaceRooStats.html,1,['configurat'],['configuration']
Deployability," Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooBlindTools _blindEngine;  ; RooRealProxy _value;  ;  Protected Attributes inherited from RooAbsHiddenReal; RooCategoryProxy _state;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooUnblindOffset.html:56989,integrat,integration,56989,doc/master/classRooUnblindOffset.html,https://root.cern,https://root.cern/doc/master/classRooUnblindOffset.html,3,['integrat'],['integration']
Deployability," Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Attributes; RooLinkedList _configSets;  List of configuration sets for individual integration methods. ;  ; RooCategory _method1D;  Selects integration method for 1D p.d.f.s. ;  ; RooCategory _method1DCat;  Selects integration method for 1D p.d.f.s with categories. ;  ; RooCategory _method1DCond;  Selects integration method for 1D conditional p.d.f.s. ;  ; RooCategory _method1DCondCat;  Selects integration method for 1D conditional p.d.f.s with categories. ;  ; RooCategory _method2D;  Selects integration method for 2D p.d.f.s. ;  ; RooCategory _method2DCat;  Selects integration method for 2D p.d.f.s with categories. ;  ; RooCategory _method2DCond;  Selects integration method for 2D conditional p.d.f.s. ;  ; RooCategory _method2DCondCat;  Selects integration method for 2D conditional p.d.f.s with categories. ;  ; RooCategory _methodND;  Selects integration method for ND p.d.f.s. ;  ; RooCategory _methodNDCat;  Selects integration method for ND p.d.f.s with categories. ;  ; RooCategory _methodNDCond;  Selects integration method for ND conditional p.d.f.s. ;  ; RooCategory _methodNDCondCat;  Selects integration method for ND conditional p.d.f.s with categories. ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumGenConfig.html:13015,integrat,integration,13015,doc/master/classRooNumGenConfig.html,https://root.cern,https://root.cern/doc/master/classRooNumGenConfig.html,1,['integrat'],['integration']
Deployability," Rewind (const State &earlierState);  Rewind to an earlier mutex state, returning the delta. ;  ; TVirtualRWMutex::Hint_t * WriteLock ();  Acquire the lock in write mode. ;  ; void WriteUnLock (TVirtualRWMutex::Hint_t *);  Release the lock in write mode. ;  . Private Member Functions; void AssertReadCountLocIsFromCurrentThread (const size_t *presumedLocalReadersCount);  Assert that presumedLocalReadersCount really matches the local read count. ;  . Private Attributes; std::condition_variable_any fCond;  ! RWlock internal condition variable ;  ; MutexT fMutex;  ! RWlock internal mutex ;  ; std::atomic< int > fReaderReservation;  ! A reader wants access ;  ; std::atomic< int > fReaders;  ! Number of readers ;  ; RecurseCountsT fRecurseCounts;  ! Trackers for re-entry in the lock by the same thread. ;  ; std::atomic< bool > fWriter;  ! Is there a writer? ;  ; std::atomic< int > fWriterReservation;  ! A writer wants access ;  . #include </home/sftnight/build/workspace/root-makedoc-v632/rootspi/rdoc/src/v6-32-00-patches/core/thread/src/TReentrantRWLock.hxx>; Member Typedef Documentation. ◆ State. template<typename MutexT = ROOT::TSpinMutex, typename RecurseCountsT = Internal::RecurseCounts> . using ROOT::TReentrantRWLock< MutexT, RecurseCountsT >::State = TVirtualRWMutex::State. Definition at line 299 of file TReentrantRWLock.hxx. ◆ StateDelta. template<typename MutexT = ROOT::TSpinMutex, typename RecurseCountsT = Internal::RecurseCounts> . using ROOT::TReentrantRWLock< MutexT, RecurseCountsT >::StateDelta = TVirtualRWMutex::StateDelta. Definition at line 300 of file TReentrantRWLock.hxx. Constructor & Destructor Documentation. ◆ TReentrantRWLock(). template<typename MutexT = ROOT::TSpinMutex, typename RecurseCountsT = Internal::RecurseCounts> . ROOT::TReentrantRWLock< MutexT, RecurseCountsT >::TReentrantRWLock ; (; ). inline . Regular constructor. ; Definition at line 304 of file TReentrantRWLock.hxx. Member Function Documentation. ◆ Apply(). template<typename MutexT , t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TReentrantRWLock.html:2164,patch,patches,2164,doc/v632/classROOT_1_1TReentrantRWLock.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TReentrantRWLock.html,1,['patch'],['patches']
Deployability," Rndm() [3/3]. virtual Double_t TRandom::Rndm ; (; Int_t ; ). inlinevirtual . Reimplemented from TRandom.; Definition at line 51 of file TRandom.h. ◆ RndmArray() [1/2]. void TRandom3::RndmArray ; (; Int_t ; n, . Double_t * ; array . ). overridevirtual . Return an array of n random numbers uniformly distributed in ]0,1]. ; Reimplemented from TRandom.; Definition at line 151 of file TRandom3.cxx. ◆ RndmArray() [2/2]. void TRandom3::RndmArray ; (; Int_t ; n, . Float_t * ; array . ). overridevirtual . Return an array of n random numbers uniformly distributed in ]0,1]. ; Reimplemented from TRandom.; Definition at line 143 of file TRandom3.cxx. ◆ SetSeed(). void TRandom3::SetSeed ; (; ULong_t ; seed = 0). overridevirtual . Set the random generator sequence if seed is 0 (default value) a TUUID is generated and used to fill the first 8 integers of the seed array. ; In this case the seed is guaranteed to be unique in space and time. Use upgraded seeding procedure to fix a known problem when seeding with values with many zero in the bit pattern (like 2**28). see http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html ; Reimplemented from TRandom.; Definition at line 206 of file TRandom3.cxx. ◆ Streamer(). void TRandom3::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TRandom3. ; Reimplemented from TRandom.; Definition at line 237 of file TRandom3.cxx. ◆ StreamerNVirtual(). void TRandom3::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 47 of file TRandom3.h. Member Data Documentation. ◆ fCount624. Int_t TRandom3::fCount624. private . Definition at line 31 of file TRandom3.h. ◆ fMt. UInt_t TRandom3::fMt[624]. private . Definition at line 30 of file TRandom3.h. Libraries for TRandom3:. [legend]; The documentation for this class was generated from the following files:; math/mathcore/inc/TRandom3.h; math/mathcore/src/TRandom3.cxx. TRandom3. ROOT master - Reference Guide Generated on Tue Nov 5 20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRandom3.html:19313,upgrade,upgraded,19313,doc/master/classTRandom3.html,https://root.cern,https://root.cern/doc/master/classTRandom3.html,1,['upgrade'],['upgraded']
Deployability," Set address of this branch. ;  ; virtual void SetAutoDelete (bool autodel=true);  Set the automatic delete bit. ;  ; virtual void SetBasketSize (Int_t buffsize);  Set the basket size The function makes sure that the basket size is greater than fEntryOffsetlen. ;  ; virtual void SetBufferAddress (TBuffer *entryBuffer);  Set address of this branch directly from a TBuffer to avoid streaming. ;  ; void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  Set compression algorithm. ;  ; void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  Set compression level. ;  ; void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Set compression settings. ;  ; virtual void SetEntries (Long64_t entries);  Set the number of entries in this branch. ;  ; virtual void SetEntryOffsetLen (Int_t len, bool updateSubBranches=false);  Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and the new value is not zero) If updateExisting is true, also update all the existing branches. ;  ; virtual void SetFile (const char *filename);  Set file where this branch writes/reads its buffers. ;  ; virtual void SetFile (TFile *file=nullptr);  Set file where this branch writes/reads its buffers. ;  ; virtual void SetFirstEntry (Long64_t entry);  set the first entry number (case of TBranchSTL) ;  ; void SetIOFeatures (TIOFeatures &features);  ; virtual bool SetMakeClass (bool decomposeObj=true);  Set the branch in a mode where the object are decomposed (Also known as MakeClass mode). ;  ; virtual void SetObject (void *objadd);  Set object this branch is pointing to. ;  ; virtual void SetOffset (Int_t offset=0);  ; virtual void SetStatus (bool status=true);  Set branch status to Process or DoNotProcess. ;  ; virtual void SetTree (TTree *tree);  ; virtual void SetupAddresses ();  If the branch address is not set, we set all addresses startin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:8411,update,updateSubBranches,8411,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,6,['update'],"['update', 'updateExisting', 'updateSubBranches']"
Deployability," SetText (TGText *text);  Adopt a new text buffer. The text will be deleted by this object. ;  ; virtual void SetVsbPosition (Long_t newPos);  Set position of vertical scrollbar. ;  ; virtual void ShowBottom ();  Show bottom of the page. ;  ; virtual void ShowTop ();  Show top of the page. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual Long_t ToObjXCoord (Long_t xCoord, Long_t line);  Convert x screen coordinate to column in specified line. ;  ; virtual Long_t ToObjYCoord (Long_t yCoord);  Convert y screen coordinate to line number. ;  ; virtual Long_t ToScrXCoord (Long_t xCoord, Long_t line);  Convert column number in specified line to screen coordinate. ;  ; virtual Long_t ToScrYCoord (Long_t yCoord);  Convert line number to screen coordinate. ;  ; virtual void Update ();  update the whole window of text view ;  ;  Public Member Functions inherited from TGView;  TGView (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, Int_t id=-1, UInt_t xMargin=0, UInt_t yMargin=0, UInt_t options=kSunkenFrame|kDoubleBorder, UInt_t sboptions=0, Pixel_t back=GetWhitePixel());  Create an editor view, containing an TGEditorFrame and (optionally) a horizontal and vertical scrollbar. ;  ;  ~TGView () override;  Delete view. ;  ; void ChangeBackground (Pixel_t) override;  Change background color of the canvas frame. ;  ; void Clear (Option_t *="""") override;  Clear view. ;  ; void DrawBorder () override;  Draw the border of the text edit widget. ;  ; TGViewFrame * GetCanvas () const;  ; TGDimension GetDefaultSize () const override;  std::cout << fWidth << ""x"" << fHeight << std::endl; ;  ; TGLongPosition GetScrollPosition () const;  ; TGLongPosition GetScrollValue () const;  ; const TGGC & GetViewWhiteGC ();  ; TGDimension GetVirtualSize () const;  ; Bool_t HandleButton (Event_t *event) override;  handle button ;  ; Bool_t HandleExpose (Event_t *event) override;  Handle expose events. ;  ; TClass * IsA () const override;  ; void Layout () override;  layout ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextViewostream.html:5803,update,update,5803,doc/master/classTGTextViewostream.html,https://root.cern,https://root.cern/doc/master/classTGTextViewostream.html,1,['update'],['update']
Deployability," ShowQuota(). void TDataSetManager::ShowQuota ; (; const char * ; opt). virtual . Display quota information. ; Definition at line 585 of file TDataSetManager.cxx. ◆ Streamer(). void TDataSetManager::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TDataSetManagerFile. ◆ StreamerNVirtual(). void TDataSetManager::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 158 of file TDataSetManager.h. ◆ ToBytes(). Long64_t TDataSetManager::ToBytes ; (; const char * ; size = 0). staticprotected . Static utility function to gt the number of bytes from a string representation in the form ""`<digit>``<sfx>`"" with <sfx> = {"""", ""k"", ""M"", ""G"", ""T"", ""P""} (case insensitive). ; Returns -1 if the format is wrong. ; Definition at line 387 of file TDataSetManager.cxx. ◆ UpdateUsedSpace(). void TDataSetManager::UpdateUsedSpace ; (; ). protectedvirtual . updates the used space maps ; Reimplemented in TDataSetManagerFile.; Definition at line 752 of file TDataSetManager.cxx. Member Data Documentation. ◆ fAvgFileSize. Long64_t TDataSetManager::fAvgFileSize. protected . Definition at line 56 of file TDataSetManager.h. ◆ fBase. TUri TDataSetManager::fBase. protected . Definition at line 50 of file TDataSetManager.h. ◆ fCommonGroup. TString TDataSetManager::fCommonGroup. protected . Definition at line 48 of file TDataSetManager.h. ◆ fCommonUser. TString TDataSetManager::fCommonUser. protected . Definition at line 47 of file TDataSetManager.h. ◆ fgCommonDataSetTag. TString TDataSetManager::fgCommonDataSetTag = ""COMMON"". staticprotected . Definition at line 65 of file TDataSetManager.h. ◆ fgDataSetSrvMaps. TList * TDataSetManager::fgDataSetSrvMaps = 0. staticprotected . Definition at line 67 of file TDataSetManager.h. ◆ fGroup. TString TDataSetManager::fGroup. protected . Definition at line 45 of file TDataSetManager.h. ◆ fGroupConfigFile. TString TDataSetManager::fGroupConfi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManager.html:38911,update,updates,38911,doc/master/classTDataSetManager.html,https://root.cern,https://root.cern/doc/master/classTDataSetManager.html,1,['update'],['updates']
Deployability," Streamer(). void RooPlot::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Definition at line 1357 of file RooPlot.cxx. ◆ StreamerNVirtual(). void RooPlot::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 256 of file RooPlot.h. ◆ updateFitRangeNorm() [1/2]. void RooPlot::updateFitRangeNorm ; (; const RooPlotable * ; rp, . bool ; refreshNorm = false . ). protected . Update our plot normalization over our plot variable's fit range, which will be determined by the first suitable object added to our plot. ; Definition at line 562 of file RooPlot.cxx. ◆ updateFitRangeNorm() [2/2]. void RooPlot::updateFitRangeNorm ; (; const TH1 * ; hist). protected . Update our plot normalization over our plot variable's fit range, which will be determined by the first suitable object added to our plot. ; Definition at line 550 of file RooPlot.cxx. ◆ updateNormVars(). void RooPlot::updateNormVars ; (; const RooArgSet & ; vars). Install the given set of observables are reference normalization variables for this frame. ; These observables are e.g. later used to automatically project out observables when plotting functions on this frame. This function is only effective when called the first time on a frame ; Definition at line 351 of file RooPlot.cxx. ◆ updateYAxis(). void RooPlot::updateYAxis ; (; double ; ymin, . double ; ymax, . const char * ; label = """" . ). protected . Update our y-axis limits to accommodate an object whose spread in y is (ymin,ymax). ; Use the specified y-axis label if we don't have one assigned already. ; Definition at line 605 of file RooPlot.cxx. Member Data Documentation. ◆ _addDirStatus. bool RooPlot::_addDirStatus = true. staticprotected . static flag controlling AutoDirectoryAdd feature ; Definition at line 254 of file RooPlot.h. ◆ _defYmax. double RooPlot::_defYmax = 1.0. protected . Default maximum for Yaxis (as calculated from contents) ; Definition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPlot.html:55127,update,updateNormVars,55127,doc/master/classRooPlot.html,https://root.cern,https://root.cern/doc/master/classRooPlot.html,1,['update'],['updateNormVars']
Deployability," TGLViewerEditor (const TGWindow *p=nullptr, Int_t width=140, Int_t height=30, UInt_t options=kChildFrame, Pixel_t back=GetDefaultFrameBackground());  ;  ~TGLViewerEditor () override;  ; void DetachFromPad ();  ; void DoAnnotation ();  Create annotation via picking. ;  ; void DoASavImageGUIBaseName (const char *t);  Update base-name. ;  ; void DoASavImageGUIOutMode (Int_t m);  Update output mode. ;  ; void DoASavImageStart ();  Start auto-rotator image auto-save. ;  ; void DoASavImageStop ();  Stop auto-rotator image auto-save. ;  ; void DoCameraCenterExt ();  Set external camera center. ;  ; void DoCameraHome ();  CameraHome was clicked. ;  ; void DoCameraOverlay ();  Update viewer with GUI state. ;  ; void DoCaptureCenter ();  Capture camera-center via picking. ;  ; void DoClearColor (Pixel_t color);  Clear-color was changed. ;  ; void DoDrawCameraCenter ();  Draw camera center. ;  ; void DoIgnoreSizesOnUpdate ();  ResetCamerasOnUpdate was toggled. ;  ; void DoResetCamerasOnUpdate ();  ResetCamerasOnUpdate was toggled. ;  ; void DoRotatorStart ();  Start auto-rotator. ;  ; void DoRotatorStop ();  Stop auto-rotator. ;  ; void DoUpdateScene ();  UpdateScene was clicked. ;  ; TClass * IsA () const override;  ; void SetGuides ();  Configuration of guides GUI called from SetModel(). ;  ; void SetModel (TObject *obj) override;  Sets model or disables/hides viewer. ;  ; void SetRotatorMode ();  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UpdateCameraCenter ();  Update current camera with GUI state. ;  ; void UpdateMaxDrawTimes ();  Slot for fMaxSceneDrawTimeHQ and fMaxSceneDrawTimeLQ. ;  ; void UpdatePointLineStuff ();  Slot for point-sizes and line-widths. ;  ; void UpdateRotator ();  Update rotator related variables. ;  ; void UpdateStereo ();  Update stereo related variables. ;  ; void UpdateViewerAxes (Int_t id);  Update viewer with GUI state. ;  ; void UpdateView",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLViewerEditor.html:1484,toggle,toggled,1484,doc/master/classTGLViewerEditor.html,https://root.cern,https://root.cern/doc/master/classTGLViewerEditor.html,1,['toggle'],['toggled']
Deployability," Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Types; enum  IntOperMode { Hybrid; , Analytic; , PassThrough; };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; RooArgSet const * actualFuncNormSet () const;  ; void autoSelectDirtyMode ();  Set appropriate cache operation mode for integral depending on cache operation mode of server objects. ;  ; double evaluate () const override;  Perform the integration and return the result. ;  ; bool initNumIntegrator () const;  (Re)Initialize numerical integration engine if necessary. ;  ; virtual double integrate () const;  Perform hybrid numerical/analytical integration over all real-valued dependents. ;  ; bool isValidReal (double value, bool printError=false) const override;  Check if current value is valid. ;  ; virtual double jacobianProduct () const;  Return product of jacobian terms originating from analytical integration. ;  ; const RooArgSet & parameters () const;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursive) override;  Intercept server redirects and reconfigure internal object accordingly. ;  ; virtual double sum () const;  Perform summation of list of category dependents to be integrated. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of gi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:49823,integrat,integration,49823,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['integrat'],['integration']
Deployability, _method1DCond. RooCategory RooNumGenConfig::_method1DCond. protected . Selects integration method for 1D conditional p.d.f.s. ; Definition at line 60 of file RooNumGenConfig.h. ◆ _method1DCondCat. RooCategory RooNumGenConfig::_method1DCondCat. protected . Selects integration method for 1D conditional p.d.f.s with categories. ; Definition at line 61 of file RooNumGenConfig.h. ◆ _method2D. RooCategory RooNumGenConfig::_method2D. protected . Selects integration method for 2D p.d.f.s. ; Definition at line 63 of file RooNumGenConfig.h. ◆ _method2DCat. RooCategory RooNumGenConfig::_method2DCat. protected . Selects integration method for 2D p.d.f.s with categories. ; Definition at line 64 of file RooNumGenConfig.h. ◆ _method2DCond. RooCategory RooNumGenConfig::_method2DCond. protected . Selects integration method for 2D conditional p.d.f.s. ; Definition at line 65 of file RooNumGenConfig.h. ◆ _method2DCondCat. RooCategory RooNumGenConfig::_method2DCondCat. protected . Selects integration method for 2D conditional p.d.f.s with categories. ; Definition at line 66 of file RooNumGenConfig.h. ◆ _methodND. RooCategory RooNumGenConfig::_methodND. protected . Selects integration method for ND p.d.f.s. ; Definition at line 68 of file RooNumGenConfig.h. ◆ _methodNDCat. RooCategory RooNumGenConfig::_methodNDCat. protected . Selects integration method for ND p.d.f.s with categories. ; Definition at line 69 of file RooNumGenConfig.h. ◆ _methodNDCond. RooCategory RooNumGenConfig::_methodNDCond. protected . Selects integration method for ND conditional p.d.f.s. ; Definition at line 70 of file RooNumGenConfig.h. ◆ _methodNDCondCat. RooCategory RooNumGenConfig::_methodNDCondCat. protected . Selects integration method for ND conditional p.d.f.s with categories. ; Definition at line 71 of file RooNumGenConfig.h. Libraries for RooNumGenConfig:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooNumGenConfig.h; roofit/roofitcore/src/Roo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumGenConfig.html:21189,integrat,integration,21189,doc/master/classRooNumGenConfig.html,https://root.cern,https://root.cern/doc/master/classRooNumGenConfig.html,1,['integrat'],['integration']
Deployability," createProjection (const RooArgSet &iset) override;  Special version of RooAbsReal::createProjection that deals with projections of projections. ;  ; double expectedEvents (const RooArgSet *nset) const override;  Return expected number of events to be used in calculation of extended likelihood. ;  ; ExtendMode extendMode () const override;  Returns ability of PDF to provide extended likelihood terms. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  Force RooRealIntegral to relegate integration of all observables to internal logic. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Mark all requested variables as internally integrated. ;  ; void initGenerator (Int_t) override;  Interface for one-time initialization to setup the generator for the specified code. ;  ; TClass * IsA () const override;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the integration operation. ;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") const;  ; virtual Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProjectedPdf.html:2991,integrat,integration,2991,doc/master/classRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classRooProjectedPdf.html,1,['integrat'],['integration']
Deployability," kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TClassMenuItem ();  Default TClassMenuItem ctor. ;  ;  TClassMenuItem (Int_t type, TClass *parent, const char *title="""", const char *functionname="""", TObject *obj=nullptr, const char *args="""", Int_t selfobjposition=-1, Bool_t self=kFALSE);  TClassMenuItem ctor. ;  ; virtual ~TClassMenuItem ();  TClassMenuItem dtor. ;  ; virtual const char * GetArgs () const;  ; virtual TObject * GetCalledObject () const;  ; virtual const char * GetFunctionName () const;  ; virtual Int_t GetSelfObjectPos () const;  ; const char * GetTitle () const override;  Returns title of object. ;  ; virtual Int_t GetType () const;  ; TClass * IsA () const override;  ; virtual Bool_t IsCallSelf () const;  ; virtual Bool_t IsSeparator () const;  ; virtual Bool_t IsStandardList () const;  ; virtual Bool_t IsToggle () const;  ; virtual void SetCall (TObject *obj, const char *method, const char *args="""", Int_t selfobjposition=0);  ; virtual void SetSelf (Bool_t self);  ; virtual void SetTitle (const char *title);  ; virtual void SetToggle (Bool_t toggle=kTRUE);  ; virtual void SetType (Int_t type);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassMenuItem.html:2787,toggle,toggle,2787,doc/master/classTClassMenuItem.html,https://root.cern,https://root.cern/doc/master/classTClassMenuItem.html,1,['toggle'],['toggle']
Deployability," printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Protected Member Functions; double evaluate () const override;  Evaluate projected p.d.f. ;  ;  Protected Member Functions inherited from RooProjectedPdf; const RooAbsReal * getProjection (const RooArgSet *iset, const RooArgSet *nset, const char *rangeName, int &code) const;  Retrieve object representing projection integral of input p.d.f over observables iset, while normalizing over observables nset. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool, bool, bool) override;  Intercept a server redirection all and update list of dependents if necessary Specifically update the set proxy 'deps' which introduces the dependency on server value dirty flags of ourselves. ;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *normSet) const;  Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ;  ; double normalizeWithNaNPacking (double rawVal, double normVal) const;  ; RooPlot * plotOn (RooPlot *frame, PlotOpt o) const override;  Plot onesel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classxRooProjectedPdf.html:56236,update,update,56236,doc/master/classxRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classxRooProjectedPdf.html,2,['update'],['update']
Deployability," registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooTemplateProxy< RooRealVar > _meas;  ; RooRealProxy _true;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPullVar.html:54969,integrat,integration,54969,doc/master/classRooPullVar.html,https://root.cern,https://root.cern/doc/master/classRooPullVar.html,1,['integrat'],['integration']
Deployability," unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:75776,integrat,integration,75776,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['integrat'],['integration']
Deployability," unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooListProxy _coefList;  ; RooListProxy _expList;  ; std::vector< double > _wksp;  ; RooRealProxy _x;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPowerSum.html:68107,configurat,configuration,68107,doc/master/classRooPowerSum.html,https://root.cern,https://root.cern/doc/master/classRooPowerSum.html,1,['configurat'],['configuration']
Deployability,"» MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; User Class for performing numerical integration of a function in one dimension. ; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Various types of adaptive and non-adaptive integration are supported. These include integration over infinite and semi-infinite ranges and singular integrals.; The integration type is selected using the Integration::type enumeration in the class constructor. The default type is adaptive integration with singularity (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule. In the case of ADAPTIVE type, the integration rule can also be specified via the Integration::GKRule. The default rule is 31 points.; In the case of integration over infinite and semi-infinite ranges, the type used is always ADAPTIVESINGULAR applying a transformation from the original interval into (0,1).; The ADAPTIVESINGULAR type is the most sophisticated type. When performances are important, it is then recommended to use the NONADAPTIVE type in case of smooth functions or ADAPTIVE with a lower Gauss-Kronrod rule.; For detailed description on GSL integration algorithms see the GSL Manual. ; Definition at line 98 of file Integrator.h. Public Types; typedef IntegrationOneDim::Type Type;  . Public Member Functions;  IntegratorOneDim (const IGenFunction &f, IntegrationOneDim::Type type=IntegrationOneDim::kDEFAULT, double absTol=-1, double relTol=-1, unsigned int size=0, int rule=0);  Constructor of one dimensional Integrator passing a function interface. ;  ; template<class Function > ;  IntegratorOneDim (Function &f, IntegrationOneDim::Type type=IntegrationOneDim::kDEFAULT, double absTol=-1, double relTol=-1, unsigned int size=0, int rule=0);  Template Constructor of one dimensional Integrator passin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html:1316,integrat,integration,1316,doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,1,['integrat'],['integration']
Deployability,"◆ DeclFileName(). static const char * RooCBShape::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 62 of file RooCBShape.h. ◆ doEval(). void RooCBShape::doEval ; (; RooFit::EvalContext & ; ctx); const. overrideprotectedvirtual . Compute multiple values of Crystal ball Shape distribution. ; Reimplemented from RooAbsReal.; Definition at line 74 of file RooCBShape.cxx. ◆ evaluate(). double RooCBShape::evaluate ; (; ); const. overrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 62 of file RooCBShape.cxx. ◆ getAnalyticalIntegral(). Int_t RooCBShape::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 82 of file RooCBShape.cxx. ◆ getMaxVal(). Int_t RooCBShape::getMaxVal ; (; const RooArgSet & ; vars); const. overridevirtual . Advertise that we know the maximum of self for given (m0,alpha,n,sigma) ; Reimplemented from RooAbsReal.; Definition at line 108 of file RooCBShape.cxx. ◆ IsA(). TClass * RooCBShape::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 62 of file RooCBShape.h. ◆ maxVal(). double RooCBShape::maxVal ; (; Int_t ; code); const. overridevirtual . Return maximum value for set of observables identified by code assigned in getMaxVal. ; Reimplemented from RooAbsReal.; Defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCBShape.html:76858,integrat,integration,76858,doc/master/classRooCBShape.html,https://root.cern,https://root.cern/doc/master/classRooCBShape.html,1,['integrat'],['integration']
Deployability,"◆ SwapValues(). void TGraph::SwapValues ; (; Double_t * ; arr, . Int_t ; pos1, . Int_t ; pos2 . ). staticprotected . Swap values. ; Definition at line 2611 of file TGraph.cxx. ◆ UpdateArrays(). void TGraph::UpdateArrays ; (; const std::vector< Int_t > & ; sorting_indices, . Int_t ; numSortedPoints, . Int_t ; low . ). protectedvirtual . Update the fX and fY arrays with the sorted values. ; Reimplemented in TGraphAsymmErrors, TGraphBentErrors, TGraphErrors, and TGraphMultiErrors.; Definition at line 2592 of file TGraph.cxx. ◆ UseCurrentStyle(). void TGraph::UseCurrentStyle ; (; ). overridevirtual . Set current style settings in this graph This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ; Reimplemented from TObject.; Definition at line 2623 of file TGraph.cxx. ◆ Zero(). void TGraph::Zero ; (; Int_t & ; k, . Double_t ; AZ, . Double_t ; BZ, . Double_t ; E2, . Double_t & ; X, . Double_t & ; Y, . Int_t ; maxiterations . ). Find zero of a continuous function. ; This function finds a real zero of the continuous real function Y(X) in a given interval (A,B). See accompanying notes for details of the argument list and calling sequence ; Definition at line 2717 of file TGraph.cxx. Member Data Documentation. ◆ fFunctions. TList* TGraph::fFunctions. protected . Pointer to list of functions (fits and user) ; Definition at line 49 of file TGraph.h. ◆ fHistogram. TH1F* TGraph::fHistogram. protected . Pointer to histogram used for drawing axis. ; Definition at line 50 of file TGraph.h. ◆ fMaximum. Double_t TGraph::fMaximum. protected . Maximum value for plotting along y. ; Definition at line 52 of file TGraph.h. ◆ fMaxSize. Int_t TGraph::fMaxSize. protected . !Current dimension of arrays fX and fY ; Definition at line 45 of file TGraph.h. ◆ fMinimum. Double_t TGraph::fMinimum. protected . Minimum value for plotting along y. ; Definition at line 51 of file TGraph.h. ◆ fNpoints. Int_t TGraph::fNpoints. protected . Number of points <= ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph.html:76330,continuous,continuous,76330,doc/master/classTGraph.html,https://root.cern,https://root.cern/doc/master/classTGraph.html,1,['continuous'],['continuous']
Deployability,"◆ ~TEveCaloData(). TEveCaloData::~TEveCaloData ; (; ). inlineoverride . Definition at line 175 of file TEveCaloData.h. Member Function Documentation. ◆ CellSelectionChanged(). void TEveCaloData::CellSelectionChanged ; (; ). virtual . Tell users (TEveCaloViz instances using this data) that cell selection has changed and they should update selection cache if necessary. ; This is done by calling TEveCaloViz::CellSelectionChanged(). ; Definition at line 398 of file TEveCaloData.cxx. ◆ Class(). static TClass * TEveCaloData::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TEveCaloData::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TEveCaloData::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 233 of file TEveCaloData.h. ◆ DataChanged(). void TEveCaloData::DataChanged ; (; ). virtual . Tell users (TEveCaloViz instances using this data) that data has changed and they should update the limits/scales etc. ; This is done by calling TEveCaloViz::DataChanged(). ; Reimplemented in TEveCaloDataVec, and TEveCaloDataHist.; Definition at line 382 of file TEveCaloData.cxx. ◆ DeclFileName(). static const char * TEveCaloData::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 233 of file TEveCaloData.h. ◆ Empty(). Bool_t TEveCaloData::Empty ; (; ); const. inline . Definition at line 216 of file TEveCaloData.h. ◆ EtaToTheta(). Float_t TEveCaloData::EtaToTheta ; (; Float_t ; eta). static . Definition at line 411 of file TEveCaloData.cxx. ◆ FillImpliedSelectedSet(). void TEveCaloData::FillImpliedSelectedSet ; (; Set_t & ; impSelSet). overridevirtual . Populate set impSelSet with derived / dependant elements. ; Reimplemented from TEveElement.; Definition at line 178 of file TEveCaloData.cxx. ◆ GetCellData(). virtual void TEveCaloData::GetCellData ; (; const CellId_t & ; id, . Cell",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCaloData.html:35622,update,update,35622,doc/master/classTEveCaloData.html,https://root.cern,https://root.cern/doc/master/classTEveCaloData.html,1,['update'],['update']
Deployability,"��������� ; �������������������������������������������; kBackDecreasingWindow��������������������� ; ������� filterType-type; of the clipping algorithm,����������������������������� ; ����������������� -possible values=kBack SuccessiveFiltering; ���������������������������������������������; kBackOneStepFiltering����������������������������� ;  ; References:; [1]�; C. G Ryan et al.: SNIP, a statistics-sensitive background treatment for the; quantitative analysis of PIXE spectra in geoscience applications. NIM, B34; (1988), 396-402.; [2]; �M. Morh�č, J. Kliman, V.; Matou�ek, M. Veselsk�, I. Turzo.:; Background elimination methods for multidimensional gamma-ray spectra. NIM,; A401 (1997) 113-132. . Example 1� script Back_gamma64.c; :. Fig.; 1 Original two-dimensional gamma-gamma-ray spectrum. Fig.; 2 Background estimated from data from Fig. 1 using decreasing clipping window with; widths 4, 4 and algorithm based on successive comparisons. The estimate; includes not only continuously changing background but also one-dimensional; ridges. Fig.; 3 Resulting peaks after subtraction of the estimated background (Fig. 2) from original; two-dimensional gamma-gamma-ray spectrum (Fig. 1).;  ;  ; Script:; // Example to illustrate the background estimator (class; TSpectrum).; // To execute this example, do; // root > .x Back_gamma64.C;  ; #include <TSpectrum> ;  ; void Back_gamma64() {; �� Int_t i, j;; �� Double_t nbinsx = 64;; �� Double_t nbinsy = 64;�� ; �� Double_t xmin� = 0;; �� Double_t xmax� = (Double_t)nbinsx;; �� Double_t ymin� = 0;; �� Double_t ymax� = (Double_t)nbinsy;�� ; �� Double_t ** source = new Double_t*[nbinsx];�� ; �� for (i=0;i<nbinsx;i++); ����� source[i]=new Double_t[nbinsy];���� ; �� TH2F *back = new TH2F(""back"",""Background estimation"",nbinsx,xmin,xmax,nbinsy,ymin,ymax);; �� TFile *f = new; TFile(""spectra2\\TSpectrum2.root"");; �� back=(TH2F*) f->Get(""back1;1"");; �� TCanvas *Background = new; TCanvas(""Background"",""Estimation of background with increasing; wind",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum2.html:17330,continuous,continuously,17330,root/html602/TSpectrum2.html,https://root.cern,https://root.cern/root/html602/TSpectrum2.html,4,['continuous'],['continuously']
Deployability,"��������� ; �������������������������������������������; kBackDecreasingWindow��������������������� ; ������� filterType-type; of the clipping algorithm,����������������������������� ; ����������������� -possible values=kBack SuccessiveFiltering; ���������������������������������������������; kBackOneStepFiltering����������������������������� ;  ; References:; [1]�; C. G Ryan et al.: SNIP, a statistics-sensitive background treatment for the; quantitative analysis of PIXE spectra in geoscience applications. NIM, B34; (1988), 396-402.; [2]; �M. Morh�č, J. Kliman, V.; Matou�ek, M. Veselsk�, I. Turzo.:; Background elimination methods for multidimensional gamma-ray spectra. NIM,; A401 (1997) 113-132. . Example 1� script Back_gamma64.c; :. Fig.; 1 Original two-dimensional gamma-gamma-ray spectrum. Fig.; 2 Background estimated from data from Fig. 1 using decreasing clipping window with; widths 4, 4 and algorithm based on successive comparisons. The estimate; includes not only continuously changing background but also one-dimensional; ridges. Fig.; 3 Resulting peaks after subtraction of the estimated background (Fig. 2) from original; two-dimensional gamma-gamma-ray spectrum (Fig. 1).;  ;  ; Script:; // Example to illustrate the background estimator (class; TSpectrum).; // To execute this example, do; // root > .x Back_gamma64.C;  ; #include <TSpectrum> ;  ; void Back_gamma64() {; �� Int_t i, j;; �� Double_t nbinsx = 64;; �� Double_t nbinsy = 64;�� ; �� Double_t xmin� = 0;; �� Double_t xmax� = (Double_t)nbinsx;; �� Double_t ymin� = 0;; �� Double_t ymax� = (Double_t)nbinsy;�� ; �� Float_t ** source = new float *[nbinsx];�� ; �� for (i=0;i<nbinsx;i++); ����� source[i]=new float[nbinsy];���� ; �� TH2F *back = new TH2F(""back"",""Background estimation"",nbinsx,xmin,xmax,nbinsy,ymin,ymax);; �� TFile *f = new; TFile(""spectra2\\TSpectrum2.root"");; �� back=(TH2F*) f->Get(""back1;1"");; �� TCanvas *Background = new; TCanvas(""Background"",""Estimation of background with increasing; window"",10",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2.html:16562,continuous,continuously,16562,root/html528/TSpectrum2.html,https://root.cern,https://root.cern/root/html528/TSpectrum2.html,6,['continuous'],['continuously']
Energy Efficiency," ""leaks"",; i.e. the memory of your process grows and eventually your program crashes.; Even if you *always* delete the allocated memory, the recovered space may not be; efficiently reused. The process knows that there are portions of free memory,; but when you allocate it again, a fresh piece of memory is grabbed.; Your program is free from semantic errors, but the total memory of your process; still grows. Moreover your program's memory is full of ""holes"" which reduce the; efficiency of memory access, this is called ""memory fragmentation"".; Moreover new / delete are expensive operations in terms of CPU time. Without entering into technical details, the TClonesArray allow to ""reuse"" the; same portion of memory for new/delete avoiding memory fragmentation and memory; growth and improving by orders of magnitude the performance. Every time the; memory of the TClonesArray has to be reused, the Clear() method is employed.; To provide its benefits, each TClonesArray must be allocated *once* per process; and disposed of (deleted) *only when not needed any more*.; So a job should see *only one* deletion for each TClonesArray, which should be; ""Cleared()"" in between several times. Keep deleting a TClonesArray is a double; waste. Not only you do not avoid memory fragmentation, but you worsen it because; the TClonesArray itself is a rather heavy structure, and there is quite some; code in the destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve program; execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used for; clearing TClonesArray. When option ""C"" is specified, ROOT automatically; executes the Clear() method (by default it is empty contained in TObject).; This method must be overridden in the relevant TClonesArray obje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:2580,allocate,allocated,2580,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,2,['allocate'],['allocated']
Energy Efficiency," ""single"" in s: stop_norm = ""mcWeight / abs(mcWeight)""; else: stop_norm = ""mcWeight""; df[s] = df[s].Define(""weight"", ""scaleFactor_ELE * scaleFactor_MUON * scaleFactor_LepTRIGGER * scaleFactor_PILEUP * scaleFactor_BTAG * {} * {} / {} * {}"".format(stop_norm, xsecs[s], sumws[s], lumi)); ; # Reconstruct the top mass from the lepton, the missing transverse energy and the b-jet; ; # Just-in-time compile the function to compute the top mass from the constituents; ROOT.gInterpreter.Declare(""""""; float ComputeTopMass(float lep_pt, float lep_eta, float lep_phi, float lep_e, float jet_pt, float jet_eta, float jet_phi, float jet_e, float met_et, float met_phi); {; const ROOT::Math::PtEtaPhiEVector lep(lep_pt / 1000.0, lep_eta, lep_phi, lep_e / 1000.0);; const ROOT::Math::PtEtaPhiEVector met(met_et / 1000.0, 0, met_phi, met_et / 1000.0);; const ROOT::Math::PtEtaPhiEVector bjet(jet_pt / 1000.0, jet_eta, jet_phi, jet_e / 1000.0);; // Please note that we treat here the missing transverse energy as the neutrino, even though the z component is missing!; return (lep + met + bjet).M();; }; """"""); ; histos = {}; for s in samples:; df[s] = df[s].Define(""top_mass"", ""ComputeTopMass(lep_pt[idx_lep], lep_eta[idx_lep], lep_phi[idx_lep], lep_E[idx_lep], jet_pt[idx_tagged], jet_eta[idx_tagged], jet_phi[idx_tagged], jet_E[idx_tagged], met_et, met_phi)""); histos[s] = df[s].Histo1D(ROOT.RDF.TH1DModel(""top_mass"", """", 10, 100, 400), ""top_mass"", ""weight""); ; # Run the event loop and merge histograms of the respective processes; ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([histos[s] for s in samples]); ; def merge_histos(label):; h = None; for i, d in enumerate(files[label]):; t = histos[d[1]].GetValue(); if i == 0: h = t.Clone(); else: h.Add(t); h.SetNameTi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:7736,energy,energy,7736,doc/master/df107__SingleTopAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html,1,['energy'],['energy']
Energy Efficiency," #include <unistd.h>. Include dependency graph for TGX11.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  RVisual;  ; struct  RXColor;  ; struct  RXGCValues;  ; struct  RXImage;  ; struct  RXPoint;  ; struct  RXVisualInfo;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Functions; static Int_t DummyX11ErrorHandler (Display *, XErrorEvent *);  Dummy error handler for X11. Used by FindUsableVisual(). ;  ; static void GetPixel (int y, int width, Byte_t *scline);  Get pixels in line y and put in array scline. ;  ; int GIFdecode (Byte_t *gifArr, Byte_t *pixArr, int *Width, int *Height, int *Ncols, Byte_t *R, Byte_t *G, Byte_t *B);  ; long GIFencode (int Width, int Height, Int_t Ncol, Byte_t R[], Byte_t G[], Byte_t B[], Byte_t ScLine[], void(*get_scline)(int, int, Byte_t *), void(*pb)(Byte_t));  ; int GIFinfo (Byte_t *gifArr, int *Width, int *Height, int *Ncols);  ; int GIFquantize (UInt_t width, UInt_t height, Int_t *ncol, Byte_t *red, Byte_t *green, Byte_t *blue, Byte_t *outputBuf, Byte_t *outputCmap);  ; static void PutByte (Byte_t b);  Put byte b in output stream. ;  ; int XRotDrawAlignedImageString (Display *, XFontStruct *, float, Drawable, GC, int, int, char *, int);  A front end to XRotPaintAlignedString: -does alignment, paints background. ;  ; int XRotDrawAlignedString (Display *, XFontStruct *, float, Drawable, GC, int, int, char *, int);  A front end to XRotPaintAlignedString: -does alignment, no background. ;  ; int XRotDrawImageString (Display *, XFontStruct *, float, Drawable, GC, int, int, char *);  A front end to XRotPaintAlignedString: -no alignment, paints background. ;  ; int XRotDrawString (Display *, XFontStruct *, float, Drawable, GC, int, int, char *);  A front end to XRotPaintAlignedString: -no alignment, no background. ;  ; void XRotSetBounding",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx.html:1892,green,green,1892,doc/master/TGX11_8cxx.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx.html,2,['green'],['green']
Energy Efficiency," &r, RLoopManager &df,; 84 std::shared_ptr<ROOT::Internal::RDF::RActionBase> actionPtr);; 85 ; 86// Fwd decl for GetMergeableValue; 87template <typename T>; 88class RMergeableValue;; 89 ; 90template <typename T>; 91std::unique_ptr<RMergeableValue<T>> GetMergeableValue(RResultPtr<T> &rptr);; 92} // namespace RDF; 93} // namespace Detail; 94namespace RDF {; 95namespace RDFInternal = ROOT::Internal::RDF;; 96namespace RDFDetail = ROOT::Detail::RDF;; 97namespace TTraits = ROOT::TypeTraits;; 98 ; 99/// Smart pointer for the return type of actions; 100/**; 101\class ROOT::RDF::RResultPtr; 102\ingroup dataframe; 103\brief A wrapper around the result of RDataFrame actions able to trigger calculations lazily.; 104\tparam T Type of the action result; 105 ; 106A smart pointer which allows to access the result of a RDataFrame action. The; 107methods of the encapsulated object can be accessed via the arrow operator.; 108Upon invocation of the arrow operator or dereferencing (`operator*`), the; 109loop on the events and calculations of all scheduled actions are executed; 110if needed.; 111It is possible to iterate on the result proxy if the proxied object is a collection.; 112~~~{.cpp}; 113for (auto& myItem : myResultProxy) { ... };; 114~~~; 115If iteration is not supported by the type of the proxied object, a compilation error is thrown.; 116 ; 117*/; 118template <typename T>; 119class RResultPtr {; 120 // private using declarations; 121 using SPT_t = std::shared_ptr<T>;; 122 ; 123 // friend declarations; 124 template <typename T1>; 125 friend class RResultPtr;; 126 ; 127 template <typename T1>; 128 friend RResultPtr<T1> RDFDetail::MakeResultPtr(const std::shared_ptr<T1> &, ::ROOT::Detail::RDF::RLoopManager &,; 129 std::shared_ptr<RDFInternal::RActionBase>);; 130 ; 131 template <typename T1>; 132 friend ROOT::RDF::Experimental::RResultMap<T1> ROOT::RDF::Experimental::VariationsFor(RResultPtr<T1> resPtr);; 133 ; 134 template <class T1, class T2>; 135 friend bool operator==(const RR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultPtr_8hxx_source.html:4120,schedul,scheduled,4120,doc/master/RResultPtr_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html,1,['schedul'],['scheduled']
Energy Efficiency," & ; os = std::cout . ). static . print only the specified default options ; print default options ; Definition at line 215 of file IntegratorOptions.cxx. ◆ SetDefaultAbsTolerance(). void ROOT::Math::IntegratorOneDimOptions::SetDefaultAbsTolerance ; (; double ; tol). static . Definition at line 246 of file IntegratorOptions.cxx. ◆ SetDefaultIntegrator(). void ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator ; (; const char * ; name). static . Definition at line 222 of file IntegratorOptions.cxx. ◆ SetDefaultNPoints(). void ROOT::Math::IntegratorOneDimOptions::SetDefaultNPoints ; (; unsigned int ; n). static . Definition at line 259 of file IntegratorOptions.cxx. ◆ SetDefaultRelTolerance(). void ROOT::Math::IntegratorOneDimOptions::SetDefaultRelTolerance ; (; double ; tol). static . Definition at line 250 of file IntegratorOptions.cxx. ◆ SetDefaultWKSize(). void ROOT::Math::IntegratorOneDimOptions::SetDefaultWKSize ; (; unsigned int ; size). static . Definition at line 255 of file IntegratorOptions.cxx. ◆ SetIntegrator(). void ROOT::Math::IntegratorOneDimOptions::SetIntegrator ; (; const char * ; name). set 1D integrator name ; Definition at line 197 of file IntegratorOptions.cxx. ◆ SetNPoints(). void ROOT::Math::IntegratorOneDimOptions::SetNPoints ; (; unsigned int ; n). inline . Set number of points for active integration rule. . For the GSL adaptive integrator, n = 1,2,3,4,5,6 correspond to the 15,21,31,41,51,61-point integration rules.; For the GaussLegendre integrator, use values > 6, which correspond to the actual number of points being evaluated. . Definition at line 140 of file IntegratorOptions.h. Libraries for ROOT::Math::IntegratorOneDimOptions:. [legend]; The documentation for this class was generated from the following files:; math/mathcore/inc/Math/IntegratorOptions.h; math/mathcore/src/IntegratorOptions.cxx. ROOTMathIntegratorOneDimOptions. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDimOptions.html:8753,adapt,adaptive,8753,doc/master/classROOT_1_1Math_1_1IntegratorOneDimOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDimOptions.html,1,['adapt'],['adaptive']
Energy Efficiency," ( 13 )). };  ;  Public Attributes inherited from TArrayL64; Long64_t * fArray;  ;  Public Attributes inherited from TArray; Int_t fN;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TH3; static TH1D * DoProject1D (const TH3 &h, const char *name, const char *title, const TAxis *projX, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 1D histogram ;  ; static TH2D * DoProject2D (const TH3 &h, const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 2D histogram ;  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Check histogram compatibility. ;  ; static bool CheckConsistentSubAxes (const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0);  Check that two sub axis are the same. ;  ; static bool CheckEqualAxes (const TAxis *a1, const TAxis *a2);  Check that the axis are the same. ;  ; static Bool_t RecomputeAxisLimits (TAxis &destAxis, const TAxis &anAxis);  Finds new limits for the axis for the Merge function. ;  ; static Bool_t SameLimitsAndNBins (const TAxis &axis1, const TAxis &axis2);  S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3L.html:57502,power,power,57502,doc/master/classTH3L.html,https://root.cern,https://root.cern/doc/master/classTH3L.html,1,['power'],['power']
Energy Efficiency," ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TXMLDocument.h>. Inheritance diagram for TXMLDocument:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TXMLDocument() [1/2]. TXMLDocument::TXMLDocument ; (; const TXMLDocument & ; ). privatedelete . ◆ TXMLDocument() [2/2]. TXMLDocument::TXMLDocument ; (; _xmlDoc * ; doc). TXMLDocument constructor. ; Definition at line 30 of file TXMLDocument.cxx. ◆ ~TXMLDocument(). TXMLDocument::~TXMLDocument ; (; ). override . TXMLDocument destructor. ; Free the global variables that may have been allocated by the parser. ; Definition at line 44 of file TXMLDocument.cxx. Member Function Documentation. ◆ Class(). static TClass * TXMLDocument::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TXMLDocument::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TXMLDocument::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 40 of file TXMLDocument.h. ◆ DeclFileName(). static const char * TXMLDocument::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 40 of file TXMLDocument.h. ◆ Encoding(). const char * TXMLDocument::Encoding ; (; ); const. Returns external initial encoding, if any or 0 in case there is no document set. ; Definition at line 72 of file TXMLDocument.cxx. ◆ GetRootNode(). TXMLNode * TXMLDocument::GetRootNode ; (; ); const. Returns the root element node. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLDocument.html:11235,allocate,allocated,11235,doc/master/classTXMLDocument.html,https://root.cern,https://root.cern/doc/master/classTXMLDocument.html,1,['allocate'],['allocated']
Energy Efficiency," (!HasInterpreterInfo() && !fCollectionProxy) {; 5559 // There is no dictionary at all and we do not have; 5560 // the services of a collection proxy available, so; 5561 // use the streamer info to approximate calling the; 5562 // array destructor.; 5563 ; 5564 Bool_t inRepo = kTRUE;; 5565 Bool_t currentVersion = kFALSE;; 5566 ; 5567 // Was this array object allocated through TClass?; 5568 Version_t objVer = -1;; 5569 {; 5570 R__LOCKGUARD2(fOVRMutex);; 5571 RepoCont_t::iterator iter = fObjectVersionRepository.find(p);; 5572 if (iter == fObjectVersionRepository.end()) {; 5573 // No, it wasn't, we cannot know what to do.; 5574 //Error(""DeleteArray"", ""Attempt to delete unregistered array object, element type '%s', at address %p!"", GetName(), p);; 5575 inRepo = kFALSE;; 5576 } else {; 5577 for (; (iter != fObjectVersionRepository.end()) && (iter->first == p); ++iter) {; 5578 objVer = iter->second;; 5579 if (objVer == fClassVersion) {; 5580 currentVersion = kTRUE;; 5581 break;; 5582 }; 5583 }; 5584 }; 5585 }; 5586 ; 5587 if (!inRepo || currentVersion) {; 5588 // The object was allocated using code for the same class version; 5589 // as is loaded now. We may proceed without worry.; 5590 TVirtualStreamerInfo* si = GetStreamerInfo();; 5591 if (si) {; 5592 si->DeleteArray(ary, dtorOnly);; 5593 } else {; 5594 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), fClassVersion, ary);; 5595 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5596 Int_t i = fStreamerInfo->LowerBound();; 5597 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5598 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5599 if (fStreamerInfo->At(i)) {; 5600 Error(""DeleteArray"", ""Doing Dump() ..."");; 5601 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5602 }; 5603 }; 5604 }; 5605 } else {; 5606 // The loaded class version is not the same as the version of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:213778,allocate,allocated,213778,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," (!HasInterpreterInfo() && !fCollectionProxy) {; 5626 // There is no dictionary at all and we do not have; 5627 // the services of a collection proxy available, so; 5628 // use the streamer info to approximate calling the; 5629 // array destructor.; 5630 ; 5631 Bool_t inRepo = kTRUE;; 5632 Bool_t currentVersion = kFALSE;; 5633 ; 5634 // Was this array object allocated through TClass?; 5635 Version_t objVer = -1;; 5636 {; 5637 R__LOCKGUARD2(fOVRMutex);; 5638 RepoCont_t::iterator iter = fObjectVersionRepository.find(p);; 5639 if (iter == fObjectVersionRepository.end()) {; 5640 // No, it wasn't, we cannot know what to do.; 5641 //Error(""DeleteArray"", ""Attempt to delete unregistered array object, element type '%s', at address %p!"", GetName(), p);; 5642 inRepo = kFALSE;; 5643 } else {; 5644 for (; (iter != fObjectVersionRepository.end()) && (iter->first == p); ++iter) {; 5645 objVer = iter->second;; 5646 if (objVer == fClassVersion) {; 5647 currentVersion = kTRUE;; 5648 break;; 5649 }; 5650 }; 5651 }; 5652 }; 5653 ; 5654 if (!inRepo || currentVersion) {; 5655 // The object was allocated using code for the same class version; 5656 // as is loaded now. We may proceed without worry.; 5657 TVirtualStreamerInfo* si = GetStreamerInfo();; 5658 if (si) {; 5659 si->DeleteArray(ary, dtorOnly);; 5660 } else {; 5661 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), fClassVersion, ary);; 5662 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5663 Int_t i = fStreamerInfo->LowerBound();; 5664 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5665 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5666 if (fStreamerInfo->At(i)) {; 5667 Error(""DeleteArray"", ""Doing Dump() ..."");; 5668 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5669 }; 5670 }; 5671 }; 5672 } else {; 5673 // The loaded class version is not the same as the version of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:216529,allocate,allocated,216529,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," () noexcept;  ; reference front ();  ; const_reference front () const;  ; size_type max_size () const noexcept;  ; const_reverse_iterator rbegin () const noexcept;  ; reverse_iterator rbegin () noexcept;  ; const_reverse_iterator rend () const noexcept;  ; reverse_iterator rend () noexcept;  ; size_t size () const;  ; size_type size_in_bytes () const;  ;  Public Member Functions inherited from ROOT::Internal::VecOps::SmallVectorBase; size_t capacity () const noexcept;  ; bool empty () const;  ; void set_size (size_t N);  Set the array size to N, which the current array must have enough capacity for. ;  ; size_t size () const;  . Protected Member Functions;  SmallVectorTemplateBase (size_t Size);  ; void grow (size_t MinSize=0);  Grow the allocated memory (without initializing new elements), doubling the size of the allocated memory. ;  ;  Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorTemplateCommon< T >;  SmallVectorTemplateCommon (size_t Size);  ; void grow_pod (size_t MinSize, size_t TSize);  ; bool isSmall () const;  Return true if this is a smallvector which has not had dynamic memory allocated for it. ;  ; void resetToSmall ();  Put this vector in a state of being small. ;  ;  Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorBase;  SmallVectorBase ()=delete;  ;  SmallVectorBase (void *FirstEl, size_t TotalCapacity);  ; void grow_pod (void *FirstEl, size_t MinSize, size_t TSize);  This is an implementation of the grow() method which only works on POD-like data types and is out of line to reduce code duplication. ;  ; bool Owns () const;  If false, the RVec is in ""memory adoption"" mode, i.e. it is acting as a view on a memory buffer it does not own. ;  . Static Protected Member Functions; static void destroy_range (T *S, T *E);  ; template<typename It1 , typename It2 > ; static void uninitialized_copy (It1 I, It1 E, It2 Dest);  Copy the range [I, E) onto the uninitialized memory starting with ""Dest"", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorTemplateBase.html:3157,allocate,allocated,3157,doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorTemplateBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorTemplateBase.html,1,['allocate'],['allocated']
Energy Efficiency," () override;  Destructor. ;  ; virtual Int_t ClearCache (const char *uri);  Clear cached information matching uri. ;  ; virtual Bool_t ExistsDataSet (const char *uri);  Checks if the indicated dataset exits. ;  ; virtual Long64_t GetAvgFileSize () const;  ; virtual TFileCollection * GetDataSet (const char *uri, const char *server=0);  Utility function used in various methods for user dataset upload. ;  ; virtual TMap * GetDataSets (const char *uri, UInt_t=TDataSetManager::kExport);  Returns all datasets for the <group> and <user> specified by <uri>. ;  ; virtual Long64_t GetGroupQuota (const char *group);  returns the quota a group is allowed to have ;  ; virtual TMap * GetGroupQuotaMap ();  ; virtual Long64_t GetGroupUsed (const char *group);  Returns the used space of that group. ;  ; virtual TMap * GetSubDataSets (const char *uri, const char *excludeservers);  Partition dataset 'ds' accordingly to the servers. ;  ; TClass * IsA () const override;  ; virtual void MonitorUsedSpace (TVirtualMonitoringWriter *monitoring);  Log info to the monitoring server. ;  ; virtual Int_t NotifyUpdate (const char *group=0, const char *user=0, const char *dspath=0, Long_t mtime=0, const char *checksum=0);  Save into the <datasetdir>/dataset.list file the name of the last updated or created or modified dataset Returns 0 on success, -1 on error. ;  ; virtual void ParseInitOpts (const char *opts);  Parse the opts string and set the init bits accordingly Available options: Cq: set kCheckQuota Ar: set kAllowRegister Av: set kAllowVerify Ti: set kTrustInfo Sb: set kIsSandbox Ca: set kUseCache or kDoNotUseCache The opts string may also contain additional unrelated info: in such a case the field delimited by the prefix ""opt:"" is analyzed, e.g. ;  ; Bool_t ParseUri (const char *uri, TString *dsGroup=0, TString *dsUser=0, TString *dsName=0, TString *dsTree=0, Bool_t onlyCurrent=kFALSE, Bool_t wildcards=kFALSE);  Parses a (relative) URI that describes a DataSet on the cluster. ;  ; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManager.html:3129,monitor,monitoring,3129,doc/master/classTDataSetManager.html,https://root.cern,https://root.cern/doc/master/classTDataSetManager.html,2,['monitor'],['monitoring']
Energy Efficiency," (1ULL << ( 11 )); , ;   kSetBranchStatus = (1ULL << ( 12 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Attributes inherited from TTree; static Int_t fgBranchStyle = 1;  Old/New branch style. ;  ; static Long64_t fgMaxTreeSize = 100000000000LL;  Maximum size of a file containing a Tree. ;  . #include <TNtuple.h>. Inheritance diagram for TNtuple:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TNtuple() [1/3]. TNtuple::TNtuple ; (; const TNtuple & ; ). privatedelete . ◆ TNtuple() [2/3]. TNtuple::TNtuple ; (; ). Default constructor for Ntuple. ; Definition at line 46 of file TNtuple.cxx. ◆ TNtuple() [3/3]. TNtuple::TNtuple ; (; const char * ; name, . const char * ; title, . const char * ; varlist, . Int_t ; bufsize = 32000 . ). Create an Ntuple. ; The parameter varlist describes the list of the ntuple variables separated by a colon:; Example: x:y:z:energy; For each variable in the list a separate branch is created.; NOTE:; Use TTree to create branches with variables of different data types.; Use TTree when the number of branches is large (> 100). . Definition at line 66 of file TNtuple.cxx. ◆ ~TNtuple(). TNtuple::~TNtuple ; (; ). override . Default destructor for an Ntuple. ; Definition at line 103 of file TNtuple.cxx. Member Function Documentation. ◆ Browse(). void TNtuple::Browse ; (; TBrowser * ; b). overridevirtual . Browse content of the ntuple. ; Reimplemented from TObject.; Definition at line 158 of file TNtuple.cxx. ◆ Class(). static TClass * TNtuple::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TNtuple::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TNtuple::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 61 of file TNtuple.h. ◆ CloneTree(). TTree * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNtuple.html:50187,energy,energy,50187,doc/master/classTNtuple.html,https://root.cern,https://root.cern/doc/master/classTNtuple.html,1,['energy'],['energy']
Energy Efficiency," (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TAttImage.h>. Inheritance diagram for TImagePalette:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TImagePalette() [1/4]. TImagePalette::TImagePalette ; (; ). Default constructor, sets all pointers to 0. ; Definition at line 273 of file TAttImage.cxx. ◆ TImagePalette() [2/4]. TImagePalette::TImagePalette ; (; const TImagePalette & ; palette). Copy constructor. ; Definition at line 294 of file TAttImage.cxx. ◆ TImagePalette() [3/4]. TImagePalette::TImagePalette ; (; UInt_t ; numPoints). Constructor for a palette with numPoints anchor points. ; It allocates the memory but does not set any colors. ; Definition at line 281 of file TAttImage.cxx. ◆ TImagePalette() [4/4]. TImagePalette::TImagePalette ; (; Int_t ; ncolors, . Int_t * ; colors . ). Creates palette in the same way as TStyle::SetPalette. ; Definition at line 314 of file TAttImage.cxx. ◆ ~TImagePalette(). TImagePalette::~TImagePalette ; (; ). override . Destructor. ; Definition at line 431 of file TAttImage.cxx. Member Function Documentation. ◆ Class(). static TClass * TImagePalette::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TImagePalette::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TImagePalette::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 56 of file TAttImage.h. ◆ Create(). TImagePalette * TImagePalette::Create ; (; Option_t * ; opts). static . Factory method to creates an image palette of a specific typ. ; Create a new palette; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTImagePalette.html:13415,allocate,allocates,13415,doc/master/classTImagePalette.html,https://root.cern,https://root.cern/doc/master/classTImagePalette.html,1,['allocate'],['allocates']
Energy Efficiency," (; ); const. inline . Definition at line 85 of file MethodRuleFit.h. ◆ VerifyRange() [1/3]. template<typename T > . Int_t TMVA::MethodRuleFit::VerifyRange ; (; const T & ; var, . const T & ; vmin, . const T & ; vmax . ). inlineprivate . Definition at line 218 of file MethodRuleFit.h. ◆ VerifyRange() [2/3]. template<typename T > . Bool_t TMVA::MethodRuleFit::VerifyRange ; (; TMVA::MsgLogger & ; mlog, . const char * ; varstr, . T & ; var, . const T & ; vmin, . const T & ; vmax . ). inlineprivate . Definition at line 228 of file MethodRuleFit.h. ◆ VerifyRange() [3/3]. template<typename T > . Bool_t TMVA::MethodRuleFit::VerifyRange ; (; TMVA::MsgLogger & ; mlog, . const char * ; varstr, . T & ; var, . const T & ; vmin, . const T & ; vmax, . const T & ; vdef . ). inlineprivate . Definition at line 250 of file MethodRuleFit.h. ◆ WriteMonitoringHistosToFile(). void TMVA::MethodRuleFit::WriteMonitoringHistosToFile ; (; void ; ); const. virtual . write special monitoring histograms to file (here ntuple) ; Reimplemented from TMVA::MethodBase.; Definition at line 628 of file MethodRuleFit.cxx. Member Data Documentation. ◆ fEventSample. std::vector<TMVA::Event *> TMVA::MethodRuleFit::fEventSample. private . the complete training sample ; Definition at line 156 of file MethodRuleFit.h. ◆ fForest. std::vector<DecisionTree *> TMVA::MethodRuleFit::fForest. private . the forest ; Definition at line 180 of file MethodRuleFit.h. ◆ fForestTypeS. TString TMVA::MethodRuleFit::fForestTypeS. private . forest generation: how the trees are generated ; Definition at line 191 of file MethodRuleFit.h. ◆ fGDErrScale. Double_t TMVA::MethodRuleFit::fGDErrScale. private . GD path: stop. ; Definition at line 203 of file MethodRuleFit.h. ◆ fGDNPathSteps. Int_t TMVA::MethodRuleFit::fGDNPathSteps. private . GD path: number of steps. ; Definition at line 202 of file MethodRuleFit.h. ◆ fGDPathEveFrac. Double_t TMVA::MethodRuleFit::fGDPathEveFrac. private . GD path: fraction of subsamples used for the fit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodRuleFit.html:44518,monitor,monitoring,44518,doc/master/classTMVA_1_1MethodRuleFit.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodRuleFit.html,1,['monitor'],['monitoring']
Energy Efficiency," (as explained above); d.add(RooArgSet(x, y, c));; }; d.Print(""v"");; cout << endl;; ; // The get() function returns a pointer to the internal copy of the RooArgSet(x,y,c); // supplied in the constructor; const RooArgSet *row = d.get();; row->Print(""v"");; cout << endl;; ; // Get with an argument loads a specific data point in row and returns; // a pointer to row argset. get() always returns the same pointer, unless; // an invalid row number is specified. In that case a null ptr is returned; d.get(900)->Print(""v"");; cout << endl;; ; // R e d u c i n g , A p p e n d i n g a n d M e r g i n g; // -------------------------------------------------------------; ; // The reduce() function returns a new dataset which is a subset of the original; cout << endl << "">> d1 has only columns x,c"" << endl;; std::unique_ptr<RooAbsData> d1{d.reduce({x, c})};; d1->Print(""v"");; ; cout << endl << "">> d2 has only column y"" << endl;; std::unique_ptr<RooAbsData> d2{d.reduce({y})};; d2->Print(""v"");; ; cout << endl << "">> d3 has only the points with y>5.17"" << endl;; std::unique_ptr<RooAbsData> d3{d.reduce(""y>5.17"")};; d3->Print(""v"");; ; cout << endl << "">> d4 has only columns x,c for data points with y>5.17"" << endl;; std::unique_ptr<RooAbsData> d4{d.reduce({x, c}, ""y>5.17"")};; d4->Print(""v"");; ; // The merge() function adds two data set column-wise; cout << endl << "">> merge d2(y) with d1(x,c) to form d1(x,c,y)"" << endl;; static_cast<RooDataSet&>(*d1).merge(&static_cast<RooDataSet&>(*d2));; d1->Print(""v"");; ; // The append() function adds two datasets row-wise; cout << endl << "">> append data points of d3 to d1"" << endl;; static_cast<RooDataSet&>(*d1).append(static_cast<RooDataSet&>(*d3));; d1->Print(""v"");; ; // O p e r a t i o n s o n b i n n e d d a t a s e t s; // ---------------------------------------------------------; ; // A binned dataset can be constructed empty, from an unbinned dataset, or; // from a ROOT native histogram (TH1,2,3); ; cout << "">> construct dh (binned) from d(unbi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf402__datahandling_8C.html:2696,reduce,reduce,2696,doc/master/rf402__datahandling_8C.html,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8C.html,1,['reduce'],['reduce']
Energy Efficiency," (promotes smoothness over detail preservation); kest3 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth, 2); ; # Plot kernel estimation pdfs with and without mirroring over data; frame = x.frame(Title=""Adaptive kernel estimation pdf with and w/o mirroring"", Bins=20); data1.plotOn(frame); kest1.plotOn(frame); kest2.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Plot kernel estimation pdfs with regular and increased bandwidth; frame2 = x.frame(Title=""Adaptive kernel estimation pdf with regular, bandwidth""); kest1.plotOn(frame2); kest3.plotOn(frame2, LineColor=""m""); ; # Create low status 2D dataset; # -------------------------------------------------------; ; # Construct a 2D toy pdf for sampleing; y = ROOT.RooRealVar(""y"", ""y"", 0, 20); py = ROOT.RooPolynomial(; ""py"",; ""py"",; y,; [0.01, 0.01, -0.0004],; ); pxy = ROOT.RooProdPdf(""pxy"", ""pxy"", [p, py]); data2 = pxy.generate({x, y}, 1000); ; # Create 2D kernel estimation pdf; # ---------------------------------------------------------------; ; # Create 2D adaptive kernel estimation pdf with mirroring; kest4 = ROOT.RooNDKeysPdf(""kest4"", ""kest4"", [x, y], data2, ""am""); ; # Create 2D adaptive kernel estimation pdf with mirroring and double; # bandwidth; kest5 = ROOT.RooNDKeysPdf(""kest5"", ""kest5"", [x, y], data2, ""am"", 2); ; # Create a histogram of the data; hh_data = data2.createHistogram(""hh_data"", x, Binning=10, YVar=dict(var=y, Binning=10)); ; # Create histogram of the 2d kernel estimation pdfs; hh_pdf = kest4.createHistogram(""hh_pdf"", x, Binning=25, YVar=dict(var=y, Binning=25)); hh_pdf2 = kest5.createHistogram(""hh_pdf2"", x, Binning=25, YVar=dict(var=y, Binning=25)); hh_pdf.SetLineColor(ROOT.kBlue); hh_pdf2.SetLineColor(ROOT.kMagenta); ; c = ROOT.TCanvas(""rf707_kernelestimation"", ""rf707_kernelestimation"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf707__kernelestimation_8py.html:2318,adapt,adaptive,2318,doc/master/rf707__kernelestimation_8py.html,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8py.html,1,['adapt'],['adaptive']
Energy Efficiency," (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t *&b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t *&c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t *&h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t *&ii); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t *&ll); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t *&ll); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t *&f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t *&d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferFile.html:25843,allocate,allocated,25843,root/html526/TBufferFile.html,https://root.cern,https://root.cern/root/html526/TBufferFile.html,1,['allocate'],['allocated']
Energy Efficiency," (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferFile.html:27140,allocate,allocated,27140,root/html528/TBufferFile.html,https://root.cern,https://root.cern/root/html528/TBufferFile.html,10,['allocate'],['allocated']
Energy Efficiency," ). inline . Constructor from pt, eta, phi, e values. ; Definition at line 71 of file PtEtaPhiE4D.h. ◆ PtEtaPhiE4D() [3/4]. template<class ScalarType > . template<class CoordSystem > . constexpr ROOT::Math::PtEtaPhiE4D< ScalarType >::PtEtaPhiE4D ; (; const CoordSystem & ; c). inlineexplicitconstexpr . Generic constructor from any 4D coordinate system implementing Pt(), Eta(), Phi() and E() ; Definition at line 79 of file PtEtaPhiE4D.h. ◆ PtEtaPhiE4D() [4/4]. template<class ScalarType > . ROOT::Math::PtEtaPhiE4D< ScalarType >::PtEtaPhiE4D ; (; const PtEtaPhiE4D< ScalarType > & ; v). inline . copy constructor ; Definition at line 88 of file PtEtaPhiE4D.h. Member Function Documentation. ◆ E(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiE4D< ScalarType >::E ; (; ); const. inline . Definition at line 135 of file PtEtaPhiE4D.h. ◆ Et(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiE4D< ScalarType >::Et ; (; ); const. inline . transverse energy ; transverse energy ; Definition at line 233 of file PtEtaPhiE4D.h. ◆ Et2(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiE4D< ScalarType >::Et2 ; (; ); const. inline . transverse energy squared ; Definition at line 241 of file PtEtaPhiE4D.h. ◆ Eta(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiE4D< ScalarType >::Eta ; (; ); const. inline . Definition at line 133 of file PtEtaPhiE4D.h. ◆ GetCoordinates() [1/2]. template<class ScalarType > . void ROOT::Math::PtEtaPhiE4D< ScalarType >::GetCoordinates ; (; Scalar & ; pt, . Scalar & ; eta, . Scalar & ; phi, . Scalar & ; e . ); const. inline . get internal data into 4 Scalar numbers ; Definition at line 125 of file PtEtaPhiE4D.h. ◆ GetCoordinates() [2/2]. template<class ScalarType > . void ROOT::Math::PtEtaPhiE4D< ScalarType >::GetCoordinates ; (; Scalar ; dest[]); const. inline . get internal data into an array of 4 Scalar numbers ; Definition at line 112 of file PtEtaPhiE4D.h. ◆ M(). template<class ScalarType > . Scalar ROOT::Math::PtEt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1PtEtaPhiE4D.html:5382,energy,energy,5382,doc/master/classROOT_1_1Math_1_1PtEtaPhiE4D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1PtEtaPhiE4D.html,2,['energy'],['energy']
Energy Efficiency," ). overridevirtual . Execute action corresponding to one event. ; This member function is called when a graph is clicked with the locator; If Left button clicked on one of the line end points, this point follows the cursor until button is released.; if Middle button clicked, the line is moved parallel to itself until the button is released. ; Reimplemented from TObject.; Definition at line 1056 of file TGraph.cxx. ◆ Expand() [1/2]. void TGraph::Expand ; (; Int_t ; newsize). virtual . If array sizes <= newsize, expand storage to 2*newsize. ; Definition at line 1065 of file TGraph.cxx. ◆ Expand() [2/2]. void TGraph::Expand ; (; Int_t ; newsize, . Int_t ; step . ). virtual . If graph capacity is less than newsize points then make array sizes equal to least multiple of step to contain newsize points. ; Definition at line 1075 of file TGraph.cxx. ◆ ExpandAndCopy(). Double_t ** TGraph::ExpandAndCopy ; (; Int_t ; size, . Int_t ; iend . ). protected . if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ; Return pointer to new arrays. ; Definition at line 1089 of file TGraph.cxx. ◆ FillZero(). void TGraph::FillZero ; (; Int_t ; begin, . Int_t ; end, . Bool_t ; from_ctor = kTRUE . ). protectedvirtual . Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes. ; Reimplemented in TGraphAsymmErrors, TGraphBentErrors, TGraphErrors, and TGraphMultiErrors.; Definition at line 1102 of file TGraph.cxx. ◆ FindObject() [1/2]. TObject * TGraph::FindObject ; (; const char * ; name); const. overridevirtual . Search object named name in the list of functions. ; Reimplemented from TObject.; Definition at line 1111 of file TGraph.cxx. ◆ FindObject() [2/2]. TObject * TGraph::FindObject ; (; const TObject * ; obj); const. overridevirtual . Search object obj in the list of functions. ; Reimplemented from TObject.; Definition at line 1119 of file TGraph.cxx. ◆ Fit() [1/2]. TFitResultPtr TGraph::Fit ; (; const char * ; f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph.html:45164,allocate,allocate,45164,doc/master/classTGraph.html,https://root.cern,https://root.cern/doc/master/classTGraph.html,1,['allocate'],['allocate']
Energy Efficiency," ); 309 */; 310 Scalar R() const { return fCoordinates.R(); }; 311 Scalar P() const { return fCoordinates.R(); }; 312 /**; 313 return the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 ); 314 */; 315 Scalar P2() const { return P() * P(); }; 316 /**; 317 return the square of the transverse spatial component ( X**2 + Y**2 ); 318 */; 319 Scalar Perp2( ) const { return fCoordinates.Perp2();}; 320 ; 321 /**; 322 return the transverse spatial component sqrt ( X**2 + Y**2 ); 323 */; 324 Scalar Pt() const { return fCoordinates.Pt(); }; 325 Scalar Rho() const { return fCoordinates.Pt(); }; 326 ; 327 /**; 328 return the transverse mass squared; 329 \f[ m_t^2 = E^2 - p{_z}^2 \f]; 330 */; 331 Scalar Mt2() const { return fCoordinates.Mt2(); }; 332 ; 333 /**; 334 return the transverse mass; 335 \f[ \sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]; 336 */; 337 Scalar Mt() const { return fCoordinates.Mt(); }; 338 ; 339 /**; 340 return the transverse energy squared; 341 \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]; 342 */; 343 Scalar Et2() const { return fCoordinates.Et2(); }; 344 ; 345 /**; 346 return the transverse energy; 347 \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]; 348 */; 349 Scalar Et() const { return fCoordinates.Et(); }; 350 ; 351 /**; 352 azimuthal Angle; 353 */; 354 Scalar Phi() const { return fCoordinates.Phi();}; 355 ; 356 /**; 357 polar Angle; 358 */; 359 Scalar Theta() const { return fCoordinates.Theta(); }; 360 ; 361 /**; 362 pseudorapidity; 363 \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]; 364 */; 365 Scalar Eta() const { return fCoordinates.Eta(); }; 366 ; 367 /**; 368 get the spatial components of the Vector in a; 369 DisplacementVector based on Cartesian Coordinates; 370 */; 371 ::ROOT::Math::DisplacementVector3D<Cartesian3D<Scalar> > Vect() const {; 372 return ::ROOT::Math::DisplacementVector3D<Cartesian3D<Scalar> >( X(), Y(), Z() );; 373 }; 374 ; 375 // ------ Operations combining two Lorentz vectors ------; 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:11243,energy,energy,11243,doc/master/GenVector_2LorentzVector_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html,1,['energy'],['energy']
Energy Efficiency," *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  . Protected Attributes; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  . Static Protected Attributes; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . Private Member Functions;  TQObject (const TQObject &)=delete;  ; TQObject & operator= (const TQObject &)=delete;  . #include <TQObject.h>. Inheritance diagram for TQObject:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TQObject() [1/2]. TQObject::TQObject ; (; const TQObject & ; ). privatedelete . ◆ TQObject() [2/2]. TQObject::TQObject ; (; ). TQObject Constructor. ; Comment:; In order to minimize memory allocation fListOfSignals and fListOfConnections are allocated only if it is neccesary; When fListOfSignals/fListOfConnections are empty they will be deleted . Definition at line 393 of file TQObject.cxx. ◆ ~TQObject(). TQObject::~TQObject ; (; ). virtual . TQObject Destructor. . delete all connections and signal list . Definition at line 404 of file TQObject.cxx. Member Function Documentation. ◆ AreAllSignalsBlocked(). Bool_t TQObject::AreAllSignalsBlocked ; (; ). static . Returns true if all signals are blocked. ; Definition at line 1049 of file TQObject.cxx. ◆ AreSignalsBlocked(). Bool_t TQObject::AreSignalsBlocked ; (; ); const. inline . Definition at line 91 of file TQObject.h. ◆ BlockAllSignals(). Bool_t TQObject::BlockAllSignals ; (; Bool_t ; b). static . Block or unblock all signals. Returns the previous block status. ; Definition at line 1057 of file TQObject.cxx. ◆ BlockSignals(). Bool_t TQObject::BlockSignals ; (; Bool_t ; b). inline . Definition at line 92 of file TQObject.h. ◆ ChangedBy(). virtual void TQObject::ChangedBy ; (; con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQObject.html:7042,allocate,allocated,7042,doc/master/classTQObject.html,https://root.cern,https://root.cern/doc/master/classTQObject.html,1,['allocate'],['allocated']
Energy Efficiency," *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; Bool_t HandleTimer (TTimer *timer) override;  Send progress and feedback to client. ;  ; void SetupFeedback () override;  Setup reporting of feedback objects and progress messages. ;  ;  Protected Member Functions inherited from TProofPlayerRemote; TProof * GetProof () const;  ; Int_t InitPacketizer (TDSet *dset, Long64_t nentries, Long64_t first, const char *defpackunit, const char *defpackdata);  Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ;  ; TList * MergeFeedback ();  Merge feedback lists. ;  ; Bool_t MergeOutputFiles ();  Merge output in files. ;  ; void NotifyMemory (TObject *obj);  Printout the memory record after merging object 'obj' This record is used by the memory monitor. ;  ; virtual Bool_t SendSelector (const char *selector_file);  Send the selector file(s) to master or worker nodes. ;  ; void SetLastMergingMsg (TObject *obj);  Set the message to be notified in case of exception. ;  ; void SetSelectorDataMembersFromOutputList ();  Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it. ;  ; void StopFeedback () override;  Stop reporting of feedback objects. ;  ;  Protected Member Functions inherited from TProofPlayer; Int_t AssertSelector (const char *selector_file);  Make sure that a valid selector object Return -1 in case of problems, 0 otherwise. ;  ; Bool_t CheckMemUsage (Long64_t &mfreq, Bool_t &w80r, Bool_t &w80v, TString &wmsg);  Check the memory usage, if requested. ;  ; virtual Int_t DrawCanvas (TObject *obj);  Draw the object if it is a canvas. ;  ; void * GetSender () override;  ; void MapOutputListToDataMem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerSuperMaster.html:20566,monitor,monitor,20566,doc/master/classTProofPlayerSuperMaster.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerSuperMaster.html,1,['monitor'],['monitor']
Energy Efficiency," *start=nullptr, UInt_t *bcnt=nullptr, const TClass *cl=nullptr)=0; TBuffer::SetByteCountvirtual void SetByteCount(UInt_t cntpos, Bool_t packInVersion=kFALSE)=0; TBuffer::EModeEModeDefinition TBuffer.h:73; TBuffer::kWrite@ kWriteDefinition TBuffer.h:73; TBuffer::CheckByteCountvirtual Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass *clss)=0; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TBuffer::ResetMapvirtual void ResetMap()=0; TBuffer::SetBufferOffsetvoid SetBufferOffset(Int_t offset=0)Definition TBuffer.h:93; TBuffer::SetReadModevoid SetReadMode()Set buffer in read mode.Definition TBuffer.cxx:302; TBuffer::WriteVersionvirtual UInt_t WriteVersion(const TClass *cl, Bool_t useBcnt=kFALSE)=0; TBuffer::MapObjectvirtual void MapObject(const TObject *obj, UInt_t offset=1)=0; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:56636,allocate,allocated,56636,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," *totyz));; ; // P l o t d a t a w i t h a L L r a t i o c u t; // -------------------------------------------------------; ; // Calculate the llratio value for each event in the dataset; data->addColumn(llratio_func);; ; // Extract the subset of data with large signal likelihood; std::unique_ptr<RooAbsData> dataSel{data->reduce(Cut(""llratio>0.7""))};; ; // Make plot frame; RooPlot *frame2 = x.frame(Title(""Same projection on X with LLratio(y,z)>0.7""), Bins(40));; ; // Plot select data on frame; dataSel->plotOn(frame2);; ; // M a k e M C p r o j e c t i o n o f p d f w i t h s a m e L L r a t i o c u t; // ---------------------------------------------------------------------------------------------; ; // Generate large number of events for MC integration of pdf projection; std::unique_ptr<RooDataSet> mcprojData{model.generate({x, y, z}, 10000)};; ; // Calculate LL ratio for each generated event and select MC events with llratio)0.7; mcprojData->addColumn(llratio_func);; std::unique_ptr<RooAbsData> mcprojDataSel{mcprojData->reduce(Cut(""llratio>0.7""))};; ; // Project model on x, integrating projected observables (y,z) with Monte Carlo technique; // on set of events with the same llratio cut as was applied to data; model.plotOn(frame2, ProjWData(*mcprojDataSel));; ; TCanvas *c = new TCanvas(""rf316_llratioplot"", ""rf316_llratioplot"", 800, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.4);; frame2->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooPolynomial.h; RooProdPdf.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdfAbstract",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf316__llratioplot_8C.html:3439,reduce,reduce,3439,doc/master/rf316__llratioplot_8C.html,https://root.cern,https://root.cern/doc/master/rf316__llratioplot_8C.html,1,['reduce'],['reduce']
Energy Efficiency," *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:2630,reduce,reduce,2630,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,8,['reduce'],['reduce']
Energy Efficiency," , kIsZoomed = (1ULL << ( 16 )); , ;   kNoTitle = (1ULL << ( 17 )); , kIsAverage = (1ULL << ( 18 )); , kIsNotW = (1ULL << ( 19 )); , kAutoBinPTwo = (1ULL << ( 20 )); , ;   kIsHighlight = (1ULL << ( 21 )). };  TH1 status bits. More...;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Check histogram compatibility. ;  ; static bool CheckConsistentSubAxes (const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0);  Check that two sub axis are the same. ;  ; static bool CheckEqualAxes (const TAxis *a1, const TAxis *a2);  Check that the axis are the same. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:55256,power,power,55256,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,1,['power'],['power']
Energy Efficiency," , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TMonitor (Bool_t mainloop=kTRUE);  Create a monitor object. ;  ;  TMonitor (const TMonitor &m);  Copy constructor. ;  ; virtual ~TMonitor ();  Cleanup the monitor object. Does not delete sockets being monitored. ;  ; virtual void Activate (TSocket *sock);  Activate a de-activated socket. ;  ; virtual void ActivateAll ();  Activate all de-activated sockets. ;  ; virtual void Add (TSocket *sock, Int_t interest=kRead);  Add socket to the monitor's active list. ;  ; virtual void DeActivate (TSocket *sock);  De-activate a socket. ;  ; virtual void DeActivateAll ();  De-activate all activated sockets. ;  ; Int_t GetActive (Long_t timeout=-1) const;  Return number of sockets in the active list. ;  ; Int_t GetDeActive () const;  Return number of sockets in the de-active list. ;  ; TList * GetListOfActives () const;  Returns a list with all active sockets. ;  ; TList * GetListOfDeActives () const;  Returns a list with all de-active sockets. ;  ; void Interrupt ();  ; TClass * IsA () const override;  ; Bool_t IsActive (TSocket *s) const;  Check if socket 's' is in the active list. ;  ; virtual void Ready (TSocket *sock);  Emit signal when some socket is ready. ;  ; virtual void Remove (TSocket *sock);  Remove a socket from the monitor. ;  ; virtual void RemoveAll ();  Remove all sockets from the monitor. ;  ; void ResetInterrupt ();  ; TSocket * Select ();  Return pointer to socket for which an ev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:1534,monitor,monitor,1534,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,1,['monitor'],['monitor']
Energy Efficiency," . CallFunc_t * ; callfunc, . Longptr_t ; offset = 0 . ). Create a method invocation environment for a specific class, method described by the callfunc. ; Definition at line 49 of file TMethodCall.cxx. ◆ TMethodCall() [3/6]. TMethodCall::TMethodCall ; (; TClass * ; cl, . const char * ; method, . const char * ; params . ). Create a method invocation environment for a specific class, method and parameters. ; The parameter string has the form: ""\""aap\"", 3, 4.35"". To execute the method call TMethodCall::Execute(object,...). This two step method is much more efficient than calling for every invocation TInterpreter::Execute(...). ; Definition at line 62 of file TMethodCall.cxx. ◆ TMethodCall() [4/6]. TMethodCall::TMethodCall ; (; const char * ; function, . const char * ; params . ). Create a global function invocation environment. ; The parameter string has the form: ""\""aap\"", 3, 4,35"". To execute the function call TMethodCall::Execute(...). This two step method is much more efficient than calling for every invocation TInterpreter::Execute(...). ; Definition at line 75 of file TMethodCall.cxx. ◆ TMethodCall() [5/6]. TMethodCall::TMethodCall ; (; const TFunction * ; func). Create a global function invocation environment base on a TFunction object. ; To execute the function call TMethodCall::Execute(...). This two step method is much more efficient than calling for every invocation TInterpreter::Execute(...). ; Definition at line 87 of file TMethodCall.cxx. ◆ TMethodCall() [6/6]. TMethodCall::TMethodCall ; (; const TMethodCall & ; org). Copy ctor. ; Definition at line 95 of file TMethodCall.cxx. ◆ ~TMethodCall(). TMethodCall::~TMethodCall ; (; ). TMethodCall dtor. ; Definition at line 130 of file TMethodCall.cxx. Member Function Documentation. ◆ CallDtorOnly(). void TMethodCall::CallDtorOnly ; (; Bool_t ; set = kTRUE). inline . Definition at line 87 of file TMethodCall.h. ◆ Class(). static TClass * TMethodCall::Class ; (; ). static . ReturnsTClass describing this class . ◆ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMethodCall.html:17094,efficient,efficient,17094,doc/master/classTMethodCall.html,https://root.cern,https://root.cern/doc/master/classTMethodCall.html,1,['efficient'],['efficient']
Energy Efficiency," . Int_t ; fieldcount . ). Single row of query result. ; Definition at line 22 of file TODBCRow.cxx. ◆ ~TODBCRow(). TODBCRow::~TODBCRow ; (; ). virtual . Destroy row object. ; Definition at line 44 of file TODBCRow.cxx. Member Function Documentation. ◆ Class(). static TClass * TODBCRow::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TODBCRow::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TODBCRow::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 50 of file TODBCRow.h. ◆ Close(). void TODBCRow::Close ; (; Option_t * ; opt = """"). finalvirtual . Close row. ; Implements TSQLRow.; Definition at line 52 of file TODBCRow.cxx. ◆ CopyFieldValue(). void TODBCRow::CopyFieldValue ; (; Int_t ; field). protected . Extracts field value from statement. ; First allocates 128 bytes for buffer. If there is not enouth space, bigger buffer is allocated and request is repeated ; Definition at line 73 of file TODBCRow.cxx. ◆ DeclFileName(). static const char * TODBCRow::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 50 of file TODBCRow.h. ◆ GetField(). const char * TODBCRow::GetField ; (; Int_t ; field). finalvirtual . Get specified field from row (0 <= field < GetFieldCount()). ; Implements TSQLRow.; Definition at line 125 of file TODBCRow.cxx. ◆ GetFieldLength(). ULong_t TODBCRow::GetFieldLength ; (; Int_t ; field). finalvirtual . Get length in bytes of specified field. ; Implements TSQLRow.; Definition at line 114 of file TODBCRow.cxx. ◆ IsA(). TClass * TODBCRow::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 50 of file TODBCRow.h. ◆ operator=(). TODBCRow & TODBCRow::operator= ; (; const TODBCRow & ; ). privatedelete . ◆ Streamer(). void TODBCRow::Streamer ; (; TBuffer & ; R__b). overri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTODBCRow.html:12428,allocate,allocated,12428,doc/master/classTODBCRow.html,https://root.cern,https://root.cern/doc/master/classTODBCRow.html,1,['allocate'],['allocated']
Energy Efficiency," . MinimizerType ; _eMinimizerType = MinimizerType::fSteepest, . double ; _learningRate = 1e-5, . double ; _momentum = 0.3, . int ; _repetitions = 3, . bool ; _multithreading = true . ). c'tor ; Definition at line 232 of file NeuralNet.cxx. ◆ ~Settings(). TMVA::DNN::Settings::~Settings ; (; ). virtual . d'tor ; Definition at line 261 of file NeuralNet.cxx. Member Function Documentation. ◆ addPoint() [1/2]. void TMVA::DNN::Settings::addPoint ; (; std::string ; histoName, . double ; x . ). inline . for monitoring ; Definition at line 821 of file NeuralNet.h. ◆ addPoint() [2/2]. void TMVA::DNN::Settings::addPoint ; (; std::string ; histoName, . double ; x, . double ; y . ). inline . for monitoring ; Definition at line 822 of file NeuralNet.h. ◆ batchSize(). size_t TMVA::DNN::Settings::batchSize ; (; ); const. inline . mini-batch size ; Definition at line 767 of file NeuralNet.h. ◆ clear(). void TMVA::DNN::Settings::clear ; (; std::string ; histoName). inline . for monitoring ; Definition at line 824 of file NeuralNet.h. ◆ computeResult(). virtual void TMVA::DNN::Settings::computeResult ; (; const Net & ; , . std::vector< double > & ;  . ). inlinevirtual . callback for monitoring and logging ; Definition at line 809 of file NeuralNet.h. ◆ convergenceCount(). size_t TMVA::DNN::Settings::convergenceCount ; (; ); const. inline . returns the current convergence count ; Definition at line 827 of file NeuralNet.h. ◆ convergenceSteps(). size_t TMVA::DNN::Settings::convergenceSteps ; (; ); const. inline . how many steps until training is deemed to have converged ; Definition at line 766 of file NeuralNet.h. ◆ create() [1/2]. void TMVA::DNN::Settings::create ; (; std::string ; histoName, . int ; bins, . double ; min, . double ; max . ). inline . for monitoring ; Definition at line 819 of file NeuralNet.h. ◆ create() [2/2]. void TMVA::DNN::Settings::create ; (; std::string ; histoName, . int ; bins, . double ; min, . double ; max, . int ; bins2, . double ; min2, . double ; max2 . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:6115,monitor,monitoring,6115,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['monitor'],['monitoring']
Energy Efficiency," . ReturnsVersion of this class ; Definition at line 61 of file TSystemFile.h. ◆ Copy() [1/2]. void TSystemFile::Copy ; (; const char * ; to). virtual . copy this file ; Reimplemented in TSystemDirectory.; Definition at line 102 of file TSystemFile.cxx. ◆ Copy() [2/2]. void TSystemFile::Copy ; (; TObject & ; named); const. inlineoverridevirtual . Copy this to obj. ; Reimplemented from TNamed.; Definition at line 59 of file TSystemFile.h. ◆ DeclFileName(). static const char * TSystemFile::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 61 of file TSystemFile.h. ◆ Delete() [1/2]. void TSystemFile::Delete ; (; ). virtual . delete this file ; Reimplemented in TSystemDirectory.; Definition at line 154 of file TSystemFile.cxx. ◆ Delete() [2/2]. void TSystemFile::Delete ; (; Option_t * ; option). inlineoverridevirtual . Delete this object. ; Typically called as a command via the interpreter. Normally use ""delete"" operator when object has been allocated on the heap. ; Reimplemented from TObject.; Definition at line 58 of file TSystemFile.h. ◆ DrawClass(). void TSystemFile::DrawClass ; (; ); const. inlineoverridevirtual . Draw class inheritance tree of the class to which this object belongs. ; If a class B inherits from a class A, description of B is drawn on the right side of description of A. Member functions overridden by B are shown in class A with a blue line crossing-out the corresponding member function. The following picture is the class inheritance tree of class TPaveLabel:. Reimplemented from TObject.; Definition at line 53 of file TSystemFile.h. ◆ DrawClone(). TObject * TSystemFile::DrawClone ; (; Option_t * ; option); const. inlineoverridevirtual . Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ; If pad was not selected - gPad will be used. ; Reimplemented from TObject.; Definition at line 54 of file TSystemFile.h. ◆ Dump(). void TSystemFile::Dump ; (; ); co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystemFile.html:13995,allocate,allocated,13995,doc/master/classTSystemFile.html,https://root.cern,https://root.cern/doc/master/classTSystemFile.html,1,['allocate'],['allocated']
Energy Efficiency," . [private] (does some specific error handling that makes the function unsuitable for general use.) returns a new'd TClass given the name of a class. ; user must delete. returns 0 in case of error. ; Definition at line 2206 of file TTabCom.cxx. ◆ MakeClassFromVarName(). TClass * TTabCom::MakeClassFromVarName ; (; const char ; varName[], . EContext_t & ; context, . int ; iter = 0 . ). private . [private] (does some specific error handling that makes the function unsuitable for general use.) returns a new'd TClass given the name of a variable. ; user must delete. returns 0 in case of error. if user has operator.() or operator->() backwards, will modify: context, *fpLoc and fBuf. context sensitive behavior. ; Definition at line 2255 of file TTabCom.cxx. ◆ NewListOfFilesInPath(). TSeqCollection * TTabCom::NewListOfFilesInPath ; (; const char ; path1[]). static . [static utility function]///////////////////////////// ; creates a list containing the full path name for each file in the (colon separated) string ""path1""; memory is allocated with ""new"", so whoever calls this function takes responsibility for deleting it. ; Definition at line 1049 of file TTabCom.cxx. ◆ NoMsg(). void TTabCom::NoMsg ; (; Int_t ; errorLevel). static . [static utility function]///////////////////////////// ; calling ""NoMsg( errorLevel )"", sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that all errors with ""level < errorLevel"" will be ignored.; calling the function with a negative argument (e.g., ""NoMsg( -1 )"") resets gErrorIgnoreLevel to its previous value. ; Definition at line 1108 of file TTabCom.cxx. ◆ operator=(). TTabCom & TTabCom::operator= ; (; const TTabCom & ; ). privatedelete . ◆ ParseReverse(). int TTabCom::ParseReverse ; (; const char * ; var_str, . int ; start . ). private . Returns the place in the string where to put the \0, starting the search from ""start"". ; Definition at line 2565 of file TTabCom.cxx. ◆ PathIsSpecifiedInFileName(). Bool_t TTabCom::PathIsSpecifiedInFileName ; (; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTabCom.html:16328,allocate,allocated,16328,doc/master/classTTabCom.html,https://root.cern,https://root.cern/doc/master/classTTabCom.html,1,['allocate'],['allocated']
Energy Efficiency," . std::string_view ; ntupleName, . std::string_view ; storage, . const RNTupleWriteOptions & ; options = RNTupleWriteOptions() . ). static . Definition at line 79 of file RNTupleWriter.cxx. ◆ Recreate() [2/2]. std::unique_ptr< ROOT::Experimental::RNTupleWriter > ROOT::Experimental::RNTupleWriter::Recreate ; (; std::unique_ptr< RNTupleModel > ; model, . std::string_view ; ntupleName, . std::string_view ; storage, . const RNTupleWriteOptions & ; options = RNTupleWriteOptions() . ). static . Throws an exception if the model is null. ; Definition at line 71 of file RNTupleWriter.cxx. Friends And Related Symbol Documentation. ◆ Internal::CreateRNTupleWriter. std::unique_ptr< RNTupleWriter > Internal::CreateRNTupleWriter ; (; std::unique_ptr< RNTupleModel > ; , . std::unique_ptr< Internal::RPageSink > ;  . ). friend . Member Data Documentation. ◆ fFillContext. RNTupleFillContext ROOT::Experimental::RNTupleWriter::fFillContext. private . Definition at line 69 of file RNTupleWriter.hxx. ◆ fLastCommittedClusterGroup. NTupleSize_t ROOT::Experimental::RNTupleWriter::fLastCommittedClusterGroup = 0. private . Definition at line 72 of file RNTupleWriter.hxx. ◆ fMetrics. Detail::RNTupleMetrics ROOT::Experimental::RNTupleWriter::fMetrics. private . Definition at line 70 of file RNTupleWriter.hxx. ◆ fZipTasks. std::unique_ptr<Internal::RPageStorage::RTaskScheduler> ROOT::Experimental::RNTupleWriter::fZipTasks. private . The page sink's parallel page compression scheduler if IMT is on. ; Needs to be destructed after the page sink (in the fill context) is destructed and so declared before. ; Definition at line 68 of file RNTupleWriter.hxx. Libraries for ROOT::Experimental::RNTupleWriter:. [legend]; The documentation for this class was generated from the following files:; tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx; tree/ntuple/v7/src/RNTupleWriter.cxx. ROOTExperimentalRNTupleWriter. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html:12893,schedul,scheduler,12893,doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html,1,['schedul'],['scheduler']
Energy Efficiency," / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?. private:. TList*fActivenodes with unfinished files; Float_tfBaseLocalPreferenceindicates how much more likely the nodes will be; Bool_tfCachePacketSynccontrol synchronization of cache and packet sizes; TList*fFileNodesnodes with files; TSortedList*fFilesToProcessGlobal list of files (TFileStat) to be processed; Bool_tfForceLocalif 1 - eliminate the remote processing; Float_tfFractionOfRemoteFilesfraction of TDSetElements that are on non-workers; Double_tfMaxEntriesRatiomax file entries to avg allowed ratio for cache-to-packet sync; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Long64_tfNEventsOnRemLocnumber of events in currently; Int_tfPacketAsAFractionused to calculate the packet size; TList*fPartitionslist of partitions on nodes; Int_tfStrategy0 means the classic and 1 (default) - the adaptive strategy; TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* file); Remove file from the list of acti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPacketizerAdaptive.html:11389,adapt,adaptive,11389,root/html528/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html528/TPacketizerAdaptive.html,1,['adapt'],['adaptive']
Energy Efficiency," / signal+background probability; llratio_func = ROOT.RooFormulaVar(""llratio"", ""log10(@0)-log10(@1)"", [sigyz, totyz]); ; # Plot data with a LL ratio cut; # -------------------------------------------------------; ; # Calculate the llratio value for each event in the dataset; data.addColumn(llratio_func); ; # Extract the subset of data with large signal likelihood; dataSel = data.reduce(Cut=""llratio>0.7""); ; # Make plot frame; frame2 = x.frame(Title=""Same projection on X with LLratio(y,z)>0.7"", Bins=40); ; # Plot select data on frame; dataSel.plotOn(frame2); ; # Make MC projection of pdf with same LL ratio cut; # ---------------------------------------------------------------------------------------------; ; # Generate large number of events for MC integration of pdf projection; mcprojData = model.generate({x, y, z}, 10000); ; # Calculate LL ratio for each generated event and select MC events with; # llratio)0.7; mcprojData.addColumn(llratio_func); mcprojDataSel = mcprojData.reduce(Cut=""llratio>0.7""); ; # Project model on x, projected observables (y,z) with Monte Carlo technique; # on set of events with the same llratio cut as was applied to data; model.plotOn(frame2, ProjWData=mcprojDataSel); ; c = ROOT.TCanvas(""rf316_llratioplot"", ""rf316_llratioplot"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); c.SaveAs(""rf316_llratioplot.png""); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) only the following components of the projection data will be used: (y,z); [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf316_ll",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf316__llratioplot_8py.html:2936,reduce,reduce,2936,doc/master/rf316__llratioplot_8py.html,https://root.cern,https://root.cern/doc/master/rf316__llratioplot_8py.html,1,['reduce'],['reduce']
Energy Efficiency," // Plum; 3415 case 94:; 3416 {; 3417 Double_t red[9] = { 0./255., 38./255., 60./255., 76./255., 84./255., 89./255., 101./255., 128./255., 204./255.};; 3418 Double_t green[9] = { 0./255., 10./255., 15./255., 23./255., 35./255., 57./255., 83./255., 123./255., 199./255.};; 3419 Double_t blue[9] = { 0./255., 11./255., 22./255., 40./255., 63./255., 86./255., 97./255., 94./255., 85./255.};; 3420 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3421 }; 3422 break;; 3423 ; 3424 // Red Blue; 3425 case 95:; 3426 {; 3427 Double_t red[9] = { 94./255., 112./255., 141./255., 165./255., 167./255., 140./255., 91./255., 49./255., 27./255.};; 3428 Double_t green[9] = { 27./255., 46./255., 88./255., 135./255., 166./255., 161./255., 135./255., 97./255., 58./255.};; 3429 Double_t blue[9] = { 42./255., 52./255., 81./255., 106./255., 139./255., 158./255., 155./255., 137./255., 116./255.};; 3430 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3431 }; 3432 break;; 3433 ; 3434 // Rose; 3435 case 96:; 3436 {; 3437 Double_t red[9] = { 30./255., 49./255., 79./255., 117./255., 135./255., 151./255., 146./255., 138./255., 147./255.};; 3438 Double_t green[9] = { 63./255., 60./255., 72./255., 90./255., 94./255., 94./255., 68./255., 46./255., 16./255.};; 3439 Double_t blue[9] = { 18./255., 28./255., 41./255., 56./255., 62./255., 63./255., 50./255., 36./255., 21./255.};; 3440 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3441 }; 3442 break;; 3443 ; 3444 // Rust; 3445 case 97:; 3446 {; 3447 Double_t red[9] = { 0./255., 30./255., 63./255., 101./255., 143./255., 152./255., 169./255., 187./255., 230./255.};; 3448 Double_t green[9] = { 0./255., 14./255., 28./255., 42./255., 58./255., 61./255., 67./255., 74./255., 91./255.};; 3449 Double_t blue[9] = { 39./255., 26./255., 21./255., 18./255., 15./255., 14./255., 14./255., 13./255., 13./255.};; 3450 Idx = TColor::CreateGradientColorTable(9, stops, red, green, bl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:134978,green,green,134978,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency," 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. THnSparseArrayChunk*AddChunk(); voidTHnBase::AddInternal(const THnBase* h, Double_t c, Bool_t rebinned); Bool_tTHnBase::CheckConsistency(const THnBase* h, const char* tag) const; THnBase*THnBase::CloneEmpty(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; TH1*THnBase::CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const TH1* h1, Bool_t sparse, Int_t chunkSize = 1024*16); static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const THnBase* hn, Bool_t sparse, Int_t chunkSize = 1024*16); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidFillBin(Long64_t bin, Double_t w); voidTHnBase::FillBinBase(Double_t w); voidFillExMap(); virtual TArray*GenerateArray() const; Long64_tGetBinIndexForCurrentBin(Bool_t allocate); THnSparseArrayChunk*GetChunk(Int_t idx) const; THnSparseCompactBinCoord*GetCompactCoord() const; voidTHnBase::Init(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis, Int_t chunkSize = 1024*16); virtual voidInitStorage(Int_t* nbins, Int_t chunkSize); voidTObject::MakeZombie(); Bool_tTHnBase::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnBase::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidReserve(Long64_t nbins); voidTHnBase::ResetBase(Option_t* option = """"); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). private:. THnSparse&operator=(const THnSparse&). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnSparse.html:14147,allocate,allocate,14147,root/html534/THnSparse.html,https://root.cern,https://root.cern/root/html534/THnSparse.html,2,['allocate'],['allocate']
Energy Efficiency," 0, not null string """"; Int_t wid = embed->GetCanvasWindowId();; TCanvas *myc = new TCanvas(""myname"",10,10,wid);; embed->AdoptCanvas(myc);; // the TCanvas is adopted by the embedded canvas and will be; // destroyed by it; 25.9 The ROOT Graphics Editor (GED); Everything drawn in a ROOT canvas is an object. There are classes for all objects, and they fall into hierarchies. In addition, the ROOT has fully cross-platform GUI classes and provides all standard components for an application environment with common ‘look and feel’. The object-oriented, event-driven programming model supports the modern signals/slots communication mechanism. It handles user interface actions and allows total independence of interacting objects and classes. This mechanism uses the ROOT dictionary information and the Cling the C++ Interpreter to connect signals to slots methods.; Therefore, all necessary elements for an object-oriented editor design are in place. The editor complexity can be reduced by splitting it into discrete units of so-called object editors. Any object editor provides an object specific GUI. The main purpose of the ROOT graphics editor is the organization of the object editors’ appearance and the task sequence between them.; 25.9.1 Object Editors; Every object editor follows a simple naming convention: to have as a name the object class name concatenated with ‘Editor’ (e.g. for TGraph objects the object editor is TGraphEditor). Thanks to the signals/slots communication mechanism and to the method DistancetoPrimitive() that computes a ‘‘distance’’ to an object from the mouse position, it was possible to implement a signal method of the canvas that says which is the selected object and to which pad it belongs. Having this information the graphics editor loads the corresponding object editor and the user interface is ready for use. This way after a click on ‘axis’—the axis editor is active; a click on a ‘pad’ activates the pad editor, etc.; The algorithm in use is simple and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1221182,reduce,reduced,1221182,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['reduce'],['reduced']
Energy Efficiency," 0.); Returns the upper estimated density. TF1* GetPDFLowerConfidenceInterval(Double_t confidenceLevel = 0.94999999999999996, UInt_t npx = 100, Double_t xMin = 1., Double_t xMax = 0.); Returns the upper estimated density. TF1* GetKDEApproximateBias(UInt_t npx = 100, Double_t xMin = 1., Double_t xMax = 0.); Returns the approximate bias. explicit TKDE(UInt_t events = 0, const Double_t* data = 0, Double_t xMin = 0., Double_t xMax = 0., const Option_t* option = ""KernelType:Gaussian;Iteration:Adaptive;Mirror:noMirror;Binning:RelaxedBinning"", Double_t rho = 1.). TKDE(UInt_t events, const Double_t* data, const Double_t* dataWeight, Double_t xMin = 0., Double_t xMax = 0., const Option_t* option = ""KernelType:Gaussian;Iteration:Adaptive;Mirror:noMirror;Binning:RelaxedBinning"", Double_t rho = 1.). TKDE(const Char_t* /*name*/, const KernelFunction& kernfunc, UInt_t events, const Double_t* data, Double_t xMin = 0.0, Double_t xMax = 0.0, const Option_t* option = ""KernelType:UserDefined;Iteration:Adaptive;Mirror:noMirror;Binning:RelaxedBinning"", Double_t rho = 1.0). Double_t GetValue(Double_t x) const; { return (*this)(x); }. TF1 * GetDrawnFunction(); get the drawn object to chanage settings; These objects are managed by TKDE and should not be deleted by the user. { return fPDF;}. TF1 * GetDrawnUpperFunction(); { return fUpperPDF;}. TF1 * GetDrawnLowerFunction(); { return fLowerPDF;}. TGraphErrors * GetDrawnGraph(); { return fGraph;}. TKDE operator=(TKDE& kde). Double_t GaussianKernel(Double_t x) const; Returns the kernel evaluation at x. Double_t EpanechnikovKernel(Double_t x) const. Double_t BiweightKernel(Double_t x) const; Returns the kernel evaluation at x. Double_t CosineArchKernel(Double_t x) const; Returns the kernel evaluation at x. Double_t ApproximateBias(const Double_t* x, const Double_t* ) const; { return GetBias(*x); }. void SetHistogram(). » Last changed: root/hist:$Id$ » Last generated: 2015-06-02 16:13; This page has been automatically generated. For comments or s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TKDE.html:20189,Adapt,Adaptive,20189,root/html604/TKDE.html,https://root.cern,https://root.cern/root/html604/TKDE.html,1,['Adapt'],['Adaptive']
Energy Efficiency," 1 if OK, otherwise 0.; 32******************************************************************************/; 33 ; 34 int ret = 1;; 35 ; 36 points = NULL;; 37 colors = NULL;; 38 segs = NULL;; 39 polys = NULL;; 40 ; 41 /*; 42 * Allocate memory for points; 43 */; 44 ; 45 if (gSize3D.numPoints) {; 46 points = (point *) calloc(gSize3D.numPoints, sizeof (point));; 47 if (!points) {; 48 puts (""Unable to allocate memory for points !"");; 49 ret = 0;; 50 }; 51 }; 52 else return (0); /* if there are no points, return back */; 53 ; 54 ; 55 ; 56 /*; 57 * Allocate memory for colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; col",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/X3DBuffer_8c_source.html:1907,green,green,1907,doc/master/X3DBuffer_8c_source.html,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html,1,['green'],['green']
Energy Efficiency," 1.0, 0.0, 0.0, 1.0};; Double_t stop[] = {0., .25, .50, .75, 1.0};; Int_t FI = TColor::CreateGradientColorTable(5, stop, r, g, b, 100);; for (int i=0;i<100;i++) MyPalette[i] = FI+i;. Later on to reuse the palette MyPalette it will be enough to do. gStyle->SetPalette(100, MyPalette);. As only one palette is active, one need to use TExec to be able to; display plots using different palettes on the same pad.; The following macro illustrate this feature. Picture; Source. //Draw color plots using different color palettes.; //Author:: Olivier Couet. #include ""TStyle.h""; #include ""TColor.h""; #include ""TF2.h""; #include ""TExec.h""; #include ""TCanvas.h"". void Pal1(); {; static Int_t colors[50];; static Bool_t initialized = kFALSE;. Double_t Red[3] = { 1.00, 0.00, 0.00};; Double_t Green[3] = { 0.00, 1.00, 0.00};; Double_t Blue[3] = { 1.00, 0.00, 1.00};; Double_t Length[3] = { 0.00, 0.50, 1.00 };. if(!initialized){; Int_t FI = TColor::CreateGradientColorTable(3,Length,Red,Green,Blue,50);; for (int i=0; i<50; i++) colors[i] = FI+i;; initialized = kTRUE;; return;; }; gStyle->SetPalette(50,colors);; }. void Pal2(); {; static Int_t colors[50];; static Bool_t initialized = kFALSE;. Double_t Red[3] = { 1.00, 0.50, 0.00};; Double_t Green[3] = { 0.50, 0.00, 1.00};; Double_t Blue[3] = { 1.00, 0.00, 0.50};; Double_t Length[3] = { 0.00, 0.50, 1.00 };. if(!initialized){; Int_t FI = TColor::CreateGradientColorTable(3,Length,Red,Green,Blue,50);; for (int i=0; i<50; i++) colors[i] = FI+i;; initialized = kTRUE;; return;; }; gStyle->SetPalette(50,colors);; }. TCanvas* multipalette() {; TCanvas *c3 = new TCanvas(""c3"",""C3"",0,0,600,400);; c3->Divide(2,1);; TF2 *f3 = new TF2(""f3"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; f3->SetLineWidth(1);; f3->SetLineColor(kBlack);. c3->cd(1);; f3->Draw(""surf1"");; TExec *ex1 = new TExec(""ex1"",""Pal1();"");; ex1->Draw();; f3->Draw(""surf1 same"");. c3->cd(2);; f3->Draw(""surf1"");; TExec *ex2 = new TExec(""ex2"",""Pal2();"");; ex2->Draw();; f3->Draw(""surf1 same"");. r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TColor.html:6714,Green,Green,6714,root/html602/TColor.html,https://root.cern,https://root.cern/root/html602/TColor.html,2,['Green'],['Green']
Energy Efficiency," 1.0e7 * K(); }. Double_t KUncertainty(); { return 0.0000024e-23; }. Double_t Sigma(); Stefan-Boltzmann constant. { return 5.6704e-8; }. Double_t SigmaUncertainty(); { return 0.000040e-8; }. Double_t Na(); Avogadro constant (Avogadro's Number). { return 6.02214199e+23; }. Double_t NaUncertainty(); { return 0.00000047e+23; }. Double_t R(); universal gas constant (Na * K); http://scienceworld.wolfram.com/physics/UniversalGasConstant.html. { return K() * Na(); }. Double_t RUncertainty(); { return R()*((KUncertainty()/K()) + (NaUncertainty()/Na())); }. Double_t MWair(); Molecular weight of dry air; 1976 US Standard Atmosphere,; also see http://atmos.nmsu.edu/jsdap/encyclopediawork.html. { return 28.9644; }. Double_t Rgair(); Dry Air Gas Constant (R / MWair); http://atmos.nmsu.edu/education_and_outreach/encyclopedia/gas_constant.htm. { return (1000.0 * R()) / MWair(); }. Double_t EulerGamma(); Euler-Mascheroni Constant. { return 0.577215664901532860606512090082402431042; }. Double_t Qe(); Elementary charge. { return 1.602176462e-19; }. Double_t QeUncertainty(); { return 0.000000063e-19; }. Bool_t AreEqualAbs(Double_t af, Double_t bf, Double_t epsilon); Comparing floating points. return Abs(af-bf); return kTRUE if absolute difference between af and bf is less than epsilon. Bool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec); return kTRUE if relative difference between af and bf is less than relPrec. return Abs(af-bf). template <typename T> T MinElement(Long64_t n, const T *a). Array Algorithms. Min, Max of an array. template <typename T> T MaxElement(Long64_t n, const T *a). template <typename T> Long64_t LocMin(Long64_t n, const T *a); Locate Min, Max element number in an array. template <typename Iterator> Iterator LocMin(Iterator first, Iterator last). template <typename T> Long64_t LocMax(Long64_t n, const T *a). template <typename Iterator> Iterator LocMax(Iterator first, Iterator last). template <typename T> Long64_t BinarySearch(Long64_t n, const T *arra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMath.html:47184,charge,charge,47184,root/html528/TMath.html,https://root.cern,https://root.cern/root/html528/TMath.html,1,['charge'],['charge']
Energy Efficiency," 1.0e7 * K(); }. Double_t KUncertainty(); { return 0.0000024e-23; }. Double_t Sigma(); Stefan-Boltzmann constant. { return 5.6704e-8; }. Double_t SigmaUncertainty(); { return 0.000040e-8; }. Double_t Na(); Avogadro constant (Avogadro's Number). { return 6.02214199e+23; }. Double_t NaUncertainty(); { return 0.00000047e+23; }. Double_t R(); universal gas constant (Na * K); http://scienceworld.wolfram.com/physics/UniversalGasConstant.html. { return K() * Na(); }. Double_t RUncertainty(); { return R()*((KUncertainty()/K()) + (NaUncertainty()/Na())); }. Double_t MWair(); Molecular weight of dry air; 1976 US Standard Atmosphere,; also see http://atmos.nmsu.edu/jsdap/encyclopediawork.html. { return 28.9644; }. Double_t Rgair(); Dry Air Gas Constant (R / MWair); http://atmos.nmsu.edu/education_and_outreach/encyclopedia/gas_constant.htm. { return (1000.0 * R()) / MWair(); }. Double_t EulerGamma(); Euler-Mascheroni Constant. { return 0.577215664901532860606512090082402431042; }. Double_t Qe(); Elementary charge. { return 1.602176462e-19; }. Double_t QeUncertainty(); { return 0.000000063e-19; }. Int_t Nint(T x). T Min(). T Max(). Bool_t AreEqualAbs(Double_t af, Double_t bf, Double_t epsilon); Comparing floating points. return Abs(af-bf); return kTRUE if absolute difference between af and bf is less than epsilon. Bool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec); return kTRUE if relative difference between af and bf is less than relPrec. return Abs(af-bf). template <typename T> T MinElement(Long64_t n, const T *a). Array Algorithms. Min, Max of an array. template <typename T> T MaxElement(Long64_t n, const T *a). template <typename T> Long64_t LocMin(Long64_t n, const T *a); Locate Min, Max element number in an array. template <typename Iterator> Iterator LocMin(Iterator first, Iterator last). template <typename T> Long64_t LocMax(Long64_t n, const T *a). template <typename Iterator> Iterator LocMax(Iterator first, Iterator last). template <typename T> Long64_t Bin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMath.html:48536,charge,charge,48536,root/html534/TMath.html,https://root.cern,https://root.cern/root/html534/TMath.html,2,['charge'],['charge']
Energy Efficiency," 1.0e7 * K(); }. Double_t KUncertainty(); { return 0.0000024e-23; }. Double_t Sigma(); Stefan-Boltzmann constant. { return 5.6704e-8; }. Double_t SigmaUncertainty(); { return 0.000040e-8; }. Double_t Na(); Avogadro constant (Avogadro's Number). { return 6.02214199e+23; }. Double_t NaUncertainty(); { return 0.00000047e+23; }. Double_t R(); universal gas constant (Na * K); http://scienceworld.wolfram.com/physics/UniversalGasConstant.html. { return K() * Na(); }. Double_t RUncertainty(); { return R()*((KUncertainty()/K()) + (NaUncertainty()/Na())); }. Double_t MWair(); Molecular weight of dry air; 1976 US Standard Atmosphere,; also see http://atmos.nmsu.edu/jsdap/encyclopediawork.html. { return 28.9644; }. Double_t Rgair(); Dry Air Gas Constant (R / MWair); http://atmos.nmsu.edu/education_and_outreach/encyclopedia/gas_constant.htm. { return (1000.0 * R()) / MWair(); }. Double_t EulerGamma(); Euler-Mascheroni Constant. { return 0.577215664901532860606512090082402431042; }. Double_t Qe(); Elementary charge. { return 1.602176462e-19; }. Double_t QeUncertainty(); { return 0.000000063e-19; }. T Min(). T Max(). Bool_t AreEqualAbs(Double_t af, Double_t bf, Double_t epsilon); Comparing floating points. return Abs(af-bf); return kTRUE if absolute difference between af and bf is less than epsilon. Bool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec); return kTRUE if relative difference between af and bf is less than relPrec. return Abs(af-bf). template <typename T> T MinElement(Long64_t n, const T *a). Array Algorithms. Min, Max of an array. template <typename T> T MaxElement(Long64_t n, const T *a). template <typename T> Long64_t LocMin(Long64_t n, const T *a); Locate Min, Max element number in an array. template <typename Iterator> Iterator LocMin(Iterator first, Iterator last). template <typename T> Long64_t LocMax(Long64_t n, const T *a). template <typename Iterator> Iterator LocMax(Iterator first, Iterator last). template <typename T> Long64_t BinarySearch(Long64_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMath.html:47403,charge,charge,47403,root/html530/TMath.html,https://root.cern,https://root.cern/root/html530/TMath.html,3,['charge'],['charge']
Energy Efficiency, 1/**; 2\defgroup RoofitPythonizations RooFit Pythonizations; 3\ingroup Roofitmain; 4- [RooAbsCollection](\ref _rooabscollection); 5 - [printLatex](\ref _rooabscollection_printlatex); 6- [RooAbsData](\ref _rooabsdata); 7 - [createHistogram](\ref _rooabsdata_createhistogram); 8 - [plotOn](\ref _rooabsdata_ploton); 9 - [reduce](\ref _rooabsdata_reduce); 10 - [statOn](\ref _rooabsdata_staton); 11- [RooAbsPdf](\ref _rooabspdf); 12 - [createCdf](\ref _rooabspdf_createcdf); 13 - [createNLL](\ref _rooabspdf_createnll); 14 - [fitTo](\ref _rooabspdf_fitto); 15 - [generate](\ref _rooabspdf_generate); 16 - [generateBinned](\ref _rooabspdf_generatebinned); 17 - [paramOn](\ref _rooabspdf_paramon); 18 - [plotOn](\ref _rooabspdf_ploton); 19 - [prepareMultiGen](\ref _rooabspdf_preparemultigen); 20- [RooAbsReal](\ref _rooabsreal); 21 - [chi2FitTo](\ref _rooabsreal_chi2fitto); 22 - [createChi2](\ref _rooabsreal_createchi2); 23 - [createHistogram](\ref _rooabsreal_createhistogram); 24 - [createIntegral](\ref _rooabsreal_createintegral); 25 - [createRunningIntegral](\ref _rooabsreal_createrunningintegral); 26 - [plotOn](\ref _rooabsreal_ploton); 27- [RooAbsRealLValue](\ref _rooabsreallvalue); 28 - [createHistogram](\ref _rooabsreallvalue_createhistogram); 29 - [frame](\ref _rooabsreallvalue_frame); 30- [RooArgSet](\ref _rooargset); 31 - [__init__](\ref _rooargset___init__); 32- [RooBCPGenDecay](\ref _roobcpgendecay); 33 - [__init__](\ref _roobcpgendecay___init__); 34- [RooBCPEffDecay](\ref _roobcpeffdecay); 35 - [__init__](\ref _roobcpeffdecay___init__); 36- [RooBDecay](\ref _roobdecay); 37 - [__init__](\ref _roobdecay___init__); 38- [RooBMixDecay](\ref _roobmixdecay); 39 - [__init__](\ref _roobmixdecay___init__); 40- [RooCategory](\ref _r,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/__roofit_8pyzdoc_source.html:572,reduce,reduce,572,doc/master/__roofit_8pyzdoc_source.html,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html,1,['reduce'],['reduce']
Energy Efficiency," 100 of file MethodPDERS.cxx. ◆ MethodPDERS() [2/2]. TMVA::MethodPDERS::MethodPDERS ; (; DataSetInfo & ; theData, . const TString & ; theWeightFile . ). construct MethodPDERS through from file ; Definition at line 134 of file MethodPDERS.cxx. ◆ ~MethodPDERS(). TMVA::MethodPDERS::~MethodPDERS ; (; void ; ). virtual . destructor ; Definition at line 208 of file MethodPDERS.cxx. Member Function Documentation. ◆ AddWeightsXMLTo(). void TMVA::MethodPDERS::AddWeightsXMLTo ; (; void * ; parent); const. virtual . write weights to xml file ; Implements TMVA::MethodBase.; Definition at line 1099 of file MethodPDERS.cxx. ◆ ApplyKernelFunction(). Double_t TMVA::MethodPDERS::ApplyKernelFunction ; (; Double_t ; normalized_distance). protected . from the normalized euclidean distance calculate the distance for a certain kernel ; Definition at line 922 of file MethodPDERS.cxx. ◆ CalcAverages(). void TMVA::MethodPDERS::CalcAverages ; (; ). private . compute also average RMS values required for adaptive Gaussian ; Definition at line 433 of file MethodPDERS.cxx. ◆ CKernelEstimate(). Double_t TMVA::MethodPDERS::CKernelEstimate ; (; const Event & ; event, . std::vector< const BinarySearchTreeNode * > & ; events, . Volume & ; v . ). protected . normalization factors so we can work with radius 1 hyperspheres ; Definition at line 834 of file MethodPDERS.cxx. ◆ Class(). static TClass * TMVA::MethodPDERS::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::MethodPDERS::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::MethodPDERS::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 221 of file MethodPDERS.h. ◆ CreateBinarySearchTree(). void TMVA::MethodPDERS::CreateBinarySearchTree ; (; Types::ETreeType ; type). private . create binary search trees for signal and background ; Definition at line 455 of file MethodPDERS.cxx. ◆ CreateRanking(). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPDERS.html:35201,adapt,adaptive,35201,doc/master/classTMVA_1_1MethodPDERS.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPDERS.html,1,['adapt'],['adaptive']
Energy Efficiency, 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/X3DBuffer_8c_source.html:2758,green,green,2758,doc/master/X3DBuffer_8c_source.html,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html,1,['green'],['green']
Energy Efficiency," 12834 * conn read/written by more than one thread, no matter if; 12835 * it is a websocket or regular connection. */; 12836 (void)mg_lock_connection(conn);; 12837 ; 12838#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 12839 size_t deflated_size = 0;; 12840 Bytef *deflated = 0;; 12841 // Deflate websocket messages over 100kb; 12842 int use_deflate = dataLen > 100 * 1024 && conn->accept_gzip;; 12843 ; 12844 if (use_deflate) {; 12845 if (!conn->websocket_deflate_initialized) {; 12846 if (websocket_deflate_initialize(conn, 1) != Z_OK); 12847 return 0;; 12848 }; 12849 ; 12850 // Deflating the message; 12851 header[0] = 0xC0u | (unsigned char)((unsigned)opcode & 0xf);; 12852 conn->websocket_deflate_state.avail_in = (uInt)dataLen;; 12853 conn->websocket_deflate_state.next_in = (unsigned char *)data;; 12854 deflated_size = (Bytef *)compressBound((uLong)dataLen);; 12855 deflated = mg_calloc(deflated_size, sizeof(Bytef));; 12856 if (deflated == NULL) {; 12857 mg_cry_internal(; 12858 conn,; 12859 ""Out of memory: Cannot allocate deflate buffer of %lu bytes"",; 12860 (unsigned long)deflated_size);; 12861 mg_unlock_connection(conn);; 12862 return -1;; 12863 }; 12864 conn->websocket_deflate_state.avail_out = (uInt)deflated_size;; 12865 conn->websocket_deflate_state.next_out = deflated;; 12866 deflate(&conn->websocket_deflate_state, conn->websocket_deflate_flush);; 12867 dataLen = deflated_size - conn->websocket_deflate_state.avail_out; 12868 - 4; // Strip trailing 0x00 0x00 0xff 0xff bytes; 12869 } else; 12870#endif; 12871 header[0] = 0x80u | (unsigned char)((unsigned)opcode & 0xf);; 12872 ; 12873#if defined(GCC_DIAGNOSTIC); 12874#pragma GCC diagnostic pop; 12875#endif; 12876 ; 12877 /* Frame format: http://tools.ietf.org/html/rfc6455#section-5.2 */; 12878 if (dataLen < 126) {; 12879 /* inline 7-bit length field */; 12880 header[1] = (unsigned char)dataLen;; 12881 headerLen = 2;; 12882 } else if (dataLen <= 0xFFFF) {; 12883 /* 16-bit length field */; 12884 uint16_t le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:374221,allocate,allocate,374221,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['allocate'],['allocate']
Energy Efficiency," 12835 * conn read/written by more than one thread, no matter if; 12836 * it is a websocket or regular connection. */; 12837 (void)mg_lock_connection(conn);; 12838 ; 12839#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 12840 size_t deflated_size = 0;; 12841 Bytef *deflated = 0;; 12842 // Deflate websocket messages over 100kb; 12843 int use_deflate = dataLen > 100 * 1024 && conn->accept_gzip;; 12844 ; 12845 if (use_deflate) {; 12846 if (!conn->websocket_deflate_initialized) {; 12847 if (websocket_deflate_initialize(conn, 1) != Z_OK); 12848 return 0;; 12849 }; 12850 ; 12851 // Deflating the message; 12852 header[0] = 0xC0u | (unsigned char)((unsigned)opcode & 0xf);; 12853 conn->websocket_deflate_state.avail_in = (uInt)dataLen;; 12854 conn->websocket_deflate_state.next_in = (unsigned char *)data;; 12855 deflated_size = (Bytef *)compressBound((uLong)dataLen);; 12856 deflated = mg_calloc(deflated_size, sizeof(Bytef));; 12857 if (deflated == NULL) {; 12858 mg_cry_internal(; 12859 conn,; 12860 ""Out of memory: Cannot allocate deflate buffer of %lu bytes"",; 12861 (unsigned long)deflated_size);; 12862 mg_unlock_connection(conn);; 12863 return -1;; 12864 }; 12865 conn->websocket_deflate_state.avail_out = (uInt)deflated_size;; 12866 conn->websocket_deflate_state.next_out = deflated;; 12867 deflate(&conn->websocket_deflate_state, conn->websocket_deflate_flush);; 12868 dataLen = deflated_size - conn->websocket_deflate_state.avail_out; 12869 - 4; // Strip trailing 0x00 0x00 0xff 0xff bytes; 12870 } else; 12871#endif; 12872 header[0] = 0x80u | (unsigned char)((unsigned)opcode & 0xf);; 12873 ; 12874#if defined(GCC_DIAGNOSTIC); 12875#pragma GCC diagnostic pop; 12876#endif; 12877 ; 12878 /* Frame format: http://tools.ietf.org/html/rfc6455#section-5.2 */; 12879 if (dataLen < 126) {; 12880 /* inline 7-bit length field */; 12881 header[1] = (unsigned char)dataLen;; 12882 headerLen = 2;; 12883 } else if (dataLen <= 0xFFFF) {; 12884 /* 16-bit length field */; 12885 uint16_t le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:374254,allocate,allocate,374254,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['allocate'],['allocate']
Energy Efficiency," 1307 Int_t py = gPad->GetEventY();; 1308 ; 1309 //localize point to be deleted; 1310 Int_t ipoint = -2;; 1311 Int_t i;; 1312 // start with a small window (in case the mouse is very close to one point); 1313 for (i=0;i<fNpoints;i++) {; 1314 Int_t dpx = px - gPad->XtoAbsPixel(gPad->XtoPad(fX[i]));; 1315 Int_t dpy = py - gPad->YtoAbsPixel(gPad->YtoPad(fY[i]));; 1316 if (dpx*dpx+dpy*dpy < 25) {ipoint = i; break;}; 1317 }; 1318 if (ipoint == -2) return;; 1319 ; 1320 fEXlow[ipoint] = exl;; 1321 fEYlow[ipoint] = eyl;; 1322 fEXhigh[ipoint] = exh;; 1323 fEYhigh[ipoint] = eyh;; 1324 gPad->Modified();; 1325}; 1326 ; 1327 ; 1328////////////////////////////////////////////////////////////////////////////////; 1329/// Set ex and ey values for point number i.; 1330 ; 1331void TGraphAsymmErrors::SetPointError(Int_t i, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh); 1332{; 1333 if (i < 0) return;; 1334 if (i >= fNpoints) {; 1335 // re-allocate the object; 1336 TGraphAsymmErrors::SetPoint(i,0,0);; 1337 }; 1338 fEXlow[i] = exl;; 1339 fEYlow[i] = eyl;; 1340 fEXhigh[i] = exh;; 1341 fEYhigh[i] = eyh;; 1342}; 1343 ; 1344 ; 1345////////////////////////////////////////////////////////////////////////////////; 1346/// Set EXlow for point `i`.; 1347 ; 1348void TGraphAsymmErrors::SetPointEXlow(Int_t i, Double_t exl); 1349{; 1350 if (i < 0) return;; 1351 if (i >= fNpoints) {; 1352 // re-allocate the object; 1353 TGraphAsymmErrors::SetPoint(i,0,0);; 1354 }; 1355 fEXlow[i] = exl;; 1356}; 1357 ; 1358 ; 1359////////////////////////////////////////////////////////////////////////////////; 1360/// Set EXhigh for point `i`.; 1361 ; 1362void TGraphAsymmErrors::SetPointEXhigh(Int_t i, Double_t exh); 1363{; 1364 if (i < 0) return;; 1365 if (i >= fNpoints) {; 1366 // re-allocate the object; 1367 TGraphAsymmErrors::SetPoint(i,0,0);; 1368 }; 1369 fEXhigh[i] = exh;; 1370}; 1371 ; 1372 ; 1373////////////////////////////////////////////////////////////////////////////////; 1374/// Set EYlow for point ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:46237,allocate,allocate,46237,doc/master/TGraphAsymmErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency," 135./255., 125./255., 96./255., 68./255., 51./255., 61./255.};; 3279 Double_t blue[9] = { 7./255., 9./255., 12./255., 19./255., 45./255., 89./255., 118./255., 146./255., 118./255.};; 3280 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3281 }; 3282 break;; 3283 ; 3284 // Fuchsia; 3285 case 81:; 3286 {; 3287 Double_t red[9] = { 19./255., 44./255., 74./255., 105./255., 137./255., 166./255., 194./255., 206./255., 220./255.};; 3288 Double_t green[9] = { 19./255., 28./255., 40./255., 55./255., 82./255., 110./255., 159./255., 181./255., 220./255.};; 3289 Double_t blue[9] = { 19./255., 42./255., 68./255., 96./255., 129./255., 157./255., 188./255., 203./255., 220./255.};; 3290 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3291 }; 3292 break;; 3293 ; 3294 // Grey Yellow; 3295 case 82:; 3296 {; 3297 Double_t red[9] = { 33./255., 44./255., 70./255., 99./255., 140./255., 165./255., 199./255., 211./255., 216./255.};; 3298 Double_t green[9] = { 38./255., 50./255., 76./255., 105./255., 140./255., 165./255., 191./255., 189./255., 167./255.};; 3299 Double_t blue[9] = { 55./255., 67./255., 97./255., 124./255., 140./255., 166./255., 163./255., 129./255., 52./255.};; 3300 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3301 }; 3302 break;; 3303 ; 3304 // Green Brown Terrain; 3305 case 83:; 3306 {; 3307 Double_t red[9] = { 0./255., 33./255., 73./255., 124./255., 136./255., 152./255., 159./255., 171./255., 223./255.};; 3308 Double_t green[9] = { 0./255., 43./255., 92./255., 124./255., 134./255., 126./255., 121./255., 144./255., 223./255.};; 3309 Double_t blue[9] = { 0./255., 43./255., 68./255., 76./255., 73./255., 64./255., 72./255., 114./255., 223./255.};; 3310 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3311 }; 3312 break;; 3313 ; 3314 // Green Pink; 3315 case 84:; 3316 {; 3317 Double_t red[9] = { 5./255., 18./255., 45./255., 124./255., 193./255., 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:127832,green,green,127832,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency," 17 )); , kIsAverage = (1ULL << ( 18 )); , kIsNotW = (1ULL << ( 19 )); , kAutoBinPTwo = (1ULL << ( 20 )); , ;   kIsHighlight = (1ULL << ( 21 )). };  TH1 status bits. More...;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TArrayD; Double_t * fArray;  ;  Public Attributes inherited from TArray; Int_t fN;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Check histogram compatibility. ;  ; static bool CheckConsistentSubAxes (const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0);  Check that two sub axis are the same. ;  ; static bool CheckEqualAxes (const TAxis *a1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1D.html:48033,power,power,48033,doc/master/classTH1D.html,https://root.cern,https://root.cern/doc/master/classTH1D.html,4,['power'],['power']
Energy Efficiency," 17 )); , kIsAverage = (1ULL << ( 18 )); , kIsNotW = (1ULL << ( 19 )); , kAutoBinPTwo = (1ULL << ( 20 )); , ;   kIsHighlight = (1ULL << ( 21 )). };  TH1 status bits. More...;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TArrayF; Float_t * fArray;  ;  Public Attributes inherited from TArray; Int_t fN;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Check histogram compatibility. ;  ; static bool CheckConsistentSubAxes (const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0);  Check that two sub axis are the same. ;  ; static bool CheckEqualAxes (const TAxis *a1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1F.html:47894,power,power,47894,doc/master/classTH1F.html,https://root.cern,https://root.cern/doc/master/classTH1F.html,3,['power'],['power']
Energy Efficiency," 17 )); , kIsAverage = (1ULL << ( 18 )); , kIsNotW = (1ULL << ( 19 )); , kAutoBinPTwo = (1ULL << ( 20 )); , ;   kIsHighlight = (1ULL << ( 21 )). };  TH1 status bits. More...;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TArrayS; Short_t * fArray;  ;  Public Attributes inherited from TArray; Int_t fN;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Check histogram compatibility. ;  ; static bool CheckConsistentSubAxes (const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0);  Check that two sub axis are the same. ;  ; static bool CheckEqualAxes (const TAxis *a1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1S.html:47757,power,power,47757,doc/master/classTH1S.html,https://root.cern,https://root.cern/doc/master/classTH1S.html,2,['power'],['power']
Energy Efficiency," 173 DoInit();; 174 }; 175 ; 176 /// clone the function; 177 IMultiGenFunction * Clone() const override {; 178 return new WrappedParamFunctionGen(fFunc, fDim, fParams.size(), fParams.empty() ? nullptr : &fParams.front(), fParIndices.empty() ? nullptr : &fParIndices.front());; 179 }; 180 ; 181private:; 182 // copy ctor; 183 WrappedParamFunctionGen(const WrappedParamFunctionGen &) = delete; // not implemented; 184 WrappedParamFunctionGen & operator=(const WrappedParamFunctionGen &) = delete; // not implemented; 185 ; 186public:; 187 ; 188 const double * Parameters() const override {; 189 return fParams.empty() ? nullptr : &fParams.front();; 190 }; 191 ; 192 void SetParameters(const double * p) override {; 193 unsigned int npar = NPar();; 194 std::copy(p, p+ npar, fParams.begin() );; 195 SetParValues(npar, p);; 196 }; 197 ; 198 unsigned int NPar() const override { return fParams.size(); }; 199 ; 200 unsigned int NDim() const override { return fDim; }; 201 ; 202// // re-implement this since is more efficient; 203// double operator() (const double * x, const double * p) {; 204// unsigned int n = fX.size();; 205// unsigned int npar = fParams.size();; 206// unsigned j = 0;; 207// return (*fFunc)( fX);; 208// }; 209 ; 210private:; 211 ; 212 /// evaluate the function (re-implement for being more efficient); 213 double DoEval(const double * x) const override {; 214 ; 215// std::cout << this << fDim << "" x : "";; 216// std::ostream_iterator<double> oix(std::cout,"" , "");; 217// std::copy(x, x+fDim, oix);; 218// std::cout << std::endl;; 219// std::cout << ""npar "" << npar << std::endl;; 220// std::cout << fVarIndices.size() << std::endl;; 221// assert ( fVarIndices.size() == fDim); // otherwise something is wrong; 222 ; 223 for (unsigned int i = 0; i < fDim; ++i) {; 224 unsigned int j = fVarIndices[i];; 225 assert ( j < NPar() + fDim);; 226 fX[ j ] = x[i];; 227 }; 228// std::cout << ""X : ("";; 229// std::ostream_iterator<double> oi(std::cout,"" , "");; 230// std::copy(fX.begin(), fX.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/WrappedParamFunction_8h_source.html:7144,efficient,efficient,7144,doc/master/WrappedParamFunction_8h_source.html,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html,1,['efficient'],['efficient']
Energy Efficiency," 179 unsigned int ndim = NDim();; 180 for (unsigned int icoord = 0; icoord < ndim; ++icoord) {; 181 grad[icoord] = Derivative(x, icoord);; 182 }; 183 }; 184 ; 185 /// In some cases, the gradient algorithm will use information from the previous step, these can be passed; 186 /// in with this overload. The `previous_*` arrays can also be used to return second derivative and step size; 187 /// so that these can be passed forward again as well at the call site, if necessary.; 188 virtual void GradientWithPrevResult(const T *x, T *grad, T *previous_grad, T *previous_g2, T *previous_gstep) const; 189 {; 190 unsigned int ndim = NDim();; 191 for (unsigned int icoord = 0; icoord < ndim; ++icoord) {; 192 grad[icoord] = Derivative(x, icoord, previous_grad, previous_g2, previous_gstep);; 193 }; 194 }; 195 ; 196 using BaseFunc::NDim;; 197 ; 198 /// Optimized method to evaluate at the same time the function value and derivative at a point x.; 199 /// Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; 200 /// Derived class should implement this method if performances play an important role and if it is faster to; 201 /// evaluate value and derivative at the same time; 202 virtual void FdF(const T *x, T &f, T *df) const; 203 {; 204 f = BaseFunc::operator()(x);; 205 Gradient(x, df);; 206 }; 207 ; 208 /// Return the partial derivative with respect to the passed coordinate.; 209 T Derivative(const T *x, unsigned int icoord = 0) const { return DoDerivative(x, icoord); }; 210 ; 211 /// In some cases, the derivative algorithm will use information from the previous step, these can be passed; 212 /// in with this overload. The `previous_*` arrays can also be used to return second derivative and step size; 213 /// so that these can be passed forward again as well at the call site, if necessary.; 214 T Derivative(const T *x, unsigned int icoord, T *previous_grad, T *previous_g2,; 215 T *previous_gstep) const; 216 {; 217 return DoDeri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/IFunction_8h_source.html:8322,efficient,efficient,8322,doc/master/IFunction_8h_source.html,https://root.cern,https://root.cern/doc/master/IFunction_8h_source.html,1,['efficient'],['efficient']
Energy Efficiency," 19 )); , kAutoBinPTwo = (1ULL << ( 20 )); , ;   kIsHighlight = (1ULL << ( 21 )). };  TH1 status bits. More...;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Check histogram compatibility. ;  ; static bool CheckConsistentSubAxes (const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0);  Check that two sub axis are the same. ;  ; static bool CheckEqualAxes (const TAxis *a1, const TAxis *a2);  Check that the axis are the same. ;  ; static Bool_t RecomputeAxisLimits (TAxis &destAxis, const TAxis &anAxis);  Finds new limits for the axis for the Merge function. ;  ; static Bool_t SameLimitsAndNBins (const TAxis &axis1, const TAxis &axis2);  S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2Poly.html:64017,power,power,64017,doc/master/classTH2Poly.html,https://root.cern,https://root.cern/doc/master/classTH2Poly.html,1,['power'],['power']
Energy Efficiency," 2002.; see for instance: http://root.cern.ch/root/roottalk/roottalk02/2916.html. Option_t * GetErrorOption() const; -*Return option to compute profile errors; *-* =======================================. char* GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the profile info (bin number, contents, eroor, entries per bin; corresponding to cursor position px,py. void GetStats(Double_t* stats) const; fill the array stats from the contents of this profile; The array stats must be correctly dimensionned in the calling program.; stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2; stats[4] = sumwy; stats[5] = sumwy2. If no axis-subrange is specified (via TAxis::SetRange), the array stats; is simply a copy of the statistics quantities computed at filling time.; If a sub-range is specified, the function recomputes these quantities; from the bin contents in the current axis range. void LabelsDeflate(Option_t* axis = ""X""); Reduce the number of bins for this axis to the number of bins having a label. void LabelsInflate(Option_t* axis = ""X""); Double the number of bins for axis.; Refill histogram; This function is called by TAxis::FindBin(const char *label). void LabelsOption(Option_t* option = ""h"", Option_t* axis = ""X""); Set option(s) to draw axis with labels; option = ""a"" sort by alphabetic order; = "">"" sort by decreasing values; = ""<"" sort by increasing values; = ""h"" draw labels horizonthal; = ""v"" draw labels vertical; = ""u"" draw labels up (end of label right adjusted); = ""d"" draw labels down (start of label left adjusted). Long64_t Merge(TCollection* list); Merge all histograms in the collection in this histogram.; This function computes the min/max for the x axis,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is succes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProfile.html:37140,Reduce,Reduce,37140,root/html532/TProfile.html,https://root.cern,https://root.cern/root/html532/TProfile.html,2,['Reduce'],['Reduce']
Energy Efficiency," 2006; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class UnBinData; 12 ; 13#ifndef ROOT_Fit_UnBinData; 14#define ROOT_Fit_UnBinData; 15 ; 16#include ""Fit/FitData.h""; 17#include ""Math/Error.h""; 18 ; 19#include <vector>; 20 ; 21namespace ROOT {; 22 ; 23 namespace Fit {; 24 ; 25 ; 26//___________________________________________________________________________________; 27/**; 28 Class describing the un-binned data sets (just x coordinates values) of any dimensions; 29 ; 30 There is the option to construct UnBindata copying the data inside; 31 (in the base FitData class) or using a pointer to external data, depending on which; 32 constructor of the UnBinData class is used.; 33 It is recommended to copy the input data inside, since this will be more efficient and; 34 less error prone, since the input provided data will have to be kept alive for all the time the; 35 Fit classes will be used.; 36 In case of really large data sets for limiting memory consumption then the other option can be used; 37 with special care.; 38 Specialized constructor exists for using external data up to 3 dimensions.; 39 ; 40 When the data are copying in the number of points can be set later (or re-set) using Initialize and; 41 the data are inserted one by one using the Add method.; 42 It is mandatory to set the size before using the Add method.; 43 ; 44 @ingroup FitData; 45*/; 46class UnBinData : public FitData {; 47 ; 48public :; 49 ; 50 /**; 51 constructor from dimension of point and max number of points (to pre-allocate vector); 52 */; 53 ; 54 explicit UnBinData( unsigned int maxpoints = 0, unsigned int dim = 1,; 55 bool isWeighted = false ) :; 56 FitData( maxpoints, isWeighted ? dim + 1 : dim ),; 57 fWeighted(isWeighted); 58 {; 59 assert( dim >= 1 );; 60 assert( !fWeighted || dim >=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/UnBinData_8h_source.html:1224,efficient,efficient,1224,doc/master/UnBinData_8h_source.html,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html,1,['efficient'],['efficient']
Energy Efficiency," 26./255., 51./255., 43./255., 33./255., 28./255., 35./255., 74./255., 144./255., 246./255.};; 3598 Double_t green[9] = { 9./255., 24./255., 55./255., 87./255., 118./255., 150./255., 180./255., 200./255., 222./255.};; 3599 Double_t blue[9] = { 30./255., 96./255., 112./255., 114./255., 112./255., 101./255., 72./255., 35./255., 0./255.};; 3600 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3601 }; 3602 break;; 3603 ; 3604 // Cividis; 3605 case 113:; 3606 {; 3607 Double_t red[9] = { 0./255., 5./255., 65./255., 97./255., 124./255., 156./255., 189./255., 224./255., 255./255.};; 3608 Double_t green[9] = { 32./255., 54./255., 77./255., 100./255., 123./255., 148./255., 175./255., 203./255., 234./255.};; 3609 Double_t blue[9] = { 77./255., 110./255., 107./255., 111./255., 120./255., 119./255., 111./255., 94./255., 70./255.};; 3610 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3611 }; 3612 break;; 3613 ; 3614 default:; 3615 ::Error(""SetPalette"", ""Unknown palette number %d"", ncolors);; 3616 return;; 3617 }; 3618 paletteType = ncolors;; 3619 if (Idx>0) fgPalettesList.fArray[paletteType-51] = (Double_t)Idx;; 3620 else fgPalettesList.fArray[paletteType-51] = 0.;; 3621 if (alpha > 0.) fgPalettesList.fArray[paletteType-51] += alpha/10.0f;; 3622 return;; 3623 }; 3624 ; 3625 // set user defined palette; 3626 if (colors) {; 3627 fgPalette.Set(ncolors);; 3628 for (i=0;i<ncolors;i++) fgPalette.fArray[i] = colors[i];; 3629 } else {; 3630 fgPalette.Set(TMath::Min(50,ncolors));; 3631 for (i=0;i<TMath::Min(50,ncolors);i++) fgPalette.fArray[i] = palette[i];; 3632 }; 3633 paletteType = 3;; 3634}; 3635 ; 3636 ; 3637////////////////////////////////////////////////////////////////////////////////; 3638/// Invert the current color palette.; 3639/// The top of the palette becomes the bottom and vice versa.; 3640 ; 3641void TColor::InvertPalette(); 3642{; 3643 std::reverse(fgPalette.fArray, fgPalette.fArray + fgPalette.GetSize());",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:144363,green,green,144363,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency," 260 ; 261 Settings::~Settings () ; 262 {; 263 }; 264 ; 265 ; 266 ; 267 ; 268 ; 269 ; 270 ; 271 ; 272 ; 273 ; 274 ; 275 ; 276 ; 277 ; 278 /** \brief action to be done when the training cycle is started (e.g. update some monitoring output); 279 *; 280 */; 281 void ClassificationSettings::startTrainCycle () ; 282 {; 283 if (fMonitoring); 284 {; 285 create (""ROC"", 100, 0, 1, 100, 0, 1);; 286 create (""Significance"", 100, 0, 1, 100, 0, 3);; 287 create (""OutputSig"", 100, 0, 1);; 288 create (""OutputBkg"", 100, 0, 1);; 289 fMonitoring->ProcessEvents ();; 290 }; 291 }; 292 ; 293 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 294 *; 295 */; 296 void ClassificationSettings::endTrainCycle (double /*error*/) ; 297 {; 298 if (fMonitoring) fMonitoring->ProcessEvents ();; 299 }; 300 ; 301 /** \brief action to be done after the computation of a test sample (e.g. update some monitoring output); 302 *; 303 */; 304 void ClassificationSettings::testSample (double /*error*/, double output, double target, double weight); 305 {; 306 ; 307 m_output.push_back (output);; 308 m_targets.push_back (target);; 309 m_weights.push_back (weight);; 310 }; 311 ; 312 ; 313 /** \brief action to be done when the test cycle is started (e.g. update some monitoring output); 314 *; 315 */; 316 void ClassificationSettings::startTestCycle () ; 317 {; 318 m_output.clear ();; 319 m_targets.clear ();; 320 m_weights.clear ();; 321 }; 322 ; 323 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 324 *; 325 */; 326 void ClassificationSettings::endTestCycle () ; 327 {; 328 if (m_output.empty ()); 329 return;; 330 double minVal = *std::min_element (begin (m_output), end (m_output));; 331 double maxVal = *std::max_element (begin (m_output), end (m_output));; 332 const size_t numBinsROC = 1000;; 333 const size_t numBinsData = 100;; 334 ; 335 std::vector<double> truePositives (numBinsROC+1, 0);; 336 std::vector<double> false",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8cxx_source.html:11645,monitor,monitoring,11645,doc/master/NeuralNet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html,1,['monitor'],['monitoring']
Energy Efficiency," 284 of file RVec.hxx. ◆ front() [2/2]. template<typename T > . const_reference ROOT::Internal::VecOps::SmallVectorTemplateCommon< T >::front ; (; ); const. inline . Definition at line 292 of file RVec.hxx. ◆ getFirstEl(). template<typename T > . void * ROOT::Internal::VecOps::SmallVectorTemplateCommon< T >::getFirstEl ; (; ); const. inlineprivate . Find the address of the first element. ; For this pointer math to be valid with small-size of 0 for T with lots of alignment, it's important that SmallVectorStorage is properly-aligned even for small-size of 0. ; Definition at line 212 of file RVec.hxx. ◆ grow_pod(). template<typename T > . void ROOT::Internal::VecOps::SmallVectorTemplateCommon< T >::grow_pod ; (; size_t ; MinSize, . size_t ; TSize . ). inlineprotected . Definition at line 222 of file RVec.hxx. ◆ isSmall(). template<typename T > . bool ROOT::Internal::VecOps::SmallVectorTemplateCommon< T >::isSmall ; (; ); const. inlineprotected . Return true if this is a smallvector which has not had dynamic memory allocated for it. ; Definition at line 226 of file RVec.hxx. ◆ max_size(). template<typename T > . size_type ROOT::Internal::VecOps::SmallVectorTemplateCommon< T >::max_size ; (; ); const. inlinenoexcept . Definition at line 275 of file RVec.hxx. ◆ rbegin() [1/2]. template<typename T > . const_reverse_iterator ROOT::Internal::VecOps::SmallVectorTemplateCommon< T >::rbegin ; (; ); const. inlinenoexcept . Definition at line 268 of file RVec.hxx. ◆ rbegin() [2/2]. template<typename T > . reverse_iterator ROOT::Internal::VecOps::SmallVectorTemplateCommon< T >::rbegin ; (; ). inlinenoexcept . Definition at line 267 of file RVec.hxx. ◆ rend() [1/2]. template<typename T > . const_reverse_iterator ROOT::Internal::VecOps::SmallVectorTemplateCommon< T >::rend ; (; ); const. inlinenoexcept . Definition at line 271 of file RVec.hxx. ◆ rend() [2/2]. template<typename T > . reverse_iterator ROOT::Internal::VecOps::SmallVectorTemplateCommon< T >::rend ; (; ). inlinenoexcept",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorTemplateCommon.html:10725,allocate,allocated,10725,doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorTemplateCommon.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1VecOps_1_1SmallVectorTemplateCommon.html,1,['allocate'],['allocated']
Energy Efficiency," 2953////////////////////////////////////////////////////////////////////////////////; 2954/// If true, the current pdf is a selected component (for use in plotting); 2955 ; 2956bool RooAbsReal::isSelectedComp() const; 2957{; 2958 return _selectComp || _globalSelectComp ;; 2959}; 2960 ; 2961 ; 2962 ; 2963////////////////////////////////////////////////////////////////////////////////; 2964/// Global switch controlling the activation of the selectComp() functionality; 2965 ; 2966void RooAbsReal::globalSelectComp(bool flag); 2967{; 2968 _globalSelectComp = flag ;; 2969}; 2970 ; 2971 ; 2972 ; 2973 ; 2974////////////////////////////////////////////////////////////////////////////////; 2975/// Create an interface adaptor f(vars) that binds us to the specified variables; 2976/// (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; 2977/// F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; 2978/// current values of x2 and x4. The caller takes ownership of the returned adaptor.; 2979 ; 2980RooFit::OwningPtr<RooAbsFunc> RooAbsReal::bindVars(const RooArgSet &vars, const RooArgSet* nset, bool clipInvalid) const; 2981{; 2982 auto binding = std::make_unique<RooRealBinding>(*this,vars,nset,clipInvalid);; 2983 if(!binding->isValid()) {; 2984 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":bindVars: cannot bind to "" << vars << std::endl ;; 2985 return nullptr;; 2986 }; 2987 return RooFit::makeOwningPtr(std::unique_ptr<RooAbsFunc>{std::move(binding)});; 2988}; 2989 ; 2990 ; 2991 ; 2992////////////////////////////////////////////////////////////////////////////////; 2993/// Copy the cached value of another RooAbsArg to our cache.; 2994/// Warning: This function just copies the cached values of source,; 2995/// it is the callers responsibility to make sure the cache is clean.; 2996 ; 2997void RooAbsReal::copyCache(const RooAbsArg* source, bool /*valueOnly*/, bool setValDirty); 2998{; 2999 auto other = static_cast<const RooAbsRea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:129264,adapt,adaptor,129264,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['adapt'],['adaptor']
Energy Efficiency," 32 (1957) 920]. The probability density function of the Vavilov distribution; as function of Landau's parameter is given by:; \f[ p(\lambda_L; \kappa, \beta^2) =; \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class Vavilov,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::Mean(kappa, beta2); and sqrt(Vavilov::Variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. Two subclasses are provided:; - VavilovFast uses the algorithm by; A. Rotondi and P. Montagna, Fast calculation of Vavilov distribution,; <A HREF=""http://dx.doi.org/10.1016/0168-583X(90)90749-K"">Nucl. Instr. and Meth. B47 (1990) 215-224</A>,; which has been implemented in; <A HREF=""http://wwwasdoc.web.cern.ch/wwwasdoc/shortwrupsdir/g115/top.html"">; CERNLIB (G11",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__Vavilov.html:1494,charge,charged,1494,root/html528/ROOT__Math__Vavilov.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__Vavilov.html,10,['charge'],['charged']
Energy Efficiency," 32./255., 58./255., 83./255., 119./255., 136./255., 173./255.};; 3479 Double_t blue[9] = { 5./255., 6./255., 7./255., 9./255., 9./255., 14./255., 17./255., 19./255., 24./255.};; 3480 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3481 }; 3482 break;; 3483 ; 3484 // South West; 3485 case 101:; 3486 {; 3487 Double_t red[9] = { 82./255., 106./255., 126./255., 141./255., 155./255., 163./255., 142./255., 107./255., 66./255.};; 3488 Double_t green[9] = { 62./255., 44./255., 69./255., 107./255., 135./255., 152./255., 149./255., 132./255., 119./255.};; 3489 Double_t blue[9] = { 39./255., 25./255., 31./255., 60./255., 73./255., 68./255., 49./255., 72./255., 188./255.};; 3490 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3491 }; 3492 break;; 3493 ; 3494 // Starry Night; 3495 case 102:; 3496 {; 3497 Double_t red[9] = { 18./255., 29./255., 44./255., 72./255., 116./255., 158./255., 184./255., 208./255., 221./255.};; 3498 Double_t green[9] = { 27./255., 46./255., 71./255., 105./255., 146./255., 177./255., 189./255., 190./255., 183./255.};; 3499 Double_t blue[9] = { 39./255., 55./255., 80./255., 108./255., 130./255., 133./255., 124./255., 100./255., 76./255.};; 3500 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3501 }; 3502 break;; 3503 ; 3504 // Sunset; 3505 case 103:; 3506 {; 3507 Double_t red[9] = { 0./255., 48./255., 119./255., 173./255., 212./255., 224./255., 228./255., 228./255., 245./255.};; 3508 Double_t green[9] = { 0./255., 13./255., 30./255., 47./255., 79./255., 127./255., 167./255., 205./255., 245./255.};; 3509 Double_t blue[9] = { 0./255., 68./255., 75./255., 43./255., 16./255., 22./255., 55./255., 128./255., 245./255.};; 3510 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3511 }; 3512 break;; 3513 ; 3514 // Temperature Map; 3515 case 104:; 3516 {; 3517 Double_t red[9] = { 34./255., 70./255., 129./255., 187./255., 225./255., 226./2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:138320,green,green,138320,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency," 3286 {; 3287 Double_t red[9] = { 19./255., 44./255., 74./255., 105./255., 137./255., 166./255., 194./255., 206./255., 220./255.};; 3288 Double_t green[9] = { 19./255., 28./255., 40./255., 55./255., 82./255., 110./255., 159./255., 181./255., 220./255.};; 3289 Double_t blue[9] = { 19./255., 42./255., 68./255., 96./255., 129./255., 157./255., 188./255., 203./255., 220./255.};; 3290 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3291 }; 3292 break;; 3293 ; 3294 // Grey Yellow; 3295 case 82:; 3296 {; 3297 Double_t red[9] = { 33./255., 44./255., 70./255., 99./255., 140./255., 165./255., 199./255., 211./255., 216./255.};; 3298 Double_t green[9] = { 38./255., 50./255., 76./255., 105./255., 140./255., 165./255., 191./255., 189./255., 167./255.};; 3299 Double_t blue[9] = { 55./255., 67./255., 97./255., 124./255., 140./255., 166./255., 163./255., 129./255., 52./255.};; 3300 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3301 }; 3302 break;; 3303 ; 3304 // Green Brown Terrain; 3305 case 83:; 3306 {; 3307 Double_t red[9] = { 0./255., 33./255., 73./255., 124./255., 136./255., 152./255., 159./255., 171./255., 223./255.};; 3308 Double_t green[9] = { 0./255., 43./255., 92./255., 124./255., 134./255., 126./255., 121./255., 144./255., 223./255.};; 3309 Double_t blue[9] = { 0./255., 43./255., 68./255., 76./255., 73./255., 64./255., 72./255., 114./255., 223./255.};; 3310 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3311 }; 3312 break;; 3313 ; 3314 // Green Pink; 3315 case 84:; 3316 {; 3317 Double_t red[9] = { 5./255., 18./255., 45./255., 124./255., 193./255., 223./255., 205./255., 128./255., 49./255.};; 3318 Double_t green[9] = { 48./255., 134./255., 207./255., 230./255., 193./255., 113./255., 28./255., 0./255., 7./255.};; 3319 Double_t blue[9] = { 6./255., 15./255., 41./255., 121./255., 193./255., 226./255., 208./255., 130./255., 49./255.};; 3320 Idx = TColor::CreateGradientColorTabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:128125,green,green,128125,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency," 3296 {; 3297 Double_t red[9] = { 33./255., 44./255., 70./255., 99./255., 140./255., 165./255., 199./255., 211./255., 216./255.};; 3298 Double_t green[9] = { 38./255., 50./255., 76./255., 105./255., 140./255., 165./255., 191./255., 189./255., 167./255.};; 3299 Double_t blue[9] = { 55./255., 67./255., 97./255., 124./255., 140./255., 166./255., 163./255., 129./255., 52./255.};; 3300 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3301 }; 3302 break;; 3303 ; 3304 // Green Brown Terrain; 3305 case 83:; 3306 {; 3307 Double_t red[9] = { 0./255., 33./255., 73./255., 124./255., 136./255., 152./255., 159./255., 171./255., 223./255.};; 3308 Double_t green[9] = { 0./255., 43./255., 92./255., 124./255., 134./255., 126./255., 121./255., 144./255., 223./255.};; 3309 Double_t blue[9] = { 0./255., 43./255., 68./255., 76./255., 73./255., 64./255., 72./255., 114./255., 223./255.};; 3310 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3311 }; 3312 break;; 3313 ; 3314 // Green Pink; 3315 case 84:; 3316 {; 3317 Double_t red[9] = { 5./255., 18./255., 45./255., 124./255., 193./255., 223./255., 205./255., 128./255., 49./255.};; 3318 Double_t green[9] = { 48./255., 134./255., 207./255., 230./255., 193./255., 113./255., 28./255., 0./255., 7./255.};; 3319 Double_t blue[9] = { 6./255., 15./255., 41./255., 121./255., 193./255., 226./255., 208./255., 130./255., 49./255.};; 3320 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3321 }; 3322 break;; 3323 ; 3324 // Island; 3325 case 85:; 3326 {; 3327 Double_t red[9] = { 180./255., 106./255., 104./255., 135./255., 164./255., 188./255., 189./255., 165./255., 144./255.};; 3328 Double_t green[9] = { 72./255., 126./255., 154./255., 184./255., 198./255., 207./255., 205./255., 190./255., 179./255.};; 3329 Double_t blue[9] = { 41./255., 120./255., 158./255., 188./255., 194./255., 181./255., 145./255., 100./255., 62./255.};; 3330 Idx = TColor::CreateGradientColo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:128656,green,green,128656,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency," 3305 case 83:; 3306 {; 3307 Double_t red[9] = { 0./255., 33./255., 73./255., 124./255., 136./255., 152./255., 159./255., 171./255., 223./255.};; 3308 Double_t green[9] = { 0./255., 43./255., 92./255., 124./255., 134./255., 126./255., 121./255., 144./255., 223./255.};; 3309 Double_t blue[9] = { 0./255., 43./255., 68./255., 76./255., 73./255., 64./255., 72./255., 114./255., 223./255.};; 3310 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3311 }; 3312 break;; 3313 ; 3314 // Green Pink; 3315 case 84:; 3316 {; 3317 Double_t red[9] = { 5./255., 18./255., 45./255., 124./255., 193./255., 223./255., 205./255., 128./255., 49./255.};; 3318 Double_t green[9] = { 48./255., 134./255., 207./255., 230./255., 193./255., 113./255., 28./255., 0./255., 7./255.};; 3319 Double_t blue[9] = { 6./255., 15./255., 41./255., 121./255., 193./255., 226./255., 208./255., 130./255., 49./255.};; 3320 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3321 }; 3322 break;; 3323 ; 3324 // Island; 3325 case 85:; 3326 {; 3327 Double_t red[9] = { 180./255., 106./255., 104./255., 135./255., 164./255., 188./255., 189./255., 165./255., 144./255.};; 3328 Double_t green[9] = { 72./255., 126./255., 154./255., 184./255., 198./255., 207./255., 205./255., 190./255., 179./255.};; 3329 Double_t blue[9] = { 41./255., 120./255., 158./255., 188./255., 194./255., 181./255., 145./255., 100./255., 62./255.};; 3330 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3331 }; 3332 break;; 3333 ; 3334 // Lake; 3335 case 86:; 3336 {; 3337 Double_t red[9] = { 57./255., 72./255., 94./255., 117./255., 136./255., 154./255., 174./255., 192./255., 215./255.};; 3338 Double_t green[9] = { 0./255., 33./255., 68./255., 109./255., 140./255., 171./255., 192./255., 196./255., 209./255.};; 3339 Double_t blue[9] = { 116./255., 137./255., 173./255., 201./255., 200./255., 201./255., 203./255., 190./255., 187./255.};; 3340 Idx = TColor::CreateGradient",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:129178,green,green,129178,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency," 3334 Int_t maxcolors = 0, ncolors = 0;; 3335 ; 3336 // collect different image colors; 3337 int x, y;; 3338 for (x = 0; x < (int) gCws->fWidth; x++) {; 3339 for (y = 0; y < (int) gCws->fHeight; y++) {; 3340 ULong_t pixel = XGetPixel(image, x, y);; 3341 CollectImageColors(pixel, orgcolors, ncolors, maxcolors);; 3342 }; 3343 }; 3344 ; 3345 // get RGB values belonging to pixels; 3346 RXColor *xcol = new RXColor[ncolors];; 3347 ; 3348 int i;; 3349 for (i = 0; i < ncolors; i++) {; 3350 xcol[i].pixel = orgcolors[i];; 3351 xcol[i].red = xcol[i].green = xcol[i].blue = 0;; 3352 xcol[i].flags = DoRed | DoGreen | DoBlue;; 3353 }; 3354 QueryColors(fColormap, xcol, ncolors);; 3355 ; 3356 // create RGB arrays and store RGB's for each color and set number of colors; 3357 // (space must be delete by caller); 3358 R = new Int_t[ncolors];; 3359 G = new Int_t[ncolors];; 3360 B = new Int_t[ncolors];; 3361 ; 3362 for (i = 0; i < ncolors; i++) {; 3363 R[i] = xcol[i].red;; 3364 G[i] = xcol[i].green;; 3365 B[i] = xcol[i].blue;; 3366 }; 3367 ncol = ncolors;; 3368 ; 3369 // update image with indices (pixels) into the new RGB colormap; 3370 for (x = 0; x < (int) gCws->fWidth; x++) {; 3371 for (y = 0; y < (int) gCws->fHeight; y++) {; 3372 ULong_t pixel = XGetPixel(image, x, y);; 3373 Int_t idx = FindColor(pixel, orgcolors, ncolors);; 3374 XPutPixel(image, x, y, idx);; 3375 }; 3376 }; 3377 ; 3378 // cleanup; 3379 delete [] xcol;; 3380 ::operator delete(orgcolors);; 3381}; 3382 ; 3383////////////////////////////////////////////////////////////////////////////////; 3384/// Writes the current window into GIF file. Returns 1 in case of success,; 3385/// 0 otherwise.; 3386 ; 3387Int_t TGX11::WriteGIF(char *name); 3388{; 3389 Byte_t scline[2000], r[256], b[256], g[256];; 3390 Int_t *red, *green, *blue;; 3391 Int_t ncol, maxcol, i;; 3392 ; 3393 if (gXimage) {; 3394 XDestroyImage(gXimage);; 3395 gXimage = nullptr;; 3396 }; 3397 ; 3398 gXimage = XGetImage((Display*)fDisplay, gCws->fDrawing, 0, 0,; 3399",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:111739,green,green,111739,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['green'],['green']
Energy Efficiency," 3475 case 100:; 3476 {; 3477 Double_t red[9] = { 99./255., 116./255., 154./255., 174./255., 200./255., 196./255., 201./255., 201./255., 230./255.};; 3478 Double_t green[9] = { 0./255., 0./255., 8./255., 32./255., 58./255., 83./255., 119./255., 136./255., 173./255.};; 3479 Double_t blue[9] = { 5./255., 6./255., 7./255., 9./255., 9./255., 14./255., 17./255., 19./255., 24./255.};; 3480 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3481 }; 3482 break;; 3483 ; 3484 // South West; 3485 case 101:; 3486 {; 3487 Double_t red[9] = { 82./255., 106./255., 126./255., 141./255., 155./255., 163./255., 142./255., 107./255., 66./255.};; 3488 Double_t green[9] = { 62./255., 44./255., 69./255., 107./255., 135./255., 152./255., 149./255., 132./255., 119./255.};; 3489 Double_t blue[9] = { 39./255., 25./255., 31./255., 60./255., 73./255., 68./255., 49./255., 72./255., 188./255.};; 3490 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3491 }; 3492 break;; 3493 ; 3494 // Starry Night; 3495 case 102:; 3496 {; 3497 Double_t red[9] = { 18./255., 29./255., 44./255., 72./255., 116./255., 158./255., 184./255., 208./255., 221./255.};; 3498 Double_t green[9] = { 27./255., 46./255., 71./255., 105./255., 146./255., 177./255., 189./255., 190./255., 183./255.};; 3499 Double_t blue[9] = { 39./255., 55./255., 80./255., 108./255., 130./255., 133./255., 124./255., 100./255., 76./255.};; 3500 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3501 }; 3502 break;; 3503 ; 3504 // Sunset; 3505 case 103:; 3506 {; 3507 Double_t red[9] = { 0./255., 48./255., 119./255., 173./255., 212./255., 224./255., 228./255., 228./255., 245./255.};; 3508 Double_t green[9] = { 0./255., 13./255., 30./255., 47./255., 79./255., 127./255., 167./255., 205./255., 245./255.};; 3509 Double_t blue[9] = { 0./255., 68./255., 75./255., 43./255., 16./255., 22./255., 55./255., 128./255., 245./255.};; 3510 Idx = TColor::CreateGradientColorTable(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:138083,green,green,138083,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency," 3506 {; 3507 Double_t red[9] = { 0./255., 48./255., 119./255., 173./255., 212./255., 224./255., 228./255., 228./255., 245./255.};; 3508 Double_t green[9] = { 0./255., 13./255., 30./255., 47./255., 79./255., 127./255., 167./255., 205./255., 245./255.};; 3509 Double_t blue[9] = { 0./255., 68./255., 75./255., 43./255., 16./255., 22./255., 55./255., 128./255., 245./255.};; 3510 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3511 }; 3512 break;; 3513 ; 3514 // Temperature Map; 3515 case 104:; 3516 {; 3517 Double_t red[9] = { 34./255., 70./255., 129./255., 187./255., 225./255., 226./255., 216./255., 193./255., 179./255.};; 3518 Double_t green[9] = { 48./255., 91./255., 147./255., 194./255., 226./255., 229./255., 196./255., 110./255., 12./255.};; 3519 Double_t blue[9] = { 234./255., 212./255., 216./255., 224./255., 206./255., 110./255., 53./255., 40./255., 29./255.};; 3520 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3521 }; 3522 break;; 3523 ; 3524 // Thermometer; 3525 case 105:; 3526 {; 3527 Double_t red[9] = { 30./255., 55./255., 103./255., 147./255., 174./255., 203./255., 188./255., 151./255., 105./255.};; 3528 Double_t green[9] = { 0./255., 65./255., 138./255., 182./255., 187./255., 175./255., 121./255., 53./255., 9./255.};; 3529 Double_t blue[9] = { 191./255., 202./255., 212./255., 208./255., 171./255., 140./255., 97./255., 57./255., 30./255.};; 3530 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3531 }; 3532 break;; 3533 ; 3534 // Valentine; 3535 case 106:; 3536 {; 3537 Double_t red[9] = { 112./255., 97./255., 113./255., 125./255., 138./255., 159./255., 178./255., 188./255., 225./255.};; 3538 Double_t green[9] = { 16./255., 17./255., 24./255., 37./255., 56./255., 81./255., 110./255., 136./255., 189./255.};; 3539 Double_t blue[9] = { 38./255., 35./255., 46./255., 59./255., 78./255., 103./255., 130./255., 152./255., 201./255.};; 3540 Idx = TColor::CreateGradientColo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:139667,green,green,139667,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency," 3535 case 106:; 3536 {; 3537 Double_t red[9] = { 112./255., 97./255., 113./255., 125./255., 138./255., 159./255., 178./255., 188./255., 225./255.};; 3538 Double_t green[9] = { 16./255., 17./255., 24./255., 37./255., 56./255., 81./255., 110./255., 136./255., 189./255.};; 3539 Double_t blue[9] = { 38./255., 35./255., 46./255., 59./255., 78./255., 103./255., 130./255., 152./255., 201./255.};; 3540 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3541 }; 3542 break;; 3543 ; 3544 // Visible Spectrum; 3545 case 107:; 3546 {; 3547 Double_t red[9] = { 18./255., 72./255., 5./255., 23./255., 29./255., 201./255., 200./255., 98./255., 29./255.};; 3548 Double_t green[9] = { 0./255., 0./255., 43./255., 167./255., 211./255., 117./255., 0./255., 0./255., 0./255.};; 3549 Double_t blue[9] = { 51./255., 203./255., 177./255., 26./255., 10./255., 9./255., 8./255., 3./255., 0./255.};; 3550 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3551 }; 3552 break;; 3553 ; 3554 // Water Melon; 3555 case 108:; 3556 {; 3557 Double_t red[9] = { 19./255., 42./255., 64./255., 88./255., 118./255., 147./255., 175./255., 187./255., 205./255.};; 3558 Double_t green[9] = { 19./255., 55./255., 89./255., 125./255., 154./255., 169./255., 161./255., 129./255., 70./255.};; 3559 Double_t blue[9] = { 19./255., 32./255., 47./255., 70./255., 100./255., 128./255., 145./255., 130./255., 75./255.};; 3560 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3561 }; 3562 break;; 3563 ; 3564 // Cool; 3565 case 109:; 3566 {; 3567 Double_t red[9] = { 33./255., 31./255., 42./255., 68./255., 86./255., 111./255., 141./255., 172./255., 227./255.};; 3568 Double_t green[9] = { 255./255., 175./255., 145./255., 106./255., 88./255., 55./255., 15./255., 0./255., 0./255.};; 3569 Double_t blue[9] = { 255./255., 205./255., 202./255., 203./255., 208./255., 205./255., 203./255., 206./255., 231./255.};; 3570 Idx = TColor::CreateGradientColorTable(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:141237,green,green,141237,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency," 37./255., 74./255., 113./255., 160./255., 221./255.};; 2989 Double_t blue[9] = { 28./255., 42./255., 59./255., 78./255., 98./255., 129./255., 154./255., 184./255., 221./255.};; 2990 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 2991 }; 2992 break;; 2993 ; 2994 // Grey Scale; 2995 case 52:; 2996 {; 2997 Double_t red[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2998 Double_t green[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2999 Double_t blue[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 3000 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3001 }; 3002 break;; 3003 ; 3004 // Dark Body Radiator; 3005 case 53:; 3006 {; 3007 Double_t red[9] = { 0./255., 45./255., 99./255., 156./255., 212./255., 230./255., 237./255., 234./255., 242./255.};; 3008 Double_t green[9] = { 0./255., 0./255., 0./255., 45./255., 101./255., 168./255., 238./255., 238./255., 243./255.};; 3009 Double_t blue[9] = { 0./255., 1./255., 1./255., 3./255., 9./255., 8./255., 11./255., 95./255., 230./255.};; 3010 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3011 }; 3012 break;; 3013 ; 3014 // Two-color hue (dark blue through neutral gray to bright yellow); 3015 case 54:; 3016 {; 3017 Double_t red[9] = { 0./255., 22./255., 44./255., 68./255., 93./255., 124./255., 160./255., 192./255., 237./255.};; 3018 Double_t green[9] = { 0./255., 16./255., 41./255., 67./255., 93./255., 125./255., 162./255., 194./255., 241./255.};; 3019 Double_t blue[9] = { 97./255., 100./255., 99./255., 99./255., 93./255., 68./255., 44./255., 26./255., 74./255.};; 3020 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3021 }; 3022 break;; 3023 ; 3024 // Rain Bow; 3025 case 55:; 3026 {; 3027 Double_t red[9] = { 0./255., 5./255., 15./255., ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:112771,green,green,112771,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency," 392 fSize = fNpoints;; 393 if (fHistogram) {; 394 delete fHistogram;; 395 fHistogram = nullptr;; 396 fDelaunay = nullptr;; 397 }; 398 return ipoint;; 399}; 400 ; 401////////////////////////////////////////////////////////////////////////////////; 402/// Set x, y and z values for point number i; 403 ; 404void TGraph2DErrors::SetPoint(Int_t i, Double_t x, Double_t y, Double_t z); 405{; 406 if (i < 0) return;; 407 if (i >= fNpoints) {; 408 // re-allocate the object; 409 Double_t *savex = new Double_t[i+1];; 410 Double_t *savey = new Double_t[i+1];; 411 Double_t *savez = new Double_t[i+1];; 412 Double_t *saveex = new Double_t[i+1];; 413 Double_t *saveey = new Double_t[i+1];; 414 Double_t *saveez = new Double_t[i+1];; 415 if (fNpoints > 0) {; 416 memcpy(savex, fX, fNpoints*sizeof(Double_t));; 417 memcpy(savey, fY, fNpoints*sizeof(Double_t));; 418 memcpy(savez, fZ, fNpoints*sizeof(Double_t));; 419 memcpy(saveex,fEX,fNpoints*sizeof(Double_t));; 420 memcpy(saveey,fEY,fNpoints*sizeof(Double_t));; 421 memcpy(saveez,fEZ,fNpoints*sizeof(Double_t));; 422 }; 423 if (fX) delete [] fX;; 424 if (fY) delete [] fY;; 425 if (fZ) delete [] fZ;; 426 if (fEX) delete [] fEX;; 427 if (fEY) delete [] fEY;; 428 if (fEZ) delete [] fEZ;; 429 fX = savex;; 430 fY = savey;; 431 fZ = savez;; 432 fEX = saveex;; 433 fEY = saveey;; 434 fEZ = saveez;; 435 fNpoints = i+1;; 436 }; 437 fX[i] = x;; 438 fY[i] = y;; 439 fZ[i] = z;; 440}; 441 ; 442 ; 443////////////////////////////////////////////////////////////////////////////////; 444/// Set ex, ey and ez values for point number i; 445 ; 446void TGraph2DErrors::SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez); 447{; 448 if (i < 0) return;; 449 if (i >= fNpoints) {; 450 // re-allocate the object; 451 TGraph2DErrors::SetPoint(i,0,0,0);; 452 }; 453 fEX[i] = ex;; 454 fEY[i] = ey;; 455 fEZ[i] = ez;; 456}; 457 ; 458 ; 459////////////////////////////////////////////////////////////////////////////////; 460/// Stream an object of class TGraph2DErrors.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:13324,allocate,allocate,13324,doc/master/TGraph2DErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency," 42 of file RooSpHarmonic.h. ◆ evaluate(). double RooSpHarmonic::evaluate ; (; ); const. overrideprivatevirtual . Note: P_0^0 = 1, so P_l^m = P_l^m P_0^0. ; Reimplemented from RooLegendre.; Definition at line 111 of file RooSpHarmonic.cxx. ◆ getAnalyticalIntegral(). Int_t RooSpHarmonic::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . TODO: check that phi.max - phi.min = 2 pi... ctheta.max = +1, and ctheta.min = -1 we don't support indefinite integrals. ; maybe one day, when there is a use for it. ; Reimplemented from RooLegendre.; Definition at line 140 of file RooSpHarmonic.cxx. ◆ getMaxVal(). Int_t RooSpHarmonic::getMaxVal ; (; const RooArgSet & ; vars); const. overridevirtual . Advertise capability to determine maximum value of function for given set of observables. ; If no direct generator method is provided, this information will assist the accept/reject generator to operate more efficiently as it can skip the initial trial sampling phase to empirically find the function maximum ; Reimplemented from RooLegendre.; Definition at line 167 of file RooSpHarmonic.cxx. ◆ IsA(). TClass * RooSpHarmonic::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooLegendre.; Definition at line 42 of file RooSpHarmonic.h. ◆ maxVal(). double RooSpHarmonic::maxVal ; (; Int_t ; code); const. overridevirtual . Return maximum value for set of observables identified by code assigned in getMaxVal. ; Reimplemented from RooLegendre.; Definition at line 171 of file RooSpHarmonic.cxx. ◆ Streamer(). void RooSpHarmonic::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooLegendre. ◆ StreamerNVirtual(). void RooSpHarmonic::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 42 of file RooSpHarmonic.h. Member Data Documentation. ◆ _n. double RooSpHarmon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSpHarmonic.html:64865,efficient,efficiently,64865,doc/master/classRooSpHarmonic.html,https://root.cern,https://root.cern/doc/master/classRooSpHarmonic.html,1,['efficient'],['efficiently']
Energy Efficiency," 45namespace ROOT {; 46namespace Math {; 47 ; 48 ; 49//_____________________________________________________________________________________; 50/**; 51 User class for MathMore random numbers template on the Engine type.; 52 The API of this class followed that of the class ROOT::Math::Random; 53 It must be implemented using as Engine one of the derived classes of; 54 ROOT::Math::GSLQuasiRandomEngine, like ROOT::Math::GSLQrngSobol; 55 ; 56 @ingroup QuasiRandom; 57 ; 58*/; 59template < class Engine>; 60class QuasiRandom {; 61 ; 62public:; 63 ; 64 ; 65 /**; 66 Create a QuasiRandom generator. Use default engine constructor.; 67 Engine will be initialized via Initialize() function in order to; 68 allocate resources; 69 */; 70 QuasiRandom(unsigned int dimension = 1) {; 71 fEngine.Initialize(dimension);; 72 }; 73 ; 74 ; 75 /**; 76 Create a QuasiRandom generator based on a provided generic engine.; 77 Engine will be initialized via Initialize() function in order to; 78 allocate resources; 79 */; 80 explicit QuasiRandom(const Engine & e, unsigned int dimension = 1) : fEngine(e) {; 81 fEngine.Initialize(dimension);; 82 }; 83 ; 84 /**; 85 Destructor: call Terminate() function of engine to free any; 86 allocated resource; 87 */; 88 ~QuasiRandom() {; 89 fEngine.Terminate();; 90 }; 91 ; 92 /**; 93 Generate next quasi random numbers points; 94 */; 95 bool Next(double * x) {; 96 return fEngine(x);; 97 }; 98 ; 99 /**; 100 Generate next quasi random numbers point (1 - dimension); 101 */; 102 double Next() {; 103 return fEngine();; 104 }; 105 ; 106 /**; 107 Generate quasi random numbers between ]0,1[; 108 0 and 1 are excluded; 109 Function to be compatible with ROOT TRandom compatibility; 110 */; 111 double Rndm() {; 112 return fEngine();; 113 }; 114 ; 115 /**; 116 skip the next n number and jumb directly to the current state + n; 117 */; 118 bool Skip(unsigned int n) {; 119 return fEngine.Skip(n);; 120 }; 121 /**; 122 Generate an array of random numbers between ]0,1[; 123 Function to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/QuasiRandom_8h_source.html:2756,allocate,allocate,2756,doc/master/QuasiRandom_8h_source.html,https://root.cern,https://root.cern/doc/master/QuasiRandom_8h_source.html,1,['allocate'],['allocate']
Energy Efficiency," 47 std::string name; ///< node name; 48 std::vector<int> chlds; ///< list of childs id; 49 int vis{0}; ///< visibility flag, 0 - off, 1 - only when level==0, 99 - always; 50 bool nochlds{false}; ///< how far in hierarchy depth should be scanned; 51 ; 52 std::string color; ///< rgb code in hex format; 53 std::string material; ///< name of the material; 54 int sortid{0}; ///<! place in sorted array, to check cuts, or id of original node when used search structures; 55 ; 56 RGeomNodeBase(int _id = 0) : id(_id) {}; 57 ; 58 bool IsVisible() const { return vis > 0; }; 59 ; 60 /** Returns argument for regexp */; 61 const char *GetArg(int kind); 62 {; 63 if (kind == 1) return color.c_str();; 64 if (kind == 2) return material.c_str();; 65 return name.c_str();; 66 }; 67};; 68 ; 69/** Full node description including matrices and other attributes */; 70 ; 71class RGeomNode : public RGeomNodeBase {; 72public:; 73 std::vector<float> matr; ///< matrix for the node, can have reduced number of elements; 74 double vol{0}; ///<! volume estimation; 75 int nfaces{0}; ///<! number of shape faces; 76 int idshift{-1}; ///<! used to jump over then scan all geom hierarchy; 77 bool useflag{false}; ///<! extra flag, used for selection; 78 float opacity{1.}; ///<! opacity of the color; 79 ; 80 RGeomNode(int _id = 0) : RGeomNodeBase(_id) {}; 81 ; 82 /** True when there is shape and it can be displayed */; 83 bool CanDisplay() const { return (vol > 0.) && (nfaces > 0); }; 84};; 85 ; 86/** \class RGeoItem; 87\ingroup rbrowser; 88\brief Representation of single item in the geometry browser; 89*/; 90 ; 91class RGeoItem : public Browsable::RItem {; 92 ; 93protected:; 94 // this is part for browser, visible for I/O; 95 int id{0}; ///< node id; 96 std::string color; ///< color; 97 std::string material; ///< material; 98 int vis{0}; ///< visibility of logical node; 99 int pvis{0}; ///< visibility of physical node; 100 bool top{false}; ///< indicates if node selected as top; 101 ; 102public:; 103 ; 104 /",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8hxx_source.html:2379,reduce,reduced,2379,doc/master/RGeomData_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8hxx_source.html,2,['reduce'],['reduced']
Energy Efficiency," 4780void TBranchElement::ResetAddress(); 4781{; 4782 for (Int_t i = 0; i < fNleaves; ++i) {; 4783 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);; 4784 //if (leaf) leaf->SetAddress(0);; 4785 leaf->SetAddress(nullptr);; 4786 }; 4787 ; 4788 // Note: We *must* do the sub-branches first, otherwise; 4789 // we may delete the object containing the sub-branches; 4790 // before giving them a chance to cleanup.; 4791 Int_t nbranches = fBranches.GetEntriesFast();; 4792 for (Int_t i = 0; i < nbranches; ++i) {; 4793 TBranch* br = (TBranch*) fBranches[i];; 4794 if (br) br->ResetAddress();; 4795 }; 4796 ; 4797 //; 4798 // SetAddress may have allocated an object.; 4799 //; 4800 ; 4801 ReleaseObject();; 4802 ; 4803 ResetBit(kAddressSet);; 4804 fAddress = nullptr;; 4805 fObject = nullptr;; 4806}; 4807 ; 4808////////////////////////////////////////////////////////////////////////////////; 4809/// Release ownership of any allocated objects.; 4810///; 4811/// Note: This interface was added so that clone trees could; 4812/// be told they do not own the allocated objects.; 4813 ; 4814void TBranchElement::ResetDeleteObject(); 4815{; 4816 ResetBit(kDeleteObject);; 4817 Int_t nb = fBranches.GetEntriesFast();; 4818 for (Int_t i = 0; i < nb; ++i) {; 4819 TBranch* br = (TBranch*) fBranches[i];; 4820 if (br->InheritsFrom(TBranchElement::Class())) {; 4821 ((TBranchElement*) br)->ResetDeleteObject();; 4822 }; 4823 }; 4824}; 4825 ; 4826////////////////////////////////////////////////////////////////////////////////; 4827/// \brief Reset offset and StreamerInfo information from this branch.; 4828/// \param[in] recurse When true call ResetInitInfo on all subbranches.; 4829///; 4830 ; 4831void TBranchElement::ResetInitInfo(bool recurse); 4832{; 4833 fInfo = nullptr;; 4834 fInit = false;; 4835 fInitOffsets = false;; 4836 fCurrentClass = nullptr;; 4837 delete fReadActionSequence;; 4838 fReadActionSequence = nullptr;; 4839 delete fFillActionSequence;; 4840 fFillActionSequence = nullptr;; 4841 ; 4842 if (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:178129,allocate,allocated,178129,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," 4961/// MyClass(); // Or a constructor with all its arguments defaulted.; 4962/// ~~~; 4963///; 4964/// When more than one pragma ioctortype is used, the first seen as priority; 4965/// For example with:; 4966/// ~~~ {.cpp}; 4967/// #pragma link C++ ioctortype UserClass1;; 4968/// #pragma link C++ ioctortype UserClass2;; 4969/// ~~~; 4970/// We look in the following order:; 4971/// ~~~ {.cpp}; 4972/// MyClass(UserClass1*);; 4973/// MyClass(UserClass2*);; 4974/// MyClass(TRootIOCtor*);; 4975/// MyClass(); // Or a constructor with all its arguments defaulted.; 4976/// ~~~; 4977 ; 4978void *TClass::New(ENewType defConstructor, Bool_t quiet) const; 4979{; 4980 auto obj = NewObject(defConstructor, quiet);; 4981 if (obj.GetPtr() && obj.GetAllocator()) {; 4982 // Register the object for special handling in the destructor.; 4983 RegisterAddressInRepository(""TClass::New"", obj.GetPtr(), this);; 4984 }; 4985 return obj.GetPtr();; 4986}; 4987 ; 4988// See TClass:New; 4989// returns a TClass::ObjectPtr which remembers if the object was allocated; 4990// via a TStreamerInfo.; 4991 ; 4992TClass::ObjectPtr TClass::NewObject(ENewType defConstructor, Bool_t quiet) const; 4993{; 4994 ObjectPtr p;; 4995 ; 4996 if (fNew) {; 4997 // We have the new operator wrapper function,; 4998 // so there is a dictionary and it was generated; 4999 // by rootcint, so there should be a default; 5000 // constructor we can call through the wrapper.; 5001 {; 5002 TClass__GetCallingNewRAII callingNew(defConstructor);; 5003 p = fNew(nullptr);; 5004 }; 5005 if (!p && !quiet) {; 5006 //Error(""New"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5007 Error(""New"", ""cannot create object of class %s"", GetName());; 5008 }; 5009 } else if (HasInterpreterInfo()) {; 5010 // We have the dictionary but do not have the; 5011 // constructor wrapper, so the dictionary was; 5012 // not generated by rootcint. Let's try to; 5013 // create the object by having the interpreter; 5014 // call the new ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:190167,allocate,allocated,190167,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," 5.8, 5.9, respectively. The achieved chi-square was 0.76732. Original spectrum. Fitted function. We have implemented the fitting function with matrix inversion based on Stiefel-Hestens method of the solution of the system of linear equations also for 2-dimensional data. The form of the function is as follows; char* Fit2Stiefel(float **source,; TSpectrumTwoDimFit* p,; int sizex,; int sizey);; This function fits the source spectrum. The calling program should fill in input parameters of the two_dim_fit structure The fitted parameters are written into structure pointed by two_dim_fit structure pointer and fitted data are written back into source spectrum.; Function parameters:. source pointer to the matrix of source spectrum; p pointer to the two_dim_fit structure pointer, see manual; sizex length x of source spectrum; sizey length y of source spectrum. The structure two_dim_fit is the same as in awmi function. The parameters power, fit_taylor are not applicable for this function; The results for small number of fitted parameters are the same as with awmi function. However it converges faster. The example for data given in Figure 5.6 (38 parameters) is presented in the following table:. # of iterations; Chi awmi; Chi-Stiefel. 1; 24.989; 10.415. 5; 20.546; 1.0553. 10; 6.256; 0.84383. 50; 1.0985; 0.64297. 100; 0.657; 1 0.64297. 500; 0.651; 94 0.64297. Again Stiefel-Hestens method converges faster. However its calculation is for this number of parameters approximately 3 times longer. For larger number of parameters the time needed to calculate the inversion grows with the cube of the number of fitted parameters. For example the fit of large number of parameters (2068) for data in Figure 5.8 using awmi algorithm lasted about 12 hours (using 450 MHz PC). The calculation using matrix inversion method is not realizable in reasonable time.; 6 TRANSFORMS; 6.1 1-DIMENSIONAL SPECTRA; Orthogonal transforms can be successfully used for the processing of nuclear spectra . They can b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:53232,power,power,53232,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,2,['power'],['power']
Energy Efficiency," 5028/// MyClass(); // Or a constructor with all its arguments defaulted.; 5029/// ~~~; 5030///; 5031/// When more than one pragma ioctortype is used, the first seen as priority; 5032/// For example with:; 5033/// ~~~ {.cpp}; 5034/// #pragma link C++ ioctortype UserClass1;; 5035/// #pragma link C++ ioctortype UserClass2;; 5036/// ~~~; 5037/// We look in the following order:; 5038/// ~~~ {.cpp}; 5039/// MyClass(UserClass1*);; 5040/// MyClass(UserClass2*);; 5041/// MyClass(TRootIOCtor*);; 5042/// MyClass(); // Or a constructor with all its arguments defaulted.; 5043/// ~~~; 5044 ; 5045void *TClass::New(ENewType defConstructor, Bool_t quiet) const; 5046{; 5047 auto obj = NewObject(defConstructor, quiet);; 5048 if (obj.GetPtr() && obj.GetAllocator()) {; 5049 // Register the object for special handling in the destructor.; 5050 RegisterAddressInRepository(""TClass::New"", obj.GetPtr(), this);; 5051 }; 5052 return obj.GetPtr();; 5053}; 5054 ; 5055// See TClass:New; 5056// returns a TClass::ObjectPtr which remembers if the object was allocated; 5057// via a TStreamerInfo.; 5058 ; 5059TClass::ObjectPtr TClass::NewObject(ENewType defConstructor, Bool_t quiet) const; 5060{; 5061 ObjectPtr p;; 5062 ; 5063 if (fNew) {; 5064 // We have the new operator wrapper function,; 5065 // so there is a dictionary and it was generated; 5066 // by rootcint, so there should be a default; 5067 // constructor we can call through the wrapper.; 5068 {; 5069 TClass__GetCallingNewRAII callingNew(defConstructor);; 5070 p = fNew(nullptr);; 5071 }; 5072 if (!p && !quiet) {; 5073 //Error(""New"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5074 Error(""New"", ""cannot create object of class %s"", GetName());; 5075 }; 5076 } else if (HasInterpreterInfo()) {; 5077 // We have the dictionary but do not have the; 5078 // constructor wrapper, so the dictionary was; 5079 // not generated by rootcint. Let's try to; 5080 // create the object by having the interpreter; 5081 // call the new ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:192918,allocate,allocated,192918,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," 503,; 14061 ""%s"",; 14062 ""Error: SSL forward not configured properly"");; 14063 mg_cry_internal(conn,; 14064 ""%s"",; 14065 ""Can not redirect to SSL, no SSL port available"");; 14066 }; 14067 return;; 14068 }; 14069 uri_len = (int)strlen(ri->local_uri);; 14070 ; 14071 /* 1.3. decode url (if config says so) */; 14072 if (should_decode_url(conn)) {; 14073 mg_url_decode(; 14074 ri->local_uri, uri_len, (char *)ri->local_uri, uri_len + 1, 0);; 14075 }; 14076 ; 14077 /* URL decode the query-string only if explicity set in the configuration */; 14078 if (conn->request_info.query_string) {; 14079 if (should_decode_query_string(conn)) {; 14080 url_decode_in_place((char *)conn->request_info.query_string);; 14081 }; 14082 }; 14083 ; 14084 /* 1.4. clean URIs, so a path like allowed_dir/../forbidden_file is not; 14085 * possible. The fact that we cleaned the URI is stored in that the; 14086 * pointer to ri->local_ur and ri->local_uri_raw are now different.; 14087 * ri->local_uri_raw still points to memory allocated in; 14088 * worker_thread_run(). ri->local_uri is private to the request so we; 14089 * don't have to use preallocated memory here. */; 14090 tmp = mg_strdup(ri->local_uri_raw);; 14091 if (!tmp) {; 14092 /* Out of memory. We cannot do anything reasonable here. */; 14093 return;; 14094 }; 14095 remove_dot_segments(tmp);; 14096 ri->local_uri = tmp;; 14097 ; 14098 /* step 1. completed, the url is known now */; 14099 DEBUG_TRACE(""URL: %s"", ri->local_uri);; 14100 ; 14101 /* 2. if this ip has limited speed, set it for this connection */; 14102 conn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],; 14103 &conn->client.rsa,; 14104 ri->local_uri);; 14105 ; 14106 /* 3. call a ""handle everything"" callback, if registered */; 14107 if (conn->phys_ctx->callbacks.begin_request != NULL) {; 14108 /* Note that since V1.7 the ""begin_request"" function is called; 14109 * before an authorization check. If an authorization check is; 14110 * required, use a request_handler instead. */; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:413069,allocate,allocated,413069,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['allocate'],['allocated']
Energy Efficiency," 503,; 14062 ""%s"",; 14063 ""Error: SSL forward not configured properly"");; 14064 mg_cry_internal(conn,; 14065 ""%s"",; 14066 ""Can not redirect to SSL, no SSL port available"");; 14067 }; 14068 return;; 14069 }; 14070 uri_len = (int)strlen(ri->local_uri);; 14071 ; 14072 /* 1.3. decode url (if config says so) */; 14073 if (should_decode_url(conn)) {; 14074 mg_url_decode(; 14075 ri->local_uri, uri_len, (char *)ri->local_uri, uri_len + 1, 0);; 14076 }; 14077 ; 14078 /* URL decode the query-string only if explicity set in the configuration */; 14079 if (conn->request_info.query_string) {; 14080 if (should_decode_query_string(conn)) {; 14081 url_decode_in_place((char *)conn->request_info.query_string);; 14082 }; 14083 }; 14084 ; 14085 /* 1.4. clean URIs, so a path like allowed_dir/../forbidden_file is not; 14086 * possible. The fact that we cleaned the URI is stored in that the; 14087 * pointer to ri->local_ur and ri->local_uri_raw are now different.; 14088 * ri->local_uri_raw still points to memory allocated in; 14089 * worker_thread_run(). ri->local_uri is private to the request so we; 14090 * don't have to use preallocated memory here. */; 14091 tmp = mg_strdup(ri->local_uri_raw);; 14092 if (!tmp) {; 14093 /* Out of memory. We cannot do anything reasonable here. */; 14094 return;; 14095 }; 14096 remove_dot_segments(tmp);; 14097 ri->local_uri = tmp;; 14098 ; 14099 /* step 1. completed, the url is known now */; 14100 DEBUG_TRACE(""URL: %s"", ri->local_uri);; 14101 ; 14102 /* 2. if this ip has limited speed, set it for this connection */; 14103 conn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],; 14104 &conn->client.rsa,; 14105 ri->local_uri);; 14106 ; 14107 /* 3. call a ""handle everything"" callback, if registered */; 14108 if (conn->phys_ctx->callbacks.begin_request != NULL) {; 14109 /* Note that since V1.7 the ""begin_request"" function is called; 14110 * before an authorization check. If an authorization check is; 14111 * required, use a request_handler instead. */; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:413102,allocate,allocated,413102,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['allocate'],['allocated']
Energy Efficiency," 5547 // not generated by rootcint. Let's try to; 5548 // delete the array by having the interpreter; 5549 // call the array delete operator, hopefully; 5550 // the class library is loaded and there will be; 5551 // a destructor we can call.; 5552 gCling->ClassInfo_DeleteArray(GetClassInfo(),ary, dtorOnly);; 5553 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5554 // There is no dictionary at all, so this is an emulated; 5555 // class; however we do have the services of a collection proxy,; 5556 // so this is an emulated STL class.; 5557 GetCollectionProxy()->DeleteArray(ary, dtorOnly);; 5558 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5559 // There is no dictionary at all and we do not have; 5560 // the services of a collection proxy available, so; 5561 // use the streamer info to approximate calling the; 5562 // array destructor.; 5563 ; 5564 Bool_t inRepo = kTRUE;; 5565 Bool_t currentVersion = kFALSE;; 5566 ; 5567 // Was this array object allocated through TClass?; 5568 Version_t objVer = -1;; 5569 {; 5570 R__LOCKGUARD2(fOVRMutex);; 5571 RepoCont_t::iterator iter = fObjectVersionRepository.find(p);; 5572 if (iter == fObjectVersionRepository.end()) {; 5573 // No, it wasn't, we cannot know what to do.; 5574 //Error(""DeleteArray"", ""Attempt to delete unregistered array object, element type '%s', at address %p!"", GetName(), p);; 5575 inRepo = kFALSE;; 5576 } else {; 5577 for (; (iter != fObjectVersionRepository.end()) && (iter->first == p); ++iter) {; 5578 objVer = iter->second;; 5579 if (objVer == fClassVersion) {; 5580 currentVersion = kTRUE;; 5581 break;; 5582 }; 5583 }; 5584 }; 5585 }; 5586 ; 5587 if (!inRepo || currentVersion) {; 5588 // The object was allocated using code for the same class version; 5589 // as is loaded now. We may proceed without worry.; 5590 TVirtualStreamerInfo* si = GetStreamerInfo();; 5591 if (si) {; 5592 si->DeleteArray(ary, dtorOnly);; 5593 } else {; 5594 Error(""DeleteArray"", ""No streamer info available for class '%",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:213050,allocate,allocated,213050,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," 5614 // not generated by rootcint. Let's try to; 5615 // delete the array by having the interpreter; 5616 // call the array delete operator, hopefully; 5617 // the class library is loaded and there will be; 5618 // a destructor we can call.; 5619 gCling->ClassInfo_DeleteArray(GetClassInfo(),ary, dtorOnly);; 5620 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5621 // There is no dictionary at all, so this is an emulated; 5622 // class; however we do have the services of a collection proxy,; 5623 // so this is an emulated STL class.; 5624 GetCollectionProxy()->DeleteArray(ary, dtorOnly);; 5625 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5626 // There is no dictionary at all and we do not have; 5627 // the services of a collection proxy available, so; 5628 // use the streamer info to approximate calling the; 5629 // array destructor.; 5630 ; 5631 Bool_t inRepo = kTRUE;; 5632 Bool_t currentVersion = kFALSE;; 5633 ; 5634 // Was this array object allocated through TClass?; 5635 Version_t objVer = -1;; 5636 {; 5637 R__LOCKGUARD2(fOVRMutex);; 5638 RepoCont_t::iterator iter = fObjectVersionRepository.find(p);; 5639 if (iter == fObjectVersionRepository.end()) {; 5640 // No, it wasn't, we cannot know what to do.; 5641 //Error(""DeleteArray"", ""Attempt to delete unregistered array object, element type '%s', at address %p!"", GetName(), p);; 5642 inRepo = kFALSE;; 5643 } else {; 5644 for (; (iter != fObjectVersionRepository.end()) && (iter->first == p); ++iter) {; 5645 objVer = iter->second;; 5646 if (objVer == fClassVersion) {; 5647 currentVersion = kTRUE;; 5648 break;; 5649 }; 5650 }; 5651 }; 5652 }; 5653 ; 5654 if (!inRepo || currentVersion) {; 5655 // The object was allocated using code for the same class version; 5656 // as is loaded now. We may proceed without worry.; 5657 TVirtualStreamerInfo* si = GetStreamerInfo();; 5658 if (si) {; 5659 si->DeleteArray(ary, dtorOnly);; 5660 } else {; 5661 Error(""DeleteArray"", ""No streamer info available for class '%",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:215801,allocate,allocated,215801,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," 57./255., 59./255., 75./255., 106./255., 142./255., 173./255.};; 3269 Double_t blue[9] = { 78./255., 55./255., 46./255., 40./255., 39./255., 39./255., 40./255., 41./255., 47./255.};; 3270 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3271 }; 3272 break;; 3273 ; 3274 // Fruit Punch; 3275 case 80:; 3276 {; 3277 Double_t red[9] = { 243./255., 222./255., 201./255., 185./255., 165./255., 158./255., 166./255., 187./255., 219./255.};; 3278 Double_t green[9] = { 94./255., 108./255., 132./255., 135./255., 125./255., 96./255., 68./255., 51./255., 61./255.};; 3279 Double_t blue[9] = { 7./255., 9./255., 12./255., 19./255., 45./255., 89./255., 118./255., 146./255., 118./255.};; 3280 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3281 }; 3282 break;; 3283 ; 3284 // Fuchsia; 3285 case 81:; 3286 {; 3287 Double_t red[9] = { 19./255., 44./255., 74./255., 105./255., 137./255., 166./255., 194./255., 206./255., 220./255.};; 3288 Double_t green[9] = { 19./255., 28./255., 40./255., 55./255., 82./255., 110./255., 159./255., 181./255., 220./255.};; 3289 Double_t blue[9] = { 19./255., 42./255., 68./255., 96./255., 129./255., 157./255., 188./255., 203./255., 220./255.};; 3290 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3291 }; 3292 break;; 3293 ; 3294 // Grey Yellow; 3295 case 82:; 3296 {; 3297 Double_t red[9] = { 33./255., 44./255., 70./255., 99./255., 140./255., 165./255., 199./255., 211./255., 216./255.};; 3298 Double_t green[9] = { 38./255., 50./255., 76./255., 105./255., 140./255., 165./255., 191./255., 189./255., 167./255.};; 3299 Double_t blue[9] = { 55./255., 67./255., 97./255., 124./255., 140./255., 166./255., 163./255., 129./255., 52./255.};; 3300 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3301 }; 3302 break;; 3303 ; 3304 // Green Brown Terrain; 3305 case 83:; 3306 {; 3307 Double_t red[9] = { 0./255., 33./255., 73./255., 124./255., 136./255",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:127306,green,green,127306,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency," 6235 1147 87.5 0.333 5 5.095 44.16 0 0 0 2; 10 5218 1018 87.5 0.333 12 4.983 40.99 0 2 0 0; 11 4193 1025 87.5 0.667 53 5.229 37.5 0 0 4 0; 12 3299 893.8 88.8 0.333 6 -4.058 54.27 0 0 1 1; 13 2458 841.2 88.8 0.333 7 -4.155 48.73 0 1 0 1; 14 1933 524.7 88.8 0.333 13 -3.291 48.45 0 1 1 0; 15 1675 258.1 88.8 0.5 19 4.211 14.56 1 0 0 2; 16 1334 340.6 88.8 0.5 26 -4.731 15.22 1 1 0 1; 17 1079 255.5 88.8 0.5 33 3.953 16.35 1 0 2 0; 18 788.2 290.4 88.8 0.5 34 4.687 13.22 1 2 0 0; 19 709.2 78.94 89.4 0.5 21 2.23 15.88 0 1 1 1; 20 473.4 235.8 89.4 0.5 23 -3.543 18.78 1 0 1 1; 21 235.4 238 89.4 0.5 28 -3.976 15.06 1 1 1 0; Results of Parameterisation:; ----------------------------; Total reduction of square residuals 5.063e+05; Relative precision obtained: 0.01185; Error obtained: 235.4; Multiple correlation coefficient: 0.9995; Reduced Chi square over sample: 0.4975; Maximum residual value: 3.243; Minimum residual value: -2.59; Estimated root mean square: 0.6862; Maximum powers used: 1 2 4 2 ; Function codes of candidate functions.; 1: considered, 2: too little contribution, 3: accepted.; 3333333333 1133311113 1313113131 1113311111 1111111111 1113111111; 1111111111 1111111111 1111111111 1111111111 1111111111 1111111111; 111111; Loop over candidates stopped because max allowed studies reached; ; Coefficients:; -------------; # Value Error Powers; ---------------------------------------; 0 -4.371 0.08798 0 0 0 0; 1 43.15 0.1601 1 0 0 0; 2 13.43 0.08032 0 0 0 1; 3 13.46 0.07805 0 0 1 0; 4 13.4 0.08054 0 1 0 0; 5 13.33 0.1423 1 1 0 0; 6 13.3 0.1367 1 0 0 1; 7 13.35 0.1331 1 0 1 0; 8 4.497 0.1511 0 0 0 2; 9 4.639 0.1585 0 2 0 0; 10 4.89 0.164 0 0 4 0; 11 -3.7 0.1364 0 0 1 1; 12 -3.986 0.1438 0 1 0 1; 13 -3.862 0.1458 0 1 1 0; 14 4.361 0.2614 1 0 0 2; 15 -4.026 0.2555 1 1 0 1; 16 4.57 0.2477 1 0 2 0; 17 4.698 0.2729 1 2 0 0; 18 2.838 0.2525 0 1 1 1; 19 -3.489 0.2292 1 0 1 1; 20 -3.976 0.2566 1 1 1 0; ; Results of Fit:; ---------------; Test sample size: 2100; Multiple correlation c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/multidimfit_8C.html:2448,power,powers,2448,doc/master/multidimfit_8C.html,https://root.cern,https://root.cern/doc/master/multidimfit_8C.html,1,['power'],['powers']
Energy Efficiency," 7112 UInt_t newBsize = UInt_t(bsize);; 7113 if (pass) { // only on the second pass so that it doesn't interfere with scaling; 7114 // If there is an entry offset, it will be stored in the same buffer as the object data; hence,; 7115 // we must bump up the size of the branch to account for this extra footprint.; 7116 // If fAutoFlush is not set yet, let's assume that it is 'in the process of being set' to; 7117 // the value of GetEntries().; 7118 Long64_t clusterSize = (fAutoFlush > 0) ? fAutoFlush : branch->GetEntries();; 7119 if (branch->GetEntryOffsetLen()) {; 7120 newBsize = newBsize + (clusterSize * sizeof(Int_t) * 2);; 7121 }; 7122 // We used ATLAS fully-split xAOD for testing, which is a rather unbalanced TTree, 10K branches,; 7123 // with 8K having baskets smaller than 512 bytes. To achieve good I/O performance ATLAS uses auto-flush 100,; 7124 // resulting in the smallest baskets being ~300-400 bytes, so this change increases their memory by about 8k*150B =~ 1MB,; 7125 // at the same time it significantly reduces the number of total baskets because it ensures that all 100 entries can be; 7126 // stored in a single basket (the old optimization tended to make baskets too small). In a toy example with fixed sized; 7127 // structures we found a factor of 2 fewer baskets needed in the new scheme.; 7128 // rounds up, increases basket size to ensure all entries fit into single basket as intended; 7129 newBsize = newBsize - newBsize%512 + 512;; 7130 }; 7131 if (newBsize < sizeOfOneEntry) newBsize = sizeOfOneEntry;; 7132 if (newBsize < bmin) newBsize = bmin;; 7133 if (newBsize > 10000000) newBsize = bmax;; 7134 if (pass) {; 7135 if (pDebug) Info(""OptimizeBaskets"", ""Changing buffer size from %6d to %6d bytes for %s\n"",oldBsize,newBsize,branch->GetName());; 7136 branch->SetBasketSize(newBsize);; 7137 }; 7138 newMemsize += newBsize;; 7139 // For this number to be somewhat accurate when newBsize is 'low'; 7140 // we do not include any space for meta data in the requested ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:279365,reduce,reduces,279365,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['reduce'],['reduces']
Energy Efficiency," 754-2008 16-bit) float fields. This can be enabled through RField<float>::SetHalfPrecision(). On reading, values of such fields are represented as regular, 32-bit floats.; A new RNTupleInspector utility class has been added, to provide information about the on-disk metadata of an RNTuple.; A new RNTupleParallelWriter class has been added, providing (initial) support for parallel writing of RNTuples.; A new static method RFieldBase::Check() has been added, which produces a support status report of a type with regards to RNTuple I/O.; A new internal RNTupleMerger class has been added, enabling the merging of different page sources into one page sink. This also means that RNTuples can be merged through hadd.; Zero-copy bulk reading has been added, with extra optimizations for ROOT::RVec fields.; It is now possible to use the RNTupleView with an external address with type erasure, e.g.:; std::shared_ptr<void> data{new float()};; auto view = reader->GetView(""pt"", data);; This enables use cases such as reading one specific entry of one specific field into a previously allocated memory location.; Further integration with RDataFrame: it is now possible to create RDataFrame for chains of RNTuples. This addition also comes with improvements to the multi-threaded work scheduling.; Many additional bug fixes and improvements. Please, report any issues regarding the above mentioned features should you encounter them. RNTuple is still in pre-production. The on-disk format is scheduled to be finalized by the end of 2024. Thus, we appreciate feedback and suggestions for improvement.; Histogram Libraries. Implement the FLT_MAX mechanism for THStack::GetMaximum() and THStack::GetMiniumum().; Print a warning when the range given to TAxis::SetRange is invalid.; Fix projection name in TH3 as requested here. Parallelism. The ROOT::Experimental::TFuture template has been removed. RooFit Libraries; New CPU likelihood evaluation backend by default; The new vectorizing CPU evaluation backend ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:7179,allocate,allocated,7179,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['allocate'],['allocated']
Energy Efficiency," 85./255., 101./255., 138./255., 163./255., 122./255., 51./255., 39./255.};; 3249 Double_t blue[9] = { 121./255., 101./255., 58./255., 44./255., 47./255., 55./255., 57./255., 44./255., 43./255.};; 3250 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3251 }; 3252 break;; 3253 ; 3254 // Dark Terrain; 3255 case 78:; 3256 {; 3257 Double_t red[9] = { 0./255., 41./255., 62./255., 79./255., 90./255., 87./255., 99./255., 140./255., 228./255.};; 3258 Double_t green[9] = { 0./255., 57./255., 81./255., 93./255., 85./255., 70./255., 71./255., 125./255., 228./255.};; 3259 Double_t blue[9] = { 95./255., 91./255., 91./255., 82./255., 60./255., 43./255., 44./255., 112./255., 228./255.};; 3260 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3261 }; 3262 break;; 3263 ; 3264 // Fall; 3265 case 79:; 3266 {; 3267 Double_t red[9] = { 49./255., 59./255., 72./255., 88./255., 114./255., 141./255., 176./255., 205./255., 222./255.};; 3268 Double_t green[9] = { 78./255., 72./255., 66./255., 57./255., 59./255., 75./255., 106./255., 142./255., 173./255.};; 3269 Double_t blue[9] = { 78./255., 55./255., 46./255., 40./255., 39./255., 39./255., 40./255., 41./255., 47./255.};; 3270 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3271 }; 3272 break;; 3273 ; 3274 // Fruit Punch; 3275 case 80:; 3276 {; 3277 Double_t red[9] = { 243./255., 222./255., 201./255., 185./255., 165./255., 158./255., 166./255., 187./255., 219./255.};; 3278 Double_t green[9] = { 94./255., 108./255., 132./255., 135./255., 125./255., 96./255., 68./255., 51./255., 61./255.};; 3279 Double_t blue[9] = { 7./255., 9./255., 12./255., 19./255., 45./255., 89./255., 118./255., 146./255., 118./255.};; 3280 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3281 }; 3282 break;; 3283 ; 3284 // Fuchsia; 3285 case 81:; 3286 {; 3287 Double_t red[9] = { 19./255., 44./255., 74./255., 105./255., 137./255., 166./255., 194./",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:126263,green,green,126263,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency," 88 return std::numeric_limits<double>::quiet_NaN();; 89 }; 90 double abs_alpha = std::abs(alpha);; 91 double C = n/abs_alpha * 1./(n-1.) * std::exp(-alpha*alpha/2.);; 92 double D = std::sqrt(M_PI/2.)*(1.+ROOT::Math::erf(abs_alpha/std::sqrt(2.)));; 93 double totIntegral = sigma*(C+D);; 94 ; 95 double integral = crystalball_integral(x,alpha,n,sigma,mean); ; 96 return (alpha > 0) ? integral/totIntegral : 1. - (integral/totIntegral); ; 97 }; 98 double crystalball_integral(double x, double alpha, double n, double sigma, double mean); 99 {; 100 // compute the integral of the crystal ball function (ROOT::Math::crystalball_function); 101 // If alpha > 0 the integral is the right tail integral.; 102 // If alpha < 0 is the left tail integrals which are always finite for finite x. ; 103 // parameters:; 104 // alpha : is non equal to zero, define the # of sigma from which it becomes a power-law function (from mean-alpha*sigma); 105 // n > 1 : is integrer, is the power of the low tail; 106 // add a value xmin for cases when n <=1 the integral diverges ; 107 if (sigma == 0) return 0;; 108 if (alpha==0); 109 {; 110 MATH_ERROR_MSG(""crystalball_integral"",""CrystalBall function not defined at alpha=0"");; 111 return 0.;; 112 }; 113 bool useLog = (n == 1.0); ; 114 if (n<=0) MATH_WARN_MSG(""crystalball_integral"",""No physical meaning when n<=0"");; 115 ; 116 double z = (x-mean)/sigma;; 117 if (alpha < 0 ) z = -z;; 118 ; 119 double abs_alpha = std::abs(alpha);; 120 ; 121 //double D = *(1.+ROOT::Math::erf(abs_alpha/std::sqrt(2.)));; 122 //double N = 1./(sigma*(C+D));; 123 double intgaus = 0.;; 124 double intpow = 0.;; 125 ; 126 const double sqrtpiover2 = std::sqrt(M_PI/2.);; 127 const double sqrt2pi = std::sqrt( 2.*M_PI); ; 128 const double oneoversqrt2 = 1./sqrt(2.);; 129 if (z <= -abs_alpha); 130 {; 131 double A = std::pow(n/abs_alpha,n) * std::exp(-0.5 * alpha*alpha);; 132 double B = n/abs_alpha - abs_alpha;; 133 ; 134 if (!useLog) {; 135 double C = (n/abs_alpha) * (1./(n-1)) * std::exp(-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ProbFuncMathCore_8cxx_source.html:3402,power,power-law,3402,doc/master/ProbFuncMathCore_8cxx_source.html,https://root.cern,https://root.cern/doc/master/ProbFuncMathCore_8cxx_source.html,2,['power'],"['power', 'power-law']"
Energy Efficiency," 93./255., 125./255., 162./255., 194./255., 241./255.};; 3019 Double_t blue[9] = { 97./255., 100./255., 99./255., 99./255., 93./255., 68./255., 44./255., 26./255., 74./255.};; 3020 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3021 }; 3022 break;; 3023 ; 3024 // Rain Bow; 3025 case 55:; 3026 {; 3027 Double_t red[9] = { 0./255., 5./255., 15./255., 35./255., 102./255., 196./255., 208./255., 199./255., 110./255.};; 3028 Double_t green[9] = { 0./255., 48./255., 124./255., 192./255., 206./255., 226./255., 97./255., 16./255., 0./255.};; 3029 Double_t blue[9] = { 99./255., 142./255., 198./255., 201./255., 90./255., 22./255., 13./255., 8./255., 2./255.};; 3030 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3031 }; 3032 break;; 3033 ; 3034 // Inverted Dark Body Radiator; 3035 case 56:; 3036 {; 3037 Double_t red[9] = { 242./255., 234./255., 237./255., 230./255., 212./255., 156./255., 99./255., 45./255., 0./255.};; 3038 Double_t green[9] = { 243./255., 238./255., 238./255., 168./255., 101./255., 45./255., 0./255., 0./255., 0./255.};; 3039 Double_t blue[9] = { 230./255., 95./255., 11./255., 8./255., 9./255., 3./255., 1./255., 1./255., 0./255.};; 3040 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3041 }; 3042 break;; 3043 ; 3044 // Bird; 3045 case 57:; 3046 {; 3047 Double_t red[9] = { 0.2082, 0.0592, 0.0780, 0.0232, 0.1802, 0.5301, 0.8186, 0.9956, 0.9764};; 3048 Double_t green[9] = { 0.1664, 0.3599, 0.5041, 0.6419, 0.7178, 0.7492, 0.7328, 0.7862, 0.9832};; 3049 Double_t blue[9] = { 0.5293, 0.8684, 0.8385, 0.7914, 0.6425, 0.4662, 0.3499, 0.1968, 0.0539};; 3050 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3051 }; 3052 break;; 3053 ; 3054 // Cubehelix; 3055 case 58:; 3056 {; 3057 Double_t red[9] = { 0.0000, 0.0956, 0.0098, 0.2124, 0.6905, 0.9242, 0.7914, 0.7596, 1.0000};; 3058 Double_t green[9] = { 0.0000, 0.1147, 0.3616, 0.5041, 0.4577, 0.4691,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:114387,green,green,114387,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency," : TRangeCast{col != nullptr ? *col : ROOT::Internal::EmptyCollection()} {}; 317};; 318 ; 319/// @brief TRangeStaticCast is an adapter class that allows the typed iteration; 320/// through a TCollection. This requires the collection to contain elements; 321/// of the type requested (or a derived class). Any deviation from this expectation; 322/// will only be caught/reported by an assert in debug builds.; 323///; 324/// This is best used with a TClonesArray, for other cases prefered TRangeDynCast.; 325///; 326/// The typical use is:; 327/// ```{.cpp}; 328/// for(auto bcl : TRangeStaticCast<TBaseClass>( *tbaseClassClonesArrayPtr )) {; 329/// ... use bcl as a TBaseClass*; 330/// }; 331/// for(auto bcl : TRangeStaticCast<TBaseClass>( tbaseClassClonesArrayPtr )) {; 332/// ... use bcl as a TBaseClass*; 333/// }; 334/// ```; 335/// \tparam T The new type to convert to.; 336template <typename T>; 337using TRangeStaticCast = TRangeCast<T, false>;; 338 ; 339} // namespace Detail; 340} // namespace ROOT; 341 ; 342/// @brief TRangeDynCast is an adapter class that allows the typed iteration; 343/// through a TCollection.; 344///; 345/// The typical use is:; 346/// ```{.cpp}; 347/// for(auto bcl : TRangeDynCast<TBaseClass>( *cl->GetListOfBases() )) {; 348/// if (!bcl) continue;; 349/// ... use bcl as a TBaseClass*; 350/// }; 351/// for(auto bcl : TRangeDynCast<TBaseClass>( cl->GetListOfBases() )) {; 352/// if (!bcl) continue;; 353/// ... use bcl as a TBaseClass*; 354/// }; 355/// ```; 356/// \tparam T The new type to convert to.; 357template <typename T>; 358using TRangeDynCast = ROOT::Detail::TRangeCast<T, true>;; 359 ; 360#define R__COLL_COND_MUTEX(mutex) this->IsUsingRWLock() ? mutex : nullptr; 361 ; 362#define R__COLLECTION_READ_LOCKGUARD(mutex) ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex)); 363#define R__COLLECTION_READ_LOCKGUARD_NAMED(name,mutex) ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex)); 364 ; 365#define R__C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8h_source.html:13374,adapt,adapter,13374,doc/master/TCollection_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html,1,['adapt'],['adapter']
Energy Efficiency," : change the Marker attributes (color, appearance, thickness) see TAttMarkerEditor; This Tab has two different layouts. One is for a histogram which is not drawn from an ntuple. The other one is available for a histogram which is drawn from an ntuple. In this case the rebin algorithm can create a rebinned histogram from the original data i.e. the ntuple. To see te differences do: TFile f(""hsimple.root""); hpx->Draw(""BAR1""); // non ntuple histogram ntuple->Draw(""px""); // ntuple histogram Non ntuple histogram: 'Rebin': with the Slider the number of bins (shown in the field below the Slider) can be changed to any number which divides the number of bins of the original histogram. Pushing 'Apply' will delete the origin histogram and replace it by the rebinned one on the screen Pushing 'Ignore' the origin histogram will be restored Histogram drawn from an ntuple: 'Rebin' with the slider the number of bins can be enlarged by a factor of 2,3,4,5 (moving to the right) or reduced by a factor of 1/2, 1/3, 1/4, 1/5 'BinOffset': with the BinOffset slider the origin of the histogram can be changed within one binwidth Using this slider the effect of binning the data into bins can be made visible => statistical fluctuations 'Axis Range': with the DoubleSlider it is possible to zoom into the specified axis range. It is also possible to set the upper and lower limit in fields below the slider 'Delayed drawing': all the Binning sliders can set to delay draw mode. Then the changes on the histogram are only updated, when the Slider is released. This should be activated if the redrawing of the histogram is too time consuming. // ; Definition at line 33 of file TH1Editor.h. Public Member Functions;  TH1Editor (const TGWindow *p=nullptr, Int_t width=140, Int_t height=30, UInt_t options=kChildFrame, Pixel_t back=GetDefaultFrameBackground());  Constructor of histogram attribute GUI. ;  ;  ~TH1Editor () override;  Destructor of TH1 editor. ;  ; Bool_t AcceptModel (TObject *model) override;  Ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1Editor.html:3249,reduce,reduced,3249,doc/master/classTH1Editor.html,https://root.cern,https://root.cern/doc/master/classTH1Editor.html,1,['reduce'],['reduced']
Energy Efficiency," ; (; const char * ; name[], . Bool_t ; allocate = kTRUE . ). overridevirtual . Get the bin index for the n dimensional tuple addressed by ""name"", allocate one if it doesn't exist yet and ""allocate"" is true. ; Implements THnBase.; Definition at line 718 of file THnSparse.cxx. ◆ GetBin() [3/6]. Long64_t THnSparse::GetBin ; (; const Double_t * ; x); const. inlineoverridevirtual . Implements THnBase.; Definition at line 97 of file THnSparse.h. ◆ GetBin() [4/6]. Long64_t THnSparse::GetBin ; (; const Double_t * ; x, . Bool_t ; allocate = kTRUE . ). overridevirtual . Get the bin index for the n dimensional tuple x, allocate one if it doesn't exist yet and ""allocate"" is true. ; Implements THnBase.; Definition at line 702 of file THnSparse.cxx. ◆ GetBin() [5/6]. Long64_t THnSparse::GetBin ; (; const Int_t * ; idx); const. inlineoverridevirtual . Implements THnBase.; Definition at line 96 of file THnSparse.h. ◆ GetBin() [6/6]. Long64_t THnSparse::GetBin ; (; const Int_t * ; idx, . Bool_t ; allocate = kTRUE . ). overridevirtual . Get the bin index for the n dimensional coordinates coord, allocate one if it doesn't exist yet and ""allocate"" is true. ; Implements THnBase.; Definition at line 733 of file THnSparse.cxx. ◆ GetBinContent() [1/2]. Double_t THnSparse::GetBinContent ; (; const Int_t * ; idx); const. inline . Forwards to THnBase::GetBinContent() overload. ; Non-virtual, CINT-compatible replacement of a using declaration. ; Definition at line 121 of file THnSparse.h. ◆ GetBinContent() [2/2]. Double_t THnSparse::GetBinContent ; (; Long64_t ; idx, . Int_t * ; coord = nullptr . ); const. overridevirtual . Return the content of the filled bin number ""idx"". ; If coord is non-null, it will contain the bin's coordinates for each axis that correspond to the bin. ; Implements THnBase.; Definition at line 744 of file THnSparse.cxx. ◆ GetBinError2(). Double_t THnSparse::GetBinError2 ; (; Long64_t ; linidx); const. overridevirtual . Get square of the error of bin addressed by linidx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparse.html:34199,allocate,allocate,34199,doc/master/classTHnSparse.html,https://root.cern,https://root.cern/doc/master/classTHnSparse.html,1,['allocate'],['allocate']
Energy Efficiency," ; // Power law example; // -----------------; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects because often, a binned fit is affected by both problems.; //; // The issue is num",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:5087,power,powerlaw,5087,doc/master/rf614__binned__fit__problems_8C.html,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html,1,['power'],['powerlaw']
Energy Efficiency," ; 1166////////////////////////////////////////////////////////////////////////////////; 1167///Computes sample quantiles, corresponding to the given probabilities; 1168///; 1169/// \param[in] x the data sample; 1170/// \param[in] n its size; 1171/// \param[out] quantiles computed quantiles are returned in there; 1172/// \param[in] prob probabilities where to compute quantiles; 1173/// \param[in] nprob size of prob array; 1174/// \param[in] isSorted is the input array x sorted ?; 1175/// \param[in] index parameter index; 1176/// \param[in] type method to compute (from 1 to 9).; 1177///; 1178/// #### NOTE:; 1179/// When the input is not sorted, an array of integers of size n needs; 1180/// to be allocated. It can be passed by the user in parameter index,; 1181/// or, if not passed, it will be allocated inside the function; 1182///; 1183/// ### Following types are provided:; 1184/// - Discontinuous:; 1185/// - type=1 - inverse of the empirical distribution function; 1186/// - type=2 - like type 1, but with averaging at discontinuities; 1187/// - type=3 - SAS definition: nearest even order statistic; 1188/// - Piecewise linear continuous:; 1189/// - In this case, sample quantiles can be obtained by linear interpolation; 1190/// between the k-th order statistic and p(k).; 1191/// -type=4 - linear interpolation of empirical cdf, p(k)=k/n;; 1192/// - type=5 - a very popular definition, p(k) = (k-0.5)/n;; 1193/// - type=6 - used by Minitab and SPSS, p(k) = k/(n+1);; 1194/// - type=7 - used by S-Plus and R, p(k) = (k-1)/(n-1);; 1195/// - type=8 - resulting sample quantiles are approximately median unbiased; 1196/// regardless of the distribution of x. p(k) = (k-1/3)/(n+1/3);; 1197/// - type=9 - resulting sample quantiles are approximately unbiased, when; 1198/// the sample comes from Normal distribution. p(k)=(k-3/8)/(n+1/4);; 1199///; 1200/// default type = 7; 1201///; 1202/// ### References:; 1203/// 1. Hyndman, R.J and Fan, Y, (1996) ""Sample quantiles in statistical packa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:38747,allocate,allocated,38747,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," ; 177 ; 178typedef QuasiRandom<ROOT::Math::GSLQRngSobol> QuasiRandomSobol;; 179typedef QuasiRandom<ROOT::Math::GSLQRngNiederreiter2> QuasiRandomNiederreiter;; 180 ; 181} // namespace Math; 182} // namespace ROOT; 183 ; 184 ; 185#endif /* ROOT_Math_QuasiRandom */; 186 ; 187 ; 188 ; GSLQuasiRandom.h; e#define e(i)Definition RSha256.hxx:103; ROOT::Math::QuasiRandomUser class for MathMore random numbers template on the Engine type.Definition QuasiRandom.h:60; ROOT::Math::QuasiRandom::QuasiRandomQuasiRandom(unsigned int dimension=1)Create a QuasiRandom generator.Definition QuasiRandom.h:70; ROOT::Math::QuasiRandom::Nextbool Next(double *x)Generate next quasi random numbers points.Definition QuasiRandom.h:95; ROOT::Math::QuasiRandom::fEngineEngine fEngineDefinition QuasiRandom.h:160; ROOT::Math::QuasiRandom::Skipbool Skip(unsigned int n)skip the next n number and jumb directly to the current state + nDefinition QuasiRandom.h:118; ROOT::Math::QuasiRandom::~QuasiRandom~QuasiRandom()Destructor: call Terminate() function of engine to free any allocated resource.Definition QuasiRandom.h:88; ROOT::Math::QuasiRandom::Namestd::string Name() constReturn the name of the generator.Definition QuasiRandom.h:154; ROOT::Math::QuasiRandom::Nextdouble Next()Generate next quasi random numbers point (1 - dimension)Definition QuasiRandom.h:102; ROOT::Math::QuasiRandom::RndmArraybool RndmArray(int n, double *array)Generate an array of random numbers between ]0,1[ Function to preserve ROOT Trandom compatibility The...Definition QuasiRandom.h:126; ROOT::Math::QuasiRandom::Rndmdouble Rndm()Generate quasi random numbers between ]0,1[ 0 and 1 are excluded Function to be compatible with ROOT ...Definition QuasiRandom.h:111; ROOT::Math::QuasiRandom::Typestd::string Type() constReturn the type (name) of the used generator.Definition QuasiRandom.h:133; ROOT::Math::QuasiRandom::EngineSizeunsigned int EngineSize() constReturn the size of the generator state.Definition QuasiRandom.h:140; ROOT::Math::Quas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/QuasiRandom_8h_source.html:5825,allocate,allocated,5825,doc/master/QuasiRandom_8h_source.html,https://root.cern,https://root.cern/doc/master/QuasiRandom_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency," ; 26 ; 27//___________________________________________________________________________________; 28/**; 29 Class describing the binned data sets :; 30 vectors of x coordinates, y values and optionally error on y values and error on coordinates; 31 The dimension of the coordinate is free; 32 There are 4 different options:; 33 - only coordinates and values (for binned likelihood fits) : kNoError; 34 - coordinate, values and error on values (for normal least square fits) : kValueError; 35 - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; 36 - coordinate, values, error on coordinates and asymmetric error on values : kAsymError; 37 ; 38 In addition there is the option to construct Bindata copying the data in (using the DataVector class); 39 or using pointer to external data (DataWrapper) class.; 40 In general is found to be more efficient to copy the data.; 41 In case of really large data sets for limiting memory consumption then the other option can be used; 42 Specialized constructor exists for data up to 3 dimensions.; 43 ; 44 When the data are copying in the number of points can be set later (or re-set) using Initialize and; 45 the data are inserted one by one using the Add method.; 46 It is mandatory to set the size before using the Add method.; 47 ; 48 @ingroup FitData; 49*/; 50 ; 51 ; 52class BinData : public FitData {; 53 ; 54public :; 55 ; 56 enum ErrorType { kNoError, kValueError, kCoordError, kAsymError };; 57 ; 58 /**; 59 constructor from dimension of point and max number of points (to pre-allocate vector); 60 Give a zero value and then use Initialize later one if the size is not known; 61 */; 62 ; 63 explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1,; 64 ErrorType err = kValueError);; 65 ; 66 ; 67 /**; 68 constructor from option and default range; 69 */; 70 explicit BinData (const DataOptions & opt, unsigned int maxpoints = 0,; 71 unsigned int dim = 1, ErrorType err = kValueError);; 72 ; 73",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:1726,consumption,consumption,1726,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,1,['consumption'],['consumption']
Energy Efficiency," ; 752 /*! \brief set the drop-out configuration (layer-wise); 753 *; 754 * \param begin begin of an array or vector denoting the drop-out probabilities for each layer; 755 * \param end end of an array or vector denoting the drop-out probabilities for each layer; 756 * \param _dropRepetitions denotes after how many repetitions the drop-out setting (which nodes are dropped out exactly) is changed; 757 */; 758 template <typename Iterator>; 759 void setDropOut (Iterator begin, Iterator end, size_t _dropRepetitions) { m_dropOut.assign (begin, end); m_dropRepetitions = _dropRepetitions; }; 760 ; 761 size_t dropRepetitions () const { return m_dropRepetitions; }; 762 const std::vector<double>& dropFractions () const { return m_dropOut; }; 763 ; 764 void setMonitoring (std::shared_ptr<Monitoring> ptrMonitoring) { fMonitoring = ptrMonitoring; } ///< prepared for monitoring; 765 ; 766 size_t convergenceSteps () const { return m_convergenceSteps; } ///< how many steps until training is deemed to have converged; 767 size_t batchSize () const { return m_batchSize; } ///< mini-batch size; 768 size_t testRepetitions () const { return m_testRepetitions; } ///< how often is the test data tested; 769 double factorWeightDecay () const { return m_factorWeightDecay; } ///< get the weight-decay factor; 770 ; 771 double learningRate () const { return fLearningRate; } ///< get the learning rate; 772 double momentum () const { return fMomentum; } ///< get the momentum (e.g. for SGD); 773 int repetitions () const { return fRepetitions; } ///< how many steps have to be gone until the batch is changed; 774 MinimizerType minimizerType () const { return fMinimizerType; } ///< which minimizer shall be used (e.g. SGD); 775 ; 776 ; 777 ; 778 ; 779 ; 780 ; 781 virtual void testSample (double /*error*/, double /*output*/, double /*target*/, double /*weight*/) {} ///< virtual function to be used for monitoring (callback); 782 virtual void startTrainCycle () ///< callback for monitoring and logging; 783",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:27392,monitor,monitoring,27392,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['monitor'],['monitoring']
Energy Efficiency," ; : linearity property of this classifier is reflected in the ; : metric with which ""far apart"" and ""close vicinity"" are ; : determined: the covariance matrix of the discriminating; : variable space.); : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Optimal performance for the linear discriminant is obtained for ; : linearly correlated Gaussian-distributed variables. Any deviation; : from this ideal reduces the achievable separation power. In ; : particular, no discrimination at all is achieved for a variable; : that has the same sample mean for signal and background, even if ; : the shapes of the distributions are very different. Thus, the linear ; : discriminant often benefits from a suitable transformation of the ; : input variables. For example, if a variable x in [-1,1] has a ; : a parabolic signal distributions, and a uniform background; : distributions, their mean value is zero in both cases, leading ; : to no separation. The simple transformation x -> |x| renders this ; : variable powerful for the use in a linear discriminant.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : <None>; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; LD : Results for LD coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : myvar1: -0.309; : myvar2: -0.102; : var3: -0.142; : var4: +0.705; : (offset): -0.055; : -----------------------; : Elapsed time for training with 2000 events: 0.00103 sec ; LD : [dataset] : Evaluation of LD on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.000394 sec ; : <CreateMVAPdfs> Separation from histogram (PDF): 0.540 (0.000); : Dataset[dataset] : Evaluation of LD on training sample; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_LD.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_LD.class.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:37092,power,powerful,37092,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['power'],['powerful']
Energy Efficiency," ; Definition at line 94 of file TDecompSparse.cxx. ◆ TDecompSparse() [5/5]. TDecompSparse::TDecompSparse ; (; const TDecompSparse & ; another). Copy constructor. ; Definition at line 107 of file TDecompSparse.cxx. ◆ ~TDecompSparse(). TDecompSparse::~TDecompSparse ; (; ). inlineoverride . Definition at line 148 of file TDecompSparse.h. Member Function Documentation. ◆ Class(). static TClass * TDecompSparse::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TDecompSparse::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TDecompSparse::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 176 of file TDecompSparse.h. ◆ CopyUpperTriang(). void TDecompSparse::CopyUpperTriang ; (; const TMatrixDSparse & ; a, . Double_t * ; b . ). staticprotected . Static function, copying the non-zero entries in the upper triangle to array b . ; User should allocate enough memory for array b . ; Definition at line 139 of file TDecompSparse.cxx. ◆ DeclFileName(). static const char * TDecompSparse::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 176 of file TDecompSparse.h. ◆ Decompose(). Bool_t TDecompSparse::Decompose ; (; ). overridevirtual . Decomposition engine . ; If the decomposition succeeds, bit kDecomposed is set . ; Implements TDecompBase.; Definition at line 234 of file TDecompSparse.cxx. ◆ Det(). void TDecompSparse::Det ; (; Double_t & ; d1, . Double_t & ; d2 . ). inlineoverridevirtual . Matrix determinant det = d1*TMath::Power(2.,d2) ; Reimplemented from TDecompBase.; Definition at line 169 of file TDecompSparse.h. ◆ ErrorFlag(). Int_t TDecompSparse::ErrorFlag ; (; ). inlineprotected . Definition at line 124 of file TDecompSparse.h. ◆ Factor(). void TDecompSparse::Factor ; (; const Int_t ; n, . const Int_t ; nz, . TArrayI & ; Airn, . TArrayI & ; Aicn, . TArrayD & ; Aa, . T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDecompSparse.html:19734,allocate,allocate,19734,doc/master/classTDecompSparse.html,https://root.cern,https://root.cern/doc/master/classTDecompSparse.html,1,['allocate'],['allocate']
Energy Efficiency," ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development Run the tests. Running the ROOT battery of tests; Running all ROOT tests on at least a platform before sending a PR or before pushing anything to the ROOT repository is mandatory.; The ROOT continuous integration infrastructure allows to automatically check the PR also on a battery of platform, for example including macos and linux boxes.; In order to be able to run all tests, the simple steps below need to be followed; Prepare your development area and build ROOT; mkdir RootDevelopment; cd RootDevelopment; git clone https://github.com/root-project/root; git clone https://github.com/root-project/roottest; mkdir build; cd build; echo Note the cmake options; cmake -DCMAKE_BUILD_TYPE=Debug -Dtesting=ON -Droottest=ON ../root. Inspect and run the tests; From within the build directory. List all tests: ctest -N; List all test matching a regex: ctest -N -R myregex; Run all tests on N cores: ctest -j N. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/run-tests.html:2137,battery,battery,2137,d/run-tests.html,https://root.cern,https://root.cern/d/run-tests.html,1,['battery'],['battery']
Energy Efficiency," ; Implements RooStats::IntervalCalculator.; Definition at line 104 of file BayesianCalculator.h. ◆ SetData(). void RooStats::BayesianCalculator::SetData ; (; RooAbsData & ; ). inlineoverridevirtual . Set the DataSet ( add to the workspace if not already there ?) ; Implements RooStats::IntervalCalculator.; Definition at line 72 of file BayesianCalculator.h. ◆ SetGlobalObservables(). virtual void RooStats::BayesianCalculator::SetGlobalObservables ; (; const RooArgSet & ; set). inlinevirtual . set the global observables which will be used when creating the NLL so the constraint pdf's will be normalized correctly on the global observables when computing the NLL ; Definition at line 96 of file BayesianCalculator.h. ◆ SetIntegrationType(). void RooStats::BayesianCalculator::SetIntegrationType ; (; const char * ; type). set the integration type (possible type are) : . 1D integration ( used when only one nuisance and when the posterior is scanned): adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration The parameter numIters (settable with SetNumIters) is the max number of function calls. It can be reduced to make the integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC: evaluate posterior by generating toy MC for the nuisance parameters. It is a MC integration, where the function is sampled according to the nuisance. It is convenient to use when all the nuisance are uncorrelated and it is efficient to generate them The toy are generated by default for each poi v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html:30486,adapt,adaptive,30486,doc/master/classRooStats_1_1BayesianCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html,2,['adapt'],['adaptive']
Energy Efficiency," ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » ROOT 6 Analysis Workshop 10. Go Parallel!. Why you care; Number crunching takes time. If you look at top (open a terminal, type top) in Linux or your activity monitor on MacOS you will see that one core is really really busy with root. But only one core - and you have two or four or if you're lucky even more. What about getting much more data crunched in the same time, or reducing the arrival time of your analysis results by factors?; TSelector; ROOT offers Proof lite - multiple ROOT processes ""hacking away"" on the same analysis. For that to work your analysis must be written using the TSelector interface: it must publicly derive from it and implement SlaveBegin() where you create the histograms, Process(Long64_t entry) to process the data, and Terminate() to do fits etc. You can find an example for using a TTreeReader within a TSelector here; try to adapt to to our tree and our efficiency determination.; TChain; Proof lite will run the TSelector on several input files in parallel - actually, it chunks the input (even of one file) and sends these chunks to worker processes. You can combine TTrees from multiple files (if they have the same name and structure) using a TChain:; TChain* chain = new TChain(""MyTree"");; chain->AddFile(""http://root.cern.ch/root/files/tutorials/mockupx.root"");; chain->AddFile(""http://root.cern.ch/root/files/tutorials/mockupx_1.root"");; chain->AddFile(""http://root.cern.ch/root/files/tutorials/mockupx_2.root"");; chain->AddFile(""http://root.cern.ch/root/files/tutorials/mockupx_3.root"");; chain->Process(""MySelector.C+""); // if you have put your selector from above into MySelector.C. The last line will run the selector on the whole chain. O - but that takes ages! We need to:; Enable Proof Lite; There are two parts to using Proof lite: you need to create an instance and you need to tell the chain to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/10-go-parallel.html:2716,adapt,adapt,2716,d/10-go-parallel.html,https://root.cern,https://root.cern/d/10-go-parallel.html,1,['adapt'],['adapt']
Energy Efficiency," ; [in]xclipl,yclipb,xclipr,ycliptClipping boundary . Definition at line 768 of file TPad.cxx. ◆ ClippingCode(). Int_t TPad::ClippingCode ; (; Double_t ; x, . Double_t ; y, . Double_t ; xcl1, . Double_t ; ycl1, . Double_t ; xcl2, . Double_t ; ycl2 . ). virtual . Compute the endpoint codes for TPad::Clip. ; Definition at line 901 of file TPad.cxx. ◆ ClipPolygon(). Int_t TPad::ClipPolygon ; (; Int_t ; n, . Double_t * ; x, . Double_t * ; y, . Int_t ; nn, . Double_t * ; xc, . Double_t * ; yc, . Double_t ; xclipl, . Double_t ; yclipb, . Double_t ; xclipr, . Double_t ; yclipt . ). virtual . Clip polygon using the Sutherland-Hodgman algorithm. ; Parameters. [in]nNumber of points in the polygon to be clipped ; [in]x,yPolygon x[n], y[n] do be clipped vertices ; [in]xclipl,yclipb,xclipr,ycliptClipping boundary ; [out]nnNumber of points in xc and yc ; [out]xc,ycClipped polygon vertices. The Int_t returned by this function is the number of points in the clipped polygon. These vectors must be allocated by the calling function. A size of 2*n for each is enough. Sutherland and Hodgman's polygon-clipping algorithm uses a divide-and-conquer strategy: It solves a series of simple and identical problems that, when combined, solve the overall problem. The simple problem is to clip a polygon against a single infinite clip edge. Four clip edges, each defining one boundary of the clip rectangle, successively clip a polygon against a clip rectangle.; Steps of Sutherland-Hodgman's polygon-clipping algorithm:. Polygons can be clipped against each edge of the window one at a time. Windows/edge intersections, if any, are easy to find since the X or Y coordinates are already known.; Vertices which are kept after clipping against one window edge are saved for clipping against the remaining edges.; Note that the number of vertices usually changes and will often increases. The clip boundary determines a visible and invisible region. The edges from vertex i to vertex i+1 can be one of four types:. C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:63221,allocate,allocated,63221,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['allocate'],['allocated']
Energy Efficiency," ;  ; TString fBoostedMethodName;  details of the boosted classifier ;  ; TString fBoostedMethodOptions;  options ;  ; TString fBoostedMethodTitle;  title ;  ; UInt_t fBoostNum;  Number of times the classifier is boosted. ;  ; TString fBoostType;  string specifying the boost type ;  ; Double_t fBoostWeight;  the weight used to boost the next classifier ;  ; std::vector< TH1 * > fBTrainBgdMVAHist;  ; std::vector< TH1 * > fBTrainSigMVAHist;  ; DataSetManager * fDataSetManager;  DSMTEST. ;  ; Bool_t fDetailedMonitoring;  produce detailed monitoring histograms (boost-wise) ;  ; Bool_t fHistoricBoolOption;  historic variable, only needed for ""CompatibilityOptions"" ;  ; TString fHistoricOption;  historic variable, only needed for ""CompatibilityOptions"" ;  ; Double_t fMethodError;  estimation of the level error of the classifier ;  ; Bool_t fMonitorBoostedMethod;  monitor the MVA response of every classifier ;  ; TTree * fMonitorTree;  tree to monitor values during the boosting ;  ; std::vector< Float_t > * fMVAvalues;  mva values for the last trained method ;  ; Double_t fOverlap_integral;  ; UInt_t fRandomSeed;  seed for random number generator used for bagging ;  ; Double_t fROC_training;  roc integral of last trained method (on training sample) ;  ; std::vector< TH1 * > fTestBgdMVAHist;  ; std::vector< TH1 * > fTestSigMVAHist;  ; std::vector< TH1 * > fTrainBgdMVAHist;  ; std::vector< TH1 * > fTrainSigMVAHist;  ; TString fTransformString;  min and max values for the classifier response ;  . Friends; class Experimental::Classification;  ; class Factory;  ; class Reader;  . Additional Inherited Members;  Public Types inherited from TMVA::MethodBase; enum  EWeightFileType { kROOT =0; , kTEXT; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBoost.html:29247,monitor,monitoring,29247,doc/master/classTMVA_1_1MethodBoost.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBoost.html,3,['monitor'],"['monitor', 'monitoring']"
Energy Efficiency," ;   kMLeft; , kMCenter; , kMRight; , kBLeft; , ;   kBCenter; , kBRight. };  . Private Member Functions; void Align (void);  Compute alignment variables. ;  ; void CloseWindow1 ();  Delete current window. ;  ; void DrawImage (FT_Bitmap *source, ULong_t fore, ULong_t back, GdkImage *xim, Int_t bx, Int_t by);  Draw FT_Bitmap bitmap to xim image at position bx,by using specified foreground color. ;  ; Int_t FindColor (ULong_t pixel, ULong_t *orgcolors, Int_t ncolors);  Returns index in orgcolors (and new_colors) for pixel. ;  ; GdkImage * GetBackground (Int_t x, Int_t y, UInt_t w, UInt_t h);  Get the background of the current window in an XImage. ;  ; void ImgPickPalette (GdkImage *image, Int_t &ncol, Int_t *&R, Int_t *&G, Int_t *&B);  Returns in R G B the ncol colors of the palette used by the image. ;  ; Bool_t IsVisible (Int_t x, Int_t y, UInt_t w, UInt_t h);  Test if there is really something to render. ;  ; void MakeOpaqueColors (Int_t percent, ULong_t *orgcolors, Int_t ncolors);  Get RGB values for orgcolors, add percent neutral to the RGB and allocate new_colors. ;  ; void MapColorStruct (ColorStruct_t *color, GdkColor &xcolor);  Map a ColorStruct_t to a XColor structure. ;  ; void MapCursor (ECursor cursor, Int_t &xcursor);  ; void MapEvent (Event_t &ev, GdkEvent &xev, Bool_t tox=kTRUE);  Map Event_t structure to gdk_event structure. ;  ; void MapEventMask (UInt_t &emask, UInt_t &xemask, Bool_t tox=kTRUE);  Map event mask to or from gdk. ;  ; void MapGCValues (GCValues_t &gval, ULong_t &xmask, GdkGCValues &xgval, Bool_t tox=kTRUE);  Map a GCValues_t to a XCGValues structure if tox is true. ;  ; void MapKeySym (UInt_t &keysym, UInt_t &xkeysym, Bool_t tox=kTRUE);  Map to and from X key symbols. ;  ; void MapModifierState (UInt_t &state, UInt_t &xstate, Bool_t tox=kTRUE);  Map modifier key state to or from X. ;  ; void MapSetWindowAttributes (SetWindowAttributes_t *attr, ULong_t &xmask, GdkWindowAttr &xattr);  Map a SetWindowAttributes_t to a GdkWindowAttr structu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:49398,allocate,allocate,49398,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['allocate'],['allocate']
Energy Efficiency," < allCoords.size(); i += 3) {; x[0] = allCoords[i + 0].first;; y[0] = allCoords[i + 0].second;; x[1] = allCoords[i + 1].first;; y[1] = allCoords[i + 1].second;; x[2] = allCoords[i + 2].first;; y[2] = allCoords[i + 2].second;; th2p->AddBin(3, x, y);; avg->AddBin(3, x, y);; err->AddBin(3, x, y);; }; ; // -------------------- Generate particles ------------------------; TRandom ran;; for (int j = 0; j < numEvents; ++j) {; Double_t r1 = ran.Gaus(0, 10);; Double_t r2 = ran.Gaus(0, 8);; Double_t rok = ran.Gaus(20, 2);; Double_t rbad1 = ran.Gaus(1, 2);; Double_t rbad2 = ran.Gaus(2, 0);; ; Double_t val = rok;; // -------------------- Malfunctioning panels -------------------; if (th2p->IsInsideBin(4, r1, r2)) val = rok - rbad1;; if (th2p->IsInsideBin(20, r1, r2)) val = rok - rbad2;; if (th2p->IsInsideBin(13, r1, r2)) val = rok + rbad1;; if (th2p->IsInsideBin(37, r1, r2)) val = rok + rbad2;; ; // -------------------- Fill histograms ------------------------; th2p->Fill(r1, r2, val);; avg->Fill(r1, r2, val);; err->Fill(r1, r2, val);; }; ; // -------------------- Display end state ------------------------; c1->cd(1);; th2p->SetStats(0);; th2p->SetTitle(""total hits"");; th2p->Draw(""COLZ"");; ; c1->cd(2);; avg->SetStats(0);; avg->SetTitle(""average charge"");; avg->Draw(""COLZ"");; ; c1->cd(3);; err->SetStats(0);; err->SetContentToError();; err->SetTitle(""error"");; err->Draw(""COLZ"");; }; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; gROOT#define gROOTDefinition TROOT.h:406; TCanvasThe Canvas class.Definition TCanvas.h:23; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TProfile2Poly2D Profile Histogram with Polygonal Bins.Definition TProfile2Poly.h:58; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html:2608,charge,charge,2608,doc/master/tprofile2polyRealisticModuleError_8C.html,https://root.cern,https://root.cern/doc/master/tprofile2polyRealisticModuleError_8C.html,1,['charge'],['charge']
Energy Efficiency," << ( 13 )). };  ;  Public Attributes inherited from TArrayF; Float_t * fArray;  ;  Public Attributes inherited from TArray; Int_t fN;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TH3; static TH1D * DoProject1D (const TH3 &h, const char *name, const char *title, const TAxis *projX, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 1D histogram ;  ; static TH2D * DoProject2D (const TH3 &h, const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 2D histogram ;  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Check histogram compatibility. ;  ; static bool CheckConsistentSubAxes (const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0);  Check that two sub axis are the same. ;  ; static bool CheckEqualAxes (const TAxis *a1, const TAxis *a2);  Check that the axis are the same. ;  ; static Bool_t RecomputeAxisLimits (TAxis &destAxis, const TAxis &anAxis);  Finds new limits for the axis for the Merge function. ;  ; static Bool_t SameLimitsAndNBins (const TAxis &axis1, const TAxis &axis2);  S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3F.html:57462,power,power,57462,doc/master/classTH3F.html,https://root.cern,https://root.cern/doc/master/classTH3F.html,1,['power'],['power']
Energy Efficiency," << ( 13 )). };  ;  Public Attributes inherited from TArrayS; Short_t * fArray;  ;  Public Attributes inherited from TArray; Int_t fN;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TH3; static TH1D * DoProject1D (const TH3 &h, const char *name, const char *title, const TAxis *projX, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 1D histogram ;  ; static TH2D * DoProject2D (const TH3 &h, const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 2D histogram ;  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Check histogram compatibility. ;  ; static bool CheckConsistentSubAxes (const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0);  Check that two sub axis are the same. ;  ; static bool CheckEqualAxes (const TAxis *a1, const TAxis *a2);  Check that the axis are the same. ;  ; static Bool_t RecomputeAxisLimits (TAxis &destAxis, const TAxis &anAxis);  Finds new limits for the axis for the Merge function. ;  ; static Bool_t SameLimitsAndNBins (const TAxis &axis1, const TAxis &axis2);  S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3S.html:57321,power,power,57321,doc/master/classTH3S.html,https://root.cern,https://root.cern/doc/master/classTH3S.html,1,['power'],['power']
Energy Efficiency," = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<double>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); Set size of the matrix to nrows x ncols with nr_nonzeros non-zero entries; if nr_nonzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTSparse<Element> &TMatrixTSparse<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSparse_double_.html:20522,allocate,allocated,20522,root/html528/TMatrixTSparse_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_double_.html,1,['allocate'],['allocated']
Energy Efficiency," = """" . ). virtual . Register the 'dataSet' on the cluster under the current user, group and the given 'dataSetName'. ; If a dataset with the same name already exists the action fails unless 'opts' contains 'O', in which case the old dataset is overwritten, or contains 'U', in which case 'newDataSet' is added to the existing dataset (duplications are ignored, if any). If 'opts' contains 'V' the dataset files are also verified (if the dataset manager is configured to allow so). By default the dataset is not verified. If 'opts' contains 'T' the in the dataset object (status bits, meta,...) is trusted, i.e. not reset (if the dataset manager is configured to allow so). If 'opts' contains 'S' validation would be run serially (meaningful only if validation is required). Returns kTRUE on success. ; Reimplemented in TProofLite.; Definition at line 10707 of file TProof.cxx. ◆ ReleaseMonitor(). void TProof::ReleaseMonitor ; (; TMonitor * ; mon). private . Release the used monitor to be used, making sure to delete newly created monitors. ; Definition at line 2654 of file TProof.cxx. ◆ Remove() [1/2]. Int_t TProof::Remove ; (; const char * ; ref, . Bool_t ; all = kFALSE . ). Send remove request for the query specified by ref. ; If all = TRUE remove also local copies of the query, if any. Generic method working for all queries known by the server. This method can be also used to reset the list of queries waiting to be processed: for that purpose use ref == ""cleanupqueue"". ; Definition at line 6034 of file TProof.cxx. ◆ Remove() [2/2]. Int_t TProof::Remove ; (; Int_t ; query, . Bool_t ; all = kFALSE . ). Send remove request for the qry-th query in fQueries. ; Definition at line 6013 of file TProof.cxx. ◆ RemoveChain(). void TProof::RemoveChain ; (; TChain * ; chain). Remove chain from data set. ; Definition at line 10231 of file TProof.cxx. ◆ RemoveDataSet(). Int_t TProof::RemoveDataSet ; (; const char * ; uri, . const char * ; optStr = """" . ). virtual . Remove the specified datas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:131156,monitor,monitor,131156,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,2,['monitor'],"['monitor', 'monitors']"
Energy Efficiency," = ""S:"" or optStr = ""short:"".; To get the sub-dataset of files located on a given server(s) specify; the list of servers (comma-separated) in the 'optStr' field. void ShowDataSet(const char* dataset = """", const char* opt = ""M""); display meta-info for given dataset usi. Int_t RemoveDataSet(const char* dataset, const char* optStr = """"); Remove the specified dataset from the PROOF cluster.; Files are not deleted. TList* FindDataSets(const char* searchString, const char* optStr = """"); Find datasets, returns in a TList all found datasets. Int_t VerifyDataSet(const char* dataset, const char* optStr = """"); Verify if all files in the specified dataset are available.; Print a list and return the number of missing files. TMap * GetDataSetQuota(const char* optStr = """"); returns a map of the quotas of all groups. void ShowDataSetQuota(Option_t* opt = 0); shows the quota and usage of all groups; if opt contains ""U"" shows also distribution of usage on user-level. void InterruptCurrentMonitor(); If in active in a monitor set ready state. Int_t ActivateWorker(const char* ord); Make sure that the worker identified by the ordinal number 'ord' is; in the active list. The request will be forwarded to the master; in direct contact with the worker. If needed, this master will move; the worker from the inactive to the active list and rebuild the list; of unique workers.; Use ord = ""*"" to activate all inactive workers.; The string 'ord' can also be a comma-separated list of ordinal numbers the; status of which will be modified at once.; Return <0 if something went wrong (-2 if at least one worker was not found); or the number of workers with status change (on master; 0 on client). Int_t DeactivateWorker(const char* ord); Remove the worker identified by the ordinal number 'ord' from the; the active list. The request will be forwarded to the master; in direct contact with the worker. If needed, this master will move; the worker from the active to the inactive list and rebuild the list; of uni",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProof.html:83827,monitor,monitor,83827,root/html530/TProof.html,https://root.cern,https://root.cern/root/html530/TProof.html,3,['monitor'],['monitor']
Energy Efficiency," = ""S:"" or optStr = ""short:"".; To get the sub-dataset of files located on a given server(s) specify; the list of servers (comma-separated) in the 'optStr' field. void ShowDataSet(const char* dataset = """", const char* opt = ""M""); display meta-info for given dataset usi. Int_t RemoveDataSet(const char* dataset, const char* optStr = """"); Remove the specified dataset from the PROOF cluster.; Files are not deleted. TList* FindDataSets(const char* searchString, const char* optStr = """"); Find datasets, returns in a TList all found datasets. Int_t VerifyDataSet(const char* dataset, const char* optStr = """"); Verify if all files in the specified dataset are available.; Print a list and return the number of missing files. TMap * GetDataSetQuota(const char* optStr = """"); returns a map of the quotas of all groups. void ShowDataSetQuota(Option_t* opt = 0); shows the quota and usage of all groups; if opt contains ""U"" shows also distribution of usage on user-level. void InterruptCurrentMonitor(); If in active in a monitor set ready state. void ActivateWorker(const char* ord); Make sure that the worker identified by the ordinal number 'ord' is; in the active list. The request will be forwarded to the master; in direct contact with the worker. If needed, this master will move; the worker from the inactive to the active list and rebuild the list; of unique workers.; Use ord = ""*"" to activate all inactive workers. void DeactivateWorker(const char* ord); Remove the worker identified by the ordinal number 'ord' from the; the active list. The request will be forwarded to the master; in direct contact with the worker. If needed, this master will move; the worker from the active to the inactive list and rebuild the list; of unique workers.; Use ord = ""*"" to deactivate all active workers. void ModifyWorkerLists(const char* ord, Bool_t add); Modify the worker active/inactive list by making the worker identified by; the ordinal number 'ord' active (add == TRUE) or inactive (add == FALSE).; If n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:82807,monitor,monitor,82807,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,1,['monitor'],['monitor']
Energy Efficiency," = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. UShort_t*fColorAlpha[fNumPoints] alpha at each anchor point; UShort_t*fColorBlue[fNumPoints] blue color at each anchor point; UShort_t*fColorGreen[fNumPoints] green color at each anchor point; UShort_t*fColorRed[fNumPoints] red color at each anchor point; UInt_tfNumPointsnumber of anchor points; Double_t*fPoints[fNumPoints] value of each anchor point [0..1]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TImagePalette(); Default constructor, sets all pointers to 0. TImagePalette(UInt_t numPoints); Constructor for a palette with numPoints anchor points.; It allocates the memory but does not set any colors. TImagePalette(const TImagePalette& palette); Copy constructor. TImagePalette(Int_t ncolors, Int_t* colors); Creates palette in the same way as TStyle::SetPalette. ~TImagePalette(); Destructor. TImagePalette & operator=(const TImagePalette& palette); Assignment operator. Int_t FindColor(UShort_t r, UShort_t g, UShort_t b); returns an index of the closest color. Int_t * GetRootColors(); Returns a list of ROOT colors. Could be used to set histogram palette.; See also http://root.cern.ch/root/htmldoc/TStyle.html#TStyle:SetPalette. » Author: Reiner Rohlfs 24/03/02 » Copyright (C) 2001-2002, Rene Brun, Fons Rademakers and Reiner Rohlfs *; » Last changed: root/graf:$Id: TAttImage.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TImagePalette.html:8181,allocate,allocates,8181,root/html528/TImagePalette.html,https://root.cern,https://root.cern/root/html528/TImagePalette.html,1,['allocate'],['allocates']
Energy Efficiency," = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. UShort_t*fColorAlpha[fNumPoints] alpha at each anchor point; UShort_t*fColorBlue[fNumPoints] blue color at each anchor point; UShort_t*fColorGreen[fNumPoints] green color at each anchor point; UShort_t*fColorRed[fNumPoints] red color at each anchor point; UInt_tfNumPointsnumber of anchor points; Double_t*fPoints[fNumPoints] value of each anchor point [0..1]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TImagePalette(); Default constructor, sets all pointers to 0. TImagePalette(UInt_t numPoints); Constructor for a palette with numPoints anchor points.; It allocates the memory but does not set any colors. TImagePalette(const TImagePalette& palette); Copy constructor. TImagePalette(Int_t ncolors, Int_t* colors); Creates palette in the same way as TStyle::SetPalette. ~TImagePalette(); Destructor. TImagePalette & operator=(const TImagePalette& palette); Assignment operator. Int_t FindColor(UShort_t r, UShort_t g, UShort_t b); returns an index of the closest color. Int_t * GetRootColors(); Returns a list of ROOT colors. Could be used to set histogram palette.; See also http://root.cern.ch/root/htmldoc/TStyle.html#TStyle:SetPalette. » Author: Reiner Rohlfs 24/03/02 » Copyright (C) 2001-2002, Rene Brun, Fons Rademakers and Reiner Rohlfs *; » Last changed: root/graf:$Id: TAttImage.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TImagePalette.html:8250,allocate,allocates,8250,root/html530/TImagePalette.html,https://root.cern,https://root.cern/root/html530/TImagePalette.html,1,['allocate'],['allocates']
Energy Efficiency," = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. UShort_t*fColorAlpha[fNumPoints] alpha at each anchor point; UShort_t*fColorBlue[fNumPoints] blue color at each anchor point; UShort_t*fColorGreen[fNumPoints] green color at each anchor point; UShort_t*fColorRed[fNumPoints] red color at each anchor point; UInt_tfNumPointsnumber of anchor points; Double_t*fPoints[fNumPoints] value of each anchor point [0..1]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TImagePalette(); Default constructor, sets all pointers to 0. TImagePalette(UInt_t numPoints); Constructor for a palette with numPoints anchor points.; It allocates the memory but does not set any colors. TImagePalette(const TImagePalette& palette); Copy constructor. TImagePalette(Int_t ncolors, Int_t* colors); Creates palette in the same way as TStyle::SetPalette. ~TImagePalette(); Destructor. TImagePalette & operator=(const TImagePalette& palette); Assignment operator. Int_t FindColor(UShort_t r, UShort_t g, UShort_t b); returns an index of the closest color. Int_t * GetRootColors(); Returns a list of ROOT colors. Could be used to set histogram palette.; See also http://root.cern.ch/root/htmldoc/TStyle.html#TStyle:SetPalette. » Author: Reiner Rohlfs 24/03/02 » Copyright (C) 2001-2002, Rene Brun, Fons Rademakers and Reiner Rohlfs *; » Last changed: root/graf:$Id: TAttImage.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TImagePalette.html:8250,allocate,allocates,8250,root/html532/TImagePalette.html,https://root.cern,https://root.cern/root/html532/TImagePalette.html,2,['allocate'],['allocates']
Energy Efficiency," = 0) const; Determine integration scenario. If no interpolation is used,; RooHistFunc can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used, only the integral; over all RooHistPdf observables is implemented. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. Bool_t importWorkspaceHook(RooWorkspace& ws); Check if our datahist is already in the workspace. Bool_t areIdentical(const RooDataHist& dh1, const RooDataHist& dh2). void Streamer(TBuffer& ); Stream an object of class RooHistFunc. void ioStreamerPass2(); Schema evolution: if histObsList wasn't filled from persistence (v1); then fill it here. Can't be done in regular schema evolution in LinkDef; as _depList content is not guaranteed to be initialized there. TObject* clone(const char* newname) const; { return new RooHistFunc(*this,newname); }. RooDataHist& dataHist(); Return RooDataHist that is represented. const RooDataHist& dataHist() const; Return RooDataHist that is represented. void setInterpolationOrder(Int_t order); Set histogram interpolation order. Int_t getInterpolationOrder() const; Return histogram interpolation order. void setC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistFunc.html:39555,efficient,efficiently,39555,root/html534/RooHistFunc.html,https://root.cern,https://root.cern/root/html534/RooHistFunc.html,6,['efficient'],['efficiently']
Energy Efficiency," = 0) const; Determine integration scenario. If no interpolation is used,; RooHistFunc can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used, only the integral; over all RooHistPdf observables is implemented. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. void Streamer(TBuffer& b); Stream an object of class RooHistFunc. TObject* clone(const char* newname) const; { return new RooHistFunc(*this,newname); }. virtual ~RooHistFunc(); { }. RooDataHist& dataHist(); Return RooDataHist that is represented. const RooDataHist& dataHist() const; Return RooDataHist that is represented. void setInterpolationOrder(Int_t order); Set histogram interpolation order. Int_t getInterpolationOrder() const; Return histogram interpolation order. void setCdfBoundaries(Bool_t flag); Set use of special boundary conditions for c.d.f.s. Bool_t getCdfBoundaries() const; If true, special boundary conditions for c.d.f.s are used. Bool_t isBinnedDistribution(const RooArgSet& ) const; { return _intOrder==0 ; }. Double_t totalVolume() const. » Last changed: Fri Dec 2 14:26:50 2011 » Last generated: 2011-12-02 14:26; This pag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistFunc.html:36683,efficient,efficiently,36683,root/html532/RooHistFunc.html,https://root.cern,https://root.cern/root/html532/RooHistFunc.html,2,['efficient'],['efficiently']
Energy Efficiency," = 0) const; voidzeroEvalCount(). protected:. voidapplyCovarianceMatrix(TMatrixDSym& V); voidbackProp(); voidclearPdfParamAsymErr(Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Int_tgetNPar() const; Double_tgetPdfParamErr(Int_t index); Double_tgetPdfParamVal(Int_t index); ofstream*logfile() const; voidTObject::MakeZombie(); Double_t&maxFCN(); voidprofileStart(); voidprofileStop(); voidsaveStatus(const char* label, Int_t status); voidsetPdfParamErr(Int_t index, Double_t value); voidsetPdfParamErr(Int_t index, Double_t loVal, Double_t hiVal); virtual Bool_tsetPdfParamVal(Int_t index, Double_t value, Bool_t verbose = kFALSE); Bool_tsynchronize(Bool_t verbose); voidupdateFloatVec(). private:. RooMinuit(const RooMinuit&). Data Members; public:. enum Strategy { Speed; Balance; Robustness; };; enum PrintLevel { None; Reduced; Normal; ExtraForProblem; Maximum; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. RooArgList*_constParamList; TStopwatch_cumulTimer; Bool_t_doEvalErrorWall; Int_t_evalCounter; TMatrixDSym*_extV; RooArgList*_floatParamList; vector<RooAbsArg*>_floatParamVec; RooAbsReal*_func; Bool_t_handleLocalErrors; RooArgList*_initConstParamList; RooArgList*_initFloatParamList; ofstream*_logfile; Int_t_maxEvalMult; Double_t_maxFCN; Int_t_nPar; Int_t_numBadNLL; Int_t_optConst; Int_t_printEvalErrors; Int_t_printLevel; Bool_t_profile; Int_t_status; vector<std::pair<std::string,int> >_statusHistory; static TVirtualFitter*_theFitter; TStopwatch_timer; Bool_t_verbose; Int_t_warnLevel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Cleanup method called by atexit handler installed by RooSentinel; to delete all global heap objects when t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMinuit.html:7307,Reduce,Reduced,7307,root/html534/RooMinuit.html,https://root.cern,https://root.cern/root/html534/RooMinuit.html,1,['Reduce'],['Reduced']
Energy Efficiency," = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TArrayL64; Long64_t * fArray;  ;  Public Attributes inherited from TArray; Int_t fN;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TH3; static TH1D * DoProject1D (const TH3 &h, const char *name, const char *title, const TAxis *projX, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 1D histogram ;  ; static TH2D * DoProject2D (const TH3 &h, const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 2D histogram ;  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3L.html:57361,power,power,57361,doc/master/classTH3L.html,https://root.cern,https://root.cern/doc/master/classTH3L.html,1,['power'],['power']
Energy Efficiency," = 1.); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator*=(double val); Multiply every element of the matrix with val. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(const TMatrixTSym<Element> &source); Add the source matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(const TMatrixTSym<Element> &source); Subtract the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTSym_double_.html:19796,efficient,efficient,19796,root/html602/TMatrixTSym_double_.html,https://root.cern,https://root.cern/root/html602/TMatrixTSym_double_.html,4,['efficient'],['efficient']
Energy Efficiency," = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;; 106 }; 107 }; 108 ; 109 ; 110 /*; 111 * Allocate memory for polygons; 112 */; 113 ; 114 if (gSize3D.numPolys) {; 115 polys = (polygon *) calloc(gSize3D.numPolys, sizeof (polygon));; 116 if (!polys) {; 117 puts (""Unable to allocate memory for polygons !"");; 118 ret = 0;; 119 }; 120 }; 121 ; 122 /*; 123 * In case of error, free allocated memory; 124 */; 125 ; 126 ; 127 if (!ret) {; 128 if (points) free (points);; 129 if (colors) free (colors);; 130 if (segs) free (segs);; 131 if (polys) free (polys);; 132 ; 133 points = NULL;; 134 colors = NULL;; 135 segs = NULL;; 136 polys = NULL;; 137 }; 138 ; 139 return (ret);; 140}; 141 ; 142void FillX3DBuffer (X3DBuffer *buff); 143{; 144/******************************************************************************; 145 Read points, Read segments & Read polygons; 146******************************************************************************/; 147 ; 148 ; 149 int n, i, j, p, q, c;; 150 int oldNumOfPoints, oldNumOfSegments;; 151 ; 152 if (b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/X3DBuffer_8c_source.html:3868,allocate,allocate,3868,doc/master/X3DBuffer_8c_source.html,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html,1,['allocate'],['allocate']
Energy Efficiency," = df_iso.Define(""Electron_ip3d_el"", ""sqrt(Electron_dxy*Electron_dxy + Electron_dz*Electron_dz)""); df_el_sip3d = df_el_ip3d.Define(""Electron_sip3d_el"",; ""Electron_ip3d_el/sqrt(Electron_dxyErr*Electron_dxyErr + ""; ""Electron_dzErr*Electron_dzErr)""); df_el_track = df_el_sip3d.Filter(""All(Electron_sip3d_el<4) && All(abs(Electron_dxy)<0.5) &&""; "" All(abs(Electron_dz)<1.0)"",; ""Electron track close to primary vertex with small uncertainty""); df_mu_ip3d = df_el_track.Define(""Muon_ip3d_mu"", ""sqrt(Muon_dxy*Muon_dxy + Muon_dz*Muon_dz)""); ; df_mu_sip3d = df_mu_ip3d.Define(""Muon_sip3d_mu"",; ""Muon_ip3d_mu/sqrt(Muon_dxyErr*Muon_dxyErr + Muon_dzErr*Muon_dzErr)""); df_mu_track = df_mu_sip3d.Filter(""All(Muon_sip3d_mu<4) && All(abs(Muon_dxy)<0.5) && All(abs(Muon_dz)<1.0)"",; ""Muon track close to primary vertex with small uncertainty""); df_2p2n = df_mu_track.Filter(""Sum(Electron_charge)==0 && Sum(Muon_charge)==0"",; ""Two opposite charged electron and muon pairs""); ; return df_2p2n; ; ; def reco_higgs_to_4mu(df):; """"""Reconstruct Higgs from four muons""""""; # Filter interesting events; df_base = selection_4mu(df); ; # Reconstruct Z systems; df_z_idx = df_base.Define(""Z_idx"", ""reco_zz_to_4l(Muon_pt, Muon_eta, Muon_phi, Muon_mass, Muon_charge)""); ; # Cut on distance between muons building Z systems; df_z_dr = df_z_idx.Filter(""filter_z_dr(Z_idx, Muon_eta, Muon_phi)"", ""Delta R separation of muons building Z system""); ; # Compute masses of Z systems; df_z_mass = df_z_dr.Define(""Z_mass"", ""compute_z_masses_4l(Z_idx, Muon_pt, Muon_eta, Muon_phi, Muon_mass)""); ; # Cut on mass of Z candidates; df_z_cut = filter_z_candidates(df_z_mass); ; # Reconstruct H mass; df_h_mass = df_z_cut.Define(""H_mass"", ""compute_higgs_mass_4l(Z_idx, Muon_pt, Muon_eta, Muon_phi, Muon_mass)""); ; return df_h_mass; ; ; def selection_4mu(df):; """"""Select interesting events with four muons""""""; df_ge4m = df.Filter(""nMuon>=4"", ""At least four muons""); ; df_iso = df_ge4m.Filter(""All(abs(Muon_pfRelIso04_all)<0.40)"", ""Require good isolati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html:4745,charge,charged,4745,doc/master/df103__NanoAODHiggsAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html,1,['charge'],['charged']
Energy Efficiency," = r * v;; You can also use the Transform() method or the operator *= of the TVector3 class:; TVector3 v;; TRotation r;; v.Transform(r);; 17.4 TLorentzVector; TLorentzVector is a general four-vector class, which can be used either for the description of position and time (x, y, z, t) or momentum and energy (px, py, pz, E).; 17.4.1 Declaration; TLorentzVector has been implemented as a set a TVector3 and a Double_t variable. By default, all components are initialized by zero.; TLorentzVector v1; // initialized by (0.,0.,0.,0.); TLorentzVector v2(1.,1.,1.,1.);; TLorentzVector v3(v1);; TLorentzVector v4(TVector3(1.,2.,3.),4.);; For backward compatibility there are two constructors from a Double_t and Float_t array.; 17.4.2 Access to Components; There are two sets of access functions to the components of a TLorentzVector: X(), Y(), Z(), T() and Px(), Py(), Pz() and E(). Both sets return the same values but the first set is more relevant for use where TLorentzVector describes a combination of position and time and the second set is more relevant where TLorentzVector describes momentum and energy:; Double_t xx =v.X();; ...; Double_t tt = v.T();; Double_t px = v.Px();; ...; Double_t ee = v.E();; The components of TLorentzVector can also accessed by index:; xx = v(0);orxx = v[0];; yy = v(1);yy = v[1];; zz = v(2);zz = v[2];; tt = v(3);tt = v[3];; You can use the Vect() method to get the vector component of TLorentzVector:; TVector3 p = v.Vect();; For setting components there are two methods: SetX(),.., SetPx(),..:; v.SetX(1.); orv.SetPx(1.);; ......; v.SetT(1.);v.SetE(1.);; To set more the one component by one call you can use the SetVect() function for the TVector3 part or SetXYZT(), SetPxPyPzE(). For convenience there is also a SetXYZM():; v.SetVect(TVector3(1,2,3));; v.SetXYZT(x,y,z,t);; v.SetPxPyPzE(px,py,pz,e);; v.SetXYZM(x,y,z,m); // v = (x,y,z,e = Sqrt(x*x+y*y+z*z+m*m)); 17.4.3 Vector Components in Non-Cartesian Coordinates; There are a couple of methods to get and set ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:867172,energy,energy,867172,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['energy'],['energy']
Energy Efficiency," > RooAbsData::reduce ; (; const RooArgSet & ; varSubset, . const char * ; cut = nullptr . ); const. Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ; The cut expression can refer to any variable in the data set. For cuts involving other variables, such as intermediate formula objects, use the equivalent reduce method specifying the as a RooFormulVar reference. ; Definition at line 500 of file RooAbsData.cxx. ◆ reduce() [3/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const RooArgSet & ; varSubset, . const RooFormulaVar & ; cutVar . ); const. Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ; The 'cutVar' formula variable is used to select the subset of data points to be retained in the reduced data collection. ; Definition at line 530 of file RooAbsData.cxx. ◆ reduce() [4/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ); const. Create a reduced copy of this dataset. ; The caller takes ownership of the returned dataset; The following optional named arguments are accepted . SelectVars(const RooArgSet& vars) Only retain the listed observables in the output dataset . Cut(const char* expression) Only retain event surviving the given cut expression. . Cut(const RooFormulaVar& expr) Only retain event surviving the given cut formula. . CutRange(const char* name) Only retain events inside range with given name. Multiple CutRange arguments may be given to select multiple ranges. Note that this will also consider the variables that are not selected by SelectVars(). . EventRange(int lo, int hi) Only retain events with given sequential event nu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:63415,reduce,reduce,63415,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['reduce'],['reduce']
Energy Efficiency," >;  CAlgebraicSumType;  CAlgebraicSumType< gen, vec >;  CAlgebraicSumType< sym, vec >;  CAlgebraicSumType< T, T >;  CAlgebraicSumType< vec, gen >;  CAlgebraicSumType< vec, sym >;  CAnalyticalGradientCalculator;  CBasicFunctionGradient;  ►CBasicFunctionMinimumResult of the minimization; both internal and external (MnUserParameterState) representation available For the parameters at the Minimum ;  CMnAboveMaxEdm;  CMnReachedCallLimit;  ►CBasicMinimumErrorInternal Class containing the error information on the estimated minimum : Error matrix + dcovar + additional flags for quality and validity checks ;  CMnHesseFailed;  CMnInvertFailed;  CMnMadePosDef;  CMnNotPosDef;  CBasicMinimumParameters;  CBasicMinimumSeed;  CBasicMinimumState;  CCombinedMinimizerCombined minimizer: combination of Migrad and Simplex ;  CCombinedMinimumBuilder;  CContoursError;  CDavidonErrorUpdatorUpdate of the covariance matrix for the Variable Metric minimizer (MIGRAD) ;  CFCNAdapterTemplate wrapped class for adapting to FCNBase signature ;  CFCNBaseInterface (abstract class) defining the function to be minimized, which has to be implemented by the user ;  CFCNGradAdapterTemplate wrapped class for adapting to FCNBase signature a IGradFunction ;  CFCNGradientBaseExtension of the FCNBase for providing the analytical Gradient of the function ;  CFlatRandomGen;  CFumiliBuilderBuilds the FunctionMinimum using the Fumili method ;  CFumiliChi2FCNExtension of the FCNBase for the Fumili method ;  CFumiliErrorUpdatorIn the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives ;  CFumiliFCNAdapterTemplate wrapped class for adapting to FumiliFCNBase signature ;  CFumiliFCNBaseExtension of the FCNBase for the Fumili method ;  CFumiliGradientCalculator;  CFumiliMaximumLikelihoodFCNExtension of the FCNBase for the Fumili method ;  CFumiliMinimizerInstantiates th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:55137,adapt,adapting,55137,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,4,['adapt'],['adapting']
Energy Efficiency," >;  CAlgebraicSumType;  CAlgebraicSumType< gen, vec >;  CAlgebraicSumType< sym, vec >;  CAlgebraicSumType< T, T >;  CAlgebraicSumType< vec, gen >;  CAlgebraicSumType< vec, sym >;  CAnalyticalGradientCalculator;  CBasicFunctionGradient;  ►CBasicFunctionMinimumResult of the minimization; both internal and external (MnUserParameterState) representation available For the parameters at the Minimum ;  CMnAboveMaxEdm;  CMnReachedCallLimit;  ►CBasicMinimumErrorInternal Class containing the error information on the estimated minimum : Error matrix + dcovar + additional flags for quality and validity checks ;  CMnHesseFailed;  CMnInvertFailed;  CMnMadePosDef;  CMnNotPosDef;  CBasicMinimumParameters;  CBasicMinimumSeed;  CBasicMinimumState;  CCombinedMinimizerCombined minimizer: combination of Migrad and Simplex ;  CCombinedMinimumBuilder;  CContoursError;  CDavidonErrorUpdatorUpdate of the covariance matrix for the Variable Metric minimizer (MIGRAD) ;  CFCNAdapterTemplate wrapped class for adapting to FCNBase signature ;  CFCNBaseInterface (abstract class) defining the function to be minimized, which has to be implemented by the user ;  CFCNGradAdapterTemplate wrapped class for adapting to FCNBase signature a IGradFunction ;  CFCNGradientBaseExtension of the FCNBase for providing the analytical Gradient of the function ;  CFumiliBuilderBuilds the FunctionMinimum using the Fumili method ;  CFumiliChi2FCNExtension of the FCNBase for the Fumili method ;  CFumiliErrorUpdatorIn the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives ;  CFumiliFCNAdapterTemplate wrapped class for adapting to FumiliFCNBase signature ;  CFumiliFCNBaseExtension of the FCNBase for the Fumili method ;  CFumiliGradientCalculator;  CFumiliMaximumLikelihoodFCNExtension of the FCNBase for the Fumili method ;  CFumiliMinimizerInstantiates the seed generator ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:61645,adapt,adapting,61645,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['adapt'],['adapting']
Energy Efficiency," @param size maximum number of sub-intervals. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). IntegratorMultiDim(const Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000); Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). virtual ~IntegratorMultiDim(); destructor. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. double Result() const; return result of last integration. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const; return integration error. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IntegratorMultiDim.html:3536,adapt,adaptive,3536,root/html526/ROOT__Math__IntegratorMultiDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IntegratorMultiDim.html,1,['adapt'],['adaptive']
Energy Efficiency," Aurora; 3145 case 67:; 3146 {; 3147 Double_t red[9] = { 46./255., 38./255., 61./255., 92./255., 113./255., 121./255., 132./255., 150./255., 191./255.};; 3148 Double_t green[9] = { 46./255., 36./255., 40./255., 69./255., 110./255., 135./255., 131./255., 92./255., 34./255.};; 3149 Double_t blue[9] = { 46./255., 80./255., 74./255., 70./255., 81./255., 105./255., 165./255., 211./255., 225./255.};; 3150 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3151 }; 3152 break;; 3153 ; 3154 // Avocado; 3155 case 68:; 3156 {; 3157 Double_t red[9] = { 0./255., 4./255., 12./255., 30./255., 52./255., 101./255., 142./255., 190./255., 237./255.};; 3158 Double_t green[9] = { 0./255., 40./255., 86./255., 121./255., 140./255., 172./255., 187./255., 213./255., 240./255.};; 3159 Double_t blue[9] = { 0./255., 9./255., 14./255., 18./255., 21./255., 23./255., 27./255., 35./255., 101./255.};; 3160 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3161 }; 3162 break;; 3163 ; 3164 // Beach; 3165 case 69:; 3166 {; 3167 Double_t red[9] = { 198./255., 206./255., 206./255., 211./255., 198./255., 181./255., 161./255., 171./255., 244./255.};; 3168 Double_t green[9] = { 103./255., 133./255., 150./255., 172./255., 178./255., 174./255., 163./255., 175./255., 244./255.};; 3169 Double_t blue[9] = { 49./255., 54./255., 55./255., 66./255., 91./255., 130./255., 184./255., 224./255., 244./255.};; 3170 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3171 }; 3172 break;; 3173 ; 3174 // Black Body; 3175 case 70:; 3176 {; 3177 Double_t red[9] = { 243./255., 243./255., 240./255., 240./255., 241./255., 239./255., 186./255., 151./255., 129./255.};; 3178 Double_t green[9] = { 0./255., 46./255., 99./255., 149./255., 194./255., 220./255., 183./255., 166./255., 147./255.};; 3179 Double_t blue[9] = { 6./255., 8./255., 36./255., 91./255., 169./255., 235./255., 246./255., 240./255., 233./255.};; 3180 Idx = TColor::CreateGradient",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:120781,green,green,120781,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency," Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » About Project Founders. Rene Brun ; ; Rene, a lifetime developer of ROOT. He joined CERN in 1973. While working with C. Rubbia at the ISR he developped the HBOOK package still in use today. In 1975 he followed Rubbia in the NA4 deep inelastic muon scattering experiment at the SPS where he was in charge of the simulation and reconstruction software and where GEANT1 and GEANT2 were created. In 1981, he joined OPAL at LEP, creating the GEANT3 detector simulation system, also pioneering the introduction of the first workstations like Apollos in Europe. In 1984 he coordinated the development of the PAW (Physics Analysis Workstation) data analysis system. Until 1994 he was in charge of the Application Software group in the computing division. In 1995, at a time when the majority of software gurus had decided to follow a dead-end line, he created the ROOT system while working for the NA49 heavy ion experiment at the SPS. Rene has led the ROOT project from 1995-2010.; ; . Fons Rademakers ; ; Fons received his Ph.D. in particle physics from the Univ. of Amsterdam in 1991 for his work on event displays and data analysis for the DELPHI experiment at CERN's LEP collider. Since then he has worked at CERN and been involved in designing and developing data analysis programs. In 1991 h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/project-founders.html:2150,charge,charge,2150,d/project-founders.html,https://root.cern,https://root.cern/d/project-founders.html,1,['charge'],['charge']
Energy Efficiency," Bool_t newParticle = kTRUE;; gstep.step = 0.1;; gstep.destep = 0;; gstep.nmec = 0;; gstep.pid = 0;; ; //transport particles; for (Int_t i=0;i<10000;i++) {; //generate a new particle if necessary; if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1; if (gRandom->Rndm() < 0.5) charge = -1;; gstep.pid += 1;; gstep.vect[0] = 0;; gstep.vect[1] = 0;; gstep.vect[2] = 0;; gstep.vect[3] = px/p;; gstep.vect[4] = py/p;; gstep.vect[5] = pz/p;; gstep.vect[6] = p*charge;; gstep.getot = TMath::Sqrt(p*p + mass*mass);; gstep.gekin = gstep.getot - mass;; newParticle = kFALSE;; }; ; // fill the Tree with current step parameters; t2.Fill();; ; //transport particle in magnetic field; helixStep(gstep.step, gstep.vect, vout); //make one step; ; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.00001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6] = charge*TMath::Sqrt(gstep.getot*gstep.getot - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0;l<gstep.nmec;l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; ; //save the Tree header. The file will be automatically closed; //when going out of the function scope; t2.Write();; }; ; void tree2r(); {; //read the Tree generated by tree2w and fill one histogram; //we are only interested by the destep branch.; ; //note that we use ""new"" to create the TFile and TTree objects !; //because we want to keep these objects alive when we leave; //this function.; TFile *f = new TFile(""tree2.root"");; TTree *t2 = (TTree*)f->Get(""t2"");; static Float_t destep;; TBranch *b_destep = t2->GetBranch(""destep"");; b_destep->SetAddress(&destep);; ; //create one histog",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree2_8C.html:3861,charge,charge,3861,doc/master/tree2_8C.html,https://root.cern,https://root.cern/doc/master/tree2_8C.html,1,['charge'],['charge']
Energy Efficiency," CERN/SFT,; Jonas Hahnfeld, CERN/SFT,; Emmanouil Michalainas, CERN/SFT,; Stephan Hageboeck, CERN/SFT,; Sergey Linev, GSI,; Javier Lopez-Gomez, CERN/SFT,; Pere Mato, CERN/SFT,; Lorenzo Moneta, CERN/SFT,; Alja Mrak-Tadel, UCSD/CMS,; Axel Naumann, CERN/SFT,; Vincenzo Eduardo Padulano, CERN/SFT and UPV,; Danilo Piparo, CERN/SFT,; Fons Rademakers, CERN/SFT,; Jonas Rembser, CERN/SFT,; Andrea Sciandra, SCIPP-UCSC/Atlas,; Oksana Shadura, UNL/CMS,; Enric Tejedor Saavedra, CERN/SFT,; Christian Tacke, GSI,; Matevz Tadel, UCSD/CMS,; Vassil Vassilev, Princeton/CMS,; Wouter Verkerke, NIKHEF/Atlas,; Stefan Wunsch, CERN/SFT; General; Deprecation and Removal. RooAbsReal::evaluateBatch() has been removed in favour of the faster evaluateSpan(). See section “RooFit Libraries” for instructions on how to use RooAbsReal::evaluateSpan().; TTreeProcessorMT::SetMaxTasksPerFilePerWorker has been deprecated in favour of TTreeProcessorMT::SetTasksPerWorkerHint. Header Dependency Reduction; As always, ROOT tries to reduce the amount of code exposed through its headers. To that end, #includes were replaced by forward declarations in several headers. This might cause compilation errors (“missing definition of type…”) in your code, if that code was relying on indirect includes, instead of including the required headers itself. Please correct that simply by including the required header directly.; Core Libraries; Due to internal changes required to comply with the deprecation of Intel TBB’s task_scheduler_init and related interfaces in recent TBB versions, as of v6.24 ROOT will not honor a maximum concurrency level set with tbb::task_scheduler_init but will require instead the usage of tbb::global_control:; //tbb::task_scheduler_init init(2); // does not affect the number of threads ROOT will use anymore. tbb::global_control c(tbb::global_control::max_allowed_parallelism, 2);; ROOT::TThreadExecutor p1; // will use 2 threads; ROOT::TThreadExecutor p2(/*nThreads=*/8); // will still use 2 threads; Note ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:2937,reduce,reduce,2937,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['reduce'],['reduce']
Energy Efficiency, Carlo study manager add-on module; RooAbsNumGenerator Abstract base class for numeric event generator algorithms; RooAbsOptTestStatistic Abstract base class for optimized test statistics; RooAbsPdf Abstract PDF with normalization support; RooAbsProxy Abstract proxy interface; RooAbsReal Abstract real-valued variable; RooAbsRealLValue Abstract modifiable real-valued object; RooAbsRootFinder Abstract interface for 1-dim real-valued function root finders; RooAbsSelfCachedPdf Abstract base class for self-caching p.d.f.s; RooAbsSelfCachedReal Abstract base class for self-caching functions; RooAbsString Abstract string-valued variable; RooAbsTestStatistic Abstract base class for real-valued test statistics; RooAcceptReject Context for generating a dataset from a PDF; RooAdaptiveGaussKronrodIntegrator1D 1-dimensional adaptive Gauss-Kronrod numerical integration engine; RooAdaptiveIntegratorND N-dimensional adaptive integration (interface to MathCore integrator); RooAddGenContext Specialized context for generating a dataset from a RooAddPdf; RooAddModel Resolution model representing a sum of resolution models; RooAddPdf PDF representing a sum of PDFs; RooAddition Sum of RooAbsReal objects; RooArgList Ordered list of RooAbsArg objects; RooArgProxy Abstract proxy for RooAbsArg objects; RooArgSet Set of RooAbsArg objects; RooArgusBG Argus background shape PDF; RooBCPEffDecay B Mixing decay PDF; RooBCPGenDecay B decay time distribution with CP violation; RooBDecay P.d.f of general description of B decay time distribution; RooBMixDecay B Mixing decay PDF; RooBernstein Bernstein polynomial PDF; RooBifurGauss Bifurcated Gaussian PDF; RooBinning Generic binning specification; RooBinningCategory RealVar-to-Category function defined by bin boundaries on input var; RooBlindTools Root implementation of BlindTools; RooBreitWigner Breit Wigner PDF; RooBrentRootFinder Abstract interface for 1-dim real-valued function root finders; RooBukinPdf Variation of Novosibirsk PDF; RooCBShape Cryst,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:24971,adapt,adaptive,24971,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,2,['adapt'],['adaptive']
Energy Efficiency," Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorMultiDim.html:3395,adapt,adaptive,3395,root/html528/ROOT__Math__IntegratorMultiDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorMultiDim.html,10,['adapt'],['adaptive']
Energy Efficiency," Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. _Input parameters:. x[2], y[2] : Segment coordinates; xclipl, yclipb, xclipr, yclipt : Clipping boundary. _Output parameters:. x[2], y[2] : New segment coordinates. Int_t ClippingCode(Double_t x, Double_t y, Double_t xcl1, Double_t ycl1, Double_t xcl2, Double_t ycl2); Compute the endpoint codes for TPad::Clip. Int_t ClipPolygon(Int_t n, Double_t* x, Double_t* y, Int_t nn, Double_t* xc, Double_t* yc, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); Clip polygon using the Sutherland-Hodgman algorithm. Input parameters:. n: Number of points in the polygon to be clipped; x[n], y[n] : Polygon do be clipped vertices; xclipl, yclipb, xclipr, yclipt : Clipping boundary. Output parameters:. nn: number of points in xc and yc; xc, yc: clipped polygon vertices. The Int_t returned by this function is; the number of points in the clipped polygon. These vectors must; be allocated by the calling function. A size of 2*n for each is; enough. Sutherland and Hodgman's polygon-clipping algorithm uses a divide-and-conquer; strategy: It solves a series of simple and identical problems that, when; combined, solve the overall problem. The simple problem is to clip a polygon; against a single infinite clip edge. Four clip edges, each defining one boundary; of the clip rectangle, successively clip a polygon against a clip rectangle. Steps of Sutherland-Hodgman's polygon-clipping algorithm:. * Polygons can be clipped against each edge of the window one at a time.; Windows/edge intersections, if any, are easy to find since the X or Y coordinates; are already known.; * Vertices which are kept after clipping against one window edge are saved for; clipping against the remaining edges.; * Note that the number of vertices usually changes and will often increases. The clip boundary determines a visible and invisible region. The edges from; vertex i to vertex i+1 can be one of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPad.html:34022,allocate,allocated,34022,root/html528/TPad.html,https://root.cern,https://root.cern/root/html528/TPad.html,10,['allocate'],['allocated']
Energy Efficiency," Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tfTextMagnitudeText Magnitude; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; DrawablefVisRootWinRoot window with fVisual to be used to create GC's and XImages; RVisual*fVisualPointer to visual used by all windows; ULong_tfWhitePixelValue of white pixel in colormap. private:. TExMap*fColorsHash list of colors; CursorfCursors[19]List of cursors; Int_tfMaxNumberOfWindowsMaximum number of windows; XWindow_t*fWindowsList of windows; void*fXEventCurrent native (X11) event. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGX11(); Default constructor. TGX11(const char* name, const char* title); Normal Constructor. TGX11(const TGX11& org); Copy constructor. Currently only used by TGX11TTF. ~TGX11(); Destructor. Bool_t Init(void* display); Initialize X11 system. Returns kFALSE in case of failure. Bool_t AllocColor(Colormap cmap, RXColor* color); Allocate color in colormap. If we are on an <= 8 plane machine; we will use XAllocColor. If we are on a >= 15 (15, 16 or 24) plane; true color machine we will calculate the pixel value using:; for 15 and 16 bit true colors have 6 bits precision per color however; only the 5 most significant bits are used in the color index.; Except for 16 bits where green uses all 6 bits. I.e.:; 15 bits = rrrrrgggggbbbbb; 16 bits = rrrrrggggggbbbbb; for 24 bits each r, g and b are represented by 8 bits. Since all colors are set with a max of 65535 (16 bits) per r, g, b; we just right shift them by 10, 11 and 10 bits for 16 planes, and; (10, 10, 10 for 15 planes) and by 8 bits for 24 planes.; Returns kFALSE in case color allocation failed. void QueryColors(Colormap cmap, RXColor* colors, Int_t ncolors); Returns the current RGB value for the pixel in the XColor structure. void ClearPixmap(Drawable* pix); Clear the pixmap pix. void ClearWindow(); Clear current window. void ClosePixmap(); Delet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGX11.html:26691,Allocate,Allocate,26691,root/html602/TGX11.html,https://root.cern,https://root.cern/root/html602/TGX11.html,2,['Allocate'],['Allocate']
Energy Efficiency," Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. TGenericTable(); {SetType(""generic"");}. TGenericTable(const char* structName, const char* name); Create TGenericTable by C structure name provided. char * GetTable(Int_t i = 0) const; { return ((char *)GetArray())+i*GetRowSize();}. TTableDescriptor * GetTableDescriptors() const; { return GetDescriptorPointer();}. TTableDescriptor * GetRowDescriptors() const; { return GetDescriptorPointer();}. char & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const char & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const char *)(GetTable(i))); }. iterator begin(); { return ((const TGenericTable *)this)->begin();}. iterator b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGenericTable.html:17564,allocate,allocated,17564,root/html528/TGenericTable.html,https://root.cern,https://root.cern/root/html528/TGenericTable.html,6,['allocate'],['allocated']
Energy Efficiency," Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. iterator & operator=(const TGenericTable& ); { fRowSize = iter.fRowSize; fCurrentRow = iter.fCurrentRow; return *this;}. TGenericTable(); {SetType(""generic"");}. TGenericTable(const char* structName, const char* name); Create TGenericTable by C structure name provided. char * GetTable(Int_t i = 0) const; { return ((char *)GetArray())+i*GetRowSize();}. TTableDescriptor * GetTableDescriptors() const; { return GetDescriptorPointer();}. TTableDescriptor * GetRowDescriptors() const; { return GetDescriptorPointer();}. char & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const char & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGenericTable.html:19060,allocate,allocated,19060,root/html602/TGenericTable.html,https://root.cern,https://root.cern/root/html602/TGenericTable.html,4,['allocate'],['allocated']
Energy Efficiency," Dark Terrain; 3255 case 78:; 3256 {; 3257 Double_t red[9] = { 0./255., 41./255., 62./255., 79./255., 90./255., 87./255., 99./255., 140./255., 228./255.};; 3258 Double_t green[9] = { 0./255., 57./255., 81./255., 93./255., 85./255., 70./255., 71./255., 125./255., 228./255.};; 3259 Double_t blue[9] = { 95./255., 91./255., 91./255., 82./255., 60./255., 43./255., 44./255., 112./255., 228./255.};; 3260 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3261 }; 3262 break;; 3263 ; 3264 // Fall; 3265 case 79:; 3266 {; 3267 Double_t red[9] = { 49./255., 59./255., 72./255., 88./255., 114./255., 141./255., 176./255., 205./255., 222./255.};; 3268 Double_t green[9] = { 78./255., 72./255., 66./255., 57./255., 59./255., 75./255., 106./255., 142./255., 173./255.};; 3269 Double_t blue[9] = { 78./255., 55./255., 46./255., 40./255., 39./255., 39./255., 40./255., 41./255., 47./255.};; 3270 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3271 }; 3272 break;; 3273 ; 3274 // Fruit Punch; 3275 case 80:; 3276 {; 3277 Double_t red[9] = { 243./255., 222./255., 201./255., 185./255., 165./255., 158./255., 166./255., 187./255., 219./255.};; 3278 Double_t green[9] = { 94./255., 108./255., 132./255., 135./255., 125./255., 96./255., 68./255., 51./255., 61./255.};; 3279 Double_t blue[9] = { 7./255., 9./255., 12./255., 19./255., 45./255., 89./255., 118./255., 146./255., 118./255.};; 3280 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3281 }; 3282 break;; 3283 ; 3284 // Fuchsia; 3285 case 81:; 3286 {; 3287 Double_t red[9] = { 19./255., 44./255., 74./255., 105./255., 137./255., 166./255., 194./255., 206./255., 220./255.};; 3288 Double_t green[9] = { 19./255., 28./255., 40./255., 55./255., 82./255., 110./255., 159./255., 181./255., 220./255.};; 3289 Double_t blue[9] = { 19./255., 42./255., 68./255., 96./255., 129./255., 157./255., 188./255., 203./255., 220./255.};; 3290 Idx = TColor::CreateGradientColorTable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:126548,green,green,126548,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency," Data Members; public:. enum TFileHandler::[unnamed] { kRead; kWrite; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intTFileHandler::fFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intTFileHandler::fMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intTFileHandler::fReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TFileHandler*fHandlerHandler associated to the input socket; TSocket*fInputSockInput socket from client or master; static TXSocketHandler*fgSocketHandlerInput socket handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t Notify(); Set readiness on the monitor. TXSocketHandler * GetSocketHandler(TFileHandler* h = 0, TSocket* s = 0); Get an instance of the input socket handler with 'h' as handler,; connected to socket 's'.; Create the instance, if not already existing. void SetHandler(TFileHandler* h, TSocket* s); { fHandler = h; fInputSock = s; }. TXSocketHandler(TFileHandler* h, TSocket* s); { fHandler = h; fInputSock = s; }. virtual ~TXSocketHandler(); { }. Bool_t ReadNotify(); { return Notify(); }. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXSocketHandler.h 26678 2008-12-05 14:53:23Z ganis $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXSocketHandler.html:10415,monitor,monitor,10415,root/html528/TXSocketHandler.html,https://root.cern,https://root.cern/root/html528/TXSocketHandler.html,1,['monitor'],['monitor']
Energy Efficiency," Data Members; public:. enum TFileHandler::[unnamed] { kRead; kWrite; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intTFileHandler::fFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intTFileHandler::fMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intTFileHandler::fReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TFileHandler*fHandlerHandler associated to the input socket; TSocket*fInputSockInput socket from client or master; static TXSocketHandler*fgSocketHandlerInput socket handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t Notify(); Set readiness on the monitor. TXSocketHandler * GetSocketHandler(TFileHandler* h = 0, TSocket* s = 0); Get an instance of the input socket handler with 'h' as handler,; connected to socket 's'.; Create the instance, if not already existing. void SetHandler(TFileHandler* h, TSocket* s); { fHandler = h; fInputSock = s; }. TXSocketHandler(TFileHandler* h, TSocket* s); { fHandler = h; fInputSock = s; }. virtual ~TXSocketHandler(); { }. Bool_t ReadNotify(); { return Notify(); }. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXSocketHandler.h 26678 2008-12-05 14:53:23Z ganis $ » Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXSocketHandler.html:10484,monitor,monitor,10484,root/html530/TXSocketHandler.html,https://root.cern,https://root.cern/root/html530/TXSocketHandler.html,1,['monitor'],['monitor']
Energy Efficiency," Data Members; public:. enum TFileHandler::[unnamed] { kRead; kWrite; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intTFileHandler::fFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intTFileHandler::fMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intTFileHandler::fReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TFileHandler*fHandlerHandler associated to the input socket; TSocket*fInputSockInput socket from client or master; static TXSocketHandler*fgSocketHandlerInput socket handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t Notify(); Set readiness on the monitor. TXSocketHandler * GetSocketHandler(TFileHandler* h = 0, TSocket* s = 0); Get an instance of the input socket handler with 'h' as handler,; connected to socket 's'.; Create the instance, if not already existing. void SetHandler(TFileHandler* h, TSocket* s); { fHandler = h; fInputSock = s; }. TXSocketHandler(TFileHandler* h, TSocket* s); { fHandler = h; fInputSock = s; }. virtual ~TXSocketHandler(); { }. Bool_t ReadNotify(); { return Notify(); }. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXSocketHandler.h 26678 2008-12-05 14:53:23Z ganis $ » Last generated: 2011-12-02 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXSocketHandler.html:10484,monitor,monitor,10484,root/html532/TXSocketHandler.html,https://root.cern,https://root.cern/root/html532/TXSocketHandler.html,2,['monitor'],['monitor']
Energy Efficiency," Deconstructor. ; Definition at line 326 of file TGondzioSolver.cxx. Member Function Documentation. ◆ Class(). static TClass * TGondzioSolver::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGondzioSolver::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGondzioSolver::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 103 of file TGondzioSolver.h. ◆ DeclFileName(). static const char * TGondzioSolver::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 103 of file TGondzioSolver.h. ◆ DefMonitor(). void TGondzioSolver::DefMonitor ; (; TQpDataBase * ; data, . TQpVar * ; vars, . TQpResidual * ; resids, . Double_t ; alpha, . Double_t ; sigma, . Int_t ; i, . Double_t ; mu, . Int_t ; status_code, . Int_t ; level . ). overridevirtual . Print information about the optimization process and monitor the convergence status of thye algorithm. ; Implements TQpSolverBase.; Definition at line 276 of file TGondzioSolver.cxx. ◆ IsA(). TClass * TGondzioSolver::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 103 of file TGondzioSolver.h. ◆ operator=(). TGondzioSolver & TGondzioSolver::operator= ; (; const TGondzioSolver & ; source). Assignment operator. ; Definition at line 337 of file TGondzioSolver.cxx. ◆ Reset_parameters(). virtual void TGondzioSolver::Reset_parameters ; (; ). inlinevirtual . Definition at line 95 of file TGondzioSolver.h. ◆ Solve(). Int_t TGondzioSolver::Solve ; (; TQpDataBase * ; prob, . TQpVar * ; iterate, . TQpResidual * ; resid . ). overridevirtual . Solve the quadratic programming problem as formulated through prob, store the final solution in iterate->fX . ; Monitor the residuals during the iterations through resid . The status is returned as defined in TQpSolverBase::E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGondzioSolver.html:15695,monitor,monitor,15695,doc/master/classTGondzioSolver.html,https://root.cern,https://root.cern/doc/master/classTGondzioSolver.html,1,['monitor'],['monitor']
Energy Efficiency," Define new text attributes for the label value ""labValue"". ; It allows to do a fine tuning of the labels. All the attributes can be changed, even the label text itself.; Parameters. [in]labValueAxis value to be changed ; [in]labAngleNew angle value ; [in]labSizeNew size (0 erase the label) ; [in]labAlignNew alignment value ; [in]labColorNew label color ; [in]labFontNew label font ; [in]labTextNew label text. Example:; {; auto c = new TCanvas(""c1"",""Examples of TGaxis"",900,100);; c->Range(-6,-0.1,6,0.1);; auto *axis = new TGaxis(-5.5,0.,5.5,0.,0.0,100,510,""S"");; axis->SetName(""axis1"");; axis->SetTitle(""Axis Title"");; axis->SetTitleSize(0.2);; axis->SetLabelSize(0.2);; axis->SetTickSize(0.15);; axis->SetTitleColor(kBlue);; axis->SetTitleFont(42);; axis->ChangeLabelByValue(0., -1, -1, -1, kRed);; axis->ChangeLabelByValue(20., -1, 0);; axis->ChangeLabelByValue(40., 30.);; axis->ChangeLabelByValue(50., -1, -1, -1, kBlue, -1, ""blue for 50."");; axis->ChangeLabelByValue(90., -1, -1, -1, kGreen, -1, ""green for 90."");; axis->Draw();; }; kGreen@ kGreenDefinition Rtypes.h:66. Notes:. If an attribute should not be changed just give the value ""-1"".; To erase a label set labSize to 0; If labText is not specified or is an empty string, the text label is not changed. . Definition at line 2813 of file TGaxis.cxx. ◆ Class(). static TClass * TGaxis::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGaxis::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGaxis::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 136 of file TGaxis.h. ◆ CleanupModLabs(). void TGaxis::CleanupModLabs ; (; ). protected . Correctly cleanup fModLabs - delete content when owned by TGaxis. ; Definition at line 881 of file TGaxis.cxx. ◆ DeclFileName(). static const char * TGaxis::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declarati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGaxis.html:65124,green,green,65124,doc/master/classTGaxis.html,https://root.cern,https://root.cern/doc/master/classTGaxis.html,1,['green'],['green']
Energy Efficiency," Definition at line 2374 of file TGraph.cxx. ◆ SetStats(). void TGraph::SetStats ; (; Bool_t ; stats = kTRUE). virtual . Set statistics option on/off. ; By default, the statistics box is drawn. The paint options can be selected via gStyle->SetOptStat. This function sets/resets the kNoStats bit in the graph object. It has priority over the Style option. ; Definition at line 2431 of file TGraph.cxx. ◆ SetTitle(). void TGraph::SetTitle ; (; const char * ; title = """"). overridevirtual . Change (i.e. ; set) the title; if title is in the form stringt;stringx;stringy;stringz the graph title is set to stringt, the x axis title to stringx, the y axis title to stringy, and the z axis title to stringz.; To insert the character ; in one of the titles, one should use #; or #semicolon. ; Reimplemented from TNamed.; Definition at line 2397 of file TGraph.cxx. ◆ ShrinkAndCopy(). Double_t ** TGraph::ShrinkAndCopy ; (; Int_t ; size, . Int_t ; oend . ). protected . if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ; Return newarray (passed or new instance if it was zero and allocations are needed) ; Definition at line 2453 of file TGraph.cxx. ◆ Sort(). void TGraph::Sort ; (; Bool_t(*)(const TGraph *, Int_t, Int_t) ; greaterfunc = &TGraph::CompareX, . Bool_t ; ascending = kTRUE, . Int_t ; low = 0, . Int_t ; high = -1111 . ). virtual . Sorts the points of this TGraph using in-place quicksort (see e.g. ; older glibc). To compare two points the function parameter greaterfunc is used (see TGraph::CompareX for an example of such a method, which is also the default comparison function for Sort). After the sort, greaterfunc(this, i, j) will return kTRUE for all i>j if ascending == kTRUE, and kFALSE otherwise.; The last two parameters are used for the recursive quick sort, stating the range to be sorted; Examples: // sort points along x axis; graph->Sort();; // sort points along their distance to origin; graph->Sort(&TGraph::CompareRadius);; ; Bool_t CompareErrors",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph.html:72714,allocate,allocate,72714,doc/master/classTGraph.html,https://root.cern,https://root.cern/doc/master/classTGraph.html,1,['allocate'],['allocate']
Energy Efficiency," Definition at line 350 of file TFileMerger.cxx. ◆ OutputFile() [5/5]. Bool_t TFileMerger::OutputFile ; (; std::unique_ptr< TFile > ; file). virtual . Set an output file opened externally by the users. ; Definition at line 318 of file TFileMerger.cxx. ◆ PartialMerge(). Bool_t TFileMerger::PartialMerge ; (; Int_t ; in_type = kAll | kIncremental). virtual . Merge the files. ; If no output file was specified it will write into the file ""FileMerger.root"" in the working directory. Returns true on success, false in case of error. The type is defined by the bit values in EPartialMergeType: kRegular : normal merge, overwritting the output file kIncremental : merge the input file with the content of the output file (if already exising) (default) kResetable : merge only the objects with a MergeAfterReset member function. kNonResetable : merge only the objects without a MergeAfterReset member function. kDelayWrite : delay the TFile write (to reduce the number of write when reusing the file) kAll : merge all type of objects (default) kAllIncremental : merge incrementally all type of objects. kOnlyListed : merge only the objects specified in fObjectNames list kSkipListed : skip objects specified in fObjectNames list kKeepCompression: keep compression level unchanged for each input; If the type is not set to kIncremental, the output file is deleted at the end of this operation. ; Definition at line 926 of file TFileMerger.cxx. ◆ PrintFiles(). void TFileMerger::PrintFiles ; (; Option_t * ; options). virtual . Print list of files being merged. ; Definition at line 360 of file TFileMerger.cxx. ◆ RecursiveRemove(). void TFileMerger::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Intercept the case where the output TFile is deleted! ; Reimplemented from TObject.; Definition at line 1087 of file TFileMerger.cxx. ◆ Reset(). void TFileMerger::Reset ; (; ). virtual . Reset merger file list. ; Definition at line 119 of file TFileMerger.cxx. ◆ SetCWD(). virtual Bool_t TFileMerger:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileMerger.html:24383,reduce,reduce,24383,doc/master/classTFileMerger.html,https://root.cern,https://root.cern/doc/master/classTFileMerger.html,1,['reduce'],['reduce']
Energy Efficiency," Double_t &sy, Double_t &syErr);  This function gets the tail parameters and their errors. ;  ; void GetVolumeErrors (Double_t *volumeErrors);  This function gets errors of the volumes of fitted 2D peaks. ;  ; void GetVolumes (Double_t *volumes);  This function gets the volumes of fitted 2D peaks. ;  ; TClass * IsA () const override;  ; void SetBackgroundParameters (Double_t a0Init, Bool_t fixA0, Double_t axInit, Bool_t fixAx, Double_t ayInit, Bool_t fixAy);  This function sets the following fitting parameters of background: ;  ; void SetFitParameters (Int_t xmin, Int_t xmax, Int_t ymin, Int_t ymax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor);  This function sets the following fitting parameters: ;  ; void SetPeakParameters (Double_t sigmaX, Bool_t fixSigmaX, Double_t sigmaY, Bool_t fixSigmaY, Double_t ro, Bool_t fixRo, const Double_t *positionInitX, const Bool_t *fixPositionX, const Double_t *positionInitY, const Bool_t *fixPositionY, const Double_t *positionInitX1, const Bool_t *fixPositionX1, const Double_t *positionInitY1, const Bool_t *fixPositionY1, const Double_t *ampInit, const Bool_t *fixAmp, const Double_t *ampInitX1, const Bool_t *fixAmpX1, const Double_t *ampInitY1, const Bool_t *fixAmpY1);  This function sets the following fitting parameters of peaks: ;  ; void SetTailParameters (Double_t tInitXY, Bool_t fixTxy, Double_t tInitX, Bool_t fixTx, Double_t tInitY, Bool_t fixTy, Double_t bInitX, Bool_t fixBx, Double_t bInitY, Bool_t fixBy, Double_t sInitXY, Bool_t fixSxy, Double_t sInitX, Bool_t fixSx, Double_t sInitY, Bool_t fixSy);  This function sets the following fitting parameters of tails of peaks. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TName",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:5421,power,power,5421,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['power'],['power']
Energy Efficiency," Double_tTQpSolverBase::fPhimerit function, defined as the sum of the complementarity gap; Double_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStepstorage for step vectors; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMehrotraSolver(); Default constructor. TMehrotraSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TMehrotraSolver(const TMehrotraSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TMehrotraSolver(); Deconstructor. TMehrotraSolver & operator=(const TMehrotraSolver& source); Assignment operator. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TMehrotraSolver.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMehrotraSolver.html:8730,monitor,monitor,8730,root/html528/TMehrotraSolver.html,https://root.cern,https://root.cern/root/html528/TMehrotraSolver.html,1,['monitor'],['monitor']
Energy Efficiency," Double_tTQpSolverBase::fPhimerit function, defined as the sum of the complementarity gap; Double_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStepstorage for step vectors; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMehrotraSolver(); Default constructor. TMehrotraSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TMehrotraSolver(const TMehrotraSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TMehrotraSolver(); Deconstructor. TMehrotraSolver & operator=(const TMehrotraSolver& source); Assignment operator. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TMehrotraSolver.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMehrotraSolver.html:8799,monitor,monitor,8799,root/html530/TMehrotraSolver.html,https://root.cern,https://root.cern/root/html530/TMehrotraSolver.html,1,['monitor'],['monitor']
Energy Efficiency," Double_tTQpSolverBase::fPhimerit function, defined as the sum of the complementarity gap; Double_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStepstorage for step vectors; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMehrotraSolver(); Default constructor. TMehrotraSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TMehrotraSolver(const TMehrotraSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TMehrotraSolver(); Deconstructor. TMehrotraSolver & operator=(const TMehrotraSolver& source); Assignment operator. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TMehrotraSolver.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMehrotraSolver.html:8799,monitor,monitor,8799,root/html532/TMehrotraSolver.html,https://root.cern,https://root.cern/root/html532/TMehrotraSolver.html,3,"['Monitor', 'monitor']","['Monitor', 'monitor']"
Energy Efficiency," EY; format = ""%lg %lg %lg %lg"" read only 4 first columns into X,Y,EX,EY. ~TGraphErrors(); TGraphErrors default destructor. void Apply(TF1* f); apply function to all the data points; y = f(x,y). The error is calculated as ey=(f(x,y+ey)-f(x,y-ey))/2; This is the same as error(fy) = df/dy * ey for small errors. For generic functions the symmetric errors might become non-symmetric; and are averaged here. Use TGraphAsymmErrors if desired. error on x doesn't change; function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>. Int_t CalculateScanfFields(const char* fmt); Calculate scan fields. void ComputeRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Compute range. void CopyAndRelease(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin); Copy and release. Bool_t CopyPoints(Double_t** arrays, Int_t ibegin, Int_t iend, Int_t obegin); Copy errors from fEX and fEY to arrays[0] and arrays[1]; or to fX and fY. Copy points. Bool_t CtorAllocate(); Constructor allocate. void FillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); Set zero values for point arrays in the range [begin, end]. Double_t GetErrorX(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorY(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along Y at point i. Double_t GetErrorXhigh(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorXlow(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorYhigh(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorYlow(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. void Print(Option_t* chopt = """") const; Print graph and errors values. void SavePrimitiv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphErrors.html:17440,allocate,allocate,17440,root/html528/TGraphErrors.html,https://root.cern,https://root.cern/root/html528/TGraphErrors.html,2,['allocate'],['allocate']
Energy Efficiency," Entries; For each TTree entry, you will add the current event's size to the data member. This, too, happens in Process() - after you have set the current event from the TTree. After the TSelector has processed the tree it will thus contain the sum of all event sizes.; Bool_t EventSelector::Process(Long64_t entry); {; //... // Tell the TTree reader to get the data for; // the entry number ""entry"" in the current tree:; fReader.SetLocalEntry(entry);. // We can still print some informations about the current event; //printf(""Size of Event %ld = %d Bytes\n"", entry, *fCurrentEventSize);. // compute the total size of all events; dereference the TTreeReaderValue; // using '*' to get the value it refers to, just like an iterator.; fTotalDataSize += *fCurrentEventSize;. return kTRUE;; }. Accessing the Analysis Result; In your selector's Terminate() function, print the sum of all event sizes. This sum shows you the real power of a TTree: even though you can analyze large amounts of data (our example tree with 22MB is tiny!) ROOT needs just a few MB of your RAM, no matter how many events you analyze. Imagine what it would be like if you had to load all data into memory, e.g. using a simple vector!; void EventSelector::Terminate(); {; // ... int sizeInMB = fTotalDataSize/1024/1024;; printf(""Total size of all events: %d MB\n"", sizeInMB);; }. If, for any reason, you don't manage to get it to work, you can download a working selector file here: CountEventSelector.C; Here again, if you are using ROOT via ssh, you have to download the file with wget from your remote directory:; wget http://root-mirror.github.io/training/intro/CountEventSelector.C; Note: You will have to use it that way:; EventTree->Process(""CountEventSelector.C""). . ‹ Compiling Your Code (also known as ACLiC); up; Histogramming in a Selector ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/accessing-ttree-tselector.html:7972,power,power,7972,d/accessing-ttree-tselector.html,https://root.cern,https://root.cern/d/accessing-ttree-tselector.html,1,['power'],['power']
Energy Efficiency," Enumeration Documentation. ◆ anonymous enum. anonymous enum. private . EnumeratorkIsOnHeap object is on heap . Definition at line 43 of file TStorage.h. Constructor & Destructor Documentation. ◆ ~TStorage(). virtual TStorage::~TStorage ; (; ). inlinevirtual . Definition at line 52 of file TStorage.h. Member Function Documentation. ◆ Alloc(). void * TStorage::Alloc ; (; size_t ; size). static . Allocate a block of memory, that later can be resized using TStorage::ReAlloc(). ; Definition at line 152 of file TStorage.cxx. ◆ Class(). static TClass * TStorage::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TStorage::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TStorage::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 85 of file TStorage.h. ◆ Dealloc(). void TStorage::Dealloc ; (; void * ; ptr). static . De-allocate block of memory, that was allocated via TStorage::Alloc(). ; Definition at line 170 of file TStorage.cxx. ◆ DeclFileName(). static const char * TStorage::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 85 of file TStorage.h. ◆ EnableStatistics(). void TStorage::EnableStatistics ; (; int ; size = -1, . int ; ix = -1 . ). static . Enable memory usage statistics gathering. ; Size is the size of the memory block that should be trapped and ix is after how many such allocations the trap should happen. ; Definition at line 412 of file TStorage.cxx. ◆ EnterStat(). void TStorage::EnterStat ; (; size_t ; size, . void * ; p . ). static . Register a memory allocation operation. ; If desired one can trap an allocation of a certain size in case one tries to find a memory leak of that particular size. This function is only called via the ROOT custom new operators. ; Definition at line 99 of file TStorage.cxx. ◆ FilledByObjectAlloc(). Bool_t TStorage::FilledB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStorage.html:5185,allocate,allocate,5185,doc/master/classTStorage.html,https://root.cern,https://root.cern/doc/master/classTStorage.html,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency," GdkColor *colors, Int_t ncolors);  Returns the current RGB value for the pixel in the XColor structure. ;  ; void UpdateFillColor ();  ; void UpdateFillStyle ();  Set fill area style index. ;  ; void UpdateLineColor ();  ; void UpdateLineStyle ();  Update line style. ;  ; void UpdateMarkerColor ();  ; void UpdateMarkerStyle ();  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Int_t fBlueDiv;  Blue value divider. ;  ; Int_t fBlueShift;  Bits to left shift blue. ;  ; Float_t fCharacterUpX;  Character Up vector along X. ;  ; Float_t fCharacterUpY;  Character Up vector along Y. ;  ; GdkColormap * fColormap;  Default colormap, 0 if b/w. ;  ; Int_t fDepth;  Number of color planes. ;  ; Bool_t fFillColorModified;  ; Bool_t fFillStyleModified;  ; Int_t fGreenDiv;  Green value divider. ;  ; Int_t fGreenShift;  Bits to left shift green. ;  ; Bool_t fHasTTFonts;  True when TrueType fonts are used. ;  ; Bool_t fLineColorModified;  ; Bool_t fMarkerColorModified;  ; Bool_t fMarkerStyleModified;  ; Bool_t fPenModified;  line syle || width modified ;  ; Int_t fRedDiv;  Red value divider, -1 if no TrueColor visual. ;  ; Int_t fRedShift;  Bits to left shift red, -1 if no TrueColor visual. ;  ; TObject * fRefreshTimer;  TGWin32RefreshTimer for GUI thread message handler. ;  ; Int_t fScreenNumber;  Screen number. ;  ; Int_t fTextAlign;  Text alignment (set in SetTextAlign) ;  ; Int_t fTextAlignH;  Text Alignment Horizontal. ;  ; Int_t fTextAlignV;  Text Alignment Vertical. ;  ; Float_t fTextMagnitude;  Text Magnitude. ;  ; Bool_t fUseSysPointers;  True when using system mouse pointers. ;  ; GdkVisual * fVisual;  ; Handle_t fXEvent;  Current native (GDK) event. ;  ;  Protected Attributes inherited from TVirtualX; EDrawMode fDrawMode;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TStr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:46562,green,green,46562,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['green'],['green']
Energy Efficiency," GetCheckSum(ECheckSum code=kCurrentCheckSum) constCall GetCheckSum with validity check.Definition TClass.cxx:6572; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::GetDataMemberTDataMember * GetDataMember(const char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3506; TClass::CanSplitBool_t CanSplit() constReturn true if the data member of this TClass can be saved separately.Definition TClass.cxx:2386; TClass::GetCollectionTypeROOT::ESTLType GetCollectionType() constReturn the 'type' of the STL the TClass is representing.Definition TClass.cxx:2953; TClass::GetStreamerInfoAbstractEmulatedTVirtualStreamerInfo * GetStreamerInfoAbstractEmulated(Int_t version=0) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4776; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::CopyCollectionProxyvoid CopyCollectionProxy(const TVirtualCollectionProxy &)Replaces the collection proxy for this class.Definition TClass.cxx:2537; TClass::HasCustomStreamerMemberBool_t HasCustomStreamerMember() constThe class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based...Definition TClass.h:508; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2981; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:281870,allocate,allocated,281870,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". EFisherMethod GetFisherMethod( void ); { return fFisherMethod; }. » Author: Andreas Hoecker, Xavier Prudent, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodFisher.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-12-10 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodFisher.html:20958,power,power,20958,root/html528/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodFisher.html,1,['power'],['power']
Energy Efficiency," GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". EFisherMethod GetFisherMethod( void ); { return fFisherMethod; }. » Author: Andreas Hoecker, Xavier Prudent, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodFisher.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodFisher.html:21578,power,power,21578,root/html530/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodFisher.html,1,['power'],['power']
Energy Efficiency," GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". EFisherMethod GetFisherMethod( void ); { return fFisherMethod; }. » Author: Andreas Hoecker, Xavier Prudent, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodFisher.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodFisher.html:21578,power,power,21578,root/html532/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodFisher.html,2,['power'],['power']
Energy Efficiency," GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodFisher(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""Fisher"", TDirectory* theTargetDir = 0). EFisherMethod GetFisherMethod( void ); { return fFisherMethod; }. » Author: Andreas Hoecker, Xavier Prudent, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodFisher.html:22885,power,power,22885,root/html604/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html,2,['power'],['power']
Energy Efficiency," GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodFisher(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""Fisher"", TDirectory* theTargetDir = 0). EFisherMethod GetFisherMethod( void ); { return fFisherMethod; }. » Author: Andreas Hoecker, Xavier Prudent, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:16; This page has been automa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodFisher.html:22877,power,power,22877,root/html602/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodFisher.html,2,['power'],['power']
Energy Efficiency," GetFunctionDeleteTwoIterators(Bool_t read=kTRUE)=0; TVirtualCollectionProxy::Sizevirtual UInt_t Size() const =0Return the current number of elements in the container.; TVirtualCollectionProxy::NewArrayvirtual void * NewArray(Int_t nElements) constConstruct an array of nElements container objects and return the base address of the array.Definition TVirtualCollectionProxy.h:126; TVirtualCollectionProxy::DeleteTwoIterators_tvoid(* DeleteTwoIterators_t)(void *begin, void *end)Definition TVirtualCollectionProxy.h:245; TVirtualCollectionProxy::DeleteIterator_tvoid(* DeleteIterator_t)(void *iter)If the size of the iterator is greater than fgIteratorArenaSize, call delete on the addresses; otherw...Definition TVirtualCollectionProxy.h:244; TVirtualCollectionProxy::Newvirtual void * New(void *arena) constConstruct a new container object at the address given by arenaDefinition TVirtualCollectionProxy.h:113; TVirtualCollectionProxy::fgIteratorArenaSizestatic const Int_t fgIteratorArenaSizeThe size of a small buffer that can be allocated on the stack to store iterator-specific information.Definition TVirtualCollectionProxy.h:207; TVirtualCollectionProxy::Generatevirtual TVirtualCollectionProxy * Generate() const =0Returns a clean object of the actual class that derives from TVirtualCollectionProxy.; TVirtualCollectionProxy::Resetvirtual Bool_t Reset()Reset the information gathered from StreamerInfos and value's TClass.Definition TVirtualCollectionProxy.h:95; TVirtualCollectionProxy::fPropertiesUInt_t fPropertiesDefinition TVirtualCollectionProxy.h:59; TVirtualCollectionProxy::GetFunctionCreateIteratorsvirtual CreateIterators_t GetFunctionCreateIterators(Bool_t read=kTRUE)=0Return a pointer to a function that can create an iterator pair, where each iterator points to the be...; TVirtualCollectionProxy::NewObjectArrayvirtual TClass::ObjectPtr NewObjectArray(Int_t nElements, void *arena) constConstruct an array of nElements container objects at the address given by arenaDefinitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:22554,allocate,allocated,22554,doc/master/TVirtualCollectionProxy_8h_source.html,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency," GetTextColor GetTextSize void char Point_t Rectangle_t srcDefinition TGWin32VirtualXProxy.cxx:164; qfloat * qDefinition THbookFile.cxx:89; ROOT::Math::DisplacementVector3DClass describing a generic displacement vector in 3 dimensions.Definition DisplacementVector3D.h:58; ROOT::Math::DisplacementVector3D::Mag2Scalar Mag2() constMagnitute squared ( r^2 in spherical coordinate)Definition DisplacementVector3D.h:323; ROOT::Math::LorentzVectorClass describing a generic LorentzVector in the 4D space-time, using the specified coordinate system ...Definition LorentzVector.h:59; ROOT::Math::LorentzVector::pzScalar pz() constDefinition LorentzVector.h:648; ROOT::Math::LorentzVector::ZScalar Z() constDefinition LorentzVector.h:290; ROOT::Math::LorentzVector::EScalar E() constreturn 4-th component (time, or energy for a 4-momentum vector)Definition LorentzVector.h:294; ROOT::Math::LorentzVector::thetaScalar theta() constDefinition LorentzVector.h:651; ROOT::Math::LorentzVector::EtScalar Et() constreturn the transverse energyDefinition LorentzVector.h:349; ROOT::Math::LorentzVector::YScalar Y() constDefinition LorentzVector.h:285; ROOT::Math::LorentzVector::SetPzLorentzVector< CoordSystem > & SetPz(Scalar a)Definition LorentzVector.h:681; ROOT::Math::LorentzVector::TScalar T() constDefinition LorentzVector.h:295; ROOT::Math::LorentzVector::GetCoordinatesvoid GetCoordinates(Scalar dest[]) constget internal data into an array of 4 Scalar numbersDefinition LorentzVector.h:211; ROOT::Math::LorentzVector::BoostToCMBetaVector BoostToCM() constThe beta vector for the boost that would bring this vector into its center of mass frame (zero moment...Definition LorentzVector.h:555; ROOT::Math::LorentzVector::operator==bool operator==(const LorentzVector &rhs) constExact equality.Definition LorentzVector.h:257; ROOT::Math::LorentzVector::MScalar M() constreturn magnitude (mass) using the (-,-,-,+) metric.Definition LorentzVector.h:306; ROOT::Math::LorentzVector::rhoScalar rho() constDefiniti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:27278,energy,energyDefinition,27278,doc/master/GenVector_2LorentzVector_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html,1,['energy'],['energyDefinition']
Energy Efficiency," Grey; 3095 case 62:; 3096 {; 3097 Double_t red[9] = { 0./255., 0./255., 0./255., 70./255., 148./255., 231./255., 235./255., 237./255., 244./255.};; 3098 Double_t green[9] = { 0./255., 0./255., 0./255., 0./255., 0./255., 69./255., 67./255., 216./255., 244./255.};; 3099 Double_t blue[9] = { 0./255., 102./255., 228./255., 231./255., 177./255., 124./255., 137./255., 20./255., 244./255.};; 3100 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3101 }; 3102 break;; 3103 ; 3104 // Alpine; 3105 case 63:; 3106 {; 3107 Double_t red[9] = { 50./255., 56./255., 63./255., 68./255., 93./255., 121./255., 165./255., 192./255., 241./255.};; 3108 Double_t green[9] = { 66./255., 81./255., 91./255., 96./255., 111./255., 128./255., 155./255., 189./255., 241./255.};; 3109 Double_t blue[9] = { 97./255., 91./255., 75./255., 65./255., 77./255., 103./255., 143./255., 167./255., 217./255.};; 3110 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3111 }; 3112 break;; 3113 ; 3114 // Aquamarine; 3115 case 64:; 3116 {; 3117 Double_t red[9] = { 145./255., 166./255., 167./255., 156./255., 131./255., 114./255., 101./255., 112./255., 132./255.};; 3118 Double_t green[9] = { 158./255., 178./255., 179./255., 181./255., 163./255., 154./255., 144./255., 152./255., 159./255.};; 3119 Double_t blue[9] = { 190./255., 199./255., 201./255., 192./255., 176./255., 169./255., 160./255., 166./255., 190./255.};; 3120 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3121 }; 3122 break;; 3123 ; 3124 // Army; 3125 case 65:; 3126 {; 3127 Double_t red[9] = { 93./255., 91./255., 99./255., 108./255., 130./255., 125./255., 132./255., 155./255., 174./255.};; 3128 Double_t green[9] = { 126./255., 124./255., 128./255., 129./255., 131./255., 121./255., 119./255., 153./255., 173./255.};; 3129 Double_t blue[9] = { 103./255., 94./255., 87./255., 85./255., 80./255., 85./255., 107./255., 120./255., 146./255.};; 3130 Idx = TColor::CreateGrad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:118160,green,green,118160,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency," Histograms tutorials. Detailed Description; Show the slice of a TH2 following the mouse position. . ; ; void DynamicSlice(); {; // Create a new canvas.; TCanvas* c1 = new TCanvas(""c1"",""Dynamic Slice Example"", 10, 10, 700, 500);; ; //create a 2-d histogram, fill and draw it; TH2F *hpxpy = new TH2F(""hpxpy"", ""py vs px"", 40,-4,4, 40,-4,4);; hpxpy->SetStats(0);; Double_t px,py;; for (Int_t i = 0; i < 50000; i++) {; gRandom->Rannor(px,py);; hpxpy->Fill(px,py);; }; hpxpy->Draw(""col"");; ; //Add a TExec object to the canvas; c1->AddExec(""dynamic"", ""DynamicExec()"");; }; ; void DynamicExec(); {; // Example of function called when a mouse event occurs in a pad.; // When moving the mouse in the canvas, a second canvas shows the; // projection along X of the bin corresponding to the Y position; // of the mouse. The resulting histogram is fitted with a gaussian.; // A ""dynamic"" line shows the current bin position in Y.; // This more elaborated example can be used as a starting point; // to develop more powerful interactive applications exploiting Cling; // as a development engine.; ; static int pyold = 0;; ; float uxmin = gPad->GetUxmin();; float uxmax = gPad->GetUxmax();; int pxmin = gPad->XtoAbsPixel(uxmin);; int pxmax = gPad->XtoAbsPixel(uxmax);; int px = gPad->GetEventX();; int py = gPad->GetEventY();; TObject *select = gPad->GetSelected();; ; gPad->GetCanvas()->FeedbackMode(kTRUE);; if (pyold) {; // erase line at old position; gVirtualX->DrawLine(pxmin, pyold, pxmax, pyold);; pyold = 0;; }; ; if(!select || !select->InheritsFrom(TH2::Class())); return;; ; TH2 *h = (TH2*)select;; ; // draw a line at current position; gVirtualX->DrawLine(pxmin, py, pxmax, py);; pyold = py;; ; Float_t upy = gPad->AbsPixeltoY(py);; Float_t y = gPad->PadtoY(upy);; ; //create or set the new canvas c2; TVirtualPad *padsav = gPad;; TCanvas *c2 = (TCanvas*)gROOT->GetListOfCanvases()->FindObject(""c2"");; if(c2) delete c2->GetPrimitive(""Projection"");; else c2 = new TCanvas(""c2"",""Projection Canvas"",710,10,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DynamicSlice_8C.html:1179,power,powerful,1179,doc/master/DynamicSlice_8C.html,https://root.cern,https://root.cern/doc/master/DynamicSlice_8C.html,1,['power'],['powerful']
Energy Efficiency," I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t *&f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t *&d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferFile::WriteDouble32. Int_t ReadStaticArray(Bool_t *b); Read array of bools from the I/O buffer. Returns the number of bools; read. Int_t ReadStaticArray(Char_t *c); Read array of characters from the I/O buffer. Returns the number of; characters read. Int_t ReadStaticArray(Short_t *h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. Int_t ReadStaticArray(Int_t *ii); Read array of ints from the I/O buffer. Returns the number of ints; read. Int_t ReadStaticArray(Long_t *ll); Read array of longs from the I/O buffer. Returns the number of longs; read. Int_t ReadStaticArray(Long64_t *ll); Read array of long longs from the I/O buffer. Returns the number of; long longs read. Int_t ReadStaticArray(Float_t *f); Read array of floats from the I/O buffer. Returns the number of floats; read. Int_t ReadStaticArray(Double_t *d); Read array of doubles from the I/O buffer. Returns the num",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferFile.html:27299,allocate,allocated,27299,root/html526/TBufferFile.html,https://root.cern,https://root.cern/root/html526/TBufferFile.html,1,['allocate'],['allocated']
Energy Efficiency," I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t*& d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferFile::WriteDouble32. Int_t ReadStaticArray(Bool_t* b); Read array of bools from the I/O buffer. Returns the number of bools; read. Int_t ReadStaticArray(Char_t* c); Read array of characters from the I/O buffer. Returns the number of; characters read. Int_t ReadStaticArray(Short_t* h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. Int_t ReadStaticArray(Int_t* i); Read array of ints from the I/O buffer. Returns the number of ints; read. Int_t ReadStaticArray(Long_t* l); Read array of longs from the I/O buffer. Returns the number of longs; read. Int_t ReadStaticArray(Long64_t* l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. Int_t ReadStaticArray(Float_t* f); Read array of floats from the I/O buffer. Returns the number of floats; read. Int_t ReadStaticArray(Double_t* d); Read array of doubles from the I/O buffer. Returns the number",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferFile.html:28593,allocate,allocated,28593,root/html528/TBufferFile.html,https://root.cern,https://root.cern/root/html528/TBufferFile.html,10,['allocate'],['allocated']
Energy Efficiency," If an I/O error occurs, the function returns -1. If the Tree has friends, also read the friends entry. To activate/deactivate one or more branches, use TBranch::SetBranchStatus; For example, if you have a Tree with several hundred branches, and you; are interested only by branches named ""a"" and ""b"", do; mytree.SetBranchStatus(""*"",0); //disable all branches; mytree.SetBranchStatus(""a"",1);; mytree.SetBranchStatus(""b"",1);; when calling mytree.GetEntry(i); only branches ""a"" and ""b"" will be read. WARNING!!; If your Tree has been created in split mode with a parent branch ""parent."",; mytree.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; mytree.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative is to call directly; brancha.GetEntry(i); branchb.GetEntry(i);. IMPORTANT NOTE. By default, GetEntry reuses the space allocated by the previous object; for each branch. You can force the previous object to be automatically; deleted if you call mybranch.SetAutoDelete(kTRUE) (default is kFALSE).; Example:; Consider the example in $ROOTSYS/test/Event.h; The top level branch in the tree T is declared with:; Event *event = 0; //event must be null or point to a valid object; //it must be initialized; T.SetBranchAddress(""event"",&event);; When reading the Tree, one can choose one of these 3 options:. OPTION 1. for (Long64_t i=0;i<nentries;i++) {; T.GetEntry(i);; // the object event has been filled at this point; }; The default (recommended). At the first entry an object of the class; Event will be created and pointed by event. At the following entries,; event will be overwritten by the new data. All internal members that are; TObject* are automatically deleted. It is important that these members; be in a valid state when GetEntry is called. Pointers must be correctly; initialized. However these internal members wil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:96012,allocate,allocated,96012,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,6,['allocate'],['allocated']
Energy Efficiency," Inheritance diagram for TGInputDialog:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGInputDialog() [1/2]. TGInputDialog::TGInputDialog ; (; const TGInputDialog & ; ). privatedelete . ◆ TGInputDialog() [2/2]. TGInputDialog::TGInputDialog ; (; const TGWindow * ; p = nullptr, . const TGWindow * ; main = nullptr, . const char * ; prompt = nullptr, . const char * ; defval = nullptr, . char * ; retstr = nullptr, . UInt_t ; options = kVerticalFrame . ). Create simple input dialog. ; It is important to know that the case where the constructor in which all the variables are initialized to their default values is only used for the TBrowser to inspect on the classes. For normal use the only variable that should be free is options.; Variables prompt, defval are the content of the input dialog while retstr has to be initialized to a char[256]. In case these are not initialized, they will show default values while retstr will be automatically allocated by the dialog. However this will make impossible to retrieve the value entered by the dialog.; To see TGInputDialog in use see: $ROOTSYS/tutorials/testInputDialog.cxx ; Definition at line 48 of file TGInputDialog.cxx. ◆ ~TGInputDialog(). TGInputDialog::~TGInputDialog ; (; ). override . Cleanup dialog. ; Definition at line 134 of file TGInputDialog.cxx. Member Function Documentation. ◆ Class(). static TClass * TGInputDialog::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGInputDialog::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGInputDialog::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 43 of file TGInputDialog.h. ◆ DeclFileName(). static const char * TGInputDialog::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 43 o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGInputDialog.html:37701,allocate,allocated,37701,doc/master/classTGInputDialog.html,https://root.cern,https://root.cern/doc/master/classTGInputDialog.html,1,['allocate'],['allocated']
Energy Efficiency," Inheritance diagram for TMVA::DNN::Settings:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ Settings(). TMVA::DNN::Settings::Settings ; (; TString ; name, . size_t ; _convergenceSteps = 15, . size_t ; _batchSize = 10, . size_t ; _testRepetitions = 7, . double ; _factorWeightDecay = 1e-5, . TMVA::DNN::EnumRegularization ; _regularization = TMVA::DNN::EnumRegularization::NONE, . MinimizerType ; _eMinimizerType = MinimizerType::fSteepest, . double ; _learningRate = 1e-5, . double ; _momentum = 0.3, . int ; _repetitions = 3, . bool ; _multithreading = true . ). c'tor ; Definition at line 232 of file NeuralNet.cxx. ◆ ~Settings(). TMVA::DNN::Settings::~Settings ; (; ). virtual . d'tor ; Definition at line 261 of file NeuralNet.cxx. Member Function Documentation. ◆ addPoint() [1/2]. void TMVA::DNN::Settings::addPoint ; (; std::string ; histoName, . double ; x . ). inline . for monitoring ; Definition at line 821 of file NeuralNet.h. ◆ addPoint() [2/2]. void TMVA::DNN::Settings::addPoint ; (; std::string ; histoName, . double ; x, . double ; y . ). inline . for monitoring ; Definition at line 822 of file NeuralNet.h. ◆ batchSize(). size_t TMVA::DNN::Settings::batchSize ; (; ); const. inline . mini-batch size ; Definition at line 767 of file NeuralNet.h. ◆ clear(). void TMVA::DNN::Settings::clear ; (; std::string ; histoName). inline . for monitoring ; Definition at line 824 of file NeuralNet.h. ◆ computeResult(). virtual void TMVA::DNN::Settings::computeResult ; (; const Net & ; , . std::vector< double > & ;  . ). inlinevirtual . callback for monitoring and logging ; Definition at line 809 of file NeuralNet.h. ◆ convergenceCount(). size_t TMVA::DNN::Settings::convergenceCount ; (; ); const. inline . returns the current convergence count ; Definition at line 827 of file NeuralNet.h. ◆ convergenceSteps(). size_t TMVA::DNN::Settings::convergenceSteps ; (; ); const. inline . how many ste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:5645,monitor,monitoring,5645,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['monitor'],['monitoring']
Energy Efficiency," Inherited Members; Includes; Libraries. Function documentation; TEvePolygonSetProjected(const char* n = ""TEvePolygonSetProjected"", const char* t = """"); Constructor. ~TEvePolygonSetProjected(); Destructor. void ComputeBBox(); Override of virtual method from TAttBBox. void SetProjection(TEveProjectionManager* mng, TEveProjectable* model); This is virtual method from base-class TEveProjected. void SetDepthLocal(Float_t d); Set depth (z-coordinate) of the projected points. void UpdateProjection(); This is virtual method from base-class TEveProjected. Bool_t IsFirstIdxHead(Int_t s0, Int_t s1); Compare the two segments and check if the first index of first segment is starting. Int_t* ProjectAndReducePoints(); Project and reduce buffer points. Float_t AddPolygon(list<Int_t,std::allocator<Int_t> >& pp, list<TEvePolygonSetProjected::Polygon_t,allocator<TEvePolygonSetProjected::Polygon_t> >& p); Check if polygon has dimensions above TEveProjection::fgEps and add it; to a list if it is not a duplicate. Float_t MakePolygonsFromBP(Int_t* idxMap); Build polygons from list of buffer polygons. Float_t MakePolygonsFromBS(Int_t* idxMap); Build polygons from the set of buffer segments.; First creates a segment pool according to reduced and projected points; and then build polygons from the pool. void ProjectBuffer3D(); Project current buffer. Float_t PolygonSurfaceXY(const TEvePolygonSetProjected::Polygon_t& poly) const; Calculate XY surface of a polygon. void DumpPolys() const; Dump information about built polygons. void DumpBuffer3D(); Dump information about currenty projected buffer. TEvePolygonSetProjected(const TEvePolygonSetProjected& ). TEvePolygonSetProjected& operator=(const TEvePolygonSetProjected& ). TEveElement* GetProjectedAsElement(); { return this; }. » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEvePolygonSetProjected.html:24687,reduce,reduced,24687,root/html534/TEvePolygonSetProjected.html,https://root.cern,https://root.cern/root/html534/TEvePolygonSetProjected.html,2,['reduce'],['reduced']
Energy Efficiency," Instead they are attached to an internal; // clone of the supplied set of arguments; ; // Fill d with dummy values; Int_t i;; for (i = 0; i < 1000; i++) {; x = i / 50 - 10;; y = sqrt(1.0 * i);; c.setLabel((i % 2) ? ""Plus"" : ""Minus"");; ; // We must explicitly refer to x,y,c here to pass the values because; // d is not linked to them (as explained above); d.add(RooArgSet(x, y, c));; }; d.Print(""v"");; cout << endl;; ; // The get() function returns a pointer to the internal copy of the RooArgSet(x,y,c); // supplied in the constructor; const RooArgSet *row = d.get();; row->Print(""v"");; cout << endl;; ; // Get with an argument loads a specific data point in row and returns; // a pointer to row argset. get() always returns the same pointer, unless; // an invalid row number is specified. In that case a null ptr is returned; d.get(900)->Print(""v"");; cout << endl;; ; // R e d u c i n g , A p p e n d i n g a n d M e r g i n g; // -------------------------------------------------------------; ; // The reduce() function returns a new dataset which is a subset of the original; cout << endl << "">> d1 has only columns x,c"" << endl;; std::unique_ptr<RooAbsData> d1{d.reduce({x, c})};; d1->Print(""v"");; ; cout << endl << "">> d2 has only column y"" << endl;; std::unique_ptr<RooAbsData> d2{d.reduce({y})};; d2->Print(""v"");; ; cout << endl << "">> d3 has only the points with y>5.17"" << endl;; std::unique_ptr<RooAbsData> d3{d.reduce(""y>5.17"")};; d3->Print(""v"");; ; cout << endl << "">> d4 has only columns x,c for data points with y>5.17"" << endl;; std::unique_ptr<RooAbsData> d4{d.reduce({x, c}, ""y>5.17"")};; d4->Print(""v"");; ; // The merge() function adds two data set column-wise; cout << endl << "">> merge d2(y) with d1(x,c) to form d1(x,c,y)"" << endl;; static_cast<RooDataSet&>(*d1).merge(&static_cast<RooDataSet&>(*d2));; d1->Print(""v"");; ; // The append() function adds two datasets row-wise; cout << endl << "">> append data points of d3 to d1"" << endl;; static_cast<RooDataSet&>(*d1).append(stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf402__datahandling_8C.html:2411,reduce,reduce,2411,doc/master/rf402__datahandling_8C.html,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8C.html,1,['reduce'],['reduce']
Energy Efficiency," Int_t* x, const Int_t* y); TGraph(Int_t n, const Float_t* x, const Float_t* y); TGraph(Int_t n, const Double_t* x, const Double_t* y); TGraph(const char* filename, const char* format = ""%lg %lg"", Option_t* option = """"); virtual voidUseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidZero(Int_t& k, Double_t AZ, Double_t BZ, Double_t E2, Double_t& X, Double_t& Y, Int_t maxiterations). protected:. virtual Double_t**Allocate(Int_t newsize); Double_t**AllocateArrays(Int_t Narrays, Int_t arraySize); virtual voidCopyAndRelease(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin); virtual Bool_tCopyPoints(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin); Bool_tCtorAllocate(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Bool_tDoMerge(const TGraph* g); Double_t**ExpandAndCopy(Int_t size, Int_t iend); virtual voidFillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); voidTObject::MakeZombie(); Double_t**ShrinkAndCopy(Int_t size, Int_t iend); virtual voidSwapPoints(Int_t pos1, Int_t pos2); static voidSwapValues(Double_t* arr, Int_t pos1, Int_t pos2). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGraph::(anonymous)kClipFrame; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TGraph::(anonymous)kNotEditable; static TObject::EStatusBitsTObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraph.html:11781,Allocate,Allocate,11781,root/html602/TGraph.html,https://root.cern,https://root.cern/root/html602/TGraph.html,4,['Allocate'],"['Allocate', 'AllocateArrays']"
Energy Efficiency," Int_t ; percent). virtual . Sets opacity of the current window. ; This image manipulation routine works by adding to a percent amount of neutral to each pixels RGB. Since it requires quite some additional color map entries is it only supported on displays with more than > 8 color planes (> 256 colors). ; Reimplemented in TGQuartz, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 868 of file TVirtualX.cxx. ◆ SetPrimarySelectionOwner(). void TVirtualX::SetPrimarySelectionOwner ; (; Window_t ; id). virtual . Makes the window ""id"" the current owner of the primary selection. ; That is the window in which, for example some text is selected. ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1978 of file TVirtualX.cxx. ◆ SetRGB(). void TVirtualX::SetRGB ; (; Int_t ; cindex, . Float_t ; r, . Float_t ; g, . Float_t ; b . ). virtual . Sets color intensities the specified color index ""cindex"". ; Parameters. [in]cindexcolor index ; [in]r,g,bthe red, green, blue intensities between 0.0 and 1.0 . Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 878 of file TVirtualX.cxx. ◆ SetSelectionOwner(). Bool_t TVirtualX::SetSelectionOwner ; (; Window_t ; , . Atom_t & ;  . ). virtual . Changes the owner and last-change time for the specified selection. ; Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 2439 of file TVirtualX.cxx. ◆ SetTextAlign(). void TVirtualX::SetTextAlign ; (; Short_t ; talign = 11). overridevirtual . Sets the text alignment. ; Parameters. [in]taligntext alignment.; talign = txalh horizontal text alignment; talign = txalv vertical text alignment . Reimplemented from TAttText.; Definition at line 890 of file TVirtualX.cxx. ◆ SetTextColor(). void TVirtualX::SetTextColor ; (; Color_t ; cindex). overridevirtual . Sets the color index ""cindex"" for text. ; Reimplemented from TAttText.; Definition at line 897 of file TVirtualX.cxx. ◆ SetTextFont() [",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:126841,green,green,126841,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['green'],['green']
Energy Efficiency," Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 2366 of file RooProdPdf.cxx. ◆ getAnalyticalIntegralWN(). Int_t RooFixedProdPdf::getAnalyticalIntegralWN ; (; RooArgSet & ; allDeps, . RooArgSet & ; analDeps, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. inlineoverridevirtual . Variant of getAnalyticalIntegral that is also passed the normalization set that should be applied to the integrand of which the integral is requested. ; For certain operator p.d.f it is useful to overload this function rather than analyticalIntegralWN() as the additional normalization information may be useful in determining a more efficient decomposition of the requested integral. ; Reimplemented from RooAbsReal.; Definition at line 2361 of file RooProdPdf.cxx. ◆ initialize(). void RooFixedProdPdf::initialize ; (; ). inlineprivate . Definition at line 2380 of file RooProdPdf.cxx. ◆ selfNormalized(). bool RooFixedProdPdf::selfNormalized ; (; ); const. inlineoverridevirtual . Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ; Always returns false, unless a PDF overrides this function. ; Reimplemented from RooAbsPdf.; Definition at line 2334 of file RooProdPdf.cxx. ◆ translate(). void RooFixedProdPdf::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. inlineoverridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFixedProdPdf.html:78475,efficient,efficient,78475,doc/master/classRooFixedProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooFixedProdPdf.html,1,['efficient'],['efficient']
Energy Efficiency," LaplaceDist(Double_t x, Double_t alpha=0, Double_t beta=1)Computes the probability density function of Laplace distribution at point x, with location parameter...Definition TMath.cxx:2364; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::ErfcDouble_t Erfc(Double_t x)Computes the complementary error function erfc(x).Definition TMath.cxx:199; TMath::VavilovIDouble_t VavilovI(Double_t x, Double_t kappa, Double_t beta2)Returns the value of the Vavilov cumulative distribution function (lower tail integral of the probabi...Definition TMath.cxx:2815; TMath::BetaDouble_t Beta(Double_t p, Double_t q)Calculates Beta-function Gamma(p)*Gamma(q)/Gamma(p+q).Definition TMath.cxx:2011; TMath::PoissonDouble_t Poisson(Double_t x, Double_t par)Computes the Poisson distribution function for (x,par).Definition TMath.cxx:587; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::BesselJ0Double_t BesselJ0(Double_t x)Modified Bessel function K_1(x)Definition TMath.cxx:1634; TMath::GammaDouble_t Gamma(Double_t z)Computation of gamma(z) for all z.Definition TMath.cxx:353; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::StruveL0Double_t StruveL0(Double_t x)Struve functions of order 1.Definition TMath.cxx:1923; TMath::NormQuantileDouble_t NormQuantile(Double_t p)Computes quantiles for standard normal distribution N(0, 1) at probability p.Definition TMath.cxx:2456; TMath::GamCfDouble_t GamCf(Double_t a, Double_t x)Computation of the incomplete gamma function P(a,x) via its continued fraction representation.Definition TMath.cxx:380; TMath::HypotDouble_t Hypot(Double_t x, Double_t y)Returns sqrt(x*x + y*y)Definition TMath.cxx:59; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:126212,power,power,126212,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['power'],['power']
Energy Efficiency," List of all members ; ROOT::Math::OneDimMultiFunctionAdapter< MultiFuncType > Class Template ReferenceMath » MathCore » Function Classes and Interfaces » Generic Function Evaluation Interfaces. ; template<class MultiFuncType = const ROOT::Math::IMultiGenFunction &>; class ROOT::Math::OneDimMultiFunctionAdapter< MultiFuncType >OneDimMultiFunctionAdapter class to wrap a multidimensional function in one dimensional one. ; Given a f(x1,x2,x3,....xn) transforms in a f( x_i) given the coordinate intex i and the vector x[] of the coordinates. It provides the possibility to copy and own the data array of the coordinates or to maintain internally a pointer to an external array for being more efficient. In this last case the user must guarantee the life of the given passed pointer ; Definition at line 56 of file OneDimFunctionAdapter.h. Public Member Functions;  OneDimMultiFunctionAdapter (const OneDimMultiFunctionAdapter &rhs);  ;  OneDimMultiFunctionAdapter (MultiFuncType f, const double *x, unsigned int icoord=0, const double *p=nullptr);  Constructor from the function object , pointer to an external array of x values and coordinate we want to adapt. ;  ;  OneDimMultiFunctionAdapter (MultiFuncType f, unsigned int dim=1, unsigned int icoord=0, const double *p=nullptr);  Constructor from the function object , dimension of the function and and coordinate we want to adapt. ;  ;  ~OneDimMultiFunctionAdapter () override;  Destructor (no operations) ;  ; OneDimMultiFunctionAdapter * Clone () const override;  clone ;  ; void SetCoord (int icoord);  ; void SetX (const double *x);  set values ;  ; void SetX (double *x);  set pointer without copying the values ;  ; template<class Iterator > ; void SetX (Iterator begin, Iterator end);  Set X values in case vector is own, iterator size must match previous set dimension. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionOneDim; virtual ~IBaseFunctionOneDim ()=default;  ; virtual bool HasGradient () const;  ; double o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1OneDimMultiFunctionAdapter.html:1426,adapt,adapt,1426,doc/master/classROOT_1_1Math_1_1OneDimMultiFunctionAdapter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1OneDimMultiFunctionAdapter.html,1,['adapt'],['adapt']
Energy Efficiency," LorentzVector.h. ◆ GetCoordinates() [4/4]. template<class CoordSystem > . void ROOT::Math::LorentzVector< CoordSystem >::GetCoordinates ; (; Scalar ; dest[]); const. inline . get internal data into an array of 4 Scalar numbers ; Definition at line 211 of file LorentzVector.h. ◆ isLightlike(). template<class CoordSystem > . bool ROOT::Math::LorentzVector< CoordSystem >::isLightlike ; (; Scalar ; tolerance = 100*std::numeric_limits<Scalar>::epsilon()); const. inline . Determine if momentum-energy can represent a massless particle. ; Definition at line 535 of file LorentzVector.h. ◆ isSpacelike(). template<class CoordSystem > . bool ROOT::Math::LorentzVector< CoordSystem >::isSpacelike ; (; ); const. inline . Determine if momentum-energy is spacelike, and represents a tachyon. ; Definition at line 545 of file LorentzVector.h. ◆ isTimelike(). template<class CoordSystem > . bool ROOT::Math::LorentzVector< CoordSystem >::isTimelike ; (; ); const. inline . Determine if momentum-energy can represent a physical massive particle. ; Definition at line 528 of file LorentzVector.h. ◆ M(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::M ; (; ); const. inline . return magnitude (mass) using the (-,-,-,+) metric. ; If M2 is negative (space-like vector) a GenVector_exception is suggested and if continuing, - sqrt( -M2) is returned ; Definition at line 306 of file LorentzVector.h. ◆ M2(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::M2 ; (; ); const. inline . return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2 (we use -,-,-,+ metric) ; Definition at line 300 of file LorentzVector.h. ◆ mag(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::mag ; (; ); const. inline . Definition at line 658 of file LorentzVector.h. ◆ mag2(). template<class CoordSystem > . Scalar ROOT::Math::LorentzVector< CoordSystem >::mag2 ; (; ); const. inline . Definition at line 657 of file LorentzVecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html:18175,energy,energy,18175,doc/master/classROOT_1_1Math_1_1LorentzVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html,1,['energy'],['energy']
Energy Efficiency," Members; public:. enum EInterest { kRead; kWrite; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMonitor.html:10084,monitor,monitor,10084,root/html528/TMonitor.html,https://root.cern,https://root.cern/root/html528/TMonitor.html,6,['monitor'],['monitor']
Energy Efficiency," Picture; Source. //Draw color plots using different color palettes.; //Author:: Olivier Couet. #include ""TStyle.h""; #include ""TColor.h""; #include ""TF2.h""; #include ""TExec.h""; #include ""TCanvas.h"". ; void Pal1(); {; static Int_t colors[50];; static Bool_t initialized = kFALSE;. Double_t Red[3] = { 1.00, 0.00, 0.00};; Double_t Green[3] = { 0.00, 1.00, 0.00};; Double_t Blue[3] = { 1.00, 0.00, 1.00};; Double_t Length[3] = { 0.00, 0.50, 1.00 };. if(!initialized){; Int_t FI = TColor::CreateGradientColorTable(3,Length,Red,Green,Blue,50);; for (int i=0; i<50; i++) colors[i] = FI+i;; initialized = kTRUE;; return;; }; gStyle->SetPalette(50,colors);; }. void Pal2(); {; static Int_t colors[50];; static Bool_t initialized = kFALSE;. Double_t Red[3] = { 1.00, 0.50, 0.00};; Double_t Green[3] = { 0.50, 0.00, 1.00};; Double_t Blue[3] = { 1.00, 0.00, 0.50};; Double_t Length[3] = { 0.00, 0.50, 1.00 };. if(!initialized){; Int_t FI = TColor::CreateGradientColorTable(3,Length,Red,Green,Blue,50);; for (int i=0; i<50; i++) colors[i] = FI+i;; initialized = kTRUE;; return;; }; gStyle->SetPalette(50,colors);; }. TCanvas* multipalette() {; TCanvas *c3 = new TCanvas(""c3"",""C3"",0,0,600,400);; c3->Divide(2,1);; TF2 *f3 = new TF2(""f3"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);. c3->cd(1);; f3->Draw(""surf1""); ; TExec *ex1 = new TExec(""ex1"",""Pal1();"");; ex1->Draw();; f3->Draw(""surf1 same""); . c3->cd(2);; f3->Draw(""surf1""); ; TExec *ex2 = new TExec(""ex2"",""Pal2();"");; ex2->Draw();; f3->Draw(""surf1 same""); . return c3;; } . Function Members (Methods); public:. TColor(); TColor(const TColor& color); TColor(Int_t color, Float_t r, Float_t g, Float_t b, const char* name = """", Float_t a = 1); virtual~TColor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); const char*AsHexString() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TColor.html:7094,Green,Green,7094,root/html532/TColor.html,https://root.cern,https://root.cern/root/html532/TColor.html,1,['Green'],['Green']
Energy Efficiency," Picture; Source. //Draw color plots using different color palettes.; //Author:: Olivier Couet. #include ""TStyle.h""; #include ""TColor.h""; #include ""TF2.h""; #include ""TExec.h""; #include ""TCanvas.h"". ; void Pal1(); {; static Int_t colors[50];; static Bool_t initialized = kFALSE;. Double_t Red[3] = { 1.00, 0.00, 0.00};; Double_t Green[3] = { 0.00, 1.00, 0.00};; Double_t Blue[3] = { 1.00, 0.00, 1.00};; Double_t Length[3] = { 0.00, 0.50, 1.00 };. if(!initialized){; Int_t FI = TColor::CreateGradientColorTable(3,Length,Red,Green,Blue,50);; for (int i=0; i<50; i++) colors[i] = FI+i;; initialized = kTRUE;; return;; }; gStyle->SetPalette(50,colors);; }. void Pal2(); {; static Int_t colors[50];; static Bool_t initialized = kFALSE;. Double_t Red[3] = { 1.00, 0.50, 0.00};; Double_t Green[3] = { 0.50, 0.00, 1.00};; Double_t Blue[3] = { 1.00, 0.00, 0.50};; Double_t Length[3] = { 0.00, 0.50, 1.00 };. if(!initialized){; Int_t FI = TColor::CreateGradientColorTable(3,Length,Red,Green,Blue,50);; for (int i=0; i<50; i++) colors[i] = FI+i;; initialized = kTRUE;; return;; }; gStyle->SetPalette(50,colors);; }. TCanvas* multipalette() {; TCanvas *c3 = new TCanvas(""c3"",""C3"",0,0,600,400);; c3->Divide(2,1);; TF2 *f3 = new TF2(""f3"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; f3->SetLineWidth(1);; f3->SetLineColor(kBlack);. c3->cd(1);; f3->Draw(""surf1""); ; TExec *ex1 = new TExec(""ex1"",""Pal1();"");; ex1->Draw();; f3->Draw(""surf1 same""); . c3->cd(2);; f3->Draw(""surf1""); ; TExec *ex2 = new TExec(""ex2"",""Pal2();"");; ex2->Draw();; f3->Draw(""surf1 same""); . return c3;; }; Color transparency; To make a graphics object transparent it is enough to set its color to a; transparent one. The color transparency is defined via its alpha component. The; alpha value varies from 0. (fully transparent) to 1. (fully; opaque). To set the alpha value of an existing color it is enough to do:. TColor *col26 = gROOT->GetColor(26);; col26->SetAlpha(0.01);. A new color can be created transparent the following way:. Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TColor.html:7162,Green,Green,7162,root/html534/TColor.html,https://root.cern,https://root.cern/root/html534/TColor.html,1,['Green'],['Green']
Energy Efficiency," Plotting control. LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is blue; LineWidth(Int_t width) -- Select line with in pixels, default is 3; FillStyle(Int_t style) -- Select fill style, default is not filled. If a filled style is selected, also use VLines(); to add vertical downward lines at end of curve to ensure proper closure; FillColor(Int_t color) -- Select fill color by ROOT color code; Range(const char* name) -- Only draw curve in range defined by given name; Range(double lo, double hi) -- Only draw curve in specified range; VLines() -- Add vertical lines to y=0 at end points of curve; Precision(Double_t eps) -- Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; will result in more and more densely spaced curve points; A negative precision value will disable adaptive point spacing and restrict sampling to; the grid point of points defined by the binning of the plotted observabled (recommended for; expensive functions such as profile likelihoods); Invisble(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(). RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plot oneself on 'frame'. In addition to features detailed in RooAbsReal::plotOn(),; the scale factor for a PDF can be interpreted in three different ways. The interpretation; is controlled by ScaleType. Relative - Scale factor is applied on top of PDF normalization scale factor; NumEvent - Scale factor is interpreted as a number of events. The surface area; under the PDF curve will match that of a histogram containing the specified; number of event; Raw - Scale factor is applied to the raw (projected) probability density.; Not too useful, option provided for completeness. RooPlot* paramOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:78497,adapt,adaptive,78497,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,6,['adapt'],['adaptive']
Energy Efficiency," ProjectionY. ;  ; virtual TH1D * DoQuantiles (bool onX, const char *name, Double_t prob) const;  Implementation of quantiles for x or y. ;  ; Int_t Fill (const char *, Double_t) override;  Increment bin with namex with a weight w. ;  ; Int_t Fill (Double_t) override;  Invalid Fill method. ;  ; Double_t Interpolate (Double_t x) const override;  illegal for a TH2 ;  ;  Protected Member Functions inherited from TH1;  TH1 ();  Histogram default constructor. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins);  Constructor for variable bin size histograms using an input array of type double. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins);  Constructor for variable bin size histograms using an input array of type float. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup);  Constructor for fix bin size histograms. ;  ; virtual Int_t AutoP2FindLimits (Double_t min, Double_t max);  Buffer-based estimate of the histogram range using the power of 2 algorithm. ;  ; Int_t AxisChoice (Option_t *axis) const;  Choose an axis according to ""axis"". ;  ; virtual void DoFillN (Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1);  Internal method to fill histogram content from a vector called directly by TH1::BufferEmpty. ;  ; virtual Double_t DoIntegral (Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t &err, Option_t *opt, Bool_t doerr=kFALSE) const;  Internal function compute integral and optionally the error between the limits specified by the bin number values working for all histograms (1D, 2D and 3D) ;  ; virtual Bool_t FindNewAxisLimits (const TAxis *axis, const Double_t point, Double_t &newMin, Double_t &newMax);  finds new limits for the axis so that point is within the range and the limits are compatible with the previous ones (see TH1::Merge). ;  ; UInt_t GetAxisLabelStatus () const;  Internal function used in TH1::Fill to see ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:48523,power,power,48523,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,7,['power'],['power']
Energy Efficiency," Public Member Functions inherited from TAttMarker; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Width_t GetMarkerLineWidth (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Protected Member Functions; Double_t ** Allocate (Int_t size) override;  Allocate internal data structures for newsize points. ;  ; void CopyAndRelease (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy and release. ;  ; Bool_t CopyPoints (Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin != iend. ;  ; Bool_t CtorAllocate ();  Constructor allocate. ;  ; Bool_t DoMerge (const TGraph *g) override;  Protected function to perform the merge operation of a graph with errors. ;  ; void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) override;  Set zero values for point arrays in the range [begin, end]. ;  ; void SwapPoints (Int_t pos1, Int_t pos2) override;  Swap points. ;  ; void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) override;  Update the fX, fY, fEX, and fEY arrays with the sorted values. ;  ;  Protected Member Functions inherited from TGraph; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphErrors.html:29795,allocate,allocate,29795,doc/master/classTGraphErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphErrors.html,1,['allocate'],['allocate']
Energy Efficiency," Public Member Functions;  BinData (const BinData &rhs);  copy constructors ;  ;  BinData (const DataOptions &opt, const DataRange &range, unsigned int maxpoints=0, unsigned int dim=1, ErrorType err=kValueError);  constructor from options and range default is 1D and value errors ;  ;  BinData (const DataOptions &opt, unsigned int maxpoints=0, unsigned i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html:2241,allocate,allocate,2241,doc/master/classROOT_1_1Fit_1_1BinData.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html,1,['allocate'],['allocate']
Energy Efficiency," RField.cxx:611; ROOT::Experimental::RNTupleFillContext::fSinkstd::unique_ptr< Internal::RPageSink > fSinkDefinition RNTupleFillContext.hxx:56; ROOT::Experimental::RNTupleModel::Createstatic std::unique_ptr< RNTupleModel > Create()Definition RNTupleModel.cxx:249; ROOT::Experimental::RNTupleWriteOptionsCommon user-tunable settings for storing ntuples.Definition RNTupleWriteOptions.hxx:48; ROOT::Experimental::RNTupleWriteOptions::GetUseBufferedWritebool GetUseBufferedWrite() constDefinition RNTupleWriteOptions.hxx:127; ROOT::Experimental::RNTupleWriteOptions::EImplicitMT::kDefault@ kDefault; ROOT::Experimental::RNTupleWriterAn RNTuple that gets filled with entries (data) and writes them to storage.Definition RNTupleWriter.hxx:60; ROOT::Experimental::RNTupleWriter::RNTupleWriterRNTupleWriter(std::unique_ptr< RNTupleModel > model, std::unique_ptr< Internal::RPageSink > sink)Definition RNTupleWriter.cxx:32; ROOT::Experimental::RNTupleWriter::fZipTasksstd::unique_ptr< Internal::RPageStorage::RTaskScheduler > fZipTasksThe page sink's parallel page compression scheduler if IMT is on.Definition RNTupleWriter.hxx:68; ROOT::Experimental::RNTupleWriter::Createstatic std::unique_ptr< RNTupleWriter > Create(std::unique_ptr< RNTupleModel > model, std::unique_ptr< Internal::RPageSink > sink, const RNTupleWriteOptions &options)Create a writer, potentially wrapping the sink in a RPageSinkBuf.Definition RNTupleWriter.cxx:58; ROOT::Experimental::RNTupleWriter::CommitClusterGroupvoid CommitClusterGroup()Definition RNTupleWriter.cxx:102; ROOT::Experimental::RNTupleWriter::fMetricsDetail::RNTupleMetrics fMetricsDefinition RNTupleWriter.hxx:70; ROOT::Experimental::RNTupleWriter::~RNTupleWriter~RNTupleWriter()Definition RNTupleWriter.cxx:47; ROOT::Experimental::RNTupleWriter::Recreatestatic std::unique_ptr< RNTupleWriter > Recreate(std::unique_ptr< RNTupleModel > model, std::string_view ntupleName, std::string_view storage, const RNTupleWriteOptions &options=RNTupleWriteOptions())Throws an ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleWriter_8cxx_source.html:7682,schedul,scheduler,7682,doc/master/RNTupleWriter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8cxx_source.html,1,['schedul'],['scheduler']
Energy Efficiency," ROOT ; ROOT::Fit ; ROOT::Fit::BasicFCN<ROOT::Math::IBaseFunctionMultiDim,ROOT::Fit::BinData> ; ROOT::Fit::BasicFCN<ROOT::Math::IBaseFunctionMultiDim,ROOT::Fit::UnBinData> ; ROOT::Fit::BasicFCN<ROOT::Math::IGradientFunctionMultiDim,ROOT::Fit::BinData> ; ROOT::Fit::BasicFCN<ROOT::Math::IGradientFunctionMultiDim,ROOT::Fit::UnBinData> ; ROOT::Fit::BinData ; ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim> ; ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim> ; ROOT::Fit::DataOptions ; ROOT::Fit::DataRange ; ROOT::Fit::FitConfig ; ROOT::Fit::FitData ; ROOT::Fit::FitResult ; ROOT::Fit::Fitter ; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim> ; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim> ; ROOT::Fit::ParameterSettings ; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim> ; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim> ; ROOT::Fit::SparseData ; ROOT::Fit::UnBinData ; ROOT::Math ; ROOT::Math::AdaptiveIntegratorMultiDim ; ROOT::Math::AxisAngle ; ROOT::Math::BaseIntegratorOptions ; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim> ; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim> ; ROOT::Math::BasicMinimizer ; ROOT::Math::Boost ; ROOT::Math::BoostX ; ROOT::Math::BoostY ; ROOT::Math::BoostZ ; ROOT::Math::BrentMinimizer1D ; ROOT::Math::BrentRootFinder ; ROOT::Math::Cartesian2D<Double32_t> ; ROOT::Math::Cartesian2D<double> ; ROOT::Math::Cartesian3D<Double32_t> ; ROOT::Math::Cartesian3D<double> ; ROOT::Math::ChebyshevApprox ; ROOT::Math::ChebyshevPol ; ROOT::Math::Cylindrical3D<Double32_t> ; ROOT::Math::Cylindrical3D<double> ; ROOT::Math::CylindricalEta3D<Double32_t> ; ROOT::Math::CylindricalEta3D<double> ; ROOT::Math::DefaultCoordinateSystemTag ; ROOT::Math::Derivator ; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag> ; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ClassIndex.html:2143,Adapt,AdaptiveIntegratorMultiDim,2143,root/html604/ClassIndex.html,https://root.cern,https://root.cern/root/html604/ClassIndex.html,1,['Adapt'],['AdaptiveIntegratorMultiDim']
Energy Efficiency," ROOT file; TFileCacheRead TFile cache when reading; TFileCacheWrite TFile cache when writing; TFileCollection Collection of TFileInfo objects; TFileDrawMap Draw a 2-d map of the objects in a file; TFileHandler Handles events on file descriptors; TFileInfo Describes generic file info including meta data information; TFileInfoMeta Describes TFileInfo meta data; TFileIter TFile class iterator; TFileMergeInfo ; TFileMerger File copying and merging services; TFilePrefetch File block prefetcher; TFileSet TDataSet class to read the native file system directory structure in; TFileStager ABC defining interface to a stager; TFitEditor Fit Panel interface; TFitParametersDialog Fit function parameters dialog; TFitResult Class holding the result of the fit ; TFitResultPtr indirection to TFitResult; TFitter The ROOT standard fitter based on TMinuit; TFitterFumili Fitter based on new Fumili method (Fumili2); TFitterMinuit The ROOT fitter based on new Minuit (Minuit2); TFoam General purpose self-adapting Monte Carlo event generator; TFoamCell Single cell of FOAM; TFoamIntegrand n-dimensional real positive integrand of FOAM; TFoamMaxwt Controlling of the MC weight (maximum weight); TFoamSampler ; TFoamVect n-dimensional vector with dynamical allocation; TFolder Describe a folder: a list of objects and folders; TFormula The formula base class f(x,y,z,par); TFormulaPrimitive The primitive formula ; TFractionFitter Fits MC fractions to data histogram; TFrame Pad graphics frame; TFrameEditor editor of TFrame objects; TFree Description of free segments on a file; TFriendElement A friend element of another TTree; TFumili The FUMILI Minimization package; TFumiliMinimizer Implementation of Minimizer interface using TFumili ; TFunction Dictionary for global function; TFunctionParametersDialog Function parameters dialog; TG16ColorSelector 16 color cells; TGApplication GUI application singleton; TGButton Button widget abstract base class; TGButtonGroup Organizes TGButtons in a group; TGCanvas ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:72430,adapt,adapting,72430,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,4,['adapt'],['adapting']
Energy Efficiency," ROOT objects hierarchyDefinition THttpServer.h:36; THttpServer::SetTimervoid SetTimer(Long_t milliSec=100, Bool_t mode=kTRUE)Create timer which will invoke ProcessRequests() function periodically.Definition THttpServer.cxx:490; THttpServer::ProcessBatchHoldervirtual void ProcessBatchHolder(std::shared_ptr< THttpCallArg > &arg)Process special http request for root_batch_holder.js script.Definition THttpServer.cxx:799; THttpServer::fWSHandlersstd::vector< std::shared_ptr< THttpWSHandler > > fWSHandlers! list of WS handlersDefinition THttpServer.h:61; THttpServer::~THttpServervirtual ~THttpServer()destructorDefinition THttpServer.cxx:245; THttpServer::SetTerminatevoid SetTerminate()set termination flag, no any further requests will be processedDefinition THttpServer.cxx:277; THttpServer::MissedRequestvirtual void MissedRequest(THttpCallArg *arg)Method called when THttpServer cannot process request.Definition THttpServer.cxx:788; THttpServer::fOwnThreadBool_t fOwnThread! true when specialized thread allocated for processing requestsDefinition THttpServer.h:40; THttpServer::SetSniffervoid SetSniffer(TRootSniffer *sniff)Set TRootSniffer to the server.Definition THttpServer.cxx:267; THttpServer::IsFileRequestedBool_t IsFileRequested(const char *uri, TString &res) constCheck if file is requested, thread safe.Definition THttpServer.cxx:612; THttpServer::SetReadOnlyvoid SetReadOnly(Bool_t readonly=kTRUE)Set read-only mode for the server (default on)Definition THttpServer.cxx:296; THttpServer::GetItemFieldconst char * GetItemField(const char *fullname, const char *name)Get item field from sniffer.Definition THttpServer.cxx:1471; THttpServer::GetCorsconst char * GetCors() constReturns specified CORS domain.Definition THttpServer.h:115; THttpServer::fThrdstd::thread fThrd! own threadDefinition THttpServer.h:41; THttpServer::StopServerThreadvoid StopServerThread()Stop server thread.Definition THttpServer.cxx:547; THttpServer::ProcessRequestsInt_t ProcessRequests()Process submitt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:58665,allocate,allocated,58665,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,2,['allocate'],['allocated']
Energy Efficiency," ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf902_numgenconfig.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: configuration and customization of how MC sampling algorithms on specific pdfs are executed ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooChebychev.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooNumGenConfig.h""; #include ""RooArgSet.h""; #include <iomanip>; using namespace RooFit;; ; void rf902_numgenconfig(); {; ; // A d j u s t g l o b a l MC s a m p l i n g s t r a t e g y; // ------------------------------------------------------------------; ; // Example pdf for use below; RooRealVar x(""x"", ""x"", 0, 10);; RooChebychev model(""model"", ""model"", x, RooArgList(0, 0.5, -0.1));; ; // Change global strategy for 1D sampling problems without conditional observable; // (1st false) and without discrete observable (2nd false) from RooFoamGenerator,; // ( an interface to the TFoam MC generator with adaptive subdivisioning strategy ) to RooAcceptReject,; // a plain accept/reject sampling algorithm [ RooFit default before ROOT 5.23/04 ]; RooAbsPdf::defaultGeneratorConfig()->method1D(false, false).setLabel(""RooAcceptReject"");; ; // Generate 10Kevt using RooAcceptReject; std::unique_ptr<RooDataSet> data_ar{model.generate(x, 10000, Verbose(true))};; data_ar->Print();; ; // A d j u s t i n g d e f a u l t c o n f i g f o r a s p e c i f i c p d f; // -------------------------------------------------------------------------------------; ; // Another possibility: associate custom MC sampling configuration as default for object 'model'; // The true argument will install a clone of the default configuration as specialized configuration; // for this model if none existed so far; model.specialGeneratorConfig(true)->method1D(false, false).setLabel(""RooFoamGenerator"");; ; // A d j u s t i n g p a r a m e t e r s o f a s p e c i f i c t e c h n i q ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf902__numgenconfig_8C.html:1109,adapt,adaptive,1109,doc/master/rf902__numgenconfig_8C.html,https://root.cern,https://root.cern/doc/master/rf902__numgenconfig_8C.html,1,['adapt'],['adaptive']
Energy Efficiency," ROOT::Math::OneDimMultiFunctionAdapter< MultiFuncType >OneDimMultiFunctionAdapter class to wrap a multidimensional function in one dimensional one. ; Given a f(x1,x2,x3,....xn) transforms in a f( x_i) given the coordinate intex i and the vector x[] of the coordinates. It provides the possibility to copy and own the data array of the coordinates or to maintain internally a pointer to an external array for being more efficient. In this last case the user must guarantee the life of the given passed pointer ; Definition at line 56 of file OneDimFunctionAdapter.h. Public Member Functions;  OneDimMultiFunctionAdapter (const OneDimMultiFunctionAdapter &rhs);  ;  OneDimMultiFunctionAdapter (MultiFuncType f, const double *x, unsigned int icoord=0, const double *p=nullptr);  Constructor from the function object , pointer to an external array of x values and coordinate we want to adapt. ;  ;  OneDimMultiFunctionAdapter (MultiFuncType f, unsigned int dim=1, unsigned int icoord=0, const double *p=nullptr);  Constructor from the function object , dimension of the function and and coordinate we want to adapt. ;  ;  ~OneDimMultiFunctionAdapter () override;  Destructor (no operations) ;  ; OneDimMultiFunctionAdapter * Clone () const override;  clone ;  ; void SetCoord (int icoord);  ; void SetX (const double *x);  set values ;  ; void SetX (double *x);  set pointer without copying the values ;  ; template<class Iterator > ; void SetX (Iterator begin, Iterator end);  Set X values in case vector is own, iterator size must match previous set dimension. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionOneDim; virtual ~IBaseFunctionOneDim ()=default;  ; virtual bool HasGradient () const;  ; double operator() (const double *x) const;  Evaluate the function at a point x[]. ;  ; double operator() (double x) const;  Evaluate the function at a point x. ;  . Private Member Functions; double DoEval (double x) const override;  evaluate function at the values x[] given in the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1OneDimMultiFunctionAdapter.html:1649,adapt,adapt,1649,doc/master/classROOT_1_1Math_1_1OneDimMultiFunctionAdapter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1OneDimMultiFunctionAdapter.html,1,['adapt'],['adapt']
Energy Efficiency," Reference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development How to use the ROOT Jenkins. The ROOT project uses a Jenkins instance to schedule a number of software development procedures (nightly builds, production of releases, documentation generation, etc.). Practical information about the service can be found here. The purpose of this page is to document the different existing procedures for the ROOT project and basic interaction with them to obtain most of the information.; SFT Jenkins Service; Access and accounts; Everybody with a CERN account has automatically read access to Jenkins service instance. For write access (e.g. to be able to stop and launch new jobs) please send a request to Patricia Mendez to obtain an account.; ROOT jobs; Each project in the SFT Jenkins has a specific 'tab' for the defined project jobs. The ROOT tab contains all the defined jobs for ROOT. They are organized as follow:. nightly builds: The jobs are named root-nightly-<version> and they are implemented as multi-configuration project. They are run once a day (around after midnight CET) but they can be started by hand at any time of the day (see later) and select for what c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/how-use-root-jenkins.html:1949,schedul,schedule,1949,d/how-use-root-jenkins.html,https://root.cern,https://root.cern/d/how-use-root-jenkins.html,1,['schedul'],['schedule']
Energy Efficiency," RooAbsReal; RooRealBinding Function binding to RooAbsReal object; RooRealConstant RooRealVar constants factory; RooRealIntegral Real-valued function representing an integral over a RooAbsReal object; RooRealMPFE Multi-process front-end for parallel calculation of a real valued function ; RooRealProxy Proxy for a RooAbsReal object; RooRealSumPdf PDF constructed from a sum of (non-pdf) functions; RooRealVar Real-valued variable ; RooRealVarSharedProperties Shared properties of a RooRealVar clone set; RooRecursiveFraction Recursive fraction formula f1*(1-f2)*(1-f3) etc...; RooRefCountList RooLinkedList with reference counting; RooResolutionModel Abstract Resolution Model; RooScaledFunc Function binding applying scaling to another function binding; RooSegmentedIntegrator1D 1-dimensional piece-wise numerical integration engine; RooSegmentedIntegrator2D 2-dimensional piece-wise numerical integration engine; RooSentinel ; RooSetPair Utility class holding a pair of RooArgSet pointers; RooSetProxy Proxy class for a RooArgSet; RooSharedProperties Abstract interface for shared property implementations; RooSharedPropertiesList Manager for shared properties among clones of certain RooAbsArg-derived types; RooSimGenContext Context for efficiently generating a dataset from a RooSimultaneous PDF; RooSimPdfBuilder RooSimultaneous PDF Builder (obsolete); RooSimWSTool Workspace oriented tool for customized cloning of p.d.f. into a simultaneous p.d.f; RooSimWSTool::BuildConfig Build configuration object for RooSimWSTool; RooSimWSTool::MultiBuildConfig Build configuration object for RooSimWSTool with multiple prototype p.d.f.; RooSimWSTool::ObjBuildConfig Validated RooSimWSTool build configuration; RooSimWSTool::ObjSplitRule Validated RooSimWSTool split rule; RooSimWSTool::SplitRule Split rule specification for prototype p.d.f; RooSimultaneous Simultaneous operator p.d.f, functions like C++ 'switch()' on input p.d.fs operating on index category5A; RooSpHarmonic SpHarmonic polynomial; Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:42590,efficient,efficiently,42590,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,2,['efficient'],['efficiently']
Energy Efficiency," RooAbsReal; RooRealBinding Function binding to RooAbsReal object; RooRealConstant RooRealVar constants factory; RooRealIntegral Real-valued function representing an integral over a RooAbsReal object; RooRealMPFE Multi-process front-end for parallel calculation of a real valued function ; RooRealProxy Proxy for a RooAbsReal object; RooRealSumPdf PDF constructed from a sum of (non-pdf) functions; RooRealVar Real-valued variable ; RooRealVarSharedProperties Shared properties of a RooRealVar clone set; RooRecursiveFraction Recursive fraction formula f1*(1-f2)*(1-f3) etc...; RooRefCountList RooLinkedList with reference counting; RooResolutionModel Abstract Resolution Model; RooScaledFunc Function binding applying scaling to another function binding; RooSegmentedIntegrator1D 1-dimensional piece-wise numerical integration engine; RooSegmentedIntegrator2D 2-dimensional piece-wise numerical integration engine; RooSentinel ; RooSetPair Utility class holding a pair of RooArgSet pointers; RooSetProxy Proxy class for a RooArgSet; RooSharedProperties Abstract interface for shared property implementations; RooSharedPropertiesList Manager for shared properties among clones of certain RooAbsArg-derived types; RooSimGenContext Context for efficiently generating a dataset from a RooSimultaneous PDF; RooSimPdfBuilder RooSimultaneous PDF Builder (obsolete); RooSimWSTool Workspace oriented tool for customized cloning of p.d.f. into a simultaneous p.d.f; RooSimWSTool::BuildConfig Build configuration object for RooSimWSTool; RooSimWSTool::MultiBuildConfig Build configuration object for RooSimWSTool with multiple prototype p.d.f.; RooSimWSTool::ObjBuildConfig Validated RooSimWSTool build configuration; RooSimWSTool::ObjSplitRule Validated RooSimWSTool split rule; RooSimWSTool::SplitRule Split rule specification for prototype p.d.f; RooSimultaneous Simultaneous operator p.d.f, functions like C++ 'switch()' on input p.d.fs operating on index category5A; RooStats ; RooStats::AcceptanceRegion A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:40801,efficient,efficiently,40801,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,2,['efficient'],['efficiently']
Energy Efficiency," RooMultiVarGaussian(); RooMultiVarGaussian(const RooMultiVarGaussian& other, const char* name = 0); RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TMatrixDSym& covMatrix); RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const RooArgList& mu, const TMatrixDSym& covMatrix); RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const RooFitResult& fr, Bool_t reduceToConditional = kTRUE); RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TVectorD& mu, const TMatrixDSym& covMatrix); virtual~RooMultiVarGaussian(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMultiVarGaussian.html:873,reduce,reduceToConditional,873,root/html534/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html534/RooMultiVarGaussian.html,2,['reduce'],['reduceToConditional']
Energy Efficiency," RooMultiVarGaussian(); RooMultiVarGaussian(const RooMultiVarGaussian& other, const char* name = 0); RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TMatrixDSym& covMatrix); RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const RooFitResult& fr, Bool_t reduceToConditional = kTRUE); RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const RooArgList& mu, const TMatrixDSym& covMatrix); RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TVectorD& mu, const TMatrixDSym& covMatrix); virtual~RooMultiVarGaussian(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMultiVarGaussian.html:739,reduce,reduceToConditional,739,root/html532/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html532/RooMultiVarGaussian.html,2,['reduce'],['reduceToConditional']
Energy Efficiency," Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(Double32_t pt); ====== Set member functions for coordinates in other systems =======. void SetEta(Double32_t eta). void SetPhi(Double32_t phi). void SetE(Double32_t energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: 464c29f33a8bbd8462a3e15b7e4c30c6f5b74a30 $ » Last generated: 2015-09-08 17:00; This page has been automatically g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__PxPyPzM4D_Double32_t_.html:7908,energy,energy,7908,root/html534/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__PxPyPzM4D_Double32_t_.html,2,['energy'],['energy']
Energy Efficiency," Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(Double32_t pt); ====== Set member functions for coordinates in other systems =======. void SetEta(Double32_t eta). void SetPhi(Double32_t phi). void SetE(Double32_t energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 30568 2009-10-06 07:17:59Z moneta $ » Last generated: 2009-12-07 13:44; This page has been automatica",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html:7906,energy,energy,7906,root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html,1,['energy'],['energy']
Energy Efficiency," Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(Double32_t pt); ====== Set member functions for coordinates in other systems =======. void SetEta(Double32_t eta). void SetPhi(Double32_t phi). void SetE(Double32_t energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatica",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__PxPyPzM4D_Double32_t_.html:7906,energy,energy,7906,root/html528/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__PxPyPzM4D_Double32_t_.html,1,['energy'],['energy']
Energy Efficiency," Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(Double32_t pt); ====== Set member functions for coordinates in other systems =======. void SetEta(Double32_t eta). void SetPhi(Double32_t phi). void SetE(Double32_t energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatica",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_Double32_t_.html:7908,energy,energy,7908,root/html530/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_Double32_t_.html,1,['energy'],['energy']
Energy Efficiency," Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(Double32_t pt); ====== Set member functions for coordinates in other systems =======. void SetEta(Double32_t eta). void SetPhi(Double32_t phi). void SetE(Double32_t energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: PxPyPzM4D.h 31938 2009-12-18 14:49:38Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatica",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html:7908,energy,energy,7908,root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__PxPyPzM4D_Double32_t_.html,2,['energy'],['energy']
Energy Efficiency," Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar e). set all values. void Negate(); ------ Manipulations -------------. negate the 4-vector - Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components.; One would need to use negate only with vectors having the energy as data members. void Scale(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPt(Double32_t pt); ====== Set member functions for coordinates in other systems =======. void SetEta(Double32_t eta). void SetPhi(Double32_t phi). void SetE(Double32_t energy). void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. » Last changed: root/mathcore:$Id: 464c29f33a8bbd8462a3e15b7e4c30c6f5b74a30 $ » Last generated: 2015-09-08 17:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__PxPyPzM4D_Double32_t_.html:8548,energy,energy,8548,root/html534/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__PxPyPzM4D_Double32_t_.html,2,['energy'],['energy']
Energy Efficiency," Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; The test is implemented in root in the ROOT::Math::GoFTest class It is the same formula ( (6) in the paper), and also shown in this preprint; Binned data are considered as un-binned data with identical observation happening in the bin center.; Parameters. [in]h2Pointer to 1D histogram ; [in]optionis a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""T"" Return the normalized A-D test statistic. Note1: Underflow and overflow are not considered in the test; Note2: The test works only for un-weighted histogram (i.e. representing counts); Note3: The histograms are not required to have the same X axis; Note4: The test works only for 1-dimensional histograms . Definition at line 8062 of file TH1.cxx. ◆ AutoP2FindLimits(). Int_t TH1::AutoP2FindLimits ; (; Double_t ; xmi, . Double_t ; xma . ). protectedvirtual . Buffer-based estimate of the histogram range using the power of 2 algorithm. ; Used by the autobin power of 2 algorithm.; Works on arguments (min and max from fBuffer) and internal inputs: fXmin, fXmax, NBinsX (from fXaxis), ... Result save internally in fXaxis.; Overloaded by TH2 and TH3.; Return -1 if internal inputs are inconsistent, 0 otherwise. ; Definition at line 1343 of file TH1.cxx. ◆ AutoP2GetBins(). Int_t TH1::AutoP2GetBins ; (; Int_t ; n). inlinestaticprotected . Auxiliary function to get the next power of 2 integer value larger then n. ; Used by the autobin power of 2 algorithm ; Definition at line 1321 of file TH1.cxx. ◆ AutoP2GetPower2(). Double_t TH1::AutoP2GetPower2 ; (; Double_t ; x, . Bool_t ; next = kTRUE . ). inlinestaticprotected . Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ; next = kTRUE : next larger next = kFALSE : previous smaller; Used by the autobin power of 2 algorithm ; Definition at line 1308 of file TH1.cxx. ◆ AxisChoice(). Int_t TH1::AxisChoice ; (; Option_t * ; axis); const. protected . Choose an axis ac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:81349,power,power,81349,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['power'],['power']
Energy Efficiency," SetSniffer(TRootSniffer* sniff); Set TRootSniffer to the server; Server takes ownership over sniffer. Bool_t IsReadOnly() const; returns read-only mode. void SetReadOnly(Bool_t readonly); Set read-only mode for the server (default on); In read-only server is not allowed to change any ROOT object, registered to the server; Server also cannot execute objects method via exe.json request. void AddLocation(const char* prefix, const char* path); add files location, which could be used in the server; one could map some system folder to the server like AddLocation(""mydir/"",""/home/user/specials"");; Than files from this directory could be addressed via server like; http://localhost:8080/mydir/myfile.root. void SetJSROOT(const char* location); Set location of JSROOT to use with the server; One could specify address like:; https://root.cern.ch/js/3.3; http://web-docs.gsi.de/~linev/js/3.3; This allows to get new JSROOT features with old server,; reduce load on THttpServer instance, also startup time can be improved; When empty string specified (default), local copy of JSROOT is used (distributed with ROOT). void SetDefaultPage(const char* filename); Set file name of HTML page, delivered by the server when; http address is opened in the browser.; By default, $ROOTSYS/etc/http/files/online.htm page is used; When empty filename is specified, default page will be used. void SetDrawPage(const char* filename); Set file name of HTML page, delivered by the server when; objects drawing page is requested from the browser; By default, $ROOTSYS/etc/http/files/draw.htm page is used; When empty filename is specified, default page will be used. Bool_t CreateEngine(const char* engine); factory method to create different http engines; At the moment two engine kinds are supported:; civetweb (default) and fastcgi; Examples:; ""civetweb:8080"" or ""http:8080"" or "":8080"" - creates civetweb web server with http port 8080; ""fastcgi:9000"" - creates fastcgi server with port 9000; ""dabc:1237"" - create DABC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THttpServer.html:10031,reduce,reduce,10031,root/html534/THttpServer.html,https://root.cern,https://root.cern/root/html534/THttpServer.html,4,['reduce'],['reduce']
Energy Efficiency," Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; TArrayI*TEvePointSet::fIntIdsOptional array of integer ideices.; Int_tTEvePointSet::fIntIdsPerPointNumber of integer indices assigned to each point.; TEveElement::sLTI_tTEveElement::fItems! Set of list-tree-items.; Int_tTPolyMarker3D::fLastPointThe index of the last filled point; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TEveProjectionManager*TEveProjected::fManagermanager; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTPolyMarker3D::fNNumber of allocated points; TStringTPolyMarker3D::fNameName of polymarker; Int_tTEveElement::fNumChildren!; TStringTPolyMarker3D::fOptionOptions; Bool_tTPointSet3D::fOwnIdsFlag specifying id-objects are owned by the point-set; Float_t*TPolyMarker3D::fP[3*fN] Array of X,Y,Z coordinates; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; TEveElement::List_tTEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; TEveProjectable*TEveProjected::fProjectablelink to original object; TEveProjectable::ProjList_tTEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TRefTEveElement::fSourceExternal object that is represented by this element.; TEvePointSelectorConsumer::ETreeVarType_eTEvePointSelectorConsumer::fSourceCSCoordinate-System of the source tree variables; TStringTEvePointSet::fTitleTitle/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEvePointSetProjected.html:26483,allocate,allocated,26483,root/html602/TEvePointSetProjected.html,https://root.cern,https://root.cern/root/html602/TEvePointSetProjected.html,4,['allocate'],['allocated']
Energy Efficiency," Streamer method; 6078/// kInstrumented: the class does have a Streamer method; 6079/// kExternal: the class has a free standing way of streaming itself; 6080/// kEmulatedStreamer: the class is missing its shared library.; 6081/// ~~~; 6082///; 6083/// Implementation note: the data member fProperty has the value -1; 6084/// until it is initialized.; 6085 ; 6086Long_t TClass::Property() const; 6087{; 6088 // Check if we can return without taking the lock,; 6089 // this is valid since fProperty is atomic and set as; 6090 // the last operation before return.; 6091 if (fProperty!=(-1)) return fProperty;; 6092 ; 6093 R__LOCKGUARD(gInterpreterMutex);; 6094 ; 6095 // Check if another thread set fProperty while we; 6096 // were waiting.; 6097 if (fProperty!=(-1)) return fProperty;; 6098 ; 6099 // Avoid asking about the class when it is still building; 6100 if (TestBit(kLoading)) return fProperty;; 6101 ; 6102 // When called via TMapFile (e.g. Update()) make sure that the dictionary; 6103 // gets allocated on the heap and not in the mapped file.; 6104 TMmallocDescTemp setreset;; 6105 ; 6106 TClass *kl = const_cast<TClass*>(this);; 6107 ; 6108 kl->fStreamerType = TClass::kDefault;; 6109 kl->fStreamerImpl = &TClass::StreamerDefault;; 6110 ; 6111 if (InheritsFrom(TObject::Class())) {; 6112 kl->SetBit(kIsTObject);; 6113 ; 6114 // Is it DIRECT inheritance from TObject?; 6115 Int_t delta = kl->GetBaseClassOffsetRecurse(TObject::Class());; 6116 if (delta==0) kl->SetBit(kStartWithTObject);; 6117 ; 6118 kl->fStreamerType = kTObject;; 6119 kl->fStreamerImpl = &TClass::StreamerTObject;; 6120 }; 6121 ; 6122 if (HasInterpreterInfo()) {; 6123 ; 6124 // This code used to use ClassInfo_Has|IsValidMethod but since v6; 6125 // they return true if the routine is defined in the class or any of; 6126 // its parent. We explicitly want to know whether the function is; 6127 // defined locally.; 6128 if (!const_cast<TClass*>(this)->GetClassMethodWithPrototype(""Streamer"",""TBuffer&"",kFALSE)) {; 6129 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:234738,allocate,allocated,234738,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," Streamer method; 6145/// kInstrumented: the class does have a Streamer method; 6146/// kExternal: the class has a free standing way of streaming itself; 6147/// kEmulatedStreamer: the class is missing its shared library.; 6148/// ~~~; 6149///; 6150/// Implementation note: the data member fProperty has the value -1; 6151/// until it is initialized.; 6152 ; 6153Long_t TClass::Property() const; 6154{; 6155 // Check if we can return without taking the lock,; 6156 // this is valid since fProperty is atomic and set as; 6157 // the last operation before return.; 6158 if (fProperty!=(-1)) return fProperty;; 6159 ; 6160 R__LOCKGUARD(gInterpreterMutex);; 6161 ; 6162 // Check if another thread set fProperty while we; 6163 // were waiting.; 6164 if (fProperty!=(-1)) return fProperty;; 6165 ; 6166 // Avoid asking about the class when it is still building; 6167 if (TestBit(kLoading)) return fProperty;; 6168 ; 6169 // When called via TMapFile (e.g. Update()) make sure that the dictionary; 6170 // gets allocated on the heap and not in the mapped file.; 6171 TMmallocDescTemp setreset;; 6172 ; 6173 TClass *kl = const_cast<TClass*>(this);; 6174 ; 6175 kl->fStreamerType = TClass::kDefault;; 6176 kl->fStreamerImpl = &TClass::StreamerDefault;; 6177 ; 6178 if (InheritsFrom(TObject::Class())) {; 6179 kl->SetBit(kIsTObject);; 6180 ; 6181 // Is it DIRECT inheritance from TObject?; 6182 Int_t delta = kl->GetBaseClassOffsetRecurse(TObject::Class());; 6183 if (delta==0) kl->SetBit(kStartWithTObject);; 6184 ; 6185 kl->fStreamerType = kTObject;; 6186 kl->fStreamerImpl = &TClass::StreamerTObject;; 6187 }; 6188 ; 6189 if (HasInterpreterInfo()) {; 6190 ; 6191 // This code used to use ClassInfo_Has|IsValidMethod but since v6; 6192 // they return true if the routine is defined in the class or any of; 6193 // its parent. We explicitly want to know whether the function is; 6194 // defined locally.; 6195 if (!const_cast<TClass*>(this)->GetClassMethodWithPrototype(""Streamer"",""TBuffer&"",kFALSE)) {; 6196 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:237489,allocate,allocated,237489,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," T > &v);  . Additional Inherited Members;  Protected Member Functions inherited from ROOT::Detail::VecOps::RVecImpl< T >;  RVecImpl (unsigned N);  ;  Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorTemplateBase< T, bool >;  SmallVectorTemplateBase (size_t Size);  ; void grow (size_t MinSize=0);  Grow the allocated memory (without initializing new elements), doubling the size of the allocated memory. ;  ;  Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorTemplateCommon< T >;  SmallVectorTemplateCommon (size_t Size);  ; void grow_pod (size_t MinSize, size_t TSize);  ; bool isSmall () const;  Return true if this is a smallvector which has not had dynamic memory allocated for it. ;  ; void resetToSmall ();  Put this vector in a state of being small. ;  ;  Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorBase;  SmallVectorBase ()=delete;  ;  SmallVectorBase (void *FirstEl, size_t TotalCapacity);  ; void grow_pod (void *FirstEl, size_t MinSize, size_t TSize);  This is an implementation of the grow() method which only works on POD-like data types and is out of line to reduce code duplication. ;  ; bool Owns () const;  If false, the RVec is in ""memory adoption"" mode, i.e. it is acting as a view on a memory buffer it does not own. ;  ;  Static Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorTemplateBase< T, bool >; static void destroy_range (T *S, T *E);  ; template<typename It1 , typename It2 > ; static void uninitialized_copy (It1 I, It1 E, It2 Dest);  Copy the range [I, E) onto the uninitialized memory starting with ""Dest"", constructing elements as needed. ;  ; template<typename It1 , typename It2 > ; static void uninitialized_move (It1 I, It1 E, It2 Dest);  Move the range [I, E) into the uninitialized memory starting with ""Dest"", constructing elements as needed. ;  ;  Static Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorBase; st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html:18808,reduce,reduce,18808,doc/v632/classROOT_1_1VecOps_1_1RVec.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html,2,['reduce'],['reduce']
Energy Efficiency," TBranchElement *sub = (TBranchElement*) fBranches[i];; 4846 sub->ResetInitInfo(true);; 4847 }; 4848 }; 4849}; 4850 ; 4851////////////////////////////////////////////////////////////////////////////////; 4852/// Point this branch at an object.; 4853///; 4854/// For a sub-branch, addr is a pointer to the branch object.; 4855///; 4856/// For a top-level branch the meaning of addr is as follows:; 4857///; 4858/// If addr is zero, then we allocate a branch object; 4859/// internally and the branch is the owner of the allocated; 4860/// object, not the caller. However the caller may obtain; 4861/// a pointer to the branch object with GetObject().; 4862/// The pointer is reset to zero (nullptr) when the relevant; 4863/// branch object is destroyed.; 4864///; 4865/// Example:; 4866/// ~~~ {.cpp}; 4867/// branch->SetAddress(0);; 4868/// Event* event = branch->GetObject();; 4869/// ... Do some work.; 4870/// ~~~; 4871/// If addr is not zero, but the pointer addr points at is; 4872/// zero, then we allocate a branch object and set the passed; 4873/// pointer to point at the allocated object. The caller; 4874/// owns the allocated object and is responsible for deleting; 4875/// it when it is no longer needed.; 4876///; 4877/// Example:; 4878/// ~~~ {.cpp}; 4879/// Event* event = 0;; 4880/// branch->SetAddress(&event);; 4881/// ... Do some work.; 4882/// delete event;; 4883/// event = 0;; 4884/// ~~~; 4885/// If addr is not zero and the pointer addr points at is; 4886/// also not zero, then the caller has allocated a branch; 4887/// object and is asking us to use it. The caller owns it; 4888/// and must delete it when it is no longer needed.; 4889///; 4890/// Example:; 4891/// ~~~ {.cpp}; 4892/// Event* event = new Event();; 4893/// branch->SetAddress(&event);; 4894/// ... Do some work.; 4895/// delete event;; 4896/// event = 0;; 4897/// ~~~; 4898/// These rules affect users of TTree::Branch(),; 4899/// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); 4900/// as well b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:180200,allocate,allocate,180200,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency," TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTMVA::MethodBase::IsSignalLike(); virtual Bool_tTMVA::MethodBase::IsSignalLike(Double_t mvaVal); virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMakeClass(const TString& = TString("""")) const; voidTObject::MayNotUse(const char* method) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; TMVA::MethodCategoryMethodCategory(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodCategoryMethodCategory(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = NULL); virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodCategory.html:8833,Monitor,MonitorBoost,8833,root/html532/TMVA__MethodCategory.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodCategory.html,1,['Monitor'],['MonitorBoost']
Energy Efficiency," TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTMVA::MethodBase::IsSignalLike(); virtual Bool_tTMVA::MethodBase::IsSignalLike(Double_t mvaVal); virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTMVA::MethodBase::MakeClass(const TString& classFileName = TString("""")) const; voidTObject::MayNotUse(const char* method) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; TMVA::MethodLDMethodLD(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = 0); TMVA::MethodLDMethodLD(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""LD"", TDirectory* theTargetDir = 0); virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodLD.html:8213,Monitor,MonitorBoost,8213,root/html532/TMVA__MethodLD.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodLD.html,1,['Monitor'],['MonitorBoost']
Energy Efficiency," TCudaDeviceReference< AFloat > operator() (size_t i, size_t j, size_t k, size_t l) const;  ; TCudaTensor & operator= (const TCudaTensor &)=default;  ; TCudaTensor & operator= (TCudaTensor &&)=default;  ; TCudaMatrix< AFloat > operator[] (size_t i) const;  ; void Print (const char *name=""Tensor"", bool truncate=false) const;  ; void PrintShape (const char *name=""Tensor"") const;  ; TCudaTensor< AFloat > Reshape (const Shape_t &newShape) const;  ; void ReshapeInPlace (const Shape_t &newShape);  ; void SetComputeStream (cudaStream_t stream);  ; void SetConstVal (const AFloat constVal);  ; void SetTensorDescriptor ();  ; void Zero ();  . Static Public Member Functions; static std::vector< std::size_t > ComputeStridesFromShape (const std::vector< std::size_t > &shape, bool rowmajorLayout);  This information is needed for the multi-dimensional indexing. ;  . Private Member Functions; void InitializeCuda ();  Initializes all shared devices resource and makes sure that a sufficient number of curand states are allocated on the device and initialized as well as that the one-vector for the summation over columns has the right size. ;  ; void InitializeCurandStates ();  . Private Attributes; int fDevice;  Device associated with current tensor instance. ;  ; TCudaDeviceBuffer< AFloat > fElementBuffer;  ; MemoryLayout fMemoryLayout;  ; size_t fNDim;  Dimension of the tensor (first dimension is the batch size, second is the no. channels) ;  ; Shape_t fShape;  The shape vector (size of dimensions) needs to be ordered as no. ;  ; size_t fSize;  No. of elements. ;  ; int fStreamIndx;  Cuda stream associated with current instance. ;  ; Shape_t fStrides;  Strides between tensor dimensions (always assume dense, non overlapping tensor) ;  ; std::shared_ptr< TensorDescriptor > fTensorDescriptor;  . Static Private Attributes; static std::vector< int > fInstances;  For each GPU device keep the CUDA streams in which tensors are used. ;  . #include <TMVA/DNN/Architectures/Cuda/CudaTensor.h>; M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCudaTensor.html:4324,allocate,allocated,4324,doc/master/classTMVA_1_1DNN_1_1TCudaTensor.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCudaTensor.html,1,['allocate'],['allocated']
Energy Efficiency," TDatabasePDG(); virtual~TDatabasePDG(); voidTObject::AbstractMethod(const char* method) const; virtual TParticlePDG*AddAntiParticle(const char* Name, Int_t PdgCode); virtual TParticlePDG*AddParticle(const char* Name, const char* Title, Double_t Mass, Bool_t Stable, Double_t DecayWidth, Double_t Charge, const char* ParticleClass, Int_t PdgCode, Int_t Anti = -1, Int_t TrackingCode = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tConvertGeant3ToPdg(Int_t Geant3Number) const; virtual Int_tConvertIsajetToPdg(Int_t isaNumber) const; virtual Int_tConvertPdgToGeant3(Int_t pdgNumber) const; virtual voidTNamed::Copy(TObject& named) const; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDatabasePDG.html:1358,Charge,Charge,1358,root/html534/TDatabasePDG.html,https://root.cern,https://root.cern/root/html534/TDatabasePDG.html,1,['Charge'],['Charge']
Energy Efficiency," TDatabasePDG(); virtual~TDatabasePDG(); voidTObject::AbstractMethod(const char* method) const; virtual TParticlePDG*AddAntiParticle(const char* Name, Int_t PdgCode); virtual TParticlePDG*AddParticle(const char* Name, const char* Title, Double_t Mass, Bool_t Stable, Double_t DecayWidth, Double_t Charge, const char* ParticleClass, Int_t PdgCode, Int_t Anti = -1, Int_t TrackingCode = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tConvertGeant3ToPdg(Int_t Geant3Number); virtual Int_tConvertIsajetToPdg(Int_t isaNumber); virtual Int_tConvertPdgToGeant3(Int_t pdgNumber); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDatabasePDG.html:1358,Charge,Charge,1358,root/html532/TDatabasePDG.html,https://root.cern,https://root.cern/root/html532/TDatabasePDG.html,1,['Charge'],['Charge']
Energy Efficiency," TEmulatedCollectionProxy(const TEmulatedCollectionProxy& copy); TEmulatedCollectionProxy(const char* cl_name, Bool_t silent); virtual~TEmulatedCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void* env); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE) const; virtual TVirtualCollectionProxy*Generate() const; virtual TClass*TGenCollectionProxy::GetCollectionClass() const; virtual Int_tTGenCollectionProxy::GetCollectionType() const; virtual TStreamerInfoActions::TActionSequence*TGenCollectionProxy::GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tTGenCollectionProxy::GetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tTGenCollectionProxy::GetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tTGenCollectionProxy::GetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tTGenCollectionProxy::GetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tTGenCollectionProxy::GetFunctionNext",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEmulatedCollectionProxy.html:865,Allocate,Allocate,865,root/html534/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TEmulatedCollectionProxy.html,1,['Allocate'],['Allocate']
Energy Efficiency," TEmulatedCollectionProxy(const TEmulatedCollectionProxy& copy); TEmulatedCollectionProxy(const char* cl_name, Bool_t silent); virtual~TEmulatedCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void* env); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual TVirtualCollectionProxy*Generate() const; virtual TClass*TGenCollectionProxy::GetCollectionClass(); virtual Int_tTGenCollectionProxy::GetCollectionType(); virtual TStreamerInfoActions::TActionSequence*TGenCollectionProxy::GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tTGenCollectionProxy::GetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tTGenCollectionProxy::GetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tTGenCollectionProxy::GetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tTGenCollectionProxy::GetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tTGenCollectionProxy::GetFunctionNext(Bool_t read = kTRUE); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEmulatedCollectionProxy.html:865,Allocate,Allocate,865,root/html532/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html532/TEmulatedCollectionProxy.html,1,['Allocate'],['Allocate']
Energy Efficiency," TEmulatedMapProxy(const TEmulatedMapProxy& copy); TEmulatedMapProxy(const char* cl_name, Bool_t silent); virtual~TEmulatedMapProxy(); virtual void*TEmulatedCollectionProxy::Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidTEmulatedCollectionProxy::Clear(const char* opt = """"); virtual voidTEmulatedCollectionProxy::Commit(void* env); virtual voidTEmulatedCollectionProxy::DeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; virtual voidTEmulatedCollectionProxy::Destructor(void* p, Bool_t dtorOnly = kFALSE) const; virtual TVirtualCollectionProxy*Generate() const; virtual TClass*TGenCollectionProxy::GetCollectionClass() const; virtual Int_tTGenCollectionProxy::GetCollectionType() const; virtual TStreamerInfoActions::TActionSequence*TGenCollectionProxy::GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tTGenCollectionProxy::GetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tTGenCollectionProxy::GetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tTGenCollectionProxy::GetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tTGenCollectionProxy::GetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tTGenCollectionProxy::GetFunctionNext(Bool_t read = kTRUE); virtual ULong_tTGenCollectionProxy::GetIncrement() const; virtual TClass*TGenCollectionProxy::GetOnFileClass()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEmulatedMapProxy.html:628,Allocate,Allocate,628,root/html534/TEmulatedMapProxy.html,https://root.cern,https://root.cern/root/html534/TEmulatedMapProxy.html,1,['Allocate'],['Allocate']
Energy Efficiency," TEmulatedMapProxy(const TEmulatedMapProxy& copy); TEmulatedMapProxy(const char* cl_name, Bool_t silent); virtual~TEmulatedMapProxy(); virtual void*TEmulatedCollectionProxy::Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidTEmulatedCollectionProxy::Clear(const char* opt = """"); virtual voidTEmulatedCollectionProxy::Commit(void* env); virtual voidTEmulatedCollectionProxy::DeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidTEmulatedCollectionProxy::Destructor(void* p, Bool_t dtorOnly = kFALSE); virtual TVirtualCollectionProxy*Generate() const; virtual TClass*TGenCollectionProxy::GetCollectionClass(); virtual Int_tTGenCollectionProxy::GetCollectionType(); virtual TStreamerInfoActions::TActionSequence*TGenCollectionProxy::GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tTGenCollectionProxy::GetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tTGenCollectionProxy::GetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tTGenCollectionProxy::GetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tTGenCollectionProxy::GetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tTGenCollectionProxy::GetFunctionNext(Bool_t read = kTRUE); virtual ULong_tTGenCollectionProxy::GetIncrement(); virtual TClass*TGenCollectionProxy::GetOnFileClass() const; virtual Int_tTVirtualC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEmulatedMapProxy.html:628,Allocate,Allocate,628,root/html532/TEmulatedMapProxy.html,https://root.cern,https://root.cern/root/html532/TEmulatedMapProxy.html,1,['Allocate'],['Allocate']
Energy Efficiency," TF1 class has several additions for its use from Python, which are also available in its subclasses TF2 and TF3.; First, TF1 instance can be initialized with user-defined Python functions. Given a generic Python callable, the following can performed:; def func(x: numpy.ndarray, pars: numpy.ndarray) -> float:; return pars[0] * x[0] * x[0] + x[1] * pars[0]; ; my_func = ROOT.TF1(""my_func"", func, -10, 10, npar=2, ndim=2); Second, after performing the initialisation with a Python functor, the TF1 instance can be evaluated using the Pythonized TF1::EvalPar function. The pythonization allows passing in 1D(single set of x variables) or 2D(a dataset) NumPy arrays.; The following example shows how we can create a TF1 instance with a Python function and evaluate it on a dataset:; import ROOT; import math; import numpy as np; ; def pyf_tf1_coulomb(x, p):; return p[1] * x[0] * x[1] / (p[0]**2) * math.exp(-p[2] / p[0]); ; rtf1_coulomb = ROOT.TF1(""my_func"", pyf_tf1_coulomb, -10, 10, ndims = 2, npars = 3); ; # x dataset: 5 pairs of particle charges; x = np.array([; [1.0, 10, 2.0],; [1.5, 10, 2.5],; [2.0, 10, 3.0],; [2.5, 10, 3.5],; [3.0, 10, 4.0]; ]); ; params = np.array([; [1.0], # Distance between charges r; [8.99e9], # Coulomb constant k (in N·m²/C²); [0.1] # Additional factor for modulation; ]); ; # Slice to avoid the dummy column of 10's; res = rtf1_coulomb.EvalPar(x[:, ::2], params). Definition at line 233 of file TF1.h. Classes; struct  TF1FunctorPointer;  ; struct  TF1FunctorPointerImpl;  . Public Types; enum class  EAddToList { kDefault; , kAdd; , kNo; };  Add to list behavior. More...;  ; enum  EStatusBits { kNotGlobal = (1ULL << ( 10 )); , kNotDraw = (1ULL << ( 9 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; en",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:9060,charge,charges,9060,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['charge'],['charges']
Energy Efficiency," TF1Parameters::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 130 of file TF1.h. ◆ DeclFileName(). static const char * TF1Parameters::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 130 of file TF1.h. ◆ GetParameter() [1/2]. Double_t TF1Parameters::GetParameter ; (; const char * ; name); const. inline . Definition at line 84 of file TF1.h. ◆ GetParameter() [2/2]. Double_t TF1Parameters::GetParameter ; (; Int_t ; iparam); const. inline . Definition at line 80 of file TF1.h. ◆ GetParameters(). const Double_t * TF1Parameters::GetParameters ; (; ); const. inline . Definition at line 88 of file TF1.h. ◆ GetParName(). const char * TF1Parameters::GetParName ; (; Int_t ; iparam); const. inline . Definition at line 99 of file TF1.h. ◆ GetParNumber(). Int_t TF1Parameters::GetParNumber ; (; const char * ; name); const. Returns the parameter number given a name not very efficient but list of parameters is typically small could use a map if needed. ; Definition at line 3846 of file TF1.cxx. ◆ IsA(). virtual TClass * TF1Parameters::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 130 of file TF1.h. ◆ operator=(). TF1Parameters & TF1Parameters::operator= ; (; const TF1Parameters & ; rhs). inline . Definition at line 70 of file TF1.h. ◆ ParamsVec(). const std::vector< double > & TF1Parameters::ParamsVec ; (; ); const. inline . Definition at line 92 of file TF1.h. ◆ SetParameter() [1/2]. void TF1Parameters::SetParameter ; (; const char * ; name, . Double_t ; value . ). inline . Definition at line 118 of file TF1.h. ◆ SetParameter() [2/2]. void TF1Parameters::SetParameter ; (; Int_t ; iparam, . Double_t ; value . ). inline . Definition at line 106 of file TF1.h. ◆ SetParameters() [1/2]. void TF1Parameters::SetParameters ; (; const Double_t * ; params). inline . Definition at line 111 of file TF1.h. ◆ SetParameters() [2/2]. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1Parameters.html:3845,efficient,efficient,3845,doc/master/classTF1Parameters.html,https://root.cern,https://root.cern/doc/master/classTF1Parameters.html,1,['efficient'],['efficient']
Energy Efficiency," TGText. class TGText. TGText. A TGText is a multi line text buffer. It allows the text to be; loaded from file, saved to file and edited. It is used in the; TGTextEdit widget. Single line text is handled by TGTextBuffer; and the TGTextEntry widget. Function Members (Methods); public:. TGText(); TGText(TGText* text); TGText(const char* string); virtual~TGText(); Bool_tAddText(TGText* text); Bool_tAppend(const char* fn); TStringAsString(); Bool_tBreakLine(TGLongPosition pos); static TClass*Class(); voidClear(); Long_tColCount() const; Bool_tDelChar(TGLongPosition pos); Bool_tDelLine(ULong_t pos); Bool_tDelText(TGLongPosition start, TGLongPosition end); charGetChar(TGLongPosition pos); TGTextLine*GetCurrentLine() const; const char*GetFileName() const; char*GetLine(TGLongPosition pos, ULong_t length); Long_tGetLineLength(Long_t row); Long_tGetLongestLine() const; Bool_tInsChar(TGLongPosition pos, char c); Bool_tInsLine(ULong_t row, const char* string); Bool_tInsText(TGLongPosition pos, const char* buf); Bool_tInsText(TGLongPosition ins_pos, TGText* src, TGLongPosition start_src, TGLongPosition end_src); virtual TClass*IsA() const; Bool_tIsSaved() const; Bool_tLoad(const char* fn, Long_t startpos = 0, Long_t length = -1); Bool_tLoadBuffer(const char* txtbuf); Bool_tReplace(TGLongPosition start, const char* oldText, const char* newText, Bool_t direction, Bool_t caseSensitive); voidReTab(Long_t row); Long_tRowCount() const; Bool_tSave(const char* fn); Bool_tSearch(TGLongPosition* foundPos, TGLongPosition start, const char* searchString, Bool_t direction, Bool_t caseSensitive); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TGText(const TGText&); voidInit(); voidLongestLine(); TGText&operator=(const TGText&); Bool_tSetCurrentRow(Long_t row). Data Members; protected:. Long_tfColCountnumber of columns in current line; TGTextLine*fCurrentcurrent line; Long_tfCurrentRowcurrent row number; TString",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGText.html:898,charGe,charGetChar,898,root/html532/TGText.html,https://root.cern,https://root.cern/root/html532/TGText.html,1,['charGe'],['charGetChar']
Energy Efficiency," TGenCollectionProxy(const TGenCollectionProxy& copy); TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); TGenCollectionProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl); virtual~TGenCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void* env); virtual voidTVirtualCollectionProxy::DeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; virtual voidTVirtualCollectionProxy::Destructor(void* p, Bool_t dtorOnly = kFALSE) const; virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass() const; virtual Int_tGetCollectionType() const; virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGenCollectionProxy.html:962,Allocate,Allocate,962,root/html534/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html,1,['Allocate'],['Allocate']
Energy Efficiency," TGenCollectionProxy(const TGenCollectionProxy& copy); TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); TGenCollectionProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl); virtual~TGenCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void* env); virtual voidTVirtualCollectionProxy::DeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidTVirtualCollectionProxy::Destructor(void* p, Bool_t dtorOnly = kFALSE); virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass(); virtual Int_tGetCollectionType(); virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGenCollectionProxy.html:962,Allocate,Allocate,962,root/html532/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html,1,['Allocate'],['Allocate']
Energy Efficiency," TGenPhaseSpace.h. ◆ GetWtMax(). Double_t TGenPhaseSpace::GetWtMax ; (; ); const. inline . Definition at line 37 of file TGenPhaseSpace.h. ◆ IsA(). TClass * TGenPhaseSpace::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 39 of file TGenPhaseSpace.h. ◆ operator=(). TGenPhaseSpace & TGenPhaseSpace::operator= ; (; const TGenPhaseSpace & ; gen). Assignment operator. ; Definition at line 76 of file TGenPhaseSpace.cxx. ◆ PDK(). Double_t TGenPhaseSpace::PDK ; (; Double_t ; a, . Double_t ; b, . Double_t ; c . ). private . The PDK function. ; Definition at line 35 of file TGenPhaseSpace.cxx. ◆ SetDecay(). Bool_t TGenPhaseSpace::SetDecay ; (; TLorentzVector & ; P, . Int_t ; nt, . const Double_t * ; mass, . Option_t * ; opt = """" . ). Input: . TLorentzVector &P: decay particle (Momentum, Energy units are Gev/C, GeV); Int_t nt: number of decay products; Double_t *mass: array of decay product masses; Option_t *opt: default -> constant cross section ""Fermi"" -> Fermi energy dependence Return value:; kTRUE: the decay is permitted by kinematics; kFALSE: the decay is forbidden by kinematics . Definition at line 193 of file TGenPhaseSpace.cxx. ◆ Streamer(). void TGenPhaseSpace::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGenPhaseSpace::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 39 of file TGenPhaseSpace.h. Member Data Documentation. ◆ fBeta. Double_t TGenPhaseSpace::fBeta[3]. private . Definition at line 19 of file TGenPhaseSpace.h. ◆ fDecPro. TLorentzVector TGenPhaseSpace::fDecPro[18]. private . Definition at line 22 of file TGenPhaseSpace.h. ◆ fMass. Double_t TGenPhaseSpace::fMass[18]. private . Definition at line 18 of file TGenPhaseSpace.h. ◆ fNt. Int_t TGenPhaseSpace::fNt. private . Definition at line 17 of file TGenPhaseSpace.h. ◆ fTeCmTm. Double_t TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenPhaseSpace.html:14287,energy,energy,14287,doc/master/classTGenPhaseSpace.html,https://root.cern,https://root.cern/doc/master/classTGenPhaseSpace.html,1,['energy'],['energy']
Energy Efficiency," TGeoHelix(); TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); virtual~TGeoHelix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tComputeSafeStep(Double_t epsil = 1E-6) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHelix.html:1449,charge,charge,1449,root/html534/TGeoHelix.html,https://root.cern,https://root.cern/root/html534/TGeoHelix.html,2,['charge'],['charge']
Energy Efficiency," TGeoHelix(); TGeoHelix(const TGeoHelix&); TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); virtual~TGeoHelix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tComputeSafeStep(Double_t epsil = 1E-6) const; virtual voidTObject::Copy(TObject& object) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHelix.html:1478,charge,charge,1478,root/html528/TGeoHelix.html,https://root.cern,https://root.cern/root/html528/TGeoHelix.html,4,['charge'],['charge']
Energy Efficiency," TH1.cxx:9707; TH1S::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.cxx:9724; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::~TH1~TH1() overrideHistogram default destructor.Definition TH1.cxx:643; TH1::SetLabelFontvirtual void SetLabelFont(Style_t font=62, Option_t *axis=""X"")Set font number used to draw axis labels.Definition Haxis.cxx:249; TH1::SetErrorvirtual void SetError(const Double_t *error)Replace bin errors by values in array error.Definition TH1.cxx:8951; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FitPanelvirtual void FitPanel()Display a panel with all histogram fit options.Definition TH1.cxx:4284; TH1::fBufferDouble_t * fBuffer[fBufferSize] entry bufferDefinition TH1.h:108; TH1::AutoP2FindLimitsvirtual Int_t AutoP2FindLimits(Double_t min, Double_t max)Buffer-based estimate of the histogram range using the power of 2 algorithm.Definition TH1.cxx:1343; TH1::SetStatOverflowsvoid SetStatOverflows(EStatOverflows statOverflows)See GetStatOverflows for more information.Definition TH1.h:417; TH1::GetEffectiveEntriesvirtual Double_t GetEffectiveEntries() constNumber of effective entries of the histogram.Definition TH1.cxx:4448; TH1::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideRedefines TObject::GetObjectInfo.Definition TH1.cxx:4502; TH1::Smoothvirtual void Smooth(Int_t ntimes=1, Option_t *option="""")Smooth bin contents of this histogram.Definition TH1.cxx:6879; TH1::SetNormFactorvirtual void SetNormFactor(Double_t factor=1)Definition TH1.h:410; TH1::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn bin center for 1D histogram.Definition TH1.cxx:9141; TH1::Rebuildvirtual void Rebuild(Option_t *option="""")Using the current bin info, recompute the arrays for contents and errors.Definition TH1.cxx:7087; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8h_source.html:51708,power,power,51708,doc/master/TH1_8h_source.html,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html,1,['power'],['power']
Energy Efficiency," THnF (typedef for THnT<Float_t>): bin content held by a Float_t,; 141 THnL (typedef for THnT<Long64_t>): bin content held by a Long64_t,; 142 THnI (typedef for THnT<Int_t>): bin content held by an Int_t,; 143 THnS (typedef for THnT<Short_t>): bin content held by a Short_t,; 144 THnC (typedef for THnT<Char_t>): bin content held by a Char_t,; 145 ; 146They take name and title, the number of dimensions, and for each dimension; 147the number of bins, the minimal, and the maximal value on the dimension's; 148axis. A TH2F h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; 149 ; 150 Int_t bins[2] = {10, 20};; 151 Double_t xmin[2] = {0., -5.};; 152 Double_t xmax[2] = {10., 5.};; 153 THnF hn(""hn"", ""hn"", 2, bins, xmin, xmax);; 154 ; 155## Filling; 156A THn is filled just like a regular histogram, using; 157THn::Fill(x, weight), where x is a n-dimensional Double_t value.; 158To take errors into account, Sumw2() must be called before filling the; 159histogram.; 160Storage is allocated when the first bin content is stored.; 161 ; 162## Projections; 163The dimensionality of a THn can be reduced by projecting it to; 1641, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; 165a THn. See the Projection() members. To only project parts of the; 166histogram, call; 167 ; 168 hn->GetAxis(12)->SetRange(from_bin, to_bin);; 169 ; 170## Conversion from other histogram classes; 171The static factory function THn::CreateHn() can be used to create a THn; 172from a TH1, TH2, TH3, THnSparse and (for copying) even from a THn. The; 173created THn will have compatble storage type, i.e. calling CreateHn() on; 174a TH2F will create a THnF.; 175*/; 176 ; 177ClassImp(THn);; 178 ; 179////////////////////////////////////////////////////////////////////////////////; 180/// Construct a THn.; 181 ; 182THn::THn(const char* name, const char* title,; 183 Int_t dim, const Int_t* nbins,; 184 const Double_t* xmin, const Double_t* xmax):; 185 THnBase(name, title, dim, nbins, xmin, xmax),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THn_8cxx_source.html:5961,allocate,allocated,5961,doc/master/THn_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THn_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension ;  statsEditing.C Edit statistics box ;  testSmooth.C Histogram smoothing ;  th2polyBoxes.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly) ;  th2polyEurope.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it ;  th2polyHoneycomb.C This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly) ;  th2polyUSA.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option ;  thstack2palettecolor.C Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color) ;  thstackpalettecolor.C Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  tprofile2polyRealistic.C Different charges depending on region ;  tprofile2polyRealisticModuleError.C Simulate faulty detector panel w.r.t ;  transpad.C Example of a canvas showing two histograms with different scales ;  twoscales.C Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad ;  twoscales.py Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad ;  xyplot.C Example showing how to produce a plot with an orthogonal axis system centered at (0,0) ;  ► histfactory;  example.C;  example.py;  makeExample.C;  makeQuickModel.py;  ModifyInterpolation.C;  ► html;  MakeTutorials.C;  ► http;  custom.CThis program creates and fills one and two dimensional histogram Macro used to demonstrate usage of custom HTML page in custom.htm One can use plain JavaScript to assign different actions with HTML buttons ;  histfitserver.CThis program demonstrates simultaneous update of histogram and fitted function ;  httpaccess.CThis program demonstrates access control",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:125570,charge,charges,125570,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,3,['charge'],['charges']
Energy Efficiency," THnSparse with ""dim"" dimensions,; with chunksize as the size of the chunks.; ""nbins"" holds the number of bins for each dimension;; ""xmin"" and ""xmax"" the minimal and maximal value for each dimension.; The arrays ""xmin"" and ""xmax"" can be NULL; in that case SetBinEdges(); must be called for each dimension. ~THnSparse(); Destruct a THnSparse. void AddBinContent(Long64_t bin, Double_t v = 1.); Add ""v"" to the content of bin with index ""bin"". THnSparseArrayChunk* AddChunk(); Create a new chunk of bin content. void InitStorage(Int_t* nbins, Int_t chunkSize); Initialize the storage of a histogram created via Init(). void FillExMap(); We have been streamed; set up fBins. void Reserve(Long64_t nbins); Initialize storage for nbins. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError2(Long64_t linidx) const; Get square of the error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THnSparse.html:18297,allocate,allocate,18297,root/html602/THnSparse.html,https://root.cern,https://root.cern/root/html602/THnSparse.html,12,['allocate'],['allocate']
Energy Efficiency," THnSparseArrayChunk::THnSparseArrayChunkTHnSparseArrayChunk()Definition THnSparse_Internal.h:37; THnSparseArrayChunk::fCoordinatesSizeInt_t fCoordinatesSizeSize of the bin coordinate buffer.Definition THnSparse_Internal.h:46; THnSparseArrayChunk::fSingleCoordinateSizeInt_t fSingleCoordinateSizeSize of a single bin coordinate.Definition THnSparse_Internal.h:45; THnSparseArrayChunk::Sumw2void Sumw2()Turn on support of errors.Definition THnSparse.cxx:480; THnSparseArrayChunk::fCoordinatesChar_t * fCoordinates[fCoordinatesSize] compact bin coordinate bufferDefinition THnSparse_Internal.h:47; THnSparseArrayChunk::fContentTArray * fContentBin content.Definition THnSparse_Internal.h:48; THnSparseArrayChunk::GetEntriesInt_t GetEntries() constDefinition THnSparse_Internal.h:58; THnSparseArrayChunk::AddBinvoid AddBin(Int_t idx, const Char_t *idxbuf)Create a new bin in this chunk.Definition THnSparse.cxx:450; THnSparseArrayChunk::fCoordinateAllocationSizeInt_t fCoordinateAllocationSize! Size of the allocated coordinate buffer; -1 means none or fCoordinatesSizeDefinition THnSparse_Internal.h:44; THnSparseCompactBinCoordTHnSparseCompactBinCoord is a class used by THnSparse internally.Definition THnSparse.cxx:351; THnSparseCompactBinCoord::THnSparseCompactBinCoordTHnSparseCompactBinCoord(Int_t dim, const Int_t *nbins)Initialize a THnSparseCompactBinCoord object with ""dim"" dimensions and ""bins"" holding the number of b...Definition THnSparse.cxx:391; THnSparseCompactBinCoord::GetHashULong64_t GetHash() constDefinition THnSparse.cxx:357; THnSparseCompactBinCoord::GetCoordInt_t * GetCoord()Definition THnSparse.cxx:355; THnSparseCompactBinCoord::GetBufferconst Char_t * GetBuffer() constDefinition THnSparse.cxx:356; THnSparseCompactBinCoord::~THnSparseCompactBinCoord~THnSparseCompactBinCoord()destruct a THnSparseCompactBinCoordDefinition THnSparse.cxx:406; THnSparseCompactBinCoord::fCoordBufferChar_t * fCoordBufferDefinition THnSparse.cxx:378; THnSparseCompactBinCoord::THnSparseCompac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:42597,allocate,allocated,42597,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," TLorentzVector(const TLorentzVector& lorentzvector); {}. ~TLorentzVector(); {}. void Boost(Double_t , Double_t , Double_t ); Boost this Lorentz vector. Double_t Rapidity() const; return rapidity. TLorentzVector & Transform(const TLorentzRotation& ); Transform this Lorentzvector. void Streamer(TBuffer& ); Stream an object of class TLorentzVector. void Print(Option_t* option = """") const; Print the TLorentz vector components as (x,y,z,t) and (P,eta,phi,E) representations. Double_t X() const; { return fP.X(); }. Double_t Y() const; { return fP.Y(); }. Double_t Z() const; { return fP.Z(); }. Double_t T() const; { return fE; }. void SetX(Double_t a); { fP.SetX(a); }. void SetY(Double_t a); { fP.SetY(a); }. void SetZ(Double_t a); { fP.SetZ(a); }. void SetT(Double_t a); { fE = a; }. Double_t Px() const; { return X(); }. Double_t Py() const; { return Y(); }. Double_t Pz() const; { return Z(); }. Double_t P() const; { return fP.Mag(); }. Double_t E() const; { return T(); }. Double_t Energy() const; { return T(); }. void SetPx(Double_t a); { SetX(a); }. void SetPy(Double_t a); { SetY(a); }. void SetPz(Double_t a); { SetZ(a); }. void SetE(Double_t a); { SetT(a); }. TVector3 Vect() const; { return fP; }. void SetVect(const TVector3& p); { fP = p; }. Double_t Phi() const. Double_t Theta() const. Double_t CosTheta() const. Double_t Rho() const. void SetTheta(Double_t th). void SetPhi(Double_t phi). void SetRho(Double_t rho). void SetXYZT(Double_t x, Double_t y, Double_t z, Double_t t). void SetPxPyPzE(Double_t px, Double_t py, Double_t pz, Double_t e). void SetXYZM(Double_t x, Double_t y, Double_t z, Double_t m). void SetPtEtaPhiM(Double_t pt, Double_t eta, Double_t phi, Double_t m). void SetPtEtaPhiE(Double_t pt, Double_t eta, Double_t phi, Double_t e). void GetXYZT(Double_t* carray) const. void GetXYZT(Float_t* carray) const. Double_t Perp2() const; { return fP.Perp2(); }. Double_t Perp() const; { return fP.Perp(); }. Double_t Pt() const; { return Perp(); }. void SetPerp(Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TLorentzVector.html:16219,Energy,Energy,16219,root/html534/TLorentzVector.html,https://root.cern,https://root.cern/root/html534/TLorentzVector.html,1,['Energy'],['Energy']
Energy Efficiency," TLorentzVector(const TLorentzVector& lorentzvector); {}. ~TLorentzVector(); {}. void Boost(Double_t , Double_t , Double_t ); Boost this Lorentz vector. Double_t Rapidity() const; return rapidity. TLorentzVector & Transform(const TLorentzRotation& ); Transform this Lorentzvector. void Streamer(TBuffer& ); Stream an object of class TLorentzVector. void Print(Option_t* option = """") const; Print the TLorentz vector components as (x,y,z,t) and (P,eta,phi,E) representations. Double_t X() const; { return fP.X(); }. Double_t Y() const; { return fP.Y(); }. Double_t Z() const; { return fP.Z(); }. Double_t T() const; { return fE; }. void SetX(Double_t a); { fP.SetX(a); }. void SetY(Double_t a); { fP.SetY(a); }. void SetZ(Double_t a); { fP.SetZ(a); }. void SetT(Double_t a); { fE = a; }. Double_t Px() const; { return X(); }. Double_t Py() const; { return Y(); }. Double_t Pz() const; { return Z(); }. Double_t P() const; { return fP.Mag(); }. Double_t E() const; { return T(); }. Double_t Energy() const; { return T(); }. void SetPx(Double_t a); { SetX(a); }. void SetPy(Double_t a); { SetY(a); }. void SetPz(Double_t a); { SetZ(a); }. void SetE(Double_t a); { SetT(a); }. TVector3 Vect() const; { return fP; }. void SetVect(const TVector3& vect3); { fP = p; }. Double_t Phi() const. Double_t Theta() const. Double_t CosTheta() const. Double_t Rho() const. void SetTheta(Double_t theta). void SetPhi(Double_t phi). void SetRho(Double_t rho). void SetXYZT(Double_t x, Double_t y, Double_t z, Double_t t). void SetPxPyPzE(Double_t px, Double_t py, Double_t pz, Double_t e). void SetXYZM(Double_t x, Double_t y, Double_t z, Double_t m). void SetPtEtaPhiM(Double_t pt, Double_t eta, Double_t phi, Double_t m). void SetPtEtaPhiE(Double_t pt, Double_t eta, Double_t phi, Double_t e). void GetXYZT(Double_t* carray) const. void GetXYZT(Float_t* carray) const. Double_t Perp2() const; { return fP.Perp2(); }. Double_t Perp() const; { return fP.Perp(); }. Double_t Pt() const; { return Perp(); }. void SetPerp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLorentzVector.html:16837,Energy,Energy,16837,root/html602/TLorentzVector.html,https://root.cern,https://root.cern/root/html602/TLorentzVector.html,2,['Energy'],['Energy']
Energy Efficiency," TMCParticle(); TMCParticle(const TMCParticle&); TMCParticle(Int_t kS, Int_t kF, Int_t parent, Int_t firstchild, Int_t lastchild, Float_t px, Float_t py, Float_t pz, Float_t energy, Float_t mass, Float_t vx, Float_t vy, Float_t vz, Float_t time, Float_t lifetime); virtual~TMCParticle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMCParticle.html:530,energy,energy,530,root/html528/TMCParticle.html,https://root.cern,https://root.cern/root/html528/TMCParticle.html,4,['energy'],['energy']
Energy Efficiency, TMVA::MethodBDT::fLowSigCut. private . Definition at line 284 of file MethodBDT.h. ◆ fMaxDepth. UInt_t TMVA::MethodBDT::fMaxDepth. private . max depth ; Definition at line 242 of file MethodBDT.h. ◆ fMinLinCorrForFisher. Double_t TMVA::MethodBDT::fMinLinCorrForFisher. private . the minimum linear correlation between two variables demanded for use in fisher criterium in node splitting ; Definition at line 237 of file MethodBDT.h. ◆ fMinNodeEvents. Int_t TMVA::MethodBDT::fMinNodeEvents. private . min number of events in node ; Definition at line 231 of file MethodBDT.h. ◆ fMinNodeSize. Float_t TMVA::MethodBDT::fMinNodeSize. private . min percentage of training events in node ; Definition at line 232 of file MethodBDT.h. ◆ fMinNodeSizeS. TString TMVA::MethodBDT::fMinNodeSizeS. private . string containing min percentage of training events in node ; Definition at line 233 of file MethodBDT.h. ◆ fMonitorNtuple. TTree* TMVA::MethodBDT::fMonitorNtuple. private . monitoring ntuple ; Definition at line 264 of file MethodBDT.h. ◆ fNCuts. Int_t TMVA::MethodBDT::fNCuts. private . grid used in cut applied in node splitting ; Definition at line 235 of file MethodBDT.h. ◆ fNegWeightTreatment. TString TMVA::MethodBDT::fNegWeightTreatment. private . variable that holds the option of how to treat negative event weights in training ; Definition at line 255 of file MethodBDT.h. ◆ fNNodesMax. UInt_t TMVA::MethodBDT::fNNodesMax. private . max # of nodes ; Definition at line 241 of file MethodBDT.h. ◆ fNodePurityLimit. Double_t TMVA::MethodBDT::fNodePurityLimit. private . purity limit for sig/bkg nodes ; Definition at line 240 of file MethodBDT.h. ◆ fNoNegWeightsInTraining. Bool_t TMVA::MethodBDT::fNoNegWeightsInTraining. private . ignore negative event weights in the training ; Definition at line 256 of file MethodBDT.h. ◆ fNTrees. Int_t TMVA::MethodBDT::fNTrees. private . number of decision trees requested ; Definition at line 211 of file MethodBDT.h. ◆ fPairNegWeightsGlobal. Bool_t TMV,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:66090,monitor,monitoring,66090,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['monitor'],['monitoring']
Energy Efficiency," TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSym_double_.html:18073,efficient,efficient,18073,root/html528/TMatrixTSym_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSym_double_.html,6,['efficient'],['efficient']
Energy Efficiency," TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool CheckMinuitInstance() const; check instance of fMinuit. bool CheckVarIndex(unsigned int ivar) const; check index of Variable (assume fMinuit exists). bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set a lower limited variable; since is not supported in TMinuit , just use a artificial large value. bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set a upper limited variable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMinuitMinimizer.html:7831,Adapt,Adapt,7831,root/html534/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html534/TMinuitMinimizer.html,1,['Adapt'],['Adapt']
Energy Efficiency," TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMinuitMinimizer.html:7443,Adapt,Adapt,7443,root/html532/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html,1,['Adapt'],['Adapt']
Energy Efficiency," TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set a lower limited variable; since is not supported in TMinuit , just use a artificial large value. bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set a upper limited variable; since is not supported in TMinuit , just use a artificial large negative value. bool CheckMinuitInstance() const; check instance of fMinuit. bool CheckVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMinuitMinimizer.html:7894,Adapt,Adapt,7894,root/html602/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html602/TMinuitMinimizer.html,2,['Adapt'],['Adapt']
Energy Efficiency," TObject and if the start of the TObject parts is at the very beginning of the objects. ;  ; Bool_t IsSyntheticPair () const;  ; Bool_t IsTObject () const;  Return kTRUE is the class inherits from TObject. ;  ; Bool_t IsVersioned () const;  ; void ls (Option_t *opt="""") const override;  The ls function lists the contents of a class on stdout. ;  ; void MakeCustomMenuList ();  Makes a customizable version of the popup menu list, i.e. ;  ; Bool_t MatchLegacyCheckSum (UInt_t checksum) const;  Return true if the checksum passed as argument is one of the checksum value produced by the older checksum calculation algorithm. ;  ; void Move (void *arenaFrom, void *arenaTo) const;  Register the fact that an object was moved from the memory location 'arenaFrom' to the memory location 'arenaTo'. ;  ; void * New (ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) const;  Return a pointer to a newly allocated object of this class. ;  ; void * New (void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; void * NewArray (Long_t nElements, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated array of objects of this class. ;  ; void * NewArray (Long_t nElements, void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; ObjectPtr NewObject (ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) const;  ; ObjectPtr NewObject (void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; ObjectPtr NewObjectArray (Long_t nElements, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated array of objects of this class. ;  ; ObjectPtr NewObjectArray (Long_t nElements, void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; virtual void PostLoadCheck ();  Do the initialization that can ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:20159,allocate,allocated,20159,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,3,['allocate'],['allocated']
Energy Efficiency," TParticlePDG(); TParticlePDG(int pdg_code); TParticlePDG(const char* Name, const char* Title, Double_t Mass, Bool_t Stable, Double_t Width, Double_t Charge, const char* ParticleClass, Int_t PdgCode, Int_t Anti, Int_t TrackingCode); virtual~TParticlePDG(); voidTObject::AbstractMethod(const char* method) const; Int_tAddDecayChannel(Int_t Type, Double_t BranchingRatio, Int_t NDaughters, Int_t* DaughterPdgCode); TParticlePDG*AntiParticle(); const TParticlePDG*AntiParticle() const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tBeauty() const; virtual voidTObject::Browse(TBrowser* b); Double_tCharge() const; Int_tCharm() const; static TClass*Class(); virtual const char*TObject::C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TParticlePDG.html:1454,Charge,Charge,1454,root/html534/TParticlePDG.html,https://root.cern,https://root.cern/root/html534/TParticlePDG.html,1,['Charge'],['Charge']
Energy Efficiency," TParticlePDG(); TParticlePDG(int pdg_code); TParticlePDG(const char* Name, const char* Title, Double_t Mass, Bool_t Stable, Double_t Width, Double_t Charge, const char* ParticleClass, Int_t PdgCode, Int_t Anti, Int_t TrackingCode); virtual~TParticlePDG(); voidTObject::AbstractMethod(const char* method) const; Int_tAddDecayChannel(Int_t Type, Double_t BranchingRatio, Int_t NDaughters, Int_t* DaughterPdgCode); TParticlePDG*AntiParticle(); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tBeauty() const; virtual voidTObject::Browse(TBrowser* b); Double_tCharge() const; Int_tCharm() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Cle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TParticlePDG.html:1454,Charge,Charge,1454,root/html532/TParticlePDG.html,https://root.cern,https://root.cern/root/html532/TParticlePDG.html,1,['Charge'],['Charge']
Energy Efficiency," TQpVar* step); Implements a version of Mehrotra starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & operator=(const TQpSolverBase& source); Assignment operator. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resids); alternative starting point heuristic: sets the; ""complementary"" variables to a large positive value; (based on the norm of the problem data) and the; remaining variables to zero. void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); perform monitor operation at each interior-point iteration. TQpLinSolverBase * GetLinearSystem(); default method for checking status. May be replaced; by a user-defined method. { return fSys; }. void SetMuTol(Double_t m); { fMutol = m; }. Double_t GetMuTol(); { return fMutol; }. void SetArTol(Double_t ar); { fArtol = ar; }. Double_t GetArTol(); { return fArtol; }. Double_t DataNorm(); { return fDnorm; }. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id$ » Last generated: 2015-03-14 16:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQpSolverBase.html:9924,monitor,monitor,9924,root/html534/TQpSolverBase.html,https://root.cern,https://root.cern/root/html534/TQpSolverBase.html,2,['monitor'],['monitor']
Energy Efficiency," TQpVar* step); Implements a version of Mehrotra starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & operator=(const TQpSolverBase& source); Assignment operator. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resids); alternative starting point heuristic: sets the; ""complementary"" variables to a large positive value; (based on the norm of the problem data) and the; remaining variables to zero. void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); perform monitor operation at each interior-point iteration. TQpLinSolverBase * GetLinearSystem(); default method for checking status. May be replaced; by a user-defined method. { return fSys; }. void SetMuTol(Double_t m); { fMutol = m; }. Double_t GetMuTol(); { return fMutol; }. void SetArTol(Double_t ar); { fArtol = ar; }. Double_t GetArTol(); { return fArtol; }. Double_t DataNorm(); { return fDnorm; }. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id$ » Last generated: 2015-06-02 16:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TQpSolverBase.html:10593,monitor,monitor,10593,root/html604/TQpSolverBase.html,https://root.cern,https://root.cern/root/html604/TQpSolverBase.html,2,['monitor'],['monitor']
Energy Efficiency," TQpVar* step); Implements a version of Mehrotra starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & operator=(const TQpSolverBase& source); Assignment operator. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resids); alternative starting point heuristic: sets the; ""complementary"" variables to a large positive value; (based on the norm of the problem data) and the; remaining variables to zero. void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); perform monitor operation at each interior-point iteration. TQpLinSolverBase * GetLinearSystem(); default method for checking status. May be replaced; by a user-defined method. { return fSys; }. void SetMuTol(Double_t m); { fMutol = m; }. Double_t GetMuTol(); { return fMutol; }. void SetArTol(Double_t ar); { fArtol = ar; }. Double_t GetArTol(); { return fArtol; }. Double_t DataNorm(); { return fDnorm; }. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQpSolverBase.html:10593,monitor,monitor,10593,root/html602/TQpSolverBase.html,https://root.cern,https://root.cern/root/html602/TQpSolverBase.html,2,['monitor'],['monitor']
Energy Efficiency," TSeqCollection::Merge, we no longer delete the object in the case where the original collection is marked as a owner.; Global resources.; Several tweaks to if and when, resources held by the global ROOT object (TROOT, TApplication) are deleted. When the default TApplication is replaced by a user provide TApplication, do not call EndOfProcessCleanups and co. and thus do not delete TFiles, TSockets or TColors that have already been created. In EndOfProcessCleanups, we now delete the objects held in TROOT’s TDirectory part. If the libCling library is unloaded, this now induces an immediate tear down of the ROOT resources; consequently objects might be deleted sooner in the process tear down process on some platforms.; TObject instances allocated as part of an array and made part of a collection, as for example the TCanvas instances into the global list of instances, are not longer deleted if the content of the collection is deleted. Technically the element of the array are now treated by collections as if they have been allocated on the stack. This fixes the issue described at ROOT-7846.; Code Cleanups.; Several definition where moved from the global or ROOT namespace to the ROOT::Internal namespace as they are not intended to be used outside of ROOT, including: gROOTLocal and related functions, TSchemaHelper, TSchemaMatch, TSchemaType, RStl, ROOT::TROOTAllocator, TSchemaRuleProcessor, TStdBitsetHelper, TInitBehavior, TDefaultInitBehavior, DefineBehavior, THnBaseBrowsable, THnBaseBinIter, GenericShowMembers, TOperatorNewHelper and BranchProxy implementations classes.; Several definition where moved from the global or ROOT namespace to the ROOT::Details namespace as they are intended to be used in ‘expert’ level code and have a lower level of backward compatibility requirement. This includes TCollectionProxyInfo, TSchemaRuleSet.; Interpreter; ROOT can now dump the context of STL collections, for instance map<string,int>. A few ROOT types print their content, too.; Fixed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:6037,allocate,allocated,6037,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['allocate'],['allocated']
Energy Efficiency," TSpectrum3 *s = new TSpectrum3();; for (i = 0; i < nbinsx; i++){; for (j = 0; j < nbinsy; j++){; for (k = 0; k < nbinsz; k++){; source[i][j][k] = decon_in->GetBinContent(i + 1,j + 1,k + 1);; resp[i][j][k] = decon_resp->GetBinContent(i + 1,j + 1,k + 1);; }; }; }; s->Deconvolution(source,resp,nbinsx,nbinsy,nbinsz,100,1,1);; for (i = 0; i < nbinsx; i++){; for (j = 0; j < nbinsy; j++){; for (k = 0; k < nbinsz; k++){; decon_in->SetBinContent(i + 1,j + 1,k + 1, source[i][j][k]);; }; }; }; decon_in->Draw("""");; }; TSpectrum3::Deconvolutionconst char * Deconvolution(Double_t ***source, const Double_t ***resp, Int_t ssizex, Int_t ssizey, Int_t ssizez, Int_t numberIterations, Int_t numberRepetitions, Double_t boost)This function calculates deconvolution from source spectrum according to response spectrum The result...Definition TSpectrum3.cxx:1599. Example 2 - script Decon_hr.c :; This example illustrates repeated Gold deconvolution with boosting. After every 10 iterations we apply power function with exponent = 2 to the spectrum given in Fig. 2. Fig. 4 Spectrum from Fig. 2 after boosted deconvolution (10 iterations repeated 10 times). It decomposes completely cluster of peaks from Fig 2.; Script:; Example to illustrate the Gold deconvolution (class TSpectrum3). To execute this example, do:; root > .x Decon3_hr.C; void Decon3_hr() {; Int_t i, j, k;; Int_t nbinsx = 32;; Int_t nbinsy = 32;; Int_t nbinsz = 32;; Int_t xmin = 0;; Int_t xmax = nbinsx;; Int_t ymin = 0;; Int_t ymax = nbinsy;; Int_t zmin = 0;; Int_t zmax = nbinsz;; Double_t*** source = new Double_t**[nbinsx];; Double_t*** resp = new Double_t**[nbinsx];; for(i=0;i<nbinsx;i++){; source[i]=new Double_t*[nbinsy];; for(j=0;j<nbinsy;j++); source[i][j]=new Double_t[nbinsz];; }; for(i=0;i<nbinsx;i++){; resp[i]=new Double_t*[nbinsy];; for(j=0;j<nbinsy;j++); resp[i][j]=new Double_t[nbinsz];; }; TH3F *decon_in = new TH3F(""decon_in"",""Deconvolution"",nbinsx,xmin,xmax,nbinsy,ymin,ymax,nbinsz,zmin,zmax);; TH3F *decon_resp = new TH3F(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum3.html:29127,power,power,29127,doc/master/classTSpectrum3.html,https://root.cern,https://root.cern/doc/master/classTSpectrum3.html,1,['power'],['power']
Energy Efficiency," TStorage::HasCustomNewDelete ; (; ). static . return the has custom delete flag ; Definition at line 434 of file TStorage.cxx. ◆ IsA(). virtual TClass * TStorage::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 85 of file TStorage.h. ◆ ObjectAlloc() [1/2]. void * TStorage::ObjectAlloc ; (; size_t ; sz). static . Used to allocate a TObject on the heap (via TObject::operator new()). ; Directly after this routine one can call (in the TObject ctor) TStorage::FilledByObjectAlloc() to find out if the just created object is on the heap. This technique is necessary as there is one stack per thread and we can not rely on comparison with the current stack memory position. ; Definition at line 291 of file TStorage.cxx. ◆ ObjectAlloc() [2/2]. void * TStorage::ObjectAlloc ; (; size_t ; size, . void * ; vp . ). static . Used to allocate a TObject on the heap (via TObject::operator new(size_t,void*)) in position vp. ; vp is already allocated (maybe on heap, maybe on stack) so just return. ; Definition at line 314 of file TStorage.cxx. ◆ ObjectAllocArray(). void * TStorage::ObjectAllocArray ; (; size_t ; sz). static . Used to allocate array of TObject on the heap (via TObject::operator new[]()). ; Unlike the 'singular' ObjectAlloc, we do not mark those object has being allocated on the heap as they can not be individually deleted. ; Definition at line 303 of file TStorage.cxx. ◆ ObjectDealloc() [1/2]. void TStorage::ObjectDealloc ; (; void * ; vp). static . Used to deallocate a TObject on the heap (via TObject::operator delete()). ; Definition at line 322 of file TStorage.cxx. ◆ ObjectDealloc() [2/2]. void TStorage::ObjectDealloc ; (; void * ; vp, . void * ; ptr . ). static . Used to deallocate a TObject on the heap (via TObject::operator delete(void*,void*)). ; Definition at line 331 of file TStorage.cxx. ◆ PrintStatistics(). void TStorage::PrintStatistics ; (; ). static . Print memory usage statistics. ; Definition at line 368 of f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStorage.html:7728,allocate,allocated,7728,doc/master/classTStorage.html,https://root.cern,https://root.cern/doc/master/classTStorage.html,1,['allocate'],['allocated']
Energy Efficiency," TTree::MakeClass() that generates skeleton code for RooAbsPdf and RooAbsReal functions given a list of input parameter names ;  CClassFacIFace;  CRooCmdArgRooCmdArg is a named container for two doubles, two integers two object points and three string pointers that can be passed as generic named arguments to a variety of RooFit end user methods ;  CRooCmdConfigClass RooCmdConfig is a configurable parser for RooCmdArg named arguments ;  CRooCompositeDataStoreRooCompositeDataStore is the abstract base class for data collection that use a TTree as internal storage mechanism ;  CRooConstraintSumRooConstraintSum calculates the sum of the -(log) likelihoods of a set of RooAbsPfs that represent constraint functions ;  CRooConstVarRooConstVar represent a constant real-valued object ;  CRooConvCoefVarRooConvCoefVar is an auxilary class that represents the coefficient of a RooAbsAnaConvPdf implementation as a separate RooAbsReal object to be able to interface these coefficient terms with the generic RooRealIntegral integration mechanism ;  CRooConvGenContextRooConvGenContext is an efficient implementation of the generator context specific for RooAbsAnaConvPdf objects ;  CRooConvIntegrandBindingImplementation of RooAbsFunc that represent the the integrand of a generic (numeric) convolution A (x) B so that it can be passed to a numeric integrator ;  CRooCurveA RooCurve is a one-dimensional graphical representation of a real-valued function ;  ►CRooCustomizer;  CCustIFace;  CRooDataHistRooDataSet is a container class to hold N-dimensional binned data ;  CRooDataHistSliceIterRooDataHistSliceIter iterates over all bins in a RooDataHist that occur in a slice defined by the bin coordinates of the input sliceSet ;  CRooDataProjBindingAdaptor that projects a real function via summation of states provided in a dataset ;  CRooDataSetRooDataSet is a container class to hold unbinned data ;  CRooDataWeightedAverageClass RooDataWeightedAverage calculate a weighted average of a function or p.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:95526,efficient,efficient,95526,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,4,['efficient'],['efficient']
Energy Efficiency," Tan(const TComplex& c); {TComplex cc=Cos(c); return Sin(c)*Conjugate(cc)/cc.Rho2();}. TComplex ASin(const TComplex& c); {return -I()*Log(I()*c+TMath::Sign(1.,c.Im())*Sqrt(1.-c*c));}. TComplex ACos(const TComplex& c); {return -I()*Log(c+TMath::Sign(1.,c.Im())*Sqrt(c*c-1.));}. TComplex ATan(const TComplex& c); {return -0.5*I()*Log((1.+I()*c)/(1.-I()*c));}. TComplex SinH(const TComplex& c). CosH(const TComplex& c). TComplex TanH(const TComplex& c); {TComplex cc=CosH(c); return SinH(c)*Conjugate(cc)/cc.Rho2();}. TComplex ASinH(const TComplex& c); {return Log(c+TMath::Sign(1.,c.Im())*Sqrt(c*c+1.));}. TComplex ACosH(const TComplex& c); {return Log(c+TMath::Sign(1.,c.Im())*Sqrt(c*c-1.));}. TComplex ATanH(const TComplex& c); {return 0.5*Log((1.+c)/(1.-c));}. Double_t Abs(const TComplex& c); {return c.Rho();}. TComplex Power(const TComplex& x, const TComplex& y). TComplex Power(const TComplex& x, Double_t y); {return TComplex(TMath::Power(x.Rho(),y),x.Theta()*y,kTRUE);}. TComplex Power(Double_t x, const TComplex& y). TComplex Power(const TComplex& x, Int_t y); {return TComplex(TMath::Power(x.Rho(),y),x.Theta()*y,kTRUE);}. Int_t Finite(const TComplex& c); {return TMath::Min(TMath::Finite(c.Re()),TMath::Finite(c.Im()));}. Int_t IsNaN(const TComplex& c); {return TMath::Max(TMath::IsNaN(c.Re()),TMath::IsNaN(c.Im()));}. TComplex Min(const TComplex& a, const TComplex& b); {return a.Rho()<=b.Rho()?a:b;}. TComplex Max(const TComplex& a, const TComplex& b); {return a.Rho()>=b.Rho()?a:b;}. TComplex Normalize(const TComplex& c); {return TComplex(1.,c.Theta(),kTRUE);}. TComplex Conjugate(const TComplex& c); {return TComplex(c.Re(),-c.Im());}. TComplex Range(const TComplex& lb, const TComplex& ub, const TComplex& c); {return Max(lb,Min(c,ub));}. » Author: Federico Carminati 22/04/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-03-12 16:38; This page has been automatically generated. For comments or suggestions re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TComplex.html:5255,Power,Power,5255,root/html534/TComplex.html,https://root.cern,https://root.cern/root/html534/TComplex.html,1,['Power'],['Power']
Energy Efficiency," Tan(const TComplex& c); {TComplex cc=Cos(c); return Sin(c)*Conjugate(cc)/cc.Rho2();}. TComplex ASin(const TComplex& c); {return -I()*Log(I()*c+TMath::Sign(1.,c.Im())*Sqrt(1.-c*c));}. TComplex ACos(const TComplex& c); {return -I()*Log(c+TMath::Sign(1.,c.Im())*Sqrt(c*c-1.));}. TComplex ATan(const TComplex& c); {return -0.5*I()*Log((1.+I()*c)/(1.-I()*c));}. TComplex SinH(const TComplex& c). CosH(const TComplex& c). TComplex TanH(const TComplex& c); {TComplex cc=CosH(c); return SinH(c)*Conjugate(cc)/cc.Rho2();}. TComplex ASinH(const TComplex& c); {return Log(c+TMath::Sign(1.,c.Im())*Sqrt(c*c+1.));}. TComplex ACosH(const TComplex& c); {return Log(c+TMath::Sign(1.,c.Im())*Sqrt(c*c-1.));}. TComplex ATanH(const TComplex& c); {return 0.5*Log((1.+c)/(1.-c));}. Double_t Abs(const TComplex& c); {return c.Rho();}. TComplex Power(const TComplex& x, const TComplex& y). TComplex Power(const TComplex& x, Double_t y); {return TComplex(TMath::Power(x.Rho(),y),x.Theta()*y,kTRUE);}. TComplex Power(Double_t x, const TComplex& y). TComplex Power(const TComplex& x, Int_t y); {return TComplex(TMath::Power(x.Rho(),y),x.Theta()*y,kTRUE);}. Int_t Finite(const TComplex& c); {return TMath::Min(TMath::Finite(c.Re()),TMath::Finite(c.Im()));}. Int_t IsNaN(const TComplex& c); {return TMath::Max(TMath::IsNaN(c.Re()),TMath::IsNaN(c.Im()));}. TComplex Min(const TComplex& a, const TComplex& b); {return a.Rho()<=b.Rho()?a:b;}. TComplex Max(const TComplex& a, const TComplex& b); {return a.Rho()>=b.Rho()?a:b;}. TComplex Normalize(const TComplex& c); {return TComplex(1.,c.Theta(),kTRUE);}. TComplex Conjugate(const TComplex& c); {return TComplex(c.Re(),-c.Im());}. TComplex Range(const TComplex& lb, const TComplex& ub, const TComplex& c); {return Max(lb,Min(c,ub));}. » Author: Federico Carminati 22/04/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-02 15:40; This page has been automatically generated. For comments or suggestions re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TComplex.html:5084,Power,Power,5084,root/html604/TComplex.html,https://root.cern,https://root.cern/root/html604/TComplex.html,1,['Power'],['Power']
Energy Efficiency," Tan(const TComplex& c); {TComplex cc=Cos(c); return Sin(c)*Conjugate(cc)/cc.Rho2();}. TComplex ASin(const TComplex& c); {return -I()*Log(I()*c+TMath::Sign(1.,c.Im())*Sqrt(1.-c*c));}. TComplex ACos(const TComplex& c); {return -I()*Log(c+TMath::Sign(1.,c.Im())*Sqrt(c*c-1.));}. TComplex ATan(const TComplex& c); {return -0.5*I()*Log((1.+I()*c)/(1.-I()*c));}. TComplex SinH(const TComplex& c). CosH(const TComplex& c). TComplex TanH(const TComplex& c); {TComplex cc=CosH(c); return SinH(c)*Conjugate(cc)/cc.Rho2();}. TComplex ASinH(const TComplex& c); {return Log(c+TMath::Sign(1.,c.Im())*Sqrt(c*c+1.));}. TComplex ACosH(const TComplex& c); {return Log(c+TMath::Sign(1.,c.Im())*Sqrt(c*c-1.));}. TComplex ATanH(const TComplex& c); {return 0.5*Log((1.+c)/(1.-c));}. Double_t Abs(const TComplex& c); {return c.Rho();}. TComplex Power(const TComplex& x, const TComplex& y). TComplex Power(const TComplex& x, Double_t y); {return TComplex(TMath::Power(x.Rho(),y),x.Theta()*y,kTRUE);}. TComplex Power(Double_t x, const TComplex& y). TComplex Power(const TComplex& x, Int_t y); {return TComplex(TMath::Power(x.Rho(),y),x.Theta()*y,kTRUE);}. Int_t Finite(const TComplex& c); {return TMath::Min(TMath::Finite(c.Re()),TMath::Finite(c.Im()));}. Int_t IsNaN(const TComplex& c); {return TMath::Max(TMath::IsNaN(c.Re()),TMath::IsNaN(c.Im()));}. TComplex Min(const TComplex& a, const TComplex& b); {return a.Rho()<=b.Rho()?a:b;}. TComplex Max(const TComplex& a, const TComplex& b); {return a.Rho()>=b.Rho()?a:b;}. TComplex Normalize(const TComplex& c); {return TComplex(1.,c.Theta(),kTRUE);}. TComplex Conjugate(const TComplex& c); {return TComplex(c.Re(),-c.Im());}. TComplex Range(const TComplex& lb, const TComplex& ub, const TComplex& c); {return Max(lb,Min(c,ub));}. » Author: Federico Carminati 22/04/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TComplex.html:5084,Power,Power,5084,root/html602/TComplex.html,https://root.cern,https://root.cern/root/html602/TComplex.html,1,['Power'],['Power']
Energy Efficiency," Tan(const TComplex& c); {TComplex cc=Cos(c); return Sin(c)*Conjugate(cc)/cc.Rho2();}. TComplex ASin(const TComplex& c); {return -I()*Log(I()*c+TMath::Sign(1.,c.Im())*Sqrt(1.-c*c));}. TComplex ACos(const TComplex& c); {return -I()*Log(c+TMath::Sign(1.,c.Im())*Sqrt(c*c-1.));}. TComplex ATan(const TComplex& c); {return -0.5*I()*Log((1.+I()*c)/(1.-I()*c));}. TComplex SinH(const TComplex& c). CosH(const TComplex& c). TComplex TanH(const TComplex& c); {TComplex cc=CosH(c); return SinH(c)*Conjugate(cc)/cc.Rho2();}. TComplex ASinH(const TComplex& c); {return Log(c+TMath::Sign(1.,c.Im())*Sqrt(c*c+1.));}. TComplex ACosH(const TComplex& c); {return Log(c+TMath::Sign(1.,c.Im())*Sqrt(c*c-1.));}. TComplex ATanH(const TComplex& c); {return 0.5*Log((1.+c)/(1.-c));}. Double_t Abs(const TComplex& c); {return c.Rho();}. TComplex Power(const TComplex& x, const TComplex& y). TComplex Power(const TComplex& x, Double_t y); {return TComplex(TMath::Power(x.Rho(),y),x.Theta()*y,kTRUE);}. TComplex Power(Double_t x, const TComplex& y). TComplex Power(const TComplex& x, Int_t y); {return TComplex(TMath::Power(x.Rho(),y),x.Theta()*y,kTRUE);}. Int_t Finite(const TComplex& c); {return TMath::Min(TMath::Finite(c.Re()),TMath::Finite(c.Im()));}. Int_t IsNaN(const TComplex& c); {return TMath::Max(TMath::IsNaN(c.Re()),TMath::IsNaN(c.Im()));}. TComplex Min(const TComplex& a, const TComplex& b); {return a.Rho()<=b.Rho()?a:b;}. TComplex Max(const TComplex& a, const TComplex& b); {return a.Rho()>=b.Rho()?a:b;}. TComplex Normalize(const TComplex& c); {return TComplex(1.,c.Theta(),kTRUE);}. TComplex Conjugate(const TComplex& c); {return TComplex(c.Re(),-c.Im());}. TComplex Range(const TComplex& lb, const TComplex& ub, const TComplex& c); {return Max(lb,Min(c,ub));}. » Author: Federico Carminati 22/04/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/mathcore:$Id: TComplex.h 22866 2008-03-27 15:32:50Z rdm $ » Last generated: 2011-11-03 20:10; This page has been automatical",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TComplex.html:5236,Power,Power,5236,root/html532/TComplex.html,https://root.cern,https://root.cern/root/html532/TComplex.html,1,['Power'],['Power']
Energy Efficiency," The mean value is then automatically calculated by using the sum of values contained in the buffer divided by their count. To disable automatic mean calculation, simply call SetBufferSize with a zero argument ; Definition at line 322 of file TGSpeedo.cxx. ◆ SetDisplayText(). void TGSpeedo::SetDisplayText ; (; const char * ; text1, . const char * ; text2 = """" . ). Set small display text (two lines). ; Definition at line 347 of file TGSpeedo.cxx. ◆ SetLabelText(). void TGSpeedo::SetLabelText ; (; const char * ; text1, . const char * ; text2 = """" . ). Set main label text (two lines). ; Definition at line 361 of file TGSpeedo.cxx. ◆ SetMeanValue(). void TGSpeedo::SetMeanValue ; (; Float_t ; mean). inline . Definition at line 96 of file TGSpeedo.h. ◆ SetMinMaxScale(). void TGSpeedo::SetMinMaxScale ; (; Float_t ; min, . Float_t ; max . ). Set min and max scale values. ; Definition at line 377 of file TGSpeedo.cxx. ◆ SetOdoValue(). void TGSpeedo::SetOdoValue ; (; Int_t ; val). Set actual value of odo meter. ; Definition at line 334 of file TGSpeedo.cxx. ◆ SetScaleValue() [1/2]. void TGSpeedo::SetScaleValue ; (; Float_t ; val). Set actual scale (needle position) value. ; Definition at line 393 of file TGSpeedo.cxx. ◆ SetScaleValue() [2/2]. void TGSpeedo::SetScaleValue ; (; Float_t ; val, . Int_t ; damping . ). Set actual scale (needle position) value. ; Definition at line 441 of file TGSpeedo.cxx. ◆ SetThresholdColors(). void TGSpeedo::SetThresholdColors ; (; EGlowColor ; col1, . EGlowColor ; col2, . EGlowColor ; col3 . ). inline . Definition at line 87 of file TGSpeedo.h. ◆ SetThresholds(). void TGSpeedo::SetThresholds ; (; Float_t ; th1 = 0.0, . Float_t ; th2 = 0.0, . Float_t ; th3 = 0.0 . ). inline . Definition at line 85 of file TGSpeedo.h. ◆ StepScale(). void TGSpeedo::StepScale ; (; Float_t ; step). Increment/decrement scale (needle position) of ""step"" value. ; Definition at line 484 of file TGSpeedo.cxx. ◆ Streamer(). void TGSpeedo::Streamer ; (; TBuffer & ; R__b). o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGSpeedo.html:37957,meter,meter,37957,doc/master/classTGSpeedo.html,https://root.cern,https://root.cern/doc/master/classTGSpeedo.html,1,['meter'],['meter']
Energy Efficiency," The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  box.cxxThis ROOT 7 example demonstrates how to create a ROOT 7 canvas (RCanvas) and draw ROOT 7 boxes in it (RBox) ;  concurrentfill.cxx;  draw.cxx;  draw_mt.cxxThis macro demonstrate usage of ROOT7 graphics from many threads Three different canvases in three different threads are started and regularly updated ;  draw_rh1.cxxThis macro generates a small V7 TH1D, fills it and draw it in a V7 canvas ;  draw_subpads.cxx;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  line.cxxThis ROOT 7 example demonstrates how to create a ROOT 7 canvas (RCanvas) and draw ROOT 7 lines in it (RLine) ;  lineStyle.cxx;  lineWidth.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  vo004_SortAndSelect.C In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo004_SortAndSelect.py In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo005_Combinations.C In this tutorial we learn how combinations of RVecs can be build ;  vo005_Combinations.py In this tutorial we learn how combinations of RVecs can be build ;  vo006_IndexManipulation.C In this tutorial we demonstrate RVec helpers for index manipulation ;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:172150,allocate,allocate,172150,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['allocate'],['allocate']
Energy Efficiency," Therefore, the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when. Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class. Limiting the Number of Terms. As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5]. There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if. where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out). Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3). The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:3993,power,power,3993,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,4,['power'],['power']
Energy Efficiency," This class can convolve any PDF; with any other PDF; ; This class should not be used blindly as numeric convolution is computing; intensive and prone to stability fitting problems. If an analytic convolution; can be calculated, you should use that or implement it if not available.; RooNumConvolution implements reasonable defaults that should convolve most; functions reasonably well, but results strongly depend on the shape of your; input PDFS so always check your result.; The default integration engine for the numeric convolution is the; adaptive Gauss-Kronrod method, which empirically seems the most robust; for this task. You can override the convolution integration settings via; the RooNumIntConfig object reference returned by the convIntConfig() member; function; ; By default the numeric convolution is integrated from -infinity to; +infinity through a x -> 1/x coordinate transformation of the; tails. For convolution with a very small bandwidth it may be; advantageous (for both CPU consumption and stability) if the; integration domain is limited to a finite range. The function; setConvolutionWindow(mean,width,scale) allows to set a sliding; window around the x value to be calculated taking a RooAbsReal; expression for an offset and a width to be taken around the x; value. These input expression can be RooFormulaVars or other; function objects although the 3d 'scale' argument 'scale'; multiplies the width RooAbsReal expression given in the 2nd; argument, allowing for an appropriate window definition for most; cases without need for a RooFormulaVar object: e.g. a Gaussian; resolution PDF do setConvolutionWindow(gaussMean,gaussSigma,5); Note that for a 'wide' Gaussian the -inf to +inf integration; may converge more quickly than that over a finite range!; ; The default numeric precision is 1e-7, i.e. the global default for; numeric integration but you should experiment with this value to; see if it is sufficient for example by studying the number of function; calls t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvolution.html:1370,consumption,consumption,1370,root/html526/RooNumConvolution.html,https://root.cern,https://root.cern/root/html526/RooNumConvolution.html,11,['consumption'],['consumption']
Energy Efficiency," This macro provides a simple example on how to use the trained regression MVAs within an analysis module ;  ► tree;  basic.C Read data from an ascii file and create a root file with an histogram and an ntuple ;  basic2.C Create can ntuple reading data from an ascii file ;  bill.C Benchmark comparing row-wise and column-wise storage performance ;  cernbuild.C Read data (CERN staff) from an ascii file and create a root file with a Tree ;  cernstaff.C Playing with a Tree containing variables of type character ;  circular.C Example of a circular Tree ;  clonesA_Event.CExample to write & read a Tree built with a complex class inheritance tree ;  clonesA_Event.cxx;  clonesA_Event.h;  copytree.C Copy a subset of a Tree to a new Tree ;  copytree2.C Copy a subset of a Tree to a new Tree, one branch in a separate file ;  copytree3.C Example of Root macro to copy a subset of a Tree to a new Tree, selecting entries ;  drawsparse.C Convert a THnSparse to a TTree using efficient iteration through the THnSparse and draw a THnSparse using TParallelCoord ;  h1analysis.C Example of analysis class for the H1 data ;  h1analysis.h;  h1analysisProxy.CExample of analysis class for the H1 data using code generated by MakeProxy ;  h1analysisProxy.h;  h1analysisProxyCut.C;  h1analysisTreeReader.C H1 analysis example expressed in terms of TTreeReader ;  h1analysisTreeReader.h;  h1chain.C Creates a TChain to be used by the h1analysis.C class the symbol H1 must point to a directory where the H1 data sets have been installed ;  hsimpleProxy.C ;  hsimpleProxyDriver.C This is the driver of the hsimpleProxy example It provides the infrastructure to run that code on an ntuple To be run from the tutorials directory ;  hsimpleReader.C TTreeReader simplest example ;  htest.C Save histograms in Tree branches ;  hvector.C Write and read STL vectors in a tree ;  JetEvent.cxx;  JetEvent.h;  jets.CUsage of a Tree using the JetEvent class ;  ntuple1.C Simple tree analysis ;  parallelcoord.C Script illustrati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:167718,efficient,efficient,167718,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['efficient'],['efficient']
Energy Efficiency," This macro provides a simple example on how to use the trained regression MVAs within an analysis module ;  ► tree;  basic.C Read data from an ascii file and create a root file with an histogram and an ntuple ;  basic2.C Create can ntuple reading data from an ascii file ;  bill.C Benchmark comparing row-wise and column-wise storage performance ;  cernbuild.C Read data (CERN staff) from an ascii file and create a root file with a Tree ;  cernstaff.C Playing with a Tree containing variables of type character ;  circular.C Example of a circular Tree ;  clonesA_Event.CExample to write & read a Tree built with a complex class inheritance tree ;  clonesA_Event.cxx;  clonesA_Event.h;  copytree.C Copy a subset of a Tree to a new Tree ;  copytree2.C Copy a subset of a Tree to a new Tree, one branch in a separate file ;  copytree3.C Example of Root macro to copy a subset of a Tree to a new Tree, selecting entries ;  drawsparse.C Convert a THnSparse to a TTree using efficient iteration through the THnSparse and draw a THnSparse using TParallelCoord ;  h1analysis.C Example of analysis class for the H1 data ;  h1analysis.h;  h1analysisProxy.CExample of analysis class for the H1 data using code generated by MakeProxy ;  h1analysisProxy.h;  h1analysisProxyCut.C;  h1analysisTreeReader.C;  h1analysisTreeReader.h;  h1chain.C Creates a TChain to be used by the h1analysis.C class the symbol H1 must point to a directory where the H1 data sets have been installed ;  hsimpleProxy.C ;  hsimpleProxyDriver.C This is the driver of the hsimpleProxy example It provides the infrastructure to run that code on an ntuple To be run from the tutorials directory ;  hsimpleReader.C TTreeReader simplest example ;  htest.C Save histograms in Tree branches ;  hvector.C Write and read STL vectors in a tree ;  JetEvent.cxx;  JetEvent.h;  jets.CUsage of a Tree using the JetEvent class ;  ntuple1.C Simple tree analysis ;  parallelcoord.C Script illustrating the use of the TParalleCoord class ;  parallelcoordt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:155515,efficient,efficient,155515,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,4,['efficient'],['efficient']
Energy Efficiency," This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameterization. Options:; None so far. For detailed description of what this entails, please refer to the; class description. void Fit(Option_t* option = """"); Try to fit the found parameterisation to the test sample. Options; M use Minuit to improve coefficients. Also, refer to; class description. TMultiDimFit* Instance(); Return the static instance. void MakeCandidates(); PRIVATE METHOD:; Create list of candidate functions for the parameterisation. See; also; class description. Double_t MakeChi2(const Double_t* coeff = 0); Calculate Chi square over either the test sample. The optional; argument coeff is a vector of coefficients to use in the; evaluation of the parameterisation. If coeff == 0, then the found; coefficients is used.; Used my MINUIT for fit (see TMultDimFit::Fit). void MakeCode(const char* functionName = ""MDF"", Option_t* option = """"); Generate the file <",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:27296,power,power,27296,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,10,['power'],['power']
Energy Efficiency," Throw(); 518 // mechanism or at least load a NAN if not.; 519 const Scalar ee = E();; 520 const Scalar pp = P();; 521 using std::log;; 522 return Scalar(0.5) * log((ee + pp) / (ee - pp));; 523 }; 524 ; 525 /**; 526 Determine if momentum-energy can represent a physical massive particle; 527 */; 528 bool isTimelike( ) const {; 529 Scalar ee = E(); Scalar pp = P(); return ee*ee > pp*pp;; 530 }; 531 ; 532 /**; 533 Determine if momentum-energy can represent a massless particle; 534 */; 535 bool isLightlike( Scalar tolerance; 536 = 100*std::numeric_limits<Scalar>::epsilon() ) const {; 537 Scalar ee = E(); Scalar pp = P(); Scalar delta = ee-pp;; 538 if ( ee==0 ) return pp==0;; 539 return delta*delta < tolerance * ee*ee;; 540 }; 541 ; 542 /**; 543 Determine if momentum-energy is spacelike, and represents a tachyon; 544 */; 545 bool isSpacelike( ) const {; 546 Scalar ee = E(); Scalar pp = P(); return ee*ee < pp*pp;; 547 }; 548 ; 549 typedef DisplacementVector3D< Cartesian3D<Scalar> > BetaVector;; 550 ; 551 /**; 552 The beta vector for the boost that would bring this vector into; 553 its center of mass frame (zero momentum); 554 */; 555 BetaVector BoostToCM( ) const {; 556 if (E() == 0) {; 557 if (P() == 0) {; 558 return BetaVector();; 559 } else {; 560 // TODO - should attempt to Throw with msg about; 561 // boostVector computed for LorentzVector with t=0; 562 return -Vect()/E();; 563 }; 564 }; 565 if (M2() <= 0) {; 566 // TODO - should attempt to Throw with msg about; 567 // boostVector computed for a non-timelike LorentzVector; 568 }; 569 return -Vect()/E();; 570 }; 571 ; 572 /**; 573 The beta vector for the boost that would bring this vector into; 574 its center of mass frame (zero momentum); 575 */; 576 template <class Other4Vector>; 577 BetaVector BoostToCM(const Other4Vector& v ) const {; 578 Scalar eSum = E() + v.E();; 579 DisplacementVector3D< Cartesian3D<Scalar> > vecSum = Vect() + v.Vect();; 580 if (eSum == 0) {; 581 if (vecSum.Mag2() == 0) {; 582 return BetaVecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:16950,energy,energy,16950,doc/master/GenVector_2LorentzVector_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html,3,['energy'],['energy']
Energy Efficiency," Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development Release Checklist. Steps to be followed to produce a new ROOT release are:; Prerequisites. Get the 'green' light from all main developers; Check that all the Jenkins builds / CDash builds are green; Verify that no performance regressions exist in the benchmark system; Update versions in JIRA. 'Release' the version in the project configuration; Create the next development version. root.git. Update the release notes in README/ReleaseNotes/vXXX/index.md. Edit release notes patches section; From the list the versions in JIRA, select the version and then 'release notes'; git commit README/ReleaseNotes/vXXX/index.md. Modify version number and modify all necessary files. edit build/version_number (even patch number for releases); Run from the build directory $ make version. Tag main ROOT repository. $ git tag -a vX-YY-ZZ; Run $ cmake . to update etc/gitinfo.txt. Create the source tarball. Run from the build directory $ make distsrc not on a MacOS machine; $ scp ../root_vX.YY.ZZ.source.tar.gz sftnight@root:/home/www/root/download. Update the release notes in README/ReleaseNotes/vXXX/index.md again. edit README/ReleaseNotes/vXXX/index.md; possibly copying from README/ReleaseNotes/em",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/release-checklist.html:1966,green,green,1966,d/release-checklist.html,https://root.cern,https://root.cern/d/release-checklist.html,2,['green'],['green']
Energy Efficiency," ULongptr_t ; pix, . UInt_t ; w, . UInt_t ; h . ). overridevirtual . register pixmap created by TGWin32GLManager ; Reimplemented from TVirtualX.; Definition at line 7436 of file TGWin32.cxx. ◆ AddWindow(). Int_t TGWin32::AddWindow ; (; ULongptr_t ; qwid, . UInt_t ; w, . UInt_t ; h . ). overridevirtual . Register a window created by Qt as a ROOT window (like InitWindow()). ; Reimplemented from TVirtualX.; Definition at line 7479 of file TGWin32.cxx. ◆ Align(). void TGWin32::Align ; (; void ; ). private . Compute alignment variables. ; The alignment is done on the horizontal string then the rotation is applied on the alignment variables. SetRotation and LayoutGlyphs should have been called before. ; Definition at line 1203 of file TGWin32.cxx. ◆ AllocColor() [1/2]. Bool_t TGWin32::AllocColor ; (; Colormap_t ; cmap, . ColorStruct_t & ; color . ). overridevirtual . Find and allocate a color cell according to the color values specified in the ColorStruct_t. ; If no cell could be allocated it returns kFALSE, otherwise kTRUE. ; Reimplemented from TVirtualX.; Definition at line 5756 of file TGWin32.cxx. ◆ AllocColor() [2/2]. Bool_t TGWin32::AllocColor ; (; GdkColormap * ; cmap, . GdkColor * ; color . ). protected . Allocate color in colormap. ; If we are on an <= 8 plane machine we will use XAllocColor. If we are on a >= 15 (15, 16 or 24) plane true color machine we will calculate the pixel value using: for 15 and 16 bit true colors have 6 bits precision per color however only the 5 most significant bits are used in the color index. Except for 16 bits where green uses all 6 bits. I.e.: 15 bits = rrrrrgggggbbbbb 16 bits = rrrrrggggggbbbbb for 24 bits each r, g and b are represented by 8 bits.; Since all colors are set with a max of 65535 (16 bits) per r, g, b we just right shift them by 10, 11 and 10 bits for 16 planes, and (10, 10, 10 for 15 planes) and by 8 bits for 24 planes. Returns kFALSE in case color allocation failed. ; Definition at line 1159 of file TGWin32.cxx. ◆ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:54009,allocate,allocated,54009,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['allocate'],['allocated']
Energy Efficiency," We test for the kObject and kAny types to support; 5413 // the (unwise) choice of inheriting from an STL container.; 5414 Error(""SetAddress"", ""Embedded STL container given a zero address for branch '%s'"", GetName());; 5415 } else {; 5416 // We are either a top-level branch or sub-branch which is a pointer to an STL container.; 5417 // Streamer type should be -1 (for a top-level branch) or kSTLp here.; 5418 if ((fStreamerType != -1) && (fStreamerType != TVirtualStreamerInfo::kSTLp)) {; 5419 Error(""SetAddress"",; 5420 ""Branch %s is a split STL container (fStreamerType is: %d), the address can not be set directly."",; 5421 GetName(), fStreamerType);; 5422 } else if (fStreamerType == -1) {; 5423 // -- We are a top-level branch, allocate.; 5424 SetBit(kDeleteObject);; 5425 fObject = (char*) proxy->New();; 5426 if (fObject) {; 5427 fAddress = (char*) &fObject;; 5428 } else {; 5429 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5430 // FIXME: Should we do this? Lots of other code wants; 5431 // fAddress to be zero if no fObject, but is; 5432 // that a good thing?; 5433 fAddress = nullptr;; 5434 ResetBit(kAddressSet);; 5435 }; 5436 } else {; 5437 // -- We are a sub-branch which is a pointer to an STL container.; 5438 Error(""SetAddress"", ""Embedded pointer to an STL container given a zero address for branch '%s'"", GetName());; 5439 }; 5440 }; 5441 }; 5442 } else if (fType == 41) {; 5443 // -- We are an STL container sub-branch.; 5444 // Initialize fCollProxy.; 5445 GetCollectionProxy();; 5446 // We are not at top-level branch.; 5447 fObject = fAddress;; 5448 } else if (fID < 0) {; 5449 // -- We are a top-level branch.; 5450 char** pp = (char**) fAddress;; 5451 if (pp && *pp) {; 5452 // -- Caller provided an i/o buffer for us to use.; 5453 fObject = *pp;; 5454 } else {; 5455 // -- Caller did not provide an i/o buffer for us to use, we must make one for ourselves.; 5456 if (clOfBranch) {; 5457 if (!pp) {; 5458 // -- Caller wants us to own the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:201831,allocate,allocate,201831,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency," X(), Y(), X() and M() ; Definition at line 78 of file PxPyPzM4D.h. ◆ PxPyPzM4D() [4/4]. template<class ScalarType = double> . ROOT::Math::PxPyPzM4D< ScalarType >::PxPyPzM4D ; (; const PxPyPzM4D< ScalarType > & ; v). inline . copy constructor ; Definition at line 87 of file PxPyPzM4D.h. Member Function Documentation. ◆ E(). template<class ScalarType = double> . Scalar ROOT::Math::PxPyPzM4D< ScalarType >::E ; (; ); const. inline . Energy. ; Definition at line 160 of file PxPyPzM4D.h. ◆ E2(). template<class ScalarType = double> . Scalar ROOT::Math::PxPyPzM4D< ScalarType >::E2 ; (; ); const. inline . energy squared ; Definition at line 189 of file PxPyPzM4D.h. ◆ Et(). template<class ScalarType = double> . Scalar ROOT::Math::PxPyPzM4D< ScalarType >::Et ; (; ); const. inline . transverse energy ; Definition at line 241 of file PxPyPzM4D.h. ◆ Et2(). template<class ScalarType = double> . Scalar ROOT::Math::PxPyPzM4D< ScalarType >::Et2 ; (; ); const. inline . transverse energy squared ; Definition at line 232 of file PxPyPzM4D.h. ◆ Eta(). template<class ScalarType = double> . Scalar ROOT::Math::PxPyPzM4D< ScalarType >::Eta ; (; ); const. inline . pseudorapidity ; Definition at line 260 of file PxPyPzM4D.h. ◆ GetCoordinates() [1/2]. template<class ScalarType = double> . void ROOT::Math::PxPyPzM4D< ScalarType >::GetCoordinates ; (; Scalar & ; px, . Scalar & ; py, . Scalar & ; pz, . Scalar & ; m . ); const. inline . get internal data into 4 Scalar numbers ; Definition at line 140 of file PxPyPzM4D.h. ◆ GetCoordinates() [2/2]. template<class ScalarType = double> . void ROOT::Math::PxPyPzM4D< ScalarType >::GetCoordinates ; (; Scalar ; dest[]); const. inline . get internal data into an array of 4 Scalar numbers ; Definition at line 126 of file PxPyPzM4D.h. ◆ M(). template<class ScalarType = double> . Scalar ROOT::Math::PxPyPzM4D< ScalarType >::M ; (; ); const. inline . Definition at line 150 of file PxPyPzM4D.h. ◆ M2(). template<class ScalarType = double> . Scalar ROOT::Math::PxP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1PxPyPzM4D.html:6233,energy,energy,6233,doc/master/classROOT_1_1Math_1_1PxPyPzM4D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1PxPyPzM4D.html,1,['energy'],['energy']
Energy Efficiency," [rowLwb..rowUpb][colLwb..colUpb] becomes [rowLwb+row_shift..rowUpb+row_shift][colLwb+col_shift..colUpb+col_shift] ; Reimplemented from TMatrixTBase< Element >.; Definition at line 756 of file TMatrixTSym.cxx. ◆ Similarity() [1/3]. template<class Element > . TMatrixTSym< Element > & TMatrixTSym< Element >::Similarity ; (; const TMatrixT< Element > & ; b). Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb) This is a similarity transform when B is orthogonal . ; It is more efficient than applying the actual multiplication because this routine realizes that the final matrix is symmetric . ; Definition at line 1099 of file TMatrixTSym.cxx. ◆ Similarity() [2/3]. template<class Element > . TMatrixTSym< Element > & TMatrixTSym< Element >::Similarity ; (; const TMatrixTSym< Element > & ; b). Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb) This is a similarity transform when B is orthogonal . ; It is more efficient than applying the actual multiplication because this routine realizes that the final matrix is symmetric . ; Definition at line 1190 of file TMatrixTSym.cxx. ◆ Similarity() [3/3]. template<class Element > . Element TMatrixTSym< Element >::Similarity ; (; const TVectorT< Element > & ; v); const. Calculate scalar v * (*this) * v^T. ; Definition at line 1292 of file TMatrixTSym.cxx. ◆ SimilarityT(). template<class Element > . TMatrixTSym< Element > & TMatrixTSym< Element >::SimilarityT ; (; const TMatrixT< Element > & ; n). Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb) It is more efficient than applying the actual multiplication because this routine realizes that the final matrix is symmetric . ; Definition at line 1327 of file TMatrixTSym.cxx. ◆ Streamer(). template<class Element > . void TMatrixTSym< Element >::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TMatrixTSym. ; Reimplemented from TMatrixTBase< Element >.; Definition at line 2037 of file TMatrixTSym.cxx. ◆ Streamer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSym.html:43851,efficient,efficient,43851,doc/master/classTMatrixTSym.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSym.html,1,['efficient'],['efficient']
Energy Efficiency," \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html:15760,energy,energy,15760,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,1,['energy'],['energy']
Energy Efficiency," \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html:15760,energy,energy,15760,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,1,['energy'],['energy']
Energy Efficiency," a RooRealvar is created and the arg list is interpreted as follows:; If list has two args, these are interpreted as xmin,xmax; If list has three args, these are interpreted as xinit,xmin,xmax; If list has one arg, this is interpreted as xinit and the variable is set as constant . Definition at line 1267 of file RooFactoryWSTool.cxx. ◆ processExpression(). std::string RooFactoryWSTool::processExpression ; (; const char * ; token). Process a single high-level expression or list of expressions. ; The returned string a the reduced expression where all inline object creations have been executed and substituted with the name of the created object. e.g. RooGaussian::g(x,m,s) --> g; e.g. {x(-10,10),s} --> {x,s} . Definition at line 882 of file RooFactoryWSTool.cxx. ◆ processListExpression(). string RooFactoryWSTool::processListExpression ; (; const char * ; arg). protected . Process a list of high-level expression. ; The returned string a the reduced expression list where all inline object creations have been executed and substituted with the name of the created object. E.g. {x(-10,10),s} --> {x,s} . Definition at line 1118 of file RooFactoryWSTool.cxx. ◆ processMetaArg(). std::string RooFactoryWSTool::processMetaArg ; (; std::string & ; func, . std::vector< std::string > & ; args . ). protected . Concatenate list of args into comma separated string. ; Definition at line 1385 of file RooFactoryWSTool.cxx. ◆ processSingleExpression(). std::string RooFactoryWSTool::processSingleExpression ; (; const char * ; arg). protected . Process a single high-level expression. ; The returned string a the reduced expression where all inline object creations have been executed and substituted with the name of the created object. e.g. RooGaussian::g(x,m,s) --> g; e.g. x[-10,10] --> x . Definition at line 972 of file RooFactoryWSTool.cxx. ◆ prod(). RooProdPdf * RooFactoryWSTool::prod ; (; const char * ; objName, . const char * ; pdfList . ). Definition at line 560 of file RooFactoryWSTool.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFactoryWSTool.html:40380,reduce,reduced,40380,doc/master/classRooFactoryWSTool.html,https://root.cern,https://root.cern/doc/master/classRooFactoryWSTool.html,1,['reduce'],['reduced']
Energy Efficiency," a cartesian metric is used. ; re-implement by derived classes if needed to be modified ; Definition at line 66 of file GSLSimAnnealing.cxx. ◆ Energy(). double ROOT::Math::GSLSimAnFunc::Energy ; (; ); const. virtual . evaluate the energy ( objective function value) re-implement by derived classes if needed to be modified ; Definition at line 50 of file GSLSimAnnealing.cxx. ◆ FastCopy(). GSLSimAnFunc & ROOT::Math::GSLSimAnFunc::FastCopy ; (; const GSLSimAnFunc & ; f). virtual . fast copy method called by GSL simulated annealing internally copy only the things which have been changed must be re-implemented by derived classes if needed ; Definition at line 96 of file GSLSimAnnealing.cxx. ◆ NDim(). unsigned int ROOT::Math::GSLSimAnFunc::NDim ; (; ); const. inline . Definition at line 135 of file GSLSimAnnealing.h. ◆ Print(). void ROOT::Math::GSLSimAnFunc::Print ; (; ). virtual . print the position in the standard output std::ostream GSL prints in addition n iteration, n function calls, temperature and energy re-implement by derived classes if necessary ; Definition at line 83 of file GSLSimAnnealing.cxx. ◆ Scale(). double ROOT::Math::GSLSimAnFunc::Scale ; (; unsigned int ; i); const. inline . Definition at line 141 of file GSLSimAnnealing.h. ◆ SetX() [1/3]. void ROOT::Math::GSLSimAnFunc::SetX ; (; const double * ; x). inline . change the x values (used by sim annealing to take a step) ; Definition at line 126 of file GSLSimAnnealing.h. ◆ SetX() [2/3]. template<class IT > . void ROOT::Math::GSLSimAnFunc::SetX ; (; IT ; begin, . IT ; end . ). inline . Definition at line 131 of file GSLSimAnnealing.h. ◆ SetX() [3/3]. void ROOT::Math::GSLSimAnFunc::SetX ; (; unsigned int ; i, . double ; x . ). inline . Definition at line 143 of file GSLSimAnnealing.h. ◆ Step(). void ROOT::Math::GSLSimAnFunc::Step ; (; const GSLRandomEngine & ; r, . double ; maxstep . ). virtual . change the x[i] value using a random value urndm generated between [0,1] up to a maximum value maxstep re-implem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLSimAnFunc.html:5603,energy,energy,5603,doc/master/classROOT_1_1Math_1_1GSLSimAnFunc.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLSimAnFunc.html,1,['energy'],['energy']
Energy Efficiency," added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranchElement.html:24627,allocate,allocated,24627,root/html526/TBranchElement.html,https://root.cern,https://root.cern/root/html526/TBranchElement.html,11,['allocate'],['allocated']
Energy Efficiency," addobj). overridevirtual . Set address of this branch. ; Reimplemented from TBranch.; Definition at line 325 of file TBranchObject.cxx. ◆ SetAutoDelete(). void TBranchObject::SetAutoDelete ; (; bool ; autodel = true). overridevirtual . Set the AutoDelete bit. ; This function can be used to instruct Root in TBranchObject::ReadBasket to not delete the object referenced by a branchobject before reading a new entry. By default, the object is deleted.; If autodel is true, this existing object will be deleted, a new object created by the default constructor, then object->Streamer called.; If autodel is false, the existing object is not deleted. Root assumes that the user is taking care of deleting any internal object or array This can be done in Streamer itself.; If this branch has sub-branches, the function sets autodel for these branches as well. We STRONGLY suggest to activate this option by default when you create the top level branch. This will make the read phase more efficient because it minimizes the numbers of new/delete operations. Once this option has been set and the Tree is written to a file, it is not necessary to specify the option again when reading, unless you want to set the opposite mode. . Reimplemented from TBranch.; Definition at line 517 of file TBranchObject.cxx. ◆ SetBasketSize(). void TBranchObject::SetBasketSize ; (; Int_t ; buffsize). overridevirtual . Reset basket size for all subbranches of this branch. ; Reimplemented from TBranch.; Definition at line 531 of file TBranchObject.cxx. ◆ SetupAddresses(). void TBranchObject::SetupAddresses ; (; ). overridevirtual . – If the branch address is not set, we set all addresses starting with the top level parent branch. ; This is required to be done in order for GetOffset to be correct and for GetEntry to run. ; Reimplemented from TBranch.; Definition at line 594 of file TBranchObject.cxx. ◆ Streamer(). void TBranchObject::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchObject.html:34811,efficient,efficient,34811,doc/master/classTBranchObject.html,https://root.cern,https://root.cern/doc/master/classTBranchObject.html,1,['efficient'],['efficient']
Energy Efficiency," algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.0000000000000001E-9, double relTol = 9.9999999999999995E-7, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::Integration::Type type, double absTol = 1.0000000000000001E-9, double relTol = 9.9999999999999995E-7, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::Integration::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.0000000000000001E-9, double relTol = 9.9999999999999995E-7, size_t size = 1000); ROOT::Math::GSL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__GSLIntegrator.html:1491,ADAPT,ADAPTIVE,1491,root/html602/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__GSLIntegrator.html,2,['ADAPT'],['ADAPTIVE']
Energy Efficiency," algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:1491,ADAPT,ADAPTIVE,1491,root/html532/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html,2,['ADAPT'],['ADAPTIVE']
Energy Efficiency," all its leaf nodes, fill max depth reached in the tree at the same time. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static BinarySearchTree * CreateFromXML (void *node, UInt_t tmva_Version_Code=262657);  re-create a new tree (decision tree or search tree) from XML ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TMVA::BinaryTree; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Private Member Functions; void DestroyNode (BinarySearchTreeNode *);  ; void Insert (const Event *, Node *);  private internal function to insert a event (node) at the proper position ;  ; Bool_t InVolume (const std::vector< Float_t > &, Volume *) const;  test if the data points are in the given volume ;  ; void NormalizeTree (std::vector< std::pair< Double_t, const TMVA::Event * > >::iterator, std::vector< std::pair< Double_t, const TMVA::Event * > >::iterator, UInt_t);  normalises the binary-search tree to reduce the branch length and hence speed up the search procedure (on average). ;  ; BinarySearchTreeNode * Search (Event *, Node *) const;  Private, recursive, function for searching. ;  ; Double_t SearchVolume (Node *, Volume *, Int_t, std::vector< const TMVA::BinarySearchTreeNode * > *events);  recursively walk through the daughter nodes and add up all weights of events that lie within the given volume ;  . Private Attributes; Bool_t fCanNormalize;  the tree can be normalised ;  ; UInt_t fCurrentDepth;  internal variable, counting the depth of the tree during insertion ;  ; std::vector< Float_t > fMax [2];  RMS for signal and background for each variable. ;  ; std::vector< Float_t > fMeans [2];  mean for signal and background for each variable ;  ; std::vector< Float_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1BinarySearchTree.html:5397,reduce,reduce,5397,doc/master/classTMVA_1_1BinarySearchTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1BinarySearchTree.html,1,['reduce'],['reduce']
Energy Efficiency," along Y . Definition at line 386 of file TCanvas.cxx. ◆ CopyPixmaps(). void TCanvas::CopyPixmaps ; (; ). overrideprivatevirtual . Copy the canvas pixmap of the pad to the canvas. ; Implements TVirtualPad.; Definition at line 833 of file TCanvas.cxx. ◆ CreatePainter(). void TCanvas::CreatePainter ; (; ). private . Probably, TPadPainter must be placed in a separate ROOT module - ""padpainter"" (the same as ""histpainter""). ; But now, it's directly in a gpad dir, so, in case of default painter, no *.so should be loaded, no need in plugin managers. May change in future. ; Definition at line 2582 of file TCanvas.cxx. ◆ DeclFileName(). static const char * TCanvas::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 238 of file TCanvas.h. ◆ Delete(). void TCanvas::Delete ; (; Option_t * ; option = """"). inlineoverridevirtual . Delete this object. ; Typically called as a command via the interpreter. Normally use ""delete"" operator when object has been allocated on the heap. ; Reimplemented from TObject.; Definition at line 120 of file TCanvas.h. ◆ DeleteCanvasPainter(). void TCanvas::DeleteCanvasPainter ; (; ). assert on IsBatch() == false? ; Definition at line 2613 of file TCanvas.cxx. ◆ Destructor(). void TCanvas::Destructor ; (; ). Actual canvas destructor. ; Definition at line 692 of file TCanvas.cxx. ◆ DisconnectWidget(). void TCanvas::DisconnectWidget ; (; ). Used by friend class TCanvasImp. ; Definition at line 2545 of file TCanvas.cxx. ◆ Draw(). void TCanvas::Draw ; (; Option_t * ; option = """"). overridevirtual . Draw a canvas. ; If a canvas with the name is already on the screen, the canvas is repainted. This function is useful when a canvas object has been saved in a Root file. One can then do: Root > TFile::Open(""file.root"");; Root > canvas->Draw();; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCanvas.html:69532,allocate,allocated,69532,doc/v632/classTCanvas.html,https://root.cern,https://root.cern/doc/v632/classTCanvas.html,1,['allocate'],['allocated']
Energy Efficiency," along Y . Definition at line 389 of file TCanvas.cxx. ◆ CopyPixmaps(). void TCanvas::CopyPixmaps ; (; ). overrideprivatevirtual . Copy the canvas pixmap of the pad to the canvas. ; Implements TVirtualPad.; Definition at line 836 of file TCanvas.cxx. ◆ CreatePainter(). void TCanvas::CreatePainter ; (; ). private . Probably, TPadPainter must be placed in a separate ROOT module - ""padpainter"" (the same as ""histpainter""). ; But now, it's directly in a gpad dir, so, in case of default painter, no *.so should be loaded, no need in plugin managers. May change in future. ; Definition at line 2595 of file TCanvas.cxx. ◆ DeclFileName(). static const char * TCanvas::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 238 of file TCanvas.h. ◆ Delete(). void TCanvas::Delete ; (; Option_t * ; option = """"). inlineoverridevirtual . Delete this object. ; Typically called as a command via the interpreter. Normally use ""delete"" operator when object has been allocated on the heap. ; Reimplemented from TObject.; Definition at line 120 of file TCanvas.h. ◆ DeleteCanvasPainter(). void TCanvas::DeleteCanvasPainter ; (; ). assert on IsBatch() == false? ; Definition at line 2626 of file TCanvas.cxx. ◆ Destructor(). void TCanvas::Destructor ; (; ). Actual canvas destructor. ; Definition at line 695 of file TCanvas.cxx. ◆ DisconnectWidget(). void TCanvas::DisconnectWidget ; (; ). Used by friend class TCanvasImp. ; Definition at line 2558 of file TCanvas.cxx. ◆ Draw(). void TCanvas::Draw ; (; Option_t * ; option = """"). overridevirtual . Draw a canvas. ; If a canvas with the name is already on the screen, the canvas is repainted. This function is useful when a canvas object has been saved in a Root file. One can then do: Root > TFile::Open(""file.root"");; Root > canvas->Draw();; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCanvas.html:69908,allocate,allocated,69908,doc/master/classTCanvas.html,https://root.cern,https://root.cern/doc/master/classTCanvas.html,1,['allocate'],['allocated']
Energy Efficiency," and loggging; 807 virtual void drawSample (const std::vector<double>& /*input*/, const std::vector<double>& /* output */, const std::vector<double>& /* target */, double /* patternWeight */) {} ///< callback for monitoring and logging; 808 ; 809 virtual void computeResult (const Net& /* net */, std::vector<double>& /* weights */) {} ///< callback for monitoring and logging; 810 ; 811 virtual bool hasConverged (double testError); ///< has this training converged already?; 812 ; 813 EnumRegularization regularization () const { return m_regularization; } ///< some regularization of the DNN is turned on?; 814 ; 815 bool useMultithreading () const { return m_useMultithreading; } ///< is multithreading turned on?; 816 ; 817 ; 818 void pads (int numPads) { if (fMonitoring) fMonitoring->pads (numPads); } ///< preparation for monitoring; 819 void create (std::string histoName, int bins, double min, double max) { if (fMonitoring) fMonitoring->create (histoName, bins, min, max); } ///< for monitoring; 820 void create (std::string histoName, int bins, double min, double max, int bins2, double min2, double max2) { if (fMonitoring) fMonitoring->create (histoName, bins, min, max, bins2, min2, max2); } ///< for monitoring; 821 void addPoint (std::string histoName, double x) { if (fMonitoring) fMonitoring->addPoint (histoName, x); } ///< for monitoring; 822 void addPoint (std::string histoName, double x, double y) {if (fMonitoring) fMonitoring->addPoint (histoName, x, y); } ///< for monitoring; 823 void plot (std::string histoName, std::string options, int pad, EColor color) { if (fMonitoring) fMonitoring->plot (histoName, options, pad, color); } ///< for monitoring; 824 void clear (std::string histoName) { if (fMonitoring) fMonitoring->clear (histoName); } ///< for monitoring; 825 bool exists (std::string histoName) { if (fMonitoring) return fMonitoring->exists (histoName); return false; } ///< for monitoring; 826 ; 827 size_t convergenceCount () const { return m_convergenceCount; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:30681,monitor,monitoring,30681,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['monitor'],['monitoring']
Energy Efficiency," and wmat. If nlmat > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then wmat contains the number of atoms; of a given kind into the molecule of the compound.; In this case, wmat in output is changed to relative; weights. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf); The same as previous but in double precision; Define a medium.; kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field:; - ifield = 0 if no magnetic field;; - ifield = -1 if user decision in guswim;; - ifield = 1 if tracking performed with g3rkuta;; - ifield = 2 if tracking; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm); ubuf pointer to an array of user words; nbuf number of user words; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ); The same as previous but in double precision; Define a rotation matrix; krot rotation matrix number assigned; thetaX polar angle for axis X; phiX azimuthal angle for axis X; thetaY polar angle for axis Y; phiY azimuthal angle for axis Y; thetaZ polar angle for axis Z; phiZ azimuthal angle for axis Z. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t np). functions from GGEOM. Create a new volume; name Volume name; shape Volume type; nmed Tracking medium number; np Number of shape parameters; upar Vector containing shape parameters; The same as previous but in double precision. void Gsdvn2(const char* name, const char* mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMCGeometry.html:10807,energy,energy,10807,root/html528/TVirtualMCGeometry.html,https://root.cern,https://root.cern/root/html528/TVirtualMCGeometry.html,10,['energy'],['energy']
Energy Efficiency," arena) const; Execute the container constructor. void Destructor(void* p, Bool_t dtorOnly = kFALSE) const; Execute the container destructor. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; Execute the container array destructor. UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objectstart); Set the address of the container being proxied and keep track of the previous one. void PopProxy(); Reset the address of the container being proxied to the previous container. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass() const; Return a pointer to the TClass representing the content. EDataType GetType() const; If the content is a simple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete). void Commit(void* ). char * operator[](UInt_t idx) const; { return (char*)(const_cast<TVirtualCollectionProxy*>(this))->At(idx); }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); Copy the iterator source, into dest. dest should contain the loc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualCollectionProxy.html:4743,Allocate,Allocate,4743,root/html534/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TVirtualCollectionProxy.html,1,['Allocate'],['Allocate']
Energy Efficiency," arena) const; Execute the container constructor. void Destructor(void* p, Bool_t dtorOnly = kFALSE) const; Execute the container destructor. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; Execute the container array destructor. UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objectstart); Set the address of the container being proxied and keep track of the previous one. void PopProxy(); Reset the address of the container being proxied to the previous container. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass() const; Return a pointer to the TClass representing the content. EDataType GetType() const; If the content is a simple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete). void Commit(void* ). void Insert(const void* data, void* container, size_t size); Insert data into the container where data is a C-style array of the actual type contained in the collection; of the given size. For associative container (map, etc.), the data type is the pair<key,value>. char * operator[](UInt_t idx) const; { return (char*)(const_cast<TVirtualCollectionProxy*>(this))->At(idx); }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualCollectionProxy.html:5192,Allocate,Allocate,5192,root/html602/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TVirtualCollectionProxy.html,2,['Allocate'],['Allocate']
Energy Efficiency," arguments values, when command element clicked in the browser. Example of the command which executes arbitrary string in application via ProcessLine looks like:; serv->RegisterCommand(""/Process"", ""%arg1%"");; When registering command, one could specify icon name which will be displayed with the command.; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; In example usage of images from $ROOTSYS/icons directory is shown. One could prepend button; string to the icon name to let browser show command as extra button. In last case one could hide command element from elements list:; serv->Hide(""/DoSomething"");; One can find example of command interface usage in tutorials/http/httpcontrol.C macro.; 1.5 Customize user interface; JSROOT is used to implement UI for the THttpServer. Default webpage shows list of registered objects on the left side and drawing area on the right side - see example. JSROOT allows to configure different parameters via URL - like monitoring interval or name of displayed items item=Files/job1.root/hpxpy&opt=colz&monitoring=1000.; Some of such parameters can be configured already on the server:; serv->SetItemField(""/"", ""_monitoring"", ""1000""); // monitoring interval in ms; serv->SetItemField(""/"", ""_drawitem"", ""Files/job1.root/hpxpy""); // item to draw; serv->SetItemField(""/"", ""_drawopt"", ""colz"");; In such case URL parameters are not required - specified item will be displayed automatically when web page is opened. One also can configure to display several items at once. For that one also can configure layout of the drawing area:; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; One also can change appearance of hierarchy browser on the left side of the web page:; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:6265,monitor,monitoring,6265,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,2,['monitor'],['monitoring']
Energy Efficiency," as if Build or BuildOld was never called on it (usef...Definition TStreamerInfo.cxx:2616; TStreamerInfo::GetElementsTObjArray * GetElements() const overrideDefinition TStreamerInfo.h:163; TStreamerInfo::fSizeInt_t fSize!size of the persistent classDefinition TStreamerInfo.h:92; TStreamerInfo::GetTypedValueAuxstatic T GetTypedValueAux(Int_t type, void *ladd, int k, Int_t len)Get the value from inside a collection.Definition TStreamerInfo.cxx:4338; TStreamerInfo::GenerateDeclarationvoid GenerateDeclaration(FILE *fp, FILE *sfp, const TList *subClasses, Bool_t top=kTRUE)Write the Declaration of class.Definition TStreamerInfo.cxx:3668; TStreamerInfo::PrintValueAuxstatic void PrintValueAux(char *ladd, Int_t atype, TStreamerElement *aElement, Int_t aleng, Int_t *count)print value of element in object at pointer, type atype, leng aleng or *count The function may be cal...Definition TStreamerInfo.cxx:5429; TStreamerInfo::NewArrayvoid * NewArray(Long_t nElements, void *ary=nullptr) overrideAn array of emulated objects is created at address ary, if ary is null, we allocate memory for the ar...Definition TStreamerInfo.cxx:4918; TStreamerInfo::GetStreamerElementTStreamerElement * GetStreamerElement(const char *datamember, Int_t &offset) const overrideReturn the StreamerElement of ""datamember"" inside our class or any of its base classes.Definition TStreamerInfo.cxx:4212; TStreamerInfo::GetCheckSumUInt_t GetCheckSum() const overrideDefinition TStreamerInfo.h:159; TStreamerInfo::Compilevoid Compile() overrideloop on the TStreamerElement list regroup members with same type Store predigested information into l...Definition TStreamerInfoActions.cxx:2972; TStreamerInfo::BuildCheckvoid BuildCheck(TFile *file=nullptr, Bool_t load=kTRUE) overrideCheck if built and consistent with the class dictionary.Definition TStreamerInfo.cxx:729; TStreamerInfo::CompareContentBool_t CompareContent(TClass *cl, TVirtualStreamerInfo *info, Bool_t warn, Bool_t complete, TFile *file) overrideReturn True if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:287279,allocate,allocate,287279,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency," as non-staged; I, nostagedcheck: do not check the actual stage status on selected files. 'process' field:; N, noaction: do nothing on the selected files; P, fullproc: open the selected files and extract the meta information; L, locateonly: only locate the selected files; S, stageonly: issue a stage request for the selected files not yet staged. 'auxiliary' field; V, verbose: notify the actions. Returns 0 on success, -1 if any failure occurs. Int_t ScanDataSet(const char* uri, UInt_t option = kReopen | kDebug); Scans the dataset indicated by <uri> and returns the number of missing files.; Returns -1 if any failure occurs.; For more details, see documentation of; ScanDataSet(TFileCollection *dataset, const char *option). void GetQuota(const char* group, const char* user, const char* dsName, TFileCollection* dataset). Gets quota information from this dataset. void ShowQuota(const char* opt); Display quota information. void PrintUsedSpace(). Prints the quota. void MonitorUsedSpace(TVirtualMonitoringWriter* monitoring). Log info to the monitoring server. Long64_t GetGroupUsed(const char* group). Returns the used space of that group. Long64_t GetGroupQuota(const char* group). returns the quota a group is allowed to have. void UpdateUsedSpace(); updates the used space maps. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings, if needed.; Returns 0 on success, -1 on failure. Int_t NotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); Save into the <datasetdir>/dataset.list file the name of the last updated; or created or modified dataset; Returns 0 on success, -1 on error. Int_t ClearCache(const char* uri); Clear cached information matching uri. Int_t ShowCache(const char* uri); Show cached information matching uri. TString CreateUri(const char* dsGroup = 0, const char* dsUser = 0, const char* dsName = 0, const char* dsTree = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDataSetManager.html:15465,monitor,monitoring,15465,root/html602/TDataSetManager.html,https://root.cern,https://root.cern/root/html602/TDataSetManager.html,6,"['Monitor', 'monitor']","['MonitorUsedSpace', 'monitoring']"
Energy Efficiency," as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = new Event();; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. If AutoDelete is on (see TBranch::SetAutoDelete),; the top level objet will be deleted and recreate; each time an entry is read, whether or not the; TTree owns the object. void SetBasketSize(Int_t buffsize); -- Reset the basket size for all sub-branches of this branch element. void SetBranchCount(TBranchElement* bre); -- Set the branch counter for this branch. Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranchElement.html:29237,allocate,allocated,29237,root/html528/TBranchElement.html,https://root.cern,https://root.cern/root/html528/TBranchElement.html,10,['allocate'],['allocated']
Energy Efficiency," as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = new Event();; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. If AutoDelete is on (see TBranch::SetAutoDelete),; the top level objet will be deleted and recreate; each time an entry is read, whether or not the; TTree owns the object. void SetBasketSize(Int_t buffsize); -- Reset the basket size for all sub-branches of this branch element. void SetBranchCount(TBranchElement* bre); -- Set the branch counter for this branch. void SetObject(void* objadd); Set object this branch is pointing to. void SetTargetClassName(const char* name); Set the name of the class of the in-memory object into which the data will; loaded. void SetupAddresses(); -- If the branch address is not set, we set all a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranchElement.html:25970,allocate,allocated,25970,root/html526/TBranchElement.html,https://root.cern,https://root.cern/root/html526/TBranchElement.html,1,['allocate'],['allocated']
Energy Efficiency," at a point x Use the private method DoDerivative. ; Definition at line 263 of file IFunction.h. ◆ DoDerivative(). virtual double ROOT::Math::IGradientFunctionOneDim::DoDerivative ; (; double ; x); const. privatepure virtual . Function to evaluate the derivative with respect each coordinate. To be implemented by the derived class. ; Implemented in ROOT::Math::WrappedTF1, ROOT::Math::GradFunctor1D, and ROOT::Math::Polynomial. ◆ FdF() [1/2]. void ROOT::Math::IGradientFunctionOneDim::FdF ; (; const double * ; x, . double & ; f, . double * ; df . ); const. inline . Compatibility method with multi-dimensional interface for Gradient and function evaluation. ; Definition at line 282 of file IFunction.h. ◆ FdF() [2/2]. virtual void ROOT::Math::IGradientFunctionOneDim::FdF ; (; double ; x, . double & ; f, . double & ; df . ); const. inlinevirtual . Optimized method to evaluate at the same time the function value and derivative at a point x. ; Often both value and derivatives are needed and it is often more efficient to compute them at the same time. Derived class should implement this method if performances play an important role and if it is faster to evaluate value and derivative at the same time. ; Reimplemented in ROOT::Math::WrappedTF1, and ROOT::Math::Polynomial.; Definition at line 275 of file IFunction.h. ◆ Gradient(). void ROOT::Math::IGradientFunctionOneDim::Gradient ; (; const double * ; x, . double * ; g . ); const. inline . Compatibility method with multi-dimensional interface for Gradient. ; Definition at line 269 of file IFunction.h. ◆ HasGradient(). bool ROOT::Math::IGradientFunctionOneDim::HasGradient ; (; ); const. inlineoverridevirtual . Reimplemented from ROOT::Math::IBaseFunctionOneDim.; Definition at line 284 of file IFunction.h. Libraries for ROOT::Math::IGradientFunctionOneDim:. [legend]; The documentation for this class was generated from the following file:; math/mathcore/inc/Math/IFunction.h. ROOTMathIGradientFunctionOneDim. ROOT master - Reference ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IGradientFunctionOneDim.html:4614,efficient,efficient,4614,doc/master/classROOT_1_1Math_1_1IGradientFunctionOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IGradientFunctionOneDim.html,1,['efficient'],['efficient']
Energy Efficiency," at line 82 of file PtEtaPhiM4D.h. ◆ PtEtaPhiM4D() [4/4]. template<class ScalarType > . ROOT::Math::PtEtaPhiM4D< ScalarType >::PtEtaPhiM4D ; (; const PtEtaPhiM4D< ScalarType > & ; v). inline . copy constructor ; Definition at line 91 of file PtEtaPhiM4D.h. Member Function Documentation. ◆ E(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D< ScalarType >::E ; (; ); const. inline . Energy (timelike component of momentum-energy 4-vector) ; Definition at line 198 of file PtEtaPhiM4D.h. ◆ E2(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D< ScalarType >::E2 ; (; ); const. inline . energy squared ; Definition at line 189 of file PtEtaPhiM4D.h. ◆ Et(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D< ScalarType >::Et ; (; ); const. inline . transverse energy ; Definition at line 250 of file PtEtaPhiM4D.h. ◆ Et2(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D< ScalarType >::Et2 ; (; ); const. inline . transverse energy squared ; Definition at line 241 of file PtEtaPhiM4D.h. ◆ Eta(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D< ScalarType >::Eta ; (; ); const. inline . Definition at line 142 of file PtEtaPhiM4D.h. ◆ GetCoordinates() [1/2]. template<class ScalarType > . void ROOT::Math::PtEtaPhiM4D< ScalarType >::GetCoordinates ; (; Scalar & ; pt, . Scalar & ; eta, . Scalar & ; phi, . Scalar & ; mass . ); const. inline . get internal data into 4 Scalar numbers ; Definition at line 134 of file PtEtaPhiM4D.h. ◆ GetCoordinates() [2/2]. template<class ScalarType > . void ROOT::Math::PtEtaPhiM4D< ScalarType >::GetCoordinates ; (; Scalar ; dest[]); const. inline . get internal data into an array of 4 Scalar numbers ; Definition at line 118 of file PtEtaPhiM4D.h. ◆ M(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D< ScalarType >::M ; (; ); const. inline . M() is the invariant mass; in this coordinate system it can be negagative if set that way. ; Definition at line 148 of file PtEtaPhiM4D.h. ◆ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1PtEtaPhiM4D.html:6518,energy,energy,6518,doc/master/classROOT_1_1Math_1_1PtEtaPhiM4D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1PtEtaPhiM4D.html,1,['energy'],['energy']
Energy Efficiency," at once. multi.bin; perform several requests at once, return result in binary form. All data will be automatically zipped if ‘.gz’ extension is appended. Like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication method. The command will look like:; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; 1.9.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: ""title"".; For the root.json request one could specify the ‘compact’ parameter, which allow to reduce the number of spaces and new lines without data lost. This parameter can have values from ‘0’ (no compression) till ‘3’ (no spaces and new lines at all). In addition, one can use simple compression algorithm for big arrays. If compact=‘10’, zero values in the begin and at the end of the array will be excluded. If compact=‘20’, similar values or large zero gaps in-between will be compressed. Such array compression support in JSROOT from version 4.8.2.; Usage of root.json request is about as efficient as binary root.bin request. Comparison of different request methods with TH2 histogram from hsimple.C shown in the table:. Request; Size. root.bin; 7672 bytes. root.bin.gz; 1582 bytes. root.json; 8570 bytes. root.json?compact=3; 6004 bytes. root.json?compact=23; 5216 bytes. root.json.gz?compact=23; 1855 bytes. One should remember that JSON representation always includes names of the data fields which are not present in the binary representation. Even then the size difference is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:15693,reduce,reduce,15693,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,2,['reduce'],['reduce']
Energy Efficiency," auto validColumnNames = GetValidatedColumnNames(nColumns, columns);; 1647 CheckAndFillDSColumns(validColumnNames, ColTypes_t());; 1648 ; 1649 using Helper_t = RDFInternal::ForeachSlotHelper<F>;; 1650 using Action_t = RDFInternal::RAction<Helper_t, Proxied>;; 1651 ; 1652 auto action = std::make_unique<Action_t>(Helper_t(std::move(f)), validColumnNames, fProxiedPtr, fColRegister);; 1653 ; 1654 fLoopManager->Run();; 1655 }; 1656 ; 1657 // clang-format off; 1658 ////////////////////////////////////////////////////////////////////////////; 1659 /// \brief Execute a user-defined reduce operation on the values of a column.; 1660 /// \tparam F The type of the reduce callable. Automatically deduced.; 1661 /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; 1662 /// \param[in] f A callable with signature `T(T,T)`; 1663 /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; 1664 /// \return the reduced quantity wrapped in a ROOT::RDF:RResultPtr.; 1665 ///; 1666 /// A reduction takes two values of a column and merges them into one (e.g.; 1667 /// by summing them, taking the maximum, etc). This action performs the; 1668 /// specified reduction operation on all processed column values, returning; 1669 /// a single value of the same type. The callable f must satisfy the general; 1670 /// requirements of a *processing function* besides having signature `T(T,T)`; 1671 /// where `T` is the type of column columnName.; 1672 ///; 1673 /// The returned reduced value of each thread (e.g. the initial value of a sum) is initialized to a; 1674 /// default-constructed T object. This is commonly expected to be the neutral/identity element for the specific; 1675 /// reduction operation `f` (e.g. 0 for a sum, 1 for a product). If a default-constructed T does not satisfy this; 1676 /// requirement, users should explicitly specify an initialization value for T by calling the appropriate `Reduce`; 1677 /// over",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:93158,reduce,reduced,93158,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['reduce'],['reduced']
Energy Efficiency," available constructors.; public:. virtual~TAttBBox(); Float_t*AssertBBox(); static TClass*Class(); virtual voidComputeBBox(); Float_t*GetBBox(); Bool_tGetBBoxOK() const; virtual TClass*IsA() const; TAttBBox&operator=(const TAttBBox& tab); voidResetBBox(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TAttBBox(). protected:. voidAssertBBoxExtents(Float_t epsilon = 0.0050000000000000001); voidBBoxCheckPoint(const Float_t* p); voidBBoxCheckPoint(Float_t x, Float_t y, Float_t z); voidBBoxClear(); voidBBoxInit(Float_t infinity = 1.0E+6); voidBBoxZero(Float_t epsilon = 0, Float_t x = 0, Float_t y = 0, Float_t z = 0); TAttBBox(const TAttBBox& tab). Data Members; protected:. Float_t*fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void BBoxInit(Float_t infinity = 1.0E+6); Allocate and prepare for incremental filling. void BBoxZero(Float_t epsilon = 0, Float_t x = 0, Float_t y = 0, Float_t z = 0); Create cube of volume (2*epsiolon)^3 at (x,y,z).; epsilon iz zero by default. void BBoxClear(); Remove BBox information. void AssertBBoxExtents(Float_t epsilon = 0.0050000000000000001); Assert extents of all sides of the bounding-box are at least epsilon. void BBoxCheckPoint(Float_t x, Float_t y, Float_t z). void BBoxCheckPoint(const Float_t* p). TAttBBox(const TAttBBox& tab). TAttBBox(); { }. virtual ~TAttBBox(); { BBoxClear(); }. TAttBBox& operator=(const TAttBBox& tab). Bool_t GetBBoxOK() const; { return fBBox != 0; }. Float_t* GetBBox(); { return fBBox; }. Float_t* AssertBBox(); { if(fBBox == 0) ComputeBBox(); return fBBox; }. void ResetBBox(); { if(fBBox != 0) BBoxClear(); }. void ComputeBBox(). » Author: Matevz Tadel 7/4/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:37; This page has been aut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TAttBBox.html:1527,Allocate,Allocate,1527,root/html604/TAttBBox.html,https://root.cern,https://root.cern/root/html604/TAttBBox.html,1,['Allocate'],['Allocate']
Energy Efficiency," available constructors.; public:. virtual~TAttBBox(); Float_t*AssertBBox(); static TClass*Class(); virtual voidComputeBBox(); Float_t*GetBBox(); Bool_tGetBBoxOK() const; virtual TClass*IsA() const; TAttBBox&operator=(const TAttBBox& tab); voidResetBBox(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TAttBBox(). protected:. voidAssertBBoxExtents(Float_t epsilon = 0.0050000000000000001); voidBBoxCheckPoint(const Float_t* p); voidBBoxCheckPoint(Float_t x, Float_t y, Float_t z); voidBBoxClear(); voidBBoxInit(Float_t infinity = 1.0E+6); voidBBoxZero(Float_t epsilon = 0, Float_t x = 0, Float_t y = 0, Float_t z = 0); TAttBBox(const TAttBBox& tab). Data Members; protected:. Float_t*fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void BBoxInit(Float_t infinity = 1.0E+6); Allocate and prepare for incremental filling. void BBoxZero(Float_t epsilon = 0, Float_t x = 0, Float_t y = 0, Float_t z = 0); Create cube of volume (2*epsiolon)^3 at (x,y,z).; epsilon iz zero by default. void BBoxClear(); Remove BBox information. void AssertBBoxExtents(Float_t epsilon = 0.0050000000000000001); Assert extents of all sides of the bounding-box are at least epsilon. void BBoxCheckPoint(Float_t x, Float_t y, Float_t z). void BBoxCheckPoint(const Float_t* p). TAttBBox(const TAttBBox& tab). TAttBBox(); { }. virtual ~TAttBBox(); { BBoxClear(); }. TAttBBox& operator=(const TAttBBox& tab). Bool_t GetBBoxOK() const; { return fBBox != 0; }. Float_t* GetBBox(); { return fBBox; }. Float_t* AssertBBox(); { if(fBBox == 0) ComputeBBox(); return fBBox; }. void ResetBBox(); { if(fBBox != 0) BBoxClear(); }. void ComputeBBox(). » Author: Matevz Tadel 7/4/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 14:39; This page has been aut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TAttBBox.html:1527,Allocate,Allocate,1527,root/html602/TAttBBox.html,https://root.cern,https://root.cern/root/html602/TAttBBox.html,1,['Allocate'],['Allocate']
Energy Efficiency," avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; * If the objects are added using the placement new then the Clear must; deallocate the memory.; * If the objects are added using TClonesArray::ConstructedAt then the; heap-based memory can stay allocated and reused as the constructor is; not called for already constructed/added object.; * To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run. Function Members (Methods); public:. virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TObject*, TObject*); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject*, Int_t); virtual voidAddAtAndExpand(TObject*, Int_t); virtual Int_tAddAtFree(TObject*); virtual voidAddBefore(const TObject*, TObject*); virtual voidAddFirst(TObject*); virtual voidAddLast(TObject*); TObject*AddrAt(Int_t idx); voidTCollection::AddVector(TObject* obj1); virtual TObject*TObjArray::After(const TObject*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClonesArray.html:4420,allocate,allocated,4420,root/html604/TClonesArray.html,https://root.cern,https://root.cern/root/html604/TClonesArray.html,2,['allocate'],['allocated']
Energy Efficiency," axis.Definition TAxis.h:31; TAxis::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TAxis.h:135; TAxis::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn center of bin.Definition TAxis.cxx:478; TAxis::GetXmaxDouble_t GetXmax() constDefinition TAxis.h:140; TAxis::FindBinvirtual Int_t FindBin(Double_t x)Find bin number corresponding to abscissa x.Definition TAxis.cxx:293; TAxis::SaveAttributesvoid SaveAttributes(std::ostream &out, const char *name, const char *subname) overrideSave axis attributes as C++ statement(s) on output stream out.Definition TAxis.cxx:710; TAxis::SetLimitsvirtual void SetLimits(Double_t xmin, Double_t xmax)Definition TAxis.h:164; TAxis::GetXminDouble_t GetXmin() constDefinition TAxis.h:139; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TF1AbsCompositionDefinition TF1AbsComposition.h:16; TF1AbsComposition::IsATClass * IsA() const overrideDefinition TF1AbsComposition.h:28; TF1ConvolutionClass wrapping convolution of two functions.Definition TF1Convolution.h:20; TF1Convolution::GetNparInt_t GetNpar() constDefinition TF1Convolution.h:68; TF1Convolution::GetParNameconst char * GetParName(Int_t ipar) constDefinition TF1Convolution.h:71; TF1NormSumClass adding two functions: c1*f1+c2*f2.Definition TF1NormSum.h:19; TF1NormSum::GetParNameconst char * GetParName(Int_t ipar) constDefinition TF1NormSum.h:66; TF1NormSum::GetParametersstd::vector< double > GetParameters() constReturn array of parameters.Definition TF1NormSum.cxx:289; TF1NormSum::GetNparInt_t GetNpar()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:171160,allocate,allocated,171160,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," based on range.; 1586 /// \param[in] end Final entry number (excluded) considered for this range. 0 means that the range goes until the end of the dataset.; 1587 /// \return a node of the computation graph for which the range is defined.; 1588 ///; 1589 /// See the other Range overload for a detailed description.; 1590 // clang-format on; 1591 RInterface<RDFDetail::RRange<Proxied>, DS_t> Range(unsigned int end) { return Range(0, end, 1); }; 1592 ; 1593 // clang-format off; 1594 ////////////////////////////////////////////////////////////////////////////; 1595 /// \brief Execute a user-defined function on each entry (*instant action*).; 1596 /// \param[in] f Function, lambda expression, functor class or any other callable object performing user defined calculations.; 1597 /// \param[in] columns Names of the columns/branches in input to the user function.; 1598 ///; 1599 /// The callable `f` is invoked once per entry. This is an *instant action*:; 1600 /// upon invocation, an event loop as well as execution of all scheduled actions; 1601 /// is triggered.; 1602 /// Users are responsible for the thread-safety of this callable when executing; 1603 /// with implicit multi-threading enabled (i.e. ROOT::EnableImplicitMT).; 1604 ///; 1605 /// ### Example usage:; 1606 /// ~~~{.cpp}; 1607 /// myDf.Foreach([](int i){ std::cout << i << std::endl;}, {""myIntColumn""});; 1608 /// ~~~; 1609 // clang-format on; 1610 template <typename F>; 1611 void Foreach(F f, const ColumnNames_t &columns = {}); 1612 {; 1613 using arg_types = typename TTraits::CallableTraits<decltype(f)>::arg_types_nodecay;; 1614 using ret_type = typename TTraits::CallableTraits<decltype(f)>::ret_type;; 1615 ForeachSlot(RDFInternal::AddSlotParameter<ret_type>(f, arg_types()), columns);; 1616 }; 1617 ; 1618 // clang-format off; 1619 ////////////////////////////////////////////////////////////////////////////; 1620 /// \brief Execute a user-defined function requiring a processing slot index on each entry (*instant ac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:89767,schedul,scheduled,89767,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['schedul'],['scheduled']
Energy Efficiency," be a unit TVector3; by TRotation (see TRotation); TRotation r;; v.Transform(r); or v *= r; // Attention v=M*v; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TRotation<div class=""legacybox""><h2>Legacy Code</h2> TRotation is a legacy interface: there will be no bug fix...Definition TRotation.h:20. Misc; Angle between two vectors; Double_t a = v1.Angle(v2.Vect()); // get angle between v1 and v2; a#define a(i)Definition RSha256.hxx:99; Light-cone components; Member functions Plus() and Minus() return the positive and negative light-cone components:; Double_t pcone = v.Plus();; Double_t mcone = v.Minus();; CAVEAT: The values returned are T{+,-}Z. It is known that some authors find it easier to define these components as (T{+,-}Z)/sqrt(2). Thus check what definition is used in the physics you're working in and adapt your code accordingly.; Transformation by TLorentzRotation; A general Lorentz transformation see class TLorentzRotation can be used by the Transform() member function, the *= or operator of the TLorentzRotation class:; TLorentzRotation l;; v.Transform(l);; v = l*v; or v *= l; // Attention v = l*v; TLorentzRotation<div class=""legacybox""><h2>Legacy Code</h2> TLorentzRotation is a legacy interface: there will be no ...Definition TLorentzRotation.h:20; lTLine lDefinition textangle.C:4. Definition at line 31 of file TLorentzVector.h. Public Types; enum  { ;   kX =0; , kY =1; , kZ =2; , kT =3; , ;   kNUM_COORDINATES =4; , kSIZE =kNUM_COORDINATES. };  ; typedef Double_t Scalar;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLorentzVector.html:7535,adapt,adapt,7535,doc/master/classTLorentzVector.html,https://root.cern,https://root.cern/doc/master/classTLorentzVector.html,1,['adapt'],['adapt']
Energy Efficiency," be fSizex*fSizey except for direct FOURIER, FOUR-WALSh, FOUR-HAAR. These need fSizex*2*fSizey length to store real and imaginary coefficients; fSizex,fSizey-basic dimensions of source and dest spectra. Transform methods; Goal: to analyse experimental data using orthogonal transforms. orthogonal transforms can be successfully used for the processing of nuclear spectra (not only); they can be used to remove high frequency noise, to increase signal-to-background ratio as well as to enhance low intensity components [1], to carry out e.g. Fourier analysis etc.; we have implemented the function for the calculation of the commonly used orthogonal transforms as well as functions for the filtration and enhancement of experimental data. References:; [1] C.V. Hampton, B. Lian, Wm. C. McHarris: Fast-Fourier-transform spectral enhancement techniques for gamma-ray spectroscopy. NIM A353 (1994) 280-284.; [2] Morhac M., Matouoek V., New adaptive Cosine-Walsh transform and its application to nuclear data compression, IEEE Transactions on Signal Processing 48 (2000) 2693.; [3] Morhac M., Matouoek V., Data compression using new fast adaptive Cosine-Haar transforms, Digital Signal Processing 8 (1998) 63.; [4] Morhac M., Matouoek V.: Multidimensional nuclear data compression using fast adaptive Walsh-Haar transform. Acta Physica Slovaca 51 (2001) 307. Example 1 - script Transform2.c:. Fig. 1 Original two-dimensional noisy spectrum. Fig. 2 Transformed spectrum from Fig. 1 using Cosine transform. Energy of the transformed data is concentrated around the beginning of the coordinate system; Script:; Example to illustrate Transform function (class TSpectrumTransform2). To execute this example, do; root > .x Transform2.C; void Transform2() {; Int_t i, j;; Int_t nbinsx = 256;; Int_t nbinsy = 256;; Int_t xmin = 0;; Int_t xmax = nbinsx;; Int_t ymin = 0;; Int_t ymax = nbinsy;; Double_t ** source = new Double_t *[nbinsx];; Double_t ** dest = new Double_t *[nbinsx];; for (i=0;i<nbinsx;i++); source[",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Transform.html:31514,adapt,adaptive,31514,doc/master/classTSpectrum2Transform.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Transform.html,1,['adapt'],['adaptive']
Energy Efficiency," been used at the training of the .xml weight file at hand ;  ; void DeclareOptions ();  ; void FindMVACut (MethodBase *method);  find the CUT on the individual MVA that defines an event as correct or misclassified (to be used in the boosting process) ;  ; Double_t GetBoostROCIntegral (Bool_t, Types::ETreeType, Bool_t CalcOverlapIntergral=kFALSE);  Calculate the ROC integral of a single classifier or even the whole boosted classifier. ;  ; void Init ();  ; void InitHistos ();  initialisation routine ;  ; void MonitorBoost (Types::EBoostStage stage, UInt_t methodIdx=0);  fill various monitoring histograms from information of the individual classifiers that have been boosted. ;  ; void PrintResults (const TString &, std::vector< Double_t > &, const Double_t) const;  ; void ProcessOptions ();  process user options ;  ; void ResetBoostWeights ();  resetting back the boosted weights of the events to 1 ;  ; Double_t SingleBoost (MethodBase *method);  ; void SingleTrain ();  initialization ;  ; virtual void TestClassification ();  initialization ;  ; virtual void WriteEvaluationHistosToFile (Types::ETreeType treetype);  writes all MVA evaluation histograms to file ;  ; void WriteMonitoringHistosToFile (void) const;  write special monitoring histograms to file dummy implementation here --------------— ;  . Private Attributes; Double_t fAdaBoostBeta;  ADA boost parameter, default is 1. ;  ; Double_t fBaggedSampleFraction;  rel.Size of bagged sample ;  ; TString fBoostedMethodName;  details of the boosted classifier ;  ; TString fBoostedMethodOptions;  options ;  ; TString fBoostedMethodTitle;  title ;  ; UInt_t fBoostNum;  Number of times the classifier is boosted. ;  ; TString fBoostType;  string specifying the boost type ;  ; Double_t fBoostWeight;  the weight used to boost the next classifier ;  ; std::vector< TH1 * > fBTrainBgdMVAHist;  ; std::vector< TH1 * > fBTrainSigMVAHist;  ; DataSetManager * fDataSetManager;  DSMTEST. ;  ; Bool_t fDetailedMonitoring;  produce detail",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBoost.html:28486,monitor,monitoring,28486,doc/master/classTMVA_1_1MethodBoost.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBoost.html,1,['monitor'],['monitoring']
Energy Efficiency," between several user define palettes.; To store a palette in an array it is enough to do:. Int_t MyPalette[100];; Double_t r[] = {0., 0.0, 1.0, 1.0, 1.0};; Double_t g[] = {0., 0.0, 0.0, 1.0, 1.0};; Double_t b[] = {0., 1.0, 0.0, 0.0, 1.0};; Double_t stop[] = {0., .25, .50, .75, 1.0};; Int_t FI = TColor::CreateGradientColorTable(5, stop, r, g, b, 100);; for (int i=0;i<100;i++) MyPalette[i] = FI+i;. Later on to reuse the palette MyPalette it will be enough to do. gStyle->SetPalette(100, MyPalette);. As only one palette is active, one need to use TExec to be able to; display plots using different palettes on the same pad.; The following macro illustrate this feature. Picture; Source. //Draw color plots using different color palettes.; //Author:: Olivier Couet. #include ""TStyle.h""; #include ""TColor.h""; #include ""TF2.h""; #include ""TExec.h""; #include ""TCanvas.h"". ; void Pal1(); {; static Int_t colors[50];; static Bool_t initialized = kFALSE;. Double_t Red[3] = { 1.00, 0.00, 0.00};; Double_t Green[3] = { 0.00, 1.00, 0.00};; Double_t Blue[3] = { 1.00, 0.00, 1.00};; Double_t Length[3] = { 0.00, 0.50, 1.00 };. if(!initialized){; Int_t FI = TColor::CreateGradientColorTable(3,Length,Red,Green,Blue,50);; for (int i=0; i<50; i++) colors[i] = FI+i;; initialized = kTRUE;; return;; }; gStyle->SetPalette(50,colors);; }. void Pal2(); {; static Int_t colors[50];; static Bool_t initialized = kFALSE;. Double_t Red[3] = { 1.00, 0.50, 0.00};; Double_t Green[3] = { 0.50, 0.00, 1.00};; Double_t Blue[3] = { 1.00, 0.00, 0.50};; Double_t Length[3] = { 0.00, 0.50, 1.00 };. if(!initialized){; Int_t FI = TColor::CreateGradientColorTable(3,Length,Red,Green,Blue,50);; for (int i=0; i<50; i++) colors[i] = FI+i;; initialized = kTRUE;; return;; }; gStyle->SetPalette(50,colors);; }. TCanvas* multipalette() {; TCanvas *c3 = new TCanvas(""c3"",""C3"",0,0,600,400);; c3->Divide(2,1);; TF2 *f3 = new TF2(""f3"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);. c3->cd(1);; f3->Draw(""surf1""); ; TExec *ex1 = new TExec(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TColor.html:6448,Green,Green,6448,root/html532/TColor.html,https://root.cern,https://root.cern/root/html532/TColor.html,1,['Green'],['Green']
Energy Efficiency," between several user define palettes.; To store a palette in an array it is enough to do:. Int_t MyPalette[100];; Double_t r[] = {0., 0.0, 1.0, 1.0, 1.0};; Double_t g[] = {0., 0.0, 0.0, 1.0, 1.0};; Double_t b[] = {0., 1.0, 0.0, 0.0, 1.0};; Double_t stop[] = {0., .25, .50, .75, 1.0};; Int_t FI = TColor::CreateGradientColorTable(5, stop, r, g, b, 100);; for (int i=0;i<100;i++) MyPalette[i] = FI+i;. Later on to reuse the palette MyPalette it will be enough to do. gStyle->SetPalette(100, MyPalette);. As only one palette is active, one need to use TExec to be able to; display plots using different palettes on the same pad.; The following macro illustrate this feature. Picture; Source. //Draw color plots using different color palettes.; //Author:: Olivier Couet. #include ""TStyle.h""; #include ""TColor.h""; #include ""TF2.h""; #include ""TExec.h""; #include ""TCanvas.h"". ; void Pal1(); {; static Int_t colors[50];; static Bool_t initialized = kFALSE;. Double_t Red[3] = { 1.00, 0.00, 0.00};; Double_t Green[3] = { 0.00, 1.00, 0.00};; Double_t Blue[3] = { 1.00, 0.00, 1.00};; Double_t Length[3] = { 0.00, 0.50, 1.00 };. if(!initialized){; Int_t FI = TColor::CreateGradientColorTable(3,Length,Red,Green,Blue,50);; for (int i=0; i<50; i++) colors[i] = FI+i;; initialized = kTRUE;; return;; }; gStyle->SetPalette(50,colors);; }. void Pal2(); {; static Int_t colors[50];; static Bool_t initialized = kFALSE;. Double_t Red[3] = { 1.00, 0.50, 0.00};; Double_t Green[3] = { 0.50, 0.00, 1.00};; Double_t Blue[3] = { 1.00, 0.00, 0.50};; Double_t Length[3] = { 0.00, 0.50, 1.00 };. if(!initialized){; Int_t FI = TColor::CreateGradientColorTable(3,Length,Red,Green,Blue,50);; for (int i=0; i<50; i++) colors[i] = FI+i;; initialized = kTRUE;; return;; }; gStyle->SetPalette(50,colors);; }. TCanvas* multipalette() {; TCanvas *c3 = new TCanvas(""c3"",""C3"",0,0,600,400);; c3->Divide(2,1);; TF2 *f3 = new TF2(""f3"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; f3->SetLineWidth(1);; f3->SetLineColor(kBlack);. c3->cd(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TColor.html:6516,Green,Green,6516,root/html534/TColor.html,https://root.cern,https://root.cern/root/html534/TColor.html,1,['Green'],['Green']
Energy Efficiency," binSampler.fitTo(data);; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; RooBinSamplingPdfThe RooBinSamplingPdf is supposed to be used as an adapter between a continuous PDF and a binned dist...Definition RooBinSamplingPdf.h:28; RooBinSamplingPdf::integratorstd::unique_ptr< ROOT::Math::IntegratorOneDim > & integrator() constDirect access to the unique_ptr holding the integrator that's used to sample the bins.Definition RooBinSamplingPdf.cxx:278; RooBinSamplingPdf::observableconst RooAbsReal & observable() constDefinition RooBinSamplingPdf.h:111; When a PDF is wrapped with a RooBinSamplingPDF, just use the bin sampling PDF instead of the original one for fits or plotting etc. NoteThe binning will be taken from the observable. Make sure that this binning is the same as the one of the dataset that should be fit. Use RooRealVar::setBinning() to adapt it. Instruct test statistics to carry out this wrapping automatically: pdf.fitTo(data, IntegrateBins(<precision>));; RooAbsPdf::fitToRooFit::OwningPtr< RooFitResult > fitTo(RooAbsData &data, CmdArgs_t const &... cmdArgs)Fit PDF to given dataset.Definition RooAbsPdf.h:157; RooBinSamplingPdf::pdfconst RooAbsPdf & pdf() constDefinition RooBinSamplingPdf.h:110; This method is especially useful when used with a simultaneous PDF, since each component will automatically be wrapped, depending on the value of precision:; precision < 0.: None of the PDFs are touched, bin sampling is off.; precision = 0.: Continuous PDFs that are fit to a RooDataHist are wrapped into a RooBinSamplingPdf. The target precision forwarded to the integrator is 1.E-4 (the default argument of the constructor).; precision > 0.: All continuous PDFs are automatically wrapped into a RooBinSamplingPdf, regardless of what data they are fit to (see next paragraph). The same ‘'precision’` is used for all integ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:2489,adapt,adapt,2489,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['adapt'],['adapt']
Energy Efficiency," both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#if !defined(CGI_ENVIRONMENT_SIZE); 486#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */; 487#endif; 488 ; 489/* Maximum number of environment variables. */; 490#if !defined(MAX_CGI_ENVIR_VARS); 491#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */; 492#endif; 493 ; 494/* General purpose buffer size. */; 495#if !defined(MG_BUF_LEN) /* in bytes */; 496#define MG_BUF_LEN (1024 * 8); 497#endif; 498 ; 499 ; 500/*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:16661,reduce,reduces,16661,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['reduce'],['reduces']
Energy Efficiency," bound of the row index; floatTMatrixTBase<float>::fTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; static TMatrixTBase<float>::(anonymous)TMatrixTBase<float>::kSizeMax; static TMatrixTBase<float>::EMatrixStatusBitsTMatrixTBase<float>::kStatus; static TMatrixTBase<float>::(anonymous)TMatrixTBase<float>::kWorkMax. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixT<Element> Delete_m(Int_t size, float*& ); Delete data pointer m, if it was assigned on the heap. Element* TMatrixT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. Int_t TMatrixT<Element> Memcpy_m(float* newp, const float* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TMatrixT<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t = -1); Allocate new matrix. Arguments are number of rows, columns, row; lowerbound (0 default) and column lowerbound (0 default). void TMatrixT<Element> Plus(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix summation. Create a matrix C such that C = A + B. void TMatrixT<Element> Plus(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); General matrix summation. Create a matrix C such that C = A + B. void TMatrixT<Element> Minus(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Minus(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Mult(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixTSym<Element> &a,const TM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixT_float_.html:16547,Allocate,Allocate,16547,root/html602/TMatrixT_float_.html,https://root.cern,https://root.cern/root/html602/TMatrixT_float_.html,4,['Allocate'],['Allocate']
Energy Efficiency," branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); -- Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranchElement.html:27164,allocate,allocate,27164,root/html528/TBranchElement.html,https://root.cern,https://root.cern/root/html528/TBranchElement.html,4,['allocate'],"['allocate', 'allocated']"
Energy Efficiency," by a Long64_t,; 142 THnI (typedef for THnT<Int_t>): bin content held by an Int_t,; 143 THnS (typedef for THnT<Short_t>): bin content held by a Short_t,; 144 THnC (typedef for THnT<Char_t>): bin content held by a Char_t,; 145 ; 146They take name and title, the number of dimensions, and for each dimension; 147the number of bins, the minimal, and the maximal value on the dimension's; 148axis. A TH2F h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; 149 ; 150 Int_t bins[2] = {10, 20};; 151 Double_t xmin[2] = {0., -5.};; 152 Double_t xmax[2] = {10., 5.};; 153 THnF hn(""hn"", ""hn"", 2, bins, xmin, xmax);; 154 ; 155## Filling; 156A THn is filled just like a regular histogram, using; 157THn::Fill(x, weight), where x is a n-dimensional Double_t value.; 158To take errors into account, Sumw2() must be called before filling the; 159histogram.; 160Storage is allocated when the first bin content is stored.; 161 ; 162## Projections; 163The dimensionality of a THn can be reduced by projecting it to; 1641, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; 165a THn. See the Projection() members. To only project parts of the; 166histogram, call; 167 ; 168 hn->GetAxis(12)->SetRange(from_bin, to_bin);; 169 ; 170## Conversion from other histogram classes; 171The static factory function THn::CreateHn() can be used to create a THn; 172from a TH1, TH2, TH3, THnSparse and (for copying) even from a THn. The; 173created THn will have compatble storage type, i.e. calling CreateHn() on; 174a TH2F will create a THnF.; 175*/; 176 ; 177ClassImp(THn);; 178 ; 179////////////////////////////////////////////////////////////////////////////////; 180/// Construct a THn.; 181 ; 182THn::THn(const char* name, const char* title,; 183 Int_t dim, const Int_t* nbins,; 184 const Double_t* xmin, const Double_t* xmax):; 185 THnBase(name, title, dim, nbins, xmin, xmax),; 186 fSumw2(dim, nbins, kTRUE /*overflow*/); 187{; 188}; 189 ; 190THn::THn(const char *name, const char *title, Int_t dim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THn_8cxx_source.html:6073,reduce,reduced,6073,doc/master/THn_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THn_8cxx_source.html,1,['reduce'],['reduced']
Energy Efficiency," cache observable is in nset then this is; the convolution observable plus; any member of nset that is either a RooCategory,; or was previously specified through setCacheObservables(). In case the cache observable is not in nset, then it is; the convolution observable plus; all member of nset that are observables of this p.d.f. . Implements RooAbsCachedPdf.; Definition at line 778 of file RooFFTConvPdf.cxx. ◆ actualParameters(). RooFit::OwningPtr< RooArgSet > RooFFTConvPdf::actualParameters ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Return the parameters on which the cache depends given normalization set nset. ; For this p.d.f these are the parameters of the input p.d.f. but never the convolution variable, in case it is not part of nset. ; Implements RooAbsCachedPdf.; Definition at line 833 of file RooFFTConvPdf.cxx. ◆ bufferFraction(). double RooFFTConvPdf::bufferFraction ; (; ); const. inline . Return value of buffer fraction applied in FFT calculation array beyond either end of the observable domain to reduce cyclical effects. ; Definition at line 43 of file RooFFTConvPdf.h. ◆ bufferStrategy(). BufStrat RooFFTConvPdf::bufferStrategy ; (; ); const. inline . Return the strategy currently used to fill the buffer: 'Extend' means is that the input p.d.f convolution observable range is widened to include the buffer range 'Flat' means that the buffer is filled with the p.d.f. ; value at the boundary of the observable range 'Mirror' means that the buffer is filled with a mirror image of the p.d.f. around the convolution observable boundary ; Definition at line 52 of file RooFFTConvPdf.h. ◆ cacheObservables(). const RooArgSet & RooFFTConvPdf::cacheObservables ; (; ); const. inline . Definition at line 39 of file RooFFTConvPdf.h. ◆ calcParams(). void RooFFTConvPdf::calcParams ; (; ). protected . (Re)calculate effective parameters of this p.d.f. ; Definition at line 957 of file RooFFTConvPdf.cxx. ◆ Class(). static TClass * RooFFTConvPdf::Class ; (; ).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:88135,reduce,reduce,88135,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['reduce'],['reduce']
Energy Efficiency," can access a file using the specified access mode.; NB: for the time being mode is ignored for XROOTD (just checks existence; of the file or directory).; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int Unlink(const char* path); Unlink 'path' on the remote server system.; Returns 0 on success, -1 otherwise. Bool_t IsOnline(const char* path); Check if the file defined by 'path' is ready to be used. Bool_t Prepare(const char* path, UChar_t opt = 8, UChar_t prio = 0); Issue a prepare request for file defined by 'path'. Int_t Prepare(TCollection* paths, UChar_t opt = 8, UChar_t prio = 0, TString* buf = 0); Issue a prepare request for a list of files defined by 'paths', which must; be of one of the following types: TFileInfo, TUrl, TObjString.; On output, bufout, if defined, points to a buffer form that can be used; with GetPathsInfo.; Return the number of paths found or -1 if any error occured. Bool_t GetPathsInfo(const char* paths, UChar_t* info); Retrieve status of a '\n'-separated list of files in 'paths'.; The information is returned as one UChar_t per file in 'info';; 'info' must be allocated by the caller. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. Int_t Locate(const char* path, TString& endurl); Get end-point url of a file. Info is returned in eurl.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. void * GetDirPtr() const; { return fDirp; }. virtual ~TXNetSystem(); { }. » Author: Frank Winklmeier, Fabrizio Furano » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/netx:$Id: TXNetSystem.h 41574 2011-10-25 13:42:03Z ganis $ » Last generated: 2011-12-02 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXNetSystem.html:22786,allocate,allocated,22786,root/html532/TXNetSystem.html,https://root.cern,https://root.cern/root/html532/TXNetSystem.html,2,['allocate'],['allocated']
Energy Efficiency," can be decoded by xml parser. Bool_t AddStyleSheet(XMLNodePointer_t parent, const char* href, const char* type = ""text/css"", const char* title = 0, int alternate = -1, const char* media = 0, const char* charset = 0); Adds style sheet definition to the specified node; Creates <?xml-stylesheet alternate=""yes"" title=""compact"" href=""small-base.css"" type=""text/css""?>; Attributes href and type must be supplied,; other attributes: title, alternate, media, charset are optional; if alternate==0, attribyte alternate=""no"" will be created,; if alternate>0, attribute alternate=""yes""; if alternate<0, attribute will not be created. Bool_t AddDocStyleSheet(XMLDocPointer_t xmldoc, const char* href, const char* type = ""text/css"", const char* title = 0, int alternate = -1, const char* media = 0, const char* charset = 0); Add style sheet definition on the top of document. void UnlinkNode(XMLNodePointer_t node); unlink (dettach) xml node from parent. void FreeNode(XMLNodePointer_t xmlnode); release all memory, allocated fro this node and; destroyes node itself. void UnlinkFreeNode(XMLNodePointer_t xmlnode); combined operation. Unlink node and free used memory. const char* GetNodeName(XMLNodePointer_t xmlnode); returns name of xmlnode. const char* GetNodeContent(XMLNodePointer_t xmlnode); get contents (if any) of xml node. XMLNodePointer_t GetChild(XMLNodePointer_t xmlnode); returns first child of xml node. XMLNodePointer_t GetParent(XMLNodePointer_t xmlnode); returns parent of xmlnode. XMLNodePointer_t GetNext(XMLNodePointer_t xmlnode); return next to xmlnode node. void ShiftToNext(XMLNodePointer_t& xmlnode, bool tonode = true); shifts specified node to next. Bool_t IsEmptyNode(XMLNodePointer_t xmlnode); return kTRUE is this is node with special data like comments to data processing instructions. void SkipEmpty(XMLNodePointer_t& xmlnode); Skip all current empty nodes and locate on first ""true"" node. void CleanNode(XMLNodePointer_t xmlnode); remove all childs node from xmlnode. XMLDocPoi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLEngine.html:13105,allocate,allocated,13105,root/html528/TXMLEngine.html,https://root.cern,https://root.cern/root/html528/TXMLEngine.html,4,['allocate'],['allocated']
Energy Efficiency," can be decoded by xml parser. Bool_t AddStyleSheet(XMLNodePointer_t parent, const char* href, const char* type = ""text/css"", const char* title = 0, int alternate = -1, const char* media = 0, const char* charset = 0); Adds style sheet definition to the specified node; Creates <?xml-stylesheet alternate=""yes"" title=""compact"" href=""small-base.css"" type=""text/css""?>; Attributes href and type must be supplied,; other attributes: title, alternate, media, charset are optional; if alternate==0, attribyte alternate=""no"" will be created,; if alternate>0, attribute alternate=""yes""; if alternate<0, attribute will not be created. Bool_t AddDocStyleSheet(XMLDocPointer_t xmldoc, const char* href, const char* type = ""text/css"", const char* title = 0, int alternate = -1, const char* media = 0, const char* charset = 0); Add style sheet definition on the top of document. void UnlinkNode(XMLNodePointer_t node); unlink (dettach) xml node from parent. void FreeNode(XMLNodePointer_t xmlnode); release all memory, allocated fro this node and; destroyes node itself. void UnlinkFreeNode(XMLNodePointer_t xmlnode); combined operation. Unlink node and free used memory. const char* GetNodeName(XMLNodePointer_t xmlnode); returns name of xmlnode. const char* GetNodeContent(XMLNodePointer_t xmlnode); get contents (if any) of xml node. void SetNodeContent(XMLNodePointer_t xmlnode, const char* content, Int_t len = 0); set content of the xml node; if old node content was exists, it will be replaced. void AddNodeContent(XMLNodePointer_t xmlnode, const char* content, Int_t len = 0); add new content of the xml node; old content will be preserved, one could mix content with child nodes. XMLNodePointer_t GetChild(XMLNodePointer_t xmlnode, Bool_t realnode = kTRUE); returns first child of xml node. XMLNodePointer_t GetParent(XMLNodePointer_t xmlnode); returns parent of xmlnode. XMLNodePointer_t GetNext(XMLNodePointer_t xmlnode, Bool_t realnode = kTRUE); return next to xmlnode node; if realnode==kTRUE, any spe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXMLEngine.html:13574,allocate,allocated,13574,root/html534/TXMLEngine.html,https://root.cern,https://root.cern/root/html534/TXMLEngine.html,6,['allocate'],['allocated']
Energy Efficiency," change unexpectedly. . Definition at line 277 of file RooDataSet.cxx. ◆ RooDataSet() [3/5]. RooDataSet::RooDataSet ; (; RooStringView ; name, . RooStringView ; title, . RooDataSet * ; dset, . const RooArgSet & ; vars, . const char * ; cuts = nullptr, . const char * ; wgtVarName = nullptr . ). Constructor of a data set from (part of) an existing data set. ; The dimensions of the data set are defined by the 'vars' RooArgSet, which can be identical to 'dset' dimensions, or a subset thereof. The 'cuts' string is an optional RooFormula expression and can be used to select the subset of the data points in 'dset' to be copied. The cut expression can refer to any variable in the source dataset. For cuts involving variables other than those contained in the source data set, such as intermediate formula objects, use the equivalent constructor accepting RooFormulaVar reference as cut specification.; For most uses the RooAbsData::reduce() wrapper function, which uses this constructor, is the most convenient way to create a subset of an existing data ; Definition at line 539 of file RooDataSet.cxx. ◆ RooDataSet() [4/5]. RooDataSet::RooDataSet ; (; RooStringView ; name, . RooStringView ; title, . RooDataSet * ; dset, . const RooArgSet & ; vars, . const RooFormulaVar & ; cutVar, . const char * ; wgtVarName = nullptr . ). Constructor of a data set from (part of) an existing data set. ; The dimensions of the data set are defined by the 'vars' RooArgSet, which can be identical to 'dset' dimensions, or a subset thereof. The 'cutVar' formula variable is used to select the subset of data points to be copied. For subsets without selection on the data points, or involving cuts operating exclusively and directly on the data set dimensions, the equivalent constructor with a string based cut expression is recommended.; For most uses the RooAbsData::reduce() wrapper function, which uses this constructor, is the most convenient way to create a subset of an existing data ; Definition at line 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataSet.html:40837,reduce,reduce,40837,doc/master/classRooDataSet.html,https://root.cern,https://root.cern/doc/master/classRooDataSet.html,1,['reduce'],['reduce']
Energy Efficiency, char * TMVA::OptimizeConfigParameters::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::OptimizeConfigParameters::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 100 of file OptimizeConfigParameters.h. ◆ DeclFileName(). static const char * TMVA::OptimizeConfigParameters::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 100 of file OptimizeConfigParameters.h. ◆ EstimatorFunction(). Double_t TMVA::OptimizeConfigParameters::EstimatorFunction ; (; std::vector< Double_t > & ; pars). privatevirtual . return the estimator (from current FOM) for the fitting interface ; Implements TMVA::IFitterTarget.; Definition at line 307 of file OptimizeConfigParameters.cxx. ◆ GetBkgEffAtSigEff(). Double_t TMVA::OptimizeConfigParameters::GetBkgEffAtSigEff ; (; Double_t ; sigEff = 0.5). private . calculate the background efficiency for a given signal efficiency ; adapted by marc-.nosp@m.oliv.nosp@m.ier.b.nosp@m.ettl.nosp@m.er@ce.nosp@m.rn.c.nosp@m.h ; Definition at line 546 of file OptimizeConfigParameters.cxx. ◆ GetBkgRejAtSigEff(). Double_t TMVA::OptimizeConfigParameters::GetBkgRejAtSigEff ; (; Double_t ; sigEff = 0.5). private . calculate the background rejection for a given signal efficiency ; adapted by marc-.nosp@m.oliv.nosp@m.ier.b.nosp@m.ettl.nosp@m.er@ce.nosp@m.rn.c.nosp@m.h ; Definition at line 583 of file OptimizeConfigParameters.cxx. ◆ GetFOM(). Double_t TMVA::OptimizeConfigParameters::GetFOM ; (; ). private . Return the Figure of Merit (FOM) used in the parameter optimization process. ; Definition at line 350 of file OptimizeConfigParameters.cxx. ◆ GetMethod(). MethodBase * TMVA::OptimizeConfigParameters::GetMethod ; (; ). inlineprivate . Definition at line 72 of file OptimizeConfigParameters.h. ◆ GetMVADists(). void TMVA::OptimizeConfigParameters::GetMVADists ; (; ). private . fill the private histograms ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:6308,adapt,adapted,6308,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['adapt'],['adapted']
Energy Efficiency," char *title, const RooArgList &funcObs, const RooArgList &histObs, const RooDataHist &dhist, Int_t intOrder=0);  Constructor from a RooDataHist. ;  ;  RooHistFunc (const char *name, const char *title, const RooArgList &pdfObs, const RooArgList &histObs, std::unique_ptr< RooDataHist > dhist, int intOrder=0);  ;  RooHistFunc (const char *name, const char *title, const RooArgSet &vars, const RooDataHist &dhist, Int_t intOrder=0);  Constructor from a RooDataHist. ;  ;  RooHistFunc (const char *name, const char *title, const RooArgSet &vars, std::unique_ptr< RooDataHist > dhist, int intOrder=0);  ;  RooHistFunc (const RooHistFunc &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooHistFunc () override;  ; double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const override;  Return integral identified by 'code'. ;  ; std::list< double > * binBoundaries (RooAbsRealLValue &, double, double) const override;  Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ;  ; std::string buildCallToAnalyticIntegral (int code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines the analytical integral translation for the class. ;  ; TObject * clone (const char *newname) const override;  ; RooDataHist * cloneAndOwnDataHist (const char *newname="""");  Replaces underlying RooDataHist with a clone, which is now owned, and returns the clone. ;  ; RooDataHist & dataHist ();  Return RooDataHist that is represented. ;  ; const RooDataHist & dataHist () const;  Return RooDataHist that is represented. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  ; Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const override;  Determine integration scenario. ;  ; Int_t getBin () const;  Compute bin numbe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:1744,efficient,efficiently,1744,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,1,['efficient'],['efficiently']
Energy Efficiency," clang; llvm / clang were updated to r227800. This includes everything from the clang 3.6 release.; Dictionary Generation; Detect usage of #pragma once for inlined headers.; Turn on verbosity of genreflex if the VERBOSE environment variable is defined.; Optimise forward declarations in rootmap files in order to make their interpretation faster.; Propagate attributes specified in xml selection files to selected classes even when selected through typedefs.; Optimise selection procedure caching selected declarations in the selection rules, therewith avoiding to query the AST twice.; Include in the PCH all the STL and C headers to guarantee portability of binaries from SLC6 to CC7.; I/O Libraries; I/O New functionalities. Support for forward_list and I/O of unordered stl containers.; Support for std::complex. I/O Behavior change. The I/O now properly skip the content of base class onfile that have been removed from the in-memory class layout.; The scheduling the I/O customization rules within a StreamerInfo is now as soon as possible, i.e. after all sources have been read. One significant consequence is that now when an object is stored in a split branch the rule is associtated with the branch of the last of the rule’s sources rather than the last of the object’s data member.; Properly support TStreamerInfo written by ROOT v4.00.; Fix the ordering of the keys in a TFile being written; in particular fixing the result of GetKey and FindKey which were no longer returning the lastest cycle for a TFile being written since v5.34/11. Networking Libraries; HTTP Server; Command Interface; One can now register an arbitrary command to the server, which become visible in the web browser. Then, when the item is clicked by the user, the command ends-up in a gROOT->ProcessLineSync() call.; Custom Properties; Custom properties can be configured for any item in the server. For example, one could configure an icon for each item visible in the browser. Or one could ‘hide’ any item from the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:8106,schedul,scheduling,8106,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['schedul'],['scheduling']
Energy Efficiency," class . ◆ Class_Name(). static const char * RooNonCPEigenDecay::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooNonCPEigenDecay::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 119 of file RooNonCPEigenDecay.h. ◆ clone(). TObject * RooNonCPEigenDecay::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 80 of file RooNonCPEigenDecay.h. ◆ coefAnalyticalIntegral(). double RooNonCPEigenDecay::coefAnalyticalIntegral ; (; Int_t ; coef, . Int_t ; code, . const char * ; rangeName = nullptr . ); const. overridevirtual . correct for the right/wrong charge... ; Reimplemented from RooAbsAnaConvPdf.; Definition at line 279 of file RooNonCPEigenDecay.cxx. ◆ coefficient(). double RooNonCPEigenDecay::coefficient ; (; Int_t ; basisIndex); const. overridevirtual . B0 : _tag == -1; B0bar : _tag == +1; rho+ : _rhoQ == +1; rho- : _rhoQ == -1; the charge correction factor ""_correctQ"" serves to implement misidentified charges . Implements RooAbsAnaConvPdf.; Definition at line 209 of file RooNonCPEigenDecay.cxx. ◆ DeclFileName(). static const char * RooNonCPEigenDecay::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 119 of file RooNonCPEigenDecay.h. ◆ generateEvent(). void RooNonCPEigenDecay::generateEvent ; (; Int_t ; code). overridevirtual . Interface for generation of an event using the algorithm corresponding to the specified code. ; The meaning of each code is defined by the getGenerator() implementation. The default implementation does nothing. ; Reimplemented from RooAbsPdf.; Definition at line 383 of file RooNonCPEigenDecay.cxx. ◆ getCoefAnalyticalIntegral(). Int_t RooNonCPEigenDecay::getCoefAnalyticalIntegral ; (; Int_t ; coef, . RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Default impl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNonCPEigenDecay.html:81401,charge,charge,81401,doc/master/classRooNonCPEigenDecay.html,https://root.cern,https://root.cern/doc/master/classRooNonCPEigenDecay.html,2,['charge'],"['charge', 'charges']"
Energy Efficiency," class RooAbsReal that binds generic C(++) functions to a RooAbsReal argument thus allowing generic C++ functions to be used as RooFit functions ;  CRooFunctor1DPdfBinding;  CRooFunctorBindingRooCFunction1Binding is a templated implementation of class RooAbsReal that binds generic C(++) functions to a RooAbsReal argument thus allowing generic C++ functions to be used as RooFit functions ;  CRooFunctorPdfBinding;  CRooGammaImplementation of the Gamma PDF for RooFit/RooStats ;  CRooGaussianPlain Gaussian p.d.f ;  CRooGaussKronrodIntegrator1DRooGaussKronrodIntegrator1D implements the Gauss-Kronrod integration algorithm ;  CRooGaussModelClass RooGaussModel implements a RooResolutionModel that models a Gaussian distribution ;  CRooGenContextClass RooGenContext implement a universal generator context for all RooAbsPdf classes that do not have or need a specialized generator context ;  CRooGenericPdfRooGenericPdf is a concrete implementation of a probability density function, which takes a RooArgList of servers and a C++ expression string defining how its value should be calculated from the given list of servers ;  CRooGenFitStudyRooGenFitStudy is an abstract base class for RooStudyManager modules ;  CRooGenFunctionLightweight interface adaptor that exports a RooAbsReal as a ROOT::Math::IGenFunction ;  CRooGenPdfPdf;  CRooGenProdProjRooGenProdProj is an auxiliary class for RooProdPdf that calculates a general normalized projection of a product of non-factorizing PDFs, e.g ;  CRooGExpModelClass RooGExpModel is a RooResolutionModel implementation that models a resolution function that is the convolution of a Gaussian with a one-sided exponential ;  CRooGlobalFunc;  CRooGridRooGrid is a utility class for RooMCIntegrator which implements an adaptive multi-dimensional Monte Carlo numerical integration, following the VEGAS algorithm ;  CRooHashTableRooHashTable implements a hash table for TObjects ;  CRooHistA RooHist is a graphical representation of binned data based on the TGr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:115318,adapt,adaptor,115318,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['adapt'],['adaptor']
Energy Efficiency," class charts. ROOT; » CORE; » BASE; » TQClass. class TQClass: public TQObject, public TClass. This is the ROOT implementation of the Qt object communication; mechanism (see also http://www.troll.no/qt/metaobjects.html). Signals and slots are used for communication between objects.; When an object has changed in some way that might be interesting; for the outside world, it emits a signal to tell whoever is; listening. All slots that are connected to this signal will be; activated (called). It is even possible to connect a signal; directly to another signal (this will emit the second signal; immediately whenever the first is emitted.) There is no limitation; on the number of slots that can be connected to a signal.; The slots will be activated in the order they were connected; to the signal. This mechanism allows objects to be easily reused,; because the object that emits a signal does not need to know; to which objects the signals are connected.; Together, signals and slots make up a powerfull component; programming mechanism. This implementation is provided by; Valeriy Onuchin (onuchin@sirius.ihep.su). Function Members (Methods); public:. TQClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmembers, const char* dfil = 0, const char* ifil = 0, Int_t dl = 0, Int_t il = 0); virtual~TQClass(); voidTObject::AbstractMethod(const char* method) const; static voidTClass::AddClass(TClass* cl); voidTClass::AddImplFile(const char* filename, int line); voidTClass::AddInstance(Bool_t heap = kFALSE); static Bool_tTClass::AddRule(const char* rule); voidTClass::AdoptMemberStreamer(const char* name, TMemberStreamer* strm); voidTClass::AdoptReferenceProxy(TVirtualRefProxy* proxy); voidTClass::AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); voidTClass::AdoptStreamer(TClassStreamer* strm); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQClass.html:1202,power,powerfull,1202,root/html534/TQClass.html,https://root.cern,https://root.cern/root/html534/TQClass.html,2,['power'],['powerfull']
Energy Efficiency," class charts. ROOT; » CORE; » BASE; » TQClass. class TQClass: public TQObject, public TClass. This is the ROOT implementation of the Qt object communication; mechanism (see also http://www.troll.no/qt/metaobjects.html). Signals and slots are used for communication between objects.; When an object has changed in some way that might be interesting; for the outside world, it emits a signal to tell whoever is; listening. All slots that are connected to this signal will be; activated (called). It is even possible to connect a signal; directly to another signal (this will emit the second signal; immediately whenever the first is emitted.) There is no limitation; on the number of slots that can be connected to a signal.; The slots will be activated in the order they were connected; to the signal. This mechanism allows objects to be easily reused,; because the object that emits a signal does not need to know; to which objects the signals are connected.; Together, signals and slots make up a powerfull component; programming mechanism. This implementation is provided by; Valeriy Onuchin (onuchin@sirius.ihep.su). Function Members (Methods); public:. TQClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmembers, const char* dfil = 0, const char* ifil = 0, Int_t dl = 0, Int_t il = 0); virtual~TQClass(); voidTObject::AbstractMethod(const char* method) const; static voidTClass::AddClass(TClass* cl); voidTClass::AddImplFile(const char* filename, int line); voidTClass::AddInstance(Bool_t heap = kFALSE); voidTClass::AddRef(TClassRef* ref); static Bool_tTClass::AddRule(const char* rule); voidTClass::AdoptMemberStreamer(const char* name, TMemberStreamer* strm); voidTClass::AdoptReferenceProxy(TVirtualRefProxy* proxy); voidTClass::AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); voidTClass::AdoptStreamer(TClassStreamer* strm); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQClass.html:1202,power,powerfull,1202,root/html528/TQClass.html,https://root.cern,https://root.cern/root/html528/TQClass.html,4,['power'],['powerfull']
Energy Efficiency," class charts. ROOT; » CORE; » BASE; » TQClass. class TQClass: public TQObject, public TClass. This is the ROOT implementation of the Qt object communication; mechanism (see also http://www.troll.no/qt/metaobjects.html). Signals and slots are used for communication between objects.; When an object has changed in some way that might be interesting; for the outside world, it emits a signal to tell whoever is; listening. All slots that are connected to this signal will be; activated (called). It is even possible to connect a signal; directly to another signal (this will emit the second signal; immediately whenever the first is emitted.) There is no limitation; on the number of slots that can be connected to a signal.; The slots will be activated in the order they were connected; to the signal. This mechanism allows objects to be easily reused,; because the object that emits a signal does not need to know; to which objects the signals are connected.; Together, signals and slots make up a powerfull component; programming mechanism. This implementation is provided by; Valeriy Onuchin (onuchin@sirius.ihep.su). Function Members (Methods); public:. virtual~TQClass(); voidTObject::AbstractMethod(const char* method) const; static voidTClass::AddClass(TClass* cl); static voidTClass::AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl); voidTClass::AddImplFile(const char* filename, int line); voidTClass::AddInstance(Bool_t heap = kFALSE); static Bool_tTClass::AddRule(const char* rule); voidTClass::AdoptMemberStreamer(const char* name, TMemberStreamer* strm); voidTClass::AdoptReferenceProxy(TVirtualRefProxy* proxy); voidTClass::AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); voidTClass::AdoptStreamer(TClassStreamer* strm); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Int_tTClass::AutoBrowse(TObject* obj, TBrowser* browser); static Bool_tTQObject::BlockAllSignals(Bool_t b)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQClass.html:1226,power,powerfull,1226,root/html602/TQClass.html,https://root.cern,https://root.cern/root/html602/TQClass.html,4,['power'],['powerfull']
Energy Efficiency," client activity on the cluster ;  CTProofMgrLiteBasic TProofMgr functionality implementation in the case of Lite session ;  ►CTProofMonSenderProvides the interface for PROOF monitoring to different writers ;  CTDSetPlet;  CTProofMonSenderMLTProofMonSender implementation for the ML writer ;  CTProofMonSenderSQLTProofMonSender implementation for the SQL writers ;  CTProofNodeInfoThe purpose of this class is to provide a complete node description for masters, submasters and workers ;  CTProofNodesPROOF worker node information ;  CTProofOutputFileClass to steer the merging of files produced on the workers ;  CTProofOutputListDerivation of TList with an overload of ls() and Print() allowing to filter out some of the variables ;  CTProofPerfAnalysisSet of tools to analyse the performance tree ;  ►CTProofPlayerInternal class steering processing in PROOF ;  CTCleanup;  CTProofPlayerLiteVersion of TProofPlayerRemote merges the functionality needed by clients and masters ;  CTProofPlayerLocal;  CTProofPlayerRemote;  CTProofPlayerSlave;  CTProofPlayerSuperMaster;  CTProofProgressDialog;  CTProofProgressInfo;  CTProofProgressLog;  CTProofProgressMemoryPlot;  CTProofProgressStatusContainer class for processing statistics ;  CTProofQueryResultTQueryResult version adapted to PROOF neeeds ;  CTProofResources;  CTProofResourcesStaticThe purpose of this class is to provide a standard interface to static config files ;  CTProofServClass providing the PROOF server ;  CTProofServLiteVersion of the PROOF worker server for local running ;  CTProofServLogHandler;  CTProofServLogHandlerGuard;  CTProofSuperMasterImplementation of TProof controlling PROOF federated clusters ;  CTProofVectorContainer;  ►CTProtoClassPersistent version of a TClass ;  CTProtoRealData;  CTPServerSocket;  CTPSocket;  CTPwdCtx;  CTPyArg;  CTPyClassGenerator;  CTPyDispatcher;  CTPyMultiGenFunction;  CTPyMultiGradFunction;  CTPyReturn;  CTPySelector;  ►CTPythia6TPythia is an interface class to F77 version of Pythia 6.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:179789,adapt,adapted,179789,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,4,['adapt'],['adapted']
Energy Efficiency," column. ; Template Parameters. FThe type of the reduce callable. Automatically deduced. ; TThe type of the column to apply the reduction to. Automatically deduced. . Parameters. [in]fA callable with signature T(T,T) ; [in]columnNameThe column to be reduced. If omitted, the first default column is used instead. ; [in]redIdentityThe reduced object of each thread is initialized to this value. . Returnsthe reduced quantity wrapped in a RResultPtr. Example usage:; auto sumOfIntColWithOffset = d.Reduce([](int x, int y) { return x + y; }, ""intCol"", 42);; See the description of the first Reduce overload for more information. ; Definition at line 1711 of file RInterface.hxx. ◆ Reduce() [2/2]. template<typename Proxied , typename DataSource = void> . template<typename F , typename T = typename TTraits::CallableTraits<F>::ret_type> . RResultPtr< T > ROOT::RDF::RInterface< Proxied, DataSource >::Reduce ; (; F ; f, . std::string_view ; columnName = """" . ). inline . Execute a user-defined reduce operation on the values of a column. ; Template Parameters. FThe type of the reduce callable. Automatically deduced. ; TThe type of the column to apply the reduction to. Automatically deduced. . Parameters. [in]fA callable with signature T(T,T) ; [in]columnNameThe column to be reduced. If omitted, the first default column is used instead. . Returnsthe reduced quantity wrapped in a ROOT::RDF:RResultPtr.; A reduction takes two values of a column and merges them into one (e.g. by summing them, taking the maximum, etc). This action performs the specified reduction operation on all processed column values, returning a single value of the same type. The callable f must satisfy the general requirements of a processing function besides having signature T(T,T) where T is the type of column columnName.; The returned reduced value of each thread (e.g. the initial value of a sum) is initialized to a default-constructed T object. This is commonly expected to be the neutral/identity element for the spe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:120351,reduce,reduce,120351,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['reduce'],['reduce']
Energy Efficiency," component squared; ppv2 = v.Perp(v1); // get transverse component with respect; // to another vector; pp2v2 = v.Perp(v1);; there are two more set functions SetPtEtaPhiE(pt,eta,phi,e) and SetPtEtaPhiM(pt,eta,phi,m) for convenience.; 17.4.4 Arithmetic and Comparison Operators; The TLorentzVector class provides operators to add subtract or compare four-vectors:; v3 = -v1;; v1 = v2+v3;; v1+= v3;; v1 = v2 + v3;; v1-= v3;; if (v1 == v2) {...}; if (v1 != v3) {...}; 17.4.5 Magnitude/Invariant mass, beta, gamma, scalar product; The scalar product of two four-vectors is calculated with the (-,-,-,+)metric:; s = v1*v2 = t1*t2-x1*x2-y1*y2-z1*z2; The magnitude squared mag2 of a four-vector is therefore:; mag2 = v*v = t*t-x*x-y*y-z*z; If mag2 is negative: mag = -Sqrt(-mag*mag). The methods are:; Double_t s, s2;; s = v1.Dot(v2);// scalar product; s = v1*v2;// scalar product; s2 = v.Mag2();ors2 = v.M2();; s = v.Mag();s = v.M();; Since in case of momentum and energy the magnitude has the meaning of invariant mass TLorentzVector provides the more meaningful aliases M2() and M(). The methods Beta() and Gamma() returns beta and gamma = 1/Sqrt(1-beta*beta).; 17.4.6 Lorentz Boost; A boost in a general direction can be parameterized with three parameters which can be taken as the components of a three vector b=(bx,by,bz). With x=(x,y,z) and gamma=1/Sqrt(1-beta*beta) (beta being the module of vector b), an arbitrary active Lorentz boost transformation (from the rod frame to the original frame) can be written as:; x = x' + (gamma-1)/(beta*beta)*(b*x')*b + gamma*t'*b; t = gamma(t'+ b*x'); The Boost() method performs a boost transformation from the rod frame to the original frame. BoostVector() returns a TVector3 of the spatial components divided by the time component:; TVector3 b;; v.Boost(bx,by,bz);; v.Boost(b);; b = v.BoostVector();// b=(x/t,y/t,z/t); 17.4.7 Rotations; There are four sets of functions to rotate the TVector3 component of a TLorentzVector:; Around Axes:; v.RotateX(TMath::Pi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:869468,energy,energy,869468,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['energy'],['energy']
Energy Efficiency," const Float_t* eyh = 0); TGraphAsymmErrors(Int_t n, const Double_t* x, const Double_t* y, const Double_t* exl = 0, const Double_t* exh = 0, const Double_t* eyl = 0, const Double_t* eyh = 0); virtual voidTGraph::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidTGraph::Zero(Int_t& k, Double_t AZ, Double_t BZ, Double_t E2, Double_t& X, Double_t& Y, Int_t maxiterations). protected:. virtual Double_t**Allocate(Int_t size); Double_t**TGraph::AllocateArrays(Int_t Narrays, Int_t arraySize); virtual voidCopyAndRelease(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin); virtual Bool_tCopyPoints(Double_t** arrays, Int_t ibegin, Int_t iend, Int_t obegin); Bool_tCtorAllocate(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Bool_tDoMerge(const TGraph* g); Double_t**TGraph::ExpandAndCopy(Int_t size, Int_t iend); virtual voidFillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); voidTObject::MakeZombie(); Double_t**TGraph::ShrinkAndCopy(Int_t size, Int_t iend); virtual voidSwapPoints(Int_t pos1, Int_t pos2); static voidTGraph::SwapValues(Double_t* arr, Int_t pos1, Int_t pos2). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGraph::(anonymous)TGraph::kClipFrame; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TGraph::(anonymous)TGraph::kNotEditable; static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraphAsymmErrors.html:13571,Allocate,Allocate,13571,root/html602/TGraphAsymmErrors.html,https://root.cern,https://root.cern/root/html602/TGraphAsymmErrors.html,4,['Allocate'],"['Allocate', 'AllocateArrays']"
Energy Efficiency," const ROOT::Math::PtEtaPhiEVector p(lep_pt[i], lep_eta[i], lep_phi[i], lep_e[i]);; if (abs(z0[i] * sin(p.Theta())) < 0.5) {; if (idx == -1) idx = i;; else return -1; // Accept only events with exactly one good lepton; }; }; }; return idx;; }; """"""); ; for s in samples:; # Select events with electron or muon trigger and with a missing transverse energy above 30 GeV; df[s] = df[s].Filter(""trigE || trigM"")\; .Filter(""met_et > 30000""); ; # Perform preselection of highly isolated leptons; df[s] = df[s].Define(""goodlep"", ""lep_isTightID && lep_pt > 35000 && lep_ptcone30 / lep_pt < 0.1 && lep_etcone20 / lep_pt < 0.1"")\; .Filter(""ROOT::VecOps::Sum(goodlep) > 0""); ; # Find a single good lepton, otherwise return -1 as index; df[s] = df[s].Define(""idx_lep"", ""FindGoodLepton(goodlep, lep_type, lep_pt, lep_eta, lep_phi, lep_E, lep_trackd0pvunbiased, lep_tracksigd0pvunbiased, lep_z0)"")\; .Filter(""idx_lep != -1""); ; # Compute transverse mass of the W boson using the missing transverse energy and the good lepton; # Use only events with a transverse mass of the reconstructed W boson larger than 60 GeV; df[s] = df[s].Define(""mtw"", ""sqrt(2 * lep_pt[idx_lep] * met_et * (1 - cos(lep_phi[idx_lep] - met_phi)))"")\; .Filter(""mtw > 60000""); ; # Perform preselection of jets; df[s] = df[s].Filter(""ROOT::VecOps::Sum(jet_pt > 30000 && abs(jet_eta) < 2.5) > 0""); ; # Select events with two good jets and one b-jet and find the indices in the collections; df[s] = df[s].Define(""goodjet"", ""jet_pt > 60000 || abs(jet_eta) > 2.4 || jet_jvt > 0.59"")\; .Filter(""ROOT::VecOps::Sum(goodjet) == 2"")\; .Define(""goodbjet"", ""goodjet && jet_MV2c10 > 0.8244273"")\; .Filter(""ROOT::VecOps::Sum(goodbjet) == 1"")\; .Define(""idx_tagged"", ""ROOT::VecOps::ArgMax(goodjet && goodbjet)"")\; .Define(""idx_untagged"", ""ROOT::VecOps::ArgMax(goodjet && !goodbjet)""); ; # Select events based on the jet kinematics and the scalar sum of the transverse momentum; # from the lepton, jets and met above 195 GeV; df[s] = df[s].Filter(""abs(jet_eta[i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:5353,energy,energy,5353,doc/master/df107__SingleTopAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html,1,['energy'],['energy']
Energy Efficiency," const char * ; exclude . ). virtual . Partition dataset 'ds' accordingly to the servers. ; The returned TMap contains: <server> --> <subdataset> (TFileCollection) where <subdataset> is the subset of 'ds' on <server> The partitioning is done using all the URLs in the TFileInfo's, so the resulting datasets are not mutually exclusive. The string 'exclude' contains a comma-separated list of servers to exclude from the map. ; Definition at line 1006 of file TDataSetManager.cxx. ◆ GetUserUsedMap(). virtual TMap * TDataSetManager::GetUserUsedMap ; (; ). inlineprotectedvirtual . Definition at line 71 of file TDataSetManager.h. ◆ IsA(). TClass * TDataSetManager::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TDataSetManagerFile.; Definition at line 158 of file TDataSetManager.h. ◆ MonitorUsedSpace(). void TDataSetManager::MonitorUsedSpace ; (; TVirtualMonitoringWriter * ; monitoring). virtual . Log info to the monitoring server. ; Definition at line 673 of file TDataSetManager.cxx. ◆ NotifyUpdate(). Int_t TDataSetManager::NotifyUpdate ; (; const char * ; group = 0, . const char * ; user = 0, . const char * ; dspath = 0, . Long_t ; mtime = 0, . const char * ; checksum = 0 . ). virtual . Save into the <datasetdir>/dataset.list file the name of the last updated or created or modified dataset Returns 0 on success, -1 on error. ; Reimplemented in TDataSetManagerFile.; Definition at line 773 of file TDataSetManager.cxx. ◆ operator=(). TDataSetManager & TDataSetManager::operator= ; (; const TDataSetManager & ; ). private . ◆ ParseDataSetSrvMaps(). TList * TDataSetManager::ParseDataSetSrvMaps ; (; const TString & ; srvmaps). static . Create a server mapping list from the content of 'srvmaps' Return the list (owned by the caller) or 0 if no valid info could be found) ; Definition at line 1867 of file TDataSetManager.cxx. ◆ ParseInitOpts(). void TDataSetManager::ParseInitOpts ; (; const char * ; opts).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManager.html:26899,monitor,monitoring,26899,doc/master/classTDataSetManager.html,https://root.cern,https://root.cern/doc/master/classTDataSetManager.html,1,['monitor'],['monitoring']
Energy Efficiency," const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions; void CalculatePrincipalComponents (const std::vector< Event * > &);  calculate the principal components for the signal and the background data it uses the MakePrincipal method of ROOT's TPrincipal class ;  ; void P2X (std::vector< Float_t > &, const std::vector< Float_t > &, Int_t cls) const;  Perform the back-transformation from the principal components pc, and return x It's the users responsibility to make sure that both x and pc are of the right size (i.e., memory must be allocated for p) ;  ; void X2P (std::vector< Float_t > &, const std::vector< Float_t > &, Int_t cls) const;  Calculate the principal components from the original data vector x, and return it in p (function extracted from TPrincipal::X2P) It's the users responsibility to make sure that both x and p are of the right size (i.e., memory must be allocated for p) ;  . Private Attributes; std::vector< TMatrixD * > fEigenVectors;  eigenvectors ;  ; std::vector< TVectorD * > fMeanValues;  mean values ;  . Additional Inherited Members;  Public Types inherited from TMVA::VariableTransformBase; typedef VectorOfCharAndInt::iterator ItVarTypeIdx;  ; typedef VectorOfCharAndInt::const_iterator ItVarTypeIdxConst;  ; typedef std::vector< std::pair< Char_t, UInt_t > > VectorOfCharAndInt;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; en",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1VariablePCATransform.html:13019,allocate,allocated,13019,doc/master/classTMVA_1_1VariablePCATransform.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1VariablePCATransform.html,1,['allocate'],['allocated']
Energy Efficiency," const char* cutSpec = 0, const char* cutRange = 0) const; { return moment(var,1,0,cutSpec,cutRange) ; }. Double_t sigma(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return sqrt(moment(var,2,cutSpec,cutRange)) ; }. Double_t skewness(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,3,cutSpec,cutRange) ; }. Double_t kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,4,cutSpec,cutRange) ; }. Double_t covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kFALSE) ; }. Double_t correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kTRUE) ; }. TMatrixDSym* covarianceMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return covarianceMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return correlationMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* covarianceMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kFALSE) ; }. TMatrixDSym* correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kTRUE) ; }. RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0). RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE). » Last changed: Fri Dec 2 14:26:35 2011 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsData.html:38646,reduce,reduceEng,38646,root/html532/RooAbsData.html,https://root.cern,https://root.cern/root/html532/RooAbsData.html,1,['reduce'],['reduceEng']
Energy Efficiency," const char* cutSpec = 0, const char* cutRange = 0) const; { return moment(var,1,0,cutSpec,cutRange) ; }. Double_t sigma(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return sqrt(moment(var,2,cutSpec,cutRange)) ; }. Double_t skewness(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,3,cutSpec,cutRange) ; }. Double_t kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,4,cutSpec,cutRange) ; }. Double_t covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kFALSE) ; }. Double_t correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kTRUE) ; }. TMatrixDSym* covarianceMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return covarianceMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return correlationMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* covarianceMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kFALSE) ; }. TMatrixDSym* correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kTRUE) ; }. RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0). RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE). » Last changed: Mon Dec 7 13:45:37 2009 » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsData.html:37311,reduce,reduceEng,37311,root/html526/RooAbsData.html,https://root.cern,https://root.cern/root/html526/RooAbsData.html,1,['reduce'],['reduceEng']
Energy Efficiency," const char* cutSpec = 0, const char* cutRange = 0) const; { return moment(var,1,0,cutSpec,cutRange) ; }. Double_t sigma(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return sqrt(moment(var,2,cutSpec,cutRange)) ; }. Double_t skewness(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,3,cutSpec,cutRange) ; }. Double_t kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,4,cutSpec,cutRange) ; }. Double_t covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kFALSE) ; }. Double_t correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kTRUE) ; }. TMatrixDSym* covarianceMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return covarianceMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return correlationMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* covarianceMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kFALSE) ; }. TMatrixDSym* correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kTRUE) ; }. RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0). RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE). » Last changed: Mon Jul 4 15:21:21 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsData.html:38121,reduce,reduceEng,38121,root/html530/RooAbsData.html,https://root.cern,https://root.cern/root/html530/RooAbsData.html,1,['reduce'],['reduceEng']
Energy Efficiency," const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual voidUseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tWrite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tWrite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidAddClone(TTree*); virtual TBranch*BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tCheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual TLeaf*GetLeafImpl(const char* branchname, const char* leafname); charGetNewlineValue(istream& inputStream); voidImportClusterRanges(TTree* fromtree); virtual voidKeepCircular(); voidTObject::MakeZombie(); Int_tSetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr). private:. TTree(const TTree& tt); TTree&operator=(const TTree& tt). Data Members; public:. enum ELockStatusBits { kFindBranch; kFindLeaf; kGetAlias; kGetBranch; kGetEntry; kGetEntryWithIndex; kGetFriend; kGetFriendAlias; kGetLeaf; kLoadTree; kPrint; kRemoveFriend; kSetBranchStatus; };; enum SetBranchAddressStatus { kMissingBranch; kInternalError; kMissingCompiledCollectionProxy; kMismatch; kClassMismatch; kM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:29654,charGe,charGetNewlineValue,29654,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['charGe'],['charGetNewlineValue']
Energy Efficiency," const. overridevirtual . check if this PDF is a binned distribution in the given observable ; Reimplemented from RooAbsReal.; Definition at line 2922 of file RooLagrangianMorphFunc.cxx. ◆ isCouplingUsed(). bool RooLagrangianMorphFunc::isCouplingUsed ; (; const char * ; couplname). check if there is any morphing power provided for the given coupling morphing power is provided as soon as any two samples provide different, non-zero values for this coupling ; Definition at line 2634 of file RooLagrangianMorphFunc.cxx. ◆ isParameterConstant(). bool RooLagrangianMorphFunc::isParameterConstant ; (; const char * ; paramname); const. return true if the parameter with the given name is set constant, false otherwise ; Definition at line 2412 of file RooLagrangianMorphFunc.cxx. ◆ isParameterUsed(). bool RooLagrangianMorphFunc::isParameterUsed ; (; const char * ; paramname); const. check if there is any morphing power provided for the given parameter morphing power is provided as soon as any two samples provide different, non-zero values for this parameter ; Definition at line 2613 of file RooLagrangianMorphFunc.cxx. ◆ makeRatio(). std::unique_ptr< RooRatio > RooLagrangianMorphFunc::makeRatio ; (; const char * ; name, . const char * ; title, . RooArgList & ; nr, . RooArgList & ; dr . ). static . Return the RooRatio form of products and denominators of morphing functions. ; Definition at line 3023 of file RooLagrangianMorphFunc.cxx. ◆ nParameters(). int RooLagrangianMorphFunc::nParameters ; (; ); const. return the number of parameters in this morphing function ; Definition at line 2660 of file RooLagrangianMorphFunc.cxx. ◆ nPolynomials(). int RooLagrangianMorphFunc::nPolynomials ; (; ); const. return the number of samples in this morphing function ; Definition at line 2668 of file RooLagrangianMorphFunc.cxx. ◆ nSamples(). int RooLagrangianMorphFunc::nSamples ; (; ); const. inline . Definition at line 228 of file RooLagrangianMorphFunc.h. ◆ plotSamplingHint(). std::list< double >",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLagrangianMorphFunc.html:86298,power,power,86298,doc/master/classRooLagrangianMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooLagrangianMorphFunc.html,2,['power'],['power']
Energy Efficiency, const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { return fCoordinates.Rho(); }. Scalar eta() const; { return fCoordinates.Eta(); }. Scalar pt() const; { return fCoordinates.Pt(); }. Scalar perp2() const; { return fCoordinates.Perp2(); }. Scalar mag2() const; { return fCoordinates.M2(); }. Scalar mag() const; { return fCoordinates.M(); }. Scalar mt() const; { return fCoordinates.Mt(); }. Scalar mt2() const; { return fCoordinates.Mt2(); }. Scalar energy() const; Methods requested by CMS ---. { return fCoordinates.E(); }. Scalar mass() const; { return fCoordinates.M(); }. Scalar mass2() const; { return fCoordinates.M2(); }. LorentzVector<CoordSystem>& SetE(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar a). Methods setting a Single-component; Work only if the component is one of which the vector is represented.; For example SetE will work for a PxPyPzE Vector but not for a PxPyPzM Vector. { fCoordinates.SetE (a); return *this; }. LorentzVector<CoordSystem>& SetEta(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar a); { fCoordinates.SetEta(a); return *this; }. LorentzVector<CoordSystem>& SetM(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar a); { fCoordinates.SetM (a); return *this; }. LorentzVector<CoordSystem>& SetPhi(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar a); { fCoordinates.SetPhi(a); return *this; }. LorentzVector<CoordSystem>& SetPt(ROOT::Math,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html:17543,energy,energy,17543,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,7,['energy'],['energy']
Energy Efficiency, const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { return fCoordinates.Rho(); }. Scalar eta() const; { return fCoordinates.Eta(); }. Scalar pt() const; { return fCoordinates.Pt(); }. Scalar perp2() const; { return fCoordinates.Perp2(); }. Scalar mag2() const; { return fCoordinates.M2(); }. Scalar mag() const; { return fCoordinates.M(); }. Scalar mt() const; { return fCoordinates.Mt(); }. Scalar mt2() const; { return fCoordinates.Mt2(); }. Scalar energy() const; Methods requested by CMS ---. { return fCoordinates.E(); }. Scalar mass() const; { return fCoordinates.M(); }. Scalar mass2() const; { return fCoordinates.M2(); }. LorentzVector<CoordSystem>& SetE(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar a). Methods setting a Single-component; Work only if the component is one of which the vector is represented.; For example SetE will work for a PxPyPzE Vector but not for a PxPyPzM Vector. { fCoordinates.SetE (a); return *this; }. LorentzVector<CoordSystem>& SetEta(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar a); { fCoordinates.SetEta(a); return *this; }. LorentzVector<CoordSystem>& SetM(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar a); { fCoordinates.SetM (a); return *this; }. LorentzVector<CoordSystem>& SetPhi(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar a); { fCoordinates.SetPhi(a); return *this; }. LorentzVector<CoordSystem>& SetPt(ROOT::Math::LorentzVector<,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html:19815,energy,energy,19815,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,15,['energy'],['energy']
Energy Efficiency, const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { return fCoordinates.Rho(); }. Scalar eta() const; { return fCoordinates.Eta(); }. Scalar pt() const; { return fCoordinates.Pt(); }. Scalar perp2() const; { return fCoordinates.Perp2(); }. Scalar mag2() const; { return fCoordinates.M2(); }. Scalar mag() const; { return fCoordinates.M(); }. Scalar mt() const; { return fCoordinates.Mt(); }. Scalar mt2() const; { return fCoordinates.Mt2(); }. Scalar energy() const; Methods requested by CMS ---. { return fCoordinates.E(); }. Scalar mass() const; { return fCoordinates.M(); }. Scalar mass2() const; { return fCoordinates.M2(); }. LorentzVector<CoordSystem>& SetE(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar a). Methods setting a Single-component; Work only if the component is one of which the vector is represented.; For example SetE will work for a PxPyPzE Vector but not for a PxPyPzM Vector. { fCoordinates.SetE (a); return *this; }. LorentzVector<CoordSystem>& SetEta(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar a); { fCoordinates.SetEta(a); return *this; }. LorentzVector<CoordSystem>& SetM(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar a); { fCoordinates.SetM (a); return *this; }. LorentzVector<CoordSystem>& SetPhi(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar a); { fCoordinates.SetPhi(a); return *this; }. LorentzVector<CoordSystem>& SetPt(ROOT::Math,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html:17543,energy,energy,17543,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,7,['energy'],['energy']
Energy Efficiency, const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { return fCoordinates.Rho(); }. Scalar eta() const; { return fCoordinates.Eta(); }. Scalar pt() const; { return fCoordinates.Pt(); }. Scalar perp2() const; { return fCoordinates.Perp2(); }. Scalar mag2() const; { return fCoordinates.M2(); }. Scalar mag() const; { return fCoordinates.M(); }. Scalar mt() const; { return fCoordinates.Mt(); }. Scalar mt2() const; { return fCoordinates.Mt2(); }. Scalar energy() const; Methods requested by CMS ---. { return fCoordinates.E(); }. Scalar mass() const; { return fCoordinates.M(); }. Scalar mass2() const; { return fCoordinates.M2(); }. LorentzVector<CoordSystem>& SetE(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar a). Methods setting a Single-component; Work only if the component is one of which the vector is represented.; For example SetE will work for a PxPyPzE Vector but not for a PxPyPzM Vector. { fCoordinates.SetE (a); return *this; }. LorentzVector<CoordSystem>& SetEta(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar a); { fCoordinates.SetEta(a); return *this; }. LorentzVector<CoordSystem>& SetM(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar a); { fCoordinates.SetM (a); return *this; }. LorentzVector<CoordSystem>& SetPhi(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar a); { fCoordinates.SetPhi(a); return *this; }. LorentzVector<CoordSystem>& SetPt(ROOT::Math::LorentzVector<,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html:19077,energy,energy,19077,root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,15,['energy'],['energy']
Energy Efficiency, const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { return fCoordinates.Rho(); }. Scalar eta() const; { return fCoordinates.Eta(); }. Scalar pt() const; { return fCoordinates.Pt(); }. Scalar perp2() const; { return fCoordinates.Perp2(); }. Scalar mag2() const; { return fCoordinates.M2(); }. Scalar mag() const; { return fCoordinates.M(); }. Scalar mt() const; { return fCoordinates.Mt(); }. Scalar mt2() const; { return fCoordinates.Mt2(); }. Scalar energy() const; Methods requested by CMS ---. { return fCoordinates.E(); }. Scalar mass() const; { return fCoordinates.M(); }. Scalar mass2() const; { return fCoordinates.M2(); }. LorentzVector<CoordSystem>& SetE(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar a). Methods setting a Single-component; Work only if the component is one of which the vector is represented.; For example SetE will work for a PxPyPzE Vector but not for a PxPyPzM Vector. { fCoordinates.SetE (a); return *this; }. LorentzVector<CoordSystem>& SetEta(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar a); { fCoordinates.SetEta(a); return *this; }. LorentzVector<CoordSystem>& SetM(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar a); { fCoordinates.SetM (a); return *this; }. LorentzVector<CoordSystem>& SetPhi(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar a); { fCoordinates.SetPhi(a); return *this; }. LorentzVector<CoordSystem>& SetPt(ROOT::Math::Lorent,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html:17257,energy,energy,17257,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,7,['energy'],['energy']
Energy Efficiency, const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { return fCoordinates.Rho(); }. Scalar eta() const; { return fCoordinates.Eta(); }. Scalar pt() const; { return fCoordinates.Pt(); }. Scalar perp2() const; { return fCoordinates.Perp2(); }. Scalar mag2() const; { return fCoordinates.M2(); }. Scalar mag() const; { return fCoordinates.M(); }. Scalar mt() const; { return fCoordinates.Mt(); }. Scalar mt2() const; { return fCoordinates.Mt2(); }. Scalar energy() const; Methods requested by CMS ---. { return fCoordinates.E(); }. Scalar mass() const; { return fCoordinates.M(); }. Scalar mass2() const; { return fCoordinates.M2(); }. LorentzVector<CoordSystem>& SetE(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar a). Methods setting a Single-component; Work only if the component is one of which the vector is represented.; For example SetE will work for a PxPyPzE Vector but not for a PxPyPzM Vector. { fCoordinates.SetE (a); return *this; }. LorentzVector<CoordSystem>& SetEta(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar a); { fCoordinates.SetEta(a); return *this; }. LorentzVector<CoordSystem>& SetM(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar a); { fCoordinates.SetM (a); return *this; }. LorentzVector<CoordSystem>& SetPhi(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar a); { fCoordinates.SetPhi(a); return *this; }. LorentzVector<CoordSystem>& SetPt(ROOT::Math::LorentzVector<ROOT::Ma,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html:20653,energy,energy,20653,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,15,['energy'],['energy']
Energy Efficiency, const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { return fCoordinates.Rho(); }. Scalar eta() const; { return fCoordinates.Eta(); }. Scalar pt() const; { return fCoordinates.Pt(); }. Scalar perp2() const; { return fCoordinates.Perp2(); }. Scalar mag2() const; { return fCoordinates.M2(); }. Scalar mag() const; { return fCoordinates.M(); }. Scalar mt() const; { return fCoordinates.Mt(); }. Scalar mt2() const; { return fCoordinates.Mt2(); }. Scalar energy() const; Methods requested by CMS ---. { return fCoordinates.E(); }. Scalar mass() const; { return fCoordinates.M(); }. Scalar mass2() const; { return fCoordinates.M2(); }. LorentzVector<CoordSystem>& SetE(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar a). Methods setting a Single-component; Work only if the component is one of which the vector is represented.; For example SetE will work for a PxPyPzE Vector but not for a PxPyPzM Vector. { fCoordinates.SetE (a); return *this; }. LorentzVector<CoordSystem>& SetEta(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar a); { fCoordinates.SetEta(a); return *this; }. LorentzVector<CoordSystem>& SetM(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar a); { fCoordinates.SetM (a); return *this; }. LorentzVector<CoordSystem>& SetPhi(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar a); { fCoordinates.SetPhi(a); return *this; }. LorentzVector<CoordSystem>& SetPt(ROOT::Math::Lorent,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html:17257,energy,energy,17257,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,7,['energy'],['energy']
Energy Efficiency, const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { return fCoordinates.Rho(); }. Scalar eta() const; { return fCoordinates.Eta(); }. Scalar pt() const; { return fCoordinates.Pt(); }. Scalar perp2() const; { return fCoordinates.Perp2(); }. Scalar mag2() const; { return fCoordinates.M2(); }. Scalar mag() const; { return fCoordinates.M(); }. Scalar mt() const; { return fCoordinates.Mt(); }. Scalar mt2() const; { return fCoordinates.Mt2(); }. Scalar energy() const; Methods requested by CMS ---. { return fCoordinates.E(); }. Scalar mass() const; { return fCoordinates.M(); }. Scalar mass2() const; { return fCoordinates.M2(); }. LorentzVector<CoordSystem>& SetE(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar a). Methods setting a Single-component; Work only if the component is one of which the vector is represented.; For example SetE will work for a PxPyPzE Vector but not for a PxPyPzM Vector. { fCoordinates.SetE (a); return *this; }. LorentzVector<CoordSystem>& SetEta(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar a); { fCoordinates.SetEta(a); return *this; }. LorentzVector<CoordSystem>& SetM(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar a); { fCoordinates.SetM (a); return *this; }. LorentzVector<CoordSystem>& SetPhi(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar a); { fCoordinates.SetPhi(a); return *this; }. LorentzVector<CoordSystem>& SetPt(ROOT::Math::LorentzVector<ROOT::Ma,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html:19047,energy,energy,19047,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,15,['energy'],['energy']
Energy Efficiency," const; virtual Bool_tCurrentBoundaryNormal(Double_t& x, Double_t& y, Double_t& z) const; virtual Int_tCurrentEvent() const; virtual Int_tCurrentMaterial(Float_t& a, Float_t& z, Float_t& dens, Float_t& radl, Float_t& absl) const; virtual Int_tCurrentMedium() const; virtual Int_tCurrentVolID(Int_t& copyNo) const; virtual const char*CurrentVolName() const; virtual Int_tCurrentVolOffID(Int_t off, Int_t& copyNo) const; virtual const char*CurrentVolOffName(Int_t off) const; virtual const char*CurrentVolPath(); virtual voidDefaultRange(); virtual Bool_tDefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); virtual voidDefineOpSurface(const char* name, EMCOpSurfaceModel model, EMCOpSurfaceType surfaceType, EMCOpSurfaceFinish surfaceFinish, Double_t sigmaAlpha); virtual Bool_tDefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime); virtual Bool_tDefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime, const TString& pType, Double_t width, Int_t iSpin, Int_t iParity, Int_t iConjugation, Int_t iIsospin, Int_t iIsospinZ, Int_t gParity, Int_t lepton, Int_t baryon, Bool_t stable, Bool_t shortlived = kFALSE, const TString& subType = """", Int_t antiEncoding = 0, Double_t magMoment = 0.0, Double_t excitation = 0.0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOneSpec(const char* name); virtual voidTObject::Dump() constMENU ; virtual Double_tEdep() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEtot() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Exec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMC.html:2376,charge,charge,2376,root/html528/TVirtualMC.html,https://root.cern,https://root.cern/root/html528/TVirtualMC.html,2,['charge'],['charge']
Energy Efficiency," const; virtual Bool_tTMVA::MethodBase::IsSignalLike(); virtual Bool_tTMVA::MethodBase::IsSignalLike(Double_t mvaVal); virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTMVA::MethodBase::MakeClass(const TString& classFileName = TString("""")) const; voidMakeClassInstantiateNode(TMVA::DecisionTreeNode* n, ostream& fout, const TString& className) const; virtual voidMakeClassSpecific(ostream&, const TString&) const; virtual voidMakeClassSpecificHeader(ostream&, const TString&) const; voidTObject::MayNotUse(const char* method) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; TMVA::MethodBDTMethodBDT(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodBDTMethodBDT(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::Pri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodBDT.html:12511,Monitor,MonitorBoost,12511,root/html532/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodBDT.html,1,['Monitor'],['MonitorBoost']
Energy Efficiency," constexpr Version_t RooEffProd::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 41 of file RooEffProd.h. ◆ clone(). TObject * RooEffProd::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 26 of file RooEffProd.h. ◆ DeclFileName(). static const char * RooEffProd::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 41 of file RooEffProd.h. ◆ evaluate(). double RooEffProd::evaluate ; (; ); const. overrideprotectedvirtual . Calculate and return 'raw' unnormalized value of p.d.f. ; Implements RooAbsReal.; Definition at line 56 of file RooEffProd.cxx. ◆ genContext(). RooAbsGenContext * RooEffProd::genContext ; (; const RooArgSet & ; vars, . const RooDataSet * ; prototype, . const RooArgSet * ; auxProto, . bool ; verbose . ); const. overridevirtual . Return specialized generator context for RooEffProds that implements generation in a more efficient way than can be done for generic correlated products. ; Reimplemented from RooAbsPdf.; Definition at line 66 of file RooEffProd.cxx. ◆ IsA(). TClass * RooEffProd::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 41 of file RooEffProd.h. ◆ Streamer(). void RooEffProd::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooEffProd::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 41 of file RooEffProd.h. ◆ translate(). void RooEffProd::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overrideprotectedvirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concaten",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooEffProd.html:75641,efficient,efficient,75641,doc/master/classRooEffProd.html,https://root.cern,https://root.cern/doc/master/classRooEffProd.html,1,['efficient'],['efficient']
Energy Efficiency," constructor. TEmulatedCollectionProxy(const TEmulatedCollectionProxy& copy); Copy constructor. TEmulatedCollectionProxy(const char* cl_name, Bool_t silent); Initializing constructor. virtual ~TEmulatedCollectionProxy(); Standard destructor. void* New() const; Virtual constructor. { return new Cont_t; }. void* New(void* memory) const; Virtual in-place constructor. { return new(memory) Cont_t; }. void* NewArray(Int_t nElements) const; Virtual array constructor. { return new Cont_t[nElements]; }. void* NewArray(Int_t nElements, void* memory) const; Virtual in-place constructor. { return new(memory) Cont_t[nElements]; }. void Destructor(void* p, Bool_t dtorOnly = kFALSE); Virtual destructor. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE); Virtual array destructor. UInt_t Sizeof() const; TVirtualCollectionProxy overload: Return the sizeof the collection object. { return sizeof(Cont_t); }. void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. void Resize(UInt_t n, Bool_t force_delete); Resize the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete); Block allocation of containees. void Commit(void* env); Block commit of containees. void ReadBuffer(TBuffer& buff, void* pObj); Read portion of the streamer. void ReadBuffer(TBuffer& buff, void* pObj, const TClass* onfile). void Streamer(TBuffer& refBuffer); Streamer for I/O handling. void Streamer(TBuffer& buff, void* pObj, int siz); Streamer I/O overload. Bool_t IsValid() const; Check validity of the proxy itself. » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TEmulatedCollectionProxy.h 41102 2011-10-03 21:42:02Z pcanal $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEmulatedCollectionProxy.html:8655,Allocate,Allocate,8655,root/html532/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html532/TEmulatedCollectionProxy.html,1,['Allocate'],['Allocate']
Energy Efficiency," control compilation; and installation of the library. Activities other than copying, distribution and modification are not; covered by this License; they are outside its scope. The act of; running a program using the Library is not restricted, and output from; such a program is covered only if its contents constitute a work based; on the Library (independent of the use of the Library in a tool for; writing it). Whether that is true depends on what the Library does; and what the program that uses the Library does. 1. You may copy and distribute verbatim copies of the Library's; complete source code as you receive it, in any medium, provided that; you conspicuously and appropriately publish on each copy an; appropriate copyright notice and disclaimer of warranty; keep intact; all the notices that refer to this License and to the absence of any; warranty; and distribute a copy of this License along with the; Library. You may charge a fee for the physical act of transferring a copy,; and you may at your option offer warranty protection in exchange for a; fee.; ; 2. You may modify your copy or copies of the Library or any portion; of it, thus forming a work based on the Library, and copy and; distribute such modifications or work under the terms of Section 1; above, provided that you also meet all of these conditions:. a) The modified work must itself be a software library. b) You must cause the files modified to carry prominent notices; stating that you changed the files and the date of any change. c) You must cause the whole of the work to be licensed at no; charge to all third parties under the terms of this License. d) If a facility in the modified Library refers to a function or a; table of data to be supplied by an application program that uses; the facility, other than as an argument passed when the facility; is invoked, then you must make a good faith effort to ensure that,; in the event an application does not supply such function or; table, the facility still",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/license.html:10603,charge,charge,10603,d/license.html,https://root.cern,https://root.cern/d/license.html,1,['charge'],['charge']
Energy Efficiency," cosh(x); }. Double_t TanH(Double_t x); { return tanh(x); }. Double_t ASin(Double_t x). Double_t ACos(Double_t x). Double_t ATan(Double_t x); { return atan(x); }. Double_t ATan2(Double_t y, Double_t x). Double_t Sqrt(Double_t x); { return sqrt(x); }. Double_t Ceil(Double_t x); { return ceil(x); }. Int_t CeilNint(Double_t x); { return TMath::Nint(ceil(x)); }. Double_t Floor(Double_t x); { return floor(x); }. Int_t FloorNint(Double_t x); { return TMath::Nint(floor(x)); }. Int_t Nint(T x); Round to nearest integer. Rounds half integers to the nearest; even integer. Double_t Exp(Double_t x); { return exp(x); }. Double_t Ldexp(Double_t x, Int_t exp); { return ldexp(x, exp); }. LongDouble_t Power(LongDouble_t x, LongDouble_t y); { return std::pow(x,y); }. LongDouble_t Power(LongDouble_t x, Long64_t y); { return std::pow(x,(LongDouble_t)y); }. LongDouble_t Power(Long64_t x, Long64_t y); { return std::pow(x,y); }. Double_t Power(Double_t x, Double_t y); { return pow(x, y); }. Double_t Power(Double_t x, Int_t y). Double_t Log(Double_t x); { return log(x); }. Double_t Log10(Double_t x); { return log10(x); }. Int_t Finite(Double_t x); { return isfinite(x); }. Int_t IsNaN(Double_t x); from math.h. { return ::isnan(x); }. Double_t QuietNaN(); --------wrapper to numeric_limits. Double_t SignalingNaN(). Double_t Infinity(); returns an infinity as defined by the IEEE standard. template <typename T> inline T NormCross(const T v1[3],const T v2[3],T out[3]); Calculate the Normalized Cross Product of two vectors. T MinElement(Long64_t n, const T *a); Return minimum of array a of length n. T MaxElement(Long64_t n, const T *a); Return maximum of array a of length n. Long64_t LocMin(Long64_t n, const T *a); Return index of array with the minimum element.; If more than one element is minimum returns first found. Iterator LocMin(Iterator first, Iterator last); Return index of array with the minimum element.; If more than one element is minimum returns first found. Long64_t LocMax(Long64_t n,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMath.html:39260,Power,Power,39260,root/html534/TMath.html,https://root.cern,https://root.cern/root/html534/TMath.html,1,['Power'],['Power']
Energy Efficiency," current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static Long64_t BinarySearch (Long64_t n, const TGeoBranchArray **array, TGeoBranchArray *value);  Binary search in an array of n pointers to branch arrays, to locate value. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TGeoBranchArray * MakeCopy (const TGeoBranchArray &other);  Make a copy of a branch array at the location (if indicated) ;  ; static TGeoBranchArray * MakeCopyAt (const TGeoBranchArray &other, void *addr);  Make a copy of a branch array at the location (if indicated) ;  ; static TGeoBranchArray * MakeInstance (size_t maxlevel);  Make an instance of the class which allocates the node array. ;  ; static TGeoBranchArray * MakeInstanceAt (size_t maxlevel, void *addr);  Make an instance of the class which allocates the node array. ;  ; static void ReleaseInstance (TGeoBranchArray *obj);  Releases the space allocated for the object. ;  ; static size_t SizeOf (size_t maxlevel);  ; static size_t SizeOfInstance (size_t maxlevel);  ; static void Sort (Int_t n, TGeoBranchArray **array, Int_t *index, Bool_t down=kTRUE);  Sorting of an array of branch array pointers. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBranchArray.html:12220,allocate,allocates,12220,doc/master/classTGeoBranchArray.html,https://root.cern,https://root.cern/doc/master/classTGeoBranchArray.html,1,['allocate'],['allocates']
Energy Efficiency," cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binni",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsData.html:16666,reduce,reduce,16666,root/html526/RooAbsData.html,https://root.cern,https://root.cern/root/html526/RooAbsData.html,1,['reduce'],['reduce']
Energy Efficiency," cutRange = 0) const; { return moment(var,1,0,cutSpec,cutRange) ; }. Double_t sigma(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return sqrt(moment(var,2,cutSpec,cutRange)) ; }. Double_t skewness(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,3,cutSpec,cutRange) ; }. Double_t kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,4,cutSpec,cutRange) ; }. Double_t covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kFALSE) ; }. Double_t correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kTRUE) ; }. TMatrixDSym* covarianceMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return covarianceMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return correlationMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* covarianceMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kFALSE) ; }. TMatrixDSym* correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kTRUE) ; }. StorageType getDefaultStorageType(). RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0). RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE). » Last changed: Sat Sep 5 16:39:53 2015 » Last generated: 2015-09-05 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsData.html:38950,reduce,reduceEng,38950,root/html534/RooAbsData.html,https://root.cern,https://root.cern/root/html534/RooAbsData.html,2,['reduce'],['reduceEng']
Energy Efficiency," cutRange = 0) const; { return moment(var,1,0,cutSpec,cutRange) ; }. Double_t sigma(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return sqrt(moment(var,2,cutSpec,cutRange)) ; }. Double_t skewness(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,3,cutSpec,cutRange) ; }. Double_t kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,4,cutSpec,cutRange) ; }. Double_t covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kFALSE) ; }. Double_t correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kTRUE) ; }. TMatrixDSym* covarianceMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return covarianceMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return correlationMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* covarianceMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kFALSE) ; }. TMatrixDSym* correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kTRUE) ; }. StorageType getDefaultStorageType(). RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0). RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE). » Last changed: Sat Sep 5 17:28:32 2015 » Last generated: 2015-09-05 17:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsData.html:40724,reduce,reduceEng,40724,root/html604/RooAbsData.html,https://root.cern,https://root.cern/root/html604/RooAbsData.html,2,['reduce'],['reduceEng']
Energy Efficiency," data, such as objects or arrays in addition to all the simple types.; When using a TTree, we fill its branch buffers with leaf data and the buffers are written to disk when it is full. Branches, buffers, and leafs, are explained a little later in this chapter, but for now, it is important to realize that each object is not written individually, but rather collected and written a bunch at a time.; This is where the TTree takes advantage of compression and will produce a much smaller file than if the objects were written individually. Since the unit to be compressed is a buffer, and the TTree contains many same-class objects, the header of the objects can be compressed.; The TTree reduces the header of each object, but it still contains the class name. Using compression, the class name of each same-class object has a good chance of being compressed, since the compression algorithm recognizes the bit pattern representing the class name. Using a TTree and compression the header is reduced to about 4 bytes compared to the original 60 bytes. However, if compression is turned off, you will not see these large savings.; The TTree is also used to optimize the data access. A tree uses a hierarchy of branches, and each branch can be read independently from any other branch. Now, assume that Px and Py are data members of the event, and we would like to compute Px2 + Py2 for every event and histogram the result.; If we had saved the million events without a TTree we would have to:. read each event in its entirety into memory; extract the Px and Py from the event; compute the sum of the squares; fill a histogram. We would have to do that a million times! This is very time consuming, and we really do not need to read the entire event, every time. All we need are two little data members (Px and Py). On the other hand, if we use a tree with one branch containing Px and another branch containing Py, we can read all values of Px and Py by only reading the Px and Py branches. This mak",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:520833,reduce,reduced,520833,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['reduce'],['reduced']
Energy Efficiency," default since ROOT 6.34 and it can't be disabled anymore in 6.36. ; Member RooStats::MarkovChain::GetAsDataHist (const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const R__DEPRECATED(6; Will be removed in ROOT 6.36. Please implement this functionality by calling RooAbsData::reduce on the Markov Chain's RooDataSet* (obtained using MarkovChain::GetAsConstDataSet), and then obtaining its binned clone. ; Will be removed in ROOT 6.36. . Member RooStats::MarkovChain::GetAsDataSet (const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const R__DEPRECATED(6; Will be removed in ROOT 6.36. ; Will be removed in ROOT 6.36. Please implement this functionality by calling RooAbsData::reduce on the Markov Chain's RooDataSet* (obtained using MarkovChain::GetAsConstDataSet) . Member RooTemplateProxy< T >::lvptr (const LValue_t *) const; This function is unnecessary if the template parameter is RooAbsRealLValue (+ derived types) or RooAbsCategoryLValue (+derived types), as arg() will always return the correct type. ; Member RooTemplateProxy< T >::R__DEPRECATED (6, 36, ""Use RooTemplateProxy(const char*, const char*, RooAbsArg*, bool, bool) and transfer the ownership with RooTemplateProxy::putOwnedArg()."") RooTemplateProxy(const char *theName; Kept for backwards compatibility and will be removed in ROOT 6.36. Either use RooTemplateProxy(const char*, const char*, RooAbsArg*, bool, bool), and transfer the ownership with RooTemplateProxy::putOwnedArg(), or use RooTemplateProxy(const char*, const char*, RooAbsArg*, std::unique_ptr<T>, bool, bool) if you want the proxy to own the argument. depending if you want to transfer ownership or not. ; Member TFitter::Chisquare (Int_t npar, Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/deprecated.html:5304,reduce,reduce,5304,doc/master/deprecated.html,https://root.cern,https://root.cern/doc/master/deprecated.html,1,['reduce'],['reduce']
Energy Efficiency," dimSet) const; voidcheckBinBounds() const; Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidimportDHistSet(const RooArgList& vars, RooCategory& indexCat, map<string,RooDataHist*> dmap, Double_t initWgt); voidimportTH1(const RooArgList& vars, TH1& histo, Double_t initWgt, Bool_t doDensityCorrection); voidimportTH1Set(const RooArgList& vars, RooCategory& indexCat, map<string,TH1*> hmap, Double_t initWgt, Bool_t doDensityCorrection); voidinitialize(const char* binningName = 0, Bool_t fillTree = kTRUE); Double_tinterpolateDim(RooRealVar& dim, const RooAbsBinning* binning, Double_t xval, Int_t intOrder, Bool_t correctForBinSize, Bool_t cdfBoundaries); voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); voidRooDirItem::removeFromDir(TObject* obj); virtual voidRooAbsData::resetCache(); RooDataHist(const char* name, const char* title, RooDataHist* h, const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t copyCache); voidsetAllWeights(Double_t value); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataHist.html:16598,reduce,reduceEng,16598,root/html602/RooDataHist.html,https://root.cern,https://root.cern/root/html602/RooDataHist.html,4,['reduce'],['reduceEng']
Energy Efficiency," dimension. The tutorial sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins"" starting with a TH3 with 30 bins per dimension. Using a THnSparse for a one-dimensional histogram is only reasonable if it has a huge number of bins. Projections; The dimensionality of a THnSparse can be reduced by projecting it to 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or a THnSparse. See the Projection() members. To only project parts of the histogram, call THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);; ; Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and its bin content. The coordinates are compacted to use as few bits as possible; e.g. a histogram with 10 bins in x and 20 bins in y will only use 4 bits for the x representation and 5 bits for the y representation. This is handled by the internal class THnSparseCompactBinCoord. Bin data (content and coordinates) are allocated in chunks of size fChunkSize; this parameter can be set when constructing a THnSparse. Each chunk is represented by an object of class THnSparseArrayChunk.; Translation from an n-dimensional bin coordinate to the linear index within the chunks is done by GetBin(). It creates a hash from the compacted bin coordinates (the hash of a bin coordinate is the compacted coordinate itself if it takes less than 8 bytes, the size of a Long64_t. This hash is used to lookup the linear index in the TExMap member fBins; the coordinates of the entry fBins points to is compared to the coordinates passed to GetBin(). If they do not match, these two coordinates have the same hash - which is extremely unlikely but (for the case where the compact bin coordinates are larger than 4 bytes) possible. In this case, fBinsContinued contains a chain of linear indexes with the same hash. Iterating through this chain and comparing each bin coordinates with the one passed to GetBin() will retrieve the matching bin. ; Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparse.html:3803,allocate,allocated,3803,doc/master/classTHnSparse.html,https://root.cern,https://root.cern/doc/master/classTHnSparse.html,1,['allocate'],['allocated']
Energy Efficiency," do not exist are silently ignored. TString DetermineClass(const char* varName); [static utility function]. returns empty string on failure.; otherwise returns something like this: ""TROOT*"".; fails for non-class types (ie, int, char, etc).; fails for pointers to functions. Bool_t ExcludedByFignore(TString s); [static utility function]. returns true iff ""s"" ends with one of; the strings listed in the ""TabCom.FileIgnore"" resource. TString GetSysIncludePath(); [static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char* fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char* path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char* dest, const char* localName, const char* appendage = 0, const char* fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char* defaultPath) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTabCom.html:10448,allocate,allocated,10448,root/html528/TTabCom.html,https://root.cern,https://root.cern/root/html528/TTabCom.html,1,['allocate'],['allocated']
Energy Efficiency," do not exist are silently ignored. TString DetermineClass(const char* varName); [static utility function]. returns empty string on failure.; otherwise returns something like this: ""TROOT*"".; fails for non-class types (ie, int, char, etc).; fails for pointers to functions. Bool_t ExcludedByFignore(TString s); [static utility function]. returns true iff ""s"" ends with one of; the strings listed in the ""TabCom.FileIgnore"" resource. TString GetSysIncludePath(); [static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char* fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char* path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char* dest, const char* localName, const char* appendage = 0, const char* fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char* de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTabCom.html:10476,allocate,allocated,10476,root/html530/TTabCom.html,https://root.cern,https://root.cern/root/html530/TTabCom.html,5,['allocate'],['allocated']
Energy Efficiency," do not have a branch count and are not a counter. void ReadLeavesMemberBranchCount(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do have a branch count and are not a counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); -- Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranchElement.html:26832,allocate,allocated,26832,root/html528/TBranchElement.html,https://root.cern,https://root.cern/root/html528/TBranchElement.html,2,['allocate'],['allocated']
Energy Efficiency," double ROOT::Math::Interpolator::Integ ; (; double ; a, . double ; b . ); const. Return the Integral of the interpolated function over the range [a,b]. ; Definition at line 92 of file Interpolator.cxx. ◆ operator=() [1/2]. Interpolator & ROOT::Math::Interpolator::operator= ; (; const Interpolator & ; ). delete . ◆ operator=() [2/2]. Interpolator & ROOT::Math::Interpolator::operator= ; (; Interpolator && ; ). delete . ◆ SetData() [1/2]. bool ROOT::Math::Interpolator::SetData ; (; const std::vector< double > & ; x, . const std::vector< double > & ; y . ). Set the data vector ( x[] and y[] ) To be efficient, the size of the data must be the same of the value used in the constructor (ndata) If this is not the case a new re-initialization is performed with the new data size. ; Definition at line 68 of file Interpolator.cxx. ◆ SetData() [2/2]. bool ROOT::Math::Interpolator::SetData ; (; unsigned int ; ndata, . const double * ; x, . const double * ; y . ). Set the data vector ( x[] and y[] ) To be efficient, the size of the data must be the same of the value used when constructing the class (ndata) If this is not the case a new re-initialization is performed with the new data size. ; Definition at line 64 of file Interpolator.cxx. ◆ Type(). std::string ROOT::Math::Interpolator::Type ; (; ); const. Return the type of interpolation method. ; Definition at line 101 of file Interpolator.cxx. ◆ TypeGet(). std::string ROOT::Math::Interpolator::TypeGet ; (; ); const. Definition at line 97 of file Interpolator.cxx. Member Data Documentation. ◆ fInterp. GSLInterpolator* ROOT::Math::Interpolator::fInterp. private . Definition at line 138 of file Interpolator.h. Libraries for ROOT::Math::Interpolator:. [legend]; The documentation for this class was generated from the following files:; math/mathmore/inc/Math/Interpolator.h; math/mathmore/src/Interpolator.cxx. ROOTMathInterpolator. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Interpolator.html:5806,efficient,efficient,5806,doc/master/classROOT_1_1Math_1_1Interpolator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Interpolator.html,1,['efficient'],['efficient']
Energy Efficiency," double ; wgt = 1.0 . ). Add all data points contained in 'dset' to this data set with given weight. ; Optional cut string expression selects the data points to be added and can reference any variable contained in this data set ; Definition at line 1802 of file RooDataHist.cxx. ◆ add() [2/4]. void RooDataHist::add ; (; const RooAbsData & ; dset, . const RooFormulaVar * ; cutVar = nullptr, . double ; wgt = 1.0 . ). Add all data points contained in 'dset' to this data set with given weight. ; Optional RooFormulaVar pointer selects the data points to be added. ; Definition at line 1814 of file RooDataHist.cxx. ◆ add() [3/4]. void RooDataHist::add ; (; const RooArgSet & ; row, . double ; wgt, . double ; sumw2 . ). Increment the bin content of the bin enclosing the given coordinates. ; Parameters. [in]rowCoordinates of the bin. ; [in]wgtIncrement by this weight. ; [in]sumw2Optionally, track the sum of squared weights. If a value > 0 or a weight != 1. is passed for the first time, a vector for the squared weights will be allocated. . Definition at line 1704 of file RooDataHist.cxx. ◆ add() [4/4]. void RooDataHist::add ; (; const RooArgSet & ; row, . double ; wgt = 1.0 . ). inlineoverridevirtual . Add wgt to the bin content enclosed by the coordinates passed in row. ; Implements RooAbsData.; Definition at line 72 of file RooDataHist.h. ◆ adjustBinning(). void RooDataHist::adjustBinning ; (; const RooArgList & ; vars, . const TH1 & ; href, . Int_t * ; offset = nullptr . ). protected . Adjust binning specification on first and optionally second and third observable to binning in given reference TH1. ; Used by constructors that import data from an external TH1. Both the variables in vars and in this RooDataHist are adjusted. Parameters. varsList with variables that are supposed to have their binning adjusted. ; hrefReference histogram that dictates the binning ; offsetIf not nullptr, a possible bin count offset for the axes x,y,z is saved here as Int_t[3] . Definition at line",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:52354,allocate,allocated,52354,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['allocate'],['allocated']
Energy Efficiency," drawing area; TRootContextMenu ROOT native GUI context sensitive popup menu; TRootControlBar ROOT native GUI implementation of TControlBar; TRootDialog Native GUI method argument prompt dialog box; TRootEmbeddedCanvas A ROOT TCanvas that can be embedded in a TGFrame; TRootGuiBuilder ROOT GUI Builder; TRootGuiFactory Factory for ROOT GUI components; TRootHelpDialog Dialog to display help text; TRootIOCtor ; TRootSecContext Class providing host specific authentication information; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TRuby Ruby/ROOT interface; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLClassColumnInfo Keeps information about single column in class table; TSQLClassInfo Keeps the table information relevant for one class ; TSQLColumnData Single SQL column data.; TSQLColumnInfo Summury information about column from SQL table; TSQLFile ROOT TFile interface to SQL database; TSQLMonitoringWriter Sending monitoring data to a SQL DB; TSQLObjectData Keeps the data requested from the SQL server for an object.; TSQLObjectDataPool XML object keeper class ; TSQLObjectInfo Info (classname, version) about object in database ; TSQLResult SQL query result; TSQLRow One row of an SQL query result; TSQLServer Connection to SQL server; TSQLStatement SQL statement; TSQLStructure Table/structure description used internally by YBufferSQL.; TSQLTableData Collection of columns data for single SQL table; TSQLTableInfo Summury information about SQL table; TSSLSocket SSL wrapped socket; TSVDUnfold Data unfolding using Singular Value Decomposition (hep-ph/9509307) ; TSVG SVG driver; TSecContext Class providing host specific authentication information; TSecContextCleanup Update the remote authentication table; TSelector A utility class for tree and object processing; TSelectorCint A utility class for tree and object processing (interpreted version); TSelectorDraw A specialized TSelector for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:125425,monitor,monitoring,125425,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,1,['monitor'],['monitoring']
Energy Efficiency," end);  Creates a node that filters entries based on range. ;  ; template<typename F , std::enable_if_t<!std::is_convertible< F, std::string >::value, int > = 0> ; RInterface< Proxied, DS_t > Redefine (std::string_view name, F expression, const ColumnNames_t &columns={});  Overwrite the value and/or type of an existing column. ;  ; RInterface< Proxied, DS_t > Redefine (std::string_view name, std::string_view expression);  Overwrite the value and/or type of an existing column. ;  ; template<typename F > ; RInterface< Proxied, DS_t > RedefineSlot (std::string_view name, F expression, const ColumnNames_t &columns={});  Overwrite the value and/or type of an existing column. ;  ; template<typename F > ; RInterface< Proxied, DS_t > RedefineSlotEntry (std::string_view name, F expression, const ColumnNames_t &columns={});  Overwrite the value and/or type of an existing column. ;  ; template<typename F , typename T = typename TTraits::CallableTraits<F>::ret_type> ; RResultPtr< T > Reduce (F f, std::string_view columnName, const T &redIdentity);  Execute a user-defined reduce operation on the values of a column. ;  ; template<typename F , typename T = typename TTraits::CallableTraits<F>::ret_type> ; RResultPtr< T > Reduce (F f, std::string_view columnName="""");  Execute a user-defined reduce operation on the values of a column. ;  ; RResultPtr< RCutFlowReport > Report ();  Gather filtering statistics. ;  ; template<typename... ColumnTypes> ; RResultPtr< RInterface< RLoopManager > > Snapshot (std::string_view treename, std::string_view filename, const ColumnNames_t &columnList, const RSnapshotOptions &options=RSnapshotOptions());  Save selected columns to disk, in a new TTree treename in file filename. ;  ; RResultPtr< RInterface< RLoopManager > > Snapshot (std::string_view treename, std::string_view filename, const ColumnNames_t &columnList, const RSnapshotOptions &options=RSnapshotOptions());  Save selected columns to disk, in a new TTree treename in file filename. ;  ; RResu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:15536,reduce,reduce,15536,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['reduce'],['reduce']
Energy Efficiency," events that have been replayed; TMutex*fMutex; TRecEvent*fNextEventThe next event that is going to be replayed (GUI event or commandline); TTimefPreviousEventTimeExecution time of the previously replayed event.; TRecorder*fRecorderReference to recorder (owner of this state) is kept in order to switch; Int_tfRegWinCounterCounter of registered windows when replaying; Bool_tfShowMouseCursorSpecifies if mouse cursor should be also replayed; TTimer*fTimerTimer used for replaying; Bool_tfWaitingForWindowSignalizes that we wait for a window to be registered in order; ULong64_tfWinWindow ID being currenty mapped; TTree*fWinTreeTTree with recorded windows (=registered during recording); Int_tfWinTreeEntriesNumber of registered windows during _recording_; TList*fWindowListList of TRecWinPair objects. Mapping of window IDs is stored here. Class Charts. Inheritance Chart:. TRecorderState. ←; TRecorderReplaying. Function documentation; TRecorderReplaying(const char* filename); Allocates all necessary data structures used for replaying; What is allocated here is deleted in destructor. ~TRecorderReplaying(); Closes all signal-slot connections; Frees all memory allocated in contructor. Bool_t Initialize(TRecorder* r, Bool_t showMouseCursor, TRecorder::EReplayModes mode); Initialization of data structures for replaying.; Start of replaying. Return value:; - kTRUE = everything is OK and replaying has begun; - kFALSE = non existing or invalid log file, replaying has not started. void RegisterWindow(Window_t w); Creates mapping for the newly registered window w and adds this; mapping to fWindowList. Called by signal whenever a new window is registered during replaying. The new window ID is mapped to the old one with the same number in the; list of registered windows.; It means that 1st new window is mapped to the 1st original,; 2nd to the 2nd, Nth new to the Nth original. Bool_t RemapWindowReferences(); All references to the old windows (IDs) in fNextEvent are replaced by; new ones acc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecorderReplaying.html:3672,allocate,allocated,3672,root/html602/TRecorderReplaying.html,https://root.cern,https://root.cern/root/html602/TRecorderReplaying.html,6,"['Allocate', 'allocate']","['Allocates', 'allocated']"
Energy Efficiency," events:; fill histograms and smooth them; if decorrelation is required, compute; corresponding square-root matrices; the reference histograms require the correct boundaries. Since in Likelihood classification; the transformations are applied using both classes, also the corresponding boundaries; need to take this into account. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the likelihood estimator for signal; fill a new Likelihood branch into the testTree. Double_t TransformLikelihoodOutput(Double_t ps, Double_t pb) const; returns transformed or non-transformed output. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to stream. void AddWeightsXMLTo(void* parent) const; write weights to XML. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void WriteWeightsToStream(TFile& rf) const; write reference PDFs to ROOT file. void ReadWeightsFromXML(void* wghtnode); read weights from XML. void ReadWeightsFromStream(istream& istr); read weight info from file; nothing to do for this method. void ReadWeightsFromStream(TFile& istr); read reference PDF from ROOT file. void WriteMonitoringHistosToFile( void ); write histograms and PDFs to file for monitoring purposes. void MakeClassSpecificHeader(ostream& , const TString& = """") const; write specific header of the classifier (mostly include files). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Peter Speckmayer, Eckhard von Toerne, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodLikelihood.html:22064,monitor,monitoring,22064,root/html534/TMVA__MethodLikelihood.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodLikelihood.html,2,['monitor'],['monitoring']
Energy Efficiency," every call of TRandom3::Rndm (when generating a random number). Before the function was returning the first element of the state, which was changing only after 624 calls to Rndm().; Fix a bug in ROOT::Fit::BinData copy constructor; Fix a bug in applying a correction factor used for the computation of the fit confidence level in ROOT::Fit::FitResult.; TMatrix: optimize implementation of TPrincipal::AddRow that is heavily used by CMS. Minuit2. Add a new improved message logging system. Debug message now can be enabled in Minuit2 when using maximum print level.; When using external provided gradient, compute in MnSeed still numerical gradients to obtain correct step sizes and initial estimate of covariance matrix. This allows to start with a good first state estimation, reducing significantly the number of subsequent iterations. TMVA. Introducing TMVA PyTorch Interface, a method to use PyTorch internally with TMVA for deep learning. This can be used as an alternative to PyKeras Interface for complex models providing more flexibility and power.; Add support in the TMVA Keras interface for Tensorflow.Keras (the version embedded in Tensorflow) and for standalone Keras versions up to it latest 2.3. For using Tensorflow.Keras one needs to use the booking option tf.keras=True.; Update the TMVA Keras tutorials to use now tensorflow.keras.; Deprecate the MethodDNN in favour of MethodDL supporting both CNN and RNN; Add possibility to customize all relevant minimizer parameters used for training in MethodDL; Add support in MethodDL for the Cudnn version 8 when using the Cuda implementation for CNN and RNN Minuit2; Implement the missing support for MethodCategory for multiclass classifiers.; Add possibility to retrieve a ROC curve made with the training dataset instead of the default test dataset. RooFit Libraries. Extension / updates of the doxygen reference guide.; Allow for removing RooPlot from global directory management, see RooPlot::AddDirectory and RooPlot::SetDirectory; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:15520,power,power,15520,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['power'],['power']
Energy Efficiency," external covariance matrix designed for the interaction of the user. The result of the minimization (internal covariance matrix) is converted into the user representable format. It can also be used as input prior to the minimization. The size of the covariance matrix is according to the number of variable parameters (free and limited).; 5.13.1 MnUserCovariance(const std::vector\(<\)double\(>\)&, unsigned int nrow); Construct from data, positions of the elements in the array are arranged according to the packed storage format. The size of the array must be \(nrow*(nrow+1)/2\). The array must contain the upper triangular part of the symmetric matrix packed sequentially, column by column, so that arr(0) contains covar(0,0), arr(1) and arr(2) contain covar(0,1) and covar(1,1) respectively, and so on. The number of rows (colums) has to be specified.; 5.13.2 MnUserCovariance(unsigned int nrow); Specify the number of rows (colums) at instantiation. It will allocate an array of the length \(nrow*(nrow+1)/2\) and inititalize it to \(0\). Elements can then be set using the method operator()(unsigned int, unsigned int).; 5.13.3 MnUserCovariance::operator()(unsigned int, unsigned int); Individual elements can be accessed via the operator(), both for reading and writing.; 5.14 MnUserParameters; [api:parameters] MnUserParameters is the main class for user interaction with the parameters. It serves both as input to the minimization as well as output as the result of the minimization is converted into the user representable format in order to allow for further interaction. Parameters for M can be added (defined) specifying a name, value and initial uncertainty.; 5.14.1 add(…); The method MnUserParameters::add(…) is overloaded for three kind of parameters:. add(const char*, double, double) for adding a free variable parameter; add(const char*, double, double, double, double) for adding a variable parameter with limits (lower and upper); add(const char*, double) for adding a constant",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:57874,allocate,allocate,57874,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['allocate'],['allocate']
Energy Efficiency," eyL2, eyH2);; 1826 if (fNYErrors > 2); 1827 SetPointEY(ipoint, 2, eyL3, eyH3);; 1828 gPad->Modified();; 1829}; 1830 ; 1831////////////////////////////////////////////////////////////////////////////////; 1832/// Set ex and ey values for point `i`.; 1833 ; 1834void TGraphMultiErrors::SetPointError(Int_t i, Int_t ne, Double_t exL, Double_t exH, const Double_t *eyL,; 1835 const Double_t *eyH); 1836{; 1837 SetPointEX(i, exL, exH);; 1838 SetPointEY(i, ne, eyL, eyH);; 1839}; 1840 ; 1841////////////////////////////////////////////////////////////////////////////////; 1842/// Set ex values for point `i`.; 1843 ; 1844void TGraphMultiErrors::SetPointEX(Int_t i, Double_t exL, Double_t exH); 1845{; 1846 SetPointEXlow(i, exL);; 1847 SetPointEXhigh(i, exH);; 1848}; 1849 ; 1850////////////////////////////////////////////////////////////////////////////////; 1851/// Set exL value for point `i`.; 1852 ; 1853void TGraphMultiErrors::SetPointEXlow(Int_t i, Double_t exL); 1854{; 1855 if (i < 0); 1856 return;; 1857 ; 1858 if (i >= fNpoints) {; 1859 // re-allocate the object; 1860 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1861 }; 1862 ; 1863 fExL[i] = exL;; 1864}; 1865 ; 1866////////////////////////////////////////////////////////////////////////////////; 1867/// Set exH value for point `i`.; 1868 ; 1869void TGraphMultiErrors::SetPointEXhigh(Int_t i, Double_t exH); 1870{; 1871 if (i < 0); 1872 return;; 1873 ; 1874 if (i >= fNpoints) {; 1875 // re-allocate the object; 1876 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1877 }; 1878 ; 1879 fExH[i] = exH;; 1880}; 1881 ; 1882////////////////////////////////////////////////////////////////////////////////; 1883/// Set ey values for point `i`.; 1884 ; 1885void TGraphMultiErrors::SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH); 1886{; 1887 SetPointEYlow(i, ne, eyL);; 1888 SetPointEYhigh(i, ne, eyH);; 1889}; 1890 ; 1891////////////////////////////////////////////////////////////////////////////////; 1892/// Set eyL values for poi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:63210,allocate,allocate,63210,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency," fNRows;}; 160 size_t GetNcols() const {return fNCols;}; 161 size_t GetNoElements() const {return fNRows * fNCols;}; 162 ; 163 const AFloat * GetDataPointer() const {return fElementBuffer.data();}; 164 AFloat * GetDataPointer() {return fElementBuffer.data();}; 165 const cublasHandle_t & GetCublasHandle() const {return fCublasHandle;}; 166 ; 167 inline TCudaDeviceBuffer<AFloat> GetDeviceBuffer() const { return fElementBuffer;}; 168 ; 169 /** Access to elements of device matrices provided through TCudaDeviceReference; 170 * class. Note that access is synchronous end enforces device synchronization; 171 * on all streams. Only used for testing. */; 172 TCudaDeviceReference<AFloat> operator()(size_t i, size_t j) const;; 173 ; 174 void Print() const {; 175 TMatrixT<AFloat> mat(*this);; 176 mat.Print();; 177 }; 178 ; 179 void Zero() {; 180 cudaMemset(GetDataPointer(), 0, sizeof(AFloat) * GetNoElements());; 181 }; 182 ; 183 ; 184private:; 185 ; 186 /** Initializes all shared devices resource and makes sure that a sufficient; 187 * number of curand states are allocated on the device and initialized as; 188 * well as that the one-vector for the summation over columns has the right; 189 * size. */; 190 void InitializeCuda();; 191 void InitializeCurandStates();; 192 ; 193};; 194 ; 195//; 196// Inline Functions.; 197//______________________________________________________________________________; 198inline void cudaError(cudaError_t code, const char *file, int line, bool abort); 199{; 200 if (code != cudaSuccess); 201 {; 202 fprintf(stderr,""CUDA Error: %s %s %d\n"", cudaGetErrorString(code), file, line);; 203 if (abort) exit(code);; 204 }; 205}; 206 ; 207//______________________________________________________________________________; 208template<typename AFloat>; 209TCudaDeviceReference<AFloat>::TCudaDeviceReference(AFloat * devicePointer); 210 : fDevicePointer(devicePointer); 211{; 212 // Nothing to do here.; 213}; 214 ; 215//_____________________________________________________",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/CudaMatrix_8h_source.html:7423,allocate,allocated,7423,doc/master/CudaMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/CudaMatrix_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency," fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<float>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); Set size of the matrix to nrows x ncols with nr_nonzeros non-zero entries; if nr_nonzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTSparse<Element> &TMatrixTSparse<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMatrixTSparse_float_.html:20569,allocate,allocated,20569,root/html530/TMatrixTSparse_float_.html,https://root.cern,https://root.cern/root/html530/TMatrixTSparse_float_.html,9,['allocate'],['allocated']
Energy Efficiency," fParentIDs to newsize for internel ProcessID index iid. ;  ; void ExpandPIDs (Int_t numpids);  Expand the arrays of managed PIDs. ;  ; Int_t FindPIDGUID (const char *guid) const;  Get fProcessGUIDs' index of the TProcessID with GUID guid. ;  ; Int_t GetInternalIdxForPID (Int_t pid) const;  Get the index for fProcessIDs, fAllocSize, etc given a PID. ;  ; Int_t GetInternalIdxForPID (TProcessID *procid) const;  Get the index for fProcessIDs, fAllocSize, etc given a PID. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Int_t * fAllocSize;  number of known ProcessIDs ;  ; Int_t fDefaultSize;  current parent ID in fParents (latest call to SetParent) ;  ; std::vector< Int_t > fMapPIDtoInternal;  ; Int_t * fN;  [fNumPIDs] allocated size of array fParentIDs for each ProcessID ;  ; Int_t fNumPIDs;  ; TObject * fOwner;  ; Int_t fParentID;  [fNumPIDs][fAllocSize] array of Parent IDs ;  ; Int_t ** fParentIDs;  [fNumPIDs] current maximum number of IDs in array fParentIDs for each ProcessID ;  ; TObjArray * fParents;  ; std::vector< std::string > fProcessGUIDs;  ; Int_t fSize;  TProcessID the current uid is referring to. ;  ; UInt_t fUID;  default size for a new PID array ;  ; TProcessID * fUIDContext;  Current uid (set by TRef::GetObject) ;  . Static Protected Attributes; static TRefTable * fgRefTable = nullptr;  cache of pid to index in fProcessGUIDs ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TRefTable.h>. Inheritance diagram for TRefTable:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EStatusBits. enum TRefTable::EStatusBits. EnumeratorkHaveWarnedReadingOld . Definition at line 62 of file TRefTable.h. Constructor & Des",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRefTable.html:13481,allocate,allocated,13481,doc/master/classTRefTable.html,https://root.cern,https://root.cern/doc/master/classTRefTable.html,1,['allocate'],['allocated']
Energy Efficiency," file PtEtaPhiE4D.h. Public Types; typedef ScalarType Scalar;  . Public Member Functions;  PtEtaPhiE4D ();  Default constructor gives zero 4-vector. ;  ; template<class CoordSystem > ; constexpr PtEtaPhiE4D (const CoordSystem &c);  Generic constructor from any 4D coordinate system implementing Pt(), Eta(), Phi() and E() ;  ;  PtEtaPhiE4D (const PtEtaPhiE4D &v);  copy constructor ;  ;  PtEtaPhiE4D (Scalar pt, Scalar eta, Scalar phi, Scalar e);  Constructor from pt, eta, phi, e values. ;  ; Scalar E () const;  ; Scalar Et () const;  transverse energy ;  ; Scalar Et2 () const;  transverse energy squared ;  ; Scalar Eta () const;  ; void GetCoordinates (Scalar &pt, Scalar &eta, Scalar &phi, Scalar &e) const;  get internal data into 4 Scalar numbers ;  ; void GetCoordinates (Scalar dest[]) const;  get internal data into an array of 4 Scalar numbers ;  ; Scalar M () const;  invariant mass ;  ; Scalar M2 () const;  vector magnitude squared (or mass squared) ;  ; Scalar Mag () const;  ; Scalar Mag2 () const;  ; Scalar Mt () const;  transverse mass ;  ; Scalar Mt2 () const;  transverse mass squared ;  ; void Negate ();  negate the 4-vector ;  ; bool operator!= (const PtEtaPhiE4D &rhs) const;  ; template<class CoordSystem > ; PtEtaPhiE4D & operator= (const CoordSystem &c);  Assignment from a generic coordinate system implementing Pt(), Eta(), Phi() and E() ;  ; PtEtaPhiE4D & operator= (const PtEtaPhiE4D &v);  assignment operator ;  ; bool operator== (const PtEtaPhiE4D &rhs) const;  Exact equality. ;  ; Scalar P () const;  magnitude of momentum ;  ; Scalar P2 () const;  squared magnitude of spatial components (momentum squared) ;  ; Scalar Perp () const;  ; Scalar Perp2 () const;  ; Scalar Phi () const;  ; Scalar Pt () const;  ; Scalar Pt2 () const;  transverse spatial component squared ;  ; Scalar Px () const;  ; Scalar Py () const;  ; Scalar Pz () const;  ; Scalar R () const;  ; Scalar Rho () const;  ; void Scale (Scalar a);  Scale coordinate values by a scalar quantity a. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1PtEtaPhiE4D.html:1314,energy,energy,1314,doc/master/classROOT_1_1Math_1_1PtEtaPhiE4D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1PtEtaPhiE4D.html,2,['energy'],['energy']
Energy Efficiency," file TGWin32.cxx. ◆ NextEvent(). void TGWin32::NextEvent ; (; Event_t & ; event). overridevirtual . Copies first pending event from event queue to Event_t structure and removes event from queue. ; Not all of the event fields are valid for each event type, except fType and fWindow. ; Reimplemented from TVirtualX.; Definition at line 5870 of file TGWin32.cxx. ◆ OpenDisplay(). Int_t TGWin32::OpenDisplay ; (; const char * ; dpyName = 0). overridevirtual . Open the display. Return -1 if the opening fails, 0 when ok. ; Reimplemented from TVirtualX.; Definition at line 971 of file TGWin32.cxx. ◆ OpenPixmap(). Int_t TGWin32::OpenPixmap ; (; UInt_t ; w, . UInt_t ; h . ). overridevirtual . Open a new pixmap. ; w,h : Width and height of the pixmap. ; Reimplemented from TVirtualX.; Definition at line 2099 of file TGWin32.cxx. ◆ ParseColor(). Bool_t TGWin32::ParseColor ; (; Colormap_t ; cmap, . const char * ; cname, . ColorStruct_t & ; color . ). overridevirtual . Parse string cname containing color name, like ""green"" or ""#00FF00"". ; It returns a filled in ColorStruct_t. Returns kFALSE in case parsing failed, kTRUE in case of success. On success, the ColorStruct_t fRed, fGreen and fBlue fields are all filled in and the mask is set for all three colors, but fPixel is not set. ; Reimplemented from TVirtualX.; Definition at line 5736 of file TGWin32.cxx. ◆ PointInRegion(). Bool_t TGWin32::PointInRegion ; (; Int_t ; x, . Int_t ; y, . Region_t ; reg . ). overridevirtual . Returns true if the point x,y is in the region. ; Reimplemented from TVirtualX.; Definition at line 7202 of file TGWin32.cxx. ◆ PolygonRegion(). Region_t TGWin32::PolygonRegion ; (; Point_t * ; points, . Int_t ; np, . Bool_t ; winding . ). overridevirtual . Create region for the polygon defined by the points array. ; If winding is true use WindingRule else EvenOddRule as fill rule. ; Reimplemented from TVirtualX.; Definition at line 7149 of file TGWin32.cxx. ◆ PutImage() [1/2]. void TGWin32::PutImage ; (; Drawable_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:93830,green,green,93830,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['green'],['green']
Energy Efficiency," file TTree.cxx. ◆ FlushBaskets(). Int_t TTree::FlushBaskets ; (; bool ; create_cluster = true); const. virtual . Write to disk all the basket that have not yet been individually written and create an event cluster boundary (by default). ; If the caller wishes to flush the baskets but not create an event cluster, then set create_cluster to false.; If ROOT has IMT-mode enabled, this will launch multiple TBB tasks in parallel via TThreadExecutor to do this operation; one per basket compression. If the caller utilizes TBB also, care must be taken to prevent deadlocks.; For example, let's say the caller holds mutex A and calls FlushBaskets; while TBB is waiting for the ROOT compression tasks to complete, it may decide to run another one of the user's tasks in this thread. If the second user task tries to acquire A, then a deadlock will occur. The example call sequence looks like this:. User acquires mutex A; User calls FlushBaskets.; ROOT launches N tasks and calls wait.; TBB schedules another user task, T2.; T2 tries to acquire mutex A. At this point, the thread will deadlock: the code may function with IMT-mode disabled if the user assumed the legacy code never would run their own TBB tasks.; SO: users of TBB who want to enable IMT-mode should carefully review their locking patterns and make sure they hold no coarse-grained application locks when they invoke ROOT.; Return the number of bytes written or -1 in case of write error. ; Definition at line 5129 of file TTree.cxx. ◆ FlushBasketsImpl(). Int_t TTree::FlushBasketsImpl ; (; ); const. private . Internal implementation of the FlushBaskets algorithm. ; Unlike the public interface, this does NOT create an explicit event cluster boundary; it is up to the (internal) caller to determine whether that should done.; Otherwise, the comments for FlushBaskets applies. ; Definition at line 5146 of file TTree.cxx. ◆ GetAlias(). const char * TTree::GetAlias ; (; const char * ; aliasName); const. virtual . Returns the expanded va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:143464,schedul,schedules,143464,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['schedul'],['schedules']
Energy Efficiency," file containg a Tree; static TTree::ELockStatusBitsTTree::kFindBranch; static TTree::ELockStatusBitsTTree::kFindLeaf; static TTree::ELockStatusBitsTTree::kGetAlias; static TTree::ELockStatusBitsTTree::kGetBranch; static TTree::ELockStatusBitsTTree::kGetEntry; static TTree::ELockStatusBitsTTree::kGetEntryWithIndex; static TTree::ELockStatusBitsTTree::kGetFriend; static TTree::ELockStatusBitsTTree::kGetFriendAlias; static TTree::ELockStatusBitsTTree::kGetLeaf; static TTree::ELockStatusBitsTTree::kLoadTree; static TTree::ELockStatusBitsTTree::kPrint; static TTree::ELockStatusBitsTTree::kRemoveFriend; static TTree::ELockStatusBitsTTree::kSetBranchStatus. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNtupleD(); Default constructor for Ntuple*-*-*-*-*-*-*-*-; *-* ==============================. TNtupleD(const char* name, const char* title, const char* varlist, Int_t bufsize = 32000); Create an Ntuple*-*-; *-* ================; The parameter varlist describes the list of the ntuple variables; separated by a colon:; example: ""x:y:z:energy""; For each variable in the list a separate branch is created. NOTE:; -Use TTree to create branches with variables of different data types.; -Use TTree when the number of branches is large (> 100).; -. ~TNtupleD(); Default destructor for an Ntuple*-*-*-*-*-*-; *-* ================================. void ResetBranchAddress(TBranch* ); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void ResetBranchAddresses(); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void Browse(TBrowser* b); Browse content. Int_t Fill(); -*-*Fill a Ntuple with current values in fArgs; *-* ==========================================; Note that this function is protected.; Currently called only by TChain::Merge. Int_t Fill(const Double_t* x); Fill a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNtupleD.html:28272,energy,energy,28272,root/html602/TNtupleD.html,https://root.cern,https://root.cern/root/html602/TNtupleD.html,4,['energy'],['energy']
Energy Efficiency," floating-point number called temp and an integer named ntrack.; ""temp/F:ntrack/I:""; The type can be omitted and if no type is given, the same type as the previous variable is assumed. This leaf list has three integers called ntrack, nseg, and nvtex.; ""ntrack/I:nseg:nvtex""; There is one more rule: when no type is given for the very first leaf, it becomes a float (F). This leaf list has three floats called temp, mass, and px.; ""temp:mass:px""; The symbols used for the type are:. C: a character string terminated by the 0 character; B: an 8 bit signed integer; b: an 8 bit unsigned integer; S: a 16 bit signed integer; s: a 16 bit unsigned integer; I: a 32 bit signed integer; i: a 32 bit unsigned integer; L: a 64 bit signed integer; l: a 64 bit unsigned integer; G: a long signed integer, stored as 64 bit; g: a long unsigned integer, stored as 64 bit; F: a 32 bit floating point; D: a 64 bit floating point; O: [the letter ‘o’, not a zero] a boolean (Bool_t). The type is used for a byte count to decide how much space to allocate. The variable written is simply the block of bytes starting at the starting address given in the second parameter. It may or may not match the leaf list depending on whether or not the programmer is being careful when choosing the leaf address, name, and type.; By default, a variable will be copied with the number of bytes specified in the type descriptor symbol. However, if the type consists of two characters, the number specifies the number of bytes to be used when copying the variable to the output buffer. The line below describes ntrack to be written as a 16-bit integer (rather than a 32-bit integer).; ""ntrack/I2""; With this Branch method, you can also add a leaf that holds an entire array of variables. To add an array of floats use the f[n] notation when describing the leaf.; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; You can also add an array of variable length:; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:539873,allocate,allocate,539873,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['allocate'],['allocate']
Energy Efficiency, fonts; [#14032] - TPaveText has problems when label is set; [#14030] - Allow zero-copy RNTuple bulk reading; [#13965] - [Cling] Assertion fails with wrong but innocent code; [#13962] - THnSparse::Scale() unsparsifies; [#13877] - [ntuple] Segfault when processing recursive classes; [#13865] - [FreeBSD] cling cmake error; [#13861] - Remove all traces of Python2 from the ROOT codebase in preparation for 6.32/00; [#13851] - Test crash with GCC 13 and C++20; [#13834] - Can’t open TBrowser locally after upgrading macos “Apple M2 14.0 (23A344)”; [#13825] - builtin libpng too old; [#13815] - Cling (rightfully) confused about forward-declared template specializations; [#13697] - Unexpected behaviour of KSTest with toys (“X” option) for identical histograms; [#13659] - rootprint/rootls missing recursive traversal; [#13623] - Add directory wildcarding in TChain; [#13531] - Huge RAM consumption of the hadd command for input files with several directories; [#13511] - TMapFile can’t work; [#13497] - Assertion failure in TMVA with vector iterators incompatible error on Windows; [#13441] - error in root-generated code for cubic spline (TSpline3); [#13421] - [MSVC] ROOT builds under msvc option /permissive- with error C4576; [#13359] - Bug in TFileMerger class for a single input file and a selective list of objects to be merged in output file; [#13288] - [cling] long double type incorrectly parsed by interpreter; [#13155] - TMVA doesn’t compile with pytorch 2.0.1; [#13130] - Valgrind reports leak when constructing TChain; [#13110] - Bug in TDecompBase::DiagProd; [#13079] - Builtin TBB library sometimes not found (or more exactly the one install in /usr/lib sometimes take priority); [#13041] - TVirtualFitter::GetFitter() unexpectedly returns NULL on macOS 12 and 13 with Xcode 14; [#13019] - LLVM assertion failure in HandleUnionActiveMemberChange; [#12993] - std::source_location not working in the interpreter; [#12959] - [ntuple] Distinguish between connecting a page sink and a page s,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:32060,consumption,consumption,32060,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['consumption'],['consumption']
Energy Efficiency," for array-backed containers are just pointers, the required information; 214 /// will be directly stored in `*(begin|end)_arena`.; 215 typedef void (*CreateIterators_t)(void *collection, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy);; 216 ; 217 /// Return a pointer to a function that can create an iterator pair, where each iterator points to the begin and end; 218 /// of the collection, respectively (see CreateIterators_t). If `read == kTRUE`, data is to be read from disk, i.e.; 219 /// written to the in-memory collection.; 220 virtual CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE) = 0;; 221 ; 222 /// Copy the iterator `source` into `dest`. `dest` should contain the location of a memory arena of size; 223 /// `fgIteratorArenaSize`.; 224 /// If iterator-specific information is of that size or less, the iterators will be constructed in place in the given; 225 /// locations. Otherwise, iterators will be allocated via `new` and their address returned by modifying the value; 226 /// of `*begin_arena` and `*end_arena`. The actual address of the iterator is returned in any case.; 227 typedef void* (*CopyIterator_t)(void *dest, const void *source);; 228 ; 229 /// Return a pointer to a function that can copy an iterator (see CopyIterator_t). If `read == kTRUE`, data is to be; 230 /// read from disk, i.e. written to the in-memory collection.; 231 virtual CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE) = 0;; 232 ; 233 /// `iter` and `end` should be pointers to an iterator to be incremented and an iterator that points to the end of; 234 /// the collection, respectively. If `iter` has not reached the end of the collection, this function increments the; 235 /// iterator and returns a pointer to the element before the increment. Otherwise, `nullptr` is returned.; 236 typedef void* (*Next_t)(void *iter, const void *end);; 237 ; 238 /// Return a pointer to a function that can advance an iterator (see Next_t). If `read == kTRUE`",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:11325,allocate,allocated,11325,doc/master/TVirtualCollectionProxy_8h_source.html,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency," for artificial neural network.; The input layer contains as many neurons as input variables used in the MVA. The output layer contains two neurons for the signal and background event classes. In between the input and output layers are a variable number of k hidden layers with arbitrary numbers of neurons. (While the structure of the input and output layers is determined by the problem, the hidden layers can be configured by the user through the option string of the method booking.); As indicated in the sketch, all neuron inputs to a layer are linear combinations of the neuron output of the previous layer. The transfer from input to output within a neuron is performed by means of an ""activation; function"". In general, the activation function of a neuron can be zero (deactivated), one (linear), or non-linear. The above example uses a sigmoid activation function. The transfer function of the output layer is usually linear. As a consequence: an ANN without hidden layer should give identical discrimination power as a linear discriminant analysis (Fisher). In case of one hidden layer, the ANN computes a linear combination of sigmoid.; The learning method used by the CFMlpANN is only stochastic. ; Definition at line 95 of file MethodCFMlpANN.h. Public Member Functions;  MethodCFMlpANN (const TString &jobName, const TString &methodTitle, DataSetInfo &theData, const TString &theOption=""3000:N-1:N-2"");  standard constructor ;  ;  MethodCFMlpANN (DataSetInfo &theData, const TString &theWeightFile);  constructor from weight file ;  ; virtual ~MethodCFMlpANN (void);  destructor ;  ; void AddWeightsXMLTo (void *parent) const;  write weights to xml file ;  ; const Ranking * CreateRanking ();  ; Int_t GetClass (Int_t ivar) const;  ; Double_t GetData (Int_t isel, Int_t ivar) const;  ; Double_t GetMvaValue (Double_t *err=nullptr, Double_t *errUpper=nullptr);  returns CFMlpANN output (normalised within [0,1]) ;  ; virtual Bool_t HasAnalysisType (Types::EAnalysisType type, UInt_t numbe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCFMlpANN.html:1586,power,power,1586,doc/master/classTMVA_1_1MethodCFMlpANN.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCFMlpANN.html,1,['power'],['power']
Energy Efficiency," for streamer, user should not use it. PDEFoam(const TString& ); User constructor, to be employed by the user. ~PDEFoam(); Default destructor. PDEFoam(const TMVA::PDEFoam& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void SetDim(Int_t kDim); Sets dimension of cubical space. void SetXmin(Int_t idim, Double_t wmin); set lower foam bound in dimension idim. void SetXmax(Int_t idim, Double_t wmax); set upper foam bound in dimension idim. void Create(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. After the foam is grown, space for 2 variables is reserved in; every cell. They are used for filling the foam cells. void InitCells(); Internal subprogram used by Create.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TMVA::PDEFoamCell* ); Internal subprogram used by Create.; It initializes content of the newly allocated active cell. void Explore(TMVA::PDEFoamCell* Cell); Internal subprogram used by Create.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of kTRUE and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. If fNmin > 0 then the total number of (training) events found in; the cell during the exploration is stored in the cell. This; information is used withing PeekMax() to avoid splitting cells; which contain less than fNmin events. void DTExplore(TMVA::PDEFoamCe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__PDEFoam.html:12660,allocate,allocated,12660,root/html528/TMVA__PDEFoam.html,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoam.html,1,['allocate'],['allocated']
Energy Efficiency," for streamer, user should not use it. PDEFoam(const TString& ); User constructor, to be employed by the user. ~PDEFoam(); Default destructor. PDEFoam(const TMVA::PDEFoam& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void SetDim(Int_t kDim); Sets dimension of cubical space. void SetXmin(Int_t idim, Double_t wmin); set lower foam bound in dimension idim. void SetXmax(Int_t idim, Double_t wmax); set upper foam bound in dimension idim. void Create(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. After the foam is grown, space for 2 variables is reserved in; every cell. They are used for filling the foam cells. void InitCells(); Internal subprogram used by Create.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TMVA::PDEFoamCell* ); Internal subprogram used by Create.; It initializes content of the newly allocated active cell. void Explore(TMVA::PDEFoamCell* Cell); Internal subprogram used by Create.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of kTRUE and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. If fNmin > 0 then the total number of (training) events found in; the cell during the exploration is stored in the cell. This; information is used withing PeekMax() to avoid splitting cells; which contain less than fNmin events. void Varedu(Double_t* , Int_t&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDEFoam.html:12248,allocate,allocated,12248,root/html530/TMVA__PDEFoam.html,https://root.cern,https://root.cern/root/html530/TMVA__PDEFoam.html,5,['allocate'],['allocated']
Energy Efficiency," for streamer, user should not use it. PDEFoam(const TString& ); User constructor, to be employed by the user. ~PDEFoam(); Default destructor. PDEFoam(const TMVA::PDEFoam& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void SetDim(Int_t kDim); Sets dimension of cubical space. void SetXmin(Int_t idim, Double_t wmin); set lower foam bound in dimension idim. void SetXmax(Int_t idim, Double_t wmax); set upper foam bound in dimension idim. void Create(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. After the foam is grown, space for 2 variables is reserved in; every cell. They are used for filling the foam cells. void InitCells(); Internal subprogram used by Create.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TMVA::PDEFoamCell* ); Internal subprogram used by Create.; It initializes content of the newly allocated active cell. void Explore(TMVA::PDEFoamCell* Cell); Internal subprogram used by Create.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of kTRUE and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. If fNmin > 0 then the total number of (training) events found in; the cell during the exploration is stored in the cell. This; information is used withing PeekMax() to avoid splitting cells; which contain less than fNmin events. void Varedu(Double_t[] , Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__PDEFoam.html:12699,allocate,allocated,12699,root/html602/TMVA__PDEFoam.html,https://root.cern,https://root.cern/root/html602/TMVA__PDEFoam.html,4,['allocate'],['allocated']
Energy Efficiency," for the same class version; 5589 // as is loaded now. We may proceed without worry.; 5590 TVirtualStreamerInfo* si = GetStreamerInfo();; 5591 if (si) {; 5592 si->DeleteArray(ary, dtorOnly);; 5593 } else {; 5594 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), fClassVersion, ary);; 5595 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5596 Int_t i = fStreamerInfo->LowerBound();; 5597 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5598 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5599 if (fStreamerInfo->At(i)) {; 5600 Error(""DeleteArray"", ""Doing Dump() ..."");; 5601 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5602 }; 5603 }; 5604 }; 5605 } else {; 5606 // The loaded class version is not the same as the version of the code; 5607 // which was used to allocate this array. The best we can do is use; 5608 // the TVirtualStreamerInfo to try to free up some of the allocated memory.; 5609 TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);; 5610 if (si) {; 5611 si->DeleteArray(ary, dtorOnly);; 5612 } else {; 5613 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), objVer, ary);; 5614 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5615 Int_t i = fStreamerInfo->LowerBound();; 5616 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5617 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5618 if (fStreamerInfo->At(i)) {; 5619 // Print some debugging info.; 5620 Error(""DeleteArray"", ""Doing Dump() ..."");; 5621 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5622 }; 5623 }; 5624 }; 5625 }; 5626 ; 5627 // Deregister the object for special handling in the destructor.; 5628 if (inRepo && p) {; 5629 UnregisterAddressInRepository(""TClass::Delete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:214835,allocate,allocated,214835,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," for the same class version; 5656 // as is loaded now. We may proceed without worry.; 5657 TVirtualStreamerInfo* si = GetStreamerInfo();; 5658 if (si) {; 5659 si->DeleteArray(ary, dtorOnly);; 5660 } else {; 5661 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), fClassVersion, ary);; 5662 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5663 Int_t i = fStreamerInfo->LowerBound();; 5664 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5665 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5666 if (fStreamerInfo->At(i)) {; 5667 Error(""DeleteArray"", ""Doing Dump() ..."");; 5668 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5669 }; 5670 }; 5671 }; 5672 } else {; 5673 // The loaded class version is not the same as the version of the code; 5674 // which was used to allocate this array. The best we can do is use; 5675 // the TVirtualStreamerInfo to try to free up some of the allocated memory.; 5676 TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);; 5677 if (si) {; 5678 si->DeleteArray(ary, dtorOnly);; 5679 } else {; 5680 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), objVer, ary);; 5681 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5682 Int_t i = fStreamerInfo->LowerBound();; 5683 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5684 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5685 if (fStreamerInfo->At(i)) {; 5686 // Print some debugging info.; 5687 Error(""DeleteArray"", ""Doing Dump() ..."");; 5688 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5689 }; 5690 }; 5691 }; 5692 }; 5693 ; 5694 // Deregister the object for special handling in the destructor.; 5695 if (inRepo && p) {; 5696 UnregisterAddressInRepository(""TClass::Delete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:217586,allocate,allocated,217586,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," from file: trained_model_higgs.h5; PyKeras : [dataset] : Evaluation of PyKeras on training sample (14000 events); : Elapsed time for evaluation of 14000 events: 0.26 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_PyKeras.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_PyKeras.class.C␛[0m; Factory : Training finished; : ; : Ranking input variables (method specific)...; Likelihood : Ranking result (top variable is best ranked); : -------------------------------------; : Rank : Variable : Delta Separation; : -------------------------------------; : 1 : m_bb : 3.688e-02; : 2 : m_wbb : 3.307e-02; : 3 : m_wwbb : 2.885e-02; : 4 : m_jjj : -1.155e-03; : 5 : m_jj : -1.436e-03; : 6 : m_lv : -5.963e-03; : 7 : m_jlv : -9.884e-03; : -------------------------------------; Fisher : Ranking result (top variable is best ranked); : ---------------------------------; : Rank : Variable : Discr. power; : ---------------------------------; : 1 : m_bb : 1.279e-02; : 2 : m_wwbb : 9.131e-03; : 3 : m_wbb : 2.668e-03; : 4 : m_jlv : 9.145e-04; : 5 : m_jjj : 1.769e-04; : 6 : m_lv : 6.617e-05; : 7 : m_jj : 6.707e-06; : ---------------------------------; BDT : Ranking result (top variable is best ranked); : ----------------------------------------; : Rank : Variable : Variable Importance; : ----------------------------------------; : 1 : m_bb : 2.089e-01; : 2 : m_wwbb : 1.673e-01; : 3 : m_wbb : 1.568e-01; : 4 : m_jlv : 1.560e-01; : 5 : m_jjj : 1.421e-01; : 6 : m_jj : 1.052e-01; : 7 : m_lv : 6.369e-02; : ----------------------------------------; : No variable ranking supplied by classifier: DNN_CPU; : No variable ranking supplied by classifier: PyKeras; TH1.Print Name = TrainingHistory_DNN_CPU_trainingError, Entries= 0, Total sum= 11.248; TH1.Print Name = TrainingHistory_DNN_CPU_valError, Entries= 0, Total sum= 11.788; TH1.Print Name = TrainingHistory_PyKeras_'accuracy', Entries= 0, Total sum= 13.3463; TH1.Print Nam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:47354,power,power,47354,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['power'],['power']
Energy Efficiency," from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t *&h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t *&ii); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t *&ll); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t *&ll); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t *&f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t *&d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Float16_t encoding at TBufferFile::WriteFloat16. Int_t ReadArrayDouble32(Double_t*& d, TStreamerElement* ele = 0); Read array of doubles (written as float) from the I/O buffer.; Returns the number of doubles read.; If argument is a 0 pointer then space will be allocated for the array.; see comments about Double32_t encoding at TBufferFile::WriteDouble32. Int_t ReadStaticArray(Bool_t *b); Read array of bools from the I/O buffer. Returns the number of bools; read. Int_t ReadStaticArray(Char_t *c); Read array of ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferFile.html:26566,allocate,allocated,26566,root/html526/TBufferFile.html,https://root.cern,https://root.cern/root/html526/TBufferFile.html,1,['allocate'],['allocated']
Energy Efficiency," from the Principal Component; Analysis. Determine ; as before. Detetmine ; as before. Use the result of the fit to determind ; . Transform back to ; from ; , using; the result from the Principal Component Analysis. Testing the parameterization. The class also provides functionality for testing the, over the; training sample, found parameterization; (TMultiDimFit::Fit). This is done by passing; the class a test sample of tuples of the form ; , where ; are the independent; variables, the known, dependent quantity, and is; the square error in ; (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every ; in the; test sample, and. is evaluated. The relative error over the test sample. should not be to low or high compared to from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representive of; the problem. A large difference in the reduced over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use Minuit; [4] to further improve the fit, using the test sample. Christian Holm; November 2000, NBI. Bibliography; 1. Philip R. Bevington and D. Keith Robinson.; Data Reduction and Error Analysis for the Physical Sciences.; McGraw-Hill, 2 edition, 1992.; 2. René Brun et al.; Mudifi.; Long writeup DD/75-23, CERN, 1980.; 3. Gene H. Golub and Charles F. van Loan.; Matrix Computations.; John Hopkins Univeristy Press, Baltimore, 3 edition, 1996.; 4. F. James.; Minuit.; Long writeup D506, CERN, 1998.; 5. H. Wind.; Function parameterization.; In Proceedings of the 1972 CERN Computing and Data Processing; School, volume 72-21 of Yellow report. CERN, 1972.; 6. H. Wind.; 1. principal component analysis, 2. pattern recognition for track; finding, 3. interpolation and functional representation.; Yellow report EP/81-12, CERN, 1981. */. Function Members (Methods); public:. TMultiDimFit(); TMultiDimFit(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:12374,reduce,reduced,12374,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,8,['reduce'],['reduced']
Energy Efficiency, from xml weight file ; Implements TMVA::MethodBase.; Definition at line 635 of file MethodFisher.cxx. ◆ Streamer(). virtual void TMVA::MethodFisher::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::MethodBase. ◆ StreamerNVirtual(). void TMVA::MethodFisher::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 154 of file MethodFisher.h. ◆ Train(). void TMVA::MethodFisher::Train ; (; void ; ). virtual . computation of Fisher coefficients by series of matrix operations ; Implements TMVA::MethodBase.; Definition at line 237 of file MethodFisher.cxx. Member Data Documentation. ◆ fBetw. TMatrixD* TMVA::MethodFisher::fBetw. private . between-class matrix ; Definition at line 139 of file MethodFisher.h. ◆ fCov. TMatrixD* TMVA::MethodFisher::fCov. private . full covariance matrix ; Definition at line 141 of file MethodFisher.h. ◆ fDiscrimPow. std::vector<Double_t>* TMVA::MethodFisher::fDiscrimPow. private . discriminating power ; Definition at line 147 of file MethodFisher.h. ◆ fF0. Double_t TMVA::MethodFisher::fF0. private . offset ; Definition at line 149 of file MethodFisher.h. ◆ fFisherCoeff. std::vector<Double_t>* TMVA::MethodFisher::fFisherCoeff. private . Fisher coefficients. ; Definition at line 148 of file MethodFisher.h. ◆ fFisherMethod. EFisherMethod TMVA::MethodFisher::fFisherMethod. private . Fisher or Mahalanobis. ; Definition at line 136 of file MethodFisher.h. ◆ fMeanMatx. TMatrixD* TMVA::MethodFisher::fMeanMatx. private . Definition at line 132 of file MethodFisher.h. ◆ fSumOfWeightsB. Double_t TMVA::MethodFisher::fSumOfWeightsB. private . sum-of-weights for background training events ; Definition at line 145 of file MethodFisher.h. ◆ fSumOfWeightsS. Double_t TMVA::MethodFisher::fSumOfWeightsS. private . sum-of-weights for signal training events ; Definition at line 144 of file MethodFisher.h. ◆ fTheMethod. TString TMVA::MethodFisher::fTheMethod. private . Fisher or Mahalanobis. ; Definition at line 135 ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodFisher.html:40801,power,power,40801,doc/master/classTMVA_1_1MethodFisher.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodFisher.html,1,['power'],['power']
Energy Efficiency," function with exponent given by fBoost; coefficient) and repeat it fNumberRepetitions times.;  ; Parameters:; ������� fSource-pointer to the matrix of source; spectrum����������������� ; ������� fResp-pointer to the matrix of response; spectrum����������������� ; ������� fSizex, fSizey, fSizez -lengths of the; spectrum matrix�������������������������������� ; ������� fNumberIterations-number; of iterations ; ������� fNumberRepetitions-number; of repetitions for boosted deconvolution. It must be ; ������� greater or equal to one.; ������� fBoost-boosting; coefficient, applies only if fNumberRepetitions is greater than one.� ; ������� Recommended; range <1,2>.;  ; References:; �[1] M.; Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�, I. Turzo.: Efficient; one- and two-dimensional Gold deconvolution and its application to gamma-ray; spectra decomposition. NIM, A401 (1997) 385-408.; [2] Morh�č M., Matou�ek V.,; Kliman J., Efficient algorithm of multidimensional deconvolution and its; application to nuclear data processing, Digital Signal Processing 13 (2003); 144. ;  ; Example 1 � script Decon.c :; �        ; response function (usually peak) should be shifted to the beginning of; the coordinate system (see Fig. 1). Fig. 1 Three-dimensional; response spectrum;  .  ; Fig. 2 Three-dimensional input; spectrum (before deconvolution);  . Fig. 3 Spectrum from Fig. 2; after deconvolution (100 iterations);  ; Script:; // Example to illustrate the; Gold deconvolution (class TSpectrum3).; // To execute this example,; do; // root > .x Decon3.C;  ; #include <TSpectrum3>;  ; void Decon3() {; �� Int_t i, j, k;; �� Int_t nbinsx = 32;; �� Int_t nbinsy = 32;; �� Int_t nbinsz =; 32;�� ; �� Int_t xmin� = 0;; �� Int_t xmax� =; nbinsx;; �� Int_t ymin� = 0;; �� Int_t ymax� =; nbinsy;�� ; �� Int_t zmin� = 0;; �� Int_t zmax� = nbinsz;����� ; �� Double_t*** source = new; Double_t**[nbinsx];; �� Double_t*** resp = new Double_t; **[nbinsx];����� ; �� for(i=0;i<nbinsx;i++){; ����� source[i]=new Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum3.html:25567,Efficient,Efficient,25567,root/html602/TSpectrum3.html,https://root.cern,https://root.cern/root/html602/TSpectrum3.html,2,['Efficient'],['Efficient']
Energy Efficiency," function with exponent given by fBoost; coefficient) and repeat it fNumberRepetitions times.;  ; Parameters:; ������� fSource-pointer to the matrix of source; spectrum����������������� ; ������� fResp-pointer to the matrix of response; spectrum����������������� ; ������� fSizex, fSizey, fSizez -lengths of the; spectrum matrix�������������������������������� ; ������� fNumberIterations-number; of iterations ; ������� fNumberRepetitions-number; of repetitions for boosted deconvolution. It must be ; ������� greater or equal to one.; ������� fBoost-boosting; coefficient, applies only if fNumberRepetitions is greater than one.� ; ������� Recommended; range <1,2>.;  ; References:; �[1] M.; Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�, I. Turzo.: Efficient; one- and two-dimensional Gold deconvolution and its application to gamma-ray; spectra decomposition. NIM, A401 (1997) 385-408.; [2] Morh�č M., Matou�ek V.,; Kliman J., Efficient algorithm of multidimensional deconvolution and its; application to nuclear data processing, Digital Signal Processing 13 (2003); 144. ;  ; Example 1 � script Decon.c :; �        ; response function (usually peak) should be shifted to the beginning of; the coordinate system (see Fig. 1). Fig. 1 Three-dimensional; response spectrum;  .  ; Fig. 2 Three-dimensional input; spectrum (before deconvolution);  . Fig. 3 Spectrum from Fig. 2; after deconvolution (100 iterations);  ; Script:; // Example to illustrate the; Gold deconvolution (class TSpectrum3).; // To execute this example,; do; // root > .x Decon3.C;  ; #include <TSpectrum3>;  ; void Decon3() {; �� Int_t i, j, k;; �� Int_t nbinsx = 32;; �� Int_t nbinsy = 32;; �� Int_t nbinsz =; 32;�� ; �� Int_t xmin� = 0;; �� Int_t xmax� =; nbinsx;; �� Int_t ymin� = 0;; �� Int_t ymax� =; nbinsy;�� ; �� Int_t zmin� = 0;; �� Int_t zmax� = nbinsz;����� ; �� float *** source = new; float **[nbinsx];; �� float *** resp = new float; **[nbinsx];����� ; �� for(i=0;i<nbinsx;i++){; ����� source[i]=new float*; [nbinsy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSpectrum3.html:24835,Efficient,Efficient,24835,root/html532/TSpectrum3.html,https://root.cern,https://root.cern/root/html532/TSpectrum3.html,2,['Efficient'],['Efficient']
Energy Efficiency," function. ; Definition at line 676 of file TSpectrumFit.cxx. ◆ SetBackgroundParameters(). void TSpectrumFit::SetBackgroundParameters ; (; Double_t ; a0Init, . Bool_t ; fixA0, . Double_t ; a1Init, . Bool_t ; fixA1, . Double_t ; a2Init, . Bool_t ; fixA2 . ). This function sets the following fitting parameters of background: . a0Init - initial value of a0 parameter (background is estimated as a0+a1*x+a2*x*x); fixA0 - logical value of a0 parameter, which allows to fix the parameter (not to fit); a1Init - initial value of a1 parameter; fixA1 - logical value of a1 parameter, which allows to fix the parameter (not to fit); a2Init - initial value of a2 parameter; fixA2 - logical value of a2 parameter, which allows to fix the parameter (not to fit) . Definition at line 2693 of file TSpectrumFit.cxx. ◆ SetFitParameters(). void TSpectrumFit::SetFitParameters ; (; Int_t ; xmin, . Int_t ; xmax, . Int_t ; numberIterations, . Double_t ; alpha, . Int_t ; statisticType, . Int_t ; alphaOptim, . Int_t ; power, . Int_t ; fitTaylor . ). This function sets the following fitting parameters: . xmin, xmax - fitting region; numberIterations - # of desired iterations in the fit; alpha - convergence coefficient, it should be positive number and <=1, for details see references; statisticType - type of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood; alphaOptim - optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal; power - possible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. . Definition at line 2610 of file TSpectrumFit.cxx. ◆ SetPeakParameters(). void TSpectrumFit::SetPeakParameters",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumFit.html:45462,power,power,45462,doc/master/classTSpectrumFit.html,https://root.cern,https://root.cern/doc/master/classTSpectrumFit.html,1,['power'],['power']
Energy Efficiency," gCws->fNewColors[i] = xcol[i].pixel;; 3012 ; 3013 delete [] xcol;; 3014}; 3015 ; 3016////////////////////////////////////////////////////////////////////////////////; 3017/// Returns index in orgcolors (and fNewColors) for pixel.; 3018 ; 3019Int_t TGX11::FindColor(ULong_t pixel, ULong_t *orgcolors, Int_t ncolors); 3020{; 3021 for (int i = 0; i < ncolors; i++); 3022 if (pixel == orgcolors[i]) return i;; 3023 ; 3024 Error(""FindColor"", ""did not find color, should never happen!"");; 3025 ; 3026 return 0;; 3027}; 3028 ; 3029////////////////////////////////////////////////////////////////////////////////; 3030/// Set color intensities for given color index.; 3031///; 3032/// \param [in] cindex : color index; 3033/// \param [in] r,g,b : red, green, blue intensities between 0.0 and 1.0; 3034 ; 3035void TGX11::SetRGB(int cindex, float r, float g, float b); 3036{; 3037 if (fColormap) {; 3038 RXColor xcol;; 3039 xcol.red = (UShort_t)(r * kBIGGEST_RGB_VALUE);; 3040 xcol.green = (UShort_t)(g * kBIGGEST_RGB_VALUE);; 3041 xcol.blue = (UShort_t)(b * kBIGGEST_RGB_VALUE);; 3042 xcol.flags = DoRed | DoGreen | DoBlue;; 3043 XColor_t &col = GetColor(cindex);; 3044 if (col.fDefined) {; 3045 // if color is already defined with same rgb just return; 3046 if (col.fRed == xcol.red && col.fGreen == xcol.green &&; 3047 col.fBlue == xcol.blue); 3048 return;; 3049 col.fDefined = kFALSE;; 3050 if (fRedDiv == -1); 3051 XFreeColors((Display*)fDisplay, fColormap, &col.fPixel, 1, 0);; 3052 }; 3053 if (AllocColor(fColormap, &xcol)) {; 3054 col.fDefined = kTRUE;; 3055 col.fPixel = xcol.pixel;; 3056 col.fRed = xcol.red;; 3057 col.fGreen = xcol.green;; 3058 col.fBlue = xcol.blue;; 3059 }; 3060 }; 3061}; 3062 ; 3063////////////////////////////////////////////////////////////////////////////////; 3064/// Set text alignment.; 3065///; 3066/// \param [in] talign text alignment; 3067 ; 3068void TGX11::SetTextAlign(Short_t talign); 3069{; 3070 Int_t txalh = talign/10;; 3071 Int_t txalv = talign%10;; 3072 fTextA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:101368,green,green,101368,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['green'],['green']
Energy Efficiency," gen >;  ; class  AlgebraicSumType< vec, sym >;  ; class  AnalyticalGradientCalculator;  ; class  BFGSErrorUpdator;  Update of the covariance matrix for the Variable Metric minimizer (MIGRAD) More...;  ; class  BFGSMinimizerType;  ; class  CombinedMinimizer;  Combined minimizer: combination of Migrad and Simplex. More...;  ; class  CombinedMinimumBuilder;  ; class  ContoursError;  ; class  DavidonErrorUpdator;  Update of the covariance matrix for the Variable Metric minimizer (MIGRAD) More...;  ; struct  DerivatorElement;  ; class  ExternalInternalGradientCalculator;  Similar to the AnalyticalGradientCalculator, the ExternalInternalGradientCalculator supplies Minuit with an externally calculated gradient. More...;  ; class  FCNAdapter;  template wrapped class for adapting to FCNBase signature More...;  ; class  FCNBase;  Interface (abstract class) defining the function to be minimized, which has to be implemented by the user. More...;  ; class  FCNGradAdapter;  template wrapped class for adapting to FCNBase signature a IGradFunction More...;  ; class  FCNGradientBase;  ; class  FumiliBuilder;  Builds the FunctionMinimum using the Fumili method. More...;  ; class  FumiliChi2FCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  FumiliFCNAdapter;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  FumiliFCNBase;  Extension of the FCNBase for the Fumili method. More...;  ; class  FumiliGradientCalculator;  Fumili gradient calculator using external gradient provided by FCN Note that the computed Hessian and G2 are an approximation valid for small residuals. More...;  ; class  FumiliMaximumLikelihoodFCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  Fumi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Minuit2.html:1940,adapt,adapting,1940,doc/v632/namespaceROOT_1_1Minuit2.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Minuit2.html,1,['adapt'],['adapting']
Energy Efficiency," gen >;  ; class  AlgebraicSumType< vec, sym >;  ; class  AnalyticalGradientCalculator;  ; class  BFGSErrorUpdator;  Update of the covariance matrix for the Variable Metric minimizer (MIGRAD) More...;  ; class  BFGSMinimizerType;  ; class  CombinedMinimizer;  Combined minimizer: combination of Migrad and Simplex. More...;  ; class  CombinedMinimumBuilder;  ; class  ContoursError;  ; class  DavidonErrorUpdator;  Update of the covariance matrix for the Variable Metric minimizer (MIGRAD) More...;  ; struct  DerivatorElement;  ; class  ExternalInternalGradientCalculator;  Similar to the AnalyticalGradientCalculator, the ExternalInternalGradientCalculator supplies Minuit with an externally calculated gradient. More...;  ; class  FCNAdapter;  template wrapped class for adapting to FCNBase signature More...;  ; class  FCNBase;  Interface (abstract class) defining the function to be minimized, which has to be implemented by the user. More...;  ; class  FCNGradAdapter;  template wrapped class for adapting to FCNBase signature a IGradFunction More...;  ; class  FCNGradientBase;  Extension of the FCNBase for providing the analytical Gradient of the function. More...;  ; class  FumiliBuilder;  Builds the FunctionMinimum using the Fumili method. More...;  ; class  FumiliChi2FCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  FumiliFCNAdapter;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  FumiliFCNBase;  Extension of the FCNBase for the Fumili method. More...;  ; class  FumiliGradientCalculator;  Fumili gradient calculator using external gradient provided by FCN Note that the computed Hessian and G2 are an approximation valid for small residuals. More...;  ; class  FumiliMaxi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html:1941,adapt,adapting,1941,doc/master/namespaceROOT_1_1Minuit2.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html,1,['adapt'],['adapting']
Energy Efficiency," grabs it, but the creator has to Release it before the pointer gets out of scope. The following sequence is valid:; // producer:; TGeoRCExtension *ext = new TGeoRCExtension();; some_TGeoVolume->SetUserExtension(ext);; ext->Release();; // user:; TGeoRCExtension *ext = dynamic_cast<TGeoRCExtension*>(some_TGeoVolume->GrabUserExtension());; // ... use extension; ext->Release();; TGeoRCExtensionReference counted extension which has a pointer to and owns a user defined TObject.Definition TGeoExtension.h:33; TGeoRCExtension::TGeoRCExtensionTGeoRCExtension()Definition TGeoExtension.h:38; TGeoRCExtension::Releasevoid Release() const overrideDefinition TGeoExtension.cxx:68; The extension is going to be released by the TGeoVolume holder at the destruction or when calling SetUserExtension(0).; The following usage is not correct:; some_TGeoVolume->SetUserExtension(new TGeoRCExtension()); since the producer code does not release the extension. One cannot call directly ""delete ext"" nor allocate an extension on the stack, since the destructor is protected. Use Release instead. ; Definition at line 33 of file TGeoExtension.h. Public Member Functions;  TGeoRCExtension ();  ;  TGeoRCExtension (TObject *obj);  ; TObject * GetUserObject () const;  ; TGeoExtension * Grab () override;  ; TClass * IsA () const override;  ; void Release () const override;  ; void SetUserObject (TObject *obj);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoExtension; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoRCExtension.html:1600,allocate,allocate,1600,doc/master/classTGeoRCExtension.html,https://root.cern,https://root.cern/doc/master/classTGeoRCExtension.html,1,['allocate'],['allocate']
Energy Efficiency," h2->Fit(""f2"",""N"");; auto cutg = new TCutG(""cutg"",5);; cutg->SetPoint(0,-7,-7);; cutg->SetPoint(1, 2,-7);; cutg->SetPoint(2, 2, 2);; cutg->SetPoint(3,-7, 2);; cutg->SetPoint(4,-7,-7);; h2->Draw(""lego2 0"");; h2->SetFillColor(38);; f2->SetNpx(80);; f2->SetNpy(80);; f2->Draw(""surf1 same bb [cutg]"");; return c;; }; TCanvas.h; TCutG.h; TF2.h; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; TH2.h; nentriesint nentriesDefinition THbookFile.cxx:91; TMath.h; TStyle.h; TCutGGraphical cut class.Definition TCutG.h:20; TF2A 2-Dim function with parameters.Definition TF2.h:29; RooFit::Detail::MathFuncs::ratiodouble ratio(double numerator, double denominator)Definition MathFuncs.h:103; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; . Drawing options for 3D histograms. Option Description . ""SCAT"" Draw a scatter plot (legacy draw option). . ""ISO"" Draw a Gouraud shaded 3d iso surface through a 3d histogram. It paints one surface at the value computed as follow: SumOfWeights/(NbinsX*NbinsY*NbinsZ) . ""BOX"" Draw a for each cell with volume proportional to the content's absolute value. An hidden line removal algorithm is used . ""BOX1"" Same as BOX but an hidden surface removal algorithm is used . ""BOX2"" Same as ""COL"". The boxes' colors are picked in the current palette according to the bins' contents (default) . ""BOX2Z"" Same as ""BOX2"". In addition the color palette is also drawn. . ""BOX3"" Same as BOX1, but the border lines of each lego-bar are not drawn. . Note that instead of BOX one can also use LEGO.; By default, 3D histograms are drawn as a colored box plots.; The following example shows a 3D histogram plotted as a scatter plot.; {; a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:113650,power,power,113650,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['power'],['power']
Energy Efficiency," have errors defined for the \( \chi^2 \) to be well defined. Options to control construction of the chi-square . YVar(RooRealVar& yvar) Designate given column in dataset as Y value . Integrate(bool flag) Integrate function over range specified by X errors rather than take value at bin center. Options to control flow of fit procedure . InitialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit steps, off by default . PrintLevel(Int_t level) Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational messages are suppressed as well . Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4236 of file RooAbsReal.cxx. ◆ chi2FitTo() [4/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataSet & ; xydata, . const RooLinkedList & ; cmdList . ). virtual . Perform a 2-D \( \chi^2 \) fit using a series of x and y ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:74704,consumption,consumption,74704,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['consumption'],['consumption']
Energy Efficiency," have errors defined for the \( \chi^2 \) to be well defined. Options to control construction of the chi-square . YVar(RooRealVar& yvar) Designate given column in dataset as Y value . Integrate(bool flag) Integrate function over range specified by X errors rather than take value at bin center. Options to control flow of fit procedure . InitialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit steps, off by default . PrintLevel(Int_t level) Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational messages are suppressed as well . Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4254 of file RooAbsReal.cxx. ◆ Class(). static TClass * RooAbsReal::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsReal::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:76865,consumption,consumption,76865,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['consumption'],['consumption']
Energy Efficiency," have errors defined for the \( \chi^2 \) to be well defined. Options to control construction of the chi-square . YVar(RooRealVar& yvar) Designate given column in dataset as Y value . Integrate(bool flag) Integrate function over range specified by X errors rather than take value at bin center. Options to control flow of fit procedure . InitialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit steps, off by default . PrintLevel(Int_t level) Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational messages are suppressed as well . Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4312 of file RooAbsReal.cxx. ◆ chi2FitTo() [4/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataSet & ; xydata, . const RooLinkedList & ; cmdList . ). virtual . Perform a 2-D \( \chi^2 \) fit using a series of x and y ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:75972,consumption,consumption,75972,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['consumption'],['consumption']
Energy Efficiency," have errors defined for the \( \chi^2 \) to be well defined. Options to control construction of the chi-square . YVar(RooRealVar& yvar) Designate given column in dataset as Y value . Integrate(bool flag) Integrate function over range specified by X errors rather than take value at bin center. Options to control flow of fit procedure . InitialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit steps, off by default . PrintLevel(Int_t level) Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational messages are suppressed as well . Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4330 of file RooAbsReal.cxx. ◆ Class(). static TClass * RooAbsReal::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsReal::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:78133,consumption,consumption,78133,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['consumption'],['consumption']
Energy Efficiency," hex format ;  ; int id {0};  node id, index in array ;  ; std::string material;  name of the material ;  ; std::string name;  node name ;  ; bool nochlds {false};  how far in hierarchy depth should be scanned ;  ; int sortid {0};  ! place in sorted array, to check cuts, or id of original node when used search structures ;  ; int vis {0};  visibility flag, 0 - off, 1 - only when level==0, 99 - always ;  . #include <ROOT/RGeomData.hxx>. Inheritance diagram for ROOT::RGeomNode:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RGeomNode(). ROOT::RGeomNode::RGeomNode ; (; int ; _id = 0). inline . Definition at line 80 of file RGeomData.hxx. Member Function Documentation. ◆ CanDisplay(). bool ROOT::RGeomNode::CanDisplay ; (; ); const. inline . True when there is shape and it can be displayed. ; Definition at line 83 of file RGeomData.hxx. Member Data Documentation. ◆ idshift. int ROOT::RGeomNode::idshift {-1}. ! used to jump over then scan all geom hierarchy ; Definition at line 76 of file RGeomData.hxx. ◆ matr. std::vector<float> ROOT::RGeomNode::matr. matrix for the node, can have reduced number of elements ; Definition at line 73 of file RGeomData.hxx. ◆ nfaces. int ROOT::RGeomNode::nfaces {0}. ! number of shape faces ; Definition at line 75 of file RGeomData.hxx. ◆ opacity. float ROOT::RGeomNode::opacity {1.}. ! opacity of the color ; Definition at line 78 of file RGeomData.hxx. ◆ useflag. bool ROOT::RGeomNode::useflag {false}. ! extra flag, used for selection ; Definition at line 77 of file RGeomData.hxx. ◆ vol. double ROOT::RGeomNode::vol {0}. ! volume estimation ; Definition at line 74 of file RGeomData.hxx. Libraries for ROOT::RGeomNode:. [legend]; The documentation for this class was generated from the following file:; geom/webviewer/inc/ROOT/RGeomData.hxx. ROOTRGeomNode. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:13:36 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RGeomNode.html:2381,reduce,reduced,2381,doc/v632/classROOT_1_1RGeomNode.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RGeomNode.html,1,['reduce'],['reduced']
Energy Efficiency," hi)` <td> Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; 4080/// Multiple comma separated range names can be specified.; 4081/// <tr><td> `NumCPU(int num)` <td> Parallelize NLL calculation on num CPUs; 4082/// <tr><td> `Optimize(bool flag)` <td> Activate constant term optimization (on by default); 4083/// <tr><td> `IntegrateBins()` <td> Integrate PDF within each bin. This sets the desired precision.; 4084///; 4085/// <tr><th> <th> Options to control flow of fit procedure; 4086/// <tr><td> `InitialHesse(bool flag)` <td> Flag controls if HESSE before MIGRAD as well, off by default; 4087/// <tr><td> `Hesse(bool flag)` <td> Flag controls if HESSE is run after MIGRAD, on by default; 4088/// <tr><td> `Minos(bool flag)` <td> Flag controls if MINOS is run after HESSE, on by default; 4089/// <tr><td> `Minos(const RooArgSet& set)` <td> Only run MINOS on given subset of arguments; 4090/// <tr><td> `Save(bool flag)` <td> Flag controls if RooFitResult object is produced and returned, off by default; 4091/// <tr><td> `Strategy(Int_t flag)` <td> Set Minuit strategy (0 through 2, default is 1); 4092///; 4093/// <tr><th> <th> Options to control informational output; 4094/// <tr><td> `Verbose(bool flag)` <td> Flag controls if verbose output is printed (NLL, parameter changes during fit; 4095/// <tr><td> `Timer(bool flag)` <td> Time CPU and wall clock consumption of fit steps, off by default; 4096/// <tr><td> `PrintLevel(Int_t level)` <td> Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; 4097/// messages are suppressed as well; 4098/// <tr><td> `Warnings(bool flag)` <td> Enable or disable MINUIT warnings (enabled by default); 4099/// <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; 4100/// value suppress output completely, a zero value will only print the error count per p.d.f component,; 4101/// a positive value is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:178576,consumption,consumption,178576,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['consumption'],['consumption']
Energy Efficiency," high = -1111); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidZero(Int_t& k, Double_t AZ, Double_t BZ, Double_t E2, Double_t& X, Double_t& Y, Int_t maxiterations). protected:. virtual Double_t**Allocate(Int_t newsize); Double_t**AllocateArrays(Int_t Narrays, Int_t arraySize); virtual voidCopyAndRelease(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin); virtual Bool_tCopyPoints(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin); Bool_tCtorAllocate(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Double_t**ExpandAndCopy(Int_t size, Int_t iend); virtual voidFillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); voidTObject::MakeZombie(); Double_t**ShrinkAndCopy(Int_t size, Int_t iend); virtual voidSwapPoints(Int_t pos1, Int_t pos2); static voidSwapValues(Double_t* arr, Int_t pos1, Int_t pos2). Data Members; public:. enum { kClipFrame; kNotEditable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TList*fFunctionsPointer to list of functions (fits and user); TH1F*fHistogramPointer to histogram used for drawing axis; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraph.html:11344,Allocate,Allocate,11344,root/html532/TGraph.html,https://root.cern,https://root.cern/root/html532/TGraph.html,2,['Allocate'],"['Allocate', 'AllocateArrays']"
Energy Efficiency," idx) const { return (char *)(const_cast<TVirtualCollectionProxy *>(this))->At(idx); }; 200 ; 201 // Functions related to member-wise actions; 202 virtual TStreamerInfoActions::TActionSequence *GetConversionReadMemberWiseActions(TClass *oldClass, Int_t version) = 0;; 203 virtual TStreamerInfoActions::TActionSequence *GetReadMemberWiseActions(Int_t version) = 0;; 204 virtual TStreamerInfoActions::TActionSequence *GetWriteMemberWiseActions() = 0;; 205 ; 206 /// The size of a small buffer that can be allocated on the stack to store iterator-specific information; 207 static const Int_t fgIteratorArenaSize = 16; // greater than sizeof(void*) + sizeof(UInt_t); 208 ; 209 /// `*begin_arena` and `*end_arena` should contain the location of a memory arena of size `fgIteratorArenaSize`.; 210 /// If iterator-specific information is of that size or less, the iterators will be constructed in place in the given; 211 /// locations. Otherwise, iterators will be allocated via `new` and their address returned by modifying the value; 212 /// of `*begin_arena` and `*end_arena`.; 213 /// As a special case, given that iterators for array-backed containers are just pointers, the required information; 214 /// will be directly stored in `*(begin|end)_arena`.; 215 typedef void (*CreateIterators_t)(void *collection, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy);; 216 ; 217 /// Return a pointer to a function that can create an iterator pair, where each iterator points to the begin and end; 218 /// of the collection, respectively (see CreateIterators_t). If `read == kTRUE`, data is to be read from disk, i.e.; 219 /// written to the in-memory collection.; 220 virtual CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE) = 0;; 221 ; 222 /// Copy the iterator `source` into `dest`. `dest` should contain the location of a memory arena of size; 223 /// `fgIteratorArenaSize`.; 224 /// If iterator-specific information is of that size or less, the iterators will be cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:10204,allocate,allocated,10204,doc/master/TVirtualCollectionProxy_8h_source.html,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency," if (fStreamerType == TVirtualStreamerInfo::kObject) {; 5287 // -- We are *not* a top-level branch and we are *not* a pointer to a TClonesArray.; 5288 // Case of an embedded TClonesArray.; 5289 fObject = fAddress;; 5290 // Check if it has already been properly built.; 5291 TClonesArray* clones = (TClonesArray*) fObject;; 5292 if (!clones->GetClass()) {; 5293 new(fObject) TClonesArray(fClonesClass);; 5294 }; 5295 } else {; 5296 // -- We are either a top-level branch or we are a subbranch which is a pointer to a TClonesArray.; 5297 // Streamer type should be -1 (for a top-level branch) or kObject(p|P) here.; 5298 if ((fStreamerType != -1) &&; 5299 (fStreamerType != TVirtualStreamerInfo::kObjectp) &&; 5300 (fStreamerType != TVirtualStreamerInfo::kObjectP)) {; 5301 Error(""SetAddress"", ""TClonesArray with fStreamerType: %d"", fStreamerType);; 5302 } else if (fStreamerType == -1) {; 5303 // -- We are a top-level branch.; 5304 TClonesArray** pp = (TClonesArray**) fAddress;; 5305 if (!*pp) {; 5306 // -- Caller wants us to allocate the clones array, but they will own it.; 5307 *pp = new TClonesArray(fClonesClass);; 5308 }; 5309 fObject = (char*) *pp;; 5310 } else {; 5311 // -- We are a pointer to a TClonesArray.; 5312 // Note: We do this so that the default constructor,; 5313 // or the i/o constructor can be lazy.; 5314 TClonesArray** pp = (TClonesArray**) fAddress;; 5315 if (!*pp) {; 5316 // -- Caller wants us to allocate the clones array, but they will own it.; 5317 *pp = new TClonesArray(fClonesClass);; 5318 }; 5319 fObject = (char*) *pp;; 5320 }; 5321 }; 5322 } else {; 5323 // -- We have been given a zero address, allocate for top-level only.; 5324 if (fStreamerType == TVirtualStreamerInfo::kObject) {; 5325 // -- We are *not* a top-level branch and we are *not* a pointer to a TClonesArray.; 5326 // Case of an embedded TClonesArray.; 5327 Error(""SetAddress"", ""Embedded TClonesArray given a zero address for branch '%s'"", GetName());; 5328 } else {; 5329 // -- We are either a t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:196193,allocate,allocate,196193,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency," if (ncolors == 0) return;; 2977 ; 2978 RXColor *xcol = new RXColor[ncolors];; 2979 ; 2980 int i;; 2981 for (i = 0; i < ncolors; i++) {; 2982 xcol[i].pixel = orgcolors[i];; 2983 xcol[i].red = xcol[i].green = xcol[i].blue = 0;; 2984 xcol[i].flags = DoRed | DoGreen | DoBlue;; 2985 }; 2986 QueryColors(fColormap, xcol, ncolors);; 2987 ; 2988 UShort_t add = percent * kBIGGEST_RGB_VALUE / 100;; 2989 ; 2990 Int_t val;; 2991 for (i = 0; i < ncolors; i++) {; 2992 val = xcol[i].red + add;; 2993 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 2994 xcol[i].red = (UShort_t) val;; 2995 val = xcol[i].green + add;; 2996 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 2997 xcol[i].green = (UShort_t) val;; 2998 val = xcol[i].blue + add;; 2999 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 3000 xcol[i].blue = (UShort_t) val;; 3001 if (!AllocColor(fColormap, &xcol[i])); 3002 Warning(""MakeOpaqueColors"", ""failed to allocate color %hd, %hd, %hd"",; 3003 xcol[i].red, xcol[i].green, xcol[i].blue);; 3004 // assumes that in case of failure xcol[i].pixel is not changed; 3005 }; 3006 ; 3007 gCws->fNewColors = new ULong_t[ncolors];; 3008 gCws->fNcolors = ncolors;; 3009 ; 3010 for (i = 0; i < ncolors; i++); 3011 gCws->fNewColors[i] = xcol[i].pixel;; 3012 ; 3013 delete [] xcol;; 3014}; 3015 ; 3016////////////////////////////////////////////////////////////////////////////////; 3017/// Returns index in orgcolors (and fNewColors) for pixel.; 3018 ; 3019Int_t TGX11::FindColor(ULong_t pixel, ULong_t *orgcolors, Int_t ncolors); 3020{; 3021 for (int i = 0; i < ncolors; i++); 3022 if (pixel == orgcolors[i]) return i;; 3023 ; 3024 Error(""FindColor"", ""did not find color, should never happen!"");; 3025 ; 3026 return 0;; 3027}; 3028 ; 3029////////////////////////////////////////////////////////////////////////////////; 3030/// Set color intensities for given color index.; 3031///; 3032/// \param [in] cindex : color index; 3033/// \param [in] r,g,b : red, green, blue intensities betwe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:100161,green,green,100161,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['green'],['green']
Energy Efficiency," if ncolors = 57 and colors=0, a monotonically increasing L value palette is used.; if ncolors = 58 and colors=0, a Cubehelix palette is used; (Cf. Dave Green's ""cubehelix"" colour scheme at http://www.mrao.cam.ac.uk/~dag/CUBEHELIX/); if ncolors = 59 and colors=0, a Green Red Violet palette is used.; if ncolors = 60 and colors=0, a Blue Red Yellow palette is used.; if ncolors = 61 and colors=0, an Ocean palette is used.; if ncolors = 62 and colors=0, a Color Printable On Grey palette is used.; if ncolors = 63 and colors=0, an Alpine palette is used.; if ncolors = 64 and colors=0, an Aquamarine palette is used.; if ncolors = 65 and colors=0, an Army palette is used.; if ncolors = 66 and colors=0, an Atlantic palette is used.; if ncolors = 67 and colors=0, an Aurora palette is used.; if ncolors = 68 and colors=0, an Avocado palette is used.; if ncolors = 69 and colors=0, a Beach palette is used.; if ncolors = 70 and colors=0, a Black Body palette is used.; if ncolors = 71 and colors=0, a Blue Green Yellow palette is used.; if ncolors = 72 and colors=0, a Brown Cyan palette is used.; if ncolors = 73 and colors=0, a CMYK palette is used.; if ncolors = 74 and colors=0, a Candy palette is used.; if ncolors = 75 and colors=0, a Cherry palette is used.; if ncolors = 76 and colors=0, a Coffee palette is used.; if ncolors = 77 and colors=0, a Dark Rain Bow palette is used.; if ncolors = 78 and colors=0, a Dark Terrain palette is used.; if ncolors = 79 and colors=0, a Fall palette is used.; if ncolors = 80 and colors=0, a Fruit Punch palette is used.; if ncolors = 81 and colors=0, a Fuchsia palette is used.; if ncolors = 82 and colors=0, a Grey Yellow palette is used.; if ncolors = 83 and colors=0, a Green Brown Terrain palette is used.; if ncolors = 84 and colors=0, a Green Pink palette is used.; if ncolors = 85 and colors=0, an Island palette is used.; if ncolors = 86 and colors=0, a Lake palette is used.; if ncolors = 87 and colors=0, a Light Temperature palette is used.; if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TColor.html:29783,Green,Green,29783,root/html604/TColor.html,https://root.cern,https://root.cern/root/html604/TColor.html,1,['Green'],['Green']
Energy Efficiency," if obj is last object. TObject * Before(const TObject* obj) const; Return the object before obj. Returns 0 if obj is first object. void Clear(Option_t* option = """"); Remove all objects from the array. Does not delete the objects; unless the TObjArray is the owner (set via SetOwner()). void Compress(); Remove empty slots from array. void Delete(Option_t* option = """"); Remove all objects from the array AND delete all heap based objects. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. TObject * FindObject(const char* name) const; Find an object in this collection using its name. Requires a sequential; scan till the object has been found. Returns 0 if object with specified; name is not found. TObject * FindObject(const TObject* obj) const; Find an object in this collection using the object's IsEqual(); member function. Requires a sequential scan till the object has; been found. Returns 0 if object is not found.; Typically this function is overridden by a more efficient version; in concrete collection classes (e.g. THashTable). void Streamer(TBuffer& ); Stream all objects in the array to or from the I/O buffer. TObject * First() const; Return the object in the first slot. TObject * Last() const; Return the object in the last filled slot. Returns 0 if no entries. Int_t GetEntries() const; Return the number of objects in array (i.e. number of non-empty slots).; Attention: use this method ONLY if you want to know the number of; non-empty slots. This function loops over the complete array and; is therefore very slow when applied in a loop. Most of the time you; better use GetEntriesFast() (only in case when there are no empty slots). Int_t GetAbsLast() const; Return absolute index to last object in array. Returns -1 in case; array is empty. Int_t GetLast() const; Return index of last object in array. Returns lowerBound-1 in case; array is empty. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer obj. If obj is 0 returns a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TObjArray.html:13993,efficient,efficient,13993,root/html534/TObjArray.html,https://root.cern,https://root.cern/root/html534/TObjArray.html,6,['efficient'],['efficient']
Energy Efficiency," if obj is last object. TObject * Before(const TObject* obj) const; Return the object before obj. Returns 0 if obj is first object. void Clear(Option_t* option = """"); Remove all objects from the array. Does not delete the objects; unless the TObjArray is the owner (set via SetOwner()). void Compress(); Remove empty slots from array. void Delete(Option_t* option = """"); Remove all objects from the array AND delete all heap based objects. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. TObject * FindObject(const char* name) const; Find an object in this collection using its name. Requires a sequential; scan till the object has been found. Returns 0 if object with specified; name is not found. TObject * FindObject(const TObject* obj) const; Find an object in this collection using the object's IsEqual(); member function. Requires a sequential scan till the object has; been found. Returns 0 if object is not found.; Typically this function is overridden by a more efficient version; in concrete collection classes (e.g. THashTable). void Streamer(TBuffer& b); Stream all objects in the array to or from the I/O buffer. TObject * First() const; Return the object in the first slot. TObject * Last() const; Return the object in the last filled slot. Returns 0 if no entries. Int_t GetEntries() const; Return the number of objects in array (i.e. number of non-empty slots).; Attention: use this method ONLY if you want to know the number of; non-empty slots. This function loops over the complete array and; is therefore very slow when applied in a loop. Most of the time you; better use GetEntriesFast() (only in case when there are no empty slots). Int_t GetAbsLast() const; Return absolute index to last object in array. Returns -1 in case; array is empty. Int_t GetLast() const; Return index of last object in array. Returns lowerBound-1 in case; array is empty. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer obj. If obj is 0 returns ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TObjArray.html:13862,efficient,efficient,13862,root/html528/TObjArray.html,https://root.cern,https://root.cern/root/html528/TObjArray.html,4,['efficient'],['efficient']
Energy Efficiency," in ROOT. First of all, in order to show better where the clusters on the various axes are, a 1D histogram is associated to each axis. These histograms (one per axis) are filled according to the number of lines passing through the bins. The histogram’s axis can be represented with colors or as bar charts. These histograms can be represented which colors (get from a palette according to the bin contents) or as bar charts. Both representations can be cumulated on the same plot. This technique allows seeing clearly where the clusters are on an individual axis but it does not give any hints about the correlations between the axes.; Avery simple technique allows to make the clusters appearing: Instead of painting solid lines we paint dotted lines. The cluttering of each individual line is reduced and the clusters show clearly as we can see on the next figure. The spacing between the dots is a parameter which can be adjusted in order to get the best results. Using dotted lines is a very simple method to reduce the cluttering. Interactivity is a very important aspect of the Parallel Coordinates plots. To really explore the data set it is essential to act directly with the events and the axes. For instance, changing the axes order may show clusters which were not visible in a different order. On the next figure the axes order has been changed interactively. We can see that many more clusters appear and all the “random spheres” we put in the data set are now clearly visible. Having moved the variables u,v,w after the variables x,y,z the correlation between these two sets of variables is clear also. Axis order is very important to show clusters. To pursue further data sets exploration we have implemented the possibility to define selections interactively. A selection is a set of ranges combined together. Within a selection, ranges along the same axis are combined with logical OR, and ranges on different axes with logical AND. A selection is displayed on top of the complete dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:613969,reduce,reduce,613969,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['reduce'],['reduce']
Energy Efficiency," in front of them. Origin axes (which generally pass through the middle of the 3D scene) are not depth clipped - so always visible.; A single orange sphere of fixed view port (window) size can be shown at any arbitrary position. Enable / disable the drawing with ‘Show’ checkbox. Enter X/Y/Z position in the edit boxes to set position. Initial position is at the center of the scene.; Set the guides using TGLViewer::SetGuideState e.g. to enable edge axes, and enable a reference marker at world position 50, 60, 100:; Double_t refPos[3] = {50.0,60.0,100.0};; v->SetGuideState(TGLUtil::kAxesEdge, kTRUE, refPos);; 9.13.2.8 Selecting Scene Shapes; You can select a single shape from your scene by pressing ‘Shift’ key, pointing and left clicking anywhere on the shape in the viewer. Selection is currently shown by drawing the shape-bounding box (not depth clipped) in white (polygon or wire frame render styles) or red (outline render style). Manipulators supported by the shape are drawn in red, green and blue while the non-supported ones are drawn in grey. To deselect a shape, either select another, or shift/click anywhere on the background (empty space) in the viewer. You cannot select Manipulators or Guides (Axes / Reference Marker).; 9.13.2.9 Editing Shapes; When a shape is selected, the viewer’s control pane shows the user interface that allows you to review and adjust the color and geometry properties of the shape.; Note: At present modifications to the shapes are local to the viewer - they are not propagated back to external objects/client that published to the viewer. The changes are preserved only until the viewer is closed. In some cases, this will never be feasible as there is not a one-to-one correspondence between a shape in the viewer and a single external object in which the modification could be stored.; 9.13.2.10 Colors / Style; Viewer Controls Pane ‘Style’ tab.; A full description of OpenGL materials, colors and lighting is beyond the scope of this document. You ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:398455,green,green,398455,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['green'],['green']
Energy Efficiency," in op: A += A * B ) ;  CPolar2DClass describing a polar 2D coordinate system based on r and phi Phi is restricted to be in the range [-PI,PI) ;  CPolar3DClass describing a polar coordinate system based on r, theta and phi Phi is restricted to be in the range [-PI,PI) ;  CPolynomialParametric Function class describing polynomials of order n ;  CPositionVector2DClass describing a generic position vector (point) in 2 dimensions ;  CPositionVector3DClass describing a generic position vector (point) in 3 dimensions ;  CPtEtaPhiE4DClass describing a 4D cylindrical coordinate system using Pt , Phi, Eta and E (or rho, phi, eta , T) The metric used is (-,-,-,+) ;  CPtEtaPhiM4DClass describing a 4D cylindrical coordinate system using Pt , Phi, Eta and M (mass) The metric used is (-,-,-,+) ;  CPxPyPzE4DClass describing a 4D cartesian coordinate system (x, y, z, t coordinates) or momentum-energy vectors stored as (Px, Py, Pz, E) ;  CPxPyPzM4DClass describing a 4D coordinate system or momentum-energy vectors stored as (Px, Py, Pz, M) ;  CQuasiRandomUser class for MathMore random numbers template on the Engine type ;  CQuaternionRotation class with the (3D) rotation represented by a unit quaternion (u, i, j, k) ;  CRandomDocumentation for the Random class ;  CRandomBaseEngine;  CRandomFunctions;  CRandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >Specialized implementation of the Random functions based on the GSL library ;  CRandomFunctionsImplDefinition of the generic impelmentation class for the RandomFunctions ;  CRandomFunctionsImpl< TRandomEngine >Implementation class for the RandomFunction for all the engined that derives from TRandomEngine class, which defines an interface which has TRandomEngine::Rndm() In this way we can have a common implementation for the RandomFunctions ;  CRetrieveMatrixStructure for getting sub matrices We have different cases according to the matrix representations ;  CRetrieveMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepStd< T, D3,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:42198,energy,energy,42198,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,2,['energy'],['energy']
Energy Efficiency," in op: A += A * B ) ;  CPolar2DClass describing a polar 2D coordinate system based on r and phi Phi is restricted to be in the range [-PI,PI) ;  CPolar3DClass describing a polar coordinate system based on r, theta and phi Phi is restricted to be in the range [-PI,PI) ;  CPolynomialParametric Function class describing polynomials of order n ;  CPositionVector2DClass describing a generic position vector (point) in 2 dimensions ;  CPositionVector3DClass describing a generic position vector (point) in 3 dimensions ;  CPtEtaPhiE4DClass describing a 4D cylindrical coordinate system using Pt , Phi, Eta and E (or rho, phi, eta , T) The metric used is (-,-,-,+) ;  CPtEtaPhiM4DClass describing a 4D cylindrical coordinate system using Pt , Phi, Eta and M (mass) The metric used is (-,-,-,+) ;  CPxPyPzE4DClass describing a 4D cartesian coordinate system (x, y, z, t coordinates) or momentum-energy vectors stored as (Px, Py, Pz, E) ;  CPxPyPzM4DClass describing a 4D coordinate system or momentum-energy vectors stored as (Px, Py, Pz, M) ;  CQuasiRandomUser class for MathMore random numbers template on the Engine type ;  CQuaternionRotation class with the (3D) rotation represented by a unit quaternion (u, i, j, k) ;  CRandomDocumentation for the Random class ;  CRandomFunctions;  CRandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >Specialized implementation of the Random functions based on the GSL library ;  CRandomFunctionsImplDefinition of the generic impelmentation class for the RandomFunctions ;  CRandomFunctionsImpl< TRandomEngine >Implementation class for the RandomFunction for all the engined that derives from TRandomEngine class, which defines an interface which has TRandomEngine::Rndm() In this way we can have a common implementation for the RandomFunctions ;  CRetrieveMatrixStructure for getting sub matrices We have different cases according to the matrix representations ;  CRetrieveMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepStd< T, D3, D4 > >;  CRetrieveM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:46437,energy,energy,46437,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,6,['energy'],['energy']
Energy Efficiency," in pad's status bar. Rotation and zooming. Rotation: When the plot is selected, it can be rotated by pressing and holding the left mouse button and move the cursor.; Zoom/Unzoom: Mouse wheel or 'j', 'J', 'k', 'K' keys. Panning; The selected plot can be moved in a pad's area by pressing and holding the left mouse button and the shift key.; Box cut; Surface, iso, box, TF3 and parametric painters support box cut by pressing the 'c' or 'C' key when the mouse cursor is in a plot's area. That will display a transparent box, cutting away part of the surface (or boxes) in order to show internal part of plot. This box can be moved inside the plot's area (the full size of the box is equal to the plot's surrounding box) by selecting one of the box cut axes and pressing the left mouse button to move it.; Plot specific interactions (dynamic slicing etc.); Currently, all gl-plots support some form of slicing. When back plane is selected (and if it's highlighted in green) you can press and hold left mouse button and shift key and move this back plane inside plot's area, creating the slice. During this ""slicing"" plot becomes semi-transparent. To remove all slices (and projected curves for surfaces) double click with left mouse button in a plot's area.; Surface with option ""GLSURF""; The surface profile is displayed on the slicing plane. The profile projection is drawn on the back plane by pressing ‘'p’or'P'` key.; TF3; The contour plot is drawn on the slicing plane. For TF3 the color scheme can be changed by pressing 's' or 'S'.; Box; The contour plot corresponding to slice plane position is drawn in real time.; Iso; Slicing is similar to ""GLBOX"" option.; Parametric plot; No slicing. Additional keys: 's' or 'S' to change color scheme - about 20 color schemes supported ('s' for ""scheme""); 'l' or 'L' to increase number of polygons ('l' for ""level"" of details), 'w' or 'W' to show outlines ('w' for ""wireframe"").; Highlight mode for histogram; SinceROOT version 6.15/01. Highlight mode; H",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:127505,green,green,127505,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['green'],['green']
Energy Efficiency," in src from escchar and copy to dst.Definition TString.cxx:2617; Printfvoid Printf(const char *fmt,...)Formats a string in a circular formatting buffer and prints the string.Definition TString.cxx:2503; StrDupchar * StrDup(const char *str)Duplicate the string str.Definition TString.cxx:2557; EscCharint EscChar(const char *src, char *dst, int dstlen, char *specchars, char escchar)Escape specchars in src with escchar and copy to dst.Definition TString.cxx:2593; TVirtualMutex.h; ThreadLocalStorage.h; Varargs.h; R__VA_COPY#define R__VA_COPY(to, from)Definition Varargs.h:48; va_#define va_(arg)Definition Varargs.h:35; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::IsATClass * IsA() const overrideDefinition TClass.h:618; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TMD5This code implements the MD5 message-digest algorithm.Definition TMD5.h:44; TMD5::AsStringconst char * AsString() constReturn message digest as string.Definition TMD5.cxx:220; TMD5::Updatevoid Update(const UChar_t *buf, UInt_t len)Update TMD5 object to reflect the concatenation of another buffer full of bytes.Definition TMD5.cxx:108; TMD5::Finalvoid Final()MD5 finalization, ends an MD5 message-digest operation, writing the the message digest and zeroizing ...Definition TMD5.cxx:167; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::Addvoid ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:94367,allocate,allocated,94367,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," in the browser. Or one could ‘hide’ any item from the user (but keep access with normal http requests). With such properties one could specify which item is drawn when web page is loaded, or configure monitoring. See tutorials/http/httpcontrol.C macro for more details.; Method Calls; Implement exe.json requests to be able to execute any method of registered objects. This request is used to provide remote TTree::Draw() functionality.; Misc; Correctly set ‘Cache-Control’ headers when replying to http requests. Better support of STL containers when converting objects into json with TBufferJSON class.; JavaScript ROOT. Several files can now be loaded simultaneously; Use d3.time.scale to display time scales; Implemented drag and drop to superimpose histograms or graphs; Allow selection of drawing option via context menu; Better support of touch devices; Provide simple layout, making it default; Allow to open ROOT files in online session (via url parameter); One could monitor simultaneously objects from server and root files; Implement ‘autocol’ draw option - when superimposing histograms, their line colors will be automatically assigned; Implement ‘nostat’ draw option - disabled stat drawing; Using ‘same’ identifier in item name, one can easily draw or superimpose similar items from different files. Could be used in URL like: ...&files=[file1.root,file2.root]&items=[file1.root/hpx, file2.root/_same_] ...&files=[file1.root,file2.root]&item=file1.root/hpx+file2.root/_same_ Main limitation - file names should have similar length.; When ‘autozoom’ specified in draw options, histogram zoomed into non-empty content. Same command available via context menu.; Item of ‘Text’ kind can be created. It is displayed as lain text in the browser. If property ‘mathjax’ specified, MathJax.js library will be loaded and used for rendering. See tutorials/http/httpcontrol.C macro for example.; When using foreignObject, provide workaround for absolute positioning problem in Chrome/Safari, see",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:10073,monitor,monitor,10073,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['monitor'],['monitor']
Energy Efficiency," index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or sh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:19633,allocate,allocated,19633,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,8,['allocate'],['allocated']
Energy Efficiency," index. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95) const. get confidence intervals for an array of n points x.; stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value. void GetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci, double cl = 0.95) const. evaluate confidence interval for the point specified in the passed data sets; the confidence interval are returned in the array ci; cl is the desired confidence interval value. int In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__FitResult.html:8478,allocate,allocates,8478,root/html526/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__FitResult.html,1,['allocate'],['allocates']
Energy Efficiency," input parameter names ;  CIFace;  CSpecialsIFace;  ►CRooFFTConvPdf;  CFFTCacheElem;  CRooFirstMomentRooFirstMoment represents the first, second, or third order derivative of any RooAbsReal as calculated (numerically) by the MathCore Richardson derivator class ;  CRooFIter;  CRooFitResult;  CRooFoamGeneratorClass RooFoamGenerator is a generic toy monte carlo generator that implement the TFOAM sampling technique on any positively valued function ;  CRooFormulaRooFormula an implementation of ROOT::v5::TFormula that interfaces it to RooAbsArg value objects ;  CRooFormulaVar;  CRooFracRemainderRooFracRemainder calculates the remainder fraction of a sum of RooAbsReal fraction, i.e (1 - sum_i a_i) ;  CRooFunctorLightweight interface adaptor that exports a RooAbsPdf as a functor ;  CRooFunctor1DBindingRooCFunction1Binding is a templated implementation of class RooAbsReal that binds generic C(++) functions to a RooAbsReal argument thus allowing generic C++ functions to be used as RooFit functions ;  CRooFunctor1DPdfBinding;  CRooFunctorBindingRooCFunction1Binding is a templated implementation of class RooAbsReal that binds generic C(++) functions to a RooAbsReal argument thus allowing generic C++ functions to be used as RooFit functions ;  CRooFunctorPdfBinding;  CRooGamma;  CRooGaussianPlain Gaussian p.d.f ;  CRooGaussKronrodIntegrator1DRooGaussKronrodIntegrator1D implements the Gauss-Kronrod integration algorithm ;  CRooGaussModelClass RooGaussModel implements a RooResolutionModel that models a Gaussian distribution ;  CRooGenContextClass RooGenContext implement a universal generator context for all RooAbsPdf classes that do not have or need a specialized generator context ;  CRooGenericPdfRooGenericPdf is a concrete implementation of a probability density function, which takes a RooArgList of servers and a C++ expression string defining how its value should be calculated from the given list of servers ;  CRooGenFitStudyRooGenFitStudy is an abstract base class for RooStud",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:90492,adapt,adaptor,90492,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['adapt'],['adaptor']
Energy Efficiency," integral which ought to be unity. Double_t ComputeMidspread(); Computes the inter-quartile range from the data. void SetCanonicalBandwidth(); Computes the user's input kernel function canonical bandwidth. void SetKernelSigma2(); Computes the user's input kernel function sigma2. TF1* GetKDEFunction(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0); Returns the estimated density. TF1* GetPDFUpperConfidenceInterval(Double_t confidenceLevel = 0.95, UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0); Returns the upper estimated density. TF1* GetPDFLowerConfidenceInterval(Double_t confidenceLevel = 0.95, UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0); Returns the upper estimated density. TF1* GetKDEApproximateBias(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0); Returns the approximate bias. explicit TKDE(UInt_t events = 0, const Double_t* data = 0, Double_t xMin = 0.0, Double_t xMax = 0.0, Option_t* option = ""KernelType:Gaussian;Iteration:Adaptive;Mirror:noMirror;Binning:RelaxedBinning"", Double_t rho = 1.0). Double_t GetValue(Double_t x) const; { return (*this)(x); }. TF1 * GetDrawnFunction(); get the drawn object to chanage settings; These objects are managed by TKDE and should not be deleted by the user. { return fPDF;}. TF1 * GetDrawnUpperFunction(); { return fUpperPDF;}. TF1 * GetDrawnLowerFunction(); { return fLowerPDF;}. TGraphErrors * GetDrawnGraph(); { return fGraph;}. TKDE operator=(TKDE& kde). Double_t GaussianKernel(Double_t x) const; Returns the kernel evaluation at x. Double_t EpanechnikovKernel(Double_t x) const. Double_t BiweightKernel(Double_t x) const; Returns the kernel evaluation at x. Double_t CosineArchKernel(Double_t x) const; Returns the kernel evaluation at x. Double_t ApproximateBias(const Double_t* x, const Double_t* ) const; { return GetBias(*x); }. void SetHistogram(). » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or sugge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TKDE.html:18233,Adapt,Adaptive,18233,root/html534/TKDE.html,https://root.cern,https://root.cern/root/html534/TKDE.html,1,['Adapt'],['Adaptive']
Energy Efficiency," integral which ought to be unity. Double_t ComputeMidspread(); Computes the inter-quartile range from the data. void SetCanonicalBandwidth(); Computes the user's input kernel function canonical bandwidth. void SetKernelSigma2(); Computes the user's input kernel function sigma2. TF1* GetKDEFunction(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0); Returns the estimated density. TF1* GetPDFUpperConfidenceInterval(Double_t confidenceLevel = 0.95, UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0); Returns the upper estimated density. TF1* GetPDFLowerConfidenceInterval(Double_t confidenceLevel = 0.95, UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0); Returns the upper estimated density. TF1* GetKDEApproximateBias(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0); Returns the approximate bias. explicit TKDE(UInt_t events = 0, const Double_t* data = 0, Double_t xMin = 0.0, Double_t xMax = 0.0, Option_t* option = ""KernelType:Gaussian;Iteration:Adaptive;Mirror:noMirror;Binning:RelaxedBinning"", Double_t rho = 1.0). Double_t GetValue(Double_t x) const; { return (*this)(x); }. TF1 * GetDrawnFunction(); get the drawn object to chanage settings; These objects are managed by TKDE and should not be deleted by the user. { return fPDF;}. TF1 * GetDrawnUpperFunction(); { return fUpperPDF;}. TF1 * GetDrawnLowerFunction(); { return fLowerPDF;}. TGraphErrors * GetDrawnGraph(); { return fGraph;}. TKDE operator=(TKDE& kde). Double_t GaussianKernel(Double_t x) const; Returns the kernel evaluation at x. Double_t EpanechnikovKernel(Double_t x) const. Double_t BiweightKernel(Double_t x) const; Returns the kernel evaluation at x. Double_t CosineArchKernel(Double_t x) const; Returns the kernel evaluation at x. Double_t ApproximateBias(const Double_t* x, const Double_t* ) const; { return GetBias(*x); }. void SetHistogram(). » Last changed: root/hist:$Id: TKDE.h 37543 2010-12-11 14:14:05Z moneta $ » Last generated: 2011-11-03 20:19; This page has been aut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TKDE.html:18214,Adapt,Adaptive,18214,root/html532/TKDE.html,https://root.cern,https://root.cern/root/html532/TKDE.html,1,['Adapt'],['Adaptive']
Energy Efficiency," is a derived class from ROOT::Math::IBaseFunctionMultiDim and ROOT::Math::IBaseParam ;  CIParametricFunctionOneDimSpecialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is a derived class from ROOT::Math::IBaseFunctionOneDim and ROOT::Math::IBaseParam ;  CIParametricGradFunctionMultiDimTemplInterface (abstract class) for parametric gradient multi-dimensional functions providing in addition to function evaluation with respect to the coordinates also the gradient with respect to the parameters, via the method ParameterGradient ;  CIParametricGradFunctionOneDimInterface (abstract class) for parametric one-dimensional gradient functions providing in addition to function evaluation with respect the coordinates also the gradient with respect to the parameters, via the method ParameterGradient ;  CIRootFinderMethodInterface for finding function roots of one-dimensional functions ;  CKahanSumThe Kahan compensate summation algorithm significantly reduces the numerical error in the total obtained by adding a sequence of finite precision floating point numbers ;  ►CKDTree;  CBaseNode;  CBinNode;  CComparePoints;  CCut;  CHeadNode;  Citerator;  CSplitNode;  CTerminalNode;  CKelvinFunctionsThis class calculates the Kelvin functions Ber(x), Bei(x), Ker(x), Kei(x), and their first derivatives ;  CLCGEngine;  CLocalCoordinateSystemTagTag for identifying vectors based on a local coordinate system ;  CLorentzRotationLorentz transformation class with the (4D) transformation represented by a 4x4 orthosymplectic matrix ;  CLorentzVectorClass describing a generic LorentzVector in the 4D space-time, using the specified coordinate system for the spatial vector part ;  CLSResidualFuncLSResidualFunc class description ;  CMathMoreLib;  CMatRepStdExpression wrapper class for Matrix objects ;  CMatRepSymMatRepSym Matrix storage representation for a symmetric matrix of dimension NxN This class is a template on the contained type and on the symmetric ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:40795,reduce,reduces,40795,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,5,['reduce'],['reduces']
Energy Efficiency," is being deleted or will soon be) is no longer referenced by this TTree. ;  ; virtual void Refresh ();  Refresh contents of this tree and its branches from the current status on disk. ;  ; virtual void RegisterExternalFriend (TFriendElement *);  Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is because this chain is a friend of another TChain) ;  ; virtual void RemoveExternalFriend (TFriendElement *);  Removes external friend. ;  ; virtual void RemoveFriend (TTree *);  Remove a friend from the list of friends. ;  ; virtual void Reset (Option_t *option="""");  Reset baskets, buffers and entries count in all branches and leaves. ;  ; virtual void ResetAfterMerge (TFileMergeInfo *);  Resets the state of this TTree after a merge (keep the customization but forget the data). ;  ; virtual void ResetBranchAddress (TBranch *);  Tell all of our branches to set their addresses to zero. ;  ; virtual void ResetBranchAddresses ();  Tell all of our branches to drop their current objects and allocate new ones. ;  ; virtual Long64_t Scan (const char *varexp="""", const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Loop over tree entries and print entries passing selection. ;  ; virtual bool SetAlias (const char *aliasName, const char *aliasFormula);  Set a tree variable alias. ;  ; virtual void SetAutoFlush (Long64_t autof=-30000000);  This function may be called at the start of a program to change the default value for fAutoFlush. ;  ; virtual void SetAutoSave (Long64_t autos=-300000000);  In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point. ;  ; virtual void SetBasketSize (const char *bname, Int_t buffsize=16000);  Set a branch's basket size. ;  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr);  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T *add, TBranch ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:36906,allocate,allocate,36906,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,3,['allocate'],['allocate']
Energy Efficiency," it to be used here. However, if the order is kept small (< 6?) any inefficiency is negligible for in-memory sorting. Knuth points out that balanced trees are actually preferable for memory sorting. I'm not sure that I believe this, but it's interesting. Also, deleting elements from balanced binary trees, being beyond the scope of Knuth's book (p. 465), is beyond my scope. B-trees are good enough.; A B-tree is declared to be of a certain ORDER (3 by default). This number determines the number of keys contained in any interior node of the tree. Each interior node will contain ORDER keys, and therefore ORDER+1 pointers to sub-trees. The keys are numbered and indexed 1 to ORDER while the pointers are numbered and indexed 0 to ORDER. The 0th ptr points to the sub-tree of all elements that are less than key[1]. Ptr[1] points to the sub-tree that contains all the elements greater than key[1] and less than key[2]. etc. The array of pointers and keys is allocated as ORDER+1 pairs of keys and nodes, meaning that one key field (key[0]) is not used and therefore wasted. Given that the number of interior nodes is small, that this waste allows fewer cases of special code, and that it is useful in certain of the methods, it was felt to be a worthwhile waste.; The size of the exterior nodes (leaf nodes) does not need to be related to the size of the interior nodes at all. Since leaf nodes contain only keys, they may be as large or small as we like independent of the size of the interior nodes. For no particular reason other than it seems like a good idea, we will allocate 2*(ORDER+1) keys in each leaf node, and they will be numbered and indexed from 0 to 2*ORDER+1. It does have the advantage of keeping the size of the leaf and interior arrays the same, so that if we find allocation and de-allocation of these arrays expensive, we can modify their allocation to use a garbage ring, or something.; Both of these numbers will be run-time constants associated with each tree (each tree at",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBtree.html:3916,allocate,allocated,3916,doc/master/classTBtree.html,https://root.cern,https://root.cern/doc/master/classTBtree.html,1,['allocate'],['allocated']
Energy Efficiency," it to the specified year, month,; day, time, hour, minute, second and nanosec.; If !isUTC then it is assumed to be the standard local time zone. If local time is PST then one can use; TTimeStamp(year,month,day,hour,min,sec,nsec,kFALSE,0);; or; Int_t secOffset = 8*60*60;; TTimeStamp(year,month,day,hour,min,sec,nsec,kTRUE,8*60*60);. TTimeStamp(UInt_t date, UInt_t time, UInt_t nsec, Bool_t isUTC = kTRUE, Int_t secOffset = 0); Create a TTimeStamp and set it to the specified date, time, nanosec.; If !isUTC then it is assumed to be the standard local time zone. TTimeStamp(UInt_t tloc, Bool_t isUTC = kTRUE, Int_t secOffset = 0, Bool_t dosDate = kFALSE); Create a TTimeStamp and set it to tloc which must be a time_t value; returned by time(). This value is the number of seconds since the EPOCH; (i.e. 00:00:00 on Jan 1m 1970). If dosDate is true then the input; is a dosDate value. const Char_t * AsString(Option_t* option = """") const; Return the date & time as a string. Result is pointer to a statically allocated string.; User should copy this into their own buffer before calling; this method again. Option ""l"" returns it in local zone format; (can be applied to default or compact format). Default format is RFC822 compliant:; ""Mon, 02 Jan 2001 18:11:12 +0000 (GMT) +999999999 nsec""; ""Mon, 02 Jan 2001 10:11:12 -0800 (PST) +999999999 nsec"". Option ""c"" compact is (almost) ISO 8601 compliant:; ""2001-01-02 18:11:12.9999999999Z""; ""2001-01-02 10:11:12.9999999999-0800"" if PST; * uses ""-"" as date separator as specified in ISO 8601; * uses ""."" rather than preferred "","" for decimal separator; * -HHMM is the difference between local and UTC (if behind, + if ahead).; The ""-HHMM"" is replaced with ""Z"" if given as UTC.; To be strictly conforming it should use ""T"" instead of the; blank separating the date and time. Option ""2"" returns as {sec,nsec} integers. Option ""s"" returns ""2001-01-02 18:11:12"" with an implied UTC,; overrides ""l"" option. Internally uses a circular list of buffers to avoid pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTimeStamp.html:4921,allocate,allocated,4921,root/html528/TTimeStamp.html,https://root.cern,https://root.cern/root/html528/TTimeStamp.html,4,['allocate'],['allocated']
Energy Efficiency," iy);; 3266 } else {; 3267 XWarpPointer((Display*)fDisplay, None, (Window) id, 0, 0, 0, 0, ix, iy);; 3268 }; 3269}; 3270 ; 3271////////////////////////////////////////////////////////////////////////////////; 3272/// Write the pixmap wid in the bitmap file pxname.; 3273///; 3274/// \param [in] wid : Pixmap address; 3275/// \param [in] w,h : Width and height of the pixmap.; 3276/// \param [in] pxname : pixmap name; 3277 ; 3278void TGX11::WritePixmap(int wid, unsigned int w, unsigned int h, char *pxname); 3279{; 3280 unsigned int wval, hval;; 3281 wval = w;; 3282 hval = h;; 3283 ; 3284 gTws = &fWindows[wid];; 3285 XWriteBitmapFile((Display*)fDisplay, pxname, gTws->fDrawing, wval, hval, -1, -1);; 3286}; 3287 ; 3288 ; 3289//; 3290// Functions for GIFencode(); 3291//; 3292 ; 3293static FILE *gOut; // output unit used WriteGIF and PutByte; 3294static XImage *gXimage = nullptr; // image used in WriteGIF and GetPixel; 3295 ; 3296extern ""C"" {; 3297 int GIFquantize(UInt_t width, UInt_t height, Int_t *ncol, Byte_t *red, Byte_t *green,; 3298 Byte_t *blue, Byte_t *outputBuf, Byte_t *outputCmap);; 3299 long GIFencode(int Width, int Height, Int_t Ncol, Byte_t R[], Byte_t G[], Byte_t B[], Byte_t ScLine[],; 3300 void (*get_scline) (int, int, Byte_t *), void (*pb)(Byte_t));; 3301 int GIFdecode(Byte_t *gifArr, Byte_t *pixArr, int *Width, int *Height, int *Ncols, Byte_t *R, Byte_t *G, Byte_t *B);; 3302 int GIFinfo(Byte_t *gifArr, int *Width, int *Height, int *Ncols);; 3303}; 3304 ; 3305////////////////////////////////////////////////////////////////////////////////; 3306/// Get pixels in line y and put in array scline.; 3307 ; 3308static void GetPixel(int y, int width, Byte_t *scline); 3309{; 3310 for (int i = 0; i < width; i++); 3311 scline[i] = Byte_t(XGetPixel(gXimage, i, y));; 3312}; 3313 ; 3314////////////////////////////////////////////////////////////////////////////////; 3315/// Put byte b in output stream.; 3316 ; 3317static void PutByte(Byte_t b); 3318{; 3319 if (ferror(gOut)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:108990,green,green,108990,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['green'],['green']
Energy Efficiency," k, Int_t eoffset) const;  ; Double_t GetValueSTL (TVirtualCollectionProxy *cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const;  ; Double_t GetValueSTLP (TVirtualCollectionProxy *cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const;  ; TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions (Bool_t forCollection);  ; TStreamerInfoActions::TActionSequence * GetWriteObjectWiseActions ();  ; TStreamerInfoActions::TActionSequence * GetWriteTextActions ();  ; TClass * IsA () const override;  ; void ls (Option_t *option="""") const override;  List the TStreamerElement list and also the precomputed tables if option contains the string ""incOrig"", also prints the original (non-optimized elements in the list of compiled elements. ;  ; Bool_t MatchLegacyCheckSum (UInt_t checksum) const;  Return true if the checksum passed as argument is one of the checksum value produced by the older checksum calculation algorithm. ;  ; void * New (void *obj=nullptr) override;  An emulated object is created at address obj, if obj is null we allocate memory for the object. ;  ; void * NewArray (Long_t nElements, void *ary=nullptr) override;  An array of emulated objects is created at address ary, if ary is null, we allocate memory for the array. ;  ; TVirtualStreamerInfo * NewInfo (TClass *cl) override;  ; void PrintValue (const char *name, char *pointer, Int_t i, Int_t len, Int_t lenmax=1000) const;  print value of element i in object at pointer The function may be called in two ways: -method1 len < 0 i is assumed to be the TStreamerElement number i in StreamerInfo -method2 len >= 0 i is the type address of variable is directly pointer. ;  ; void PrintValueClones (const char *name, TClonesArray *clones, Int_t i, Int_t eoffset, Int_t lenmax=1000) const;  Print value of element i in a TClonesArray. ;  ; void PrintValueSTL (const char *name, TVirtualCollectionProxy *cont, Int_t i, Int_t eoffset, Int_t lenmax=1000) const;  Print value of element i in a TClonesArray. ;  ; template<class ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerInfo.html:10989,allocate,allocate,10989,doc/master/classTStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTStreamerInfo.html,1,['allocate'],['allocate']
Energy Efficiency," kBASelfAlloc; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TGeoNode**fArray![fMaxLevel+1] Array of nodes; Int_tfLevelBranch depth; TGeoHMatrixfMatrixGlobal matrix (owned); Int_tfMaxLevelArray length; TGeoNode*fRealArray[1]Beginning address of the array of nodes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBranchArray(Int_t level); Constructor. Alocates the array with a size given by level. TGeoBranchArray * MakeInstance(size_t maxlevel); Make an instance of the class which allocates the node array. To be; released using ReleaseInstance. If addr is non-zero, the user promised that; addr contains at least that many bytes: size_t needed = SizeOf(maxlevel);. TGeoBranchArray * MakeInstanceAt(size_t maxlevel, void* addr); Make an instance of the class which allocates the node array. To be; released using ReleaseInstance. If addr is non-zero, the user promised that; addr contains at least that many bytes: size_t needed = SizeOf(maxlevel);. TGeoBranchArray * MakeCopy(const TGeoBranchArray& other); Make a copy of a branch array at the location (if indicated). TGeoBranchArray * MakeCopyAt(const TGeoBranchArray& other, void* addr); Make a copy of a branch array at the location (if indicated). void CopyTo(TGeoBranchArray* dest); Raw memcpy of the branch array content to an existing destination. void ReleaseInstance(TGeoBranchArray* obj); Releases the space allocated for the object. void UpdateArray(size_t nobj); Updates the internal addresses for n contiguous objects which have the same; fMaxLevel; Updates the internal addresses for n contiguous objects which have the same fMaxLevel. TGeoBranchArray(const TGeoBranchArray& ); Copy constructor. Not callable anymore. Use TGeoBranchArray::MakeCopy instead. TGeoB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBranchArray.html:7802,allocate,allocates,7802,root/html534/TGeoBranchArray.html,https://root.cern,https://root.cern/root/html534/TGeoBranchArray.html,2,['allocate'],['allocates']
Energy Efficiency," kFALSE) the result is divided; 469/// by sqrt(2*Pi)*sigma.; 470 ; 471Double_t TMath::Gaus(Double_t x, Double_t mean, Double_t sigma, Bool_t norm); 472{; 473 if (sigma == 0) return 1.e30;; 474 Double_t arg = (x-mean)/sigma;; 475 // for |arg| > 39 result is zero in double precision; 476 if (arg < -39.0 || arg > 39.0) return 0.0;; 477 Double_t res = TMath::Exp(-0.5*arg*arg);; 478 if (!norm) return res;; 479 return res/(2.50662827463100024*sigma); //sqrt(2*Pi)=2.50662827463100024; 480}; 481 ; 482////////////////////////////////////////////////////////////////////////////////; 483/// The LANDAU function.; 484///; 485/// mu is a location parameter and correspond approximately to the most probable value; 486/// and sigma is a scale parameter (not the sigma of the full distribution which is not defined); 487/// Note that for mu=0 and sigma=1 (default values) the exact location of the maximum of the distribution; 488/// (most proper value) is at x = -0.22278; 489/// This function has been adapted from the CERNLIB routine G110 denlan.; 490/// If norm=kTRUE (default is kFALSE) the result is divided by sigma; 491 ; 492Double_t TMath::Landau(Double_t x, Double_t mu, Double_t sigma, Bool_t norm); 493{; 494 if (sigma <= 0) return 0;; 495 Double_t den = ::ROOT::Math::landau_pdf( (x-mu)/sigma );; 496 if (!norm) return den;; 497 return den/sigma;; 498}; 499 ; 500////////////////////////////////////////////////////////////////////////////////; 501/// Computation of ln[gamma(z)] for all z.; 502///; 503/// C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86.; 504///; 505/// The accuracy of the result is better than 2e-10.; 506///; 507/// \author NvE 14-nov-1998 UU-SAP Utrecht; 508 ; 509Double_t TMath::LnGamma(Double_t z); 510{; 511 return ::ROOT::Math::lgamma(z);; 512}; 513 ; 514////////////////////////////////////////////////////////////////////////////////; 515/// Normalize a vector v in place.; 516/// Returns the norm of the original vector.; 517 ; 518Float_t TMath::Normaliz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:15659,adapt,adapted,15659,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['adapt'],['adapted']
Energy Efficiency," kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  VariableTransformBase (DataSetInfo &dsi, Types::EVariableTransform tf, const TString &trfName);  standard constructor ;  ; virtual ~VariableTransformBase (void);  ; virtual void AttachXMLTo (void *parent)=0;  create XML description the transformation (write out info of selected variables) ;  ; virtual void CountVariableTypes (UInt_t &nvars, UInt_t &ntgts, UInt_t &nspcts) const;  count variables, targets and spectators ;  ; virtual Bool_t GetInput (const Event *event, std::vector< Float_t > &input, std::vector< Char_t > &mask, Bool_t backTransform=kFALSE) const;  select the values from the event ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; TString GetShortName () const;  ; virtual std::vector< TString > * GetTransformationStrings (Int_t cls) const;  TODO --> adapt to variable,target,spectator selection default transformation output --> only indicate that transformation occurred. ;  ; Types::EVariableTransform GetVariableTransform () const;  ; virtual void Initialize ()=0;  ; virtual const Event * InverseTransform (const Event *const, Int_t cls) const =0;  ; virtual TClass * IsA () const;  ; Bool_t IsCreated () const;  ; Bool_t IsEnabled () const;  ; Bool_t IsNormalised () const;  ; MsgLogger & Log () const;  ; virtual void MakeFunction (std::ostream &fout, const TString &fncName, Int_t part, UInt_t trCounter, Int_t cls)=0;  getinput and setoutput equivalent ;  ; virtual Bool_t PrepareTransformation (const std::vector< Event * > &)=0;  ; virtual void PrintTransformation (std::ostream &);  ; virtual void ReadFromXML (void *trfnode)=0;  Read the input variables from the XML node. ;  ; virtual void ReadTransformationFromStream (std::istream &istr, const TString &classname="""")=0;  ; virtual void SelectInput (const TString &inputVariables, Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1VariableTransformBase.html:2172,adapt,adapt,2172,doc/master/classTMVA_1_1VariableTransformBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1VariableTransformBase.html,1,['adapt'],['adapt']
Energy Efficiency," kSingleKey; kOverwrite; kWriteDelete; };. protected:. ULong_tTGX11::fBlackPixelValue of black pixel in colormap; Int_tTGX11::fBlueDivBlue value divider; Int_tTGX11::fBlueShiftBits to left shift blue; Float_tTGX11::fCharacterUpXCharacter Up vector along X; Float_tTGX11::fCharacterUpYCharacter Up vector along Y; unsigned longTGX11::fColormapDefault colormap, 0 if b/w; Int_tTGX11::fDepthNumber of color planes; Display*TGX11::fDisplayPointer to display; TVirtualX::EDrawModeTVirtualX::fDrawModeDrawing mode; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Int_tTGX11::fGreenDivGreen value divider; Int_tTGX11::fGreenShiftBits to left shift green; Bool_tTGX11::fHasTTFontsTrue when TrueType fonts are used; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TStringTNamed::fNameobject identifier; Int_tTGX11::fRedDivRed value divider, -1 if no TrueColor visual; Int_tTGX11::fRedShiftBits to left shift red, -1 if no TrueColor visual; unsigned longTGX11::fRootWinRoot window used as parent of all windows; Int_tTGX11::fScreenNumberScreen number; Int_tTGX11::fTextAlignText alignment (set in SetTextAlign); Short_tTAttText::fTextAlignText alignment; Int_tTGX11::fTextAlignHText Alignment Horizontal; Int_tTGX11::fTextAlignVText Alignment Vertical; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTGX11::fTextMagnitudeText Magnitude; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; unsigned longTGX11::fVisRootWinRoot window with fVisual to be used to create GC's and XImages; Visual*TGX11::fVisualPointer to visual used by all windows; ULong_tTGX11::fWhitePixelValue of white pixel in colormap. private:. FT_VectorfAlignalignment vector; TXftFontHa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGX11TTF.html:23348,green,green,23348,root/html528/TGX11TTF.html,https://root.cern,https://root.cern/root/html528/TGX11TTF.html,4,['green'],['green']
Energy Efficiency," kSingular; };; enum { kWorkMax; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfColLwbColumn lower bound of decomposed matrix; Double_tfConditionmatrix condition number; Double_tfDet1determinant mantissa; Double_tfDet2determinant exponent for powers of 2; Int_tfRowLwbRow lower bound of decomposed matrix; Double_tfTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t Hager(Double_t& est, Int_t iter = 5). void DiagProd(const TVectorD& diag, Double_t tol, Double_t& d1, Double_t& d2). Double_t Condition(); Matrix condition number. Bool_t MultiSolve(TMatrixD& B); Solve set of equations with RHS in columns of B. void Det(Double_t& d1, Double_t& d2); Matrix determinant det = d1*TMath::Power(2.,d2). void Print(Option_t* opt = """") const; Print class members. TDecompBase & operator=(const TDecompBase& source); Assignment operator. Double_t SetTol(Double_t newTol). void ResetStatus(); { for (Int_t i = 14; i < 22; i++) ResetBit(BIT(i)); }. const TMatrixDBase & GetDecompMatrix() const. virtual ~TDecompBase(); {}. Double_t GetTol() const; { return fTol; }. Double_t GetDet1() const; { return fDet1; }. Double_t GetDet2() const; { return fDet2; }. Double_t GetCondition() const; { return fCondition; }. Int_t GetNrows() const. Int_t GetNcols() const. Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetColLwb() const; { return fColLwb; }. Bool_t Decompose(). Bool_t Solve(TVectorD& b). TVectorD Solve(const TVectorD& b, Bool_t& ok). Bool_t Solve(TMatrixDColumn& b). Bool_t TransSolve(TVectorD& b). TVectorD TransSolve(const TVectorD& b, Bool_t& ok). Bool_t TransSolve(TMatrixDColumn& b). » Last changed: root/matrix:$Id$ » Last generated: 2015-03-12",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDecompBase.html:10690,Power,Power,10690,root/html534/TDecompBase.html,https://root.cern,https://root.cern/root/html534/TDecompBase.html,1,['Power'],['Power']
Energy Efficiency," kSingular; };; enum { kWorkMax; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfColLwbColumn lower bound of decomposed matrix; Double_tfConditionmatrix condition number; Double_tfDet1determinant mantissa; Double_tfDet2determinant exponent for powers of 2; Int_tfRowLwbRow lower bound of decomposed matrix; Double_tfTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t Hager(Double_t& est, Int_t iter = 5). void DiagProd(const TVectorD& diag, Double_t tol, Double_t& d1, Double_t& d2). Double_t Condition(); Matrix condition number. Bool_t MultiSolve(TMatrixD& B); Solve set of equations with RHS in columns of B. void Det(Double_t& d1, Double_t& d2); Matrix determinant det = d1*TMath::Power(2.,d2). void Print(Option_t* opt = """") const; Print class members. TDecompBase & operator=(const TDecompBase& source); Assignment operator. Double_t SetTol(Double_t newTol). void ResetStatus(); { for (Int_t i = 14; i < 22; i++) ResetBit(BIT(i)); }. const TMatrixDBase & GetDecompMatrix() const. virtual ~TDecompBase(); {}. Double_t GetTol() const; { return fTol; }. Double_t GetDet1() const; { return fDet1; }. Double_t GetDet2() const; { return fDet2; }. Double_t GetCondition() const; { return fCondition; }. Int_t GetNrows() const. Int_t GetNcols() const. Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetColLwb() const; { return fColLwb; }. Bool_t Decompose(). Bool_t Solve(TVectorD& b). TVectorD Solve(const TVectorD& b, Bool_t& ok). Bool_t Solve(TMatrixDColumn& b). Bool_t TransSolve(TVectorD& b). TVectorD TransSolve(const TVectorD& b, Bool_t& ok). Bool_t TransSolve(TMatrixDColumn& b). » Last changed: root/matrix:$Id: TDecompBase.h 20882 2007-11-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDecompBase.html:10671,Power,Power,10671,root/html532/TDecompBase.html,https://root.cern,https://root.cern/root/html532/TDecompBase.html,1,['Power'],['Power']
Energy Efficiency," kTRUE); virtual TClass*ProjectedClass(const TEveProjection* p) const; virtual voidTEveProjectable::PropagateMainColor(Color_t color, Color_t old_color); virtual voidTEveElement::PropagateMainColorToProjecteds(Color_t color, Color_t old_color); virtual voidTEveProjectable::PropagateMainTransparency(Char_t t, Char_t old_t); virtual voidTEveElement::PropagateMainTransparencyToProjecteds(Char_t t, Char_t old_t); virtual voidTEveProjectable::PropagateRenderState(Bool_t rnr_self, Bool_t rnr_children); virtual voidTEveElement::PropagateRnrStateToProjecteds(); virtual voidTEveProjectable::PropagateVizParams(TEveElement* el = 0); virtual voidTEveElement::PropagateVizParamsToElements(TEveElement* el = 0); virtual voidTEveElement::PropagateVizParamsToProjecteds(); virtual TEveTrans*TEveElement::PtrMainTrans(Bool_t create = kTRUE); virtual Int_tTObject::Read(const char* name); voidTEveElement::RecheckImpliedSelections(); virtual voidTObject::RecursiveRemove(TObject* obj); voidTEveLine::ReduceSegmentLengths(Float_t max); const TEveElement::List_t&TEveElement::RefChildren() const; virtual TEveTrans&TEveElement::RefMainTrans(); TEveTrack::vPathMark_t&RefPathMarks(); const TEveTrack::vPathMark_t&RefPathMarks() const; virtual voidTEveElement::RemoveElement(TEveElement* el); virtual voidTEveElement::RemoveElementLocal(TEveElement* el); virtual voidTEveElement::RemoveElements(); virtual voidTEveElement::RemoveElementsLocal(); virtual Bool_tTEveElement::RemoveFromListTree(TGListTree* ltree, TGListTreeItem* parent_lti); virtual Int_tTEveElement::RemoveFromListTrees(TEveElement* parent); virtual voidTEveElement::RemoveParent(TEveElement* re); virtual voidTEveProjectable::RemoveProjected(TEveProjected* p); voidTEvePointSet::Reset(Int_t n_points = 0, Int_t n_int_ids = 0); voidTEveElement::ResetAllCSCBits(); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); virtual voidTAttMarker::ResetAttMarker(Option_t* toption = """"); voidTAttBBox::ResetBBox(); voidTObject::ResetBit(UInt_t f); vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveTrack.html:17130,Reduce,ReduceSegmentLengths,17130,root/html532/TEveTrack.html,https://root.cern,https://root.cern/root/html532/TEveTrack.html,4,['Reduce'],['ReduceSegmentLengths']
Energy Efficiency," kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMonitor.html:10369,monitor,monitor,10369,root/html528/TMonitor.html,https://root.cern,https://root.cern/root/html528/TMonitor.html,6,['monitor'],['monitor']
Energy Efficiency," kWriteDelete; };. protected:. ULong_tTGX11::fBlackPixelValue of black pixel in colormap; Int_tTGX11::fBlueDivBlue value divider; Int_tTGX11::fBlueShiftBits to left shift blue; Float_tTGX11::fCharacterUpXCharacter Up vector along X; Float_tTGX11::fCharacterUpYCharacter Up vector along Y; unsigned longTGX11::fColormapDefault colormap, 0 if b/w; Int_tTGX11::fDepthNumber of color planes; Display*TGX11::fDisplayPointer to display; TVirtualX::EDrawModeTVirtualX::fDrawModeDrawing mode; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Int_tTGX11::fGreenDivGreen value divider; Int_tTGX11::fGreenShiftBits to left shift green; Bool_tTGX11::fHasTTFontsTrue when TrueType fonts are used; Bool_tTGX11::fHasXftTrue when XftFonts are used; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TStringTNamed::fNameobject identifier; Int_tTGX11::fRedDivRed value divider, -1 if no TrueColor visual; Int_tTGX11::fRedShiftBits to left shift red, -1 if no TrueColor visual; unsigned longTGX11::fRootWinRoot window used as parent of all windows; Int_tTGX11::fScreenNumberScreen number; Int_tTGX11::fTextAlignText alignment (set in SetTextAlign); Short_tTAttText::fTextAlignText alignment; Int_tTGX11::fTextAlignHText Alignment Horizontal; Int_tTGX11::fTextAlignVText Alignment Vertical; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTGX11::fTextMagnitudeText Magnitude; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; unsigned longTGX11::fVisRootWinRoot window with fVisual to be used to create GC's and XImages; Visual*TGX11::fVisualPointer to visual used by all windows; ULong_tTGX11::fWhitePixelValue of white pixel in colormap. private:. FT_VectorfAlignalig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGX11TTF.html:24741,green,green,24741,root/html534/TGX11TTF.html,https://root.cern,https://root.cern/root/html534/TGX11TTF.html,2,['green'],['green']
Energy Efficiency," large number of; bins (eg 100000).; - in version 3.10/02, a new static function TProfile::Approximate; is introduced to enable or disable (default) the approximation.; (see also comments in TProfile::GetBinError). Option_t * GetErrorOption() const; -*-*Return option to compute profile2D errors; *-* =========================================. void GetStats(Double_t* stats) const; fill the array stats from the contents of this profile; The array stats must be correctly dimensionned in the calling program.; stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2; stats[4] = sumwy; stats[5] = sumwy2; stats[6] = sumwxy; stats[7] = sumwz; stats[8] = sumwz2. If no axis-subrange is specified (via TAxis::SetRange), the array stats; is simply a copy of the statistics quantities computed at filling time.; If a sub-range is specified, the function recomputes these quantities; from the bin contents in the current axis range. void LabelsDeflate(Option_t* axis = ""X""); Reduce the number of bins for this axis to the number of bins having a label. void LabelsInflate(Option_t* axis = ""X""); Double the number of bins for axis.; Refill histogram; This function is called by TAxis::FindBin(const char *label). void LabelsOption(Option_t* option = ""h"", Option_t* axis = ""X""); Set option(s) to draw axis with labels; option = ""a"" sort by alphabetic order; = "">"" sort by decreasing values; = ""<"" sort by increasing values; = ""h"" draw labels horizonthal; = ""v"" draw labels vertical; = ""u"" draw labels up (end of label right adjusted); = ""d"" draw labels down (start of label left adjusted). Long64_t Merge(TCollection* list); Merge all histograms in the collection in this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProfile2D.html:38448,Reduce,Reduce,38448,root/html532/TProfile2D.html,https://root.cern,https://root.cern/root/html532/TProfile2D.html,4,['Reduce'],['Reduce']
Energy Efficiency," length to store real and imaginary coefficients. Transform methods; Goal: to analyse experimental data using orthogonal transforms. orthogonal transforms can be successfully used for the processing of nuclear spectra (not only); they can be used to remove high frequency noise, to increase signal-to-background ratio as well as to enhance low intensity components [1], to carry out e.g. Fourier analysis etc.; we have implemented the function for the calculation of the commonly used orthogonal transforms as well as functions for the filtration and enhancement of experimental data. References:; [1] C.V. Hampton, B. Lian, Wm. C. McHarris: Fast-Fourier-transform spectral enhancement techniques for gamma-ray spectroscopy. NIM A353 (1994) 280-284.; [2] Morhac; M., Matouoek V., New adaptive Cosine-Walsh transform and its application to nuclear data compression, IEEE Transactions on Signal Processing 48 (2000) 2693.; [3] Morhac; M., Matouoek V., Data compression using new fast adaptive Cosine-Haar transforms, Digital Signal Processing 8 (1998) 63.; [4] Morhac; M., Matouoek V.: Multidimensional nuclear data compression using fast adaptive Walsh-Haar transform. Acta Physica Slovaca 51 (2001) 307. Example - script Transform.c:. Fig. 1 Original gamma-ray spectrum. Fig. 2 Transformed spectrum from Fig. 1 using Cosine transform; Script:; Example to illustrate Transform function (class TSpectrumTransform). To execute this example, do:; root > .x Transform.C; #include <TSpectrum>; #include <TSpectrumTransform>; void Transform() {; Int_t i;; Double_t nbins = 4096;; Double_t xmin = 0;; Double_t xmax = (Double_t)nbins;; Double_t * source = new Double_t[nbins];; Double_t * dest = new Double_t[nbins];; TH1F *h = new TH1F(""h"",""Transformed spectrum using Cosine transform"",nbins,xmin,xmax);; TFile *f = new TFile(""spectra/TSpectrum.root"");; h=(TH1F*) f->Get(""transform1;1"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; TCanvas *Transform1 = gROOT->GetListOfCanvases()->FindOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumTransform.html:30894,adapt,adaptive,30894,doc/master/classTSpectrumTransform.html,https://root.cern,https://root.cern/doc/master/classTSpectrumTransform.html,1,['adapt'],['adaptive']
Energy Efficiency," level of 1.3 for raw data files and around two on most DST files is the optimum. The choice of one for the default is a compromise between the time it takes to read and write the object vs. the disk space savings.; To specify no compression, set the level to zero.; We recommend using compression when the time spent in I/O is small compared to the total processing time. If the I/O operation is increased by a factor of 5 it is still a small percentage of the total time and it may compress the data by a factor of 10. On the other hand if the time spend on I/O is large, compression may have a large impact on the program’s performance.; The compression factor, i.e. the savings of disk space, varies with the type of data. A buffer with a same value array is compressed so that the value is only written once. For example, a track has the mass of a pion that it is always the same, and the charge of the pion that is either positive or negative. For 1000 pions, the mass will be written only once, and the charge only twice (positive and negative). When the data is sparse, i.e. when there are many zeros, the compression factor is also high. Compression level; Bytes; Write Time (sec); Read Time (sec.). 0; 1,004,998; 4.77; 0.07. 1; 438,366; 6.67; 0.05. 5; 429,871; 7.03; 0.06. 9; 426,899; 8.47; 0.05. The time to uncompress an object is small compared to the compression time and is independent of the selected compression level. Note that the compression level may be changed at any time, but the new compression level will only apply to newly written objects. Consequently, a ROOT file may contain objects with different compression levels. This table shows four runs of the demo script that creates 15 histograms with different compression parameters. To make the numbers more significant, the macro was modified to create 1000 histograms. We have included two more examples to show the impact of compression on Trees in the next chapter.; 11.6.1 Using the General Open Function of TFile; To ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:513821,charge,charge,513821,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['charge'],['charge']
Energy Efficiency," line 353 of file RPageStorage.cxx. ◆ LoadPageImpl(). virtual RPageRef ROOT::Experimental::Internal::RPageSource::LoadPageImpl ; (; ColumnHandle_t ; columnHandle, . const RClusterInfo & ; clusterInfo, . ClusterSize_t::ValueType ; idxInCluster . ). protectedpure virtual . Implemented in ROOT::Experimental::Internal::RPageSourceDaos, ROOT::Experimental::Internal::RPageSourceFile, and ROOT::Experimental::Internal::RPageSourceFriends. ◆ LoadSealedPage(). virtual void ROOT::Experimental::Internal::RPageSource::LoadSealedPage ; (; DescriptorId_t ; physicalColumnId, . RClusterIndex ; clusterIndex, . RSealedPage & ; sealedPage . ). pure virtual . Read the packed and compressed bytes of a page into the memory buffer provided by sealedPage. ; The sealed page can be used subsequently in a call to RPageSink::CommitSealedPage. The fSize and fNElements member of the sealedPage parameters are always set. If sealedPage.fBuffer is nullptr, no data will be copied but the returned size information can be used by the caller to allocate a large enough buffer and call LoadSealedPage again. ; Implemented in ROOT::Experimental::Internal::RPageSourceFriends, ROOT::Experimental::Internal::RPageSourceDaos, and ROOT::Experimental::Internal::RPageSourceFile. ◆ LoadStructure(). void ROOT::Experimental::Internal::RPageSource::LoadStructure ; (; ). Loads header and footer without decompressing or deserializing them. ; This can be used to asynchronously open a file in the background. The method is idempotent and it is called as a first step in Attach(). Pages sources may or may not make use of splitting loading and processing meta-data. Therefore, LoadStructure() may do nothing and defer loading the meta-data to Attach(). ; Definition at line 188 of file RPageStorage.cxx. ◆ LoadStructureImpl(). virtual void ROOT::Experimental::Internal::RPageSource::LoadStructureImpl ; (; ). protectedpure virtual . Implemented in ROOT::Experimental::Internal::RPageSourceFriends, ROOT::Experimental::Internal::RPageSo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:16820,allocate,allocate,16820,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['allocate'],['allocate']
Energy Efficiency," line 82 of file EvalContext.cxx. ◆ set(). void RooFit::EvalContext::set ; (; RooAbsArg const * ; arg, . std::span< const double > const & ; span . ). inline . Definition at line 91 of file EvalContext.h. ◆ setConfig(). void RooFit::EvalContext::setConfig ; (; RooAbsArg const * ; arg, . RooBatchCompute::Config const & ; config . ). Definition at line 65 of file EvalContext.cxx. ◆ setOutputWithOffset(). void RooFit::EvalContext::setOutputWithOffset ; (; RooAbsArg const * ; arg, . ROOT::Math::KahanSum< double > ; val, . ROOT::Math::KahanSum< double > const & ; offset . ). Sets the output value with an offset. ; This function sets the output value with an offset for the given argument. It should only be used in reducer nodes. Depending on the current OffsetMode, the result will either be just the value, the value minus the offset, of just the offset.; Parameters. argPointer to the RooAbsArg object. ; valThe value to be set. ; offsetThe offset value. Exceptions. std::runtime_errorif the argument is not a reducer node. . Definition at line 100 of file EvalContext.cxx. ◆ size(). auto RooFit::EvalContext::size ; (; ); const. inline . Definition at line 88 of file EvalContext.h. Friends And Related Symbol Documentation. ◆ Evaluator. friend class Evaluator. friend . Definition at line 118 of file EvalContext.h. Member Data Documentation. ◆ _bufferIdx. std::size_t RooFit::EvalContext::_bufferIdx = 0. private . Definition at line 125 of file EvalContext.h. ◆ _buffers. std::vector<std::vector<double> > RooFit::EvalContext::_buffers. private . Definition at line 124 of file EvalContext.h. ◆ _cfgs. std::vector<RooBatchCompute::Config> RooFit::EvalContext::_cfgs. private . Definition at line 126 of file EvalContext.h. ◆ _ctx. std::vector<std::span<const double> > RooFit::EvalContext::_ctx. private . Definition at line 122 of file EvalContext.h. ◆ _currentOutput. std::span<double> RooFit::EvalContext::_currentOutput. private . Definition at line 121 of file EvalContext.h. ◆ _enableV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFit_1_1EvalContext.html:3823,reduce,reducer,3823,doc/master/classRooFit_1_1EvalContext.html,https://root.cern,https://root.cern/doc/master/classRooFit_1_1EvalContext.html,1,['reduce'],['reducer']
Energy Efficiency," logggingDefinition NeuralNet.h:805; TMVA::DNN::Settings::testIterationvirtual void testIteration()callback for monitoring and logggingDefinition NeuralNet.h:806; TMVA::DNN::Settings::hasConvergedvirtual bool hasConverged(double testError)has this training converged already?Definition NeuralNet.cxx:485; TMVA::DNN::Settings::cyclevirtual void cycle(double progress, TString text)Definition NeuralNet.h:799; TMVA::DNN::Settings::endTrainCyclevirtual void endTrainCycle(double)callback for monitoring and loggingDefinition NeuralNet.h:788; TMVA::DNN::Settings::dropFractionsconst std::vector< double > & dropFractions() constDefinition NeuralNet.h:762; TMVA::DNN::Settings::addPointvoid addPoint(std::string histoName, double x)for monitoringDefinition NeuralNet.h:821; TMVA::DNN::Settings::testSamplevirtual void testSample(double, double, double, double)virtual function to be used for monitoring (callback)Definition NeuralNet.h:781; TMVA::DNN::Settings::plotvoid plot(std::string histoName, std::string options, int pad, EColor color)for monitoringDefinition NeuralNet.h:823; TMVA::DNN::Settings::startTrainCyclevirtual void startTrainCycle()Definition NeuralNet.h:782; TMVA::DNN::Settings::convergenceStepssize_t convergenceSteps() consthow many steps until training is deemed to have convergedDefinition NeuralNet.h:766; TMVA::DNN::Settings::factorWeightDecaydouble factorWeightDecay() constget the weight-decay factorDefinition NeuralNet.h:769; TMVA::DNN::Settings::maxConvergenceCountsize_t maxConvergenceCount() constreturns the max convergence count so farDefinition NeuralNet.h:828; TMVA::DNN::Settings::padsvoid pads(int numPads)preparation for monitoringDefinition NeuralNet.h:818; TMVA::DNN::Settings::batchSizesize_t batchSize() constmini-batch sizeDefinition NeuralNet.h:767; TMVA::DNN::Settings::computeResultvirtual void computeResult(const Net &, std::vector< double > &)callback for monitoring and loggingDefinition NeuralNet.h:809; TMVA::DNN::Settings::dropRepetitionssize_t dropRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:68502,monitor,monitoringDefinition,68502,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['monitor'],['monitoringDefinition']
Energy Efficiency," loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock); Activate a de-activated socket. void ActivateAll(); Activate all de-activated sockets. void DeActivate(TSocket* sock); De-activate a socket. void DeActivateAll(); De-activate all activated sockets. TSocket * Select(); Return pointer to socket for which an event is waiting.; Select can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMonitor.html:10812,monitor,monitor,10812,root/html528/TMonitor.html,https://root.cern,https://root.cern/root/html528/TMonitor.html,30,['monitor'],['monitor']
Energy Efficiency," marked; 5152 // as preallocated with the ""->"" comment, in which case; 5153 // we default-construct an object to point at).; 5154 ; 5155 // ???BUG??? ???WHY???; 5156 // Do not register any TObject's that we create; 5157 // as a result of creating this object.; 5158 Bool_t statsave = GetObjectStat();; 5159 if(statsave) {; 5160 SetObjectStat(kFALSE);; 5161 }; 5162 ; 5163 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5164 if (!sinfo) {; 5165 Error(""New with placement"", ""Cannot construct class '%s' version %d at address %p, no streamer info available!"", GetName(), fClassVersion, arena);; 5166 return nullptr;; 5167 }; 5168 ; 5169 {; 5170 TClass__GetCallingNewRAII callingNew(defConstructor);; 5171 p = { sinfo->New(arena), sinfo };; 5172 }; 5173 ; 5174 // ???BUG???; 5175 // Allow TObject's to be registered again.; 5176 if(statsave) {; 5177 SetObjectStat(statsave);; 5178 }; 5179 ; 5180 } else {; 5181 Error(""New with placement"", ""This cannot happen!"");; 5182 }; 5183 ; 5184 return p;; 5185}; 5186 ; 5187////////////////////////////////////////////////////////////////////////////////; 5188/// Return a pointer to a newly allocated array of objects; 5189/// of this class.; 5190/// The class must have a default constructor. For meaning of; 5191/// defConstructor, see TClass::IsCallingNew().; 5192 ; 5193void *TClass::NewArray(Long_t nElements, ENewType defConstructor) const; 5194{; 5195 auto obj = NewObjectArray(nElements, defConstructor);; 5196 if (obj.GetPtr() && obj.GetAllocator()) {; 5197 // Register the object for special handling in the destructor.; 5198 RegisterAddressInRepository(""TClass::NewArray"", obj.GetPtr(), this);; 5199 }; 5200 return obj.GetPtr();; 5201}; 5202 ; 5203////////////////////////////////////////////////////////////////////////////////; 5204/// Return a pointer to a newly allocated array of objects; 5205/// of this class.; 5206/// The class must have a default constructor. For meaning of; 5207/// defConstructor, see TClass::IsCallingNew().; 5208 ; 5209TC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:197880,allocate,allocated,197880,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," marked; 5219 // as preallocated with the ""->"" comment, in which case; 5220 // we default-construct an object to point at).; 5221 ; 5222 // ???BUG??? ???WHY???; 5223 // Do not register any TObject's that we create; 5224 // as a result of creating this object.; 5225 Bool_t statsave = GetObjectStat();; 5226 if(statsave) {; 5227 SetObjectStat(kFALSE);; 5228 }; 5229 ; 5230 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5231 if (!sinfo) {; 5232 Error(""New with placement"", ""Cannot construct class '%s' version %d at address %p, no streamer info available!"", GetName(), fClassVersion, arena);; 5233 return nullptr;; 5234 }; 5235 ; 5236 {; 5237 TClass__GetCallingNewRAII callingNew(defConstructor);; 5238 p = { sinfo->New(arena), sinfo };; 5239 }; 5240 ; 5241 // ???BUG???; 5242 // Allow TObject's to be registered again.; 5243 if(statsave) {; 5244 SetObjectStat(statsave);; 5245 }; 5246 ; 5247 } else {; 5248 Error(""New with placement"", ""This cannot happen!"");; 5249 }; 5250 ; 5251 return p;; 5252}; 5253 ; 5254////////////////////////////////////////////////////////////////////////////////; 5255/// Return a pointer to a newly allocated array of objects; 5256/// of this class.; 5257/// The class must have a default constructor. For meaning of; 5258/// defConstructor, see TClass::IsCallingNew().; 5259 ; 5260void *TClass::NewArray(Long_t nElements, ENewType defConstructor) const; 5261{; 5262 auto obj = NewObjectArray(nElements, defConstructor);; 5263 if (obj.GetPtr() && obj.GetAllocator()) {; 5264 // Register the object for special handling in the destructor.; 5265 RegisterAddressInRepository(""TClass::NewArray"", obj.GetPtr(), this);; 5266 }; 5267 return obj.GetPtr();; 5268}; 5269 ; 5270////////////////////////////////////////////////////////////////////////////////; 5271/// Return a pointer to a newly allocated array of objects; 5272/// of this class.; 5273/// The class must have a default constructor. For meaning of; 5274/// defConstructor, see TClass::IsCallingNew().; 5275 ; 5276TC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:200631,allocate,allocated,200631,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency, marker; TPolyMarker3D An array of 3-D points with the same marker; TPosixCondition Posix condition variable; TPosixMutex Posix mutex lock; TPosixThread TPosixThread class; TPosixThreadFactory Posix thread factory; TPostScript PostScript driver; TPrimary TPrimary vertex particle information; TPrincipal Principal Components Analysis; TProcessEventTimer Process pending events at fixed time intervals; TProcessID Process Unique Identifier in time and space; TProcessUUID TProcessID managing UUIDs; TProfile Profile histogram class; TProfile2D Profile2D histogram class; TProfile3D Profile3D histogram class; TProof PROOF control class; TProofBench Steering class for PROOF benchmarks; TProofBenchDataSet Handle operations on datasets; TProofBenchRun Abstract base class for PROOF benchmark run; TProofBenchRunCPU CPU-intensive PROOF benchmark; TProofBenchRunDataRead IO-intensive PROOF benchmark; TProofChain TChain proxy for running chains on PROOF; TProofCondor PROOF control class for slaves allocated by condor; TProofDebug ; TProofDesc Small class describing a proof session; TProofDraw Tree drawing selector for PROOF; TProofDrawEntryList A Selectoor to fill a TEntryList from TTree::Draw; TProofDrawEventList Tree drawing selector for PROOF; TProofDrawGraph Tree drawing selector for PROOF; TProofDrawHist Tree drawing selector for PROOF; TProofDrawListOfGraphs Tree drawing selector for PROOF; TProofDrawListOfGraphs::Point3D_t ; TProofDrawListOfPolyMarkers3D Tree drawing selector for PROOF; TProofDrawListOfPolyMarkers3D::Point4D_t ; TProofDrawPolyMarker3D Tree drawing selector for PROOF; TProofDrawProfile Tree drawing selector for PROOF; TProofDrawProfile2D Tree drawing selector for PROOF; TProofLimitsFinder Find and communicate best axis limits; TProofLite PROOF-Lite control class; TProofLog PROOF session log handler; TProofLogElem PROOF session log element; TProofMgr Abstract PROOF manager interface; TProofMgrLite XrdProofd PROOF manager interface; TProofMonSender Interface for ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:117342,allocate,allocated,117342,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,7,['allocate'],['allocated']
Energy Efficiency, marker; TPolyMarker3D An array of 3-D points with the same marker; TPosixCondition Posix condition variable; TPosixMutex Posix mutex lock; TPosixThread TPosixThread class; TPosixThreadFactory Posix thread factory; TPostScript PostScript driver; TPrimary TPrimary vertex particle information; TPrincipal Principal Components Analysis; TProcessEventTimer Process pending events at fixed time intervals; TProcessID Process Unique Identifier in time and space; TProcessUUID TProcessID managing UUIDs; TProfile Profile histogram class; TProfile2D Profile2D histogram class; TProfile3D Profile3D histogram class; TProof PROOF control class; TProofBench Steering class for PROOF benchmarks; TProofBenchDataSet Handle operations on datasets; TProofBenchRun Abstract base class for PROOF benchmark run; TProofBenchRunCPU CPU-intensive PROOF benchmark; TProofBenchRunDataRead IO-intensive PROOF benchmark; TProofChain TChain proxy for running chains on PROOF; TProofCondor PROOF control class for slaves allocated by condor; TProofDebug ; TProofDesc Small class describing a proof session; TProofDraw Tree drawing selector for PROOF; TProofDrawEntryList A Selectoor to fill a TEntryList from TTree::Draw; TProofDrawEventList Tree drawing selector for PROOF; TProofDrawGraph Tree drawing selector for PROOF; TProofDrawHist Tree drawing selector for PROOF; TProofDrawListOfGraphs Tree drawing selector for PROOF; TProofDrawListOfGraphs::Point3D_t ; TProofDrawListOfPolyMarkers3D Tree drawing selector for PROOF; TProofDrawListOfPolyMarkers3D::Point4D_t ; TProofDrawPolyMarker3D Tree drawing selector for PROOF; TProofDrawProfile Tree drawing selector for PROOF; TProofDrawProfile2D Tree drawing selector for PROOF; TProofLimitsFinder Find and communicate best axis limits; TProofLite PROOF-Lite control class; TProofLog PROOF session log handler; TProofLogElem PROOF session log element; TProofMgr Abstract PROOF manager interface; TProofMgrLite XrdProofd PROOF manager interface; TProofNodeInfo Class describin,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:115881,allocate,allocated,115881,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,1,['allocate'],['allocated']
Energy Efficiency," matching bin. ; Definition at line 37 of file THnSparse.h. Public Member Functions;  ~THnSparse () override;  Destruct a THnSparse. ;  ; void AddBinContent (const Int_t *idx, Double_t v=1.);  Forwards to THnBase::AddBinContent(). ;  ; void AddBinContent (Long64_t bin, Double_t v=1.) override;  Add ""v"" to the content of bin with index ""bin"". ;  ; void AddBinError2 (Long64_t bin, Double_t e2) override;  Add ""e"" to error of bin with index ""bin"", enable errors if needed. ;  ; ROOT::Internal::THnBaseBinIter * CreateIter (Bool_t respectAxisRange) const override;  Create an iterator over all filled bins of a THnSparse. ;  ; Long64_t GetBin (const char *name[]) const override;  ; Long64_t GetBin (const char *name[], Bool_t allocate=kTRUE) override;  Get the bin index for the n dimensional tuple addressed by ""name"", allocate one if it doesn't exist yet and ""allocate"" is true. ;  ; Long64_t GetBin (const Double_t *x) const override;  ; Long64_t GetBin (const Double_t *x, Bool_t allocate=kTRUE) override;  Get the bin index for the n dimensional tuple x, allocate one if it doesn't exist yet and ""allocate"" is true. ;  ; Long64_t GetBin (const Int_t *idx) const override;  ; Long64_t GetBin (const Int_t *idx, Bool_t allocate=kTRUE) override;  Get the bin index for the n dimensional coordinates coord, allocate one if it doesn't exist yet and ""allocate"" is true. ;  ; Double_t GetBinContent (const Int_t *idx) const;  Forwards to THnBase::GetBinContent() overload. ;  ; Double_t GetBinContent (Long64_t bin, Int_t *idx=nullptr) const override;  Return the content of the filled bin number ""idx"". ;  ; Double_t GetBinError2 (Long64_t linidx) const override;  Get square of the error of bin addressed by linidx as \(\sum weight^{2}\) If errors are not enabled (via Sumw2() or CalculateErrors()) return contents. ;  ; Int_t GetChunkSize () const;  ; Long64_t GetNbins () const override;  ; Int_t GetNChunks () const;  ; Double_t GetSparseFractionBins () const;  Return the amount of filled bins ov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparse.html:5781,allocate,allocate,5781,doc/master/classTHnSparse.html,https://root.cern,https://root.cern/doc/master/classTHnSparse.html,3,['allocate'],['allocate']
Energy Efficiency," mathematical functions taking full advantage of the precision and speed of the C99 compliant environments ;  mathcoreStatFunc.C Example macro showing some major probability density functions in ROOT ;  mathcoreVectorCollection.C Example showing how to write and read a std vector of ROOT::Math LorentzVector in a ROOT tree ;  mathcoreVectorFloatIO.C Macro illustrating automatic dictionary generation and I/O with Lorentz Vectors of floats The dictionary for LorentzVector of float is not in the libMathCore, therefore is generated when parsed the file with CINT ;  mathcoreVectorIO.C Example of I/O of a mathcore Lorentz Vectors in a Tree and comparison with a TLorentzVector ;  mathGammaNormal.C Tutorial illustrating the use of TMath::GammaDist and TMath::LogNormal ;  mathLaplace.C Test the TMath::LaplaceDist and TMath::LaplaceDistI functions ;  mathmoreIntegration.C Example on the usage of the adaptive 1D integration algorithm of MathMore it calculates the numerically cumulative integral of a distribution (like in this case the BreitWigner) to execute the macro type it (you need to compile with AClic) ;  mathStudent.C Tutorial illustrating the use of the Student and F distributions ;  multidimSampling.C Example of sampling a multi-dim distribution using the DistSampler class NOTE: This tutorial must be run with ACLIC ;  normalDist.C Tutorial illustrating the new statistical distributions functions (pdf, cdf and quantile) ;  permute.C Tutorial illustrating the use of TMath::Permute can be run with: ;  principal.C Principal Components Analysis (PCA) example ;  quantiles.C Demo for quantiles ;  quasirandom.C Example of generating quasi-random numbers ;  Rolke.C Example of the usage of the TRolke class The TRolke class computes the profile likelihood confidence limits for 7 different model assumptions on systematic/statistical uncertainties ;  testrandom.C Performance test of all the ROOT random generator (TRandom, TRandom1, TRandom2 and TRandom3) Tests the generator TRandom3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:129678,adapt,adaptive,129678,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['adapt'],['adaptive']
Energy Efficiency," matrix; Double_tfTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; static TDecompBase::EMatrixDecompStatkCondition; static TDecompBase::EMatrixDecompStatkDecomposed; static TDecompBase::EMatrixDecompStatkDetermined; static TDecompBase::EMatrixDecompStatkInit; static TDecompBase::EMatrixDecompStatkMatrixSet; static TDecompBase::EMatrixDecompStatkPatternSet; static TDecompBase::EMatrixDecompStatkSingular; static TDecompBase::EMatrixDecompStatkValuesSet; static TDecompBase::(anonymous)kWorkMax. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecompBase(); Default constructor. TDecompBase(const TDecompBase& another); Copy constructor. Int_t Hager(Double_t& est, Int_t iter = 5). void DiagProd(const TVectorD& diag, Double_t tol, Double_t& d1, Double_t& d2). Double_t Condition(); Matrix condition number. Bool_t MultiSolve(TMatrixD& B); Solve set of equations with RHS in columns of B. void Det(Double_t& d1, Double_t& d2); Matrix determinant det = d1*TMath::Power(2.,d2). void Print(Option_t* opt = """") const; Print class members. TDecompBase & operator=(const TDecompBase& source); Assignment operator. Double_t SetTol(Double_t tol). void ResetStatus(); { for (Int_t i = 14; i < 22; i++) ResetBit(BIT(i)); }. const TMatrixDBase & GetDecompMatrix() const. virtual ~TDecompBase(); {}. Double_t GetTol() const; { return fTol; }. Double_t GetDet1() const; { return fDet1; }. Double_t GetDet2() const; { return fDet2; }. Double_t GetCondition() const; { return fCondition; }. Int_t GetNrows() const. Int_t GetNcols() const. Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetColLwb() const; { return fColLwb; }. Bool_t Decompose(). Bool_t Solve(TVectorD& b). TVectorD Solve(const TVectorD& b, Bool_t& ok). Bool_t Solve(TMatrixDColumn& b). Bool_t TransSolve(TVectorD& b). TVectorD TransSolve(const TVectorD& b, Bool_t& ok). Bool_t TransSolve(TMatrixDColumn& b). » Last changed: root/matrix:$Id$ » Last generated: 2015-06-02 15",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TDecompBase.html:11586,Power,Power,11586,root/html604/TDecompBase.html,https://root.cern,https://root.cern/root/html604/TDecompBase.html,1,['Power'],['Power']
Energy Efficiency," matrix; Double_tfTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; static TDecompBase::EMatrixDecompStatkCondition; static TDecompBase::EMatrixDecompStatkDecomposed; static TDecompBase::EMatrixDecompStatkDetermined; static TDecompBase::EMatrixDecompStatkInit; static TDecompBase::EMatrixDecompStatkMatrixSet; static TDecompBase::EMatrixDecompStatkPatternSet; static TDecompBase::EMatrixDecompStatkSingular; static TDecompBase::EMatrixDecompStatkValuesSet; static TDecompBase::(anonymous)kWorkMax. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecompBase(); Default constructor. TDecompBase(const TDecompBase& another); Copy constructor. Int_t Hager(Double_t& est, Int_t iter = 5). void DiagProd(const TVectorD& diag, Double_t tol, Double_t& d1, Double_t& d2). Double_t Condition(); Matrix condition number. Bool_t MultiSolve(TMatrixD& B); Solve set of equations with RHS in columns of B. void Det(Double_t& d1, Double_t& d2); Matrix determinant det = d1*TMath::Power(2.,d2). void Print(Option_t* opt = """") const; Print class members. TDecompBase & operator=(const TDecompBase& source); Assignment operator. Double_t SetTol(Double_t tol). void ResetStatus(); { for (Int_t i = 14; i < 22; i++) ResetBit(BIT(i)); }. const TMatrixDBase & GetDecompMatrix() const. virtual ~TDecompBase(); {}. Double_t GetTol() const; { return fTol; }. Double_t GetDet1() const; { return fDet1; }. Double_t GetDet2() const; { return fDet2; }. Double_t GetCondition() const; { return fCondition; }. Int_t GetNrows() const. Int_t GetNcols() const. Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetColLwb() const; { return fColLwb; }. Bool_t Decompose(). Bool_t Solve(TVectorD& b). TVectorD Solve(const TVectorD& b, Bool_t& ok). Bool_t Solve(TMatrixDColumn& b). Bool_t TransSolve(TVectorD& b). TVectorD TransSolve(const TVectorD& b, Bool_t& ok). Bool_t TransSolve(TMatrixDColumn& b). » Last changed: root/matrix:$Id$ » Last generated: 2015-06-30 14",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDecompBase.html:11586,Power,Power,11586,root/html602/TDecompBase.html,https://root.cern,https://root.cern/root/html602/TDecompBase.html,1,['Power'],['Power']
Energy Efficiency," means left-handed helix. ; Definition at line 195 of file TGeoHelix.cxx. ◆ SetField(). void TGeoHelix::SetField ; (; Double_t ; bx, . Double_t ; by, . Double_t ; bz, . Bool_t ; is_normalized = kTRUE . ). Initialize particle direction (tangent on the helix in initial point) ; Definition at line 211 of file TGeoHelix.cxx. ◆ SetHelixStep(). void TGeoHelix::SetHelixStep ; (; Double_t ; hstep). Set Z step of the helix on a complete turn. Positive or null. ; Definition at line 227 of file TGeoHelix.cxx. ◆ SetXYcurvature(). void TGeoHelix::SetXYcurvature ; (; Double_t ; curvature). Set XY curvature: c = 1/Rxy. ; Definition at line 178 of file TGeoHelix.cxx. ◆ Step(). void TGeoHelix::Step ; (; Double_t ; step). Make a step from current point along the helix and compute new point, direction and angle To reach a plane/ shape boundary, one has to: . Compute the safety to the plane/boundary; Define / update a helix according local field and particle state (position, direction, charge); Compute the magnetic safety (maximum distance for which the field can be considered constant); Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; Repeat from 1. until the step to be made is small enough.; Add to the total step the distance along a straight line from the last point to the plane/shape boundary . Definition at line 260 of file TGeoHelix.cxx. ◆ StepToPlane(). Double_t TGeoHelix::StepToPlane ; (; Double_t * ; point, . Double_t * ; norm . ). Propagate initial point up to a given Z position in MARS. ; Definition at line 293 of file TGeoHelix.cxx. ◆ Streamer(). void TGeoHelix::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGeoHelix::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 73 of file TGeoHelix.h. ◆ UpdateHelix(). void TGeoHelix::UpdateHelix ; (; ). Update the local helix matrix. ; Definition at line 352 of file TGeoHeli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoHelix.html:18475,charge,charge,18475,doc/master/classTGeoHelix.html,https://root.cern,https://root.cern/doc/master/classTGeoHelix.html,1,['charge'],['charge']
Energy Efficiency," method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitImplementation(const char* methodname, const char* params, const char* proto, TClass* cl, const ClassInfo_t* cinfo); This function implements Init and InitWithPrototype. void InitWithPrototype(TClass* cl, const char* method, const char* proto); Initialize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitWithPrototype(const char* function, const char* proto); Initialize the function invocation environment. Necessary input; information: the function name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). Bool_t IsValid() const; Return true if the method call has been properly initialized and is; usable. TFunction * GetMethod(); Returns the TMethod describing the method to be executed. This takes; all overriding and overloading into account (call TClass::GetMethod()).; Since finding the method is expensive the result is cached. void Execute(void* object); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params); Execute the method for the specified object and argument values. void Execute(void* object, Long_t& retLong); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Long_t& retLong); Execute the method for the specified object and argument values. void Execute(void* object, Double_t& retDouble); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMethodCall.html:10155,efficient,efficient,10155,root/html528/TMethodCall.html,https://root.cern,https://root.cern/root/html528/TMethodCall.html,6,['efficient'],['efficient']
Energy Efficiency," methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1.0E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1.0E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1.0E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1.0E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, double h = 1.0E-8). Evaluate the derivative with respect a parameter for one-dim parameteric function; at the point ( x,p[]) with respect the parameter p_ipar. double Eval(ROOT::Math::IParamMultiFunction& f, const double* x, const double* p, unsigned int ipar = 0, double h = 1.0E-8). Evaluate the derivative with respect a parameter for a multi-dim parameteric function; at the point ( x[],p[]) with respect the parameter p_ipar. int Status() const. return the error status of the last derivative calcul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__Derivator.html:5138,adapt,adaptive,5138,root/html602/ROOT__Math__Derivator.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__Derivator.html,4,['adapt'],['adaptive']
Energy Efficiency," milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in degrees. Return value will always be between 0 and 24; (hours). Sidereal time is most accurately calculated from UT1. If fSec; and fNanoSec are in UTC (which they are by default), the optional; argument UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. const Char_t * AsString(const Option_t* option = """") const; Return the date & time as a string. Result is pointer to a statically allocated string.; User should copy this into their own buffer before calling; this method again. Option ""l"" returns it in local zone format; (can be applied to default or compact format). Default format is RFC822 compliant:; ""Mon, 02 Jan 2001 18:11:12 +0000 (GMT) +999999999 nsec""; ""Mon, 02 Jan 2001 10:11:12 -0800 (PST) +999999999 nsec"". Option ""c"" compact is (almost) ISO 8601 compliant:; ""2001-01-02 18:11:12.9999999999Z""; ""2001-01-02 10:11:12.9999999999-0800"" if PST; * uses ""-"" as date separator as specified in ISO 8601; * uses ""."" rather than preferred "","" for decimal separator; * -HHMM is the difference between local and UTC (if behind, + if ahead).; The ""-HHMM"" is replaced with ""Z"" if given as UTC.; To be strictly conforming it should use ""T"" instead of the; blank separating the date and time. Option ""2"" returns as {sec,nsec} integers. Option ""s"" returns ""2001-01-02 18:11:12"" with an implied UTC,; overrides ""l"" option. Internally uses a circular list of buffers to avoid pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTimeStamp.html:7861,allocate,allocated,7861,root/html604/TTimeStamp.html,https://root.cern,https://root.cern/root/html604/TTimeStamp.html,2,['allocate'],['allocated']
Energy Efficiency," monitoring and logging; 810 ; 811 virtual bool hasConverged (double testError); ///< has this training converged already?; 812 ; 813 EnumRegularization regularization () const { return m_regularization; } ///< some regularization of the DNN is turned on?; 814 ; 815 bool useMultithreading () const { return m_useMultithreading; } ///< is multithreading turned on?; 816 ; 817 ; 818 void pads (int numPads) { if (fMonitoring) fMonitoring->pads (numPads); } ///< preparation for monitoring; 819 void create (std::string histoName, int bins, double min, double max) { if (fMonitoring) fMonitoring->create (histoName, bins, min, max); } ///< for monitoring; 820 void create (std::string histoName, int bins, double min, double max, int bins2, double min2, double max2) { if (fMonitoring) fMonitoring->create (histoName, bins, min, max, bins2, min2, max2); } ///< for monitoring; 821 void addPoint (std::string histoName, double x) { if (fMonitoring) fMonitoring->addPoint (histoName, x); } ///< for monitoring; 822 void addPoint (std::string histoName, double x, double y) {if (fMonitoring) fMonitoring->addPoint (histoName, x, y); } ///< for monitoring; 823 void plot (std::string histoName, std::string options, int pad, EColor color) { if (fMonitoring) fMonitoring->plot (histoName, options, pad, color); } ///< for monitoring; 824 void clear (std::string histoName) { if (fMonitoring) fMonitoring->clear (histoName); } ///< for monitoring; 825 bool exists (std::string histoName) { if (fMonitoring) return fMonitoring->exists (histoName); return false; } ///< for monitoring; 826 ; 827 size_t convergenceCount () const { return m_convergenceCount; } ///< returns the current convergence count; 828 size_t maxConvergenceCount () const { return m_maxConvergenceCount; } ///< returns the max convergence count so far; 829 size_t minError () const { return m_minError; } ///< returns the smallest error so far; 830 ; 831 public:; 832 Timer m_timer; ///< timer for monitoring; 833 double m_minProgress; ///",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:31034,monitor,monitoring,31034,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['monitor'],['monitoring']
Energy Efficiency," moved into Doxygen. Still some work and polish has to be done but the reference guide in this new format is now online and can be seen from the ROOT home page.; Core Libraries; Dictionary generation; Fixed the dictionary generation in the case of class inside a namespace marked inlined.; Added mechanisms to stop the dictionary generation while parsing the XML and while selecting in presence of duplicates.; Fix ROOT-7760 : fully allow the usage of the dylib extension on OSx.; Fix ROOT-7723 : allow IOCtors to have as argument a ref to a type called void.; We added a dictionary for map as part of the default STL dictionary.; We added support for template parameter packs in class name involved in the I/O.; Thread safety and thread awareness; We added the function TMethodCall::GetCallFunc to allow direct access to the function wrapper.; We reduced thread serialization in TClass::GetCheckSum, TClass::GetBaseClassOffset and TClass::Property; TObjArray::Delete was updated to allow its caller to explicitly avoid costly checks (extra RecursiveRemove and lock); We removed the need to create a TThread object per thread in a multi-threaded application. Now ROOT can be used with any threading model (e.g. OpenMP, STL threads, TBB) transparently. All the internal synchronisation mechanisms of ROOT are activated by a single call: ROOT::EnableThreadSafety() which is the successor of the existing TThread::Initialize. This call must take place if ROOT needs to be used in a thread safe manner.; The implementation of TSemaphore was redone based on C++11 thread primitive in order to prevent cases where some of request post were lost.; TDirectory::TContext; We added a default constructor to TDirectory::TContext which record the current directory and will restore it at destruction time and does not change the current directory.; The constructor for TDirectory::TContext that takes a single TDirectory pointer as an argument was changed to set gDirectory to zero when being passed a null pointe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:3430,reduce,reduced,3430,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['reduce'],['reduced']
Energy Efficiency," must be deleted by the user. void RemoveHostAuth(THostAuth* ha, Option_t* opt = """"); Remove THostAuth instance from the list. void Show(Option_t* opt = ""S""); Print info about the authentication sector.; If 'opt' contains 's' or 'S' prints information about established TSecContext,; else prints information about THostAuth (if 'opt' is 'p' or 'P', prints; Proof related information). Int_t AuthExists(TString User, Int_t method, const char* Options, Int_t* Message, Int_t* Rflag, CheckSecCtx_t funcheck); Check if we have a valid established sec context in memory; Retrieves relevant info and negotiates with server.; options = ""Opt,strlen(username),username.Data()""; message = kROOTD_USER, ... void InitRandom(); Initialize random machine using seed from /dev/urandom; (or current time if /dev/urandom not available). Int_t GenRSAKeys(); Generate a valid pair of private/public RSA keys to protect for; authentication token exchange. char * GetRandString(Int_t Opt, Int_t Len); Allocates and fills a 0 terminated buffer of length len+1 with; len random characters.; Returns pointer to the buffer (to be deleted by the caller); opt = 0 any non dangerous char; 1 letters and numbers (upper and lower case); 2 hex characters (upper and lower case). Int_t SecureSend(TSocket* Socket, Int_t enc, Int_t KeyType, const char* In); Encode null terminated str using the session private key indicated by enc; and sends it over the network; Returns number of bytes sent, or -1 in case of error.; enc = 1 for private encoding, enc = 2 for public encoding. Int_t SecureRecv(TSocket* Socket, Int_t dec, Int_t KeyType, char** Out); Receive str from sock and decode it using key indicated by key type; Return number of received bytes or -1 in case of error.; dec = 1 for private decoding, dec = 2 for public decoding. Int_t DecodeRSAPublic(const char* rsapubexport, rsa_NUMBER& n, rsa_NUMBER& d, char** rsassl = 0); Store RSA public keys from export string rsaPubExport. Int_t SetRSAPublic(const char* rsapubexport, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TAuthenticate.html:19637,Allocate,Allocates,19637,root/html532/TAuthenticate.html,https://root.cern,https://root.cern/root/html532/TAuthenticate.html,4,['Allocate'],['Allocates']
Energy Efficiency," must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar energy). » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:9352,energy,energy,9352,root/html534/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,2,['energy'],['energy']
Energy Efficiency," needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CDUMMY;  CEditor;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  CFUMILI2;  Cfuncptr_and_voidptr_t;  CGaussFunction;  CGcCache_t;  CGCValues_t;  Cgroup;  CGSL_BFGS;  CGSL_BFGS2;  CGSL_FR;  CGSL_NLS;  CGSL_PR;  Ch1analysis;  Ch1analysisTreeReader;  Chash< std::experimental::basic_string_view< _CharT, _Traits > >;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CLINEAR;  CMemInfo_t;  Cmg_callbacks;  Cmg_client_options;  Cmg_form_data_handler;  Cmg_option;  ►Cmg_request_info;  Cmg_header;  Cmg_server_ports;  CMINUIT2;  CMultiDistFree functions adapter needed by UNURAN for multidimensional cont distribution ;  CMYSQL_BIND;  CMYSQL_STMT;  CNuMuToNuE_Oscillation;  ►CParamHistFunc;  CCacheElem;  CPassiveKeyGrab;  Cpasswd;  CPattern;  CPgSQL_Stmt_t;  CPictureAttributes_t;  ►CPiecewiseInterpolation;  CCacheElem;  CPoint_t;  CProcInfo_t;  CProofServEnv_t;  Cpthread_cond_t;  CPybins_tPythia6 common block Pybins ;  CPydat1_tPythia6 common block Pydat1 ;  CPydat2_tPythia6 common block Pydat2 ;  CPydat3_tPythia6 common block Pydat3 ;  CPydat4_tPythia6 common block Pydat4 ;  CPydatr_tPythia6 common block Pydatr ;  CPyint1_tPythia6 common block Pyint1 ;  CPyint2_tPythia6 common block Pyint2 ;  CPyint3_tPythia6 common block Pyint3 ;  CPyint4_tPythia6 common block Pyint4 ;  CPyint5_tPythia6 common block Pyint5 ;  CPyint6_tPythia6 common block Pyint6 ;  CPyint7_tPythia6 common block Pyint7 ;  CPyint8_tPythia6 common block Pyint8 ;  CPyint9_tPythia6 common block Pyint9 ;  CPyints_tPythia6 common block Pyints ;  CPyjets_tPythia6 common block Pyje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:73345,adapt,adapter,73345,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['adapt'],['adapter']
Energy Efficiency," neither thread is able to progress; they are deadlocked.; A multiprocessor is a hardware system with multiple processors or multiple, simultaneous execution units. Examples can be found at http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html (the thread authors’ web site - Jörn Adamczewski and Marc Hemberger). 24 PROOF: Parallel Processing; ; The Parallel ROOT Facility, PROOF, is an extension of ROOT allowing transparent analysis of large sets of ROOT files in parallel on remote computer clusters or multi-core computers. The main design goals for the PROOF system are:; Transparency : there should be as little difference as possible between a local ROOT based analysis session and a remote parallel PROOF session, both being interactive and giving the same results.; Scalability : the basic architecture should not put any implicit limitations on the number of computers that can be used in parallel.; Adaptability : the system should be able to adapt itself to variations in the remote environment (changing load on the cluster nodes, network interruptions, etc.).; Being an extension of the ROOT system, PROOF is designed to work on objects in ROOT data stores, though, for the time being, it mainly addresses the case of TTree based object collections.; PROOF is primarily meant as an interactive alternative to batch systems for Central Analysis Facilities and departmental workgroups (Tier-2’s). However, thanks to a multi-tier architecture allowing multiple levels of masters, it can be easily adapted to wide range virtual clusters distributed over geographically separated domains and heterogeneous machines (GRIDs).; While pure interactivity might not always be possible when performing a complicated analysis on a very large data set, PROOF still tries to give the user the interactive experience with something we call “interactive batch”. With “interactive batch” the user can start very long running queries, disconnect the client and at any time, any location and from",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1125637,adapt,adapt,1125637,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,"['Adapt', 'adapt']","['Adaptability', 'adapt']"
Energy Efficiency," node can be converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode: // a function that conditionally adds a Range to an RDataFrame node.; RNode MaybeAddRange(RNode df, bool mustAddRange); {; return mustAddRange ? df.Range(1) : df;; }; // use as :; ROOT::RDataFrame df(10);; auto maybeRangedDF = MaybeAddRange(df, true);; The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function ROOT.RDF.AsRNode. Storing RDataFrame objects in collections; ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a std::vector<RNode> or a std::map<std::string, RNode>:; std::vector<ROOT::RDF::RNode> dfs;; dfs.emplace_back(ROOT::RDataFrame(10));; dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));. Executing callbacks every N events; It's possible to schedule execution of arbitrary functions (callbacks) during the event loop. Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running, drawing a partially-filled histogram every time a certain number of new entries is processed, or displaying a progress bar while the event loop runs.; For example one can draw an up-to-date version of a result histogram every 100 entries like this: auto h = df.Histo1D(""x"");; TCanvas c(""c"",""x hist"");; h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; // event loop runs here, this final `Draw` is executed after the event loop is finished; h->Draw();; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:669; Callbacks are registered to a ROOT::RDF::RResultPtr and must be callables that takes a reference to the result type as argument and return nothing. RDataFrame will invoke registered callbacks passing partial action",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:59822,schedul,schedule,59822,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['schedul'],['schedule']
Energy Efficiency," node can be converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode: // a function that conditionally adds a Range to an RDataFrame node.; RNode MaybeAddRange(RNode df, bool mustAddRange); {; return mustAddRange ? df.Range(1) : df;; }; // use as :; ROOT::RDataFrame df(10);; auto maybeRangedDF = MaybeAddRange(df, true);; The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function ROOT.RDF.AsRNode. Storing RDataFrame objects in collections; ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a std::vector<RNode> or a std::map<std::string, RNode>:; std::vector<ROOT::RDF::RNode> dfs;; dfs.emplace_back(ROOT::RDataFrame(10));; dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));. Executing callbacks every N events; It's possible to schedule execution of arbitrary functions (callbacks) during the event loop. Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running, drawing a partially-filled histogram every time a certain number of new entries is processed, or displaying a progress bar while the event loop runs.; For example one can draw an up-to-date version of a result histogram every 100 entries like this: auto h = df.Histo1D(""x"");; TCanvas c(""c"",""x hist"");; h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; // event loop runs here, this final `Draw` is executed after the event loop is finished; h->Draw();; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; Callbacks are registered to a ROOT::RDF::RResultPtr and must be callables that takes a reference to the result type as argument and return nothing. RDataFrame will invoke registered callbacks passing partial action",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:61244,schedul,schedule,61244,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['schedul'],['schedule']
Energy Efficiency," non-integer x values, it IS NOT equal to the Poisson distribution !. Definition at line 587 of file TMath.cxx. ◆ PoissonI(). Double_t TMath::PoissonI ; (; Double_t ; x, . Double_t ; par . ). Computes the Discrete Poisson distribution function for (x,par). ; This is a discrete and a non-smooth function. This function is equivalent to ROOT::Math::poisson_pdf. Definition at line 615 of file TMath.cxx. ◆ Power() [1/5]. Double_t TMath::Power ; (; Double_t ; x, . Double_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 739 of file TMath.h. ◆ Power() [2/5]. Double_t TMath::Power ; (; Double_t ; x, . Int_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 745 of file TMath.h. ◆ Power() [3/5]. LongDouble_t TMath::Power ; (; Long64_t ; x, . Long64_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 733 of file TMath.h. ◆ Power() [4/5]. LongDouble_t TMath::Power ; (; LongDouble_t ; x, . Long64_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 727 of file TMath.h. ◆ Power() [5/5]. LongDouble_t TMath::Power ; (; LongDouble_t ; x, . LongDouble_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 721 of file TMath.h. ◆ Prob(). Double_t TMath::Prob ; (; Double_t ; chi2, . Int_t ; ndf . ). Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ; Calculations are based on the incomplete gamma function P(a,x), where a=ndf/2 and x=chi2/2.; P(a,x) represents the probability that the observed Chi-squared for a correct model should be less than the value chi2.; The returned probability corresponds to 1-P(a,x), which denotes the probability that an observed Chi-squared exceeds the value chi2 by chance, even for a correct model.; AuthorNvE 14-nov-1998 UU-SAP Utrecht ; Definition at line 637 of file TMath.cxx. ◆ Qe(). constexpr Double_t TMath::Qe ; (; ). constexpr . Elementary charge in \( C \) . ; Definition at line 339 of file TMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:72385,power,power,72385,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['power'],['power']
Energy Efficiency," not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See [Activating RDataFrame execution logs](\ref rdf-logging).; 966 ; 967### Memory usage; 968 ; 969There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage.; 970 ; 971Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, to allocate some memory for the generated code that is only released at the end of the application. This commonly results in memory usage creep in long-running applications that create many RDataFrames one after the other. Possible mitigations include creating and running each RDataFrame event loop in a sub-process, or booking all operations for all different RDataFrame computation graphs before the first event loop is triggered, so that the interpreter is invoked only once for all computation graphs:; 972 ; 973~~~{.cpp}; 974// assuming df1 and df2 are separate computation graphs, do:; 975auto h1 = df1.Histo1D(""x"");; 976auto h2 = df2.Histo1D(""y"");; 977h1->Draw(); // we just-in-time compile everything needed by df1 and df2 here; 978h2->Draw(""SAME"");; 979 ; 980// do not:; 981auto h1 = df1.Histo1D(""x"");; 982h1->Draw(); // we just-in-time compile here; 983auto h2 = df2.Histo1D(""y"");; 984h2->Draw(""SAME""); // we just-in-time compile again here, as the second His",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:56932,allocate,allocate,56932,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency," not exist are silently ignored. TString DetermineClass(const char[] varName); [static utility function]. returns empty string on failure.; otherwise returns something like this: ""TROOT*"".; fails for non-class types (ie, int, char, etc).; fails for pointers to functions. Bool_t ExcludedByFignore(TString s); [static utility function]. returns true iff ""s"" ends with one of; the strings listed in the ""TabCom.FileIgnore"" resource. TString GetSysIncludePath(); [static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char[] fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char[] path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char[] appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char[] dest, const char[] localName, const char[] appendage = 0, const char[] fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTabCom.html:11242,allocate,allocated,11242,root/html602/TTabCom.html,https://root.cern,https://root.cern/root/html602/TTabCom.html,4,['allocate'],['allocated']
Energy Efficiency," not supported, neither is removal of atoms.; The structure can be Refit() to occupy a single contiguous array. Function Members (Methods); public:. TEveChunkManager(); TEveChunkManager(Int_t atom_size, Int_t chunk_size); virtual~TEveChunkManager(); Char_t*Atom(Int_t idx) const; Int_tCapacity() const; Char_t*Chunk(Int_t chk) const; static TClass*Class(); virtual TClass*IsA() const; Int_tN() const; Int_tNAtoms(Int_t chk) const; Char_t*NewAtom(); Char_t*NewChunk(); voidRefit(); voidReset(Int_t atom_size, Int_t chunk_size); Int_tS() const; virtual voidShowMembers(TMemberInspector&); Int_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Int_tVecSize() const. protected:. voidReleaseChunks(). private:. TEveChunkManager(const TEveChunkManager&); TEveChunkManager&operator=(const TEveChunkManager&). Data Members; protected:. Int_tfCapacityAvailable capacity within the chunks; vector<TArrayC*>fChunksMemory blocks; Int_tfNNumber of atoms in a chunk; Int_tfSSize of atom; Int_tfSizeSize of container, number of atoms; Int_tfVecSizeNumber of allocated chunks. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ReleaseChunks(); Release all memory chunks. TEveChunkManager(); Default constructor.; Call reset for initialization. TEveChunkManager(Int_t atom_size, Int_t chunk_size); Constructor. ~TEveChunkManager(); Destructor. void Reset(Int_t atom_size, Int_t chunk_size); Empty the container and reset it with given atom and chunk sizes. void Refit(); Refit the container so that all current data fits into a single; chunk. Char_t* NewChunk(); Allocate a new memory chunk and register it. Char_t* NewAtom(). TEveChunkManager(const TEveChunkManager& ). TEveChunkManager& operator=(const TEveChunkManager& ). Int_t S() const; { return fS; }. Int_t N() const; { return fN; }. Int_t Size() const; { return fSize; }. Int_t VecSize() const; { return fVecSize; }. Int_t Capacity() const; { return fCapac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveChunkManager.html:1618,allocate,allocated,1618,root/html534/TEveChunkManager.html,https://root.cern,https://root.cern/root/html534/TEveChunkManager.html,2,['allocate'],['allocated']
Energy Efficiency," not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:19335,allocate,allocate,19335,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,8,['allocate'],['allocate']
Energy Efficiency, number of doubles read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer.; Definition at line 934 of file TBufferFile.cxx. ◆ ReadArray() [4/13]. Int_t TBufferFile::ReadArray ; (; Float_t *& ; f). overridevirtual . Read array of floats from the I/O buffer. ; Returns the number of floats read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer.; Definition at line 901 of file TBufferFile.cxx. ◆ ReadArray() [5/13]. Int_t TBufferFile::ReadArray ; (; Int_t *& ; ii). overridevirtual . Read array of ints from the I/O buffer. ; Returns the number of ints read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer.; Definition at line 814 of file TBufferFile.cxx. ◆ ReadArray() [6/13]. Int_t TBufferFile::ReadArray ; (; Long64_t *& ; ll). overridevirtual . Read array of long longs from the I/O buffer. ; Returns the number of long longs read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer.; Definition at line 873 of file TBufferFile.cxx. ◆ ReadArray() [7/13]. Int_t TBufferFile::ReadArray ; (; Long_t *& ; ll). overridevirtual . Read array of longs from the I/O buffer. ; Returns the number of longs read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer.; Definition at line 847 of file TBufferFile.cxx. ◆ ReadArray() [8/13]. Int_t TBufferFile::ReadArray ; (; Short_t *& ; h). overridevirtual . Read array of shorts from the I/O buffer. ; Returns the number of shorts read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer.; Definition at line 781 of file TBufferFile.cxx. ◆ ReadArray() [9/13]. Int_t TBufferFile::ReadArray ; (; UChar_t *& ; c). inlineoverridevirtual . Implements TBuffer.; Definition at line 456 of file TBufferFile.h. ◆ ReadArray() [10/13]. Int_t TBufferFile::ReadArray ; (; UInt_t *& ; i). inlineoverridevirtual . Implements,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:47736,allocate,allocated,47736,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['allocate'],['allocated']
Energy Efficiency, number of ints read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer.; Definition at line 814 of file TBufferFile.cxx. ◆ ReadArray() [6/13]. Int_t TBufferFile::ReadArray ; (; Long64_t *& ; ll). overridevirtual . Read array of long longs from the I/O buffer. ; Returns the number of long longs read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer.; Definition at line 873 of file TBufferFile.cxx. ◆ ReadArray() [7/13]. Int_t TBufferFile::ReadArray ; (; Long_t *& ; ll). overridevirtual . Read array of longs from the I/O buffer. ; Returns the number of longs read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer.; Definition at line 847 of file TBufferFile.cxx. ◆ ReadArray() [8/13]. Int_t TBufferFile::ReadArray ; (; Short_t *& ; h). overridevirtual . Read array of shorts from the I/O buffer. ; Returns the number of shorts read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer.; Definition at line 781 of file TBufferFile.cxx. ◆ ReadArray() [9/13]. Int_t TBufferFile::ReadArray ; (; UChar_t *& ; c). inlineoverridevirtual . Implements TBuffer.; Definition at line 456 of file TBufferFile.h. ◆ ReadArray() [10/13]. Int_t TBufferFile::ReadArray ; (; UInt_t *& ; i). inlineoverridevirtual . Implements TBuffer.; Definition at line 462 of file TBufferFile.h. ◆ ReadArray() [11/13]. Int_t TBufferFile::ReadArray ; (; ULong64_t *& ; l). inlineoverridevirtual . Implements TBuffer.; Definition at line 468 of file TBufferFile.h. ◆ ReadArray() [12/13]. Int_t TBufferFile::ReadArray ; (; ULong_t *& ; l). inlineoverridevirtual . Implements TBuffer.; Definition at line 465 of file TBufferFile.h. ◆ ReadArray() [13/13]. Int_t TBufferFile::ReadArray ; (; UShort_t *& ; h). inlineoverridevirtual . Implements TBuffer.; Definition at line 459 of file TBufferFile.h. ◆ ReadArrayDouble32(). Int_t TBufferFile::ReadArrayDouble32 ; (; Do,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:48358,allocate,allocated,48358,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['allocate'],['allocated']
Energy Efficiency," object by itself and must contain data of at least maxbytes Returns nread;; In output arguments:. nbytes : number of bytes in record if negative, this is a deleted record if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header. Note that the arguments objlen and keylen are returned only if maxbytes >=16 Note: This was adapted from TFile... so some things dont apply ; Definition at line 469 of file TTreeCacheUnzip.cxx. ◆ GetUnzipBuffer(). Int_t TTreeCacheUnzip::GetUnzipBuffer ; (; char ** ; buf, . Long64_t ; pos, . Int_t ; len, . bool * ; free . ). overridevirtual . We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ; pos and len are the original values as were passed to ReadBuffer but instead we will return the inflated buffer. Note!! : If *buf == 0 we will allocate the buffer and it will be the responsibility of the caller to free it... it is useful for example to pass it to the creator of TBuffer ; Reimplemented from TFileCacheRead.; Definition at line 668 of file TTreeCacheUnzip.cxx. ◆ GetUnzipGroupSize(). Int_t TTreeCacheUnzip::GetUnzipGroupSize ; (; ). inline . Definition at line 142 of file TTreeCacheUnzip.h. ◆ Init(). void TTreeCacheUnzip::Init ; (; ). private . Initialization procedure common to all the constructors. ; Definition at line 196 of file TTreeCacheUnzip.cxx. ◆ IsA(). TClass * TTreeCacheUnzip::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TTreeCache.; Definition at line 159 of file TTreeCacheUnzip.h. ◆ IsParallelUnzip(). bool TTreeCacheUnzip::IsParallelUnzip ; (; ). static . Static function that tells wether the multithreading unzipping is activated. ; Definition at line 415 of file TTreeCacheUnzip.cxx. ◆ operator=(). TTreeCacheUnzip & TTreeCacheUnzip::operator= ; (; const TTreeCacheUnz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:31013,allocate,allocate,31013,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,1,['allocate'],['allocate']
Energy Efficiency," object by itself and must contain data of at least maxbytes Returns nread;; In output arguments:. nbytes : number of bytes in record if negative, this is a deleted record if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header. Note that the arguments objlen and keylen are returned only if maxbytes >=16 Note: This was adapted from TFile... so some things dont apply ; Definition at line 470 of file TTreeCacheUnzip.cxx. ◆ GetUnzipBuffer(). Int_t TTreeCacheUnzip::GetUnzipBuffer ; (; char ** ; buf, . Long64_t ; pos, . Int_t ; len, . bool * ; free . ). overridevirtual . We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ; pos and len are the original values as were passed to ReadBuffer but instead we will return the inflated buffer. Note!! : If *buf == 0 we will allocate the buffer and it will be the responsibility of the caller to free it... it is useful for example to pass it to the creator of TBuffer ; Reimplemented from TFileCacheRead.; Definition at line 669 of file TTreeCacheUnzip.cxx. ◆ GetUnzipGroupSize(). Int_t TTreeCacheUnzip::GetUnzipGroupSize ; (; ). inline . Definition at line 142 of file TTreeCacheUnzip.h. ◆ Init(). void TTreeCacheUnzip::Init ; (; ). private . Initialization procedure common to all the constructors. ; Definition at line 196 of file TTreeCacheUnzip.cxx. ◆ IsA(). TClass * TTreeCacheUnzip::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TTreeCache.; Definition at line 159 of file TTreeCacheUnzip.h. ◆ IsParallelUnzip(). bool TTreeCacheUnzip::IsParallelUnzip ; (; ). static . Static function that tells wether the multithreading unzipping is activated. ; Definition at line 416 of file TTreeCacheUnzip.cxx. ◆ operator=(). TTreeCacheUnzip & TTreeCacheUnzip::operator= ; (; const TTreeCacheUnz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:31017,allocate,allocate,31017,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,1,['allocate'],['allocate']
Energy Efficiency," object from the list of functions. Int_t RemovePoint(); Delete point close to the mouse position. Int_t RemovePoint(Int_t ipoint); Delete point number ipoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void Set(Int_t n); Set number of points in the graph; Existing coordinates are preserved; New coordinates above fNpoints are preset to 0. Bool_t GetEditable() const; Return kTRUE if kNotEditable bit is not set, kFALSE otherwise. void SetEditable(Bool_t editable = kTRUE); if editable=kFALSE, the graph cannot be modified with the mouse; by default a TGraph is editable. void SetMaximum(Double_t maximum = -1111); Set the maximum of the graph. void SetMinimum(Double_t minimum = -1111); Set the minimum of the graph. void SetPoint(Int_t i, Double_t x, Double_t y); Set x and y values for point number i. void SetTitle(const char* title = """"); Set graph title. Double_t ** ShrinkAndCopy(Int_t size, Int_t iend); if size*2 <= fMaxSize allocate new arrays of size points,; copy points [0,oend).; Return newarray (passed or new instance if it was zero; and allocations are needed). void Sort(Bool_t (*)(const TGraph*, Int_t, Int_t) greater = &TGraph::CompareX, Bool_t ascending = kTRUE, Int_t low = 0, Int_t high = -1111); Sorts the points of this TGraph using in-place quicksort (see e.g. older glibc).; To compare two points the function parameter greaterfunc is used (see TGraph::CompareX for an; example of such a method, which is also the default comparison function for Sort). After; the sort, greaterfunc(this, i, j) will return kTRUE for all i>j if ascending == kTRUE, and; kFALSE otherwise. The last two parameters are used for the recursive quick sort, stating the range to be sorted. Examples:; // sort points along x axis; graph->Sort();; // sort points along their distance to origin; graph->Sort(&TGraph::CompareRadius);. Bool_t CompareErrors(const TGraph* gr, Int_t i, Int_t j) {; const TGraphErrors* ge=(const TGr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraph.html:38281,allocate,allocate,38281,root/html528/TGraph.html,https://root.cern,https://root.cern/root/html528/TGraph.html,6,['allocate'],['allocate']
Energy Efficiency," object from the list of functions. Int_t RemovePoint(); Delete point close to the mouse position. Int_t RemovePoint(Int_t ipoint); Delete point number ipoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void Set(Int_t n); Set number of points in the graph; Existing coordinates are preserved; New coordinates above fNpoints are preset to 0. Bool_t GetEditable() const; Return kTRUE if kNotEditable bit is not set, kFALSE otherwise. void SetEditable(Bool_t editable = kTRUE); if editable=kFALSE, the graph cannot be modified with the mouse; by default a TGraph is editable. void SetMaximum(Double_t maximum = -1111); Set the maximum of the graph. void SetMinimum(Double_t minimum = -1111); Set the minimum of the graph. void SetPoint(Int_t i, Double_t x, Double_t y); Set x and y values for point number i. void SetTitle(const char* title = """"); Set graph title. Double_t ** ShrinkAndCopy(Int_t size, Int_t iend); if size*2 <= fMaxSize allocate new arrays of size points,; copy points [0,oend).; Return newarray (passed or new instance if it was zero; and allocations are needed). void Sort(Bool_t(*)(const TGraph*,Int_t,Int_t) greater = &TGraph::CompareX, Bool_t ascending = kTRUE, Int_t low = 0, Int_t high = -1111); Sorts the points of this TGraph using in-place quicksort (see e.g. older glibc).; To compare two points the function parameter greaterfunc is used (see TGraph::CompareX for an; example of such a method, which is also the default comparison function for Sort). After; the sort, greaterfunc(this, i, j) will return kTRUE for all i>j if ascending == kTRUE, and; kFALSE otherwise. The last two parameters are used for the recursive quick sort, stating the range to be sorted. Examples:; // sort points along x axis; graph->Sort();; // sort points along their distance to origin; graph->Sort(&TGraph::CompareRadius);. Bool_t CompareErrors(const TGraph* gr, Int_t i, Int_t j) {; const TGraphErrors* ge=(const TGraph",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraph.html:40498,allocate,allocate,40498,root/html602/TGraph.html,https://root.cern,https://root.cern/root/html602/TGraph.html,4,['allocate'],['allocate']
Energy Efficiency," object in an invalid state.; 1349 ; 1350\note RVec methods (e.g. `at` or `size`) follow the STL naming convention instead of the ROOT naming convention in order; 1351to make RVec a drop-in replacement for `std::vector`.; 1352 ; 1353\htmlonly; 1354<a href=""https://doi.org/10.5281/zenodo.1253756""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.1253756.svg"" alt=""DOI""></a>; 1355\endhtmlonly; 1356 ; 1357## Table of Contents; 1358- [Example](\ref example); 1359- [Arithmetic operations, logical operations and mathematical functions](\ref operationsandfunctions); 1360- [Owning and adopting memory](\ref owningandadoptingmemory); 1361- [Sorting and manipulation of indices](\ref sorting); 1362- [Usage in combination with RDataFrame](\ref usagetdataframe); 1363- [Reference for the RVec class](\ref RVecdoxyref); 1364- [Reference for RVec helper functions](https://root.cern/doc/master/namespaceROOT_1_1VecOps.html); 1365 ; 1366\anchor example; 1367## Example; 1368Suppose to have an event featuring a collection of muons with a certain pseudorapidity,; 1369momentum and charge, e.g.:; 1370~~~{.cpp}; 1371std::vector<short> mu_charge {1, 1, -1, -1, -1, 1, 1, -1};; 1372std::vector<float> mu_pt {56, 45, 32, 24, 12, 8, 7, 6.2};; 1373std::vector<float> mu_eta {3.1, -.2, -1.1, 1, 4.1, 1.6, 2.4, -.5};; 1374~~~; 1375Suppose you want to extract the transverse momenta of the muons satisfying certain; 1376criteria, for example consider only negatively charged muons with a pseudorapidity; 1377smaller or equal to 2 and with a transverse momentum greater than 10 GeV.; 1378Such a selection would require, among the other things, the management of an explicit; 1379loop, for example:; 1380~~~{.cpp}; 1381std::vector<float> goodMuons_pt;; 1382const auto size = mu_charge.size();; 1383for (size_t i=0; i < size; ++i) {; 1384 if (mu_pt[i] > 10 && abs(mu_eta[i]) <= 2. && mu_charge[i] == -1) {; 1385 goodMuons_pt.emplace_back(mu_pt[i]);; 1386 }; 1387}; 1388~~~; 1389These operations become straightforward ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:47835,charge,charge,47835,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['charge'],['charge']
Energy Efficiency," objects. At each Tree::Fill, the branch numbers containing the; referenced objects are saved to the TBranchRef basket.; When the Tree header is saved (via TTree::Write), the branch; is saved keeping the information with the pointers to the branches; having referenced objects. TBranch* Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); Create a new TTree BranchElement. WARNING about this new function. This function is designed to replace the internal; implementation of the old TTree::Branch (whose implementation; has been moved to BranchOld). NOTE: The 'Bronch' method supports only one possible calls; signature (where the object type has to be specified; explicitly and the address must be the address of a pointer).; For more flexibility use 'Branch'. Use Bronch only in (rare); cases (likely to be legacy cases) where both the new and old; implementation of Branch needs to be used at the same time. This function is far more powerful than the old Branch; function. It supports the full C++, including STL and has; the same behaviour in split or non-split mode. classname does; not have to derive from TObject. The function is based on; the new TStreamerInfo. Build a TBranchElement for an object of class classname. addr is the address of a pointer to an object of class; classname. The class dictionary must be available (ClassDef; in class header). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addr parameter. This option requires access to the library where the; corresponding class is defined. Accessing one single data; member in the object implies reading the full object. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:54741,power,powerful,54741,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,6,['power'],['powerful']
Energy Efficiency," of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum that were described unloaded enum ;  CTListOfEnumsWithLockIterIterator for TListOfEnumsWithLock ;  CTListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFunction that were described unloaded function ;  CTListOfFunctionsIterIterator for TListOfFunctions ;  CTListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFunction that were described unloaded function ;  CTListOfTypesA collection of TDataType designed to hold the typedef information and numerical type information ;  CTLockFileA scoped lock based on files ;  CTLockGuard;  ►CTLorentzRotation;  CTLorentzRotationRow;  CTLorentzVector;  CTMacOSXSystem;  CTMacroClass supporting a collection of lines with C++ code ;  CTMakeProject;  CTMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval (therefore TMap does not conserve the order of the entries) ;  CTMapFileThis class implements a shared memory region mapped to a file ;  CTMapIterIterator of map ;  CTMapRecKeep track of an object in the mapped file ;  CTMarkerManages Markers ;  CTMarker3DBoxA special 3-D marker designed for event display ;  CTMaterialManages a detector material ;  CTMathTextTo draw TeX Mathematical Formula ;  CTMatrixDEigen;  CTMatrixDSymEigen;  CTMatrixT;  CTMatrixTBase;  CTMatrixTColumn;  CTMatrixTColumn_const;  CTMatrixTDiag;  CTMatrixTDiag_const;  CTMatrixTFlat;  CTMatrixTFlat_const;  CTMatrixTLazy;  CTMatrixTRow;  CTMatrixTRow_const;  CTMatrixTSparse;  CTMatrixTSparseDiag;  CTMatrixTSparseDiag_const;  CTMatrixTSparseRow;  CTMatrixTSparseRow_const;  CTMatrixTSub;  CTMatrixTSub_const;  CTMatrixTSym;  CTMatrixTSymLazy;  CTMCParticle;  CTMCVerbose;  CTMD5This code implements the MD5 message-digest algorithm ;  CTMehrotraSolver;  CTMemberInspectorAbstract base class for accessing the da",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:141377,efficient,efficient,141377,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,2,['efficient'],['efficient']
Energy Efficiency," of X points; Double_t*TGraph::fY[fNpoints] array of Y points. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCutG(); TCutG default constructor. TCutG(const TCutG& cutg); TCutG copy constructor. TCutG(const char* name, Int_t n); TCutG normal constructor. TCutG(const char* name, Int_t n, const Float_t* x, const Float_t* y); TCutG normal constructor. TCutG(const char* name, Int_t n, const Double_t* x, const Double_t* y); TCutG normal constructor. ~TCutG(); TCutG destructor. Double_t Area() const; Compute the area inside this TCutG; The algorithm uses Stoke's theorem over the border of the closed polygon.; Just as a reminder: Stoke's theorem reduces a surface integral; to a line integral over the border of the surface integral. void Center(Double_t& cx, Double_t& cy) const; Compute the center x,y of this TCutG; The algorithm uses Stoke's theorem over the border of the closed polygon.; Just as a reminder: Stoke's theorem reduces a surface integral; to a line integral over the border of the surface integral. Double_t IntegralHist(TH2* h, Option_t* option = """") const; Compute the integral of 2-d histogram h for all bins inside the cut; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetObjectX(TObject* obj); Set the X object (and delete the previous one if any). void SetObjectY(TObject* obj); Set the Y object (and delete the previous one if any). void SetVarX(const char* varx); Set X variable. void SetVarY(const char* vary); Set Y variable. void Streamer(TBuffer& b); Stream an object of class TCutG. TObject * GetObjectX() const; {return fObjectX;}. TObject * GetObjectY() const; {return fObjectY;}. const char * GetVarX() const; {return fVarX.Data();}. const char * GetVarY() const; {return fVarY.Data();}. » Author: Rene Brun 16/05/97 » Copyr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TCutG.html:16924,reduce,reduces,16924,root/html528/TCutG.html,https://root.cern,https://root.cern/root/html528/TCutG.html,4,['reduce'],['reduces']
Energy Efficiency," of a given input p.d.f and the object returned by RooAbsPdf::createProjection. More...;  ; class  RooPullVar;  Represents the pull of a measurement w.r.t. More...;  ; class  RooQuasiRandomGenerator;  This class generates the quasi-random (aka ""low discrepancy"") sequence for dimensions up to 12 using the Niederreiter base 2 algorithm described in Bratley, Fox, Niederreiter, ACM Trans. More...;  ; class  RooRandom;  This class provides a static interface for generating random numbers. More...;  ; class  RooRandomizeParamMCSModule;  Add-on module to RooMCStudy that allows you to randomize input generation parameters. More...;  ; class  RooRangeBinning;  Binning/range definition that only defines a range but no binning. More...;  ; class  RooRangeBoolean;  Returns 1.0 if variable is within given a range and 0.0 otherwise. More...;  ; class  RooRatio;  Represents the ratio of two RooAbsReal objects. More...;  ; class  RooRealBinding;  Lightweight interface adaptor that binds a RooAbsReal object to a subset of its servers and present it as a simple array oriented interface. More...;  ; class  RooRealConstant;  Provides static functions to create and keep track of RooRealVar constants. More...;  ; class  RooRealIntegral;  Performs hybrid numerical/analytical integrals of RooAbsReal objects. More...;  ; class  RooFit::TestStatistics::RooRealL;  RooAbsReal that wraps RooAbsL likelihoods for use in RooFit outside of the RooMinimizer context. More...;  ; class  RooRealMPFE;  Multi-processor front-end for parallel calculation of RooAbsReal objects. More...;  ; class  RooRealSumPdf;  Implements a PDF constructed from a sum of functions: More...;  ; class  RooRealVar;  Variable that can be changed from the outside. More...;  ; class  RooRealVarSharedProperties;  Implementation of RooSharedProperties that stores the properties of a RooRealVar that are shared among clones. More...;  ; class  RooRecursiveFraction;  A RooAbsReal implementation that calculates the plain fraction of su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Roofitcore.html:17084,adapt,adaptor,17084,doc/master/group__Roofitcore.html,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html,1,['adapt'],['adaptor']
Energy Efficiency," of file RooAbsData.cxx. ◆ printName(). void RooAbsData::printName ; (; std::ostream & ; os); const. overridevirtual . Print name of dataset. ; Reimplemented from RooPrintable.; Definition at line 783 of file RooAbsData.cxx. ◆ printTitle(). void RooAbsData::printTitle ; (; std::ostream & ; os); const. overridevirtual . Print title of dataset. ; Reimplemented from RooPrintable.; Definition at line 791 of file RooAbsData.cxx. ◆ RecursiveRemove(). void RooAbsData::RecursiveRemove ; (; TObject * ; obj). overridevirtual . If one of the TObject we have a referenced to is deleted, remove the reference. ; Reimplemented from TObject.; Definition at line 2458 of file RooAbsData.cxx. ◆ reduce() [1/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const char * ; cut); const. Create a subset of the data set by applying the given cut on the data points. ; The cut expression can refer to any variable in the data set. For cuts involving other variables, such as intermediate formula objects, use the equivalent reduce method specifying the as a RooFormulVar reference. ; Definition at line 472 of file RooAbsData.cxx. ◆ reduce() [2/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const RooArgSet & ; varSubset, . const char * ; cut = nullptr . ); const. Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ; The cut expression can refer to any variable in the data set. For cuts involving other variables, such as intermediate formula objects, use the equivalent reduce method specifying the as a RooFormulVar reference. ; Definition at line 500 of file RooAbsData.cxx. ◆ reduce() [3/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const RooArgSet & ; varSubset, . const RooFormulaVar & ; cutVar . ); const. Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ; The 'cutVar' formula variable is used to select the subse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:62258,reduce,reduce,62258,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['reduce'],['reduce']
Energy Efficiency," of file TListOfFunctions.cxx. ◆ GetListForObject() [2/2]. TList * TListOfFunctions::GetListForObject ; (; const TObject * ; obj); const. virtual . Return the set of overloads for function obj, collecting all available ones. ; Can construct and insert new TFunction-s. ; Definition at line 239 of file TListOfFunctions.cxx. ◆ GetListForObjectNonConst(). TList * TListOfFunctions::GetListForObjectNonConst ; (; const char * ; name). private . Return the set of overloads for this name, collecting all available ones. ; Can construct and insert new TFunction-s. ; Definition at line 191 of file TListOfFunctions.cxx. ◆ GetObjectRef(). TObject ** TListOfFunctions::GetObjectRef ; (; const TObject * ; obj); const. overridevirtual . Return address of pointer to obj. ; Reimplemented from TList.; Definition at line 499 of file TListOfFunctions.cxx. ◆ GetSize(). Int_t TListOfFunctions::GetSize ; (; ); const. overridevirtual . Return the capacity of the collection, i.e. ; the current total amount of space that has been allocated so far. Same as Capacity. Use GetEntries to get the number of elements currently in the collection. ; Reimplemented from TCollection.; Definition at line 541 of file TListOfFunctions.cxx. ◆ IndexOf(). Int_t TListOfFunctions::IndexOf ; (; const TObject * ; obj); const. overridevirtual . Return index of object in collection. ; Returns -1 when object not found. Uses member IsEqual() to find object. ; Reimplemented from TSeqCollection.; Definition at line 532 of file TListOfFunctions.cxx. ◆ IsA(). TClass * TListOfFunctions::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from THashList.; Definition at line 102 of file TListOfFunctions.h. ◆ Last(). TObject * TListOfFunctions::Last ; (; ); const. overridevirtual . Return the last object in the list. Returns 0 when list is empty. ; Reimplemented from TList.; Definition at line 507 of file TListOfFunctions.cxx. ◆ LastLink(). TObjLink * TListOfFunctions::LastLink ; (;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctions.html:30950,allocate,allocated,30950,doc/master/classTListOfFunctions.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctions.html,1,['allocate'],['allocated']
Energy Efficiency," of file TStorage.cxx. ◆ FilledByObjectAlloc(). Bool_t TStorage::FilledByObjectAlloc ; (; volatile const UInt_t *const ; member). inlinestatic . Definition at line 88 of file TStorage.h. ◆ GetFreeHook(). FreeHookFun_t TStorage::GetFreeHook ; (; ). inlinestatic . Definition at line 135 of file TStorage.h. ◆ GetFreeHookData(). void * TStorage::GetFreeHookData ; (; ). static . return static free hook data ; Definition at line 426 of file TStorage.cxx. ◆ GetMaxBlockSize(). size_t TStorage::GetMaxBlockSize ; (; ). inlinestatic . Definition at line 131 of file TStorage.h. ◆ HasCustomNewDelete(). Bool_t TStorage::HasCustomNewDelete ; (; ). static . return the has custom delete flag ; Definition at line 434 of file TStorage.cxx. ◆ IsA(). virtual TClass * TStorage::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 85 of file TStorage.h. ◆ ObjectAlloc() [1/2]. void * TStorage::ObjectAlloc ; (; size_t ; sz). static . Used to allocate a TObject on the heap (via TObject::operator new()). ; Directly after this routine one can call (in the TObject ctor) TStorage::FilledByObjectAlloc() to find out if the just created object is on the heap. This technique is necessary as there is one stack per thread and we can not rely on comparison with the current stack memory position. ; Definition at line 291 of file TStorage.cxx. ◆ ObjectAlloc() [2/2]. void * TStorage::ObjectAlloc ; (; size_t ; size, . void * ; vp . ). static . Used to allocate a TObject on the heap (via TObject::operator new(size_t,void*)) in position vp. ; vp is already allocated (maybe on heap, maybe on stack) so just return. ; Definition at line 314 of file TStorage.cxx. ◆ ObjectAllocArray(). void * TStorage::ObjectAllocArray ; (; size_t ; sz). static . Used to allocate array of TObject on the heap (via TObject::operator new[]()). ; Unlike the 'singular' ObjectAlloc, we do not mark those object has being allocated on the heap as they can not be individually deleted. ; Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStorage.html:7119,allocate,allocate,7119,doc/master/classTStorage.html,https://root.cern,https://root.cern/doc/master/classTStorage.html,1,['allocate'],['allocate']
Energy Efficiency," of quaternion is null, creates identity rotation; if quaternion is non-unit, creates rotation corresponding to the normalized (unit) quaternion. TRotation & Rotate(Double_t , const TVector3& ); rotate along an axis. TRotation & RotateX(Double_t ); rotate around x. TRotation & RotateY(Double_t ); rotate around y. TRotation & RotateZ(Double_t ); rotate around z. TRotation & RotateAxes(const TVector3& newX, const TVector3& newY, const TVector3& newZ); rotate axes. Double_t PhiX() const; return Phi. Double_t PhiY() const; return Phi. Double_t PhiZ() const; return Phi. Double_t ThetaX() const; return Phi. Double_t ThetaY() const; return Theta. Double_t ThetaZ() const; return Theta. void AngleAxis(Double_t& , TVector3& ) const; rotation defined by an angle and a vector. TRotation & SetXEulerAngles(Double_t phi, Double_t theta, Double_t psi); Rotate using the x-convention (Landau and Lifshitz, Goldstein, &c) by; doing the explicit rotations. This is slightly less efficient than; directly applying the rotation, but makes the code much clearer. My; presumption is that this code is not going to be a speed bottle neck. TRotation & SetYEulerAngles(Double_t phi, Double_t theta, Double_t psi); Rotate using the y-convention. TRotation & RotateXEulerAngles(Double_t phi, Double_t theta, Double_t psi); Rotate using the x-convention. TRotation & RotateYEulerAngles(Double_t phi, Double_t theta, Double_t psi); Rotate using the y-convention. void SetXPhi(Double_t ); set XPhi. void SetXTheta(Double_t ); set XTheta. void SetXPsi(Double_t ); set XPsi. void SetYPhi(Double_t ); set YPhi. void SetYTheta(Double_t ); set YTheta. void SetYPsi(Double_t ); set YPsi. Double_t GetXPhi(void); return phi angle. Double_t GetYPhi(void); return YPhi. Double_t GetXTheta(void); return XTheta. Double_t GetYTheta(void); return YTheta. Double_t GetXPsi(void); Get psi angle. Double_t GetYPsi(void); return YPsi. TRotation & SetXAxis(const TVector3& axis, const TVector3& xyPlane); set X axis. TRotation & SetXAxis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRotation.html:13980,efficient,efficient,13980,root/html528/TRotation.html,https://root.cern,https://root.cern/root/html528/TRotation.html,10,['efficient'],['efficient']
Energy Efficiency," of steps without improvement to consider the DNN to have convergedDefinition NeuralNet.h:837; TMVA::DNN::Settings::hasConvergedvirtual bool hasConverged(double testError)has this training converged already?Definition NeuralNet.cxx:485; TMVA::DNN::Settings::minimizerTypeMinimizerType minimizerType() constwhich minimizer shall be used (e.g. SGD)Definition NeuralNet.h:774; TMVA::DNN::Settings::m_dropOutstd::vector< double > m_dropOutDefinition NeuralNet.h:850; TMVA::DNN::Settings::m_minProgressdouble m_minProgresscurrent limits for the progress barDefinition NeuralNet.h:833; TMVA::DNN::Settings::cyclevirtual void cycle(double progress, TString text)Definition NeuralNet.h:799; TMVA::DNN::Settings::setProgressLimitsvirtual void setProgressLimits(double minProgress=0, double maxProgress=100)Definition NeuralNet.h:790; TMVA::DNN::Settings::m_maxProgressdouble m_maxProgresscurrent limits for the progress barDefinition NeuralNet.h:834; TMVA::DNN::Settings::endTrainCyclevirtual void endTrainCycle(double)callback for monitoring and loggingDefinition NeuralNet.h:788; TMVA::DNN::Settings::count_dEsize_t count_dEDefinition NeuralNet.h:843; TMVA::DNN::Settings::drawSamplevirtual void drawSample(const std::vector< double > &, const std::vector< double > &, const std::vector< double > &, double)callback for monitoring and loggingDefinition NeuralNet.h:807; TMVA::DNN::Settings::learningRatedouble learningRate() constget the learning rateDefinition NeuralNet.h:771; TMVA::DNN::Settings::m_dropRepetitionsdouble m_dropRepetitionsDefinition NeuralNet.h:849; TMVA::DNN::Settings::dropFractionsconst std::vector< double > & dropFractions() constDefinition NeuralNet.h:762; TMVA::DNN::Settings::addPointvoid addPoint(std::string histoName, double x)for monitoringDefinition NeuralNet.h:821; TMVA::DNN::Settings::~Settingsvirtual ~Settings()d'torDefinition NeuralNet.cxx:261; TMVA::DNN::Settings::m_convergenceCountsize_t m_convergenceCountDefinition NeuralNet.h:857; TMVA::DNN::Settings::m_regulariza",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:74232,monitor,monitoring,74232,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['monitor'],['monitoring']
Energy Efficiency," of the ROOT::Math::GSLIntegrator class.; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied \[; absErr <= max ( epsAbs, epsRel * Integral); \] Where absErr is an estimate of the absolute error (it can be retrieved with GSLIntegrator::Error()) and Integral is the estimate of the function integral (it can be obtained with GSLIntegrator::Result()); The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the GSL users documentation. * ROOT::Math::Integration::kNONADAPTIVE : based on gsl_integration_qng. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions. * ROOT::Math::Integration::kADAPTIVE: based on gsl_integration_qag. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are * Integration::kGAUSS15 : 15 points Gauss-Konrod rule (value = 1) * Integration::kGAUSS21 : 21 points Gauss-Konrod rule (value = 2) * Integration::kGAUSS31 : 31 points Gauss-Konrod rule (value = 3) * Integration::kGAUSS41 : 41 points Gauss-Konrod rule (value = 4) * Integration::kGAUSS51 : 51 points Gauss-Konrod rule (value = 5) * Integration::kGAUSS61 : 61 points Gauss-Konrod rule (value = 6) The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the functi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:707433,adapt,adaptive,707433,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['adapt'],['adaptive']
Energy Efficiency," of the probabi...Definition TMath.cxx:2815; TMath::Sigmaconstexpr Double_t Sigma()Stefan-Boltzmann constant in : .Definition TMath.h:270; TMath::BetaDouble_t Beta(Double_t p, Double_t q)Calculates Beta-function Gamma(p)*Gamma(q)/Gamma(p+q).Definition TMath.cxx:2011; TMath::Kcgsconstexpr Double_t Kcgs()Definition TMath.h:254; TMath::SqDouble_t Sq(Double_t x)Returns x*x.Definition TMath.h:656; TMath::PoissonDouble_t Poisson(Double_t x, Double_t par)Computes the Poisson distribution function for (x,par).Definition TMath.cxx:587; TMath::Hconstexpr Double_t H()Planck's constant in : .Definition TMath.h:188; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::CeilNintInt_t CeilNint(Double_t x)Returns the nearest integer of TMath::Ceil(x).Definition TMath.h:674; TMath::LdexpDouble_t Ldexp(Double_t x, Int_t exp)Returns the result of multiplying x (the significant) by 2 raised to the power of exp (the exponent).Definition TMath.h:715; TMath::BesselJ0Double_t BesselJ0(Double_t x)Modified Bessel function K_1(x)Definition TMath.cxx:1634; TMath::LogEconstexpr Double_t LogE()Base-10 log of e (to convert ln to log)Definition TMath.h:107; TMath::GammaDouble_t Gamma(Double_t z)Computation of gamma(z) for all z.Definition TMath.cxx:353; TMath::MWairconstexpr Double_t MWair()Molecular weight of dry air 1976 US Standard Atmosphere in orDefinition TMath.h:317; TMath::Gcgsconstexpr Double_t Gcgs()Definition TMath.h:143; TMath::StruveL0Double_t StruveL0(Double_t x)Struve functions of order 1.Definition TMath.cxx:1923; TMath::NormQuantileDouble_t NormQuantile(Double_t p)Computes quantiles for standard normal distribution N(0, 1) at probability p.Definition TMath.cxx:2456; TMath::Ln10constexpr Double_t Ln10()Natural log of 10 (to convert log to ln)Definition TMath.h:100; TMath::HypotDouble_t Hypot(Double_t x, Double_t y)Returns sqr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:66461,power,power,66461,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['power'],['power']
Energy Efficiency," of transition to a power law on the left, in standard deviations away from the mean. ; nLExponent of power-law tail on the left. ; alphaRLocation of transition to a power law on the right, in standard deviations away from the mean. ; nRExponent of power-law tail on the right. . Definition at line 102 of file RooCrystalBall.cxx. ◆ RooCrystalBall() [4/5]. RooCrystalBall::RooCrystalBall ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . RooAbsReal & ; x0, . RooAbsReal & ; sigmaLR, . RooAbsReal & ; alpha, . RooAbsReal & ; n, . bool ; doubleSided = false . ). Create a crystal ball shape with symmetric Gaussian core and only a tail on one side (just like RooCBShape) or two symmetric tails (like RooSDSCBShape). ; Parameters. nameName that identifies the PDF in computations. ; titleTitle for plotting. ; xThe variable of the PDF. ; x0Location parameter of the Gaussian component. ; sigmaLRWidth parameter of the Gaussian component. ; alphaLocation of transition to a power law, in standard deviations away from the mean. ; nExponent of power-law tail. ; doubleSidedWhether the tail is only on one side or on both sides . Definition at line 129 of file RooCrystalBall.cxx. ◆ RooCrystalBall() [5/5]. RooCrystalBall::RooCrystalBall ; (; const RooCrystalBall & ; other, . const char * ; name = nullptr . ). Copy a RooCrystalBall. ; Definition at line 150 of file RooCrystalBall.cxx. Member Function Documentation. ◆ analyticalIntegral(). double RooCrystalBall::analyticalIntegral ; (; Int_t ; code, . const char * ; rangeName = nullptr . ); const. overridevirtual . Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ; This functions will only be called with codes returned by getAnalyticalIntegral, except code zero. ; Reimplemented from RooAbsReal.; Definition at line 241 of file RooCrystalBall.cxx. ◆ Class(). static TClass * RooCrystalBall::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooCry",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCrystalBall.html:77995,power,power,77995,doc/master/classRooCrystalBall.html,https://root.cern,https://root.cern/doc/master/classRooCrystalBall.html,1,['power'],['power']
Energy Efficiency," of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceProperty(Double_t qqa, Double_t qqd, Double_t qqs, Int_t nnqs, Int_t& irep); Set surface property coefficients. Input: QQA - diffusion coefficient for diffused light [0.,1.]; QQD - diffusion coefficient for direct light [0.,1.]; QQS - diffusion coefficient for reflected light [0.,1.]; NNCS - power coefficient for reflected light (.GE.1). --; Lightness model formula: Y = YD*QA + > YLi*(QD*cosNi+QS*cosRi); --. Output: IREP - reply : 0 - O.K.; -1 - error in cooefficients. void ImplicitFunction(Double_t* rmin, Double_t* rmax, Int_t nx, Int_t ny, Int_t nz, const char* chopt); Draw implicit function FUN(X,Y,Z) = 0 in cartesian coordinates using; hidden surface removal algorithm ""Painter"". Input: FUN - external routine FUN(X,Y,Z); RMIN(3) - min scope coordinates; RMAX(3) - max scope coordinates; NX - number of steps along X; NY - number of steps along Y; NZ - number of steps along Z. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - 1; ICODES(2) - 1; ICODES(3) - 1; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function (lightness). CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void MarchingCube(Double_t fiso, Double_t** p, Double_t* f, Double_t** g, Int_t& nnod, Int_t& ntria, Double_t** xyz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPainter3dAlgorithms.html:32669,power,power,32669,root/html528/TPainter3dAlgorithms.html,https://root.cern,https://root.cern/root/html528/TPainter3dAlgorithms.html,6,['power'],['power']
Energy Efficiency," of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceProperty(Double_t qqa, Double_t qqd, Double_t qqs, Int_t nnqs, Int_t& irep); Set surface property coefficients. Input: QQA - diffusion coefficient for diffused light [0.,1.]; QQD - diffusion coefficient for direct light [0.,1.]; QQS - diffusion coefficient for reflected light [0.,1.]; NNCS - power coefficient for reflected light (.GE.1). --; Lightness model formula: Y = YD*QA + > YLi*(QD*cosNi+QS*cosRi); --. Output: IREP - reply : 0 - O.K.; -1 - error in cooefficients. void ImplicitFunction(Double_t* rmin, Double_t* rmax, Int_t nx, Int_t ny, Int_t nz, const char* chopt); Draw implicit function FUN(X,Y,Z) = 0 in cartesian coordinates using; hidden surface removal algorithm ""Painter"". Input: FUN - external routine FUN(X,Y,Z); RMIN(3) - min scope coordinates; RMAX(3) - max scope coordinates; NX - number of steps along X; NY - number of steps along Y; NZ - number of steps along Z. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - 1; ICODES(2) - 1; ICODES(3) - 1; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function (lightness). CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void MarchingCube(Double_t fiso, Double_t[8][3] p, Double_t[8] f, Double_t[8][3] g, Int_t& nnod, Int_t& ntria, Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPainter3dAlgorithms.html:33875,power,power,33875,root/html602/TPainter3dAlgorithms.html,https://root.cern,https://root.cern/root/html602/TPainter3dAlgorithms.html,4,['power'],['power']
Energy Efficiency," often is the test data tested; 769 double factorWeightDecay () const { return m_factorWeightDecay; } ///< get the weight-decay factor; 770 ; 771 double learningRate () const { return fLearningRate; } ///< get the learning rate; 772 double momentum () const { return fMomentum; } ///< get the momentum (e.g. for SGD); 773 int repetitions () const { return fRepetitions; } ///< how many steps have to be gone until the batch is changed; 774 MinimizerType minimizerType () const { return fMinimizerType; } ///< which minimizer shall be used (e.g. SGD); 775 ; 776 ; 777 ; 778 ; 779 ; 780 ; 781 virtual void testSample (double /*error*/, double /*output*/, double /*target*/, double /*weight*/) {} ///< virtual function to be used for monitoring (callback); 782 virtual void startTrainCycle () ///< callback for monitoring and logging; 783 {; 784 m_convergenceCount = 0;; 785 m_maxConvergenceCount= 0;; 786 m_minError = 1e10;; 787 }; 788 virtual void endTrainCycle (double /*error*/) {} ///< callback for monitoring and logging; 789 ; 790 virtual void setProgressLimits (double minProgress = 0, double maxProgress = 100) ///< for monitoring and logging (set the current ""progress"" limits for the display of the progress) \param minProgress minimum value \param maxProgress maximum value; 791 {; 792 m_minProgress = minProgress;; 793 m_maxProgress = maxProgress;; 794 }; 795 virtual void startTraining () ///< start drawing the progress bar; 796 {; 797 m_timer.DrawProgressBar (Int_t(m_minProgress));; 798 }; 799 virtual void cycle (double progress, TString text) ///< advance on the progress bar \param progress the new value \param text a label; 800 {; 801 m_timer.DrawProgressBar (Int_t(m_minProgress+(m_maxProgress-m_minProgress)*(progress/100.0)), text);; 802 }; 803 ; 804 virtual void startTestCycle () {} ///< callback for monitoring and loggging; 805 virtual void endTestCycle () {} ///< callback for monitoring and loggging; 806 virtual void testIteration () {} ///< callback for monitoring and l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:28423,monitor,monitoring,28423,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,4,['monitor'],['monitoring']
Energy Efficiency," old size, use ReAlloc(void *, size_t, size_t) instead. void * ReAlloc(void* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) block of memory. Checks if current size is; equal to oldsize. If not memory was overwritten. char * ReAllocChar(char* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of chars. Size and oldsize are; in number of chars. Int_t * ReAllocInt(Int_t* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of integers. Size and oldsize are; number of integers (not number of bytes). void * ObjectAlloc(size_t size); Used to allocate a TObject on the heap (via TObject::operator new()).; Directly after this routine one can call (in the TObject ctor); TStorage::FilledByObjectAlloc() to find out if the just created object is on; the heap. This technique is necessary as there is one stack per thread; and we can not rely on comparison with the current stack memory position. void * ObjectAlloc(size_t size, void* vp); Used to allocate a TObject on the heap (via TObject::operator new(size_t,void*)); in position vp. vp is already allocated (maybe on heap, maybe on; stack) so just return. void ObjectDealloc(void* vp); Used to deallocate a TObject on the heap (via TObject::operator delete()). void ObjectDealloc(void* vp, void* ptr); Used to deallocate a TObject on the heap (via TObject::operator delete(void*,void*)). void SetFreeHook(FreeHookFun_t func, void* data); Set a free handler. void SetReAllocHooks(ReAllocFun_t func1, ReAllocCFun_t func2); Set a custom ReAlloc handlers. This function is typically; called via a static object in the ROOT libNew.so shared library. void PrintStatistics(); Print memory usage statistics. void EnableStatistics(int size = -1, int ix = -1); Enable memory usage statistics gathering. Size is the size of the memory; block that should be trapped and ix is after how many such allocations; the trap should happen. ULong_t GetHeapBegin(). ULong_t GetHeapEnd(). void * GetFreeHookData(); return static free ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TStorage.html:4833,allocate,allocate,4833,root/html604/TStorage.html,https://root.cern,https://root.cern/root/html604/TStorage.html,2,['allocate'],['allocate']
Energy Efficiency," omit the second argument for subsequent calls; T.ReadFile(""file1.dat"",""branch descriptor"");; T.ReadFile(""file2.dat"");. Long64_t ReadStream(istream& inputStream, const char* branchDescriptor = """"); Create or simply read branches from an input stream. See reference information for TTree::ReadFile. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Refresh(); Refresh contents of this tree and its branches from the current status on disk. One can call this function in case the tree file is being; updated by another process. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Reset baskets, buffers and entries count in all branches and leaves. void ResetBranchAddress(TBranch* ); Tell all of our branches to set their addresses to zero. Note: If any of our branches own any objects, they are deleted. void ResetBranchAddresses(); Tell all of our branches to drop their current objects and allocate new ones. Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over tree entries and print entries passing selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. Bool_t SetAlias(const char* aliasName, const char* aliasFormula); Set a tree variable alias. Set an alias for an expression/formula based on the tree 'variables'. The content of 'aliasName' can be used in TTreeFormula (i.e. TTree::Draw,; TTree::Scan, TTreeViewer) and will be evaluated as the content of; 'aliasFormula'.; If the content of 'aliasFormula' only contains symbol names, periods and; array index specification (for example event.fTracks[3]), then; the content of 'aliasName' can be used as the start of symbol. If the alia",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:113231,allocate,allocate,113231,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['allocate'],['allocate']
Energy Efficiency," on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binni",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsData.html:16768,reduce,reduce,16768,root/html528/RooAbsData.html,https://root.cern,https://root.cern/root/html528/RooAbsData.html,9,['reduce'],['reduce']
Energy Efficiency," only by branches named ""a"" and ""b"", do; 5539/// ~~~ {.cpp}; 5540/// mytree.SetBranchStatus(""*"",0); //disable all branches; 5541/// mytree.SetBranchStatus(""a"",1);; 5542/// mytree.SetBranchStatus(""b"",1);; 5543/// ~~~; 5544/// when calling mytree.GetEntry(i); only branches ""a"" and ""b"" will be read.; 5545///; 5546/// __WARNING!!__; 5547/// If your Tree has been created in split mode with a parent branch ""parent."",; 5548/// ~~~ {.cpp}; 5549/// mytree.SetBranchStatus(""parent"",1);; 5550/// ~~~; 5551/// will not activate the sub-branches of ""parent"". You should do:; 5552/// ~~~ {.cpp}; 5553/// mytree.SetBranchStatus(""parent*"",1);; 5554/// ~~~; 5555/// Without the trailing dot in the branch creation you have no choice but to; 5556/// call SetBranchStatus explicitly for each of the sub branches.; 5557///; 5558/// An alternative is to call directly; 5559/// ~~~ {.cpp}; 5560/// brancha.GetEntry(i); 5561/// branchb.GetEntry(i);; 5562/// ~~~; 5563/// ## IMPORTANT NOTE; 5564///; 5565/// By default, GetEntry reuses the space allocated by the previous object; 5566/// for each branch. You can force the previous object to be automatically; 5567/// deleted if you call mybranch.SetAutoDelete(true) (default is false).; 5568///; 5569/// Example:; 5570///; 5571/// Consider the example in $ROOTSYS/test/Event.h; 5572/// The top level branch in the tree T is declared with:; 5573/// ~~~ {.cpp}; 5574/// Event *event = 0; //event must be null or point to a valid object; 5575/// //it must be initialized; 5576/// T.SetBranchAddress(""event"",&event);; 5577/// ~~~; 5578/// When reading the Tree, one can choose one of these 3 options:; 5579///; 5580/// ## OPTION 1; 5581///; 5582/// ~~~ {.cpp}; 5583/// for (Long64_t i=0;i<nentries;i++) {; 5584/// T.GetEntry(i);; 5585/// // the object event has been filled at this point; 5586/// }; 5587/// ~~~; 5588/// The default (recommended). At the first entry an object of the class; 5589/// Event will be created and pointed by event. At the following entries,; 5590",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:220121,allocate,allocated,220121,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h offsetDefinition TGWin32VirtualXProxy.cxx:245; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; TInterpreter.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TSelector.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTree.h; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; THashList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition THashList.cxx:207; TInterpreter::ClassInfo_Newvirtual void * ClassInfo_New(Class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8cxx_source.html:16738,allocate,allocated,16738,doc/master/TSelector_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," operation `f` (e.g. 0 for a sum, 1 for a product). If a default-constructed T does not satisfy this; 1676 /// requirement, users should explicitly specify an initialization value for T by calling the appropriate `Reduce`; 1677 /// overload.; 1678 ///; 1679 /// ### Example usage:; 1680 /// ~~~{.cpp}; 1681 /// auto sumOfIntCol = d.Reduce([](int x, int y) { return x + y; }, ""intCol"");; 1682 /// ~~~; 1683 ///; 1684 /// This action is *lazy*: upon invocation of this method the calculation is; 1685 /// booked but not executed. Also see RResultPtr.; 1686 // clang-format on; 1687 template <typename F, typename T = typename TTraits::CallableTraits<F>::ret_type>; 1688 RResultPtr<T> Reduce(F f, std::string_view columnName = """"); 1689 {; 1690 static_assert(; 1691 std::is_default_constructible<T>::value,; 1692 ""reduce object cannot be default-constructed. Please provide an initialisation value (redIdentity)"");; 1693 return Reduce(std::move(f), columnName, T());; 1694 }; 1695 ; 1696 ////////////////////////////////////////////////////////////////////////////; 1697 /// \brief Execute a user-defined reduce operation on the values of a column.; 1698 /// \tparam F The type of the reduce callable. Automatically deduced.; 1699 /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; 1700 /// \param[in] f A callable with signature `T(T,T)`; 1701 /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; 1702 /// \param[in] redIdentity The reduced object of each thread is initialized to this value.; 1703 /// \return the reduced quantity wrapped in a RResultPtr.; 1704 ///; 1705 /// ### Example usage:; 1706 /// ~~~{.cpp}; 1707 /// auto sumOfIntColWithOffset = d.Reduce([](int x, int y) { return x + y; }, ""intCol"", 42);; 1708 /// ~~~; 1709 /// See the description of the first Reduce overload for more information.; 1710 template <typename F, typename T = typename TTraits::CallableTraits<F>::ret_type>; 1711 RResult",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:95038,reduce,reduce,95038,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['reduce'],['reduce']
Energy Efficiency," option. void Draw(Option_t* option = """"); Draws either the KDE functions or its errors; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.95); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Returns the indices (bins) for the binned weights. Double_t UpperConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise upper estimated density. Double_t LowerConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise lower estimated density. Double_t GetBias(Double_t x) const; Returns the pointwise approximate estimated density bias. Double_t GetError(Double_t x) const; Returns the pointwise sigma of estimated density. void CheckKernelValidity(); Checks if kernel has unit integral, mu = 0 and positive finite sigma conditions. Double_t ComputeKernelL2Norm() const; Computes the kernel's L2 norm. Double_t ComputeKernelSigma2() const; Computes the kernel's sigma squared. Double_t ComputeKernelMu() const; Computes the kernel's mu. Double_t ComputeKernelIntegral() const; Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKDE.html:16160,adapt,adaptive,16160,root/html528/TKDE.html,https://root.cern,https://root.cern/root/html528/TKDE.html,6,['adapt'],['adaptive']
Energy Efficiency," or via TColor::GetPixel()) to r,g,b triplet.; The r,g,b triplet will be [0,1].; ; . void Pixel2RGB(ULong_t pixel, Int_t& r, Int_t& g, Int_t& b). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; The r,g,b triplet will be [0,255].; ; . const char * PixelAsHexString(ULong_t pixel). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to a hexadecimal string.; This string can be directly passed to, for example,; TGClient::GetColorByName(). String will be reused so copy immediately; if needed.; ; . void SaveColor(ostream& out, Int_t ci). Save a color with index > 228 as a C++ statement(s) on output stream out.; ; . Bool_t IsGrayscale(). Return whether all colors return grayscale values.; ; . void SetGrayscale(Bool_t set = kTRUE). Set whether all colors should return grayscale values.; ; . Int_t CreateGradientColorTable(UInt_t Number, Double_t* Stops, Double_t* Red, Double_t* Green, Double_t* Blue, UInt_t NColors). Static function creating a color table with several connected linear gradients.; ; Number: The number of end point colors that will form the gradients.; Must be at least 2.; Stops: Where in the whole table the end point colors should lie.; Each entry must be on [0, 1], each entry must be greater than; the previous entry.; Red, Green, Blue: The end point color values.; Each entry must be on [0, 1]; NColors: Total number of colors in the table. Must be at least 1.; ; Returns a positive value on success and -1 on error.; ; The table is constructed by tracing lines between the given points in; RGB space. Each color value may have a value between 0 and 1. The; difference between consecutive ""Stops"" values gives the fraction of; space in the whole table that should be used for the interval between; the corresponding color values.; ; Normally the first element of Stops should be 0 and the last should be 1.; If this is not true, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TColor.html:22877,Green,Green,22877,root/html532/TColor.html,https://root.cern,https://root.cern/root/html532/TColor.html,1,['Green'],['Green']
Energy Efficiency," out[3]);  Calculates the Normalized Cross Product of two vectors. ;  ; Double_t NormQuantile (Double_t p);  Computes quantiles for standard normal distribution N(0, 1) at probability p. ;  ; Bool_t Odd (Long_t a);  Returns true if a is odd. ;  ; Bool_t Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t Pi ();  \( \pi\) ;  ; constexpr Double_t PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ;  ; constexpr Double_t Qe ();  Elementary charge in \( C \) . ;  ; constexpr Double_t QeUncertainty ();  Elementary charge uncertainty. ;  ; void Quantiles (Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7);  Computes sample quantiles, corresponding to the given probabilities. ;  ; Double_t QuietNaN ();  Returns a quiet NaN as defined by IEEE 754. ;  ; constexpr Double_t R ();  Universal gas constant ( \( Na K \)) in \( J K^{-1} mol^{-1} \) ;  ; constexpr Double_t RadToDeg ();  Conversion from radian to degree: \( \frac{180}{\pi} \). ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:17230,power,power,17230,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['power'],['power']
Energy Efficiency," override;; 76 ; 77 static THnSparse* CreateSparse(const char* name, const char* title,; 78 const TH1* h1, Int_t chunkSize = 1024 * 16) {; 79 return (THnSparse*) CreateHnAny(name, title, h1, kTRUE /*sparse*/,; 80 chunkSize);; 81 }; 82 static THnSparse* CreateSparse(const char* name, const char* title,; 83 const THnBase* hn, Int_t chunkSize = 1024 * 16) {; 84 return (THnSparse*) CreateHnAny(name, title, hn, kTRUE /*sparse*/,; 85 chunkSize);; 86 }; 87 ; 88 Int_t GetChunkSize() const { return fChunkSize; }; 89 Int_t GetNChunks() const { return fBinContent.GetEntriesFast(); }; 90 ; 91 ROOT::Internal::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const override;; 92 ; 93 Long64_t GetNbins() const override { return fFilledBins; }; 94 void SetFilledBins(Long64_t nbins) override { fFilledBins = nbins; }; 95 ; 96 Long64_t GetBin(const Int_t* idx) const override { return const_cast<THnSparse*>(this)->GetBin(idx, kFALSE); }; 97 Long64_t GetBin(const Double_t* x) const override { return const_cast<THnSparse*>(this)->GetBin(x, kFALSE); }; 98 Long64_t GetBin(const char* name[]) const override { return const_cast<THnSparse*>(this)->GetBin(name, kFALSE); }; 99 Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE) override;; 100 Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE) override;; 101 Long64_t GetBin(const char* name[], Bool_t allocate = kTRUE) override;; 102 ; 103 /// Forwards to THnBase::SetBinContent().; 104 /// Non-virtual, CINT-compatible replacement of a using declaration.; 105 void SetBinContent(const Int_t* idx, Double_t v) {; 106 THnBase::SetBinContent(idx, v);; 107 }; 108 void SetBinContent(Long64_t bin, Double_t v) override;; 109 void SetBinError2(Long64_t bin, Double_t e2) override;; 110 ; 111 /// Forwards to THnBase::AddBinContent().; 112 /// Non-virtual, CINT-compatible replacement of a using declaration.; 113 void AddBinContent(const Int_t* idx, Double_t v = 1.) {; 114 THnBase::AddBinContent(idx, v);; 115 }; 116 void AddBinContent(Long64_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8h_source.html:3984,allocate,allocate,3984,doc/master/THnSparse_8h_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html,3,['allocate'],['allocate']
Energy Efficiency," place. ;  ; template<typename T > ; T NormCross (const T v1[3], const T v2[3], T out[3]);  Calculates the Normalized Cross Product of two vectors. ;  ; Double_t NormQuantile (Double_t p);  Computes quantiles for standard normal distribution N(0, 1) at probability p. ;  ; Bool_t Odd (Long_t a);  Returns true if a is odd. ;  ; Bool_t Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t Pi ();  \( \pi\) ;  ; constexpr Double_t PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ;  ; constexpr Double_t Qe ();  Elementary charge in \( C \) . ;  ; constexpr Double_t QeUncertainty ();  Elementary charge uncertainty. ;  ; void Quantiles (Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7);  Computes sample quantiles, corresponding to the given probabilities. ;  ; Double_t QuietNaN ();  Returns a quiet NaN as defined by IEEE 754. ;  ; constexpr Double_t R ();  Universal gas constant ( \( Na K \)) in \( J K^{-1} mol^{-1} \) ;  ; constexpr Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:17146,power,power,17146,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['power'],['power']
Energy Efficiency," point, also across different computation graphs.; 964 ; 965Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See [Activating RDataFrame execution logs](\ref rdf-logging).; 966 ; 967### Memory usage; 968 ; 969There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage.; 970 ; 971Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, to allocate some memory for the generated code that is only released at the end of the application. This commonly results in memory usage creep in long-running applications that create many RDataFrames one after the other. Possible mitigations include creating and running each RDataFrame event loop in a sub-process, or booking all operations for all different RDataFrame computation graphs before the first event loop is triggered, so that the interpreter is invoked only once for all computation graphs:; 972 ; 973~~~{.cpp}; 974// assuming df1 and df2 are separate computation graphs, do:; 975auto h1 = df1.Histo1D(""x"");; 976auto h2 = df2.Histo1D(""y"");; 977h1->Draw(); // we just-in-time compile everything needed by df1 and df2 here; 978h2->Draw(""SAME"");; 979 ; 980// do not:; 981auto h1 = df1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:56745,reduce,reduce,56745,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['reduce'],['reduce']
Energy Efficiency," pointed by source pointer. On successful completion it returns 0. On error it; returns pointer to the string describing error. If desired after every; numberIterations one can apply boosting operation (exponential function with; exponent given by boost coefficient) and repeat it numberRepetitions times.;  ; Parameters:; ������� source-pointer; to the matrix of source spectrum����������������� ; ������� resp-pointer; to the matrix of response spectrum����������������� ; ������� ssizex, ssizey-lengths; of the spectrum matrix�������������������������������� ; ������� numberIterations-number of iterations ; ������� numberRepetitions-number of repetitions; for boosted deconvolution. It must be ; ������� greater or equal to one.; ������� boost-boosting coefficient, applies only; if numberRepetitions is greater than one.� ; ������� Recommended range <1,2>.;  ; References:; �[1]; M. Morh�č, J. Kliman, V.; Matou�ek, M. Veselsk�, I. Turzo.:; Efficient one- and two-dimensional Gold deconvolution and its application to; gamma-ray spectra decomposition. NIM, A401 (1997) 385-408.; [2]; Morh�č M., Matou�ek V., Kliman J., Efficient algorithm of multidimensional; deconvolution and its application to nuclear data processing, Digital Signal; Processing 13 (2003) 144. ;  . . Example 5 � script Decon.c; :; �        ; response function (usually peak); should be shifted to the beginning of the coordinate system (see Fig. 13);  . Fig.; 13 2-dimensional response spectrum. Fig.; 14 2-dimensional gamma-gamma-ray input spectrum (before deconvolution). Fig.; 15 Spectrum from Fig. 14 after deconvolution (1000 iterations);  ; Script:; // Example to illustrate the Gold deconvolution (class; TSpectrum2).; // To execute this example, do; // root > .x Decon.C;  ; #include <TSpectrum2> ;  ; void Decon() {; �� Int_t i, j;; �� Double_t nbinsx = 256;; �� Double_t nbinsy = 256;�� ; �� Double_t xmin� = 0;; �� Double_t xmax� = (Double_t)nbinsx;; �� Double_t ymin� = 0;; �� Double_t ymax� = (Double_t)nbinsy;�",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSpectrum2.html:27986,Efficient,Efficient,27986,root/html532/TSpectrum2.html,https://root.cern,https://root.cern/root/html532/TSpectrum2.html,4,['Efficient'],['Efficient']
Energy Efficiency," pointer to a newly allocated object of this class. ;  ; void * NewArray (Long_t nElements, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated array of objects of this class. ;  ; void * NewArray (Long_t nElements, void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; ObjectPtr NewObject (ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) const;  ; ObjectPtr NewObject (void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; ObjectPtr NewObjectArray (Long_t nElements, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated array of objects of this class. ;  ; ObjectPtr NewObjectArray (Long_t nElements, void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; virtual void PostLoadCheck ();  Do the initialization that can only be done after the CINT dictionary has been fully populated and can not be delayed efficiently. ;  ; Long_t Property () const override;  Returns the properties of the TClass as a bit field stored as a Long_t value. ;  ; Int_t ReadBuffer (TBuffer &b, void *pointer);  Function called by the Streamer functions to deserialize information from buffer b into object at p. ;  ; Int_t ReadBuffer (TBuffer &b, void *pointer, Int_t version, UInt_t start, UInt_t count);  Function called by the Streamer functions to deserialize information from buffer b into object at p. ;  ; void RegisterStreamerInfo (TVirtualStreamerInfo *info);  Register the StreamerInfo in the given slot, change the State of the TClass as appropriate. ;  ; void RemoveStreamerInfo (Int_t slot);  Remove and delete the StreamerInfo in the given slot. ;  ; void ReplaceWith (TClass *newcl) const;  ; void ResetCaches ();  To clean out all caches. ;  ; void ResetClassInfo ();  Make sure that the current ClassInfo is up to date. ;  ; void ResetCla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:21211,efficient,efficiently,21211,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,3,['efficient'],['efficiently']
Energy Efficiency," points, return back */; 53 ; 54 ; 55 ; 56 /*; 57 * Allocate memory for colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].gree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/X3DBuffer_8c_source.html:2400,green,green,2400,doc/master/X3DBuffer_8c_source.html,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html,1,['green'],['green']
Energy Efficiency," points; 159 */; 160 ; 161 for (i = 0; i < buff->numPoints; i++, currPoint++) {; 162 points[currPoint].x = buff->points[3*i ];; 163 points[currPoint].y = buff->points[3*i+1];; 164 points[currPoint].z = buff->points[3*i+2];; 165 }; 166 ; 167 ; 168 /*; 169 * Read segments; 170 */; 171 ; 172 for (i = 0; i < buff->numSegs; i++, currSeg++) {; 173 c = buff->segs[3*i];; 174 p = oldNumOfPoints + buff->segs[3*i+1];; 175 q = oldNumOfPoints + buff->segs[3*i+2];; 176 ; 177 segs[currSeg].color = &(colors[c]);; 178 segs[currSeg].P = &(points[p]);; 179 segs[currSeg].Q = &(points[q]);; 180 ; 181 /*; 182 * Update points' segment lists; 183 */; 184 ; 185 if(points[p].numSegs == 0){; 186 if((points[p].segs = (segment **)calloc(1, sizeof(segment *))) == NULL){; 187 puts(""Unable to allocate memory for point segments !"");; 188 return;; 189 }; 190 }else{; 191 if((points[p].segs = (segment **)realloc(points[p].segs,; 192 (points[p].numSegs + 1) * sizeof(segment *))) == NULL){; 193 puts(""Unable to allocate memory for point segments !"");; 194 return;; 195 }; 196 }; 197 ; 198 if(points[q].numSegs == 0){; 199 if((points[q].segs = (segment **)calloc(1, sizeof(segment *))) == NULL){; 200 puts(""Unable to allocate memory for point segments !"");; 201 return;; 202 }; 203 }else{; 204 if((points[q].segs = (segment **)realloc(points[q].segs,; 205 (points[q].numSegs + 1) * sizeof(segment *))) == NULL){; 206 puts(""Unable to allocate memory for point segments !"");; 207 return;; 208 }; 209 }; 210 points[p].segs[points[p].numSegs] = &(segs[currSeg]);; 211 points[q].segs[points[q].numSegs] = &(segs[currSeg]);; 212 points[p].numSegs++;; 213 points[q].numSegs++;; 214 ; 215 }; 216 ; 217 /*; 218 * Read polygons; 219 */; 220 ; 221 n = 0;; 222 ; 223 for (i = 0; i < buff->numPolys; i++, currPoly++) {; 224 c = buff->polys[n++];; 225 polys[currPoly].color = &(colors)[c];; 226 polys[currPoly].numSegs = buff->polys[n++];; 227 ; 228 polys[currPoly].segs = (segment **) calloc(polys[currPoly].numSegs, sizeof(segment *));; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/X3DBuffer_8c_source.html:6001,allocate,allocate,6001,doc/master/X3DBuffer_8c_source.html,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html,1,['allocate'],['allocate']
Energy Efficiency," procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it back to an empty screen. Bool_t HandleTimer(TTimer* timer); Handle timer even",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGHtml.html:33883,Schedul,ScheduleRedraw,33883,root/html532/TGHtml.html,https://root.cern,https://root.cern/root/html532/TGHtml.html,4,['Schedul'],['ScheduleRedraw']
Energy Efficiency," product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html:19246,energy,energy,19246,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,1,['energy'],['energy']
Energy Efficiency," product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html:17640,energy,energy,17640,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,1,['energy'],['energy']
Energy Efficiency," protected by a read-write lock. ; We don't expose that to the users of RNTupleReader::GetDescriptor(). Instead, if descriptor information is needed, we clone the descriptor. Using the descriptor's generation number, we know if the cached descriptor is stale. Retrieving descriptor data from an RNTupleReader is supposed to be for testing and information purposes, not on a hot code path. ; Definition at line 89 of file RNTupleReader.hxx. ◆ fDisplayReader. std::unique_ptr<RNTupleReader> ROOT::Experimental::RNTupleReader::fDisplayReader. private . We use a dedicated on-demand reader for Show() and Scan(). ; Printing data uses all the fields from the full model even if the analysis code uses only a subset of fields. The display reader is a clone of the original reader. ; Definition at line 83 of file RNTupleReader.hxx. ◆ fMetrics. Detail::RNTupleMetrics ROOT::Experimental::RNTupleReader::fMetrics. private . Definition at line 90 of file RNTupleReader.hxx. ◆ fModel. std::unique_ptr<RNTupleModel> ROOT::Experimental::RNTupleReader::fModel. private . Needs to be destructed before fSource. ; Definition at line 79 of file RNTupleReader.hxx. ◆ fSource. std::unique_ptr<Internal::RPageSource> ROOT::Experimental::RNTupleReader::fSource. private . Definition at line 77 of file RNTupleReader.hxx. ◆ fUnzipTasks. std::unique_ptr<Internal::RPageStorage::RTaskScheduler> ROOT::Experimental::RNTupleReader::fUnzipTasks. private . Set as the page source's scheduler for parallel page decompression if IMT is on Needs to be destructed after the pages source is destructed (an thus be declared before) ; Definition at line 75 of file RNTupleReader.hxx. Libraries for ROOT::Experimental::RNTupleReader:. [legend]; The documentation for this class was generated from the following files:; tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx; tree/ntuple/v7/src/RNTupleReader.cxx. ROOTExperimentalRNTupleReader. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html:19355,schedul,scheduler,19355,doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,1,['schedul'],['scheduler']
Energy Efficiency," proved to work as the best, other methods (Fourier, VanCittert etc) oscillate. \[ y = Hx \] \[ H^T=H^THx \] \[ y^{'} = H^{'}x \] \[x_{i}^{(k+1)}=\frac{y_{i}^{'}}{\sum_{m=0}^{N-1}H_{im}^{'}x_{m}^{(k)}}x_{i}^{(k)}, i=0,1,...,N-1, \] where: \[ k=1,2,3,...,I \] \[ x^{(0)} = [1,1,...,1]^T \]; The basic function has the form; char *Deconvolution1(float *source,; const float *resp,; int size,; int number-of-iterations);; This function calculates deconvolution from source spectrum according to response spectrum.; Function parameters:. source pointer to the vector of source spectrum; resp pointer to the vector of response spectrum; size length of source and response spectra; number_of_iterations for details see [8]. As an illustration of the method let us introduce small example. In Figure 4.1 we present original 1-dimensional spectrum. It contains multiplets that cannot be directly analyzed. The response function (one peak) is given in Figure 4.2. We assume the same response function (not changing the shape) along the entire energy scale. So the response matrix is composed of mutually shifted response functions by one channel, however of the same shape. Original 1-dimensional spectrum. Response function (one peak). The result after deconvolution is given in Figure 4.3. It substantially improves the resolution in the spectrum. Result after deconvolution. We have developed a new high resolution deconvolution algorithm. We have observed that the Gold deconvolution converges to its stable state (solution). It is useless to increase the number of iterations, the result obtained does not change. To continue in decreasing the width of peaks we have found that when the solution reaches its stable state it is necessary to stop iterations, then to change the vector in a way and repeat again the Gold deconvolution . We have found that to change the particular solution we need to apply non-linear boosting function to it. The power function proved to give the best results. At the beginn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:24978,energy,energy,24978,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,2,['energy'],['energy']
Energy Efficiency," py4j. Tests for the Spark backend can be turned ON/OFF with the new build option test_distrdf_pyspark (OFF by default).; Histogram Libraries. Add a new THistRange class for defining a generic bin range and iteration in a 1d and multi-dimensional histogram; Fix a memory leak in TF1::Copy and TFormula::Copy; Enable using automatic differentiation when computing parameter gradient in formula based TF1; Add several fixes and improvements to the TKDE class using kernel estimation for estimating a density from data.; Improve TF1::GetRandom, TH1::GetRandom and TH1::FillRandom (and same for TF2,TF3, TH2 and TH3 functions) to pass optionally a random number generator instance. This allows to use these function with a user provided random number generator instead of using the default gRandom. Math Libraries. Update the definitions of the physical constants using the recommended 2018 values from NIST.; Use also the new SI definition of base units from 2019, where the Planck constant, the Boltzmann constant, the elementary electric charge and the Avogadro constant are exact numerical values. See https://en.wikipedia.org/wiki/2019_redefinition_of_the_SI_base_units. Note that with this new definition the functions TMath::HUncertainty(), TMath::KUncertainty(), TMath::QeUncertainty() and TMath::NaUncertainty() all return a 0.0 value.; Due to some planned major improvements to RVec, the layout of RVec objects will change in a backward-incompatible way between v6.24 and v6.26. Because of this, we now print a warning if an application is reading or writing a ROOT::RVec object from/to a ROOT file. We assume this is an exceedingly rare case, as the ROOT interface typically used to manipulate RVecs is RDataFrame, and RDataFrame performs an on-the-fly RVec <-> std::vector conversion rather than writing RVecs to disk. Note that, currently, RVecs written e.g. in a TTree cannot be read back using certain ROOT interfaces (e.g. TTreeReaderArray, RDataFrame and the experimental RNTuple). All th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:13232,charge,charge,13232,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['charge'],['charge']
Energy Efficiency," quality stored in the RooFitResult object will be the minimum of the original covariance matrix quality and the quality of the covariance matrix calculated with the squared weights. . AsymptoticError() Use the asymptotically correct approach to estimate errors in the presence of weights. This is slower but more accurate than SumW2Error. See also https://arxiv.org/abs/1911.01303). This option even correctly implements the case of extended likelihood fits (see this writeup on extended weighted fits that complements the paper linked before). . PrefitDataFraction(double fraction) Runs a prefit on a small dataset of size fraction*(actual data size). This can speed up fits by finding good starting values for the parameters for the actual fit. WarningPrefitting may give bad results when used in binned analysis. Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit). . Timer(bool flag) Time CPU and wall clock consumption of fit steps, off by default. . PrintLevel(Int_t level) Set Minuit print level (-1 to 3, default is 1). At -1 all RooFit informational messages are suppressed as well. See RooMinimizer::PrintLevel for the meaning of the levels. . Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppresses output completely, a zero value will only print the error count per p.d.f component, a positive value will print details of each error up to numErr messages per p.d.f component. . Parallelize(Int_t nWorkers) Control global parallelization settings. Arguments 1 and above enable the use of RooFit's parallel minimization backend and uses the number given as the number of workers to use in the parallelization. -1 also enables RooFit's parallel minimization backend, and sets the number of workers to the number of available processes. 0 disables ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:109289,consumption,consumption,109289,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['consumption'],['consumption']
Energy Efficiency," range of the fraction coefficients is kept at the nominal convolutions observable range (instead of interpreting coefficients; in the widened range including the buffer). void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the; product operator construction. void calcParams(); (Re)calculate effective parameters of this p.d.f. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); calcParams() ;. RooFFTConvPdf(); {}. TObject* clone(const char* newname) const; { return new RooFFTConvPdf(*this,newname); }. void setShift(Double_t val1, Double_t val2); { _shift1 = val1 ; _shift2 = val2 ; }. void setCacheObservables(const RooArgSet& obs); { _cacheObs.removeAll() ; _cacheObs.add(obs) ; }. const RooArgSet& cacheObservables() const; { return _cacheObs ; }. Double_t bufferFraction() const; Return value of buffer fraction applied in FFT calculation array beyond either; end of the observable domain to reduce cyclical effects. BufStrat bufferStrategy() const; Return the strategy currently used to fill the buffer:; 'Extend' means is that the input p.d.f convolution observable range is widened to include the buffer range; 'Flat' means that the buffer is filled with the p.d.f. value at the boundary of the observable range; 'Mirror' means that the buffer is filled with a mirror image of the p.d.f. around the convolution observable boundary. Int_t getMaxVal(const RooArgSet& vars) const; Propagate maximum value estimate of pdf1 as convolution can only result in lower max values. { return _pdf1.arg().getMaxVal(vars) ; }. Double_t maxVal(Int_t code) const; { return _pdf1.arg().maxVal(code) ; }. Double_t evaluate() const; { RooArgSet dummy(_x.arg()) ; return getVal(&dummy) ; }. PdfCacheElem* createCache(const RooArgSet* nset) const. » Last changed: Mon Dec 7 13:47:37 2009 » Last generated: 2009-12-07 13:47; This page has been automa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:51806,reduce,reduce,51806,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,1,['reduce'],['reduce']
Energy Efficiency," read branches from the file named whose name is passed in 'filename'.; {; gROOT->Reset();; TFile *f = new TFile(""basic2.root"",""RECREATE"");; TH1F *h1 = new TH1F(""h1"",""x distribution"",100,-4,4);; TTree *T = new TTree(""ntuple"",""data from ascii file"");; Long64_t nlines = T->ReadFile(""basic.dat"",""x:y:z"");; printf("" found %lld pointsn"",nlines);; T->Draw(""x"",""z>2"");; T->Write();; }; If branchDescriptor is set to an empty string (the default), it is assumed that the Tree descriptor is given in the first line of the file with a syntax like: A/D:Table[2]/F:Ntracks/I:astring/C.; Otherwise branchDescriptor must be specified with the above syntax.Lines in the input file starting with “#” are ignored. A TBranch object is created for each variable in the expression. The total number of rows read from the file is returned.; 12.19 Trees in Analysis; The methods TTree::Draw, TTree::MakeClass and TTree::MakeSelector are available for data analysis using trees. The TTree::Draw method is a powerful yet simple way to look and draw the trees contents. It enables you to plot a variable (a leaf) with just one line of code. However, the Draw method falls short once you want to look at each entry and design more sophisticated acceptance criteria for your analysis. For these cases, you can use TTree::MakeClass. It creates a class that loops over the trees entries one by one. You can then expand it to do the logic of your analysis.; The TTree::MakeSelector is the recommended method for ROOT data analysis. It is especially important for large data set in a parallel processing configuration where the analysis is distributed over several processors and you can specify which entries to send to each processor. With MakeClass the user has control over the event loop, with MakeSelectorthe tree is in control of the event loop.; 12.20 Simple Analysis Using TTree::Draw; We will use the tree in cernstaff.root that was made by the macro in $ROOTSYS/tutorials/tree/staff.C.; First, open the file and lists it",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:584027,power,powerful,584027,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['power'],['powerful']
Energy Efficiency," regions have the same offset, size, and shape. void GetRegionBox(Region_t reg, Rectangle_t* rect); Returns smallest enclosing rectangle. char ** ListFonts(const char* fontname, Int_t max, Int_t& count); Returns list of font names matching fontname regexp, like ""-*-times-*"".; The pattern string can contain any characters, but each asterisk (*); is a wildcard for any number of characters, and each question mark (?); is a wildcard for a single character. If the pattern string is not in; the Host Portable Character Encoding, the result is implementation; dependent. Use of uppercase or lowercase does not matter. Each returned; string is null-terminated. fontname - specifies the null-terminated pattern string that can; contain wildcard characters; max - specifies the maximum number of names to be returned; count - returns the actual number of font names. void FreeFontNames(char** fontlist); Frees the specified the array of strings ""fontlist"". Drawable_t CreateImage(UInt_t width, UInt_t height); Allocates the memory needed for an drawable. width - the width of the image, in pixels; height - the height of the image, in pixels. void GetImageSize(Drawable_t id, UInt_t& width, UInt_t& height); Returns the width and height of the image id. void PutPixel(Drawable_t id, Int_t x, Int_t y, ULong_t pixel); Overwrites the pixel in the image with the specified pixel value.; The image must contain the x and y coordinates. id - specifies the image; x, y - coordinates; pixel - the new pixel value. void PutImage(Drawable_t id, GContext_t gc, Drawable_t img, Int_t dx, Int_t dy, Int_t x, Int_t y, UInt_t w, UInt_t h); Combines an image with a rectangle of the specified drawable. The; section of the image defined by the x, y, width, and height arguments; is drawn on the specified part of the drawable. id - the drawable; gc - the GC; img - the image you want combined with the rectangle; dx - the offset in X from the left edge of the image; dy - the offset in Y from the top edge of the image; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualX.html:63019,Allocate,Allocates,63019,root/html532/TVirtualX.html,https://root.cern,https://root.cern/root/html532/TVirtualX.html,4,['Allocate'],['Allocates']
Energy Efficiency," represents the first, second, or third order derivative of any RooAbsReal as calculated (numerically) by the MathCore Richardson derivator class ;  CRooFIter;  CRooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset ;  CRooFoamGeneratorClass RooFoamGenerator is a generic toy monte carlo generator that implement the TFOAM sampling technique on any positively valued function ;  CRooFormulaRooFormula an implementation of ROOT::v5::TFormula that interfaces it to RooAbsArg value objects ;  CRooFormulaVar;  CRooFracRemainderRooFracRemainder calculates the remainder fraction of a sum of RooAbsReal fraction, i.e (1 - sum_i a_i) ;  CRooFunctorLightweight interface adaptor that exports a RooAbsPdf as a functor ;  CRooFunctor1DBindingRooCFunction1Binding is a templated implementation of class RooAbsReal that binds generic C(++) functions to a RooAbsReal argument thus allowing generic C++ functions to be used as RooFit functions ;  CRooFunctor1DPdfBinding;  CRooFunctorBindingRooCFunction1Binding is a templated implementation of class RooAbsReal that binds generic C(++) functions to a RooAbsReal argument thus allowing generic C++ functions to be used as RooFit functions ;  CRooFunctorPdfBinding;  CRooGammaImplementation of the Gamma PDF for RooFit/RooStats ;  CRooGaussianPlain Gaussian p.d.f ;  CRooGaussKronrodIntegrator1DRooGaussKronrodIntegrator1D implements the Gauss-Kronrod integration algorithm ;  CRooGaussModelClass RooGaussModel implements a RooResolutionModel that models a Gaussian distribution ;  CRooGenContextClass RooGenContext implement a universal generator context for all RooAbsPdf classes that do not have or need a specialized generator context ;  CRooGenericPdfRooGenericPdf is a concrete implementation of a probability density function, which takes a RooArgList of servers and a C++ expression string defining how its value should be calculated from the given list of servers ;  CRooGenFitStudyRooGenFitStudy is an abstr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:113946,adapt,adaptor,113946,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['adapt'],['adaptor']
Energy Efficiency," reproducing the signal and background; : distributions of the input variables. Correlations among the ; : variables are ignored.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Required for good performance are decorrelated input variables; : (PCA transformation via the option ""VarTransform=Decorrelate""; : may be tried). Irreducible non-linear correlations may be reduced; : by precombining strongly correlated input variables, or by simply; : removing one of the variables.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : High fidelity PDF estimates are mandatory, i.e., sufficient training ; : statistics is required to populate the tails of the distributions; : It would be a surprise if the default Spline or KDE kernel parameters; : provide a satisfying fit to the data. The user is advised to properly; : tune the events per bin and smooth options in the spline cases; : individually per variable. If the KDE kernel is used, the adaptive; : Gaussian kernel may lead to artefacts, so please always also try; : the non-adaptive one.; : ; : All tuning parameters must be adjusted individually for each input; : variable!; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for training with 14000 events: 0.117 sec ; Likelihood : [dataset] : Evaluation of Likelihood on training sample (14000 events); : Elapsed time for evaluation of 14000 events: 0.02 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_Likelihood.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_Likelihood.class.C␛[0m; : Higgs_ClassificationOutput.root:/dataset/Method_Likelihood/Likelihood; Factory : Training finished; : ; Factory : Train method: Fisher for Classification; : ; : ; : ␛[1m=====================================",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:17501,adapt,adaptive,17501,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,2,['adapt'],['adaptive']
Energy Efficiency," reproducing the signal and background; : distributions of the input variables. Correlations among the ; : variables are ignored.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Required for good performance are decorrelated input variables; : (PCA transformation via the option ""VarTransform=Decorrelate""; : may be tried). Irreducible non-linear correlations may be reduced; : by precombining strongly correlated input variables, or by simply; : removing one of the variables.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : High fidelity PDF estimates are mandatory, i.e., sufficient training ; : statistics is required to populate the tails of the distributions; : It would be a surprise if the default Spline or KDE kernel parameters; : provide a satisfying fit to the data. The user is advised to properly; : tune the events per bin and smooth options in the spline cases; : individually per variable. If the KDE kernel is used, the adaptive; : Gaussian kernel may lead to artefacts, so please always also try; : the non-adaptive one.; : ; : All tuning parameters must be adjusted individually for each input; : variable!; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for training with 14000 events: 0.118 sec ; Likelihood : [dataset] : Evaluation of Likelihood on training sample (14000 events); : Elapsed time for evaluation of 14000 events: 0.0223 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_Likelihood.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_Likelihood.class.C␛[0m; : Higgs_ClassificationOutput.root:/dataset/Method_Likelihood/Likelihood; Factory : Training finished; : ; Factory : Train method: Fisher for Classification; : ; : ; : ␛[1m===================================",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:17436,adapt,adaptive,17436,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,2,['adapt'],['adaptive']
Energy Efficiency," reproducing the signal and background; : distributions of the input variables. Correlations among the ; : variables are ignored.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Required for good performance are decorrelated input variables; : (PCA transformation via the option ""VarTransform=Decorrelate""; : may be tried). Irreducible non-linear correlations may be reduced; : by precombining strongly correlated input variables, or by simply; : removing one of the variables.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : High fidelity PDF estimates are mandatory, i.e., sufficient training ; : statistics is required to populate the tails of the distributions; : It would be a surprise if the default Spline or KDE kernel parameters; : provide a satisfying fit to the data. The user is advised to properly; : tune the events per bin and smooth options in the spline cases; : individually per variable. If the KDE kernel is used, the adaptive; : Gaussian kernel may lead to artefacts, so please always also try; : the non-adaptive one.; : ; : All tuning parameters must be adjusted individually for each input; : variable!; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for training with 2000 events: 0.0149 sec ; Likelihood : [dataset] : Evaluation of Likelihood on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.0035 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_Likelihood.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_Likelihood.class.C␛[0m; : TMVAC.root:/dataset/Method_Likelihood/Likelihood; Factory : Training finished; : ; Factory : Train method: LikelihoodPCA for Classification; : ; : Preparing the Principle Component (PCA) transformation...; TFHandler_Like",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:28845,adapt,adaptive,28845,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,2,['adapt'],['adaptive']
Energy Efficiency," request methods with TH2 histogram from hsimple.C shown in the table:. Request; Size. root.bin; 7672 bytes. root.bin.gz; 1582 bytes. root.json; 8570 bytes. root.json?compact=3; 6004 bytes. root.json?compact=23; 5216 bytes. root.json.gz?compact=23; 1855 bytes. One should remember that JSON representation always includes names of the data fields which are not present in the binary representation. Even then the size difference is negligible.; root.json used in JSROOT to request objects from THttpServer.; 1.9.2 Generating images out of objects; For the ROOT classes which are implementing Draw method (like TH1 or TGraph) one could produce images with requests: root.png, root.gif, root.jpeg. For example:; [shell] wget ""http://localhost:8080/Files/hsimple.root/hpx/root.png?w=500&h=500&opt=lego1"" -O lego1.png; For all such requests following parameters could be specified:. h - image height; w - image width; opt - draw options. 1.9.3 Methods execution; By default THttpServer starts in monitoring (read-only) mode and therefore forbid any methods execution. One could specify read-write mode when server is started:; auto serv = new THttpServer(""http:8080;rw"");; Or one could disable read-only mode with the call:; serv->SetReadOnly(kFALSE);; Or one could allow access to the folder, object or specific object methods with:; serv->Restrict(""/Histograms"", ""allow=admin""); // allow full access for user with 'admin' account; serv->Restrict(""/Histograms/hist1"", ""allow=all""); // allow full access for all users; serv->Restrict(""/Histograms/hist1"", ""allow_method=Rebin""); // allow only Rebin method; ‘exe.json’ accepts following parameters:. method - name of method to execute; prototype - method prototype (see TClass::GetMethodWithPrototype for details); compact - compact parameter, used to compress return value; _ret_object_ - name of the object which should be returned as result of method execution (used together with remote TTree::Draw call). Example of retrieving object title:; [shell] wg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:17248,monitor,monitoring,17248,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,2,['monitor'],['monitoring']
Energy Efficiency," resource.Definition TEnv.cxx:491; TExMapIterDefinition TExMap.h:85; TExMapIter::NextBool_t Next(ULong64_t &hash, Long64_t &key, Long64_t &value)Get next entry from TExMap. Returns kFALSE at end of map.Definition TExMap.cxx:412; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::Addvoid Add(ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table. The key should be unique.Definition TExMap.cxx:88; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TGX11This class is the basic interface to the X11 (Xlib) graphics system.Definition TGX11.h:80; TGX11::DrawFillAreavoid DrawFillArea(Int_t n, TPoint *xy) overrideFill area described by polygon.Definition TGX11.cxx:589; TGX11::fDisplayvoid * fDisplayPointer to display.Definition TGX11.h:125; TGX11::MakeOpaqueColorsvoid MakeOpaqueColors(Int_t percent, ULong_t *orgcolors, Int_t ncolors)Get RGB values for orgcolors, add percent neutral to the RGB and allocate fNewColors.Definition TGX11.cxx:2974; TGX11::SetLineColorvoid SetLineColor(Color_t cindex) overrideSet color index for lines.Definition TGX11.cxx:2276; TGX11::GetGeometryvoid GetGeometry(Int_t wid, Int_t &x, Int_t &y, UInt_t &w, UInt_t &h) overrideReturn position and size of window wid.Definition TGX11.cxx:961; TGX11::fColormapColormap fColormapDefault colormap, 0 if b/w.Definition TGX11.h:129; TGX11::GetWindowIDWindow_t GetWindowID(Int_t wid) overrideReturn the X11 window identifier.Definition TGX11.cxx:1068; TGX11::WriteGIFInt_t WriteGIF(char *name) overrideWrites the current window into GIF file.Definition TGX11.cxx:3387; TGX11::SetFillColorvoid SetFillColor(Color_t cindex) overrideSet color index for fill areas.Definition TGX11.cxx:2183; TGX11::ResizeWindowvoid ResizeWindow(Int_t wid) overrideResize the current window if necessary.Definition TGX11.cxx:1919; TGX11::SetTextAlignvoid SetTextAlign(Short_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:144375,allocate,allocate,144375,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency," responsibility to manage the created histogram. code proposed by Jason Seely (seely@mit.edu) and adapted by R.Brun. clone the histograms so top and bottom will have the; correct dimensions:; Sumw2 just makes sure the errors will be computed properly; when we form sums and ratios below. Int_t GetDefaultBufferSize(); static function; return the default buffer size for automatic histograms; the parameter fgBufferSize may be changed via SetDefaultBufferSize. Bool_t GetDefaultSumw2(); static function; return kTRUE if TH1::Sumw2 must be called when creating new histograms.; see TH1::SetDefaultSumw2. Double_t GetEntries() const; return the current number of entries. Double_t GetEffectiveEntries() const; number of effective entries of the histogram,; neff = (Sum of weights )^2 / (Sum of weight^2 ); In case of an unweighted histogram this number is equivalent to the; number of entries of the histogram.; For a weighted histogram, this number corresponds to the hypotetical number of unweighted entries; a histogram would need to have the same statistical power as this weighted histogram.; Note: The underflow/overflow are included if one has set the TH1::StatOverFlows flag; and if the statistics has been computed at filling time.; If a range is set in the histogram the number is computed from the given range. char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the histogram info (bin number, contents, integral up to bin; corresponding to cursor position px,py. TVirtualHistPainter * GetPainter(Option_t* option = """"); return pointer to painter; if painter does not exist, it is created. Int_t GetQuantiles(Int_t nprobSum, Double_t* q, const Double_t* probSum = 0); Compute Quantiles for this histogram; Quantile x_q of a probability distribution Function F is defined as. F(x_q) = q with 0 <= q <= 1. For instance the median x_0.5 of a distribution is defined as that value; of the random variable for which the distribution function equals 0.5:. F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:88834,power,power,88834,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,2,['power'],['power']
Energy Efficiency," return 1 if the file; exists and contains the correct tree and 0 otherwise. Int_t AddFile(const char* name, Long64_t nentries = kBigNumber, const char* tname = """"); -- Add a new file to this chain. If tname is specified, the chain will load the tree named tname; from the file, otherwise the original treename specified in the; TChain constructor will be used. A. If nentries <= 0, the file is opened and the tree header read; into memory to get the number of entries. B. If nentries > 0, the file is not opened, and nentries is assumed; to be the number of entries in the file. In this case, no check; is made that the file exists nor that the tree exists in the file.; This second mode is interesting in case the number of entries in; the file is already stored in a run database for example. C. If nentries == kBigNumber (default), the file is not opened.; The number of entries in each file will be read only when the file; is opened to read an entry. This option is the default and very; efficient if one processes the chain sequentially. Note that in; case GetEntry(entry) is called and entry refers to an entry in the; third file, for example, this forces the tree headers in the first; and second file to be read to find the number of entries in those; files. Note that if one calls GetEntriesFast() after having created; a chain with this default, GetEntriesFast() will return kBigNumber!; Using the GetEntries() function instead will force all of the tree; headers in the chain to be read to read the number of entries in; each tree. D. The TChain data structure; Each TChainElement has a name equal to the tree name of this TChain; and a title equal to the file name. So, to loop over the; TFiles that have been added to this chain:. TObjArray *fileElements=chain->GetListOfFiles();; TIter next(fileElements);; TChainElement *chEl=0;; while (( chEl=(TChainElement*)next() )) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. The function returns 1 if the file is successfully",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TChain.html:31481,efficient,efficient,31481,root/html532/TChain.html,https://root.cern,https://root.cern/root/html532/TChain.html,2,['efficient'],['efficient']
Energy Efficiency," return;; 4978 }; 4979 ; 4980 //; 4981 // FIXME: When would this happen?; 4982 //; 4983 ; 4984 if (fType < -1) {; 4985 return;; 4986 }; 4987 ; 4988 //; 4989 // Special case when called from code generated by TTree::MakeClass.; 4990 //; 4991 ; 4992 if (Longptr_t(addr) == -1) {; 4993 // FIXME: Do we have to release an object here?; 4994 // ReleaseObject();; 4995 fAddress = (char*) -1;; 4996 fObject = (char*) -1;; 4997 ResetBit(kDeleteObject);; 4998 ResetBit(kAddressSet);; 4999 return;; 5000 }; 5001 ; 5002 //; 5003 // Reset last read entry number, we have a new user object now.; 5004 //; 5005 ; 5006 fReadEntry = -1;; 5007 ; 5008 //; 5009 // Make sure our branch class is instantiated.; 5010 //; 5011 TClass* clOfBranch = fBranchClass.GetClass();; 5012 if( fTargetClass.GetClassName()[0] ) {; 5013 clOfBranch = fTargetClass;; 5014 }; 5015 ; 5016 //; 5017 // Try to build the streamer info.; 5018 //; 5019 ; 5020 TStreamerInfo *info = GetInfoImp();; 5021 ; 5022 // FIXME: Warn about failure to get the streamer info here?; 5023 ; 5024 //; 5025 // We may have allocated an object last time we were called.; 5026 //; 5027 ; 5028 if (fObject && TestBit(kDeleteObject)){; 5029 ReleaseObject();; 5030 }; 5031 ; 5032 //; 5033 // Remember the pointer to the pointer to our object.; 5034 //; 5035 ; 5036 fAddress = (char*) addr;; 5037 if (fAddress != (char*)(&fObject)) {; 5038 fObject = nullptr;; 5039 }; 5040 ResetBit(kDeleteObject);; 5041 SetBit(kAddressSet);; 5042 ; 5043 //; 5044 // Do special stuff if we got called from a MakeClass class.; 5045 // Allow sub-branches to have independently set addresses.; 5046 //; 5047 ; 5048 if (TestBit(kDecomposedObj)) {; 5049 if (fID > -1) {; 5050 // We are *not* a top-level branch.; 5051 if (!info) {; 5052 // No streamer info, give up.; 5053 // FIXME: We should have an error message here.; 5054 fObject = fAddress;; 5055 } else {; 5056 // Compensate for the fact that the i/o routines; 5057 // will add the streamer offset to the address.; 5058 fObject = fA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:184766,allocate,allocated,184766,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," rgb[2]); }; 81 ; 82 /** Set r/g/b components of color */; 83 void SetRGB(uint8_t r, uint8_t g, uint8_t b);; 84 ; 85 /** Set r/g/b/a components of color, a is integer between 0..255 */; 86 void SetRGBA(uint8_t r, uint8_t g, uint8_t b, uint8_t alpha);; 87 ; 88 /** Set alpha as value from range 0..255 */; 89 void SetAlpha(uint8_t alpha);; 90 ; 91 /** Set alpha as float value from range 0..1 */; 92 void SetAlphaFloat(float alpha); 93 {; 94 if (alpha <= 0.); 95 SetAlpha(0);; 96 else if (alpha >= 1.); 97 SetAlpha(255);; 98 else; 99 SetAlpha((uint8_t)(alpha * 255));; 100 }; 101 ; 102 /** Returns true if color alpha (opacity) was specified */; 103 bool HasAlpha() const { return IsRGBA(); }; 104 ; 105 /** Returns color as RGBA array, trying also convert color name into RGBA value */; 106 std::vector<uint8_t> AsRGBA() const;; 107 ; 108 /** Returns red color component 0..255 */; 109 uint8_t GetRed() const; 110 {; 111 auto rgba = AsRGBA();; 112 return rgba.size() > 2 ? rgba[0] : 0;; 113 }; 114 ; 115 /** Returns green color component 0..255 */; 116 uint8_t GetGreen() const; 117 {; 118 auto rgba = AsRGBA();; 119 return rgba.size() > 2 ? rgba[1] : 0;; 120 }; 121 ; 122 /** Returns blue color component 0..255 */; 123 uint8_t GetBlue() const; 124 {; 125 auto rgba = AsRGBA();; 126 return rgba.size() > 2 ? rgba[2] : 0;; 127 }; 128 ; 129 /** Returns color alpha (opacity) as uint8_t 0..255 */; 130 uint8_t GetAlpha() const; 131 {; 132 auto rgba = AsRGBA();; 133 return rgba.size() > 3 ? rgba[3] : 0xFF;; 134 }; 135 ; 136 /** Returns color alpha (opacity) as float from 0..1 */; 137 float GetAlphaFloat() const; 138 {; 139 return GetAlpha() / 255.;; 140 }; 141 ; 142 /** Set color as plain SVG name like ""white"" or ""lightblue"" */; 143 bool SetName(const std::string &name); 144 {; 145 fColor = name;; 146 if (!IsName()) {; 147 Clear();; 148 return false;; 149 }; 150 return true;; 151 }; 152 ; 153 void SetOrdinal(float val);; 154 float GetOrdinal() const;; 155 ; 156 /** Returns color as it stored ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RColor_8hxx_source.html:3631,green,green,3631,doc/master/RColor_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RColor_8hxx_source.html,1,['green'],['green']
Energy Efficiency," same moment ( has to be an atomic operation in case of multithreading ). ;  ; template<class Iterator > ; void InitFromRange (Iterator dataItr);  ; void UnWrap ();  ;  Static Protected Member Functions inherited from ROOT::Fit::FitData; static constexpr unsigned VectorPadding (const unsigned);  If VecCore is not defined, there is no vectorization available and the SIMD vector size will always be one. ;  ;  Protected Attributes inherited from ROOT::Fit::FitData; unsigned int fDim;  ; unsigned int fMaxPoints;  ; unsigned int fNPoints;  ; bool fWrapped;  . #include <Fit/UnBinData.h>. Inheritance diagram for ROOT::Fit::UnBinData:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ UnBinData() [1/12]. ROOT::Fit::UnBinData::UnBinData ; (; unsigned int ; maxpoints = 0, . unsigned int ; dim = 1, . bool ; isWeighted = false . ). inlineexplicit . constructor from dimension of point and max number of points (to pre-allocate vector) ; Definition at line 54 of file UnBinData.h. ◆ UnBinData() [2/12]. ROOT::Fit::UnBinData::UnBinData ; (; const DataRange & ; range, . unsigned int ; maxpoints = 0, . unsigned int ; dim = 1, . bool ; isWeighted = false . ). inlineexplicit . constructor from range and default option ; Definition at line 67 of file UnBinData.h. ◆ UnBinData() [3/12]. ROOT::Fit::UnBinData::UnBinData ; (; const DataOptions & ; opt, . const DataRange & ; range, . unsigned int ; maxpoints = 0, . unsigned int ; dim = 1, . bool ; isWeighted = false . ). inline . constructor from options and range ; Definition at line 79 of file UnBinData.h. ◆ UnBinData() [4/12]. ROOT::Fit::UnBinData::UnBinData ; (; unsigned int ; n, . const double * ; dataX . ). inline . constructor for 1D external data (data are not copied inside) ; Definition at line 91 of file UnBinData.h. ◆ UnBinData() [5/12]. ROOT::Fit::UnBinData::UnBinData ; (; unsigned int ; n, . const double * ; dataX, . const double * ; dataY, . boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1UnBinData.html:10132,allocate,allocate,10132,doc/master/classROOT_1_1Fit_1_1UnBinData.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1UnBinData.html,1,['allocate'],['allocate']
Energy Efficiency," see RResultPtr.; 1686 // clang-format on; 1687 template <typename F, typename T = typename TTraits::CallableTraits<F>::ret_type>; 1688 RResultPtr<T> Reduce(F f, std::string_view columnName = """"); 1689 {; 1690 static_assert(; 1691 std::is_default_constructible<T>::value,; 1692 ""reduce object cannot be default-constructed. Please provide an initialisation value (redIdentity)"");; 1693 return Reduce(std::move(f), columnName, T());; 1694 }; 1695 ; 1696 ////////////////////////////////////////////////////////////////////////////; 1697 /// \brief Execute a user-defined reduce operation on the values of a column.; 1698 /// \tparam F The type of the reduce callable. Automatically deduced.; 1699 /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; 1700 /// \param[in] f A callable with signature `T(T,T)`; 1701 /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; 1702 /// \param[in] redIdentity The reduced object of each thread is initialized to this value.; 1703 /// \return the reduced quantity wrapped in a RResultPtr.; 1704 ///; 1705 /// ### Example usage:; 1706 /// ~~~{.cpp}; 1707 /// auto sumOfIntColWithOffset = d.Reduce([](int x, int y) { return x + y; }, ""intCol"", 42);; 1708 /// ~~~; 1709 /// See the description of the first Reduce overload for more information.; 1710 template <typename F, typename T = typename TTraits::CallableTraits<F>::ret_type>; 1711 RResultPtr<T> Reduce(F f, std::string_view columnName, const T &redIdentity); 1712 {; 1713 return Aggregate(f, f, columnName, redIdentity);; 1714 }; 1715 ; 1716 ////////////////////////////////////////////////////////////////////////////; 1717 /// \brief Return the number of entries processed (*lazy action*).; 1718 /// \return the number of entries wrapped in a RResultPtr.; 1719 ///; 1720 /// Useful e.g. for counting the number of entries passing a certain filter (see also `Report`).; 1721 /// This action is *lazy*: upon invocation of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:95458,reduce,reduced,95458,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['reduce'],['reduced']
Energy Efficiency," set of boxes, size of box is proportional to bin content. GLBOX1""; The same as ""glbox"", but spheres are drawn instead of boxes. TH3 as iso-surface(s); The supported option is:. ""GLISO"" ; TH3 is drawn using iso-surfaces. TF3 (implicit function); The supported option is:. GLTF3"" ; Draw a TF3. Parametric surfaces; $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric; equations and visualize the surface.; Interaction with the plots; All the interactions are implemented via standard methods; DistancetoPrimitive() and ExecuteEvent(). That's why all the; interactions with the OpenGL plots are possible only when the mouse cursor is; in the plot's area (the plot's area is the part of a the pad occupied by; gl-produced picture). If the mouse cursor is not above gl-picture, the standard; pad interaction is performed.; Selectable parts; Different parts of the plot can be selected:. xoz, yoz, xoy back planes:; When such a plane selected, it's highlighted in green if the; dynamic slicing by this plane is supported, and it's; highlighted in red, if the dynamic slicing is not supported.; The plot itself:; On surfaces, the selected surface is outlined in red. (TF3 and; ISO are not outlined). On lego plots, the selected bin is; highlighted. The bin number and content are displayed in pad's; status bar. In box plots, the box or sphere is highlighted and; the bin info is displayed in pad's status bar. Rotation and zooming. Rotation:; When the plot is selected, it can be rotated by pressing and; holding the left mouse button and move the cursor.; Zoom/Unzoom:; Mouse wheel or 'j', 'J', 'k', 'K' keys. Panning; The selected plot can be moved in a pad's area by pressing and; holding the left mouse button and the shift key.; Box cut; Surface, iso, box, TF3 and parametric painters support box cut by; pressing the 'c' or 'C' key when the mouse cursor is in a plot's; area. That will display a transparent box, cutting away part of the; surface (or boxes) in order to show internal ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:71498,green,green,71498,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,8,['green'],['green']
Energy Efficiency," set of unblinding parameters ;  CRooUnblindPrecisionImplementation of BlindTools' precision blinding method A RooUnblindPrecision object is a real valued function object, constructed from a blind value holder and a set of unblinding parameters ;  CRooUnblindUniformImplementation of BlindTools' offset blinding method A RooUnblindUniform object is a real valued function object, constructed from a blind value holder and a set of unblinding parameters ;  CRooUniformFlat p.d.f ;  CRooUniformBinningRooUniformBinning is an implementation of RooAbsBinning that provides a uniform binning in 'n' bins between the range end points ;  CRooUnitTestRooUnit test is an abstract base class for unit regression tests for RooFit and RooStats tests performed in stressRooFit and stressRooStats Implementations of this class must implement abstract method testCode() which defines the regression test to be performed ;  ►CRooVectorDataStoreRooVectorDataStore is the abstract base class for data collection that use a TTree as internal storage mechanism ;  CCatVector;  CRealFullVector;  CRealVector;  CRooVoigtianRooVoigtian is an efficient implementation of the convolution of a Breit-Wigner with a Gaussian, making use of the complex error function ;  ►CRooWorkspaceThe RooWorkspace is a persistable container for RooFit projects ;  ►CCodeRepo;  CClassFiles;  CClassRelInfo;  CExtraHeader;  CWSDir;  CRooWorkspaceHandleAn interface to set and retrieve a workspace ;  CRooXYChi2Var;  CRPadUserAxisBaseBase class for user coordinates (e.g ;  Crsa_KEY;  Crsa_KEY_export;  Crsa_NUMBER;  CSegment_t;  CSetWindowAttributes_t;  CSHtmlExtensions_t;  CSHtmlIndex_t;  CSHtmlMargin_t;  CSHtmlStyle_t;  CSHtmlStyleStack_t;  CSHtmlTokenMap_t;  CSQLite3_Stmt_t;  CSysInfo_t;  CtableDescriptor_st;  CTAdvancedGraphicsDialog;  CTAlien;  CTAlienCollection;  CTAlienDirectory;  CTAlienDirectoryEntry;  CTAlienFile;  CTAliEnFind;  CTAlienJDL;  CTAlienJob;  CTAlienJobStatus;  CTAlienJobStatusList;  CTAlienMasterJob;  CTAlienMaste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:131995,efficient,efficient,131995,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['efficient'],['efficient']
Energy Efficiency," siblings. ;  ; void MapRaised (Window_t id) override;  Map window on screen and put on top of all windows. ;  ; void MapSubwindows (Window_t id) override;  Maps all subwindows for the specified window ""id"" in top-to-bottom stacking order. ;  ; void MapWindow (Window_t id) override;  Map window on screen. ;  ; void MoveResizeWindow (Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h) override;  Move and resize a window. ;  ; void MoveWindow (Int_t wid, Int_t x, Int_t y) override;  Move the window wid. ;  ; void MoveWindow (Window_t id, Int_t x, Int_t y) override;  Move a window. ;  ; void NextEvent (Event_t &event) override;  Copies first pending event from event queue to Event_t structure and removes event from queue. ;  ; Int_t OpenDisplay (const char *dpyName=0) override;  Open the display. Return -1 if the opening fails, 0 when ok. ;  ; Int_t OpenPixmap (UInt_t w, UInt_t h) override;  Open a new pixmap. ;  ; Bool_t ParseColor (Colormap_t cmap, const char *cname, ColorStruct_t &color) override;  Parse string cname containing color name, like ""green"" or ""#00FF00"". ;  ; Bool_t PointInRegion (Int_t x, Int_t y, Region_t reg) override;  Returns true if the point x,y is in the region. ;  ; Region_t PolygonRegion (Point_t *points, Int_t np, Bool_t winding) override;  Create region for the polygon defined by the points array. ;  ; void PutImage (Drawable_t id, GContext_t gc, Drawable_t img, Int_t dx, Int_t dy, Int_t x, Int_t y, UInt_t w, UInt_t h) override;  Combines an image with a rectangle of the specified drawable. ;  ; void PutPixel (Drawable_t id, Int_t x, Int_t y, ULong_t pixel) override;  Overwrites the pixel in the image with the specified pixel value. ;  ; void QueryColor (Colormap_t cmap, ColorStruct_t &color) override;  Fill in the primary color components for a specific pixel value. ;  ; void QueryPointer (Int_t &ix, Int_t &iy) override;  Query pointer position. ;  ; void QueryPointer (Window_t id, Window_t &rootw, Window_t &childw, Int_t &root_x, Int_t &root",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:15674,green,green,15674,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['green'],['green']
Energy Efficiency," signal region has to be blinded, one has to exclude the blinded region from the computation of the normalisation.; In this tutorial, we show how to explicitly choose the normalisation when plotting using NormRange().; Thanks to Marc Escalier for asking how to do this correctly. ; #include <RooDataSet.h>; #include <RooExponential.h>; #include <RooPlot.h>; #include <RooRealVar.h>; #include <TCanvas.h>; ; using namespace RooFit;; ; void rf212_plottingInRanges_blinding(); {; // Make a fit model; RooRealVar x(""x"", ""The observable"", 1, 30);; RooRealVar tau(""tau"", ""The exponent"", -0.1337, -10., -0.1);; RooExponential expo(""expo"", ""A falling exponential function"", x, tau);; ; // Define the sidebands (e.g. background regions); x.setRange(""full"", 1, 30);; x.setRange(""left"", 1, 10);; x.setRange(""right"", 20, 30);; ; // Generate toy data, and cut out the blinded region.; std::unique_ptr<RooDataSet> data{expo.generate(x, 1000)};; std::unique_ptr<RooAbsData> blindedData{data->reduce(CutRange(""left,right""))};; ; // Kick tau a bit, and run an unbinned fit where the blinded data are missing.; // ----------------------------------------------------------------------------------------------------------; // The fit should be done only in the unblinded regions, otherwise it would; // try to make the model adapt to the empty bins in the blinded region.; tau.setVal(-2.);; expo.fitTo(*blindedData, Range(""left,right""), PrintLevel(-1));; ; // Clear the ""fitrange"" attribute of the PDF. Otherwise, the fitrange would; // be automatically taken as the NormRange() for plotting. We want to avoid; // this, because the point of this tutorial is to show what can go wrong when; // the NormRange() is not specified.; expo.removeStringAttribute(""fitrange"");; ; ; // Here we will plot the results; TCanvas *canvas=new TCanvas(""canvas"",""canvas"",800,600);; canvas->Divide(2,1);; ; ; // Wrong:; // ----------------------------------------------------------------------------------------------------------; // Plott",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8C.html:1534,reduce,reduce,1534,doc/master/rf212__plottingInRanges__blinding_8C.html,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8C.html,1,['reduce'],['reduce']
Energy Efficiency," size = 0, unsigned int rule = 0) :; 124 fIntegrator(nullptr), fFunc(nullptr); 125 {; 126 fIntegrator = CreateIntegrator(type, absTol, relTol, size, rule);; 127 }; 128 ; 129 /**; 130 Constructor of one dimensional Integrator passing a function interface; 131 ; 132 @param f integration function (1D interface). It is copied inside; 133 @param type integration type (adaptive, non-adaptive, etc..); 134 @param absTol desired absolute tolerance. The algorithm will stop when either the absolute OR the relative tolerance are satisfied.; 135 @param relTol desired relative tolerance; 136 @param size maximum number of sub-intervals; 137 @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type); 138 ; 139 NOTE: When no values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions; 140 */; 141 explicit; 142 IntegratorOneDim(const IGenFunction &f, IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = -1, double relTol = -1, unsigned int size = 0, int rule = 0) :; 143 fIntegrator(nullptr), fFunc(nullptr); 144 {; 145 fIntegrator = CreateIntegrator(type, absTol, relTol, size, rule);; 146 SetFunction(f,true);; 147 }; 148 ; 149 /**; 150 Template Constructor of one dimensional Integrator passing a generic function object; 151 ; 152 @param f integration function (any C++ callable object implementing operator()(double x); 153 @param type integration type (adaptive, non-adaptive, etc..); 154 @param absTol desired absolute tolerance. The algorithm will stop when either the absolute OR the relative tolerance are satisfied.; 155 @param relTol desired relative tolerance; 156 @param size maximum number of sub-intervals; 157 @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type); 158 ; 159 NOTE: When no values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions; 160 ; 161 */; 162 ; 163 template<class Function>; 164 explicit; 165 IntegratorOneDim(F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Integrator_8h_source.html:6246,adapt,adaptive,6246,doc/master/Integrator_8h_source.html,https://root.cern,https://root.cern/doc/master/Integrator_8h_source.html,2,['adapt'],['adaptive']
Energy Efficiency," socket. ;  ; virtual void ActivateAll ();  Activate all de-activated sockets. ;  ; virtual void Add (TSocket *sock, Int_t interest=kRead);  Add socket to the monitor's active list. ;  ; virtual void DeActivate (TSocket *sock);  De-activate a socket. ;  ; virtual void DeActivateAll ();  De-activate all activated sockets. ;  ; Int_t GetActive (Long_t timeout=-1) const;  Return number of sockets in the active list. ;  ; Int_t GetDeActive () const;  Return number of sockets in the de-active list. ;  ; TList * GetListOfActives () const;  Returns a list with all active sockets. ;  ; TList * GetListOfDeActives () const;  Returns a list with all de-active sockets. ;  ; void Interrupt ();  ; TClass * IsA () const override;  ; Bool_t IsActive (TSocket *s) const;  Check if socket 's' is in the active list. ;  ; virtual void Ready (TSocket *sock);  Emit signal when some socket is ready. ;  ; virtual void Remove (TSocket *sock);  Remove a socket from the monitor. ;  ; virtual void RemoveAll ();  Remove all sockets from the monitor. ;  ; void ResetInterrupt ();  ; TSocket * Select ();  Return pointer to socket for which an event is waiting. ;  ; TSocket * Select (Long_t timeout);  Return pointer to socket for which an event is waiting. ;  ; Int_t Select (TList *rdready, TList *wrready, Long_t timeout);  Return numbers of sockets that are ready for reading or writing. ;  ; virtual void SetInterest (TSocket *sock, Int_t interest=kRead);  Set interest mask for socket sock to interest. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:2402,monitor,monitor,2402,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,1,['monitor'],['monitor']
Energy Efficiency," solution to this problem is to call BypassStreamer(kFALSE) for the TClonesArray. In this case, the normal Bar::Streamer function will be called. The Bar::Streamer function works OK independently if the Bar StreamerInfo had been generated in optimized mode or not. . Definition at line 321 of file TClonesArray.cxx. ◆ CanBypassStreamer(). Bool_t TClonesArray::CanBypassStreamer ; (; ); const. inline . Definition at line 64 of file TClonesArray.h. ◆ Class(). static TClass * TClonesArray::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TClonesArray::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TClonesArray::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 83 of file TClonesArray.h. ◆ Clear(). void TClonesArray::Clear ; (; Option_t * ; option = """"). overridevirtual . Clear the clones array. ; Only use this routine when your objects don't allocate memory since it will not call the object dtors. However, if the class in the TClonesArray implements the function Clear(Option_t *option) and if option = ""C"" the function Clear() is called for all objects in the array. In the function Clear(), one can delete objects or dynamic arrays allocated in the class. This procedure is much faster than calling TClonesArray::Delete(). When the option starts with ""C+"", eg ""C+xyz"" the objects in the array are in turn cleared with the option ""xyz"" ; Implements TCollection.; Definition at line 420 of file TClonesArray.cxx. ◆ Compress(). void TClonesArray::Compress ; (; ). overridevirtual . Remove empty slots from array. ; Reimplemented from TObjArray.; Definition at line 332 of file TClonesArray.cxx. ◆ ConstructedAt() [1/2]. TObject * TClonesArray::ConstructedAt ; (; Int_t ; idx). Get an object at index 'idx' that is guaranteed to have been constructed. ; It might be either a freshly allocated object or one that had already been allocated (and as",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:33209,allocate,allocate,33209,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['allocate'],['allocate']
Energy Efficiency," start (cm). See also comments*; float phi0; /* azimuthal angle at start (deg) *; float z0; /* z-coord. at start (cm) *; float psi; /* azimuthal angle of pT vector (deg) *; float tanl; /* tan(dip) =pz/pt at start *; float invpt; /* 1/pt at start (GeV/c)^(-1) *; float curvature; /* Track curvature (1/cm) *; float covar[15]; /* full covariance matrix *; float chisq[2]; /* Chi-square per degree of freedom *; float x_first[3]; /* coord. of first measured point (cm) *; float x_last[3]; /* coord. of last measured point (cm) *; float length; /* from first to last point (cm) *; float impact; /* primary vertex (cm) *; unsigned long map[2]; /* extrap. info. (see preceeding comments)*; int id; /* Primary key (see comments) *; int iflag; /* bitmask quality info. (see comments) *; int det_id; /* Detector id information *; int method; /* Track finding/fitting method, packed *; int pid; /* Geant particle ID for assumed mass *; int n_point; /* SVT, TPC, FTPC component #s are packed *; int n_max_point; /* SVT, TPC, FTPC component #s are packed *; int n_fit_point; /* SVT, TPC, FTPC component #s are packed *; int icharge; /* Particle charge in units of |e| *; int id_start_vertex; /* final fit and primary track candidates *; } DST_TRACK_ST;. class St_dst_track : public TTable; {; public:; ClassDefTable(St_dst_track,dst_track_st); ClassDef(St_dst_track,2) //C++ wrapper for <dst_track> StAF table; };; #endif. where the CPP macro defines several convinient methods for the; ""table"" class (see: $ROOTSYS/table/inc/Ttypes.h for details:. #define ClassDefTable(className,structName); protected:; static TTableDescriptor *fgColDescriptors;; virtual TTableDescriptor *GetDescriptorPointer() const { return fgColDescriptors;}; virtual void SetDescriptorPointer(TTableDescriptor *list) const { fgColDescriptors = list;}; public:; typedef structName* iterator;; className() : TTable(_QUOTE_(className),sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name) : TTable(name,sizeof(stru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTable.html:2294,charge,charge,2294,root/html528/TTable.html,https://root.cern,https://root.cern/root/html528/TTable.html,4,['charge'],['charge']
Energy Efficiency," static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TGColorDialog.h>. Inheritance diagram for TGColorPick:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGColorPick(). TGColorPick::TGColorPick ; (; const TGWindow * ; p = nullptr, . Int_t ; w = 1, . Int_t ; h = 1, . Int_t ; id = -1 . ). TGColorPick constructor. ; TGColorPick is a widget which allows a color to be picked from HLS space. It consists of two elements: a color map window from where the user can select the hue and saturation level of a color, and a slider to select color's lightness. ; Definition at line 399 of file TGColorDialog.cxx. ◆ ~TGColorPick(). TGColorPick::~TGColorPick ; (; ). override . TGColorPick destructor. ; Definition at line 448 of file TGColorDialog.cxx. Member Function Documentation. ◆ AllocColors(). void TGColorPick::AllocColors ; (; ). protected . Try to allocate first a palette of 64 colors. ; Used by the dithered version of the color maps. ; Definition at line 541 of file TGColorDialog.cxx. ◆ Class(). static TClass * TGColorPick::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGColorPick::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGColorPick::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 131 of file TGColorDialog.h. ◆ ColorSelected(). virtual void TGColorPick::ColorSelected ; (; Pixel_t ; col = 0). inlinevirtual . Definition at line 128 of file TGColorDialog.h. ◆ CreateDitheredImage(). void TGColorPick::CreateDitheredImage ; (; Pixmap_t ; image, . Int_t ; which . ). protected . Create a dithered version of the color map and lightness images for display modes with reduced number of colors. ; The Floyd-Steinberg error diffusion dithering algorithm is used. This routine is called in PseudoColor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGColorPick.html:31380,allocate,allocate,31380,doc/master/classTGColorPick.html,https://root.cern,https://root.cern/doc/master/classTGColorPick.html,1,['allocate'],['allocate']
Energy Efficiency," static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooPowerSum.h>. Inheritance diagram for RooPowerSum:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooPowerSum() [1/3]. RooPowerSum::RooPowerSum ; (; ). inline . Definition at line 22 of file RooPowerSum.h. ◆ RooPowerSum() [2/3]. RooPowerSum::RooPowerSum ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . const RooArgList & ; coefList, . const RooArgList & ; expList . ). Create a power law in the variable x. ; Parameters. [in]nameName of the PDF ; [in]titleTitle for plotting the PDF ; [in]xThe variable of the polynomial ; [in]coefListThe coefficients \( a_i \) ; [in]expListThe exponentials \( b_i \) ; \[; \sum_{i=0}^{n} a_{i} * x^{b_{i}}; \]. This means that RooPowerSum powl(""pow"", ""pow"", x, RooArgList(a1, a2), RooArgList(b1,b2)); RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooPowerSumRooPowerSum implements a power law PDF of the form.Definition RooPowerSum.h:20; xDouble_t x[n]Definition legend1.C:17; computes ; \[; \mathrm{pol}(x) = a1 * x^b1 + a2 * x^b2; \]. Definition at line 56 of file RooPowerSum.cxx. ◆ RooPowerSum() [3/3]. RooPowerSum::RooPowerSum ; (; const RooPowerSum & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 75 of file RooPowerSum.cxx. Member Function Documentation. ◆ analyticalIntegral(). double RooPowerSum::analyticalIntegral ; (; int ; code, . con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPowerSum.html:74000,power,power,74000,doc/master/classRooPowerSum.html,https://root.cern,https://root.cern/doc/master/classRooPowerSum.html,1,['power'],['power']
Energy Efficiency," statistical uncertainties of the histogram template. In conjunction with a constraint term, this can be used to implement the Barlow-Beeston method. The constraint can be implemented using RooHistConstraint.; See also the tutorial rf709_BarlowBeeston.C ; Definition at line 24 of file RooParamHistFunc.h. Public Member Functions;  RooParamHistFunc ();  ;  RooParamHistFunc (const char *name, const char *title, RooDataHist &dh, const RooAbsArg &x, const RooParamHistFunc *paramSource=nullptr, bool paramRelative=true);  ;  RooParamHistFunc (const RooParamHistFunc &other, const char *name=nullptr);  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Implement analytical integrations by doing appropriate weighting from component integrals functions to integrators of components. ;  ; std::list< double > * binBoundaries (RooAbsRealLValue &, double, double) const override;  Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ;  ; TObject * clone (const char *newname) const override;  ; bool forceAnalyticalInt (const RooAbsArg &) const override;  ; double getActual (Int_t ibin);  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise that all integrals can be handled internally. ;  ; double getNominal (Int_t ibin) const;  ; double getNominalError (Int_t ibin) const;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &) const override;  Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ;  ; const RooArgList & paramList () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const override;  Return sampling hint for making curves of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooParamHistFunc.html:1636,efficient,efficiently,1636,doc/master/classRooParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooParamHistFunc.html,1,['efficient'],['efficiently']
Energy Efficiency," storing in the dictionaries the include paths passed with the “-I” switch. ROOT will rely on ROOT_INCLUDE_PATH only at runtime to find headers. Interpreter Library. Resolve memory hoarding in some case of looking up functions ROOT-8145. I/O. Resolve an issue when space is freed in a large ROOT file and a TDirectory is updated and stored the lower (less than 2GB) freed portion of the file ROOT-8055.; Repaired the automatic conversion on read back into an STL collection of a on file object of a class that was inheriting from the STL collection. Meta. Reduce autoparse occasions by autoloading libraries also based on their type_info-derived name, instead of only their normalized name ROOT-7972.; Improve TClassEdit’s handling of STL’s default allocator, in particular for std::map ROOT-8048; Fix a problem reading ROOT pcm files using gcc 6 optimized build ROOT-8097; Fix the detection of inheritance from an STL collection of an emulated class. Core. Reduce memory consumption (autoparsing) of plugins TXNetSystem/TNetXNGSystem and TGQt. Minuit. Improve thread safety of TMinuit constructor and destructor ROOT-7992. Bug fixes. ROOT-6923 - Memory leak with circular TTree; ROOT-7593 - Memory leak TROOT::RegisterModule; ROOT-7867 - memprobe script is broken when using CMake; ROOT-7992 - Destructor of TMinuit is not thread safe; ROOT-8048 - ShortTypes doesn’t always strip default stdlib template args; ROOT-8055 - File corruption after TTree deletion; ROOT-8066 - problems creating dictionaries in pyROOT; ROOT-8067 - Source code tree left “polluted” with “interpreter/llvm/src/utils/llvm-build/llvmbuild/*.pyc; ROOT-8068 - Fix file flags for bin/setxrd.* bin/thisroot.*; ROOT-8097 - null pointer dereference in TProtoClass::FillTClass with gcc6 build; ROOT-8117 - Particle in TPDGCode.h but not in TDatabasePDG; ROOT-8145 - TMethodCall::InitWithPrototype keeps accumulating memory on successive calls; ROOT-8149 - Memory leak in TList I/O. Release 6.06/06; Released on July 6, 2016; Cling. P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:29951,consumption,consumption,29951,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['consumption'],['consumption']
Energy Efficiency," strings to printf implementations,; 6814 * so we need to disable the format-nonliteral warning. */; 6815#pragma GCC diagnostic push; 6816#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 6817#endif; 6818 ; 6819 ; 6820/* Alternative alloc_vprintf() for non-compliant C runtimes */; 6821static int; 6822alloc_vprintf2(char **buf, const char *fmt, va_list ap); 6823{; 6824 va_list ap_copy;; 6825 size_t size = MG_BUF_LEN / 4;; 6826 int len = -1;; 6827 ; 6828 *buf = NULL;; 6829 while (len < 0) {; 6830 if (*buf) {; 6831 mg_free(*buf);; 6832 }; 6833 ; 6834 size *= 4;; 6835 *buf = (char *)mg_malloc(size);; 6836 if (!*buf) {; 6837 break;; 6838 }; 6839 ; 6840 va_copy(ap_copy, ap);; 6841 len = vsnprintf_impl(*buf, size - 1, fmt, ap_copy);; 6842 va_end(ap_copy);; 6843 (*buf)[size - 1] = 0;; 6844 }; 6845 ; 6846 return len;; 6847}; 6848 ; 6849 ; 6850/* Print message to buffer. If buffer is large enough to hold the message,; 6851 * return buffer. If buffer is to small, allocate large enough buffer on; 6852 * heap,; 6853 * and return allocated buffer. */; 6854static int; 6855alloc_vprintf(char **out_buf,; 6856 char *prealloc_buf,; 6857 size_t prealloc_size,; 6858 const char *fmt,; 6859 va_list ap); 6860{; 6861 va_list ap_copy;; 6862 int len;; 6863 ; 6864 /* Windows is not standard-compliant, and vsnprintf() returns -1 if; 6865 * buffer is too small. Also, older versions of msvcrt.dll do not have; 6866 * _vscprintf(). However, if size is 0, vsnprintf() behaves correctly.; 6867 * Therefore, we make two passes: on first pass, get required message; 6868 * length.; 6869 * On second pass, actually print the message. */; 6870 va_copy(ap_copy, ap);; 6871 len = vsnprintf_impl(NULL, 0, fmt, ap_copy);; 6872 va_end(ap_copy);; 6873 ; 6874 if (len < 0) {; 6875 /* C runtime is not standard compliant, vsnprintf() returned -1.; 6876 * Switch to alternative code path that uses incremental; 6877 * allocations.; 6878 */; 6879 va_copy(ap_copy, ap);; 6880 len = alloc_vprintf2(out_buf, fmt, ap_copy);; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:198145,allocate,allocate,198145,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency," strings to printf implementations,; 6815 * so we need to disable the format-nonliteral warning. */; 6816#pragma GCC diagnostic push; 6817#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 6818#endif; 6819 ; 6820 ; 6821/* Alternative alloc_vprintf() for non-compliant C runtimes */; 6822static int; 6823alloc_vprintf2(char **buf, const char *fmt, va_list ap); 6824{; 6825 va_list ap_copy;; 6826 size_t size = MG_BUF_LEN / 4;; 6827 int len = -1;; 6828 ; 6829 *buf = NULL;; 6830 while (len < 0) {; 6831 if (*buf) {; 6832 mg_free(*buf);; 6833 }; 6834 ; 6835 size *= 4;; 6836 *buf = (char *)mg_malloc(size);; 6837 if (!*buf) {; 6838 break;; 6839 }; 6840 ; 6841 va_copy(ap_copy, ap);; 6842 len = vsnprintf_impl(*buf, size - 1, fmt, ap_copy);; 6843 va_end(ap_copy);; 6844 (*buf)[size - 1] = 0;; 6845 }; 6846 ; 6847 return len;; 6848}; 6849 ; 6850 ; 6851/* Print message to buffer. If buffer is large enough to hold the message,; 6852 * return buffer. If buffer is to small, allocate large enough buffer on; 6853 * heap,; 6854 * and return allocated buffer. */; 6855static int; 6856alloc_vprintf(char **out_buf,; 6857 char *prealloc_buf,; 6858 size_t prealloc_size,; 6859 const char *fmt,; 6860 va_list ap); 6861{; 6862 va_list ap_copy;; 6863 int len;; 6864 ; 6865 /* Windows is not standard-compliant, and vsnprintf() returns -1 if; 6866 * buffer is too small. Also, older versions of msvcrt.dll do not have; 6867 * _vscprintf(). However, if size is 0, vsnprintf() behaves correctly.; 6868 * Therefore, we make two passes: on first pass, get required message; 6869 * length.; 6870 * On second pass, actually print the message. */; 6871 va_copy(ap_copy, ap);; 6872 len = vsnprintf_impl(NULL, 0, fmt, ap_copy);; 6873 va_end(ap_copy);; 6874 ; 6875 if (len < 0) {; 6876 /* C runtime is not standard compliant, vsnprintf() returned -1.; 6877 * Switch to alternative code path that uses incremental; 6878 * allocations.; 6879 */; 6880 va_copy(ap_copy, ap);; 6881 len = alloc_vprintf2(out_buf, fmt, ap_copy);; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:198177,allocate,allocate,198177,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['allocate'],"['allocate', 'allocated']"
Energy Efficiency," sz); void*TObject::operator new[](size_t sz, void* vp); TMultiDimFit&operator=(const TMultiDimFit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = ""ps"") constMENU ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetBinVarX(Int_t nbbinvarx); voidSetBinVarY(Int_t nbbinvary); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMaxAngle(Double_t angle = 0); voidSetMaxFunctions(Int_t n); voidSetMaxPowers(const Int_t* powers); voidSetMaxStudy(Int_t n); voidSetMaxTerms(Int_t terms); voidSetMinAngle(Double_t angle = 1); voidSetMinRelativeError(Double_t error); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPowerLimit(Double_t limit = 1e-3); virtual voidSetPowers(const Int_t* powers, Int_t terms); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMultiDimFit.html:19900,power,powers,19900,root/html530/TMultiDimFit.html,https://root.cern,https://root.cern/root/html530/TMultiDimFit.html,3,['power'],['powers']
Energy Efficiency," taken by outlining box. Float_t GetWidth() const; Returns width of outlining box. Float_t GetX() const; Returns X coordinate. Float_t GetY() const; Returns Y coordinate. Bool_t IsCollapsed() const; Returns true if node is colllapsed. Bool_t IsSortable() const; Returns true, because we have overrided method Compare. bool IsVisible() const; Returns true if node is visible. void SetAllMembersCount(ULong_t count); Sets numbers of all members to ""number"". void SetCollapsed(Bool_t collapsed); Sets collapsing of node to ""collapse"". void SetHeight(Float_t h); Sets width of outlining box to ""w"". void SetMaxLevel(UInt_t level); Sets maximum number of leves displayed when the node is top node on scene. void SetMaxObjects(UInt_t max); Sets maximum number of objects displayed when the node is top node on scene. void SetMembers(TList* list); Sets list of dauther nodes to ""list"". void SetMembersCount(ULong_t count); Sets number of members to ""number"". void SetNodeType(ENodeType type); Sets type of node to ""type"". void SetPointer(void* pointer); Sets main pointer to ""pointer"". void SetScaleBy(EScalingType type); Sets scaling by to ""type"". void SetSize(ULong_t size); Sets size of node to ""size"". void SetTotalSize(ULong_t size); Sets total size of allocated memory in bytes to value ""size"". void SetVisible(bool visible); Sets visibility of node to ""visible"". void SetWidth(Float_t w); Sets width of outlining box to ""w"". void SetX(Float_t x); Sets X coordinate to ""x"". void SetY(Float_t y); Sets Y coordinate to ""y"". TStructNode(TString name, TString typeName, void* pointer, TStructNode* parent, ULong_t size, ENodeType type). » Author: Tomasz Sosnicki 18/09/09 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/gviz3d:$Id: TStructNode.h 29985 2009-08-31 16:05:21Z brun $ » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TStructNode.html:11785,allocate,allocated,11785,root/html530/TStructNode.html,https://root.cern,https://root.cern/root/html530/TStructNode.html,1,['allocate'],['allocated']
Energy Efficiency," taken by outlining box. Float_t GetWidth() const; Returns width of outlining box. Float_t GetX() const; Returns X coordinate. Float_t GetY() const; Returns Y coordinate. Bool_t IsCollapsed() const; Returns true if node is colllapsed. Bool_t IsSortable() const; Returns true, because we have overrided method Compare. bool IsVisible() const; Returns true if node is visible. void SetAllMembersCount(ULong_t count); Sets numbers of all members to ""number"". void SetCollapsed(Bool_t collapsed); Sets collapsing of node to ""collapse"". void SetHeight(Float_t h); Sets width of outlining box to ""w"". void SetMaxLevel(UInt_t level); Sets maximum number of leves displayed when the node is top node on scene. void SetMaxObjects(UInt_t max); Sets maximum number of objects displayed when the node is top node on scene. void SetMembers(TList* list); Sets list of dauther nodes to ""list"". void SetMembersCount(ULong_t count); Sets number of members to ""number"". void SetNodeType(ENodeType type); Sets type of node to ""type"". void SetPointer(void* pointer); Sets main pointer to ""pointer"". void SetScaleBy(EScalingType type); Sets scaling by to ""type"". void SetSize(ULong_t size); Sets size of node to ""size"". void SetTotalSize(ULong_t size); Sets total size of allocated memory in bytes to value ""size"". void SetVisible(bool visible); Sets visibility of node to ""visible"". void SetWidth(Float_t w); Sets width of outlining box to ""w"". void SetX(Float_t x); Sets X coordinate to ""x"". void SetY(Float_t y); Sets Y coordinate to ""y"". TStructNode(TString name, TString typeName, void* pointer, TStructNode* parent, ULong_t size, ENodeType type). » Author: Tomasz Sosnicki 18/09/09 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/gviz3d:$Id: TStructNode.h 29985 2009-08-31 16:05:21Z brun $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStructNode.html:11785,allocate,allocated,11785,root/html532/TStructNode.html,https://root.cern,https://root.cern/root/html532/TStructNode.html,2,['allocate'],['allocated']
Energy Efficiency," template<typename T > ; T TMath::NormCross (const T v1[3], const T v2[3], T out[3]);  Calculates the Normalized Cross Product of two vectors. ;  ; Double_t TMath::NormQuantile (Double_t p);  Computes quantiles for standard normal distribution N(0, 1) at probability p. ;  ; Bool_t TMath::Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t TMath::Pi ();  \( \pi\) ;  ; constexpr Double_t TMath::PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t TMath::PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t TMath::Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t TMath::PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t TMath::Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ;  ; constexpr Double_t TMath::Qe ();  Elementary charge in \( C \) . ;  ; constexpr Double_t TMath::QeUncertainty ();  Elementary charge uncertainty. ;  ; void TMath::Quantiles (Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7);  Computes sample quantiles, corresponding to the given probabilities. ;  ; Double_t TMath::QuietNaN ();  Returns a quiet NaN as defined by IEEE 754. ;  ; constexpr Double_t TMath::R ();  Universal gas c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h.html:15361,power,power,15361,doc/master/TMath_8h.html,https://root.cern,https://root.cern/doc/master/TMath_8h.html,1,['power'],['power']
Energy Efficiency," texta label . Definition at line 799 of file NeuralNet.h. ◆ drawSample(). virtual void TMVA::DNN::Settings::drawSample ; (; const std::vector< double > & ; , . const std::vector< double > & ; , . const std::vector< double > & ; , . double ;  . ). inlinevirtual . callback for monitoring and logging ; Definition at line 807 of file NeuralNet.h. ◆ dropFractions(). const std::vector< double > & TMVA::DNN::Settings::dropFractions ; (; ); const. inline . Definition at line 762 of file NeuralNet.h. ◆ dropRepetitions(). size_t TMVA::DNN::Settings::dropRepetitions ; (; ); const. inline . Definition at line 761 of file NeuralNet.h. ◆ endTestCycle(). virtual void TMVA::DNN::Settings::endTestCycle ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 805 of file NeuralNet.h. ◆ endTrainCycle(). virtual void TMVA::DNN::Settings::endTrainCycle ; (; double ; ). inlinevirtual . callback for monitoring and logging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 788 of file NeuralNet.h. ◆ exists(). bool TMVA::DNN::Settings::exists ; (; std::string ; histoName). inline . for monitoring ; Definition at line 825 of file NeuralNet.h. ◆ factorWeightDecay(). double TMVA::DNN::Settings::factorWeightDecay ; (; ); const. inline . get the weight-decay factor ; Definition at line 769 of file NeuralNet.h. ◆ hasConverged(). bool TMVA::DNN::Settings::hasConverged ; (; double ; testError). virtual . has this training converged already? ; check for convergence; Definition at line 485 of file NeuralNet.cxx. ◆ learningRate(). double TMVA::DNN::Settings::learningRate ; (; ); const. inline . get the learning rate ; Definition at line 771 of file NeuralNet.h. ◆ maxConvergenceCount(). size_t TMVA::DNN::Settings::maxConvergenceCount ; (; ); const. inline . returns the max convergence count so far ; Definition at line 828 of file NeuralNet.h. ◆ minError(). size_t TMVA::DNN::Settings::minError ; (; ); c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:8362,monitor,monitoring,8362,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['monitor'],['monitoring']
Energy Efficiency," that the function resembles the histogram.; That's fitting.; Fitting in Practice; As often with ROOT, you can use a GUI element (the fit panel, available through the menu in ""Tools"", ""Fit Panel"", or on the prompt (TH1::Fit()). Let's use the fit panel!; First, we draw the distribution of the vertex position along X for all muons. Do that into a histogram that has 20 bins and runs from -10 to +10. Now open the fit panel and click the histogram. We want to fit a Gaussian distribution - and hat's already selected by default. Se just press ""Fit"". Looks good, right?; Fit Parameters; As mentioned before, fitting means finding the optimal set of parameters. In the menu, select ""Options"", ""Fit Parameters"" (and resize the statistics box to make its content readable). You will see the values that the minimizer has found optimal, for instance it chose 1.2 as the mean of the Gaussian and 1.041 as the width.; These values are the crucial ones for physicists: they reduce the large amount of data into just a few parameters, describing the distribution even better than the original histogram. Fitting (or ""parametrization"") is thus a cornerstone of any physics analysis.; . ‹ 3. Examining a TTree's data; up; 6. Multivariate Analysis ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Codi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/5-fitting.html:3444,reduce,reduce,3444,d/5-fitting.html,https://root.cern,https://root.cern/d/5-fitting.html,1,['reduce'],['reduce']
Energy Efficiency," that the matrix has been decomposed.; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; lu.Solve(b,ok);; In the next example, we show again the same decomposition but now performed in a loop and all necessary steps are manually invoked. This example also demonstrates another very important point concerning memory management! Note that the vector, matrix and decomposition class are constructed outside the loop since the dimensions of vector/matrix are constant. If we would have replaced lu.SetMatrix(a) by TDecompLU lu(a), we would construct/deconstruct the array elements of lu on the stack.; TVectorD b(n);; TMatrixD a(n,n);; TDecompLU lu(n);; Bool_t ok;; for (....) {; b = ..;; a = ..;; lu.SetMatrix(a);; lu.Decompose();; lu.Solve(b,ok);; }; 14.6.1 Tolerances and Scaling; The tolerance parameter fTol (a member of the base class TDecompBase) plays a crucial role in all operations of the decomposition classes. It gives the user a tool to monitor and steer the operations its default value is \(\varepsilon\) where \(1+\varepsilon=1\).; If you do not want to be bothered by the following considerations, like in most other linear algebra packages, just set the tolerance with SetTol to an arbitrary small number. The tolerance number is used by each decomposition method to decide whether the matrix is near singular, except of course SVD that can handle singular matrices. This will be checked in a different way for any decomposition. For instance in LU, a matrix is considered singular in the solving stage when a diagonal element of the decomposed matrix is smaller than fTol. Here an important point is raised. The Decompose() method is successful as long no zero diagonal element is encountered. Therefore, the user could perform decomposition and only after this step worry about the tolerance number.; If the matrix is flagged as being singular, operations with the decomposition will fail and will return matrices or vectors that are invalid. If one would like to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:792726,monitor,monitor,792726,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['monitor'],['monitor']
Energy Efficiency," that this function must be called for the class deriving; directly from TObject, eg, assuming that BigTrack derives from Track; and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();. Bool_t InheritsFrom(const char *classname); Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns KTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass *cl); Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClass.html:30855,allocate,allocated,30855,root/html526/TClass.html,https://root.cern,https://root.cern/root/html526/TClass.html,1,['allocate'],['allocated']
Energy Efficiency," the TClonesArray. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. TObject * ConstructedAt(Int_t idx, Option_t* clear_options); Get an object at index 'idx' that is guaranteed to have been constructed.; It might be either a freshly allocated object or one that had already been; allocated (and assumingly used). In the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:19141,allocate,allocate,19141,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,8,['allocate'],['allocate']
Energy Efficiency," the Tree; TTree t2(""t2"",""a Tree with data from a fake Geant3"");; // declare a variable of the C structure type; Gctrak_t gstep;. // add the branches for a subset of gstep; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; t2.Branch(""destep"",&gstep.destep,""destep/F"");; t2.Branch(""pid"",&gstep.pid,""pid/I"");. //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep.step = 0.1;; gstep.destep = 0;; gstep.nmec = 0;; gstep.pid = 0;. //transport particles; for (Int_t i=0; i<10000; i++) {; //generate a new particle if necessary (Geant3 emulation); if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1;; if (gRandom->Rndm() < 0.5) charge = -1;; gstep.pid += 1;; gstep.vect[0] = 0;; gstep.vect[1] = 0;; gstep.vect[2] = 0;; gstep.vect[3] = px/p;; gstep.vect[4] = py/p;; gstep.vect[5] = pz/p;; gstep.vect[6] = p*charge;; gstep.getot = TMath::Sqrt(p*p + mass*mass);; gstep.gekin = gstep.getot - mass;; newParticle = kFALSE;; }; // fill the Tree with current step parameters; t2.Fill();. //transport particle in magnetic field (Geant3 emulation); helixStep(gstep.step, gstep.vect, vout);; //make one step; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.00001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6]= charge*TMath::Sqrt(gstep.getot*gstep.getot; - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0; l<gstep.nmec; l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:563698,charge,charge,563698,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['charge'],['charge']
Energy Efficiency," the actual stage status on selected files. 'process' field:; N, noaction: do nothing on the selected files; P, fullproc: open the selected files and extract the meta information; L, locateonly: only locate the selected files; S, stageonly: issue a stage request for the selected files not yet staged. 'auxiliary' field; V, verbose: notify the actions. Returns 0 on success, -1 if any failure occurs. Int_t ScanDataSet(const char* uri, UInt_t option = kReopen|kDebug); Scans the dataset indicated by <uri> and returns the number of missing files.; Returns -1 if any failure occurs.; For more details, see documentation of; ScanDataSet(TFileCollection *dataset, const char *option). void GetQuota(const char* group, const char* user, const char* dsName, TFileCollection* dataset). Gets quota information from this dataset. void ShowQuota(const char* opt); Display quota information. void PrintUsedSpace(). Prints the quota. void MonitorUsedSpace(TVirtualMonitoringWriter* monitoring). Log info to the monitoring server. Long64_t GetGroupUsed(const char* group). Returns the used space of that group. Long64_t GetGroupQuota(const char* group). returns the quota a group is allowed to have. void UpdateUsedSpace(); updates the used space maps. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings, if needed.; Returns 0 on success, -1 on failure. Int_t NotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); Save into the <datasetdir>/dataset.list file the name of the last updated; or created or modified dataset; Returns 0 on success, -1 on error. Int_t ClearCache(const char* uri); Clear cached information matching uri. Int_t ShowCache(const char* uri); Show cached information matching uri. TString CreateUri(const char* dsGroup = 0, const char* dsUser = 0, const char* dsName = 0, const char* dsTree = 0); Creates URI for the dataset manger in the fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDataSetManager.html:13913,monitor,monitoring,13913,root/html534/TDataSetManager.html,https://root.cern,https://root.cern/root/html534/TDataSetManager.html,2,['monitor'],['monitoring']
Energy Efficiency, the array AND delete all heap based objects. ; Implements TCollection.; Definition at line 356 of file TObjArray.cxx. ◆ Expand(). void TObjArray::Expand ; (; Int_t ; newSize). virtual . Expand or shrink the array to newSize elements. ; Reimplemented in TClonesArray.; Definition at line 387 of file TObjArray.cxx. ◆ FindObject() [1/2]. TObject * TObjArray::FindObject ; (; const char * ; name); const. overridevirtual . Find an object in this collection using its name. ; Requires a sequential scan till the object has been found. Returns 0 if object with specified name is not found. ; Reimplemented from TCollection.; Definition at line 415 of file TObjArray.cxx. ◆ FindObject() [2/2]. TObject * TObjArray::FindObject ; (; const TObject * ; iobj); const. overridevirtual . Find an object in this collection using the object's IsEqual() member function. ; Requires a sequential scan till the object has been found. Returns 0 if object is not found. Typically this function is overridden by a more efficient version in concrete collection classes (e.g. THashTable). ; Reimplemented from TCollection.; Definition at line 434 of file TObjArray.cxx. ◆ First(). TObject * TObjArray::First ; (; ); const. overridevirtual . Return the object in the first slot. ; Implements TSeqCollection.; Definition at line 496 of file TObjArray.cxx. ◆ GetAbsLast(). Int_t TObjArray::GetAbsLast ; (; ); const. protected . Return absolute index to last object in array. ; Returns -1 in case array is empty. ; Definition at line 539 of file TObjArray.cxx. ◆ GetEntries(). Int_t TObjArray::GetEntries ; (; ); const. overridevirtual . Return the number of objects in array (i.e. ; number of non-empty slots). Attention: use this method ONLY if you want to know the number of non-empty slots. This function loops over the complete array and is therefore very slow when applied in a loop. Most of the time you better use GetEntriesFast() (only in case when there are no empty slots). ; Reimplemented from TCollection.; Definit,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObjArray.html:26857,efficient,efficient,26857,doc/master/classTObjArray.html,https://root.cern,https://root.cern/doc/master/classTObjArray.html,1,['efficient'],['efficient']
Energy Efficiency," the bin List since it owns the objects; 198 delete fBins;; 199}; 200 ; 201/////////////////////////////////////////////////////////////////////////////////; 202/// Assignment operator; 203TH2Poly & TH2Poly::operator=(const TH2Poly & rhs) {; 204 if (this != &rhs); 205 rhs.Copy(*this);; 206 return *this;; 207}; 208 ; 209////////////////////////////////////////////////////////////////////////////////; 210/// Copy function for TH2Poly; 211 ; 212void TH2Poly::Copy(TObject &newobj) const; 213{; 214 // copy first TH2 information; 215 TH2::Copy(newobj);; 216 auto & newth2p = dynamic_cast<TH2Poly &>(newobj);; 217 newth2p.SetName(GetName());; 218 newth2p.SetTitle(GetTitle());; 219 ; 220 newth2p.fCellX = fCellX;; 221 newth2p.fCellY = fCellY;; 222 newth2p.fNCells = fNCells;; 223 newth2p.fStepX = fStepX;; 224 newth2p.fStepY = fStepY;; 225 ; 226 // deallocate previous arrays, if existing; 227 delete[] newth2p.fCells;; 228 delete[] newth2p.fIsEmpty;; 229 delete[] newth2p.fCompletelyInside;; 230 // allocate arrays; 231 newth2p.fCells = new TList [fNCells];; 232 newth2p.fIsEmpty = new Bool_t [fNCells]; // Empty partition; 233 newth2p.fCompletelyInside = new Bool_t [fNCells]; // Cell is completely inside bin; 234 // Initializes the flags; 235 for (int i = 0; i<fNCells; i++) {; 236 newth2p.fIsEmpty[i] = fIsEmpty[i];; 237 newth2p.fCompletelyInside[i] = fCompletelyInside[i];; 238 }; 239 // need to use Clone to copy the contained bin list; 240 delete newth2p.fBins; // in case there was something before there; 241 if (!fBins) {; 242 newth2p.fBins = nullptr;; 243 }; 244 else {; 245 newth2p.fBins = dynamic_cast<TList *>(fBins->Clone());; 246 if (!newth2p.fBins); 247 Error(""Copy"",""Error cloning the TH2Poly bin list"");; 248 else {; 249 // add bins in the fCells partition. We need to add the TH2PolyBin objects; 250 // of the new copied histograms. For this we call AddBinToPartition; 251 // we could probably optimize this by implementing a copy of the partition; 252 for (auto bin : *(newth2p.f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2Poly_8cxx_source.html:9357,allocate,allocate,9357,doc/master/TH2Poly_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency," the bin content for each (linear) bin number can; 535be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord).; 536After the call, coord will contain the bin coordinate of each axis for the bin; 537with linear index linidx. A possible call would be; 538 ; 539 std::cout << hs.GetBinContent(0, coord);; 540 std::cout <<"" is the content of bin [x = "" << coord[0] ""; 541 << "" | y = "" << coord[1] << ""]"" << std::endl;; 542 ; 543## Efficiency; 544TH1 and TH2 are generally faster than THnSparse for one and two dimensional; 545distributions. THnSparse becomes competitive for a sparsely filled TH3; 546with large numbers of bins per dimension. The tutorial sparsehist.C; 547shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; 548starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; 549one-dimensional histogram is only reasonable if it has a huge number of bins.; 550 ; 551## Projections; 552The dimensionality of a THnSparse can be reduced by projecting it to; 5531, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; 554a THnSparse. See the Projection() members. To only project parts of the; 555histogram, call; 556 ; 557 THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);; 558 ; 559## Internal Representation; 560An entry for a filled bin consists of its n-dimensional coordinates and; 561its bin content. The coordinates are compacted to use as few bits as; 562possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; 563use 4 bits for the x representation and 5 bits for the y representation.; 564This is handled by the internal class THnSparseCompactBinCoord.; 565Bin data (content and coordinates) are allocated in chunks of size; 566fChunkSize; this parameter can be set when constructing a THnSparse. Each; 567chunk is represented by an object of class THnSparseArrayChunk.; 568 ; 569Translation from an n-dimensional bin coordinate to the linear index within; 570the chunks is done by GetBin(). It creates a ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:20415,reduce,reduced,20415,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['reduce'],['reduced']
Energy Efficiency," the common abstract base class for objects that represent a real value that may appear on the left hand side of an equation ('lvalue') ;  CRooAbsRootFinderRooAbsRootFinder is the abstract interface for finding roots of real-valued 1-dimensional function that implements the RooAbsFunc interface ;  CRooAbsSelfCachedPdfRooAbsSelfCachedPdf is an abstract base class for probability density functions whose output is cached in terms of a histogram in all observables between getVal() and evaluate() ;  CRooAbsSelfCachedRealRooAbsSelfCachedReal is an abstract base class for functions whose output is cached in terms of a histogram in all observables between getVal() and evaluate() ;  CRooAbsStringRooAbsString is the common abstract base class for objects that represent a string value ;  CRooAbsStudyRooAbsStudy is an abstract base class for RooStudyManager modules ;  CRooAbsTestStatisticRooAbsTestStatistic is the abstract base class for all test statistics ;  CRooAcceptRejectClass RooAcceptReject is a generic toy monte carlo generator implement the accept/reject sampling technique on any positively valued function ;  CRooAdaptiveGaussKronrodIntegrator1DRooAdaptiveGaussKronrodIntegrator1D implements the Gauss-Kronrod integration algorithm ;  CRooAdaptiveIntegratorNDRooAdaptiveIntegratorND implements an adaptive one-dimensional numerical integration algorithm ;  CRooAddGenContextRooAddGenContext is an efficient implementation of the generator context specific for RooAddPdf PDFs ;  ►CRooAdditionRooAddition calculates the sum of a set of RooAbsReal terms, or when constructed with two sets, it sums the product of the terms in the two sets ;  CCacheElemIterator over set ;  ►CRooAddModel;  CCacheElemTransiet cache with transformed values of coefficients ;  CIntCacheElem;  ►CRooAddPdfRooAddPdf is an efficient implementation of a sum of PDFs of the form ;  CCacheElemTransiet cache with transformed values of coefficients ;  CRooAICRegistryRooAICRegistry is a utility class for operator p.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:103353,adapt,adaptive,103353,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,3,"['adapt', 'efficient']","['adaptive', 'efficient']"
Energy Efficiency," the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static Long64_t BinarySearch (Long64_t n, const TGeoBranchArray **array, TGeoBranchArray *value);  Binary search in an array of n pointers to branch arrays, to locate value. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TGeoBranchArray * MakeCopy (const TGeoBranchArray &other);  Make a copy of a branch array at the location (if indicated) ;  ; static TGeoBranchArray * MakeCopyAt (const TGeoBranchArray &other, void *addr);  Make a copy of a branch array at the location (if indicated) ;  ; static TGeoBranchArray * MakeInstance (size_t maxlevel);  Make an instance of the class which allocates the node array. ;  ; static TGeoBranchArray * MakeInstanceAt (size_t maxlevel, void *addr);  Make an instance of the class which allocates the node array. ;  ; static void ReleaseInstance (TGeoBranchArray *obj);  Releases the space allocated for the object. ;  ; static size_t SizeOf (size_t maxlevel);  ; static size_t SizeOfInstance (size_t maxlevel);  ; static void Sort (Int_t n, TGeoBranchArray **array, Int_t *index, Bool_t down=kTRUE);  Sorting of an array of branch array pointers. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; TGeoNode ** fArray;  ; Int_t fLevel;  ; TGeoHMatri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBranchArray.html:12359,allocate,allocates,12359,doc/master/classTGeoBranchArray.html,https://root.cern,https://root.cern/doc/master/classTGeoBranchArray.html,1,['allocate'],['allocates']
Energy Efficiency," the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t *&b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t *&c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t *&h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t *&ii); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t *&ll); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t *&ll); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t *&f); Read array of floats from the I/O buffer. Returns the number of floats; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Double_t *&d); Read array of doubles from the I/O buffer. Returns the number of doubles; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArrayFloat16(Float_t*& f, TStreamerElement* ele = 0); Read array of floats (written as truncated float) from the I/O buffer.; Returns the number of floats read.; If argument is a 0 pointer then space will be allocated for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferFile.html:26018,allocate,allocated,26018,root/html526/TBufferFile.html,https://root.cern,https://root.cern/root/html526/TBufferFile.html,1,['allocate'],['allocated']
Energy Efficiency," the first, second, or third order derivative of any RooAbsReal as calculated (numerically) by the MathCore Richardson derivator class ;  CRooSegmentedIntegrator1DRooSegmentedIntegrator1D implements an adaptive one-dimensional numerical integration algorithm ;  CRooSegmentedIntegrator2DRooSegmentedIntegrator2D implements an adaptive one-dimensional numerical integration algorithm ;  CRooSentinelRooSentinel is a special purposes singleton class that terminates all other RooFit singleton services when the process exists ;  CRooSetPairRooSetPair is a utility class that stores a pair of RooArgSets ;  CRooSetProxyRooSetProxy is the concrete proxy for RooArgSet objects ;  CRooSharedPropertiesClass RooSharedProperties is the base class for shared properties that can be stored in RooSharedPropertiesList ;  CRooSharedPropertiesListClass RooSharedPropertiesList maintains the properties of RooRealVars and RooCategories that are clones of each other ;  CRooSimGenContextRooSimGenContext is an efficient implementation of the generator context specific for RooSimultaneous PDFs when generating more than one of the component pdfs ;  CRooSimPdfBuilder;  CRooSimSplitGenContextRooSimSplitGenContext is an efficient implementation of the generator context specific for RooSimultaneous PDFs when generating more than one of the component pdfs ;  ►CRooSimultaneousRooSimultaneous facilitates simultaneous fitting of multiple PDFs to subsets of a given dataset ;  CCacheElem;  ►CRooSimWSTool;  CBuildConfig;  CMultiBuildConfig;  CObjBuildConfig;  CObjSplitRule;  CSimWSIFace;  CSplitRule;  CRooSpHarmonicImplementation of the so-called real spherical harmonics, using the orthonormal normalization, which are related to spherical harmonics as: ;  CRooStepFunctionThe Step Function is a binned function whose parameters are the heights of each bin ;  CRooStreamParser;  CRooStringVarRooStringVar implements a string values RooAbsArg ;  CRooStudyManagerRooStudyManager is a utility class to manage studies t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:128033,efficient,efficient,128033,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['efficient'],['efficient']
Energy Efficiency," the function range ??); 140 // to check if inclusion/exclusion at end/point; 141 const DataRange & range = dv.Range();; 142 if (range.Size(0) != 0) {; 143 HFitInterface::ExamineRange( hfit->GetXaxis(), range(0), hxfirst, hxlast);; 144 if (range.Size(0) > 1 ) {; 145 Warning(""ROOT::Fit::FillData"",""support only one range interval for X coordinate"");; 146 }; 147 }; 148 ; 149 if (hfit->GetDimension() > 1 && range.Size(1) != 0) {; 150 HFitInterface::ExamineRange( hfit->GetYaxis(), range(1), hyfirst, hylast);; 151 if (range.Size(1) > 1 ); 152 Warning(""ROOT::Fit::FillData"",""support only one range interval for Y coordinate"");; 153 }; 154 ; 155 if (hfit->GetDimension() > 2 && range.Size(2) != 0) {; 156 HFitInterface::ExamineRange( hfit->GetZaxis(), range(2), hzfirst, hzlast);; 157 if (range.Size(2) > 1 ); 158 Warning(""ROOT::Fit::FillData"",""support only one range interval for Z coordinate"");; 159 }; 160 ; 161 ; 162 int n = (hxlast-hxfirst+1)*(hylast-hyfirst+1)*(hzlast-hzfirst+1);; 163 ; 164#ifdef DEBUG; 165 std::cout << ""THFitInterface: ifirst = "" << hxfirst << "" ilast = "" << hxlast; 166 << "" total bins "" << n; 167 << std::endl;; 168#endif; 169 ; 170 // reserve n for more efficient usage; 171 //dv.Data().reserve(n);; 172 ; 173 int hdim = hfit->GetDimension();; 174 int ndim = hdim;; 175 // case of function dimension less than histogram; 176 if (func !=nullptr && func->GetNdim() == hdim-1) ndim = hdim-1;; 177 ; 178 assert( ndim > 0 );; 179 //typedef BinPoint::CoordData CoordData;; 180 //CoordData x = CoordData( hfit->GetDimension() );; 181 dv.Initialize(n,ndim, (fitOpt.fErrors1) ? ROOT::Fit::BinData::kNoError : ROOT::Fit::BinData::kValueError);; 182 ; 183 double x[3];; 184 double s[3];; 185 ; 186 int binx = 0;; 187 int biny = 0;; 188 int binz = 0;; 189 ; 190 const TAxis *xaxis = hfit->GetXaxis();; 191 const TAxis *yaxis = hfit->GetYaxis();; 192 const TAxis *zaxis = hfit->GetZaxis();; 193 ; 194 for ( binx = hxfirst; binx <= hxlast; ++binx) {; 195 if (useBinEdges) {; 196 x[0] = x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitInterface_8cxx_source.html:6042,efficient,efficient,6042,doc/master/HFitInterface_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitInterface_8cxx_source.html,1,['efficient'],['efficient']
Energy Efficiency," the kObject and kAny types to support; 5360 // the (unwise) choice of inheriting from an STL container.; 5361 fObject = fAddress;; 5362 } else {; 5363 // We are either a top-level branch or subbranch which is a pointer to an STL container.; 5364 // Streamer type should be -1 (for a top-level branch) or kSTLp here.; 5365 if ((fStreamerType != -1) && (fStreamerType != TVirtualStreamerInfo::kSTLp)) {; 5366 Error(""SetAddress"",; 5367 ""Branch %s is a split STL container (fStreamerType is: %d), the address can not be set directly."",; 5368 GetName(), fStreamerType);; 5369 } else if (fStreamerType == -1) {; 5370 // -- We are a top-level branch.; 5371 void** pp = (void**) fAddress;; 5372 if (!*pp) {; 5373 // -- Caller wants us to allocate the STL container, but they will own it.; 5374 *pp = proxy->New();; 5375 if (!(*pp)) {; 5376 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5377 // FIXME: Should we do this? Lots of other code wants; 5378 // fAddress to be zero if no fObject, but is; 5379 // that a good thing?; 5380 fAddress = nullptr;; 5381 ResetBit(kAddressSet);; 5382 }; 5383 }; 5384 fObject = (char*) *pp;; 5385 } else {; 5386 // -- We are a pointer to an STL container.; 5387 // Note: We do this so that the default constructor,; 5388 // or the i/o constructor can be lazy.; 5389 void** pp = (void**) fAddress;; 5390 if (!*pp) {; 5391 // -- Caller wants us to allocate the STL container, but they will own it.; 5392 *pp = proxy->New();; 5393 if (!(*pp)) {; 5394 Error(""SetAddress"", ""Failed to allocate STL container for branch '%s'"", GetName());; 5395 // FIXME: Should we do this? Lots of other code wants; 5396 // fAddress to be zero if no fObject, but is; 5397 // that a good thing?; 5398 fAddress = nullptr;; 5399 ResetBit(kAddressSet);; 5400 }; 5401 }; 5402 fObject = (char*) *pp;; 5403 }; 5404 }; 5405 } else {; 5406 // -- We have been given a zero address, allocate for top-level only.; 5407 if ((fStreamerType == TVirtualStreamerInfo::kObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:199515,allocate,allocate,199515,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency," the kd-tree don't require the original data to be present after the tree; has been built. Check the functions documentation for more details. 3b. Navigating the kd-tree. Nodes of the tree are indexed top to bottom, left to right. The root node has index 0. Functions; TKDTree::GetLeft(Index inode), TKDTree::GetRight(Index inode) and TKDTree::GetParent(Index inode); allow to find the children and the parent of a given node. For a given node, one can find the indexes of the original points, contained in this node,; by calling the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; fAxix[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value. Given the index of a node in those arrays, it's easy to find the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKDTree_int_double_.html:6589,consumption,consumption,6589,root/html528/TKDTree_int_double_.html,https://root.cern,https://root.cern/root/html528/TKDTree_int_double_.html,20,['consumption'],['consumption']
Energy Efficiency," the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * FindObject(const TObject* key) const; Check if a (key,value) pair exists with key as key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * GetValue(const char* keyname) const; Returns a pointer to the value associated with keyname as name of the key. TObject * GetValue(const TObject* key) const; R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMap.html:10054,allocate,allocated,10054,root/html528/TMap.html,https://root.cern,https://root.cern/root/html528/TMap.html,10,['allocate'],['allocated']
Energy Efficiency," the new quantity is defined.; The old value of the column can be used as an input for the expression. An exception is thrown in case the column to re-define does not already exist.; See DefineSlotEntry() for more information. ; Definition at line 598 of file RInterface.hxx. ◆ Reduce() [1/2]. template<typename Proxied , typename DataSource = void> . template<typename F , typename T = typename TTraits::CallableTraits<F>::ret_type> . RResultPtr< T > ROOT::RDF::RInterface< Proxied, DataSource >::Reduce ; (; F ; f, . std::string_view ; columnName, . const T & ; redIdentity . ). inline . Execute a user-defined reduce operation on the values of a column. ; Template Parameters. FThe type of the reduce callable. Automatically deduced. ; TThe type of the column to apply the reduction to. Automatically deduced. . Parameters. [in]fA callable with signature T(T,T) ; [in]columnNameThe column to be reduced. If omitted, the first default column is used instead. ; [in]redIdentityThe reduced object of each thread is initialized to this value. . Returnsthe reduced quantity wrapped in a RResultPtr. Example usage:; auto sumOfIntColWithOffset = d.Reduce([](int x, int y) { return x + y; }, ""intCol"", 42);; See the description of the first Reduce overload for more information. ; Definition at line 1711 of file RInterface.hxx. ◆ Reduce() [2/2]. template<typename Proxied , typename DataSource = void> . template<typename F , typename T = typename TTraits::CallableTraits<F>::ret_type> . RResultPtr< T > ROOT::RDF::RInterface< Proxied, DataSource >::Reduce ; (; F ; f, . std::string_view ; columnName = """" . ). inline . Execute a user-defined reduce operation on the values of a column. ; Template Parameters. FThe type of the reduce callable. Automatically deduced. ; TThe type of the column to apply the reduction to. Automatically deduced. . Parameters. [in]fA callable with signature T(T,T) ; [in]columnNameThe column to be reduced. If omitted, the first default column is used instead. . Returnsthe r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:119694,reduce,reduced,119694,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['reduce'],['reduced']
Energy Efficiency," the notation with 10^N ...Definition TStyle.cxx:1880; TStyle::GetGridWidthWidth_t GetGridWidth() constDefinition TStyle.h:224; TStyle::GetStripDecimalsInt_t GetStripDecimals() constDefinition TStyle.h:268; TStyle::GetExponentOffsetvoid GetExponentOffset(Float_t &xoff, Float_t &yoff, Option_t *axis=""X"") constMethod returns X and Y offset of the axis 10^n notation.Definition TStyle.cxx:1855; TText::SetTextvirtual void SetText(Double_t x, Double_t y, const char *text)Definition TText.h:74; TTimeStamp::MktimeFromUTCstatic time_t MktimeFromUTC(tm_t *tmstruct)Equivalent of standard routine ""mktime"" but using the assumption that tm struct is filled with UTC,...Definition TTimeStamp.cxx:768; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; v@ vDefinition rootcling_impl.cxx:3699; lTLine lDefinition textangle.C:4. graf2dgrafsrcTGaxis.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGaxis_8cxx_source.html:130361,power,power,130361,doc/master/TGaxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html,1,['power'],['power']
Energy Efficiency, the number of characters read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer.; Definition at line 758 of file TBufferFile.cxx. ◆ ReadArray() [3/13]. Int_t TBufferFile::ReadArray ; (; Double_t *& ; d). overridevirtual . Read array of doubles from the I/O buffer. ; Returns the number of doubles read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer.; Definition at line 934 of file TBufferFile.cxx. ◆ ReadArray() [4/13]. Int_t TBufferFile::ReadArray ; (; Float_t *& ; f). overridevirtual . Read array of floats from the I/O buffer. ; Returns the number of floats read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer.; Definition at line 901 of file TBufferFile.cxx. ◆ ReadArray() [5/13]. Int_t TBufferFile::ReadArray ; (; Int_t *& ; ii). overridevirtual . Read array of ints from the I/O buffer. ; Returns the number of ints read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer.; Definition at line 814 of file TBufferFile.cxx. ◆ ReadArray() [6/13]. Int_t TBufferFile::ReadArray ; (; Long64_t *& ; ll). overridevirtual . Read array of long longs from the I/O buffer. ; Returns the number of long longs read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer.; Definition at line 873 of file TBufferFile.cxx. ◆ ReadArray() [7/13]. Int_t TBufferFile::ReadArray ; (; Long_t *& ; ll). overridevirtual . Read array of longs from the I/O buffer. ; Returns the number of longs read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer.; Definition at line 847 of file TBufferFile.cxx. ◆ ReadArray() [8/13]. Int_t TBufferFile::ReadArray ; (; Short_t *& ; h). overridevirtual . Read array of shorts from the I/O buffer. ; Returns the number of shorts read. If argument is a 0 pointer then space will be allocated for the array. ; Implements TBuffer,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:47414,allocate,allocated,47414,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['allocate'],['allocated']
Energy Efficiency," the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionMultiDim::BaseGrad. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IGradientMultiDim.html:1881,efficient,efficient,1881,root/html528/ROOT__Math__IGradientMultiDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IGradientMultiDim.html,2,['efficient'],['efficient']
Energy Efficiency," the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionMultiDim::BaseGrad. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__IGradientMultiDim.html:1883,efficient,efficient,1883,root/html530/ROOT__Math__IGradientMultiDim.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__IGradientMultiDim.html,2,['efficient'],['efficient']
Energy Efficiency," the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionMultiDim::BaseGrad. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IGradientMultiDim.html:1883,efficient,efficient,1883,root/html532/ROOT__Math__IGradientMultiDim.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IGradientMultiDim.html,4,['efficient'],['efficient']
Energy Efficiency," the remoteName with a '-'. ; Definition at line 233 of file TFTP.cxx. ◆ pwd(). void TFTP::pwd ; (; ); const. inline . Definition at line 117 of file TFTP.h. ◆ Recv(). Int_t TFTP::Recv ; (; Int_t & ; status, . EMessageTypes & ; kind . ); const. private . Return status from rootd server and message kind. ; Returns -1 in case of error otherwise 8 (sizeof 2 words, status and kind). ; Definition at line 191 of file TFTP.cxx. ◆ RenameFile(). Int_t TFTP::RenameFile ; (; const char * ; file1, . const char * ; file2 . ); const. Rename a remote file. ; Anonymous users may not rename files. Returns 0 in case of success and -1 in case of failure. ; Definition at line 790 of file TFTP.cxx. ◆ rm(). void TFTP::rm ; (; const char * ; file); const. inline . Definition at line 119 of file TFTP.h. ◆ rmdir(). void TFTP::rmdir ; (; const char * ; dir); const. inline . Definition at line 115 of file TFTP.h. ◆ SetBlockSize(). void TFTP::SetBlockSize ; (; Int_t ; blockSize). Make sure the block size is a power of two, with a minimum of 32768. ; Definition at line 207 of file TFTP.cxx. ◆ SetMode(). void TFTP::SetMode ; (; Int_t ; mode). inlineprivate . Definition at line 62 of file TFTP.h. ◆ SetRestartAt(). void TFTP::SetRestartAt ; (; Long64_t ; at). inline . Definition at line 81 of file TFTP.h. ◆ Streamer(). void TFTP::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TFTP::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 125 of file TFTP.h. Member Data Documentation. ◆ fBlockSize. Int_t TFTP::fBlockSize. private . Definition at line 44 of file TFTP.h. ◆ fBytesRead. Long64_t TFTP::fBytesRead. private . Definition at line 50 of file TFTP.h. ◆ fBytesWrite. Long64_t TFTP::fBytesWrite. private . connection to rootd ; Definition at line 49 of file TFTP.h. ◆ fCurrentFile. TString TFTP::fCurrentFile. private . Definition at line 47 of file TFTP.h. ◆ fDir. Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFTP.html:23482,power,power,23482,doc/master/classTFTP.html,https://root.cern,https://root.cern/doc/master/classTFTP.html,1,['power'],['power']
Energy Efficiency," the same as ""glbox"", but spheres are drawn instead of boxes.; ; TH3 as iso-surface(s) - (TGLIsoPainter); The supported option is:; ; ""GLISO"" : TH3 is drawn using iso-surfaces.; ; TF3 (implicit function) - (TGLTF3Painter); The supported option is:; ; ""GLTF3"" : Draw a TF3.; ; Parametric surfaces - (TGLParametricPlot); $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric equations and; visualize the surface. Interaction with the plots. General information. All the interactions are implemented via standard methods DistancetoPrimitive and; ExecuteEvent. That's why all the interactions with the OpenGL plots are possible i; only when the mouse cursor is in the plot's area (the plot's area is the part of a the pad; occupied by gl-produced picture). If the mouse cursor is not above gl-picture,; the standard pad interaction is performed.; Selectable parts. Different parts of the plot can be selected:; ; xoz, yoz, xoy back planes:; When such a plane selected, it's highlighted in green if the dynamic slicing; by this plane is supported, and it's highlighted in red, if the dynamic slicing; is not supported.; The plot itself:; On surfaces, the selected surface is outlined in red. (TF3 and ISO are not; outlined). On lego plots, the selected bin is highlihted. The bin number and content are displayed in pad's status; bar. In box plots, the box or sphere is highlighted and the bin info is displayed in pad's status bar.; ; Rotation and zooming. Rotation:; ; When the plot is selected, it can be rotated by pressing and holding the left mouse button and move the cursor.; Zoom/Unzoom:; ; Mouse wheel or 'j', 'J', 'k', 'K' keys.; ; Panning. The selected plot can be moved in a pad's area by; pressing and holding the left mouse button and the shift key. Box cut; Surface, iso, box, TF3 and parametric painters support box cut by pressing the 'c' or; 'C' key when the mouse cursor is in a plot's area. That will display a transparent box,; cutting away part of the surface (or boxes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLHistPainter.html:2978,green,green,2978,root/html528/TGLHistPainter.html,https://root.cern,https://root.cern/root/html528/TGLHistPainter.html,1,['green'],['green']
Energy Efficiency," the screen; mode = 1 the box looks as it is in front of the screen; border is the border size in already pre-computed dark is the; color for the dark part of the frame light is the color for the light; part of the frame. void DrawPolyMarker(Int_t n, Float_t* x, Float_t* y); not used. void DrawPolyMarker(Int_t n, Double_t* x, Double_t* y); draw polymarker. void DrawPS(Int_t n, Double_t* xw, Double_t* yw); This function defines a path with xw and yw and draw it according the; value of nn:. If nn > 0 a line is drawn.; If nn < 0 a closed polygon is drawn. void DrawPS(Int_t n, Float_t* xw, Float_t* yw); not used. void DrawDashPolyLine(Int_t npoints, TPoint* pt, UInt_t nDash, const char* pDash, const char* col, UInt_t thick); draw dashed polyline. void NewPage(); new page. void Text(Double_t x, Double_t y, const char* string); Draw text. x: x position of the text; y: y position of the text. void Text(Double_t x, Double_t y, const wchar_t* string); Draw text. x: x position of the text; y: y position of the text. void CellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); cell array begin. void CellArrayFill(Int_t r, Int_t g, Int_t b); Cell array fill. void CellArrayEnd(); Cell array end. void SetColor(Float_t r, Float_t g, Float_t b); Set color with its R G B components. r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1]. Int_t XtoPixel(Double_t x); x to pixel. Int_t YtoPixel(Double_t y); y to pixel. TImageDump(). void * GetStream() const; { return (void*)fImage; }. void SetType(Int_t type = -111); { fType = type; }. Int_t GetType() const; { return fType; }. TImage * GetImage() const; { return fImage; }. » Author: Valeriy Onuchin 29/04/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/postscript:$Id$ » Last generated: 2015-06-02 16:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TImageDump.html:13827,green,green,13827,root/html604/TImageDump.html,https://root.cern,https://root.cern/root/html604/TImageDump.html,2,['green'],['green']
Energy Efficiency," the screen; mode = 1 the box looks as it is in front of the screen; border is the border size in already pre-computed dark is the; color for the dark part of the frame light is the color for the light; part of the frame. void DrawPolyMarker(Int_t n, Float_t* x, Float_t* y); not used. void DrawPolyMarker(Int_t n, Double_t* x, Double_t* y); draw polymarker. void DrawPS(Int_t n, Double_t* xw, Double_t* yw); This function defines a path with xw and yw and draw it according the; value of nn:. If nn > 0 a line is drawn.; If nn < 0 a closed polygon is drawn. void DrawPS(Int_t n, Float_t* xw, Float_t* yw); not used. void DrawDashPolyLine(Int_t npoints, TPoint* pt, UInt_t nDash, const char* pDash, const char* col, UInt_t thick); draw dashed polyline. void NewPage(); new page. void Text(Double_t x, Double_t y, const char* string); Draw text. x: x position of the text; y: y position of the text. void Text(Double_t x, Double_t y, const wchar_t* string); Draw text. x: x position of the text; y: y position of the text. void CellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); cell array begin. void CellArrayFill(Int_t r, Int_t g, Int_t b); Cell array fill. void CellArrayEnd(); Cell array end. void SetColor(Float_t r, Float_t g, Float_t b); Set color with its R G B components. r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1]. Int_t XtoPixel(Double_t x); x to pixel. Int_t YtoPixel(Double_t y); y to pixel. TImageDump(). void * GetStream() const; { return (void*)fImage; }. void SetType(Int_t type = -111); { fType = type; }. Int_t GetType() const; { return fType; }. TImage * GetImage() const; { return fImage; }. » Author: Valeriy Onuchin 29/04/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/postscript:$Id$ » Last generated: 2015-06-30 15:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TImageDump.html:13827,green,green,13827,root/html602/TImageDump.html,https://root.cern,https://root.cern/root/html602/TImageDump.html,2,['green'],['green']
Energy Efficiency," the specified year, month,; day, time, hour, minute, second and nanosec.; If !isUTC then it is assumed to be the standard local time zone. If local time is PST then one can use; TTimeStamp(year,month,day,hour,min,sec,nsec,kFALSE,0);; or; Int_t secOffset = 8*60*60;; TTimeStamp(year,month,day,hour,min,sec,nsec,kTRUE,8*60*60);. TTimeStamp(UInt_t date, UInt_t time, UInt_t nsec, Bool_t isUTC = kTRUE, Int_t secOffset = 0); Create a TTimeStamp and set it to the specified date, time, nanosec.; If !isUTC then it is assumed to be the standard local time zone. TTimeStamp(UInt_t tloc, Bool_t isUTC = kTRUE, Int_t secOffset = 0, Bool_t dosDate = kFALSE); Create a TTimeStamp and set it to tloc which must be a time_t value; returned by time(). This value is the number of seconds since the EPOCH; (i.e. 00:00:00 on Jan 1m 1970). If dosDate is true then the input; is a dosDate value. const Char_t * AsString(const Option_t* option = """") const; Return the date & time as a string. Result is pointer to a statically allocated string.; User should copy this into their own buffer before calling; this method again. Option ""l"" returns it in local zone format; (can be applied to default or compact format). Default format is RFC822 compliant:; ""Mon, 02 Jan 2001 18:11:12 +0000 (GMT) +999999999 nsec""; ""Mon, 02 Jan 2001 10:11:12 -0800 (PST) +999999999 nsec"". Option ""c"" compact is (almost) ISO 8601 compliant:; ""2001-01-02 18:11:12.9999999999Z""; ""2001-01-02 10:11:12.9999999999-0800"" if PST; * uses ""-"" as date separator as specified in ISO 8601; * uses ""."" rather than preferred "","" for decimal separator; * -HHMM is the difference between local and UTC (if behind, + if ahead).; The ""-HHMM"" is replaced with ""Z"" if given as UTC.; To be strictly conforming it should use ""T"" instead of the; blank separating the date and time. Option ""2"" returns as {sec,nsec} integers. Option ""s"" returns ""2001-01-02 18:11:12"" with an implied UTC,; overrides ""l"" option. Internally uses a circular list of buffers to avoid pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTimeStamp.html:4972,allocate,allocated,4972,root/html602/TTimeStamp.html,https://root.cern,https://root.cern/root/html602/TTimeStamp.html,2,['allocate'],['allocated']
Energy Efficiency," the table; return; - the new table size (# of table rows); - 0 if the object doesn't own the internal array and can not expand it. Long_t InsertRows(const void* rows, Long_t indx, UInt_t nRows = 1); void InsertRows(cons void *row, Long_t indx, UInt_t nRows). Insert one or several rows into the table at ""indx"" position; The rest table stuff is shifted down. cons void - a pointer to the array of rows to be inserted; Long_t indx = The position these rows will be inserted to; Int_t nRows - the total number of rows to be inserted; = 1 ""by default; return:; The number of the rows has been shifted to accomodate; the new rows. void * ReAllocate(); Reallocate this table leaving only (used rows)+1 allocated; GetTableSize() = GetNRows() + 1; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void * ReAllocate(Int_t newsize); Reallocate this table leaving only <newsize> allocated; GetTableSize() = newsize;; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void ReAlloc(Int_t newsize); The table is reallocated if it is an owner of the internal array. Char_t * Create(); Allocate a space for the new table, if any; Sleep for a while if space is not available and try again. void Browse(TBrowser* b); Wrap each table coulumn with TColumnView object to browse. void Clear(Option_t* opt = """"); Deletes the internal array of this class; if this object does own its internal table. void Delete(Option_t* opt = """"). Delete the internal array and free the memory it occupied; if this object did own this array. Then perform TDataSet::Delete(opt). TClass * GetRowClass() const; to be documented. Long_t GetNRows() const; Returns the number of the used rows for the wrapped table. Long_t GetRowSize() const; Returns the size (in bytes) of one table row. Long_t GetTableSize() const; Returns the number of the allocated rows. void Fit(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTable.html:26788,allocate,allocated,26788,root/html528/TTable.html,https://root.cern,https://root.cern/root/html528/TTable.html,10,['allocate'],['allocated']
Energy Efficiency," the testSample for the monitoring plots; during the training .. but using the testing events. Double_t AdaBoost(vector<TMVA::Event*> , TMVA::DecisionTree* dt); the AdaBoost implementation.; a new training sample is generated by weighting; events that are misclassified by the decision tree. The weight; applied is w = (1-err)/err or more general:; w = ((1-err)/err)^beta; where err is the fraction of misclassified events in the tree ( <0.5 assuming; demanding the that previous selection was better than random guessing); and ""beta"" being a free parameter (standard: beta = 1) that modifies the; boosting. Double_t Bagging(vector<TMVA::Event*> , Int_t iTree); call it boot-strapping, re-sampling or whatever you like, in the end it is nothing; else but applying ""random"" weights to each event. Double_t RegBoost(vector<TMVA::Event*> , TMVA::DecisionTree* dt); a special boosting only for Regression ...; maybe I'll implement it later... Double_t AdaBoostR2(vector<TMVA::Event*> , TMVA::DecisionTree* dt); adaption of the AdaBoost to regression problems (see H.Drucker 1997). void AddWeightsXMLTo(void* parent) const; write weights to XML. void ReadWeightsFromXML(void* parent); reads the BDT from the xml file. void ReadWeightsFromStream(istream& istr); read the weights (BDT coefficients). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0). Double_t GetMvaValue(Double_t* err, Double_t* errUpper, UInt_t useNTrees); Return the MVA value (range [-1;1]) that classifies the; event according to the majority vote from the total number of; decision trees. Double_t PrivateGetMvaValue(TMVA::Event& ev, Double_t* err = 0, Double_t* errUpper = 0, UInt_t useNTrees = 0); Return the MVA value (range [-1;1]) that classifies the; event according to the majority vote from the total number of; decision trees. const std::vector<Float_t>& GetMulticlassValues(); get the multiclass MVA response for the BDT classifier. const std::vector<Float_t> & GetRegressionValues(); get the regression value ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodBDT.html:32146,adapt,adaption,32146,root/html530/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodBDT.html,3,['adapt'],['adaption']
Energy Efficiency," this case m2 must always be less than P2 to preserve a positive value of E2 Phi is restricted to be in the range [-PI,PI); See alsoOverview of the physics vector library ; Definition at line 54 of file PtEtaPhiM4D.h. Public Types; typedef ScalarType Scalar;  . Public Member Functions;  PtEtaPhiM4D ();  Default constructor gives zero 4-vector (with zero mass) ;  ; template<class CoordSystem > ; constexpr PtEtaPhiM4D (const CoordSystem &c);  Generic constructor from any 4D coordinate system implementing Pt(), Eta(), Phi() and M() ;  ;  PtEtaPhiM4D (const PtEtaPhiM4D &v);  copy constructor ;  ;  PtEtaPhiM4D (Scalar pt, Scalar eta, Scalar phi, Scalar mass);  Constructor from pt, eta, phi, mass values. ;  ; Scalar E () const;  Energy (timelike component of momentum-energy 4-vector) ;  ; Scalar E2 () const;  energy squared ;  ; Scalar Et () const;  transverse energy ;  ; Scalar Et2 () const;  transverse energy squared ;  ; Scalar Eta () const;  ; void GetCoordinates (Scalar &pt, Scalar &eta, Scalar &phi, Scalar &mass) const;  get internal data into 4 Scalar numbers ;  ; void GetCoordinates (Scalar dest[]) const;  get internal data into an array of 4 Scalar numbers ;  ; Scalar M () const;  M() is the invariant mass; in this coordinate system it can be negagative if set that way. ;  ; Scalar M2 () const;  vector magnitude squared (or mass squared) In case of negative mass (spacelike particles return negative values) ;  ; Scalar Mag () const;  ; Scalar Mag2 () const;  ; Scalar Mt () const;  transverse mass - will be negative if Mt2() is negative ;  ; Scalar Mt2 () const;  transverse mass squared ;  ; void Negate ();  negate the 4-vector – Note that the energy cannot be negate (would need an additional data member) therefore negate will work only on the spatial components One would need to use negate only with vectors having the energy as data members ;  ; bool operator!= (const PtEtaPhiM4D &rhs) const;  ; template<class CoordSystem > ; PtEtaPhiM4D & operator= (const CoordSy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1PtEtaPhiM4D.html:1478,energy,energy,1478,doc/master/classROOT_1_1Math_1_1PtEtaPhiM4D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1PtEtaPhiM4D.html,4,['energy'],['energy']
Energy Efficiency," this class is currently in the a process's memory. ;  ; Bool_t IsStartingWithTObject () const;  Returns true if this class inherits from TObject and if the start of the TObject parts is at the very beginning of the objects. ;  ; Bool_t IsSyntheticPair () const;  ; Bool_t IsTObject () const;  Return kTRUE is the class inherits from TObject. ;  ; Bool_t IsVersioned () const;  ; void ls (Option_t *opt="""") const override;  The ls function lists the contents of a class on stdout. ;  ; void MakeCustomMenuList ();  Makes a customizable version of the popup menu list, i.e. ;  ; Bool_t MatchLegacyCheckSum (UInt_t checksum) const;  Return true if the checksum passed as argument is one of the checksum value produced by the older checksum calculation algorithm. ;  ; void Move (void *arenaFrom, void *arenaTo) const;  Register the fact that an object was moved from the memory location 'arenaFrom' to the memory location 'arenaTo'. ;  ; void * New (ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) const;  Return a pointer to a newly allocated object of this class. ;  ; void * New (void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; void * NewArray (Long_t nElements, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated array of objects of this class. ;  ; void * NewArray (Long_t nElements, void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; ObjectPtr NewObject (ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) const;  ; ObjectPtr NewObject (void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; ObjectPtr NewObjectArray (Long_t nElements, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated array of objects of this class. ;  ; ObjectPtr NewObjectArray (Long_t nElements, void *arena, ENewType defConstructor=kClassNew)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:20026,allocate,allocated,20026,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,3,['allocate'],['allocated']
Energy Efficiency," this function must be called for the class deriving; directly from TObject, eg, assuming that BigTrack derives from Track; and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();. Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns KTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:34260,allocate,allocated,34260,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,1,['allocate'],['allocated']
Energy Efficiency," timeout = 0, then reset activity timestamp on all active sockets. This time out is typically used if GetActive() is used to see how many remotes still need to send something. If they pass the timeout they will be skipped and GetActive() will return 0 and the loop can be exited. ; Definition at line 438 of file TMonitor.cxx. ◆ GetDeActive(). Int_t TMonitor::GetDeActive ; (; ); const. Return number of sockets in the de-active list. ; Definition at line 473 of file TMonitor.cxx. ◆ GetListOfActives(). TList * TMonitor::GetListOfActives ; (; ); const. Returns a list with all active sockets. ; This list must be deleted by the user. DO NOT call Delete() on this list as it will delete the sockets that are still being used by the monitor. ; Definition at line 498 of file TMonitor.cxx. ◆ GetListOfDeActives(). TList * TMonitor::GetListOfDeActives ; (; ); const. Returns a list with all de-active sockets. ; This list must be deleted by the user. DO NOT call Delete() on this list as it will delete the sockets that are still being used by the monitor. ; Definition at line 515 of file TMonitor.cxx. ◆ GetSender(). void * TMonitor::GetSender ; (; ). inlineoverrideprivatevirtual . Reimplemented from TQObject.; Definition at line 51 of file TMonitor.h. ◆ Interrupt(). void TMonitor::Interrupt ; (; ). inline . Definition at line 71 of file TMonitor.h. ◆ IsA(). TClass * TMonitor::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 85 of file TMonitor.h. ◆ IsActive(). Bool_t TMonitor::IsActive ; (; TSocket * ; sock); const. Check if socket 's' is in the active list. ; Avoids the duplication of active list via TMonitor::GetListOfActives(). ; Definition at line 482 of file TMonitor.cxx. ◆ Ready(). void TMonitor::Ready ; (; TSocket * ; sock). virtual . Emit signal when some socket is ready. ; Definition at line 530 of file TMonitor.cxx. ◆ Remove(). void TMonitor::Remove ; (; TSocket * ; sock). virtual . Remove a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:20175,monitor,monitor,20175,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,1,['monitor'],['monitor']
Energy Efficiency," to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; Double_t AdaBoost (std::vector< const TMVA::Event * > &, DecisionTree *dt);  The AdaBoost implementation. ;  ; Double_t AdaBoostR2 (std::vector< const TMVA::Event * > &, DecisionTree *dt);  Adaption of the AdaBoost to regression problems (see H.Drucker 1997). ;  ; Double_t AdaCost (std::vector< const TMVA::Event * > &, DecisionTree *dt);  The AdaCost boosting algorithm takes a simple cost Matrix (currently fixed for all events... later could be modified to use individual cost matrices for each events as in the original paper... ;  ; Double_t ApplyPreselectionCuts (const Event *ev);  Apply the preselection cuts before even bothering about any Decision Trees in the GetMVA . ;  ; Double_t Bagging ();  Call it boot-strapping, re-sampling or whatever you like, in the end it is nothing else but applying ""random"" poisson weights to each event. ;  ; void BoostMonitor (Int_t iTree);  Fills the ROCIntegral vs Itree from the testSample for the monitoring plots during the training . ;  ; void DeterminePreselectionCuts (const std::vector< const TMVA::Event * > &eventSample);  Find useful preselection cuts that will be applied before and Decision Tree training. ;  ; void GetBaggedSubSample (std::vector< const TMVA::Event * > &);  Fills fEventSample with fBaggedSampleFraction*NEvents random training events. ;  ; Double_t GetGradBoostMVA (const TMVA::Event *e, UInt_t nTrees);  Returns MVA value: -1 for background, 1 for signal. ;  ; Double_t GetMvaValue (Double_t *err, Double_t *errUpper, UInt_t useNTrees);  Return the MVA value (range [-1;1]) that classifies the event according to the majority vote from the total number of decision trees. ;  ; Double_t GradBoost (std::vector< const TMVA::Event * > &, DecisionTree *dt, UInt_t cls=0);  Calculate the desired response value for each region. ;  ; Double_t GradBoostRegression (std::vector< const TMVA::Event * > &, DecisionTree *dt);  Implementation of M_T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:31948,monitor,monitoring,31948,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['monitor'],['monitoring']
Energy Efficiency," to autoload for %s"", cls);; 6299 }; 6300 ; 6301 if (!gROOT || !gInterpreter || gROOT->TestBit(TObject::kInvalidObject)) {; 6302 if (gDebug > 2) {; 6303 Info(""TCling::AutoLoad"",; 6304 ""Disabled due to gROOT or gInterpreter being invalid/not ready (the class name is %s)"", cls);; 6305 }; 6306 return 0;; 6307 }; 6308 // Prevent the recursion when the library dictionary are loaded.; 6309 SuspendAutoLoadingRAII autoLoadOff(this);; 6310 // Try using externally provided callback first.; 6311 if (fAutoLoadCallBack) {; 6312 int success = (*(AutoLoadCallBack_t)fAutoLoadCallBack)(cls);; 6313 if (success); 6314 return success;; 6315 }; 6316 ; 6317 // During the 'Deep' part of the search we will call GetClassSharedLibsForModule; 6318 // (when module are enabled) which might end up calling AutoParsing but; 6319 // that should only be for the cases where the library has no generated pcm; 6320 // and in that case a rootmap should be available.; 6321 // This avoids a very costly operation (for generally no gain) but reduce the; 6322 // quality of the search (i.e. bad in case of library with no pcm and no rootmap; 6323 // file).; 6324 TInterpreter::SuspendAutoParsing autoParseRaii(this);; 6325 std::unordered_set<std::string> visited;; 6326 return DeepAutoLoadImpl(cls, visited, false /*normalized*/);; 6327}; 6328 ; 6329////////////////////////////////////////////////////////////////////////////////; 6330/// Parse the payload or header.; 6331 ; 6332static cling::Interpreter::CompilationResult ExecAutoParse(const char *what,; 6333 Bool_t header,; 6334 cling::Interpreter *interpreter); 6335{; 6336 std::string code = gNonInterpreterClassDef ;; 6337 if (!header) {; 6338 // This is the complete header file content and not the; 6339 // name of a header.; 6340 code += what;; 6341 ; 6342 } else {; 6343 code += (""#include \"""");; 6344 code += what;; 6345 code += ""\""\n"";; 6346 }; 6347 code += (""#ifdef __ROOTCLING__\n""; 6348 ""#undef __ROOTCLING__\n""; 6349 + gInterpreterClassDef +; 6350 ""#endif"");; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:245549,reduce,reduce,245549,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['reduce'],['reduce']
Energy Efficiency," to book all operations *for all RDataFrame computation graphs*; 963before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs.; 964 ; 965Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See [Activating RDataFrame execution logs](\ref rdf-logging).; 966 ; 967### Memory usage; 968 ; 969There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage.; 970 ; 971Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, to allocate some memory for the generated code that is only released at the end of the application. This commonly results in memory usage creep in long-running applications that create many RDataFrames one after the other. Possible mitigations include creating and running each RDataFrame event loop in a sub-process, or booking all operations for all different RDataFrame computation graphs before the first event loop is triggered, so that the interpreter is invoked only once for all computation graphs:; 972 ; 973~~~{.cpp}; 974// assuming df1 and df2 are separate computation graphs, do:; 975a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:56561,consumption,consumption,56561,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['consumption'],['consumption']
Energy Efficiency," to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList*TTree::fEventList! Pointer to event selection list (if one); TFile*TChain::fFile! Pointer to current file (We own the file).; Int_tTTree::fFileNumber! current file number (if file extensions); TObjArray*TChain::fFiles-> List of file names containing the trees (TChainElement, owned); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tTTree::fFlushedBytesNumber of autoflushed bytes; UInt_tTTree::fFriendLockStatus! Record which method is locking the friend recursion; TList*TTree::fFriendspointer to list of friend elements; TArrayITTree::fIndexIndex of sorted values; TArrayDTTree::fIndexValuesSorted index values; TObjArrayTTree::fLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tTChain::fNtreesNumber ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofChain.html:25839,allocate,allocated,25839,root/html534/TProofChain.html,https://root.cern,https://root.cern/root/html534/TProofChain.html,6,['allocate'],['allocated']
Energy Efficiency," to fX and fY if arrays == 0 and ibegin != iend. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; virtual Bool_t DoMerge (const TGraph *g);  protected function to perform the merge operation of a graph ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; virtual void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE);  Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option);  Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes. ;  ; Double_t ** ShrinkAndCopy (Int_t size, Int_t iend);  if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ;  ; virtual void SwapPoints (Int_t pos1, Int_t pos2);  Swap points. ;  ; virtual void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low);  Update the fX and fY arrays with the sorted values. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TF1 * fF {nullptr};  theoretical density function, if specified ;  ; Int_t fNy0 {0};  size of the fY0 dataset ;  ; Double_t fXq1 {0.};  x1 coordinate of the interquartile line ;  ; Double_t fXq2 {0.};  x2 coordinate of the interquartile line ;  ; Double_t * fY0 {nullptr};  ! second dataset, if specified ;  ; Double_t fYq1 {0.};  y1 coordinate of the interquartile line ;  ; Double_t fYq2 {0.};  y2 coordinate of the interquartile line ;  ;  Protected Attri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphQQ.html:31369,allocate,allocate,31369,doc/master/classTGraphQQ.html,https://root.cern,https://root.cern/doc/master/classTGraphQQ.html,1,['allocate'],['allocate']
Energy Efficiency," to fX and fY if arrays == 0 and ibegin != iend. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; virtual Bool_t DoMerge (const TGraph *g);  protected function to perform the merge operation of a graph ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; virtual void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE);  Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option);  Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes. ;  ; Double_t ** ShrinkAndCopy (Int_t size, Int_t iend);  if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ;  ; virtual void SwapPoints (Int_t pos1, Int_t pos2);  Swap points. ;  ; virtual void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low);  Update the fX and fY arrays with the sorted values. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; bool _showProgress = false;  ! Show progress indication when adding points ;  ;  Protected Attributes inherited from TGraph; TList * fFunctions;  Pointer to list of functions (fits and user) ;  ; TH1F * fHistogram;  Pointer to histogram used for drawing axis. ;  ; Double_t fMaximum;  Maximum value for plotting along y. ;  ; Int_t fMaxSize;  !Current dimension of arrays fX and fY ;  ; Double_t fMinimum;  Minimum value for plotting along y. ;  ; Int_t fNpo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCurve.html:37333,allocate,allocate,37333,doc/master/classRooCurve.html,https://root.cern,https://root.cern/doc/master/classRooCurve.html,1,['allocate'],['allocate']
Energy Efficiency," to fX and fY if arrays == 0 and ibegin != iend. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; virtual Bool_t DoMerge (const TGraph *g);  protected function to perform the merge operation of a graph ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; virtual void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE);  Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option);  Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes. ;  ; Double_t ** ShrinkAndCopy (Int_t size, Int_t iend);  if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ;  ; virtual void SwapPoints (Int_t pos1, Int_t pos2);  Swap points. ;  ; virtual void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low);  Update the fX and fY arrays with the sorted values. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static void SwapValues (Double_t *arr, Int_t pos1, Int_t pos2);  Swap values. ;  . Protected Attributes; TList * fFunctions;  Pointer to list of functions (fits and user) ;  ; TH1F * fHistogram;  Pointer to histogram used for drawing axis. ;  ; Double_t fMaximum;  Maximum value for plotting along y. ;  ; Int_t fMaxSize;  !Current dimension of arrays fX and fY ;  ; Double_t fMinimum;  Minimum value for plotting along y. ;  ; Int_t fNpoints;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph.html:29613,allocate,allocate,29613,doc/master/classTGraph.html,https://root.cern,https://root.cern/doc/master/classTGraph.html,1,['allocate'],['allocate']
Energy Efficiency," to fX and fY if arrays == 0 and ibegin != iend. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; virtual Bool_t DoMerge (const TGraph *g);  protected function to perform the merge operation of a graph ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; virtual void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE);  Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option);  Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes. ;  ; Double_t ** ShrinkAndCopy (Int_t size, Int_t iend);  if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ;  ; virtual void SwapPoints (Int_t pos1, Int_t pos2);  Swap points. ;  ; virtual void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low);  Update the fX and fY arrays with the sorted values. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from TGraph; static void SwapValues (Double_t *arr, Int_t pos1, Int_t pos2);  Swap values. ;  . #include <TCutG.h>. Inheritance diagram for TCutG:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TCutG() [1/5]. TCutG::TCutG ; (; ). TCutG default constructor. ; Definition at line 99 of file TCutG.cxx. ◆ TCutG() [2/5]. TCutG::TCutG ; (; const TC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCutG.html:34797,allocate,allocate,34797,doc/master/classTCutG.html,https://root.cern,https://root.cern/doc/master/classTCutG.html,1,['allocate'],['allocate']
Energy Efficiency," to fX and fY if arrays == 0 and ibegin != iend. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; virtual Bool_t DoMerge (const TGraph *g);  protected function to perform the merge operation of a graph ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; virtual void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE);  Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option);  Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes. ;  ; Double_t ** ShrinkAndCopy (Int_t size, Int_t iend);  if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ;  ; virtual void SwapPoints (Int_t pos1, Int_t pos2);  Swap points. ;  ; virtual void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low);  Update the fX and fY arrays with the sorted values. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from TGraph; static void SwapValues (Double_t *arr, Int_t pos1, Int_t pos2);  Swap values. ;  ;  Protected Attributes inherited from TGraph; TList * fFunctions;  Pointer to list of functions (fits and user) ;  ; TH1F * fHistogram;  Pointer to histogram used for drawing axis. ;  ; Double_t fMaximum;  Maximum value for plotting along y. ;  ; Int_t fMaxSize;  !Current dimension of arrays fX and fY ;  ; Double_t fMinimum;  Minimum valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooEllipse.html:32454,allocate,allocate,32454,doc/master/classRooEllipse.html,https://root.cern,https://root.cern/doc/master/classRooEllipse.html,1,['allocate'],['allocate']
Energy Efficiency," to implement the function to create,access and destroy iterators ;  CIterators< Cont_t, true >;  CIterators< std::vector< T >, false >;  CIteratorValueSmall helper to encapsulate whether to return the value pointed to by the iterator or its address ;  CIteratorValue< Cont_t, value_ptr * >;  CMapInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CPairHolder;  CPushbackSmall helper to encapsulate all necessary data accesses for containers like vector, list, deque ;  CPushback< Internal::TStdBitsetHelper< Bitset_t > >;  CPushback< std::vector< Bool_t, A > >;  CPushfrontSmall helper to encapsulate all necessary data accesses for containers like forward_list ;  CSfinaeHelper;  CTypeSmall helper to encapsulate basic data accesses for all STL continers ;  ►CType< Internal::TStdBitsetHelper< Bitset_t > >;  ►CIterators;  CPtrSize_t;  ►CType< std::vector< Bool_t, A > >;  CIterators;  CTFutureImpl;  CTRangeStaticCastTRangeStaticCast is an adaptater class that allows the typed iteration through a TCollection ;  ►CTSchemaRuleSet;  CTMatches;  ►CTStatusBitsChecker;  CRegistry;  CTTypedIterTTypedIter is a typed version of TIter ;  ►NExecutorUtilsThis namespace contains pre-defined functions to be used in conjuction with TExecutor::Map and TExecutor::MapReduce ;  CReduceObjectsMerge collection of TObjects ;  ►NExperimental;  ►NDetail;  CRArgsMenuItem;  CRCheckedMenuItem;  CRHistBinIterIterates over the bins of a RHist or RHistImpl ;  CRHistBinPtrPoints to a histogram bin (or actually a RHistBinRef) ;  CRHistBinRefRepresents a bin reference ;  CRHistBinStatConst view on a bin's statistical data ;  CRHistDataA RHistImplBase's data, provides accessors to all its statistics ;  CRHistImpl;  CRHistImplBaseInterface class for RHistImpl ;  CRHistImplPrecisionAgnosticBaseBase class for RHistImplBase that abstracts out the histogram's PRECISION ;  CRMenuArgument;  CRMenuItemClass contains info for producing menu item on the JS side ;  ►NHi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:17532,adapt,adaptater,17532,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,2,['adapt'],['adaptater']
Energy Efficiency," to one point); 601 for (Int_t i = 0; i < fNpoints; i++) {; 602 Int_t dpx = px - gPad->XtoAbsPixel(gPad->XtoPad(fX[i]));; 603 Int_t dpy = py - gPad->YtoAbsPixel(gPad->YtoPad(fY[i]));; 604 if (dpx*dpx+dpy*dpy < 25) {ipoint = i; break;}; 605 }; 606 if (ipoint == -2) return;; 607 ; 608 fEXlow[ipoint] = exl;; 609 fEYlow[ipoint] = eyl;; 610 fEXhigh[ipoint] = exh;; 611 fEYhigh[ipoint] = eyh;; 612 fEXlowd[ipoint] = exld;; 613 fEXhighd[ipoint] = exhd;; 614 fEYlowd[ipoint] = eyld;; 615 fEYhighd[ipoint] = eyhd;; 616 ; 617 gPad->Modified();; 618}; 619 ; 620 ; 621////////////////////////////////////////////////////////////////////////////////; 622/// Set ex and ey values for point number `i`.; 623 ; 624void TGraphBentErrors::SetPointError(Int_t i, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh,; 625 Double_t exld, Double_t exhd, Double_t eyld, Double_t eyhd); 626{; 627 if (i < 0) return;; 628 if (i >= fNpoints) {; 629 // re-allocate the object; 630 TGraphBentErrors::SetPoint(i,0,0);; 631 }; 632 fEXlow[i] = exl;; 633 fEYlow[i] = eyl;; 634 fEXhigh[i] = exh;; 635 fEYhigh[i] = eyh;; 636 fEXlowd[i] = exld;; 637 fEXhighd[i] = exhd;; 638 fEYlowd[i] = eyld;; 639 fEYhighd[i] = eyhd;; 640}; 641 ; 642 ; 643////////////////////////////////////////////////////////////////////////////////; 644/// Swap points.; 645 ; 646void TGraphBentErrors::SwapPoints(Int_t pos1, Int_t pos2); 647{; 648 SwapValues(fEXlow, pos1, pos2);; 649 SwapValues(fEXhigh, pos1, pos2);; 650 SwapValues(fEYlow, pos1, pos2);; 651 SwapValues(fEYhigh, pos1, pos2);; 652 ; 653 SwapValues(fEXlowd, pos1, pos2);; 654 SwapValues(fEXhighd, pos1, pos2);; 655 SwapValues(fEYlowd, pos1, pos2);; 656 SwapValues(fEYhighd, pos1, pos2);; 657 ; 658 TGraph::SwapPoints(pos1, pos2);; 659}; 660 ; 661////////////////////////////////////////////////////////////////////////////////; 662/// Update the fX, fY, fEXlow, fEXhigh, fEXlowd, fEXhighd, fEYlow, fEYhigh, fEYlowd, ; 663/// and fEYhighd arrays with the sorted values.; 664 ; 665void TGraphB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:20959,allocate,allocate,20959,doc/master/TGraphBentErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency," to signal + background; ; histgen();; ; TFile *f = new TFile(""background.root"");; background = (TH1F*)f->Get(""background""); //pointer used in ftotal; TH1F *result = (TH1F*)f->Get(""result"");; ; TF1 *ftot = new TF1(""ftot"",ftotal,0,10,4);; double norm = result->GetMaximum();; ftot->SetParameters(0.5*norm,5,.2,norm);; ftot->SetParLimits(0,.3*norm,norm);; ; result->Fit(""ftot"",""b"");; }; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; TF1.h; TFile.h; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; TH1F.h; TAxis::FindBinvirtual Int_t FindBin(Double_t x)Find bin number corresponding to abscissa x.Definition TAxis.cxx:293; TF11-Dim function classDefinition TF1.h:233; TF1::SetParLimitsvirtual void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax)Set lower and upper limits for parameter ipar.Definition TF1.cxx:3507; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; xDouble_t x[n]Definition legend1.C:17; f1TF1 * f1Definition legend1.C:11; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; AuthorRene Brun ; Definition in file fithist.C. tutorialsfitfithist.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/fithist_8C.html:3209,power,power,3209,doc/master/fithist_8C.html,https://root.cern,https://root.cern/doc/master/fithist_8C.html,1,['power'],['power']
Energy Efficiency," to the appropriate cells is done when the bin is added to the histogram. To do this, AddBin() calls the AddBinToPartition() method. This method adds the input bin to the partitioning matrix.; The number of partition cells per axis can be specified in the constructor. If it is not specified, the default value of 25 along each axis will be assigned. This value was chosen because it is small enough to avoid slowing down AddBin(), while being large enough to enhance Fill() by a considerable amount. Regardless of how it is initialized at construction time, it can be changed later with the ChangePartition() method. ChangePartition() deletes the old partition matrix and generates a new one with the specified number of cells on each axis.; The optimum number of partition cells per axis changes with the number of times Fill() will be called. Although partitioning greatly speeds up filling, it also adds a constant time delay into the code. When Fill() is to be called many times, it is more efficient to divide the histogram into a large number cells. However, if the histogram is to be filled only a few times, it is better to divide into a small number of cells. ; Definition at line 66 of file TH2Poly.h. Public Member Functions;  TH2Poly ();  Default Constructor. No boundaries specified. ;  ;  TH2Poly (const char *name, const char *title, Double_t xlow, Double_t xup, Double_t ylow, Double_t yup);  Constructor with specified name and boundaries, but no partition cell number. ;  ;  TH2Poly (const char *name, const char *title, Int_t nX, Double_t xlow, Double_t xup, Int_t nY, Double_t ylow, Double_t yup);  Constructor with specified name and boundaries and partition cell number. ;  ;  TH2Poly (const TH2Poly &rhs);  Copy constructor. ;  ;  ~TH2Poly () override;  Destructor. ;  ; Bool_t Add (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1) override;  NOT IMPLEMENTED for TH2Poly. ;  ; Bool_t Add (const TH1 *h1, Double_t c1) override;  Performs the operation: this = this +",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2Poly.html:5910,efficient,efficient,5910,doc/master/classTH2Poly.html,https://root.cern,https://root.cern/doc/master/classTH2Poly.html,1,['efficient'],['efficient']
Energy Efficiency," to variations in the remote environment (changing load on the cluster nodes, network interruptions, etc.).; Being an extension of the ROOT system, PROOF is designed to work on objects in ROOT data stores, though, for the time being, it mainly addresses the case of TTree based object collections.; PROOF is primarily meant as an interactive alternative to batch systems for Central Analysis Facilities and departmental workgroups (Tier-2’s). However, thanks to a multi-tier architecture allowing multiple levels of masters, it can be easily adapted to wide range virtual clusters distributed over geographically separated domains and heterogeneous machines (GRIDs).; While pure interactivity might not always be possible when performing a complicated analysis on a very large data set, PROOF still tries to give the user the interactive experience with something we call “interactive batch”. With “interactive batch” the user can start very long running queries, disconnect the client and at any time, any location and from any computer reconnect to the query to monitor its progress or retrieve the results. This feature gives it a distinct advantage over purely batch based solutions, that only provide an answer once all sub-jobs have been finished. The Multi-tier structure of a PROOF cluster. Details about the PROOF system and the way to use it can be found at 1; The PROOF development is a joint effort between CERN and MIT.; 25 Writing a Graphical User Interface. The ROOT GUI classes support an extensive and rich set of widgets with the Windows 95 look and feel. The widget classes interface to the underlying graphics system via a single abstract class. Concrete versions of this abstract class have been implemented for X11 and Win32, thereby making the ROOT GUI fully cross-platform. Originally the GUI classes were based on Hector Peraza’s Xclass’95 widget library http://xclass.sourceforge.net/; 25.1 The ROOT GUI Classes; Features of the GUI classes in a nutshell:. Originally based o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1126713,monitor,monitor,1126713,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['monitor'],['monitor']
Energy Efficiency," to; be fitted, and the new candidate function to be included in the; fit. By default it is 0, which automatically chooses another; selection criteria. See also; class description. void SetMinAngle(Double_t angle = 1); Set the min angle (in degrees) between a new candidate function; and the subspace spanned by the previously accepted; functions. See also; class description. void SetPowers(const Int_t* powers, Int_t terms); Define a user function. The input array must be of the form; (p11, ..., p1N, ... ,pL1, ..., pLN); Where N is the dimension of the data sample, L is the number of; terms (given in terms) and the first number, labels the term, the; second the variable. More information is given in the; class description. void SetPowerLimit(Double_t limit = 0.001); Set the user parameter for the function selection. The bigger the; limit, the more functions are used. The meaning of this variable; is defined in the; class description. void SetMaxPowers(const Int_t* powers); Set the maximum power to be considered in the fit for each; variable. See also; class description. void SetMinRelativeError(Double_t error); Set the acceptable relative error for when sum of square; residuals is considered minimized. For a full account, refer to; the; class description. Bool_t TestFunction(Double_t squareResidual, Double_t dResidur); PRIVATE METHOD:; Test whether the currently considered function contributes to the; fit. See also; class description. TMultiDimFit(). void Draw(Option_t* = ""d""); { }. Double_t GetChi2() const; { return fChi2; }. const TMatrixD* GetCorrelationMatrix() const; { return &fCorrelationMatrix; }. const TVectorD* GetCoefficients() const; { return &fCoefficients; }. const TVectorD* GetCoefficientsRMS() const; { return &fCoefficientsRMS; }. Double_t GetError() const; { return fError; }. Int_t* GetFunctionCodes() const; { return fFunctionCodes; }. const TMatrixD* GetFunctions() const; { return &fFunctions; }. TList* GetHistograms() const; { return fHistograms; }. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMultiDimFit.html:34957,power,powers,34957,root/html602/TMultiDimFit.html,https://root.cern,https://root.cern/root/html602/TMultiDimFit.html,8,['power'],"['power', 'powers']"
Energy Efficiency," top name, visible in the web browser; auth_file=filename - authentication file name, created with htdigets utility; auth_domain=domain - authentication domain; loopback - bind specified port to loopback 127.0.0.1 address; debug - enable debug mode, server always returns html page with request info. If necessary, one could bind http server to specific IP address like:; new THttpServer(""http:192.168.1.17:8080""); 1.2 Registering objects; At any time, one could register other objects with the command:; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; One should specify sub-folder name, where objects will be registered. If sub-folder name does not starts with slash /, than top-name folder /Objects/ will be prepended. At any time one could unregister objects:; serv->Unregister(gr);; THttpServer does not take ownership over registered objects - they should be deleted by user.; If the objects content is changing in the application, one could enable monitoring flag in the browser - then objects view will be regularly updated.; 1.3 Command interface; THttpServer class provide simple interface to invoke command from web browser. One just register command like:; serv->RegisterCommand(""/DoSomething"",""SomeFunction()"");; Element with name DoSomething will appear in the web browser and can be clicked. It will result in gROOT->ProcessLineSync(""SomeFunction()"") call. When registering command, one could specify icon name which will be displayed with the command.; serv->RegisterCommand(""/DoSomething"",""SomeFunction()"", ""/rootsys/icons/ed_execute.png"");; In example usage of images from $ROOTSYS/icons directory is shown. One could prepend button; string to the icon name to let browser show command as extra button. In last case one could hide command element from elements list:; serv->Hide(""/DoSomething"");; One can find example of command interface usage in tutorials/http/httpcontrol.C macro.; 1.4 Configuring user access; By default, the http serv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:3124,monitor,monitoring,3124,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,2,['monitor'],['monitoring']
Energy Efficiency," trees will be; : generated leading to more simple rules.; : By changing this range, the average complexity; : of the rule ensemble can be controlled.; : ␛[1mRuleMinDist ␛[0m: By increasing the minimum distance between; : rules, fewer and more diverse rules will remain.; : Initially it is a good idea to keep this small; : or zero and let the fitting do the selection of; : rules. In order to reduce the ensemble size,; : the value can then be increased.; : ; : II. TUNING OF THE FITTING:; : ; : ␛[1mGDPathEveFrac ␛[0m: fraction of events in path evaluation; : Increasing this fraction will improve the path; : finding. However, a too high value will give few; : unique events available for error estimation.; : It is recommended to use the default = 0.5.; : ␛[1mGDTau ␛[0m: cutoff parameter tau; : By default this value is set to -1.0.; : This means that the cut off parameter is; : automatically estimated. In most cases; : this should be fine. However, you may want; : to fix this value if you already know it; : and want to reduce on training time.; : ␛[1mGDTauPrec ␛[0m: precision of estimated tau; : Increase this precision to find a more; : optimum cut-off parameter.; : ␛[1mGDNStep ␛[0m: number of steps in path search; : If the number of steps is too small, then; : the program will give a warning message.; : ; : III. WARNING MESSAGES; : ; : ␛[1mRisk(i+1)>=Risk(i) in path␛[0m; : ␛[1mChaotic behaviour of risk evolution.␛[0m; : The error rate was still decreasing at the end; : By construction the Risk should always decrease.; : However, if the training sample is too small or; : the model is overtrained, such warnings can; : occur.; : The warnings can safely be ignored if only a; : few (<3) occur. If more warnings are generated,; : the fitting fails.; : A remedy may be to increase the value; : ␛[1mGDValidEveFrac␛[0m to 1.0 (or a larger value).; : In addition, if ␛[1mGDPathEveFrac␛[0m is too high; : the same warnings may occur since the events; : used for error estimation are also",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:55630,reduce,reduce,55630,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['reduce'],['reduce']
Energy Efficiency," turned on?Definition NeuralNet.h:815; TMVA::DNN::Settings::regularizationEnumRegularization regularization() constsome regularization of the DNN is turned on?Definition NeuralNet.h:813; TMVA::DNN::Settings::convergenceCountsize_t convergenceCount() constreturns the current convergence countDefinition NeuralNet.h:827; TMVA::DNN::Settings::testRepetitionssize_t testRepetitions() consthow often is the test data testedDefinition NeuralNet.h:768; TMVA::DNN::Settings::endTestCyclevirtual void endTestCycle()callback for monitoring and logggingDefinition NeuralNet.h:805; TMVA::DNN::Settings::testIterationvirtual void testIteration()callback for monitoring and logggingDefinition NeuralNet.h:806; TMVA::DNN::Settings::hasConvergedvirtual bool hasConverged(double testError)has this training converged already?Definition NeuralNet.cxx:485; TMVA::DNN::Settings::cyclevirtual void cycle(double progress, TString text)Definition NeuralNet.h:799; TMVA::DNN::Settings::endTrainCyclevirtual void endTrainCycle(double)callback for monitoring and loggingDefinition NeuralNet.h:788; TMVA::DNN::Settings::dropFractionsconst std::vector< double > & dropFractions() constDefinition NeuralNet.h:762; TMVA::DNN::Settings::addPointvoid addPoint(std::string histoName, double x)for monitoringDefinition NeuralNet.h:821; TMVA::DNN::Settings::testSamplevirtual void testSample(double, double, double, double)virtual function to be used for monitoring (callback)Definition NeuralNet.h:781; TMVA::DNN::Settings::plotvoid plot(std::string histoName, std::string options, int pad, EColor color)for monitoringDefinition NeuralNet.h:823; TMVA::DNN::Settings::startTrainCyclevirtual void startTrainCycle()Definition NeuralNet.h:782; TMVA::DNN::Settings::convergenceStepssize_t convergenceSteps() consthow many steps until training is deemed to have convergedDefinition NeuralNet.h:766; TMVA::DNN::Settings::factorWeightDecaydouble factorWeightDecay() constget the weight-decay factorDefinition NeuralNet.h:769; TMVA::DNN::Setti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:67950,monitor,monitoring,67950,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['monitor'],['monitoring']
Energy Efficiency," two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const char* function, const char* params); Create a global function invocation environment. The parameter; string has the form: ""\""aap\"", 3, 4,35"". To execute the; function call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const TMethodCall& org); Copy ctor. TMethodCall & operator=(const TMethodCall& rhs); Assignement operator. ~TMethodCall(); TMethodCall dtor. TObject * Clone(const char* newname = """") const; Return an exact copy of this object. void Init(TClass* cl, const char* method, const char* params); Initialize the method invocation environment. Necessary input; information: the class, method name and the parameter string; of the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void Init(const char* function, const char* params); Initialize the function invocation environment. Necessary input; information: the function name and the parameter string of; the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitImplementation(const char* methodname, const char* params, const char* proto, TClass* cl, const ClassInfo_t* cinfo); This function implements Init and InitWithPrototype. void InitWithPrototype(TClass* cl, const char* method, const char* proto); Initialize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMethodCall.html:8822,efficient,efficient,8822,root/html528/TMethodCall.html,https://root.cern,https://root.cern/root/html528/TMethodCall.html,6,['efficient'],['efficient']
Energy Efficiency," type inherits from TObject and a new constructor that takes the TCollection by pointer. ;  ; namespace  ROOT::Internal;  . Macros; #define R__COLL_COND_MUTEX(mutex)   this->IsUsingRWLock() ? mutex : nullptr;  ; #define R__COLLECTION_ITER_GUARD(collection);  ; #define R__COLLECTION_READ_GUARD();  ; #define R__COLLECTION_READ_LOCKGUARD(mutex)   ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_READ_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_GUARD();  ; #define R__COLLECTION_WRITE_LOCKGUARD(mutex)   ::ROOT::TWriteLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TWriteLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__FOR_EACH(type, proc);  . Typedefs; template<typename T > ; using TRangeDynCast = ROOT::Detail::TRangeCast< T, true >;  TRangeDynCast is an adapter class that allows the typed iteration through a TCollection. ;  ; template<typename T > ; using ROOT::Detail::TRangeStaticCast = TRangeCast< T, false >;  TRangeStaticCast is an adapter class that allows the typed iteration through a TCollection. ;  . Functions; bool ROOT::Internal::ContaineeInheritsFrom (TClass *cl, TClass *base);  Return true if 'cl' inherits from 'base'. ;  ; const TCollection & ROOT::Internal::EmptyCollection ();  Return an empty collection for use with nullptr TRangeCast. ;  . Variables; R__EXTERN TVirtualMutex * gCollectionMutex;  ; const Bool_t kIterBackward = !kIterForward;  ; const Bool_t kIterForward = kTRUE;  . Macro Definition Documentation. ◆ R__COLL_COND_MUTEX. #define R__COLL_COND_MUTEX; (;  ; mutex);    this->IsUsingRWLock() ? mutex : nullptr. Definition at line 360 of file TCollection.h. ◆ R__COLLECTION_ITER_GUARD. #define R__COLLECTION_ITER_GUARD; (;  ; collection). Definition at line 129 of file TCollection.h. ◆ R__COLLE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8h.html:2185,adapt,adapter,2185,doc/master/TCollection_8h.html,https://root.cern,https://root.cern/doc/master/TCollection_8h.html,1,['adapt'],['adapter']
Energy Efficiency," type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int size = 1000, int rule = 3). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int size = 1000, int rule = 3). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html:5582,adapt,adaptive,5582,root/html526/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html,2,['adapt'],['adaptive']
Energy Efficiency," unsigned Broadcast (unsigned code, std::initializer_list< T > &objs);  Send a message with a different object to each server. ;  ; template<class T > ; unsigned Broadcast (unsigned code, T obj, unsigned nMessages=0);  Send a message containing code and obj to each worker, up to a maximum number of nMessages workers. ;  ; unsigned Broadcast (unsigned code, unsigned nMessages=0);  Send a message with the specified code to at most nMessages workers. ;  ; void DeActivate (TSocket *s);  DeActivate a certain socket. ;  ; bool Fork (TMPWorker &server);  This method forks the ROOT session into fNWorkers children processes. ;  ; bool GetIsParent () const;  ; TMonitor & GetMonitor ();  ; unsigned GetNWorkers () const;  ; void HandleMPCode (MPCodeBufPair &msg, TSocket *sender);  Handle messages containing an EMPCode. ;  ; TMPClient & operator= (const TMPClient &)=delete;  ; void ReapWorkers ();  Wait on worker processes and remove their pids from fWorkerPids. ;  ; void Remove (TSocket *s);  Remove a certain socket from the monitor. ;  ; void SetNWorkers (unsigned n);  Set the number of workers that will be spawned by the next call to Fork() ;  . Private Attributes; unsigned fNProcessed;  number of arguments already passed to the workers ;  ; unsigned fNToProcess;  total number of arguments to pass to the workers ;  ; ETask fTaskType = ETask::kNoTask;  the kind of task that is being executed, if any ;  . #include <ROOT/TTreeProcessorMP.hxx>. Inheritance diagram for ROOT::TTreeProcessorMP:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ InvokeResult_t. template<typename F , typename... Args> . using ROOT::TTreeProcessorMP::InvokeResult_t = ROOT::TypeTraits::InvokeResult_t<F, Args...>. private . Definition at line 40 of file TTreeProcessorMP.hxx. Member Enumeration Documentation. ◆ ETask. enum class ROOT::TTreeProcessorMP::ETask : unsigned char. strongprivate . A collection of the types of tasks tha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TTreeProcessorMP.html:10577,monitor,monitor,10577,doc/v632/classROOT_1_1TTreeProcessorMP.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TTreeProcessorMP.html,2,['monitor'],['monitor']
Energy Efficiency," unsigned Broadcast (unsigned code, std::initializer_list< T > &objs);  Send a message with a different object to each server. ;  ; template<class T > ; unsigned Broadcast (unsigned code, T obj, unsigned nMessages=0);  Send a message containing code and obj to each worker, up to a maximum number of nMessages workers. ;  ; unsigned Broadcast (unsigned code, unsigned nMessages=0);  Send a message with the specified code to at most nMessages workers. ;  ; void DeActivate (TSocket *s);  DeActivate a certain socket. ;  ; bool Fork (TMPWorker &server);  This method forks the ROOT session into fNWorkers children processes. ;  ; bool GetIsParent () const;  ; TMonitor & GetMonitor ();  ; unsigned GetNWorkers () const;  ; void HandleMPCode (MPCodeBufPair &msg, TSocket *sender);  Handle messages containing an EMPCode. ;  ; TMPClient & operator= (const TMPClient &)=delete;  ; void ReapWorkers ();  Wait on worker processes and remove their pids from fWorkerPids. ;  ; void Remove (TSocket *s);  Remove a certain socket from the monitor. ;  ; void SetNWorkers (unsigned n);  Set the number of workers that will be spawned by the next call to Fork() ;  . Private Attributes; unsigned fNProcessed;  number of arguments already passed to the workers ;  ; unsigned fNToProcess;  total number of arguments to pass to the workers ;  ; ETask fTaskType = ETask::kNoTask;  the kind of task that is being executed, if any ;  ; friend TExecutorCRTP;  . Additional Inherited Members;  Protected Types inherited from ROOT::TExecutorCRTP< TProcessExecutor >; using InvokeResult_t = ROOT::TypeTraits::InvokeResult_t< F, Args... >;  ; using validMapReturnCond = std::enable_if_t<!std::is_reference< InvokeResult_t< F, T... > >::value &&!std::is_void< InvokeResult_t< F, T... > >::value >;  type definition used in templated functions for not allowing mapping functions that return references or void. ;  . #include <ROOT/TProcessExecutor.hxx>. Inheritance diagram for ROOT::TProcessExecutor:. This browser is not abl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TProcessExecutor.html:11007,monitor,monitor,11007,doc/v632/classROOT_1_1TProcessExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TProcessExecutor.html,2,['monitor'],['monitor']
Energy Efficiency," used.; if ncolors = 68 and colors=0, an Avocado palette is used.; if ncolors = 69 and colors=0, a Beach palette is used.; if ncolors = 70 and colors=0, a Black Body palette is used.; if ncolors = 71 and colors=0, a Blue Green Yellow palette is used.; if ncolors = 72 and colors=0, a Brown Cyan palette is used.; if ncolors = 73 and colors=0, a CMYK palette is used.; if ncolors = 74 and colors=0, a Candy palette is used.; if ncolors = 75 and colors=0, a Cherry palette is used.; if ncolors = 76 and colors=0, a Coffee palette is used.; if ncolors = 77 and colors=0, a Dark Rain Bow palette is used.; if ncolors = 78 and colors=0, a Dark Terrain palette is used.; if ncolors = 79 and colors=0, a Fall palette is used.; if ncolors = 80 and colors=0, a Fruit Punch palette is used.; if ncolors = 81 and colors=0, a Fuchsia palette is used.; if ncolors = 82 and colors=0, a Grey Yellow palette is used.; if ncolors = 83 and colors=0, a Green Brown Terrain palette is used.; if ncolors = 84 and colors=0, a Green Pink palette is used.; if ncolors = 85 and colors=0, an Island palette is used.; if ncolors = 86 and colors=0, a Lake palette is used.; if ncolors = 87 and colors=0, a Light Temperature palette is used.; if ncolors = 88 and colors=0, a Light Terrain palette is used.; if ncolors = 89 and colors=0, a Mint palette is used.; if ncolors = 90 and colors=0, a Neon palette is used.; if ncolors = 91 and colors=0, a Pastel palette is used.; if ncolors = 92 and colors=0, a Pearl palette is used.; if ncolors = 93 and colors=0, a Pigeon palette is used.; if ncolors = 94 and colors=0, a Plum palette is used.; if ncolors = 95 and colors=0, a Red Blue palette is used.; if ncolors = 96 and colors=0, a Rose palette is used.; if ncolors = 97 and colors=0, a Rust palette is used.; if ncolors = 98 and colors=0, a Sandy Terrain palette is used.; if ncolors = 99 and colors=0, a Sienna palette is used.; if ncolors = 100 and colors=0, a Solar palette is used.; if ncolors = 101 and colors=0, a South We",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TColor.html:30566,Green,Green,30566,root/html604/TColor.html,https://root.cern,https://root.cern/root/html604/TColor.html,1,['Green'],['Green']
Energy Efficiency," user data.; TEveVectorDfVStart vertex.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTrackPropagator(const char* n = ""TEveTrackPropagator"", const char* t = """", TEveMagField* field = 0, Bool_t own_field = kTRUE); Default constructor. ~TEveTrackPropagator(); Destructor. void OnZeroRefCount(); Virtual from TEveRefBackPtr - track reference count has reached zero. void CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); Check reference count - virtual from TEveElement.; Must also take into account references from TEveRefBackPtr. void ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); Element-change notification.; Stamp all tracks as requiring display-list regeneration.; Virtual from TEveElement. void InitTrack(const TEveVectorD& v, Int_t charge); Initialize internal data-members for given particle parameters. void InitTrack(const TEveVectorF& v, Int_t charge); TEveVectorF wrapper. void ResetTrack(); Reset cache holding particle trajectory. Bool_t GoToVertex(TEveVectorD& v, TEveVectorD& p); Propagate particle with momentum p to vertex v. Bool_t GoToVertex(TEveVectorF& v, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. void GoToBounds(TEveVectorF& p); TEveVectorF wrapper. void Update(const TEveVector4D& v, const TEveVectorD& p, Bool_t full_update = kFALSE, Bool_t enforce_max_step = kFALSE); Update helix / B-field projection state. void Step(const TEveVector4D& v, const TEveVectorD& p, TEveVector4D& vOut, TEveVectorD& pOut); Wrapper to step helix. void LoopToBounds(TEveVectorD& p); Propagate charged particle with momentum p to bounds.; It is expected that Update() with full-update was called before. Bool_t LoopToVertex(TEveVectorD& v, TEveVectorD& p); Prop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveTrackPropagator.html:25856,charge,charge,25856,root/html530/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html530/TEveTrackPropagator.html,3,['charge'],['charge']
Energy Efficiency," user data.; TEveVectorDfVStart vertex.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTrackPropagator(const char* n = ""TEveTrackPropagator"", const char* t = """", TEveMagField* field = 0, Bool_t own_field = kTRUE); Default constructor. ~TEveTrackPropagator(); Destructor. void OnZeroRefCount(); Virtual from TEveRefBackPtr - track reference count has reached zero. void CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); Check reference count - virtual from TEveElement.; Must also take into account references from TEveRefBackPtr. void ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); Element-change notification.; Stamp all tracks as requiring display-list regeneration.; Virtual from TEveElement. void InitTrack(const TEveVectorD& v, Int_t charge); Initialize internal data-members for given particle parameters. void InitTrack(const TEveVectorF& v, Int_t charge); TEveVectorF wrapper. void ResetTrack(); Reset cache holding particle trajectory. Int_t GetCurrentPoint() const; Get index of current point on track. Double_t GetTrackLength(Int_t start_point = 0, Int_t end_point = -1) const; Calculate track length from start_point to end_point.; If end_point is less than 0, distance to the end is returned. Bool_t GoToVertex(TEveVectorD& v, TEveVectorD& p); Propagate particle with momentum p to vertex v. Bool_t GoToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate particle with momentum p to line with start point s and vector r to the second point. Bool_t GoToVertex(TEveVectorF& v, TEveVectorF& p); TEveVectorF wrapper. Bool_t GoToLineSegment(const TEveVectorF& s, const TEveVectorF& r, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveTrackPropagator.html:26934,charge,charge,26934,root/html534/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html,2,['charge'],['charge']
Energy Efficiency," using ProjWData as; # a RooSimultaneous makes no prediction on the shape in the index category and; # can thus not be integrated. In other words: Since the PDF doesn't know the; # number of events in the different category states, it doesn't know how much; # of each component it has to project out. This info is read from the data.; simPdf.plotOn(frame1, Slice=(sample, ""physics""), ProjWData=(sample, combData)); simPdf.plotOn(frame1, Slice=(sample, ""physics""), Components=""px"", ProjWData=(sample, combData), LineStyle=""--""); ; # The same plot for the control sample slice. We do this with a different; # approach this time, for illustration purposes. Here, we are slicing the; # dataset and then use the data slice for the projection, because then the; # RooFit::Slice() becomes unnecessary. This approach is more general,; # because you can plot sums of slices by using logical or in the Cut(); # command.; frame2 = x.frame(Title=""Control sample""); slicedData = combData.reduce(Cut=""sample==sample::control""); slicedData.plotOn(frame2); simPdf.plotOn(frame2, ProjWData=(sample, slicedData)); simPdf.plotOn(frame2, Components=""px_ctl"", ProjWData=(sample, slicedData), LineStyle=""--""); ; # The same plot for all the phase space. Here, we can just use the original; # combined dataset.; frame3 = x.frame(Title=""Both samples""); combData.plotOn(frame3); simPdf.plotOn(frame3, ProjWData=(sample, combData)); simPdf.plotOn(frame3, Components=""px,px_ctl"", ProjWData=(sample, combData), LineStyle=""--""); ; c = ROOT.TCanvas(""rf501_simultaneouspdf"", ""rf501_simultaneouspdf"", 1200, 400); c.Divide(3); ; ; def draw(i, frame):; c.cd(i); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; ; draw(1, frame1); draw(2, frame2); draw(3, frame3); ; c.SaveAs(""rf501_simultaneouspdf.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(simPdf) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mav",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html:4461,reduce,reduce,4461,doc/master/rf501__simultaneouspdf_8py.html,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html,1,['reduce'],['reduce']
Energy Efficiency," using a zero pointer in old versions of root.; In versions of ROOT older than 4.00/03, if a collection (TClonesArray; or STL container) was split but the pointer to the collection was zeroed; out, nothing was saved. Hence there is no __easy__ way to detect the; case. In newer versions, a zero is written so that a 'missing' collection; appears to be an empty collection. void Print(Option_t* option = """") const; Print branch parameters. void PrintValue(Int_t i) const; -- Prints values of leaves. void ReadLeaves(TBuffer& b); -- Read leaves into i/o buffers for this branch. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); -- Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranchElement.html:23670,allocate,allocated,23670,root/html526/TBranchElement.html,https://root.cern,https://root.cern/root/html526/TBranchElement.html,1,['allocate'],['allocated']
Energy Efficiency," using namespace RooFit;; ; RooDataSet *makeFakeDataXY();; ; void rf303_conditional(); {; // S e t u p c o m p o s e d m o d e l g a u s s ( x , m ( y ) , s ); // -----------------------------------------------------------------------; ; // Create observables; RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar y(""y"", ""y"", -10, 10);; ; // Create function f(y) = a0 + a1*y; RooRealVar a0(""a0"", ""a0"", -0.5, -5, 5);; RooRealVar a1(""a1"", ""a1"", -0.5, -1, 1);; RooPolyVar fy(""fy"", ""fy"", y, RooArgSet(a0, a1));; ; // Create gauss(x,f(y),s); RooRealVar sigma(""sigma"", ""width of gaussian"", 0.5, 0.1, 2.0);; RooGaussian model(""model"", ""Gaussian with shifting mean"", x, fy, sigma);; ; // Obtain fake external experimental dataset with values for x and y; RooDataSet *expDataXY = makeFakeDataXY();; ; // G e n e r a t e d a t a f r o m c o n d i t i o n a l p . d . f m o d e l ( x | y ); // ---------------------------------------------------------------------------------------------; ; // Make subset of experimental data with only y values; std::unique_ptr<RooAbsData> expAbsDataY{expDataXY->reduce(y)};; RooDataSet *expDataY = static_cast<RooDataSet*>(expAbsDataY.get());; ; // Generate 10000 events in x obtained from _conditional_ model(x|y) with y values taken from experimental data; std::unique_ptr<RooDataSet> data{model.generate(x, ProtoData(*expDataY))};; data->Print();; ; // F i t c o n d i t i o n a l p . d . f m o d e l ( x | y ) t o d a t a; // ---------------------------------------------------------------------------------------------; ; model.fitTo(*expDataXY, ConditionalObservables(y), PrintLevel(-1));; ; // P r o j e c t c o n d i t i o n a l p . d . f o n x a n d y d i m e n s i o n s; // ---------------------------------------------------------------------------------------------; ; // Plot x distribution of data and projection of model on x = 1/Ndata sum(data(y_i)) model(x;y_i); RooPlot *xframe = x.frame();; expDataXY->plotOn(xframe);; model.plotOn(xframe, ProjWData(*expDataY));;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf303__conditional_8C.html:1686,reduce,reduce,1686,doc/master/rf303__conditional_8C.html,https://root.cern,https://root.cern/doc/master/rf303__conditional_8C.html,1,['reduce'],['reduce']
Energy Efficiency," version 2 *; 11 * of the License, or (at your option) any later version. *; 12 * *; 13 * This library is distributed in the hope that it will be useful, *; 14 * but WITHOUT ANY WARRANTY; without even the implied warranty of *; 15 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU *; 16 * General Public License for more details. *; 17 * *; 18 * You should have received a copy of the GNU General Public License *; 19 * along with this library (see file COPYING); if not, write *; 20 * to the Free Software Foundation, Inc., 59 Temple Place, Suite *; 21 * 330, Boston, MA 02111-1307 USA, or contact the author. *; 22 * *; 23 **********************************************************************/; 24 ; 25// Header file for class GSLFunctionAdapter; 26//; 27// Generic adapter for gsl_function signature; 28// usable for any c++ class which defines operator( ); 29//; 30// Created by: Lorenzo Moneta at Fri Nov 12 16:58:51 2004; 31//; 32// Last update: Fri Nov 12 16:58:51 2004; 33//; 34#ifndef ROOT_Math_GSLFunctionAdapter; 35#define ROOT_Math_GSLFunctionAdapter; 36 ; 37 ; 38namespace ROOT {; 39namespace Math {; 40 ; 41 /**; 42 Function pointer corresponding to gsl_function signature; 43 */; 44 ; 45 typedef double ( * GSLFuncPointer ) ( double, void *);; 46 ; 47 ; 48 /**; 49 Class for adapting any C++ functor class to C function pointers used by GSL.; 50 The templated C++ function class must implement:; 51 ; 52 <em> double operator( double x)</em>; 53 and if the derivatives are required:; 54 <em> double Gradient( double x)</em>; 55 ; 56 This class defines static methods with will be used to fill the; 57 \a gsl_function and \a gsl_function_fdf structs used by GSL.; 58 See for examples the <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_32.html#SEC432"">GSL online manual</A>; 59 */; 60 ; 61 ; 62 template<class UserFunc>; 63 class GSLFunctionAdapter {; 64 ; 65 public:; 66 ; 67 GSLFunctionAdapter() {}; 68 virtual ~GSLFunctionAdapter() {}; 69 ; 70 static double F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GSLFunctionAdapter_8h_source.html:1404,adapt,adapter,1404,doc/master/GSLFunctionAdapter_8h_source.html,https://root.cern,https://root.cern/doc/master/GSLFunctionAdapter_8h_source.html,2,['adapt'],"['adapter', 'adapting']"
Energy Efficiency," via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to a hexadecimal string.; This string can be directly passed to, for example,; TGClient::GetColorByName(). String will be reused so copy immediately; if needed.; ; . void SaveColor(ostream& out, Int_t ci). Save a color with index > 228 as a C++ statement(s) on output stream out.; ; . Bool_t IsGrayscale(). Return whether all colors return grayscale values.; ; . void SetGrayscale(Bool_t set = kTRUE). Set whether all colors should return grayscale values.; ; . Int_t CreateGradientColorTable(UInt_t Number, Double_t* Stops, Double_t* Red, Double_t* Green, Double_t* Blue, UInt_t NColors). Static function creating a color table with several connected linear gradients.; ; Number: The number of end point colors that will form the gradients.; Must be at least 2.; Stops: Where in the whole table the end point colors should lie.; Each entry must be on [0, 1], each entry must be greater than; the previous entry.; Red, Green, Blue: The end point color values.; Each entry must be on [0, 1]; NColors: Total number of colors in the table. Must be at least 1.; ; Returns a positive value on success and -1 on error.; ; The table is constructed by tracing lines between the given points in; RGB space. Each color value may have a value between 0 and 1. The; difference between consecutive ""Stops"" values gives the fraction of; space in the whole table that should be used for the interval between; the corresponding color values.; ; Normally the first element of Stops should be 0 and the last should be 1.; If this is not true, fewer than NColors will be used in proportion with; the total interval between the first and last elements of Stops.; ; This definition is similar to the povray-definition of gradient; color tables.; ; For instance:; ; UInt_t Number = 3;; Double_t Red[3] = { 0.0, 1.0, 1.0 };; Double_t Green[3] = { 0.0, 0.0, 1.0 };; Double_t Blue[3] = { 1.0, 0.0, 1.0 };; Double_t Stops[3] = { 0.0, 0.4, 1.0 };; ; This defines ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TColor.html:23246,Green,Green,23246,root/html532/TColor.html,https://root.cern,https://root.cern/root/html532/TColor.html,1,['Green'],['Green']
Energy Efficiency," via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::GradFunctor1D::Impl, ROOT::Math::IGradFunction, ROOT::Math::IParametricGradFunctionOneDim::BaseGradFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionOneDim&operator=(const ROOT::Math::IGradientFunctionOneDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionOneDim(). Virtual Destructor (no operations). {}. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IGradientFunctionOneDim.html:2268,efficient,efficient,2268,root/html526/ROOT__Math__IGradientFunctionOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IGradientFunctionOneDim.html,1,['efficient'],['efficient']
Energy Efficiency," via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::GradFunctor1D::Impl, ROOT::Math::IGradFunction, ROOT::Math::IParametricGradFunctionOneDim::BaseGradFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionOneDim&operator=(const ROOT::Math::IGradientFunctionOneDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionOneDim(). Virtual Destructor (no operations). {}. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__IGradientFunctionOneDim.html:2270,efficient,efficient,2270,root/html530/ROOT__Math__IGradientFunctionOneDim.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__IGradientFunctionOneDim.html,1,['efficient'],['efficient']
Energy Efficiency," via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionOneDim::BaseGradFunc, ROOT::Math::IGradFunction, ROOT::Math::GradFunctor1D::Impl. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionOneDim&operator=(const ROOT::Math::IGradientFunctionOneDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionOneDim(). Virtual Destructor (no operations). {}. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IGradientFunctionOneDim.html:2268,efficient,efficient,2268,root/html528/ROOT__Math__IGradientFunctionOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IGradientFunctionOneDim.html,1,['efficient'],['efficient']
Energy Efficiency," via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionOneDim::BaseGradFunc, ROOT::Math::IGradFunction, ROOT::Math::GradFunctor1D::Impl. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionOneDim&operator=(const ROOT::Math::IGradientFunctionOneDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionOneDim(). Virtual Destructor (no operations). {}. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IGradientFunctionOneDim.html:2270,efficient,efficient,2270,root/html532/ROOT__Math__IGradientFunctionOneDim.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IGradientFunctionOneDim.html,2,['efficient'],['efficient']
Energy Efficiency," virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLContextIdentity(); TGLContextIdentity(const TGLContextIdentity&). private:. voidCheckDestroy(). Data Members; protected:. TGLFontManager*fFontManagerFreeType font manager. private:. Int_tfClientCnt; Int_tfCnt; TGLContextIdentity::CtxList_tfCtxs; TGLContextIdentity::DLTrash_tfDLTrash; static TGLContextIdentity*fgDefaultIdentity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLContextIdentity(); Constructor. ~TGLContextIdentity(); Destructor. void AddRef(TGLContext* ctx); Add context ctx to the list of references. void Release(TGLContext* ctx); Remove context ctx from the list of references. void RegisterDLNameRangeToWipe(UInt_t base, Int_t size); Remember dl range for deletion in next MakeCurrent or dtor execution. void DeleteGLResources(); Delete GL resources registered for destruction. TGLContextIdentity* GetCurrent(); Find identitfy of current context. Static. TGLContextIdentity* GetDefaultIdentity(); Get identity of a default Gl context. Static. TGLContext* GetDefaultContextAny(); Get the first GL context with the default identity.; Can return zero, but that's OK, too. Static. TGLFontManager* GetFontManager(); Get the free-type font-manager associated with this context-identity. void CheckDestroy(); Private function called when reference count is reduced. Bool_t IsValid() const; { return fValid; }. TGLContextIdentity(). void AddClientRef(); { ++fClientCnt; }. void ReleaseClient(); { --fClientCnt; CheckDestroy(); }. Int_t GetRefCnt() const; { return fCnt; }. Int_t GetClientRefCnt() const; { return fClientCnt; }. » Author: Timur Pocheptsov, Jun 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-02 15:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLContextIdentity.html:2503,reduce,reduced,2503,root/html604/TGLContextIdentity.html,https://root.cern,https://root.cern/root/html604/TGLContextIdentity.html,2,['reduce'],['reduced']
Energy Efficiency," virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLContextIdentity(); TGLContextIdentity(const TGLContextIdentity&). private:. voidCheckDestroy(). Data Members; protected:. TGLFontManager*fFontManagerFreeType font manager. private:. Int_tfClientCnt; Int_tfCnt; TGLContextIdentity::CtxList_tfCtxs; TGLContextIdentity::DLTrash_tfDLTrash; static TGLContextIdentity*fgDefaultIdentity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLContextIdentity(); Constructor. ~TGLContextIdentity(); Destructor. void AddRef(TGLContext* ctx); Add context ctx to the list of references. void Release(TGLContext* ctx); Remove context ctx from the list of references. void RegisterDLNameRangeToWipe(UInt_t base, Int_t size); Remember dl range for deletion in next MakeCurrent or dtor execution. void DeleteGLResources(); Delete GL resources registered for destruction. TGLContextIdentity* GetCurrent(); Find identitfy of current context. Static. TGLContextIdentity* GetDefaultIdentity(); Get identity of a default Gl context. Static. TGLContext* GetDefaultContextAny(); Get the first GL context with the default identity.; Can return zero, but that's OK, too. Static. TGLFontManager* GetFontManager(); Get the free-type font-manager associated with this context-identity. void CheckDestroy(); Private function called when reference count is reduced. Bool_t IsValid() const; { return fValid; }. TGLContextIdentity(). void AddClientRef(); { ++fClientCnt; }. void ReleaseClient(); { --fClientCnt; CheckDestroy(); }. Int_t GetRefCnt() const; { return fCnt; }. Int_t GetClientRefCnt() const; { return fClientCnt; }. » Author: Timur Pocheptsov, Jun 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLContextIdentity.html:2503,reduce,reduced,2503,root/html602/TGLContextIdentity.html,https://root.cern,https://root.cern/root/html602/TGLContextIdentity.html,2,['reduce'],['reduced']
Energy Efficiency," virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTMVA::MethodBase::IsSignalLike(); virtual Bool_tTMVA::MethodBase::IsSignalLike(Double_t mvaVal); virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTMVA::MethodBase::MakeClass(const TString& classFileName = TString("""")) const; voidTObject::MayNotUse(const char* method) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; TMVA::MethodKNNMethodKNN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodKNNMethodKNN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""KNN"", TDirectory* theTargetDir = NULL); virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodKNN.html:8188,Monitor,MonitorBoost,8188,root/html532/TMVA__MethodKNN.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodKNN.html,1,['Monitor'],['MonitorBoost']
Energy Efficiency," virtual~TDatabasePDG(); voidTObject::AbstractMethod(const char* method) const; virtual TParticlePDG*AddAntiParticle(const char* Name, Int_t PdgCode); virtual TParticlePDG*AddParticle(const char* Name, const char* Title, Double_t Mass, Bool_t Stable, Double_t DecayWidth, Double_t Charge, const char* ParticleClass, Int_t PdgCode, Int_t Anti = -1, Int_t TrackingCode = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tConvertGeant3ToPdg(Int_t Geant3Number) const; virtual Int_tConvertIsajetToPdg(Int_t isaNumber) const; virtual Int_tConvertPdgToGeant3(Int_t pdgNumber) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDatabasePDG.html:1342,Charge,Charge,1342,root/html602/TDatabasePDG.html,https://root.cern,https://root.cern/root/html602/TDatabasePDG.html,2,['Charge'],['Charge']
Energy Efficiency," virtual~TEmulatedCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void* env); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE) const; virtual TVirtualCollectionProxy*Generate() const; virtual TClass*TGenCollectionProxy::GetCollectionClass() const; virtual Int_tTGenCollectionProxy::GetCollectionType() const; virtual TStreamerInfoActions::TActionSequence*TGenCollectionProxy::GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tTGenCollectionProxy::GetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tTGenCollectionProxy::GetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tTGenCollectionProxy::GetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tTGenCollectionProxy::GetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tTGenCollectionProxy::GetFunctionNext(Bool_t read = kTRUE); virtual ULong_tTGenCollectionPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEmulatedCollectionProxy.html:811,Allocate,Allocate,811,root/html602/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TEmulatedCollectionProxy.html,2,['Allocate'],['Allocate']
Energy Efficiency," virtual~TEmulatedMapProxy(); virtual void*TEmulatedCollectionProxy::Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidTEmulatedCollectionProxy::Clear(const char* opt = """"); virtual voidTEmulatedCollectionProxy::Commit(void* env); virtual voidTEmulatedCollectionProxy::DeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; virtual voidTEmulatedCollectionProxy::Destructor(void* p, Bool_t dtorOnly = kFALSE) const; virtual TVirtualCollectionProxy*Generate() const; virtual TClass*TGenCollectionProxy::GetCollectionClass() const; virtual Int_tTGenCollectionProxy::GetCollectionType() const; virtual TStreamerInfoActions::TActionSequence*TGenCollectionProxy::GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tTGenCollectionProxy::GetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tTGenCollectionProxy::GetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tTGenCollectionProxy::GetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tTGenCollectionProxy::GetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEmulatedMapProxy.html:807,Allocate,Allocate,807,root/html602/TEmulatedMapProxy.html,https://root.cern,https://root.cern/root/html602/TEmulatedMapProxy.html,2,['Allocate'],['Allocate']
Energy Efficiency," virtual~TEveMCTrack(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTParticle::Beauty() const; virtual voidTObject::Browse(TBrowser* b); Int_tTParticle::Charm() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTParticle::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; Double_tTParticle::Energy() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tTParticle::Eta() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTParticle::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTParticle::GetCalcMass() const; Int_tTParticle::GetDaughter(Int_t i) const; virtual Option_t*TObject::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveMCTrack.html:1326,Energy,Energy,1326,root/html602/TEveMCTrack.html,https://root.cern,https://root.cern/root/html602/TEveMCTrack.html,2,['Energy'],['Energy']
Energy Efficiency," virtual~TGenCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void* env); virtual voidTVirtualCollectionProxy::DeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; virtual voidTVirtualCollectionProxy::Destructor(void* p, Bool_t dtorOnly = kFALSE) const; virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass() const; virtual Int_tGetCollectionType() const; virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement() const; virtual TClass*GetOnFileClass() const; virtual Int_tTVirtualCollectionProxy::GetProperties() const; virtual TStreamerInfoActions::TActio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGenCollectionProxy.html:787,Allocate,Allocate,787,root/html602/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TGenCollectionProxy.html,2,['Allocate'],['Allocate']
Energy Efficiency," void *p=nullptr);  Set the function f for evaluating the derivative using a GSL function pointer type. ;  . — Static methods —; int fStatus;  ; double fResult;  ; double fError;  ; GSLFunctionWrapper fFunction;  ; int Status () const;  return the error status of the last integral calculation ;  ; double Result () const;  return the result of the last derivative calculation ;  ; double Error () const;  return the estimate of the absolute error of the last derivative calculation ;  ; static double EvalCentral (const IGenFunction &f, double x, double h);  Computes the numerical derivative of a function f at a point x using an adaptive central difference algorithm with a step size h. ;  ; static double EvalForward (const IGenFunction &f, double x, double h);  Computes the numerical derivative of a function f at a point x using an adaptive forward difference algorithm with a step size h. ;  ; static double EvalBackward (const IGenFunction &f, double x, double h);  Computes the numerical derivative of a function f at a point x using an adaptive backward difference algorithm with a step size h. ;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/math/mathmore/src/GSLDerivator.h>; Constructor & Destructor Documentation. ◆ GSLDerivator(). ROOT::Math::GSLDerivator::GSLDerivator ; (; ). inline . Default Constructor of a GSLDerivator class based on GSL numerical differentiation algorithms. ; Definition at line 68 of file GSLDerivator.h. ◆ ~GSLDerivator(). virtual ROOT::Math::GSLDerivator::~GSLDerivator ; (; ). inlinevirtual . destructor (no operations) ; Definition at line 71 of file GSLDerivator.h. Member Function Documentation. ◆ Error(). double ROOT::Math::GSLDerivator::Error ; (; ); const. return the estimate of the absolute error of the last derivative calculation ; Definition at line 111 of file GSLDerivator.cxx. ◆ EvalBackward() [1/2]. double ROOT::Math::GSLDerivator::EvalBackward ; (; const IGenFunction & ; f, . double ; x, . double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLDerivator.html:2450,adapt,adaptive,2450,doc/master/classROOT_1_1Math_1_1GSLDerivator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLDerivator.html,1,['adapt'],['adaptive']
Energy Efficiency," voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). private:. virtual void*GetSender(); voidSetReady(TSocket* sock). Data Members; public:. enum EInterest { kRead; kWrite; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMonitor.html:9712,monitor,monitor,9712,root/html528/TMonitor.html,https://root.cern,https://root.cern/root/html528/TMonitor.html,12,['monitor'],"['monitor', 'monitoring']"
Energy Efficiency," void ReadLeavesCollection (TBuffer &b);  Read leaves into i/o buffers for this branch. ;  ; void ReadLeavesCollectionMember (TBuffer &b);  Read leaves into i/o buffers for this branch. ;  ; void ReadLeavesCollectionSplitPtrMember (TBuffer &b);  Read leaves into i/o buffers for this branch. ;  ; void ReadLeavesCollectionSplitVectorPtrMember (TBuffer &b);  Read leaves into i/o buffers for this branch. ;  ; void ReadLeavesCustomStreamer (TBuffer &b);  Read leaves into i/o buffers for this branch. ;  ; void ReadLeavesImpl (TBuffer &b);  Unconfiguration Read Leave function. ;  ; void ReadLeavesMakeClass (TBuffer &b);  Read leaves into i/o buffers for this branch. ;  ; void ReadLeavesMember (TBuffer &b);  Read leaves into i/o buffers for this branch. ;  ; void ReadLeavesMemberBranchCount (TBuffer &b);  Read leaves into i/o buffers for this branch. ;  ; void ReadLeavesMemberCounter (TBuffer &b);  Read leaves into i/o buffers for this branch. ;  ; void ReleaseObject ();  Delete any object we may have allocated on a previous call to SetAddress. ;  ; void SetActionSequence (TClass *originalClass, TStreamerInfo *localInfo, TStreamerInfoActions::TActionSequence::SequenceGetter_t create, TStreamerInfoActions::TActionSequence *&actionSequence);  Set the sequence of actions needed to read the data out of the buffer. ;  ; void SetAddressImpl (void *addr, bool implied) override;  See TBranchElement::SetAddress. ;  ; void SetBranchCount (TBranchElement *bre);  Set the branch counter for this branch. ;  ; void SetBranchCount2 (TBranchElement *bre);  ; void SetFillActionSequence ();  Set the sequence of actions needed to write the data out from the buffer. ;  ; void SetFillLeavesPtr ();  Set the FillLeaves pointer to execute the expected operations. ;  ; void SetReadActionSequence ();  Set the sequence of actions needed to read the data out of the buffer. ;  ; void SetReadLeavesPtr ();  Set the ReadLeaves pointer to execute the expected operations. ;  ; void SetupAddressesImpl ();  If ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:30458,allocate,allocated,30458,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['allocate'],['allocated']
Energy Efficiency," w, . UInt_t ; h . ). virtual . Registers a pixmap created by TGLManager as a ROOT pixmap. ; Parameters. [in]pixidpixmap identifier ; [in]w,hthe width and height, which define the pixmap size . Reimplemented in TGCocoa, TGX11, and TGWin32.; Definition at line 561 of file TVirtualX.cxx. ◆ AddWindow(). Int_t TVirtualX::AddWindow ; (; ULongptr_t ; qwid, . UInt_t ; w, . UInt_t ; h . ). virtual . Registers a window created by Qt as a ROOT window. ; Parameters. [in]qwidwindow identifier ; [in]w,hthe width and height, which define the window size . Reimplemented in TGCocoa, TGX11, TGWin32, and TGWin32VirtualXProxy.; Definition at line 550 of file TVirtualX.cxx. ◆ AllocColor(). Bool_t TVirtualX::AllocColor ; (; Colormap_t ; cmap, . ColorStruct_t & ; color . ). virtual . Allocates a read-only colormap entry corresponding to the closest RGB value supported by the hardware. ; If no cell could be allocated it returns kFALSE, otherwise kTRUE.; The pixel value is set to default. Let system think we could allocate color.; Parameters. [in]cmapthe colormap ; [in]colorspecifies and returns the values actually used in the cmap . Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 113 of file TVirtualX.cxx. ◆ BeginModalSessionFor(). void TVirtualX::BeginModalSessionFor ; (; Window_t ; window). virtual . Start a modal session for a dialog window. ; Definition at line 2488 of file TVirtualX.cxx. ◆ Bell(). void TVirtualX::Bell ; (; Int_t ; percent). virtual . Sets the sound bell. Percent is loudness from -100% to 100%. ; Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 1517 of file TVirtualX.cxx. ◆ ChangeActivePointerGrab(). void TVirtualX::ChangeActivePointerGrab ; (; Window_t ; , . UInt_t ; , . Cursor_t ;  . ). virtual . Changes the specified dynamic parameters if the pointer is actively grabbed by the client and if the specified time is no earlier than the last-pointer-grab time and no later than the current X s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:50604,allocate,allocate,50604,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['allocate'],['allocate']
Energy Efficiency," weigths. void Mixture(Int_t& kmat, const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nlmat, Double_t* wmat). Defines mixture OR COMPOUND IMAT as composed by; THE BASIC NLMAT materials defined by arrays A,Z and WMAT. If NLMAT > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then WMAT contains the number of atoms; of a given kind into the molecule of the COMPOUND; In this case, WMAT in output is changed to relative; weigths. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoMCGeometry.html:12334,energy,energy,12334,root/html528/TGeoMCGeometry.html,https://root.cern,https://root.cern/root/html528/TGeoMCGeometry.html,10,['energy'],['energy']
Energy Efficiency," where range used was from data xmin to xmax.; 517 TH1 * h1 = mg->GetHistogram();; 518 if (h1) {; 519 HFit::GetDrawingRange(h1, range);; 520 }; 521 else if (range.Size(0) == 0) {; 522 // compute range from all the TGraph's belonging to the MultiGraph; 523 double xmin = std::numeric_limits<double>::infinity();; 524 double xmax = -std::numeric_limits<double>::infinity();; 525 TIter next(mg->GetListOfGraphs() );; 526 TGraph * g = nullptr;; 527 while ( (g = (TGraph*) next() ) ) {; 528 double x1 = 0, x2 = 0, y1 = 0, y2 = 0;; 529 g->ComputeRange(x1,y1,x2,y2);; 530 if (x1 < xmin) xmin = x1;; 531 if (x2 > xmax) xmax = x2;; 532 }; 533 range.AddRange(xmin,xmax);; 534 }; 535}; 536void HFit::GetDrawingRange(TGraph2D * gr, ROOT::Fit::DataRange & range) {; 537 // get range for graph2D (used sub-set histogram); 538 // N.B. : this is different than in previous implementation of TGraph2D::Fit. There range used was always(0,0); 539 // cannot use TGraph2D::GetHistogram which makes an interpolation; 540 //TH1 * h1 = gr->GetHistogram();; 541 //if (h1) HFit::GetDrawingRange(h1, range);; 542 // not very efficient (t.b.i.); 543 if (range.Size(0) == 0) {; 544 double xmin = gr->GetXmin();; 545 double xmax = gr->GetXmax();; 546 range.AddRange(0,xmin,xmax);; 547 }; 548 if (range.Size(1) == 0) {; 549 double ymin = gr->GetYmin();; 550 double ymax = gr->GetYmax();; 551 range.AddRange(1,ymin,ymax);; 552 }; 553}; 554 ; 555void HFit::GetDrawingRange(THnBase * s1, ROOT::Fit::DataRange & range) {; 556 // get range from histogram and update the DataRange class; 557 // if a ranges already exist in that dimension use that one; 558 ; 559 Int_t ndim = GetDimension(s1);; 560 ; 561 for ( int i = 0; i < ndim; ++i ) {; 562 if ( range.Size(i) == 0 ) {; 563 TAxis *axis = s1->GetAxis(i);; 564 range.AddRange(i, axis->GetXmin(), axis->GetXmax());; 565 }; 566 }; 567}; 568 ; 569template<class FitObject>; 570void HFit::StoreAndDrawFitFunction(FitObject * h1, TF1 * f1, const ROOT::Fit::DataRange & range, bool delOldFun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitImpl_8cxx_source.html:20627,efficient,efficient,20627,doc/master/HFitImpl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitImpl_8cxx_source.html,1,['efficient'],['efficient']
Energy Efficiency," white pixel in colormap. private:. TExMap*fColorsHash list of colors; CursorfCursors[19]List of cursors; Int_tfMaxNumberOfWindowsMaximum number of windows; XWindow_t*fWindowsList of windows; void*fXEventCurrent native (X11) event. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGX11(); Default constructor. TGX11(const char* name, const char* title); Normal Constructor. TGX11(const TGX11& org); Copy constructor. Currently only used by TGX11TTF. ~TGX11(); Destructor. Bool_t Init(void* display); Initialize X11 system. Returns kFALSE in case of failure. Bool_t AllocColor(Colormap cmap, RXColor* color); Allocate color in colormap. If we are on an <= 8 plane machine; we will use XAllocColor. If we are on a >= 15 (15, 16 or 24) plane; true color machine we will calculate the pixel value using:; for 15 and 16 bit true colors have 6 bits precision per color however; only the 5 most significant bits are used in the color index.; Except for 16 bits where green uses all 6 bits. I.e.:; 15 bits = rrrrrgggggbbbbb; 16 bits = rrrrrggggggbbbbb; for 24 bits each r, g and b are represented by 8 bits. Since all colors are set with a max of 65535 (16 bits) per r, g, b; we just right shift them by 10, 11 and 10 bits for 16 planes, and; (10, 10, 10 for 15 planes) and by 8 bits for 24 planes.; Returns kFALSE in case color allocation failed. void QueryColors(Colormap cmap, RXColor* colors, Int_t ncolors); Returns the current RGB value for the pixel in the XColor structure. void ClearPixmap(Drawable* pix); Clear the pixmap pix. void ClearWindow(); Clear current window. void ClosePixmap(); Delete current pixmap. void CloseWindow(); Delete current window. void CloseWindow1(); Delete current window. void CopyPixmap(Int_t wid, Int_t xpos, Int_t ypos); Copy the pixmap wid at the position xpos, ypos in the current window. void CopyWindowtoPixmap(Drawable* pix, Int_t xpos, Int_t ypos); Copy area of current window in the pixmap pix. void DrawBox(Int_t x1, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGX11.html:27043,green,green,27043,root/html602/TGX11.html,https://root.cern,https://root.cern/root/html602/TGX11.html,4,['green'],['green']
Energy Efficiency," with ROOT dataframes. The NanoAOD-like input files are filled with 66 mio. events from CMS OpenData containing muon candidates part of 2012 dataset (DOI: 10.7483/OPENDATA.CMS.YLIC.86ZZ and DOI: 10.7483/OPENDATA.CMS.M5AD.Y3V3). The macro matches muon pairs and produces an histogram of the dimuon mass spectrum showing resonances up to the Z mass. Note that the bump at 30 GeV is not a resonance but a trigger effect.; More details about the dataset can be found on the CERN Open Data portal. ; import ROOT; ; # Enable multi-threading; ROOT.ROOT.EnableImplicitMT(); ; # Create dataframe from NanoAOD files; df = ROOT.RDataFrame(""Events"", ""root://eospublic.cern.ch//eos/opendata/cms/derived-data/AOD2NanoAODOutreachTool/Run2012BC_DoubleMuParked_Muons.root""); ; # For simplicity, select only events with exactly two muons and require opposite charge; df_2mu = df.Filter(""nMuon == 2"", ""Events with exactly two muons""); df_os = df_2mu.Filter(""Muon_charge[0] != Muon_charge[1]"", ""Muons with opposite charge""); ; # Compute invariant mass of the dimuon system; df_mass = df_os.Define(""Dimuon_mass"", ""InvariantMass(Muon_pt, Muon_eta, Muon_phi, Muon_mass)""); ; # Make histogram of dimuon mass spectrum. Note how we can set titles and axis labels in one go.; h = df_mass.Histo1D((""Dimuon_mass"", ""Dimuon mass;m_{#mu#mu} (GeV);N_{Events}"", 30000, 0.25, 300), ""Dimuon_mass""); ; # Request cut-flow report; report = df_mass.Report(); ; # Produce plot; ROOT.gStyle.SetOptStat(0); ROOT.gStyle.SetTextFont(42); c = ROOT.TCanvas(""c"", """", 800, 700); c.SetLogx(); c.SetLogy(); ; h.SetTitle(""""); h.GetXaxis().SetTitleSize(0.04); h.GetYaxis().SetTitleSize(0.04); h.Draw(); ; label = ROOT.TLatex(); label.SetNDC(True); label.DrawLatex(0.175, 0.740, ""#eta""); label.DrawLatex(0.205, 0.775, ""#rho,#omega""); label.DrawLatex(0.270, 0.740, ""#phi""); label.DrawLatex(0.400, 0.800, ""J/#psi""); label.DrawLatex(0.415, 0.670, ""#psi'""); label.DrawLatex(0.485, 0.700, ""Y(1,2,3S)""); label.DrawLatex(0.755, 0.680, ""Z""); label.SetTextSize(0.0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8py.html:1383,charge,charge,1383,doc/master/df102__NanoAODDimuonAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8py.html,1,['charge'],['charge']
Energy Efficiency," with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and; 51ROOT::Math::IntegratorMultiDimOptions classes.; 52 ; 53@ingroup NumAlgo; 54 ; 55*/; 56 ; 57 ; 58 ; 59namespace ROOT {; 60namespace Math {; 61 ; 62 ; 63 ; 64 ; 65//____________________________________________________________________________________________; 66/**; 67 ; 68User Class for performing numerical integration of a function in one dimension.; 69It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; 70algorithms used in the QUADPACK, a numerical integration package written in Fortran.; 71 ; 72Various types of adaptive and non-adaptive integration are supported. These include; 73integration over infinite and semi-infinite ranges and singular integrals.; 74 ; 75The integration type is selected using the Integration::type enumeration; 76in the class constructor.; 77The default type is adaptive integration with singularity; 78(ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; 79In the case of ADAPTIVE type, the integration rule can also be specified via the; 80Integration::GKRule. The default rule is 31 points.; 81 ; 82In the case of integration over infinite and semi-infinite ranges, the type used is always; 83ADAPTIVESINGULAR applying a transformation from the original interval into (0,1).; 84 ; 85The ADAPTIVESINGULAR type is the most sophisticated type. When performances are; 86important, it is then recommended to use the NONADAPTIVE type in case of smooth functions or; 87 ADAPTIVE with a lower Gauss-Kronrod rule.; 88 ; 89For detailed description on GSL integration algorithms see the; 90<A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>.; 91 ; 92 ; 93@ingroup Integration; 94 ; 95*/; 96 ; 97 ; 98class IntegratorOneDim {; 99 ; 100public:; 101 ; 102 typedef IntegrationOneDim::Type Type; // for the enumerations defining the types; 103 ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Integrator_8h_source.html:2651,adapt,adaptive,2651,doc/master/Integrator_8h_source.html,https://root.cern,https://root.cern/doc/master/Integrator_8h_source.html,1,['adapt'],['adaptive']
Energy Efficiency," with the Library, with the complete machine-readable ""work that; uses the Library"", as object code and/or source code, so that the; user can modify the Library and then relink to produce a modified; executable containing the modified Library. (It is understood; that the user who changes the contents of definitions files in the; Library will not necessarily be able to recompile the application; to use the modified definitions.). b) Use a suitable shared library mechanism for linking with the; Library. A suitable mechanism is one that (1) uses at run time a; copy of the library already present on the user's computer system,; rather than copying library functions into the executable, and (2); will operate properly with a modified version of the library, if; the user installs one, as long as the modified version is; interface-compatible with the version that the work was made with. c) Accompany the work with a written offer, valid for at; least three years, to give the same user the materials; specified in Subsection 6a, above, for a charge no more; than the cost of performing this distribution. d) If distribution of the work is made by offering access to copy; from a designated place, offer equivalent access to copy the above; specified materials from the same place. e) Verify that the user has already received a copy of these; materials or that you have already sent this user a copy. For an executable, the required form of the ""work that uses the; Library"" must include any data and utility programs needed for; reproducing the executable from it. However, as a special exception,; the materials to be distributed need not include anything that is; normally distributed (in either source or binary form) with the major; components (compiler, kernel, and so on) of the operating system on; which the executable runs, unless that component itself accompanies; the executable. It may happen that this requirement contradicts the license; restrictions of other proprietary librarie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/license.html:18551,charge,charge,18551,d/license.html,https://root.cern,https://root.cern/d/license.html,1,['charge'],['charge']
Energy Efficiency," with the rest of the framework.; More consistent and modular code - the code reuse provides consistency and common capabilities between programs, no matter who writes them. Frameworks make it easier to break programs into smaller pieces.; More focus on areas of expertise - users can concentrate on their particular problem domain. They do not have to be experts at writing user interfaces, graphics, or networking to use the frameworks that provide those services. 1.4.2 Why Object-Oriented?; Object-Oriented Programming offers considerable benefits compared to Procedure-Oriented Programming:. Encapsulation enforces data abstraction and increases opportunity for reuse.; Sub classing and inheritance make it possible to extend and modify objects.; Class hierarchies and containment containment hierarchies provide a flexible mechanism for modeling real-world objects and the relationships among them.; Complexity is reduced because there is little growth of the global state, the state is contained within each object, rather than scattered through the program in the form of global variables.; Objects may come and go, but the basic structure of the program remains relatively static, increases opportunity for reuse of design. 1.5 Installing ROOT. To install ROOT you have the choice to download the binaries or the source. The source is quicker to transfer since it is only ~22 MB, but you will need to compile and link it. The binaries compiled with no debug information range from ~35 MB to ~45 MB depending on the target platform.; The installation and building of ROOT is described in Appendix A: Install and Build ROOT. You can download the binaries, or the source. The GNU g++ compiler on most UNIX platforms can compile ROOT.; Before downloading a binary version make sure your machine contains the right run-time environment. In most cases it is not possible to run a version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is installed. In such cases you’ll have to instal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:14129,reduce,reduced,14129,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['reduce'],['reduced']
Energy Efficiency," within a TClonesArray (fType == 31). void ReadLeavesMember(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are not a counter. void ReadLeavesMemberBranchCount(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do have a branch count and are not a counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void FillLeavesImpl(TBuffer& b); -- Unconfiguration Fill Leave function. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBranchElement.html:30312,allocate,allocated,30312,root/html532/TBranchElement.html,https://root.cern,https://root.cern/root/html532/TBranchElement.html,8,['allocate'],['allocated']
Energy Efficiency," would invalidate Kolmogorov's theorem). The solution is to just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t R = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than 10^(-r).; r can be set by the the user subject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMath.html:21020,adapt,adapted,21020,root/html528/TMath.html,https://root.cern,https://root.cern/root/html528/TMath.html,2,['adapt'],['adapted']
Energy Efficiency," would invalidate Kolmogorov's theorem). The solution is to just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than 10^(-r).; r can be set by the the user subject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMath.html:21120,adapt,adapted,21120,root/html532/TMath.html,https://root.cern,https://root.cern/root/html532/TMath.html,4,['adapt'],['adapted']
Energy Efficiency," would invalidate Kolmogorov's theorem). The solution is to just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than 10^(-r).; r can be set by the the user subject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubic(const Double_t[4] coef, Double_t& a, Double_t& b, Double_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMath.html:15828,adapt,adapted,15828,root/html602/TMath.html,https://root.cern,https://root.cern/root/html602/TMath.html,4,['adapt'],['adapted']
Energy Efficiency," x using an adaptive forward difference algorithm with a step size h. ;  ; void SetFunction (const IGenFunction &f);  Set the function for calculating the derivatives. ;  ; void SetFunction (GSLFuncPointer f, void *p=nullptr);  Set the function f for evaluating the derivative using a GSL function pointer type. ;  . — Static methods —; int fStatus;  ; double fResult;  ; double fError;  ; GSLFunctionWrapper fFunction;  ; int Status () const;  return the error status of the last integral calculation ;  ; double Result () const;  return the result of the last derivative calculation ;  ; double Error () const;  return the estimate of the absolute error of the last derivative calculation ;  ; static double EvalCentral (const IGenFunction &f, double x, double h);  Computes the numerical derivative of a function f at a point x using an adaptive central difference algorithm with a step size h. ;  ; static double EvalForward (const IGenFunction &f, double x, double h);  Computes the numerical derivative of a function f at a point x using an adaptive forward difference algorithm with a step size h. ;  ; static double EvalBackward (const IGenFunction &f, double x, double h);  Computes the numerical derivative of a function f at a point x using an adaptive backward difference algorithm with a step size h. ;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/math/mathmore/src/GSLDerivator.h>; Constructor & Destructor Documentation. ◆ GSLDerivator(). ROOT::Math::GSLDerivator::GSLDerivator ; (; ). inline . Default Constructor of a GSLDerivator class based on GSL numerical differentiation algorithms. ; Definition at line 68 of file GSLDerivator.h. ◆ ~GSLDerivator(). virtual ROOT::Math::GSLDerivator::~GSLDerivator ; (; ). inlinevirtual . destructor (no operations) ; Definition at line 71 of file GSLDerivator.h. Member Function Documentation. ◆ Error(). double ROOT::Math::GSLDerivator::Error ; (; ); const. return the estimate of the absolute error o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLDerivator.html:2242,adapt,adaptive,2242,doc/master/classROOT_1_1Math_1_1GSLDerivator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLDerivator.html,1,['adapt'],['adaptive']
Energy Efficiency," x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; in each interval (x(i),x(i+1)) the spline function s(xx) is a polynomial of fifth degree: s(xx) = ((((f(i)*p+e(i))*p+d(i))*p+c(i))*p+b(i))*p+y(i) (*); = ((((-f(i)*q+e(i+1))*q-d(i+1))*q+c(i+1))*q-b(i+1))*q+y(i+1); d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; e#define e(i)Definition RSha256.hxx:103; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; qfloat * qDefinition THbookFile.cxx:89; where p = xx - x(i) and q = x(i+1) - xx. (note the first subscript in the second expression.) the different polynomials are pieced together so that s(x) and its derivatives up to s"""" are continuous. input:; n number of data points, (at least three, i.e. n > 2); x(1:n) the strictly increasing or decreasing sequence of; knots. the spacing must be such that the fifth power; of x(i+1) - x(i) can be formed without overflow or; underflow of exponents.; y(1:n) the prescribed function values at the knots.; ; output:; b,c,d,e,f the computed spline coefficients as in (*).; (1:n) specifically; b(i) = s'(x(i)), c(i) = s""(x(i))/2, d(i) = s""'(x(i))/6,; e(i) = s""""(x(i))/24, f(i) = s""""'(x(i))/120.; f(n) is neither used nor altered. the five arrays; b,c,d,e,f must always be distinct.; ; option:; it is possible to specify values for the first and second; derivatives of the spline function at arbitrarily many knots.; this is done by relaxing the requirement that the sequence of; knots be strictly increasing or decreasing. specifically:; if x(j) = x(j+1) then s(x(j)) = y(j) and s'(x(j)) = y(j+1),; if x(j) = x(j+1) = x(j+2) then in addition s""(x(j)) = y(j+2).; note that s""""(x) is discontinuous at a double knot and, in; addition, s""'(x) is discontinuous at a triple knot. the; subroutine assigns y(i) to y(i+1) in these cases and also to; y(i+2) at a triple knot. the representation (*) rem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpline5.html:26111,power,power,26111,doc/master/classTSpline5.html,https://root.cern,https://root.cern/doc/master/classTSpline5.html,1,['power'],['power']
Energy Efficiency," y, c); print(type(x)); d.add({x, y, c}); ; d.Print(""v""); print(""""); ; # The get() function returns a pointer to the internal copy of the RooArgSet(x,y,c); # supplied in the constructor; row = d.get(); row.Print(""v""); print(""""); ; # Get with an argument loads a specific data point in row and returns; # a pointer to row argset. get() always returns the same pointer, unless; # an invalid row number is specified. In that case a null ptr is returned; d.get(900).Print(""v""); print(""""); ; # Reducing, appending and merging; # -------------------------------------------------------------; ; # The reduce() function returns a dataset which is a subset of the; # original; print(""\n >> d1 has only columns x,c""); d1 = d.reduce({x, c}); d1.Print(""v""); ; print(""\n >> d2 has only column y""); d2 = d.reduce({y}); d2.Print(""v""); ; print(""\n >> d3 has only the points with y>5.17""); d3 = d.reduce(""y>5.17""); d3.Print(""v""); ; print(""\n >> d4 has only columns x, for data points with y>5.17""); d4 = d.reduce({x, c}, ""y>5.17""); d4.Print(""v""); ; # The merge() function adds two data set column-wise; print(""\n >> merge d2(y) with d1(x,c) to form d1(x,c,y)""); d1.merge(d2); d1.Print(""v""); ; # The append() function adds two datasets row-wise; print(""\n >> append data points of d3 to d1""); d1.append(d3); d1.Print(""v""); ; # Operations on binned datasets; # ---------------------------------------------------------; ; # A binned dataset can be constructed empty, an unbinned dataset, or; # from a ROOT native histogram (TH1,2,3); ; print("">> construct dh (binned) from d(unbinned) but only take the x and y dimensions, ""); print("">> the category 'c' will be projected in the filling process""); ; # The binning of real variables (like x,y) is done using their fit range; # 'get/setRange()' and number of specified fit bins 'get/setBins()'.; # Category dimensions of binned datasets get one bin per defined category; # state; x.setBins(10); y.setBins(10); dh = ROOT.RooDataHist(""dh"", ""binned version of d"", {x, y}, d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf402__datahandling_8py.html:2588,reduce,reduce,2588,doc/master/rf402__datahandling_8py.html,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8py.html,1,['reduce'],['reduce']
Energy Efficiency," yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; T2#define T2Definition md5.inl:147; T7#define T7Definition md5.inl:152; T6#define T6Definition md5.inl:151; T3#define T3Definition md5.inl:148; T5#define T5Definition md5.inl:150; T4#define T4Definition md5.inl:149; F#define F(x, y, z); I#define I(x, y, z); T1#define T1Definition md5.inl:146; ROOT::Detail::VecOps::IsSmallbool IsSmall(const ROOT::VecOps::RVec< T > &v)Definition RVec.hxx:1118; ROOT::Detail::VecOps::IsAdoptingbool IsAdopting(const ROOT::VecOps::RVec< T > &v)Definition RVec.hxx:1124; ROOT::Internal::VecOps::MapImplauto MapImpl(F &&f, RVecs &&... vs) -> RVec< decltype(f(vs[0]...))>Definition RVec.hxx:105; ROOT::Internal::VecOps::ResetViewvoid ResetView(RVec< T > &v, T *addr, std::size_t sz)An unsafe function to reset the buffer for which this RVec is acting as a view.Definition RVec.hxx:546; ROOT::Internal::VecOps::NextPowerOf2uint64_t NextPowerOf2(uint64_t A)Return the next power of two (in 64-bits) that is strictly greater than A.Definition RVec.hxx:126; ROOT::Internal::VecOps::Allconstexpr bool All(const bool *vals, std::size_t size)Definition RVec.hxx:79; ROOT::Internal::VecOps::GetVectorsSizestd::size_t GetVectorsSize(const std::string &id, const RVec< T > &... vs)Definition RVec.hxx:88; ROOT::Internal::VecOps::UninitializedValueConstructvoid UninitializedValueConstruct(ForwardIt first, ForwardIt last)Definition RVec.hxx:530; ROOT::Internal::VecOps::MapFromTupleauto MapFromTuple(Tuple_t &&t, std::index_sequence< Is... >) -> decltype(MapImpl(std::get< std::tuple_size< Tuple_t >::value - 1 >(t), std::get< Is >(t)...))Definition RVec.hxx:117; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; Dot#define Dot(u, v)Definition normal.c:49; v2@ v2Definition rootcling_impl.cxx:3690; v0@ v0Definition rootcling_impl.cxx:3688; v@ vDefinition rootcling_imp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RVec_8hxx_source.html:150558,power,power,150558,doc/v632/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RVec_8hxx_source.html,1,['power'],['power']
Energy Efficiency," yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; T2#define T2Definition md5.inl:147; T7#define T7Definition md5.inl:152; T6#define T6Definition md5.inl:151; T3#define T3Definition md5.inl:148; T5#define T5Definition md5.inl:150; T4#define T4Definition md5.inl:149; F#define F(x, y, z); I#define I(x, y, z); T1#define T1Definition md5.inl:146; ROOT::Detail::VecOps::IsSmallbool IsSmall(const ROOT::VecOps::RVec< T > &v)Definition RVec.hxx:1118; ROOT::Detail::VecOps::IsAdoptingbool IsAdopting(const ROOT::VecOps::RVec< T > &v)Definition RVec.hxx:1124; ROOT::Internal::VecOps::MapImplauto MapImpl(F &&f, RVecs &&... vs) -> RVec< decltype(f(vs[0]...))>Definition RVec.hxx:105; ROOT::Internal::VecOps::ResetViewvoid ResetView(RVec< T > &v, T *addr, std::size_t sz)An unsafe function to reset the buffer for which this RVec is acting as a view.Definition RVec.hxx:546; ROOT::Internal::VecOps::NextPowerOf2uint64_t NextPowerOf2(uint64_t A)Return the next power of two (in 64-bits) that is strictly greater than A.Definition RVec.hxx:126; ROOT::Internal::VecOps::Allconstexpr bool All(const bool *vals, std::size_t size)Definition RVec.hxx:79; ROOT::Internal::VecOps::GetVectorsSizestd::size_t GetVectorsSize(const std::string &id, const RVec< T > &... vs)Definition RVec.hxx:88; ROOT::Internal::VecOps::UninitializedValueConstructvoid UninitializedValueConstruct(ForwardIt first, ForwardIt last)Definition RVec.hxx:530; ROOT::Internal::VecOps::MapFromTupleauto MapFromTuple(Tuple_t &&t, std::index_sequence< Is... >) -> decltype(MapImpl(std::get< std::tuple_size< Tuple_t >::value - 1 >(t), std::get< Is >(t)...))Definition RVec.hxx:117; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; Dot#define Dot(u, v)Definition normal.c:49; v2@ v2Definition rootcling_impl.cxx:3702; v0@ v0Definition rootcling_impl.cxx:3700; v@ vDefinition rootcling_imp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:154983,power,power,154983,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,1,['power'],['power']
Energy Efficiency," yw); This function defines a path with xw and yw and draw it according the; value of nn:. If nn>0 a line is drawn.; If nn<0 a closed polygon is drawn. void NewPage(); Start the TeX page. This function starts the tikzpicture environment. void Range(Float_t xrange, Float_t yrange); Set the range for the paper in centimetres. void SetFillColor(Color_t cindex = 1); Set color index for fill areas. void SetLineColor(Color_t cindex = 1); Set color index for lines. void SetLineStyle(Style_t linestyle = 1); Change the line style. linestyle = 2 dashed; = 3 dotted; = 4 dash-dotted; = else solid (1 in is used most of the time). void SetLineWidth(Width_t linewidth = 1); Set the lines width. void SetMarkerSize(Size_t msize = 1); Set size for markers. void SetMarkerColor(Color_t cindex = 1); Set color index for markers. void SetColor(Int_t color = 1); Set color with its color index. void SetColor(Float_t r, Float_t g, Float_t b); Set color with its R G B components. r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1]. void SetTextColor(Color_t cindex = 1); Set color index for text. void Text(Double_t x, Double_t y, const char* string); Draw text. xx: x position of the text; yy: y position of the text; chars: text to be drawn. void TextNDC(Double_t u, Double_t v, const char* string); Write a string of characters in NDC. Float_t UtoTeX(Double_t u); Convert U from NDC coordinate to TeX. Float_t VtoTeX(Double_t v); Convert V from NDC coordinate to TeX. Float_t XtoTeX(Double_t x); Convert X from world coordinate to TeX. Float_t YtoTeX(Double_t y); Convert Y from world coordinate to TeX. void CellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); Begin the Cell Array painting. void CellArrayFill(Int_t r, Int_t g, Int_t b); Paint the Cell Array. void CellArrayEnd(); End the Cell Array painting. void DrawPS(Int_t n, Float_t* xw, Float_t* yw); Not needed in TeX case. void DefineMarkers(); add additional pgfplotmarks. Int_t CMtoTeX(Double_t u);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTeXDump.html:15758,green,green,15758,root/html534/TTeXDump.html,https://root.cern,https://root.cern/root/html534/TTeXDump.html,2,['green'],['green']
Energy Efficiency," yw); This function defines a path with xw and yw and draw it according the; value of nn:. If nn>0 a line is drawn.; If nn<0 a closed polygon is drawn. void NewPage(); Start the TeX page. This function starts the tikzpicture environment. void Range(Float_t xrange, Float_t yrange); Set the range for the paper in centimetres. void SetFillColor(Color_t cindex = 1); Set color index for fill areas. void SetLineColor(Color_t cindex = 1); Set color index for lines. void SetLineStyle(Style_t linestyle = 1); Change the line style. linestyle = 2 dashed; = 3 dotted; = 4 dash-dotted; = else solid (1 in is used most of the time). void SetLineWidth(Width_t linewidth = 1); Set the lines width. void SetMarkerSize(Size_t msize = 1); Set size for markers. void SetMarkerColor(Color_t cindex = 1); Set color index for markers. void SetColor(Int_t color = 1); Set color with its color index. void SetColor(Float_t r, Float_t g, Float_t b); Set color with its R G B components. r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1]. void SetTextColor(Color_t cindex = 1); Set color index for text. void Text(Double_t x, Double_t y, const char* string); Draw text. xx: x position of the text; yy: y position of the text; chars: text to be drawn. void TextNDC(Double_t u, Double_t v, const char* string); Write a string of characters in NDC. Float_t UtoTeX(Double_t u); Convert U from NDC coordinate to TeX. Float_t VtoTeX(Double_t v); Convert V from NDC coordinate to TeX. Float_t XtoTeX(Double_t x); Convert X from world coordinate to TeX. Float_t YtoTeX(Double_t y); Convert Y from world coordinate to TeX. void CellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); Begin the Cell Array painting. void CellArrayFill(Int_t r, Int_t g, Int_t b); Paint the Cell Array. void CellArrayEnd(); End the Cell Array painting. void DrawPS(Int_t n, Float_t* xw, Float_t* yw); Not needed in TeX case. void DefineMarkers(); add additional pgfplotmarks. TTeXDump(). Int_t CMtoTeX(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTeXDump.html:16319,green,green,16319,root/html602/TTeXDump.html,https://root.cern,https://root.cern/root/html602/TTeXDump.html,4,['green'],['green']
Energy Efficiency," {; 1260 char *data = GetLongPointer();; 1261 Ssiz_t cap = Recommend(nc);; 1262 if (cap != Capacity()) {; 1263 data = new char[cap+1];; 1264 UnLink();; 1265 SetLongCap(cap+1);; 1266 SetLongPointer(data);; 1267 }; 1268 SetLongSize(0);; 1269 data[0] = 0;; 1270 }; 1271 return nc;; 1272}; 1273 ; 1274////////////////////////////////////////////////////////////////////////////////; 1275/// Make self a distinct copy with capacity of at least tot, where tot cannot; 1276/// be smaller than the current length. Preserve previous contents.; 1277/// \warning If tot > MaxSize(), then Fatal() is raised and only MaxSize() elements are allocated; 1278 ; 1279void TString::Clone(Ssiz_t tot); 1280{; 1281 Ssiz_t len = Length();; 1282 if (len >= tot) return;; 1283 ; 1284 if (tot > MaxSize()) {; 1285 Fatal(""TString::Clone"", ""tot too large (%d, max = %d)"", tot, MaxSize());; 1286 tot = MaxSize();; 1287 }; 1288 ; 1289 Ssiz_t capac = Capacity();; 1290 char *data, *p = GetPointer();; 1291 ; 1292 if (capac - tot < 0) {; 1293 Ssiz_t cap = Recommend(tot);; 1294 data = new char[cap+1];; 1295 memcpy(data, p, len);; 1296 UnLink();; 1297 SetLongCap(cap+1);; 1298 SetLongSize(len);; 1299 SetLongPointer(data);; 1300 data[len] = 0;; 1301 }; 1302}; 1303 ; 1304////////////////////////////////////////////////////////////////////////////////; 1305// ROOT I/O; 1306 ; 1307////////////////////////////////////////////////////////////////////////////////; 1308/// Copy string into I/O buffer.; 1309 ; 1310void TString::FillBuffer(char *&buffer) const; 1311{; 1312 UChar_t nwh;; 1313 Int_t nchars = Length();; 1314 ; 1315 if (nchars > 254) {; 1316 nwh = 255;; 1317 tobuf(buffer, nwh);; 1318 tobuf(buffer, nchars);; 1319 } else {; 1320 nwh = UChar_t(nchars);; 1321 tobuf(buffer, nwh);; 1322 }; 1323 const char *data = GetPointer();; 1324 for (int i = 0; i < nchars; i++) buffer[i] = data[i];; 1325 buffer += nchars;; 1326}; 1327 ; 1328////////////////////////////////////////////////////////////////////////////////; 1329/// Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:39149,allocate,allocated,39149,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency," {; 1395 Log() << kFATAL << ""Mismatch in bins: "" << tmpbin-1 << "" >= "" << fNbins << Endl;; 1396 }; 1397 ; 1398 fEffBvsSLocal->SetBinContent( tmpbin, tmpeffB );; 1399 void* ct = gTools().GetChild(ch);; 1400 for (UInt_t ivar=0; ivar<GetNvar(); ivar++) {; 1401 gTools().ReadAttr( ct, TString::Format( ""cutMin_%i"", ivar ), fCutMin[ivar][tmpbin-1] );; 1402 gTools().ReadAttr( ct, TString::Format( ""cutMax_%i"", ivar ), fCutMax[ivar][tmpbin-1] );; 1403 }; 1404 ch = gTools().GetNextChild(ch, ""Bin"");; 1405 }; 1406}; 1407 ; 1408////////////////////////////////////////////////////////////////////////////////; 1409/// write histograms and PDFs to file for monitoring purposes; 1410 ; 1411void TMVA::MethodCuts::WriteMonitoringHistosToFile( void ) const; 1412{; 1413 Log() << kINFO << ""Write monitoring histograms to file: "" << BaseDir()->GetPath() << Endl;; 1414 ; 1415 fEffBvsSLocal->Write();; 1416 ; 1417 // save reference histograms to file; 1418 if (fEffMethod == kUsePDFs) {; 1419 for (UInt_t ivar=0; ivar<GetNvar(); ivar++) {; 1420 (*fVarHistS)[ivar]->Write();; 1421 (*fVarHistB)[ivar]->Write();; 1422 (*fVarHistS_smooth)[ivar]->Write();; 1423 (*fVarHistB_smooth)[ivar]->Write();; 1424 (*fVarPdfS)[ivar]->GetPDFHist()->Write();; 1425 (*fVarPdfB)[ivar]->GetPDFHist()->Write();; 1426 }; 1427 }; 1428}; 1429 ; 1430////////////////////////////////////////////////////////////////////////////////; 1431/// Overloaded function to create background efficiency (rejection) versus; 1432/// signal efficiency plot (first call of this function).; 1433///; 1434/// The function returns the signal efficiency at background efficiency; 1435/// indicated in theString; 1436///; 1437/// ""theString"" must have two entries:; 1438/// - `[0]`: ""Efficiency""; 1439/// - `[1]`: the value of background efficiency at which the signal efficiency; 1440/// is to be returned; 1441 ; 1442Double_t TMVA::MethodCuts::GetTrainingEfficiency(const TString& theString); 1443{; 1444 // parse input string for required background efficien",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:54027,monitor,monitoring,54027,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,2,['monitor'],['monitoring']
Energy Efficiency," {; 5580 currentVersion = kTRUE;; 5581 break;; 5582 }; 5583 }; 5584 }; 5585 }; 5586 ; 5587 if (!inRepo || currentVersion) {; 5588 // The object was allocated using code for the same class version; 5589 // as is loaded now. We may proceed without worry.; 5590 TVirtualStreamerInfo* si = GetStreamerInfo();; 5591 if (si) {; 5592 si->DeleteArray(ary, dtorOnly);; 5593 } else {; 5594 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), fClassVersion, ary);; 5595 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5596 Int_t i = fStreamerInfo->LowerBound();; 5597 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5598 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5599 if (fStreamerInfo->At(i)) {; 5600 Error(""DeleteArray"", ""Doing Dump() ..."");; 5601 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5602 }; 5603 }; 5604 }; 5605 } else {; 5606 // The loaded class version is not the same as the version of the code; 5607 // which was used to allocate this array. The best we can do is use; 5608 // the TVirtualStreamerInfo to try to free up some of the allocated memory.; 5609 TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);; 5610 if (si) {; 5611 si->DeleteArray(ary, dtorOnly);; 5612 } else {; 5613 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), objVer, ary);; 5614 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5615 Int_t i = fStreamerInfo->LowerBound();; 5616 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5617 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5618 if (fStreamerInfo->At(i)) {; 5619 // Print some debugging info.; 5620 Error(""DeleteArray"", ""Doing Dump() ..."");; 5621 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5622 }; 5623 }; 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:214724,allocate,allocate,214724,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency," {; 5647 currentVersion = kTRUE;; 5648 break;; 5649 }; 5650 }; 5651 }; 5652 }; 5653 ; 5654 if (!inRepo || currentVersion) {; 5655 // The object was allocated using code for the same class version; 5656 // as is loaded now. We may proceed without worry.; 5657 TVirtualStreamerInfo* si = GetStreamerInfo();; 5658 if (si) {; 5659 si->DeleteArray(ary, dtorOnly);; 5660 } else {; 5661 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), fClassVersion, ary);; 5662 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5663 Int_t i = fStreamerInfo->LowerBound();; 5664 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5665 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5666 if (fStreamerInfo->At(i)) {; 5667 Error(""DeleteArray"", ""Doing Dump() ..."");; 5668 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5669 }; 5670 }; 5671 }; 5672 } else {; 5673 // The loaded class version is not the same as the version of the code; 5674 // which was used to allocate this array. The best we can do is use; 5675 // the TVirtualStreamerInfo to try to free up some of the allocated memory.; 5676 TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);; 5677 if (si) {; 5678 si->DeleteArray(ary, dtorOnly);; 5679 } else {; 5680 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), objVer, ary);; 5681 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5682 Int_t i = fStreamerInfo->LowerBound();; 5683 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5684 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5685 if (fStreamerInfo->At(i)) {; 5686 // Print some debugging info.; 5687 Error(""DeleteArray"", ""Doing Dump() ..."");; 5688 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5689 }; 5690 }; 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:217475,allocate,allocate,217475,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency," |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; RooFitResult Class Reference. ; RooFitResult is a container class to hold the input and output of a PDF fit to a dataset. ; It contains:. Values of all constant parameters; Initial and final values of floating parameters with error; Correlation matrix and global correlation coefficients; NLL and EDM at minimum. No references to the fitted PDF and dataset are stored ; Definition at line 40 of file RooFitResult.h. Public Member Functions;  RooFitResult (const char *name=nullptr, const char *title=nullptr);  Constructor with name and title. ;  ;  RooFitResult (const RooFitResult &other);  Copy constructor. ;  ;  ~RooFitResult () override;  Destructor. ;  ; virtual TObject * clone () const;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; TMatrixDSym conditionalCovarianceMatrix (const RooArgList &params) const;  Return a reduced covariance matrix, which is calculated as. ;  ; const RooArgList & constPars () const;  Return list of constant parameters. ;  ; const RooArgList * correlation (const char *parname) const;  Return the set of correlation coefficients of parameter 'par' with all other floating parameters. ;  ; double correlation (const char *parname1, const char *parname2) const;  Return the correlation between parameters 'par1' and 'par2'. ;  ; const RooArgList * correlation (const RooAbsArg &par) const;  Return pointer to list of correlations of all parameters with par. ;  ; double correlation (const RooAbsArg &par1, const RooAbsArg &par2) const;  Return correlation between par1 and par2. ;  ; TH2 * correlationHist (const char *name=""correlation_matrix"") const;  Return TH2D of correlation matrix. ;  ; const TMatrixDSym & correlationMatrix () const;  Return correlation matrix ;. ;  ; const TMatrixDSym & covarianceMatrix () const;  Return covariance matrix. ;  ; Int_t covQual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFitResult.html:1185,reduce,reduced,1185,doc/master/classRooFitResult.html,https://root.cern,https://root.cern/doc/master/classRooFitResult.html,1,['reduce'],['reduced']
Energy Efficiency," }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. Scalar Dot(const OtherLorentzVector & q); ------ Operations combining two Lorentz vectors ------. scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html:18938,energy,energy,18938,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,1,['energy'],['energy']
Energy Efficiency," }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. Scalar Dot(const OtherLorentzVector & q); ------ Operations combining two Lorentz vectors ------. scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html:17332,energy,energy,17332,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,1,['energy'],['energy']
Energy Efficiency," }; 2930 ; 2931 // put image back in pixmap on server; 2932 XPutImage((Display*)fDisplay, gCws->fDrawing, *gGCpxmp, image, 0, 0, 0, 0,; 2933 gCws->fWidth, gCws->fHeight);; 2934 XFlush((Display*)fDisplay);; 2935 ; 2936 // clean up; 2937 if (tmpc) {; 2938 if (fRedDiv == -1); 2939 XFreeColors((Display*)fDisplay, fColormap, tmpc, ntmpc, 0);; 2940 delete [] tmpc;; 2941 }; 2942 XDestroyImage(image);; 2943 ::operator delete(orgcolors);; 2944}; 2945 ; 2946////////////////////////////////////////////////////////////////////////////////; 2947/// Collect in orgcolors all different original image colors.; 2948 ; 2949void TGX11::CollectImageColors(ULong_t pixel, ULong_t *&orgcolors, Int_t &ncolors,; 2950 Int_t &maxcolors); 2951{; 2952 if (maxcolors == 0) {; 2953 ncolors = 0;; 2954 maxcolors = 100;; 2955 orgcolors = (ULong_t*) ::operator new(maxcolors*sizeof(ULong_t));; 2956 }; 2957 ; 2958 for (int i = 0; i < ncolors; i++); 2959 if (pixel == orgcolors[i]) return;; 2960 ; 2961 if (ncolors >= maxcolors) {; 2962 orgcolors = (ULong_t*) TStorage::ReAlloc(orgcolors,; 2963 maxcolors*2*sizeof(ULong_t), maxcolors*sizeof(ULong_t));; 2964 maxcolors *= 2;; 2965 }; 2966 ; 2967 orgcolors[ncolors++] = pixel;; 2968}; 2969 ; 2970////////////////////////////////////////////////////////////////////////////////; 2971/// Get RGB values for orgcolors, add percent neutral to the RGB and; 2972/// allocate fNewColors.; 2973 ; 2974void TGX11::MakeOpaqueColors(Int_t percent, ULong_t *orgcolors, Int_t ncolors); 2975{; 2976 if (ncolors == 0) return;; 2977 ; 2978 RXColor *xcol = new RXColor[ncolors];; 2979 ; 2980 int i;; 2981 for (i = 0; i < ncolors; i++) {; 2982 xcol[i].pixel = orgcolors[i];; 2983 xcol[i].red = xcol[i].green = xcol[i].blue = 0;; 2984 xcol[i].flags = DoRed | DoGreen | DoBlue;; 2985 }; 2986 QueryColors(fColormap, xcol, ncolors);; 2987 ; 2988 UShort_t add = percent * kBIGGEST_RGB_VALUE / 100;; 2989 ; 2990 Int_t val;; 2991 for (i = 0; i < ncolors; i++) {; 2992 val = xcol[i].red + add;; 2993 if (v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:99044,allocate,allocate,99044,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency," };  . Protected Member Functions; Bool_t ClosestPointBetweenLines (const TEveVectorD &, const TEveVectorD &, const TEveVectorD &, const TEveVectorD &, TEveVectorD &out);  Get closest point on line defined with vector p0 and u. ;  ; void ClosestPointFromVertexToLineSegment (const TEveVectorD &v, const TEveVectorD &s, const TEveVectorD &r, Double_t rMagInv, TEveVectorD &c);  Get closest point from given vertex v to line segment defined with s and r. ;  ; Bool_t HelixIntersectPlane (const TEveVectorD &p, const TEveVectorD &point, const TEveVectorD &normal, TEveVectorD &itsect);  Intersect helix with a plane. ;  ; Bool_t LineIntersectPlane (const TEveVectorD &p, const TEveVectorD &point, const TEveVectorD &normal, TEveVectorD &itsect);  Intersect line with a plane. ;  ; void LineToBounds (TEveVectorD &p);  Propagate neutral particle with momentum p to bounds. ;  ; Bool_t LineToVertex (TEveVectorD &v);  Propagate neutral particle to vertex v. ;  ; void LoopToBounds (TEveVectorD &p);  Propagate charged particle with momentum p to bounds. ;  ; Bool_t LoopToLineSegment (const TEveVectorD &s, const TEveVectorD &r, TEveVectorD &p);  Propagate charged particle with momentum p to line segment with point s and vector r to the second point. ;  ; Bool_t LoopToVertex (TEveVectorD &v, TEveVectorD &p);  Propagate charged particle with momentum p to vertex v. ;  ; Bool_t PointOverVertex (const TEveVector4D &v0, const TEveVector4D &v, Double_t *p=nullptr);  ; void RebuildTracks ();  Rebuild all tracks using this render-style. ;  ; void Step (const TEveVector4D &v, const TEveVectorD &p, TEveVector4D &vOut, TEveVectorD &pOut);  Wrapper to step helix. ;  ; void StepRungeKutta (Double_t step, Double_t *vect, Double_t *vout);  Wrapper to step with method RungeKutta. ;  ; void Update (const TEveVector4D &v, const TEveVectorD &p, Bool_t full_update=kFALSE, Bool_t enforce_max_step=kFALSE);  Update helix / B-field projection state. ;  ;  Protected Member Functions inherited from TEveElement; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveTrackPropagator.html:38546,charge,charged,38546,doc/master/classTEveTrackPropagator.html,https://root.cern,https://root.cern/doc/master/classTEveTrackPropagator.html,1,['charge'],['charged']
Energy Efficiency," }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { return fCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html:16062,energy,energy,16062,root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,6,['energy'],['energy']
Energy Efficiency," }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinates.Pz(); }. Scalar e() const; { return fCoordinates.E(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar rho() const; { return fCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html:16062,energy,energy,16062,root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,6,['energy'],['energy']
Energy Efficiency," ~Type(); voidAddBase(const Reflex::Base& b) const; voidAddBase(const Reflex::Type& bas, Reflex::OffsetFunction offsFP, unsigned int modifiers = 0) const; voidAddDataMember(const Reflex::Member& dm) const; Reflex::MemberAddDataMember(const char* nam, const Reflex::Type& typ, size_t offs, unsigned int modifiers = 0, char* interpreterOffset = 0) const; voidAddFunctionMember(const Reflex::Member& fm) const; Reflex::MemberAddFunctionMember(const char* nam, const Reflex::Type& typ, Reflex::StubFunction stubFP, void* stubCtx = 0, const char* params = 0, unsigned int modifiers = 0) const; voidAddSubScope(const Reflex::Scope& sc) const; voidAddSubScope(const char* scop, Reflex::TYPE scopeTyp = NAMESPACE) const; voidAddSubType(const Reflex::Type& ty) const; voidAddSubType(const char* typ, size_t size, Reflex::TYPE typeTyp, const type_info& ti, unsigned int modifiers = 0) const; void*Allocate() const; size_tArrayLength() const; Reflex::Base_IteratorBase_Begin() const; Reflex::Base_IteratorBase_End() const; Reflex::Reverse_Base_IteratorBase_RBegin() const; Reflex::Reverse_Base_IteratorBase_REnd() const; Reflex::BaseBaseAt(size_t nth) const; size_tBaseSize() const; static Reflex::TypeByName(const string& key); static Reflex::TypeByTypeInfo(const type_info& tid); Reflex::ObjectCastObject(const Reflex::Type& to, const Reflex::Object& obj) const; Reflex::ObjectConstruct(const Reflex::Type& signature = Type(0,0), const vector<void*>& values = std::vector<void*>(), void* mem = 0) const; Reflex::Member_IteratorDataMember_Begin(Reflex::EMEMBERQUERY inh = INHERITEDMEMBERS_DEFAULT) const; Reflex::Member_IteratorDataMember_End(Reflex::EMEMBERQUERY inh = INHERITEDMEMBERS_DEFAULT) const; Reflex::Rever",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Reflex__Type.html:1182,Allocate,Allocate,1182,root/html534/Reflex__Type.html,https://root.cern,https://root.cern/root/html534/Reflex__Type.html,1,['Allocate'],['Allocate']
Energy Efficiency,"  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; TMVA::KDEKernel Class ReferenceTMVA. ; KDE Kernel for ""smoothing"" the PDFs. ; Definition at line 50 of file KDEKernel.h. Public Types; enum  EKernelBorder { kNoTreatment = 1; , kKernelRenorm = 2; , kSampleMirror = 3; };  ; enum  EKernelIter { kNonadaptiveKDE = 1; , kAdaptiveKDE = 2; };  ; enum  EKernelType { kNone = 0; , kGauss = 1; };  . Public Member Functions;  KDEKernel (EKernelIter kiter=kNonadaptiveKDE, const TH1 *hist=nullptr, Float_t lower_edge=0., Float_t upper_edge=1., EKernelBorder kborder=kNoTreatment, Float_t FineFactor=1.);  constructor sanity check ;  ; virtual ~KDEKernel (void);  destructor ;  ; Float_t GetBinKernelIntegral (Float_t lowr, Float_t highr, Float_t mean, Int_t binnum);  calculates the integral of the Kernel ;  ; const char * GetName () const;  ; virtual TClass * IsA () const;  ; void SetKernelType (EKernelType ktype=kGauss);  fIter == 1 —> nonadaptive KDE fIter == 2 —> adaptive KDE ;  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Private Member Functions; MsgLogger & Log () const;  . Private Attributes; Float_t fFineFactor;  fine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function ;  ; TH1F * fFirstIterHist;  histogram to be filled in the hidden iteration ;  ; Bool_t fHiddenIteration;  Defines if whats currently running is the. ;  ; TH1F * fHist;  copy of input histogram ;  ; EKernelIter fIter;  iteration number ;  ; EKernelBorder fKDEborder;  The method to take care about ""border"" effects. ;  ; TF1 * fKernel_integ;  the integral of the Kernel function ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1KDEKernel.html:1205,adapt,adaptive,1205,doc/master/classTMVA_1_1KDEKernel.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1KDEKernel.html,1,['adapt'],['adaptive']
Energy Efficiency,"  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf707_kernelestimation.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using non-parametric (multi-dimensional) kernel estimation pdfs . ; import ROOT; ; ; # Create low stats 1D dataset; # -------------------------------------------------------; ; # Create a toy pdf for sampling; x = ROOT.RooRealVar(""x"", ""x"", 0, 20); p = ROOT.RooPolynomial(""p"", ""p"", x, [0.01, -0.01, 0.0004]); ; # Sample 500 events from p; data1 = p.generate({x}, 200); ; # Create 1D kernel estimation pdf; # ---------------------------------------------------------------; ; # Create adaptive kernel estimation pdf. In self configuration the input data; # is mirrored over the boundaries to minimize edge effects in distribution; # that do not fall to zero towards the edges; kest1 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth); ; # An adaptive kernel estimation pdf on the same data without mirroring option; # for comparison; kest2 = ROOT.RooKeysPdf(""kest2"", ""kest2"", x, data1, ROOT.RooKeysPdf.NoMirror); ; # Adaptive kernel estimation pdf with increased bandwidth scale factor; # (promotes smoothness over detail preservation); kest3 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth, 2); ; # Plot kernel estimation pdfs with and without mirroring over data; frame = x.frame(Title=""Adaptive kernel estimation pdf with and w/o mirroring"", Bins=20); data1.plotOn(frame); kest1.plotOn(frame); kest2.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Plot kernel estimation pdfs with regular and increased bandwidth; frame2 = x.frame(Title=""Adaptive kernel estimation pdf with regular, bandwidth""); kest1.plotOn(frame2); kest3.plotOn(frame2, LineColor=""m""); ; # Create low status 2D dataset; # -------------------------------------------------------; ; # Construct a 2D toy pdf for sampleing; y = ROOT.RooRealVar(""y"", ""y"", 0, 20); py = ROOT.RooPolynomial(; """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf707__kernelestimation_8py.html:1031,adapt,adaptive,1031,doc/master/rf707__kernelestimation_8py.html,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8py.html,1,['adapt'],['adaptive']
Energy Efficiency,"  ; class  GSLMultiMinFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm More...;  ; class  GSLMultiMinimizer;  GSLMultiMinimizer class , for minimizing multi-dimensional function using derivatives. More...;  ; class  GSLMultiRootBaseSolver;  GSLMultiRootBaseSolver, internal class for implementing GSL multi-root finders This is the base class for GSLMultiRootSolver (solver not using derivatives) and GSLMUltiRootDerivSolver (solver using derivatives) More...;  ; class  GSLMultiRootDerivFunctionWrapper;  wrapper to a multi-dim function with derivatives for multi roots algorithm More...;  ; class  GSLMultiRootDerivSolver;  GSLMultiRootDerivSolver, internal class for implementing GSL multi-root finders using derivatives. More...;  ; class  GSLMultiRootFinder;  Class for Multidimensional root finding algorithms bassed on GSL. More...;  ; class  GSLMultiRootFunctionAdapter;  Class for adapting a C++ functor class to C function pointers used by GSL MultiRoot Algorithm The templated C++ function class must implement: More...;  ; class  GSLMultiRootFunctionWrapper;  wrapper to a multi-dim function without derivatives for multi roots algorithm More...;  ; class  GSLMultiRootSolver;  GSLMultiRootSolver, internal class for implementing GSL multi-root finders not using derivatives. More...;  ; class  GSLNLSMinimizer;  GSLNLSMinimizer class for Non Linear Least Square fitting It Uses the Levemberg-Marquardt algorithm from GSL Non Linear Least Square fitting. More...;  ; class  GSLPlainIntegrationWorkspace;  ; class  GSLQRngNiederreiter2;  Niederreiter generator gsl_qrng_niederreiter_2 from here More...;  ; class  GSLQRngSobol;  Sobol generator gsl_qrng_sobol from here More...;  ; class  GSLQRngWrapper;  GSLQRngWrapper class to wrap gsl_qrng structure. More...;  ; class  GSLQuasiRandomEngine;  GSLQuasiRandomEngine Base class for all GSL quasi random engines, normally user instantiate the derived classes which creates",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:11984,adapt,adapting,11984,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['adapt'],['adapting']
Energy Efficiency,"  ; static Bool_t ConnectToClass (TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TMonitor.h>. Inheritance diagram for TMonitor:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EInterest. enum TMonitor::EInterest. EnumeratorkRead ; kWrite . Definition at line 54 of file TMonitor.h. Constructor & Destructor Documentation. ◆ TMonitor() [1/2]. TMonitor::TMonitor ; (; Bool_t ; mainloop = kTRUE). Create a monitor object. ; If mainloop is true the monitoring will be done in the main event loop. ; Definition at line 109 of file TMonitor.cxx. ◆ TMonitor() [2/2]. TMonitor::TMonitor ; (; const TMonitor & ; m). Copy constructor. ; Definition at line 123 of file TMonitor.cxx. ◆ ~TMonitor(). TMonitor::~TMonitor ; (; ). virtual . Cleanup the monitor object. Does not delete sockets being monitored. ; Definition at line 153 of file TMonitor.cxx. Member Function Documentation. ◆ Activate(). void TMonitor::Activate ; (; TSocket * ; sock). virtual . Activate a de-activated socket. ; Definition at line 250 of file TMonitor.cxx. ◆ ActivateAll(). void TMonitor::ActivateAll ; (; ). virtual . Activate all de-activated sockets. ; Definition at line 268 of file TMonitor.cxx. ◆ Add(). void TMonitor::Add ; (; TSocket * ; sock, . Int_t ; interest = kRead . ). virtual . Add socket to the monitor's active list. ; If interest=kRead then we want to monitor the socket for read readiness, if interest=kWrite then we monitor the socket for write readiness, if interest=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:16926,monitor,monitoring,16926,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,1,['monitor'],['monitoring']
Energy Efficiency,"  ; unsigned int Dimension () const;  dimension ;  ; template<class OtherLorentzVector > ; Scalar Dot (const OtherLorentzVector &q) const;  scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+) Enable the product using any other LorentzVector implementing the x(), y() , y() and t() member functions ;  ; Scalar E () const;  return 4-th component (time, or energy for a 4-momentum vector) ;  ; Scalar e () const;  ; Scalar energy () const;  ; Scalar Et () const;  return the transverse energy ;  ; Scalar Et2 () const;  return the transverse energy squared ;  ; Scalar Eta () const;  pseudorapidity ;  ; Scalar eta () const;  ; Scalar Gamma () const;  Return Gamma scalar value. ;  ; template<class IT > ; void GetCoordinates (IT begin) const;  get internal data into 4 Scalars at *begin ;  ; template<class IT > ; void GetCoordinates (IT begin, IT end) const;  get internal data into 4 Scalars at *begin to *end ;  ; void GetCoordinates (Scalar &a, Scalar &b, Scalar &c, Scalar &d) const;  get internal data into 4 Scalar numbers ;  ; void GetCoordinates (Scalar dest[]) const;  get internal data into an array of 4 Scalar numbers ;  ; bool isLightlike (Scalar tolerance=100 *std::numeric_limits< Scalar >::epsilon()) const;  Determine if momentum-energy can represent a massless particle. ;  ; bool isSpacelike () const;  Determine if momentum-energy is spacelike, and represents a tachyon. ;  ; bool isTimelike () const;  Determine if momentum-energy can represent a physical massive particle. ;  ; Scalar M () const;  return magnitude (mass) using the (-,-,-,+) metric. ;  ; Scalar M2 () const;  return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2 (we use -,-,-,+ metric) ;  ; Scalar mag () const;  ; Scalar mag2 () const;  ; Scalar mass () const;  ; Scalar mass2 () const;  ; Scalar Mt () const;  return the transverse mass ;  ; Scalar mt () const;  ; Scalar Mt2 () const;  return the transverse mass squared ;  ; Scalar mt2 () const;  ; bool operator!= (const Lorentz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html:4702,energy,energy,4702,doc/master/classROOT_1_1Math_1_1LorentzVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html,1,['energy'],['energy']
Energy Efficiency,"  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; virtual double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parameters. ;  ; RooFit::OwningPtr< RooAbsFunc > bindVars (const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) const;  Create an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order). ;  ; virtual std::string buildCallToAnalyticIntegral (Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const;  This function defines the analytical integral translation for the class. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a \( \chi^2 \) fit to given histogram. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooLinkedList &cmdList);  Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={},",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFormulaVar.html:5990,adapt,adaptor,5990,doc/master/classRooFormulaVar.html,https://root.cern,https://root.cern/doc/master/classRooFormulaVar.html,4,['adapt'],['adaptor']
Energy Efficiency,"  CVariablePCATransformLinear interpolation class ;  CVariableRearrangeTransformRearrangement of input variables ;  CVariableTransformBaseLinear interpolation class ;  CVarTransformHandler;  CVolumeVolume for BinarySearchTree ;  ►NTStreamerInfoActions;  ►CTActionSequence;  CSequencePtr;  CTConfigurationBase class of the Configurations ;  CTConfiguredAction;  CTIDNode;  CTLoopConfigurationBase class of the Configurations for the member wise looping routines ;  CTNestedIDs;  ►Nvecgeom;  ►Nwriter;  Cwriter;  C_x3d_data_;  C_x3d_sizeof_;  CAnyCollectionProxy;  CAnyCollectionStreamer;  CBalancerInfo;  Cbasic_string_view;  CBasicRNNLayerGeneric implementation ;  ►CBidirMMapPipeBidirMMapPipe creates a bidirectional channel between the current process and a child it forks ;  CPollEntryFor poll() interface ;  CBinaryOpPolicy;  CBinomialNeymanInterval;  CBinomialProbHelper;  Cclient_cert;  CColorStruct_t;  CCompareAsc;  CcompareBAasc;  CcompareBAdesc;  CCompareDesc;  CContDistFree functions adapter needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CDebuggingSamplerDebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging ;  CDebuggingTestStatDebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging ;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  Cfuncptr_and_voidptr_t;  CGcCache_t;  CGCValues_t;  Cgroup;  Ch1analysis;  Ch1analysisTreeReader;  Chash< std::experimental::basic_string_view< _CharT, _Traits > >;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CMemInfo_t;  Cmg_callbacks;  Cmg_client_cert;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:91538,adapt,adapter,91538,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,1,['adapt'],['adapter']
Energy Efficiency,"  C_x3d_sizeof_;  CAnyCollectionProxy;  CAnyCollectionStreamer;  CBalancerInfo;  Cbasic_string_view;  CBasicRNNLayerGeneric implementation ;  ►CBidirMMapPipeBidirMMapPipe creates a bidirectional channel between the current process and a child it forks ;  CPollEntryFor poll() interface ;  CBinaryOpPolicy;  CBinomialNeymanInterval;  CBinomialProbHelper;  CClassificationClass to perform two class classification ;  CClassificationResultClass to save the results of the classifier ;  CColorStruct_t;  CCompareAsc;  CcompareBAasc;  CcompareBAdesc;  CCompareDesc;  CContDistFree functions adapter needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CDebuggingSamplerDebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging ;  CDebuggingTestStatDebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging ;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  Cfuncptr_and_voidptr_t;  CGcCache_t;  CGCValues_t;  CGraphCreatorHelperHelper class that provides the operation graph nodes ;  CGraphNodeClass used to create the operation graph to be printed in the dot representation ;  Cgroup;  Ch1analysis;  Ch1analysisTreeReader;  Chash< std::experimental::basic_string_view< _CharT, _Traits > >;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CMemInfo_t;  ►CMemPoolForRooSetsMemory pool for RooArgSet and RooDataSet ;  CArena;  Cmg_callbacks;  Cmg_client_cert;  Cmg_client_options;  Cmg_form_data_handler;  Cmg_header;  Cmg_option;  Cmg_request_info;  Cmg_response_info;  Cmg_server_ports;  Cmg_websocket_subprotocols;  CMultiDistF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:95469,adapt,adapter,95469,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['adapt'],['adapter']
Energy Efficiency,"  generic constructors from four scalar values. ;  ; Scalar Beta () const;  Return beta scalar value. ;  ; BetaVector BoostToCM () const;  The beta vector for the boost that would bring this vector into its center of mass frame (zero momentum) ;  ; template<class Other4Vector > ; BetaVector BoostToCM (const Other4Vector &v) const;  The beta vector for the boost that would bring this vector into its center of mass frame (zero momentum) ;  ; Scalar ColinearRapidity () const;  Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. ;  ; const CoordSystem & Coordinates () const;  Retrieve a const reference to the coordinates object. ;  ; unsigned int Dimension () const;  dimension ;  ; template<class OtherLorentzVector > ; Scalar Dot (const OtherLorentzVector &q) const;  scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+) Enable the product using any other LorentzVector implementing the x(), y() , y() and t() member functions ;  ; Scalar E () const;  return 4-th component (time, or energy for a 4-momentum vector) ;  ; Scalar e () const;  ; Scalar energy () const;  ; Scalar Et () const;  return the transverse energy ;  ; Scalar Et2 () const;  return the transverse energy squared ;  ; Scalar Eta () const;  pseudorapidity ;  ; Scalar eta () const;  ; Scalar Gamma () const;  Return Gamma scalar value. ;  ; template<class IT > ; void GetCoordinates (IT begin) const;  get internal data into 4 Scalars at *begin ;  ; template<class IT > ; void GetCoordinates (IT begin, IT end) const;  get internal data into 4 Scalars at *begin to *end ;  ; void GetCoordinates (Scalar &a, Scalar &b, Scalar &c, Scalar &d) const;  get internal data into 4 Scalar numbers ;  ; void GetCoordinates (Scalar dest[]) const;  get internal data into an array of 4 Scalar numbers ;  ; bool isLightlike (Scalar tolerance=100 *std::numeric_limits< Scalar >::epsilon()) const;  Determine if momentum-energy can represent a massless particle. ;  ; bool isSpacelike () const;  Determ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html:3810,energy,energy,3810,doc/master/classROOT_1_1Math_1_1LorentzVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1LorentzVector.html,4,['energy'],['energy']
Energy Efficiency,"   kNoTitle = (1ULL << ( 17 )); , kIsAverage = (1ULL << ( 18 )); , kIsNotW = (1ULL << ( 19 )); , kAutoBinPTwo = (1ULL << ( 20 )); , ;   kIsHighlight = (1ULL << ( 21 )). };  TH1 status bits. More...;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TH2Poly; enum  { kNOverflow = 9; };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Check histogram compatibility. ;  ; static bool CheckConsistentSubAxes (const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0);  Check that two sub axis are the same. ;  ; static bool CheckEqualAxes (const TAxis *a1, const TAxis *a2);  Che",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2Poly.html:56826,power,power,56826,doc/master/classTProfile2Poly.html,https://root.cern,https://root.cern/doc/master/classTProfile2Poly.html,1,['power'],['power']
Energy Efficiency," » SPECTRUM; » TSpectrumTransform. class TSpectrumTransform: public TNamed. THIS CLASS CONTAINS ORTHOGONAL TRANSFORM FUNCTIONS. These functions were written by:; Miroslav Morhac; Institute of Physics; Slovak Academy of Sciences; Dubravska cesta 9, 842 28 BRATISLAVA; SLOVAKIA. email:fyzimiro@savba.sk, fax:+421 7 54772479. The original code in C has been repackaged as a C++ class by R.Brun. The algorithms in this class have been published in the following; references:. [1] C.V. Hampton, B. Lian, Wm. C. McHarris: Fast-Fourier-transform; spectral enhancement techniques for gamma-ray spectroscopy.NIM A353; (1994) 280-284.; [2] Morhac M., Matousek V., New adaptive Cosine-Walsh transform and; its application to nuclear data compression, IEEE Transactions on; Signal Processing 48 (2000) 2693.; [3] Morhac M., Matousek V., Data compression using new fast adaptive; Cosine-Haar transforms, Digital Signal Processing 8 (1998) 63.; [4] Morhac M., Matousek V.: Multidimensional nuclear data compression; using fast adaptive Walsh-Haar transform. Acta Physica Slovaca 51; (2001) 307. Function Members (Methods); public:. TSpectrumTransform(); TSpectrumTransform(Int_t size); TSpectrumTransform(const TSpectrumTransform&); virtual~TSpectrumTransform(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrumTransform.html:1255,adapt,adaptive,1255,root/html528/TSpectrumTransform.html,https://root.cern,https://root.cern/root/html528/TSpectrumTransform.html,6,['adapt'],['adaptive']
Energy Efficiency," » SPECTRUM; » TSpectrumTransform. class TSpectrumTransform: public TNamed. THIS CLASS CONTAINS ORTHOGONAL TRANSFORM FUNCTIONS. These functions were written by:; Miroslav Morhac; Institute of Physics; Slovak Academy of Sciences; Dubravska cesta 9, 842 28 BRATISLAVA; SLOVAKIA. email:fyzimiro@savba.sk, fax:+421 7 54772479. The original code in C has been repackaged as a C++ class by R.Brun. The algorithms in this class have been published in the following; references:. [1] C.V. Hampton, B. Lian, Wm. C. McHarris: Fast-Fourier-transform; spectral enhancement techniques for gamma-ray spectroscopy.NIM A353; (1994) 280-284.; [2] Morhac M., Matousek V., New adaptive Cosine-Walsh transform and; its application to nuclear data compression, IEEE Transactions on; Signal Processing 48 (2000) 2693.; [3] Morhac M., Matousek V., Data compression using new fast adaptive; Cosine-Haar transforms, Digital Signal Processing 8 (1998) 63.; [4] Morhac M., Matousek V.: Multidimensional nuclear data compression; using fast adaptive Walsh-Haar transform. Acta Physica Slovaca 51; (2001) 307. Function Members (Methods); public:. virtual~TSpectrumTransform(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidEnhance(const Double_t* source, Double_t* destVector); virtual voidTObject::Error(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrumTransform.html:1279,adapt,adaptive,1279,root/html602/TSpectrumTransform.html,https://root.cern,https://root.cern/root/html602/TSpectrumTransform.html,4,['adapt'],['adaptive']
Energy Efficiency," ◆ IntegralMultiple() [3/3]. virtual Double_t TF1::IntegralMultiple ; (; Int_t ; n, . const Double_t * ; a, . const Double_t * ; b, . Int_t ; , . Int_t ; maxpts, . Double_t ; epsrel, . Double_t & ; relerr, . Int_t & ; nfnevl, . Int_t & ; ifail . ). inlinevirtual . Definition at line 616 of file TF1.h. ◆ IntegralOneDim(). Double_t TF1::IntegralOneDim ; (; Double_t ; a, . Double_t ; b, . Double_t ; epsrel, . Double_t ; epsabs, . Double_t & ; error . ). virtual . Return Integral of function between a and b using the given parameter values and relative and absolute tolerance. ; The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used If ROOT contains the MathMore library the default integrator is set to be the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the ROOT::Math::GaussIntegrator is used See the reference documentation of these classes for more information about the integration algorithms To change integration algorithm just do : ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName); Valid integrator names are:; Gauss : for ROOT::Math::GaussIntegrator; GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG). In order to use the GSL integrators one needs to have the MathMore library installed; Note 1:; Values of the function f(x) at the interval end-points A and B are not required. The subprogram may therefore be used when these values are undefined.; Note 2:; Instead of TF1::Integral, you may want to use the combination of TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast. See an example with the following script:; void gint() {; TF1 *g = new TF1(""g"",""gaus"",-5,5);; g->SetParameters(1,0,1);; //default gaus integration method uses 6 points; //not suitable to integrate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:101724,adapt,adaptive,101724,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,4,['adapt'],['adaptive']
Energy Efficiency,""" and the other has column ""y""; ROOT.RDataFrame df{dataset};; auto df_valid_col_x = df.FilterMissing(""y"");; auto df_valid_col_y = df.FilterMissing(""x"");; auto display_x = df_valid_col_x.Display<int>({""x""});; auto display_y = df_valid_col_y.Display<int>({""y""});; NoteSee FilterAvailable() if you want to discard the entries in case there is a missing value instead. ; Definition at line 388 of file RInterface.hxx. ◆ Foreach(). template<typename Proxied , typename DataSource = void> . template<typename F > . void ROOT::RDF::RInterface< Proxied, DataSource >::Foreach ; (; F ; f, . const ColumnNames_t & ; columns = {} . ). inline . Execute a user-defined function on each entry (instant action). ; Parameters. [in]fFunction, lambda expression, functor class or any other callable object performing user defined calculations. ; [in]columnsNames of the columns/branches in input to the user function. The callable f is invoked once per entry. This is an instant action: upon invocation, an event loop as well as execution of all scheduled actions is triggered. Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled (i.e. ROOT::EnableImplicitMT). Example usage:; myDf.Foreach([](int i){ std::cout << i << std::endl;}, {""myIntColumn""});. Definition at line 1611 of file RInterface.hxx. ◆ ForeachSlot(). template<typename Proxied , typename DataSource = void> . template<typename F > . void ROOT::RDF::RInterface< Proxied, DataSource >::ForeachSlot ; (; F ; f, . const ColumnNames_t & ; columns = {} . ). inline . Execute a user-defined function requiring a processing slot index on each entry (instant action). ; Parameters. [in]fFunction, lambda expression, functor class or any other callable object performing user defined calculations. ; [in]columnsNames of the columns/branches in input to the user function. Same as Foreach, but the user-defined function takes an extra unsigned int as its first parameter, the processing slot index. Thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:76469,schedul,scheduled,76469,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['schedul'],['scheduled']
Energy Efficiency,""" is set using:. gStyle->SetPalette(...);. This function has two parameters: the number of colors in the palette and an; array of containing the indices of colors in the palette. The following small; example demonstrates how to define and use the color palette:. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",0,0,600,400);; TF2 *f1 = new TF2(""f1"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; Int_t palette[5];; palette[0] = 15;; palette[1] = 20;; palette[2] = 23;; palette[3] = 30;; palette[4] = 32;; gStyle->SetPalette(5,palette);; f1->Draw(""colz"");; return c1;; }; To define more a complex palette with a continuous gradient of color, one; should use the static function TColor::CreateGradientColorTable().; The following example demonstrates how to proceed:. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",0,0,600,400);; TF2 *f2 = new TF2(""f2"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; const Int_t Number = 3;; Double_t Red[Number] = { 1.00, 0.00, 0.00};; Double_t Green[Number] = { 0.00, 1.00, 0.00};; Double_t Blue[Number] = { 1.00, 0.00, 1.00};; Double_t Length[Number] = { 0.00, 0.50, 1.00 };; Int_t nb=50;; TColor::CreateGradientColorTable(Number,Length,Red,Green,Blue,nb);; f2->SetContour(nb);; f2->SetLineWidth(1);; f2->SetLineColor(kBlack);; f2->Draw(""surf1z"");; return c2;; }; The function TColor::CreateGradientColorTable() automatically; calls gStyle->SetPalette(), so there is not need to add one. After a call to TColor::CreateGradientColorTable() it is sometimes; useful to store the newly create palette for further use. In particular, it is; recommended to do if one wants to switch between several user define palettes.; To store a palette in an array it is enough to do:. Int_t MyPalette[100];; Double_t r[] = {0., 0.0, 1.0, 1.0, 1.0};; Double_t g[] = {0., 0.0, 0.0, 1.0, 1.0};; Double_t b[] = {0., 1.0, 0.0, 0.0, 1.0};; Double_t stop[] = {0., .25, .50, .75, 1.0};; Int_t FI = TColor::CreateGradientColorTable(5, stop, r, g, b, 100);; for (int i=0;i<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TColor.html:4889,Green,Green,4889,root/html602/TColor.html,https://root.cern,https://root.cern/root/html602/TColor.html,2,['Green'],['Green']
Energy Efficiency,""" is true.; 426 ; 427THnSparseArrayChunk::THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont):; 428 fCoordinateAllocationSize(-1), fSingleCoordinateSize(coordsize), fCoordinatesSize(0),; 429 fCoordinates(nullptr), fContent(cont),; 430 fSumw2(nullptr); 431{; 432 fCoordinateAllocationSize = fSingleCoordinateSize * cont->GetSize();; 433 fCoordinates = new Char_t[fCoordinateAllocationSize];; 434 if (errors) Sumw2();; 435}; 436 ; 437////////////////////////////////////////////////////////////////////////////////; 438/// Destructor; 439 ; 440THnSparseArrayChunk::~THnSparseArrayChunk(); 441{; 442 delete fContent;; 443 delete [] fCoordinates;; 444 delete fSumw2;; 445}; 446 ; 447////////////////////////////////////////////////////////////////////////////////; 448/// Create a new bin in this chunk; 449 ; 450void THnSparseArrayChunk::AddBin(Int_t idx, const Char_t* coordbuf); 451{; 452 // When streaming out only the filled chunk is saved.; 453 // When reading back only the memory needed for that filled part gets; 454 // allocated. We need to check whether the allowed chunk size is; 455 // bigger than the allocated size. If fCoordinateAllocationSize is; 456 // set to -1 this chunk has been allocated by the streamer and the; 457 // buffer allocation size is defined by [fCoordinatesSize]. In that; 458 // case we need to compare fCoordinatesSize to; 459 // fSingleCoordinateSize * fContent->GetSize(); 460 // to determine whether we need to expand the buffer.; 461 if (fCoordinateAllocationSize == -1 && fContent) {; 462 Int_t chunksize = fSingleCoordinateSize * fContent->GetSize();; 463 if (fCoordinatesSize < chunksize) {; 464 // need to re-allocate:; 465 Char_t *newcoord = new Char_t[chunksize];; 466 memcpy(newcoord, fCoordinates, fCoordinatesSize);; 467 delete [] fCoordinates;; 468 fCoordinates = newcoord;; 469 }; 470 fCoordinateAllocationSize = chunksize;; 471 }; 472 ; 473 memcpy(fCoordinates + idx * fSingleCoordinateSize, coordbuf, fSingleCoordinateSize);; 474 fCoordi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:15910,allocate,allocated,15910,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"""%arg1%"");; When registering command, one could specify icon name which will be displayed with the command.; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; In example usage of images from $ROOTSYS/icons directory is shown. One could prepend button; string to the icon name to let browser show command as extra button. In last case one could hide command element from elements list:; serv->Hide(""/DoSomething"");; One can find example of command interface usage in tutorials/http/httpcontrol.C macro.; 1.5 Customize user interface; JSROOT is used to implement UI for the THttpServer. Default webpage shows list of registered objects on the left side and drawing area on the right side - see example. JSROOT allows to configure different parameters via URL - like monitoring interval or name of displayed items item=Files/job1.root/hpxpy&opt=colz&monitoring=1000.; Some of such parameters can be configured already on the server:; serv->SetItemField(""/"", ""_monitoring"", ""1000""); // monitoring interval in ms; serv->SetItemField(""/"", ""_drawitem"", ""Files/job1.root/hpxpy""); // item to draw; serv->SetItemField(""/"", ""_drawopt"", ""colz"");; In such case URL parameters are not required - specified item will be displayed automatically when web page is opened. One also can configure to display several items at once. For that one also can configure layout of the drawing area:; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; One also can change appearance of hierarchy browser on the left side of the web page:; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; If necessary, one also can automatically open ROOT file when web page is o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:6483,monitor,monitoring,6483,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,2,['monitor'],['monitoring']
Energy Efficiency,""");; } else {; printf(""\nmultidimfit .............................................. fails case %d\n"",compare);; }; ; // We're done; delete fit;; delete [] xMin;; delete [] xMax;; return compare;; }; d#define d(i)Definition RSha256.hxx:102; e#define e(i)Definition RSha256.hxx:103; Riostream.h; TApplication.h; TBrowser.h; TCanvas.h; TFile.h; TH1.h; TMath.h; TMultiDimFit.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TSystem.h; TVectorD.h; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TMultiDimFitMultidimensional Fits in ROOT.Definition TMultiDimFit.h:15; TMultiDimFit::kMonomials@ kMonomialsDefinition TMultiDimFit.h:19; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TVectorT< Double_t >; xDouble_t x[n]Definition legend1.C:17; PyTorch_Generate_CNN_Model.fitfit(model, train_loader, val_loader, num_epochs, batch_size, optimizer, criterion, save_best, scheduler)Definition PyTorch_Generate_CNN_Model.py:34; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::AreEqualRelBool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec)Comparing floating points.Definition TMath.h:426; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; outputstatic void output(); AuthorsRene Brun, Christian Holm Christensen ; Definition in file multidimfit.C. tutorialsfitmultidimfit.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/multidimfit_8C.html:12203,schedul,scheduler,12203,doc/master/multidimfit_8C.html,https://root.cern,https://root.cern/doc/master/multidimfit_8C.html,1,['schedul'],['scheduler']
Energy Efficiency,""",&gstep.destep);; t2.Branch(""pid"",&gstep.pid);; ; //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep.step = 0.1;; gstep.destep = 0;; gstep.nmec = 0;; gstep.pid = 0;; ; //transport particles; for (Int_t i=0;i<10000;i++) {; //generate a new particle if necessary; if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1; if (gRandom->Rndm() < 0.5) charge = -1;; gstep.pid += 1;; gstep.vect[0] = 0;; gstep.vect[1] = 0;; gstep.vect[2] = 0;; gstep.vect[3] = px/p;; gstep.vect[4] = py/p;; gstep.vect[5] = pz/p;; gstep.vect[6] = p*charge;; gstep.getot = TMath::Sqrt(p*p + mass*mass);; gstep.gekin = gstep.getot - mass;; newParticle = kFALSE;; }; ; // fill the Tree with current step parameters; t2.Fill();; ; //transport particle in magnetic field; helixStep(gstep.step, gstep.vect, vout); //make one step; ; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.00001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6] = charge*TMath::Sqrt(gstep.getot*gstep.getot - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0;l<gstep.nmec;l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; ; //save the Tree header. The file will be automatically closed; //when going out of the function scope; t2.Write();; }; ; void tree2r(); {; //read the Tree generated by tree2w and fill one histogram; //we are only interested by the destep branch.; ; //note that we use ""new"" to create the TFile and TTree objects !; //because we want to keep these objects alive when we leave; //this function.; TFile *f = new TFile(""tre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree2_8C.html:3709,energy,energy,3709,doc/master/tree2_8C.html,https://root.cern,https://root.cern/doc/master/tree2_8C.html,1,['energy'],['energy']
Energy Efficiency,"""; starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; one-dimensional histogram is only reasonable if it has a huge number of bins. * Projections; The dimensionality of a THnSparse can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THnSparse. See the Projection() members. To only project parts of the; histogram, call; THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);; See the important remark in THnSparse::IsInRange() when excluding under-; and overflow bins!. * Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Functio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THnSparse.html:3812,allocate,allocated,3812,root/html528/THnSparse.html,https://root.cern,https://root.cern/root/html528/THnSparse.html,4,['allocate'],['allocated']
Energy Efficiency,"""You can see the transparency ONLY in a pdf or png output (\""File\""->\""Save As\"" ->...)\n""; ""To have transparency in a canvas graphics, you need either OpenGL or Web rendering enabled"");; ; // 2. Some arbitrary histograms.; auto h1 = new TH1F(""TH1F 1"", ""TH1F 1"", 100, -1.5, 1.5);; h1->FillRandom(""gaus"");; ; auto h2 = new TH1F(""TH1F 2"", ""TH1F 2"", 100, -1.5, 0.);; h2->FillRandom(""gaus"");; ; auto h3 = new TH1F(""TH1F 3"", ""TH1F 3"", 100, 0.5, 2.);; h3->FillRandom(""landau"");; ; // 3. Now overlapping transparent pads.; auto pad1 = new TPad(""transparent pad 1"", ""transparent pad 1"", 0.1, 0.1, 0.7, 0.7);; pad1->SetFillColor(TColor::GetColor((Float_t) 1., 0.2, 0.2, 0.25)); // transparent pink, here's the magic!; c1->cd();; pad1->Draw();; pad1->cd();; h1->Draw(""lego2"");; ; auto pad2 = new TPad(""transparent pad 2"", ""transparent pad 2"", 0.2, 0.2, 0.8, 0.8);; pad2->SetFillColor(TColor::GetColor((Float_t) 0.2, 1., 0.2, 0.25)); // transparent green, here's the magic!; c1->cd();; pad2->Draw();; pad2->cd();; h2->Draw();; ; auto pad3 = new TPad(""transparent pad 3"", ""transparent pad 3"", 0.3, 0.3, 0.9, 0.9);; pad3->SetFillColor(TColor::GetColor((Float_t) 0.2, 1., 1., 0.15)); // transparent blue, here's the magic!; c1->cd();; pad3->Draw();; pad3->cd();; h3->Draw();; }; ; Float_tfloat Float_tDefinition RtypesCore.h:57; TCanvas.h; TColor.h; TError.h; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; TH1F.h; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/gl_2transparentpad_8C.html:1684,green,green,1684,doc/master/gl_2transparentpad_8C.html,https://root.cern,https://root.cern/doc/master/gl_2transparentpad_8C.html,1,['green'],['green']
Energy Efficiency,"""alien"")); 5025 opt += TString::Format(""&source=%s"", GetName());; 5026 ; 5027 dURL.SetOptions(opt);; 5028 ; 5029 char *copybuffer = nullptr;; 5030 ; 5031 TFile *sfile = this;; 5032 TFile *dfile = nullptr;; 5033 ; 5034 // ""RECREATE"" does not work always well with XROOTD; 5035 // namely when some pieces of the path are missing;; 5036 // we force ""NEW"" in such a case; 5037 if (TFile::GetType(ourl, """") == TFile::kNet) {; 5038 if (gSystem->AccessPathName(ourl)) {; 5039 oopt = ""NEW"";; 5040 // Force creation of the missing parts of the path; 5041 opt += ""&mkpath=1"";; 5042 dURL.SetOptions(opt);; 5043 }; 5044 }; 5045 ; 5046 // Open destination file; 5047 if (!(dfile = TFile::Open(dURL.GetUrl(), oopt))) {; 5048 ::Error(""TFile::Cp"", ""cannot open destination file %s"", dst);; 5049 goto copyout;; 5050 }; 5051 ; 5052 // Probably we created a new file; 5053 // We have to remove it in case of errors; 5054 rmdestiferror = kTRUE;; 5055 ; 5056 sfile->Seek(0);; 5057 dfile->Seek(0);; 5058 ; 5059 copybuffer = new char[buffersize];; 5060 if (!copybuffer) {; 5061 ::Error(""TFile::Cp"", ""cannot allocate the copy buffer"");; 5062 goto copyout;; 5063 }; 5064 ; 5065 Bool_t readop, writeop;; 5066 Long64_t read, written, totalread, filesize, b00;; 5067 ; 5068 totalread = 0;; 5069 filesize = sfile->GetSize();; 5070 ; 5071 watch.Start();; 5072 ; 5073 b00 = sfile->GetBytesRead();; 5074 ; 5075 do {; 5076 if (progressbar) CpProgress(totalread, filesize,watch);; 5077 ; 5078 Long64_t b1 = sfile->GetBytesRead() - b00;; 5079 ; 5080 Long64_t readsize;; 5081 if (filesize - b1 > (Long64_t)buffersize) {; 5082 readsize = buffersize;; 5083 } else {; 5084 readsize = filesize - b1;; 5085 }; 5086 ; 5087 if (readsize == 0) break;; 5088 ; 5089 Long64_t b0 = sfile->GetBytesRead();; 5090 sfile->Seek(totalread,TFile::kBeg);; 5091 readop = sfile->ReadBuffer(copybuffer, (Int_t)readsize);; 5092 read = sfile->GetBytesRead() - b0;; 5093 if ((read <= 0) || readop) {; 5094 ::Error(""TFile::Cp"", ""cannot read from source file %s. r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:184620,allocate,allocate,184620,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"""d"","""",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; h=(TH1F*) f->Get(""decon1;1"");; TFile *fr = new TFile(""spectra\\TSpectrum.root"");; d=(TH1F*) fr->Get(""decon_response;1"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; for (i = 0; i < nbins; i++) response[i]=d->GetBinContent(i + 1);; TCanvas *Decon1 = gROOT->GetListOfCanvases()->FindObject(""Decon1"");; if (!Decon1) Decon1 = new TCanvas(""Decon1"",""Decon1"",10,10,1000,700);; h->Draw(""L"");; TSpectrum *s = new TSpectrum();; s->Deconvolution(source,response,256,1000,1,1);; for (i = 0; i < nbins; i++) d->SetBinContent(i + 1,source[i]);; d->SetLineColor(kRed);; d->Draw(""SAME L"");; }; . Examples of Gold deconvolution method:. First let us study the influence of the number of iterations on the; deconvolved spectrum (Figure 12).; . Figure 12 Study of Gold deconvolution algorithm.The original source spectrum; is drawn with black color, spectrum after 100 iterations with red color,; spectrum after 1000 iterations with blue color, spectrum after 10000; iterations with green color and spectrum after 100000 iterations with; magenta color.; ; For relatively narrow peaks in the above given example the Gold; deconvolution method is able to decompose overlapping peaks practically to; delta - functions. In the next example we have chosen a synthetic data; (spectrum, 256 channels) consisting of 5 very closely positioned, relatively; wide peaks (sigma =5), with added noise (Figure 13). Thin lines represent; pure Gaussians (see Table 1); thick line is a resulting spectrum with; additive noise (10% of the amplitude of small peaks).; . Figure 13 Testing example of synthetic spectrum composed of 5 Gaussians with; added noise.; . Peak # Position Height Area . 1 50 500 10159 . 2 70 3000 60957 . 3 80 1000 20319 . 4 100 5000 101596 . 5 110 500 10159 . Table 1 Positions, heights and areas of peaks in the spectrum shown in; Figure 13.; ; In ideal case, we should obtain the result given in Figure 14. The areas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum.html:35704,green,green,35704,root/html528/TSpectrum.html,https://root.cern,https://root.cern/root/html528/TSpectrum.html,10,['green'],['green']
Energy Efficiency,"""reuse"" the; same portion of memory for new/delete avoiding memory fragmentation and memory; growth and improving by orders of magnitude the performance. Every time the; memory of the TClonesArray has to be reused, the Clear() method is employed.; To provide its benefits, each TClonesArray must be allocated *once* per process; and disposed of (deleted) *only when not needed any more*.; So a job should see *only one* deletion for each TClonesArray, which should be; ""Cleared()"" in between several times. Keep deleting a TClonesArray is a double; waste. Not only you do not avoid memory fragmentation, but you worsen it because; the TClonesArray itself is a rather heavy structure, and there is quite some; code in the destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve program; execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used for; clearing TClonesArray. When option ""C"" is specified, ROOT automatically; executes the Clear() method (by default it is empty contained in TObject).; This method must be overridden in the relevant TClonesArray object class,; implementing the reset procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the TClonesArrays; are not destroyed and created on every event.; They must only be constructed/destructed at the beginning/end of the run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TClonesArray.html:3299,allocate,allocate,3299,root/html530/TClonesArray.html,https://root.cern,https://root.cern/root/html530/TClonesArray.html,1,['allocate'],['allocate']
Energy Efficiency,"""reuse"" the; same portion of memory for new/delete avoiding memory fragmentation and memory; growth and improving by orders of magnitude the performance. Every time the; memory of the TClonesArray has to be reused, the Clear() method is employed.; To provide its benefits, each TClonesArray must be allocated *once* per process; and disposed of (deleted) *only when not needed any more*.; So a job should see *only one* deletion for each TClonesArray, which should be; ""Cleared()"" in between several times. Keep deleting a TClonesArray is a double; waste. Not only you do not avoid memory fragmentation, but you worsen it because; the TClonesArray itself is a rather heavy structure, and there is quite some; code in the destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve program; execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used for; clearing TClonesArray. When option ""C"" is specified, ROOT automatically; executes the Clear() method (by default it is empty contained in TObject).; This method must be overridden in the relevant TClonesArray object class,; implementing the reset procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the TClonesArrays; are not destroyed and created on every event.; They must only be constructed/destructed at the beginning/end of the run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:3299,allocate,allocate,3299,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,1,['allocate'],['allocate']
Energy Efficiency,"#define BIT(n)Definition Rtypes.h:90; TClassRef.h; TDataType.h; EDataTypeEDataTypeDefinition TDataType.h:28; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; destOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t destDefinition TGWin32VirtualXProxy.cxx:164; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassRef::GetClassTClass * GetClass() constDefinition TClassRef.h:66; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5260; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::DeleteArrayvoid DeleteArray(void *ary, Bool_t dtorOnly=kFALSE)Explicitly call operator delete[] for an array.Definition TClass.cxx:5596; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5276; TClass::NewObjectObjectPtr NewObject(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constDefinition TClass.cxx:5059; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TVirtualCollectionProxy::TPushPopRAII",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:14491,allocate,allocated,14491,doc/master/TVirtualCollectionProxy_8h_source.html,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency,"& , vector<Float_t>* count). Double_t CKernelEstimate(const TMVA::Event& , vector<const TMVA::BinarySearchTreeNode*,allocator<const TMVA::BinarySearchTreeNode*> >& , TMVA::Volume& ); normalization factors so we can work with radius 1 hyperspheres. void RKernelEstimate(const TMVA::Event& , vector<const TMVA::BinarySearchTreeNode*,allocator<const TMVA::BinarySearchTreeNode*> >& , TMVA::Volume& , vector<Float_t>* pdfSum); normalization factors so we can work with radius 1 hyperspheres. Double_t ApplyKernelFunction(Double_t normalized_distance); from the normalized euclidean distance calculate the distance; for a certain kernel. Double_t KernelNormalization(Double_t pdf); Calculating the normalization factor only once (might need a reset at some point.; Can the method be restarted with different params?). Double_t GetNormalizedDistance(const TMVA::Event& base_event, const TMVA::BinarySearchTreeNode& sample_event, Double_t* dim_normalization); We use Euclidian metric here. Might not be best or most efficient. Double_t NormSinc(Double_t x); NormSinc. Double_t LanczosFilter(Int_t level, Double_t x); Lanczos Filter. Float_t GetError(Float_t countS, Float_t countB, Float_t sumW2S, Float_t sumW2B) const; statistical error estimate for RS estimator. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr); read weight info from file. void WriteWeightsToStream(TFile& rf) const; write training sample (TTree) to file. void ReadWeightsFromStream(TFile& istr); read training sample from file. TMVA::MethodPDERS* ThisPDERS( void ); static pointer to this object. void UpdateThis( void ); update static this pointer. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". BinarySearchTree* GetBinaryTree( void )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodPDERS.html:23578,efficient,efficient,23578,root/html528/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDERS.html,6,['efficient'],['efficient']
Energy Efficiency,"& TMatrixTSparse< Element >::SetRowIndexArray ; (; Int_t * ; data). inlineoverridevirtual . Implements TMatrixTBase< Element >.; Definition at line 106 of file TMatrixTSparse.h. ◆ SetSparseIndex() [1/2]. template<class Element > . TMatrixTSparse< Element > & TMatrixTSparse< Element >::SetSparseIndex ; (; const TMatrixTBase< Element > & ; another). Use non-zero data of matrix source to set the sparse structure. ; Definition at line 1511 of file TMatrixTSparse.cxx. ◆ SetSparseIndex() [2/2]. template<class Element > . TMatrixTSparse< Element > & TMatrixTSparse< Element >::SetSparseIndex ; (; Int_t ; nelem_new). Increase/decrease the number of non-zero elements to nelems_new. ; Definition at line 1477 of file TMatrixTSparse.cxx. ◆ SetSparseIndexAB() [1/3]. template<class Element > . TMatrixTSparse< Element > & TMatrixTSparse< Element >::SetSparseIndexAB ; (; const TMatrixT< Element > & ; a, . const TMatrixTSparse< Element > & ; b . ). Set the row/column indices to the ""sum"" of matrices a and b It is checked that enough space has been allocated. ; Definition at line 1648 of file TMatrixTSparse.cxx. ◆ SetSparseIndexAB() [2/3]. template<class Element > . TMatrixTSparse< Element > & TMatrixTSparse< Element >::SetSparseIndexAB ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixT< Element > & ; b . ). inline . Definition at line 113 of file TMatrixTSparse.h. ◆ SetSparseIndexAB() [3/3]. template<class Element > . TMatrixTSparse< Element > & TMatrixTSparse< Element >::SetSparseIndexAB ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixTSparse< Element > & ; b . ). Set the row/column indices to the ""sum"" of matrices a and b It is checked that enough space has been allocated. ; Definition at line 1554 of file TMatrixTSparse.cxx. ◆ SetSub(). template<class Element > . TMatrixTBase< Element > & TMatrixTSparse< Element >::SetSub ; (; Int_t ; row_lwb, . Int_t ; col_lwb, . const TMatrixTBase< Element > & ; source . ). overridevirtual . Insert matrix source starting at ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSparse.html:53376,allocate,allocated,53376,doc/master/classTMatrixTSparse.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSparse.html,1,['allocate'],['allocated']
Energy Efficiency,"& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidapplyCovarianceMatrix(TMatrixDSym& V); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Int_tgetNPar() const; ofstream*logfile() const; voidTObject::MakeZombie(); Double_t&maxFCN(); voidprofileStart(); voidprofileStop(). private:. RooMinimizer(const RooMinimizer&). Data Members; public:. enum Strategy { Speed; Balance; Robustness; };; enum PrintLevel { None; Reduced; Normal; ExtraForProblem; Maximum; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStopwatch_cumulTimer; TMatrixDSym*_extV; RooMinimizerFcn*_fcn; RooAbsReal*_func; string_minimizerType; Bool_t_optConst; Int_t_printLevel; Bool_t_profile; Int_t_status; vector<std::pair<std::string,int> >_statusHistory; static ROOT::Fit::Fitter*_theFitter; TStopwatch_timer; Bool_t_verbose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Cleanup method called by atexit handler installed by RooSentinel; to delete all global heap objects when the program is terminated. RooMinimizer(RooAbsReal& function); Construct MINUIT interface to given function. Function can be anything,; but is typically a -log(likelihood) implemented by RooNLLVar or a chi^2; (implemented by RooChi2Var). Other frequent use cases are a RooAddition; of a RooNLLVar plu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMinimizer.html:6985,Reduce,Reduced,6985,root/html532/RooMinimizer.html,https://root.cern,https://root.cern/root/html532/RooMinimizer.html,1,['Reduce'],['Reduced']
Energy Efficiency,"& config) const; Clone integrator with new function binding and configuration. Needed by RooNumIntFactory. Bool_t initialize(); Initialize the integrator. ~RooIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Calculate numeric integral at given set of function binding parameters. Double_t addMidpoints(Int_t n); Calculate the n-th stage of refinement of the Second Euler-Maclaurin; summation rule which has the useful property of not evaluating the; integrand at either of its endpoints but requires more function; evaluations than the trapezoidal rule. This rule can be used with; a suitable change of variables to estimate improper integrals. Double_t addTrapezoids(Int_t n); Calculate the n-th stage of refinement of the extended trapezoidal; summation rule. This is the most efficient rule for a well behaved; integrand that can be evaluated over its entire range, including the; endpoints. void extrapolate(Int_t n); Extrapolate result to final value. RooIntegrator1D(). Bool_t setUseIntegrandLimits(Bool_t flag); {_useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kFALSE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. Double_t* xvec(Double_t& xx); { _x[0] = xx ; return _x ; }. » Last changed: Tue Jun 30 14:33:35 2015 » Last generated: 2015-06-30 14:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooIntegrator1D.html:11060,efficient,efficient,11060,root/html602/RooIntegrator1D.html,https://root.cern,https://root.cern/root/html602/RooIntegrator1D.html,2,['efficient'],['efficient']
Energy Efficiency,"& config) const; Clone integrator with new function binding and configuration. Needed by RooNumIntFactory. Bool_t initialize(); Initialize the integrator. ~RooIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Calculate numeric integral at given set of function binding parameters. Double_t addMidpoints(Int_t n); Calculate the n-th stage of refinement of the Second Euler-Maclaurin; summation rule which has the useful property of not evaluating the; integrand at either of its endpoints but requires more function; evaluations than the trapezoidal rule. This rule can be used with; a suitable change of variables to estimate improper integrals. Double_t addTrapezoids(Int_t n); Calculate the n-th stage of refinement of the extended trapezoidal; summation rule. This is the most efficient rule for a well behaved; integrand that can be evaluated over its entire range, including the; endpoints. void extrapolate(Int_t n); Extrapolate result to final value. RooIntegrator1D(). Bool_t setUseIntegrandLimits(Bool_t flag); {_useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kFALSE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. Double_t* xvec(Double_t& xx); { _x[0] = xx ; return _x ; }. » Last changed: Tue Mar 10 17:17:26 2015 » Last generated: 2015-03-10 17:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooIntegrator1D.html:10523,efficient,efficient,10523,root/html534/RooIntegrator1D.html,https://root.cern,https://root.cern/root/html534/RooIntegrator1D.html,2,['efficient'],['efficient']
Energy Efficiency,"& vars, TH1& href, Int_t* offset = 0); Adjust binning specification on first and optionally second and third; observable to binning in given reference TH1. Used by constructors; that import data from an external TH1. void initialize(const char* binningName = 0, Bool_t fillTree = kTRUE); Initialization procedure: allocate weights array, calculate; multipliers needed for N-space to 1-dim array jump table,; and fill the internal tree with all bin center coordinates. void checkBinBounds() const. RooDataHist(const RooDataHist& other, const char* newname = 0); Copy constructor. RooDataHist(const char* name, const char* title, RooDataHist* h, const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t copyCache); Constructor of a data hist from (part of) an existing data hist. The dimensions; of the data set are defined by the 'vars' RooArgSet, which can be identical; to 'dset' dimensions, or a subset thereof. Reduced dimensions will be projected; in the output data hist. The optional 'cutVar' formula variable can used to; select the subset of bins to be copied. For most uses the RooAbsData::reduce() wrapper function, which uses this constructor,; is the most convenient way to create a subset of an existing data. RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Construct a clone of this dataset that contains only the cached variables. RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); Implementation of RooAbsData virtual method that drives the RooAbsData::reduce() methods. ~RooDataHist(); Destructor. Int_t getIndex(const RooArgSet& coord, Bool_t fast = kFALSE). Int_t calcTreeIndex() const; Calculate the index for the weights array corresponding to; to the bin enclosing the current coordinates of the internal argset. void dump2(); Debug s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataHist.html:27509,Reduce,Reduced,27509,root/html534/RooDataHist.html,https://root.cern,https://root.cern/root/html534/RooDataHist.html,3,['Reduce'],['Reduced']
Energy Efficiency,"&); voidSetNBins(Int_t bins); virtual voidSetNuisanceParameters(const RooArgSet&); voidSetParameterPointsToTest(RooAbsData& pointsToTest); virtual voidSetParameters(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); voidSetPOIPointsToTest(RooAbsData& poiToTest); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector&); virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUseAdaptiveSampling(bool flag = true). private:. voidCreateParameterPoints() const; voidCreateTestStatSampler() const. Data Members; private:. Bool_tfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; Bool_tfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set ; Bool_tfDoProfileConstructioninstead of full construction over nuisance parametrs, do profile; Bool_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; RooStats::ModelConfig&fModel; Int_tfNbinsnumber of samples per variable; RooAbsData*fPOIToTestvalue of POI points to perform the construction; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the paramet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__FeldmanCousins.html:3182,adapt,adaptive,3182,root/html534/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html534/RooStats__FeldmanCousins.html,2,['adapt'],['adaptive']
Energy Efficiency,"&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidZero(Int_t& k, Double_t AZ, Double_t BZ, Double_t E2, Double_t& X, Double_t& Y, Int_t maxiterations). protected:. virtual Double_t**Allocate(Int_t newsize); Double_t**AllocateArrays(Int_t Narrays, Int_t arraySize); virtual voidCopyAndRelease(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin); virtual Bool_tCopyPoints(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin); Bool_tCtorAllocate(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Bool_tDoMerge(const TGraph* g); Double_t**ExpandAndCopy(Int_t size, Int_t iend); virtual voidFillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); voidTObject::MakeZombie(); Double_t**ShrinkAndCopy(Int_t size, Int_t iend); virtual voidSwapPoints(Int_t pos1, Int_t pos2); static voidSwapValues(Double_t* arr, Int_t pos1, Int_t pos2). Data Members; public:. enum { kClipFrame; kNotEditable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TList*fFunctionsPointer to list of functions (fits and user); TH1F*fHistogramPointer to histogram used for drawing axis; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraph.html:11807,Allocate,Allocate,11807,root/html534/TGraph.html,https://root.cern,https://root.cern/root/html534/TGraph.html,2,['Allocate'],"['Allocate', 'AllocateArrays']"
Energy Efficiency,"&;; int FindGoodLepton(cRVecI goodlep, cRVecI type, cRVecF lep_pt, cRVecF lep_eta, cRVecF lep_phi, cRVecF lep_e, cRVecF trackd0pv, cRVecF tracksigd0pv, cRVecF z0); {; int idx = -1; // Return -1 if no good lepton is found.; for(auto i = 0; i < type.size(); i++) {; if(!goodlep[i]) continue;; if (type[i] == 11 && abs(lep_eta[i]) < 2.47 && (abs(lep_eta[i]) < 1.37 || abs(lep_eta[i]) > 1.52) && abs(trackd0pv[i] / tracksigd0pv[i]) < 5) {; const ROOT::Math::PtEtaPhiEVector p(lep_pt[i], lep_eta[i], lep_phi[i], lep_e[i]);; if (abs(z0[i] * sin(p.Theta())) < 0.5) {; if (idx == -1) idx = i;; else return -1; // Accept only events with exactly one good lepton; }; }; if (type[i] == 13 && abs(lep_eta[i]) < 2.5 && abs(trackd0pv[i] / tracksigd0pv[i]) < 3) {; const ROOT::Math::PtEtaPhiEVector p(lep_pt[i], lep_eta[i], lep_phi[i], lep_e[i]);; if (abs(z0[i] * sin(p.Theta())) < 0.5) {; if (idx == -1) idx = i;; else return -1; // Accept only events with exactly one good lepton; }; }; }; return idx;; }; """"""); ; for s in samples:; # Select events with electron or muon trigger and with a missing transverse energy above 30 GeV; df[s] = df[s].Filter(""trigE || trigM"")\; .Filter(""met_et > 30000""); ; # Perform preselection of highly isolated leptons; df[s] = df[s].Define(""goodlep"", ""lep_isTightID && lep_pt > 35000 && lep_ptcone30 / lep_pt < 0.1 && lep_etcone20 / lep_pt < 0.1"")\; .Filter(""ROOT::VecOps::Sum(goodlep) > 0""); ; # Find a single good lepton, otherwise return -1 as index; df[s] = df[s].Define(""idx_lep"", ""FindGoodLepton(goodlep, lep_type, lep_pt, lep_eta, lep_phi, lep_E, lep_trackd0pvunbiased, lep_tracksigd0pvunbiased, lep_z0)"")\; .Filter(""idx_lep != -1""); ; # Compute transverse mass of the W boson using the missing transverse energy and the good lepton; # Use only events with a transverse mass of the reconstructed W boson larger than 60 GeV; df[s] = df[s].Define(""mtw"", ""sqrt(2 * lep_pt[idx_lep] * met_et * (1 - cos(lep_phi[idx_lep] - met_phi)))"")\; .Filter(""mtw > 60000""); ; # Perform presel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:4717,energy,energy,4717,doc/master/df107__SingleTopAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html,1,['energy'],['energy']
Energy Efficiency,"&ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from THnSparse;  ~THnSparse () override;  Destruct a THnSparse. ;  ; void AddBinContent (const Int_t *idx, Double_t v=1.);  Forwards to THnBase::AddBinContent(). ;  ; void AddBinContent (Long64_t bin, Double_t v=1.) override;  Add ""v"" to the content of bin with index ""bin"". ;  ; void AddBinError2 (Long64_t bin, Double_t e2) override;  Add ""e"" to error of bin with index ""bin"", enable errors if needed. ;  ; ROOT::Internal::THnBaseBinIter * CreateIter (Bool_t respectAxisRange) const override;  Create an iterator over all filled bins of a THnSparse. ;  ; Long64_t GetBin (const char *name[]) const override;  ; Long64_t GetBin (const char *name[], Bool_t allocate=kTRUE) override;  Get the bin index for the n dimensional tuple addressed by ""name"", allocate one if it doesn't exist yet and ""allocate"" is true. ;  ; Long64_t GetBin (const Double_t *x) const override;  ; Long64_t GetBin (const Double_t *x, Bool_t allocate=kTRUE) override;  Get the bin index for the n dimensional tuple x, allocate one if it doesn't exist yet and ""allocate"" is true. ;  ; Long64_t GetBin (const Int_t *idx) const override;  ; Long64_t GetBin (const Int_t *idx, Bool_t allocate=kTRUE) override;  Get the bin index for the n dimensional coordinates coord, allocate one if it doesn't exist yet and ""allocate"" is true. ;  ; Double_t GetBinContent (const Int_t *idx) const;  Forwards to THnBase::GetBinContent() overload. ;  ; Double_t GetBinContent (Long64_t bin, Int_t *idx=nullptr) const override;  Return the content of the filled bin number ""idx"". ;  ; Double_t GetBinError2 (Long64_t linidx) const override;  Get square of the error of bin addressed by linidx as \(\sum weight^{2}\) If errors are not enabled (via Sumw2() or CalculateErrors()) return contents. ;  ; Int_t GetChunkSize () const;  ; Long64_t GetNbins () const override;  ; Int_t GetNChunks () const;  ; Double_t GetSparseFractionBins () const;  Return the amount of filled bins ov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnSparseT.html:3045,allocate,allocate,3045,doc/master/classTHnSparseT.html,https://root.cern,https://root.cern/doc/master/classTHnSparseT.html,3,['allocate'],['allocate']
Energy Efficiency,"&operator=(const TGeoHelix&). Data Members; public:. enum EGeoHelixTypes { kHelixNeedUpdate; kHelixStraigth; kHelixCircle; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfB[3]normalized direction for magnetic field; Double_tfCcurvature in XY plane; Double_tfDir[3]direction after a step; Double_tfDirInit[3]normalized initial direction; TGeoHMatrix*fMatrixtransformation of local helix frame to MARS ; Double_tfPhiphi angle; Double_tfPoint[3]point after a step; Double_tfPointInit[3]initial point; Int_tfQright/left-handed (+/- 1) - ""charge""; Double_tfSZ step of the helix / 2*PI; Double_tfStepcurrent step. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 1E-6) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHelix.html:7705,charge,charge,7705,root/html534/TGeoHelix.html,https://root.cern,https://root.cern/root/html534/TGeoHelix.html,2,['charge'],['charge']
Energy Efficiency,"&os) const override;  Print class name of dataset. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Interface for detailed printing of object. ;  ; void printName (std::ostream &os) const override;  Print name of dataset. ;  ; void printTitle (std::ostream &os) const override;  Print title of dataset. ;  ; void RecursiveRemove (TObject *obj) override;  If one of the TObject we have a referenced to is deleted, remove the reference. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const char *cut) const;  Create a subset of the data set by applying the given cut on the data points. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooArgSet &varSubset, const char *cut=nullptr) const;  Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooArgSet &varSubset, const RooFormulaVar &cutVar) const;  Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create a reduced copy of this dataset. ;  ; RooFit::OwningPtr< RooAbsData > reduce (const RooFormulaVar &cutVar) const;  Create a subset of the data set by applying the given cut on the data points. ;  ; virtual void reset ();  ; void resetBuffers ();  ; RooRealVar * rmsVar (const RooRealVar &var, const char *cutSpec=nullptr, const char *cutRange=nullptr) const;  Create a RooRealVar containing the RMS of observable 'var' in this dataset. ;  ; void setDirtyProp (bool flag);  Control propagation of dirty flags from observables in dataset. ;  ; void setGlobalObservables (RooArgSet const &globalObservables);  Sets the g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeData.html:7885,reduce,reduce,7885,doc/master/classRooTreeData.html,https://root.cern,https://root.cern/doc/master/classRooTreeData.html,2,['reduce'],['reduce']
Energy Efficiency,"&ref);  Get reference for the qry-th query in fQueries (as displayed by ShowQueries). ;  ; Int_t GoMoreParallel (Int_t nWorkersToAdd);  Add nWorkersToAdd workers to current list of workers. ;  ; Int_t GoParallel (Int_t nodes, Bool_t accept=kFALSE, Bool_t random=kFALSE);  Go in parallel mode with at most ""nodes"" slaves. ;  ; Int_t HandleInputMessage (TSlave *wrk, TMessage *m, Bool_t deactonfail=kFALSE);  Analyze the received message. ;  ; void HandleSubmerger (TMessage *mess, TSlave *sl);  Process a message of type kPROOF_SUBMERGER. ;  ; void Interrupt (EUrgent type, ESlaves list=kActive);  Send interrupt to master or slave servers. ;  ; void InterruptCurrentMonitor ();  If in active in a monitor set ready state. ;  ; Bool_t IsEndMaster () const;  ; Bool_t IsSync () const;  ; Int_t LoadPackage (const char *package, Bool_t notOnClient=kFALSE, TList *loadopts=0, TList *workers=0);  Load specified package. ;  ; void MarkBad (TSlave *wrk, const char *reason=0);  Add a bad slave server to the bad slave list and remove it from the active list and from the two monitor objects. ;  ; void MarkBad (TSocket *s, const char *reason=0);  Add slave with socket s to the bad slave list and remove if from the active list and from the two monitor objects. ;  ; Int_t ModifyWorkerLists (const char *ord, Bool_t add, Bool_t save);  Modify the worker active/inactive list by making the worker identified by the ordinal number 'ord' active (add == TRUE) or inactive (add == FALSE). ;  ; void NotifyLogMsg (const char *msg, const char *sfx=""\n"");  Notify locally 'msg' to the appropriate units (file, stdout, window) If defined, 'sfx' is added after 'msg' (typically a line-feed);. ;  ; void operator= (const TProof &);  ; void ParseConfigField (const char *config);  The config file field may contain special instructions which need to be parsed at the beginning, e.g. ;  ; Int_t Ping (ESlaves list);  Ping PROOF slaves. Returns the number of slaves that responded. ;  ; void PrintProgress (Long64_t tota",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:50702,monitor,monitor,50702,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['monitor'],['monitor']
Energy Efficiency,"&source) override;  Insert matrix source starting at [row_lwb][col_lwb] in a symmetric fashion, thereby overwriting the part [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. ;  ; TMatrixTBase< Element > & Shift (Int_t row_shift, Int_t col_shift) override;  Shift the row index by adding row_shift and the column index by adding col_shift, respectively. ;  ; TMatrixTSym< Element > & Similarity (const TMatrixT< Element > &n);  Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb) This is a similarity transform when B is orthogonal . ;  ; TMatrixTSym< Element > & Similarity (const TMatrixTSym< Element > &n);  Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb) This is a similarity transform when B is orthogonal . ;  ; Element Similarity (const TVectorT< Element > &v) const;  Calculate scalar v * (*this) * v^T. ;  ; TMatrixTSym< Element > & SimilarityT (const TMatrixT< Element > &n);  Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb) It is more efficient than applying the actual multiplication because this routine realizes that the final matrix is symmetric . ;  ; void Streamer (TBuffer &) override;  Stream an object of class TMatrixTSym. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; TMatrixTSym< Element > & T ();  ; void TMult (const TMatrixT< Element > &a);  Replace this matrix with C such that C = A' * A. ;  ; void TMult (const TMatrixTSym< Element > &a);  Matrix multiplication, with A symmetric Replace this matrix with C such that C = A' * A = A * A = A * A'. ;  ; TMatrixTSym< Element > & Transpose (const TMatrixTSym< Element > &source);  Transpose a matrix. ;  ; const TMatrixTSym< Element > & Use (const TMatrixTSym< Element > &a) const;  ; const TMatrixTSym< Element > & Use (Int_t nrows, const Element *data) const;  ; TMatrixTSym< Element > & Use (Int_t nrows, Element *data);  ; const TMatrixTSym< Element > & Use (Int_t row_lwb, Int_t row_upb, const Element *data) const;  ; TMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSym.html:9106,efficient,efficient,9106,doc/master/classTMatrixTSym.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSym.html,1,['efficient'],['efficient']
