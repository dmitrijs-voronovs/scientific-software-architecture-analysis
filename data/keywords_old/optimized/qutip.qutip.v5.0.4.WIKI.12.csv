quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance,"{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\) [Hav03], [Wat13].; To represent superoperators acting on \(\mathcal{L}(\mathcal{H}_1 \otimes \mathcal{H}_2)\) thus takes some tensor rearrangement to get the desired ordering; \(\mathcal{H}_1 \otimes \mathcal{H}_2 \otimes \mathcal{H}_1 \otimes \mathcal{H}_2\).; In particular, this means that qutip.tensor does not act as; one might expect on the results of qutip.to_super:; In [27]: A = qeye([2]). In [28]: B = qeye([3]). In [29]: to_super(tensor(A, B)).dims; Out[29]: [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. In [30]: tensor(to_super(A), to_super(B)).dims; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-tensor.html:10680,perform,performs,10680,docs/4.2/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-tensor.html,5,['perform'],['performs']
Performance,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Features. QuTiP is the original quantum framework written in Python; the most widely ; used programming language in the quantum sciences. Python's straightforward syntax allows for constructing, manipulating, and evolving quantum objects using QuTiP with just a few lines of code. Easy to learn, and 100% open-source, QuTiP is the ideal toolbox for research or the classroom. Did you know that you can determine if an operator is Hermitian without performing the conjugate transpose? QuTiP does. In fact, it is just one of many custom algorithms that QuTiP uses to maximize performance. Focusing on sparse matrices, and the means by which to efficiently manipulate these data structures, allows QuTiP to tackle even the largest quantum mechanical calculations. ; . In addition to custom algorithms, QuTiP is capable of leveraging the multiprocessing power inside every modern computer. Taking advantage of the Python multiprocessing library, OPENMP, SSE3 processor extensions, and the Intel MKL, if available, allows for faster manipulation of quantum objects, and increased performance of evolution equations, without any work at all.; . QuTiP includes a variety of builtin solvers for dynamical simulations. In addition to the standard Lindblad and Monte Carlo Solvers, QuTiP includes routines for Bloch-Redfield evolution, periodic systems using the Floquet formalism, and stochastic solvers. Add to this, steady state analysis and non-Markovian techniques, and you have a wide variety of tools from which to explore your systems behavior. A wide range of time-dependent evolution simulations can be runtime compiled into C++ behind the scenes using Cython. Thus, you get the ease of use of the Python programming lang",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/features.html:728,perform,performing,728,features.html,https://qutip.org,https://qutip.org/features.html,2,['perform'],"['performance', 'performing']"
Performance,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP Contributors; The development of QuTiP is a community based effort with several developers contributing, or helping to add, many new features to the growing list of QuTiP functions:; Original Developers. Paul Nation; IBM Q; Library designer and main contributor. Robert Johansson; Tokyo, Japan; Library designer and main contributor. Project Governance; The governance process and model for the QuTiP Project can be found here. It contains a charter document.; Admin Team. Alex Pitchford; Aberystwyth University; Main focus: Quantum optimal control, solvers. Eric Giguère; Université de Sherbrooke; Main focus: Stochastic solvers, code optimization. Nathan Shammah; RIKEN; Main focus: Symmetrical models, education and outreach. Shahnawaz Ahmed; Chalmers; Main focus: Machine learning, Non-Markovian dynamics. Neill Lambert; RIKEN; Main focus: Non-Markovian dynamics, counting statistics. Boxi Li; Forschungszentrum Juelich; Main focus: Quantum control, Quantum device simulation. Jake Lishman; Imperial College London; Main focus: Core data model and linear algebra. Simon Cross; RIKEN; Main focus: Quantum control, machine learning, general maintenance. Asier Galicia; Forschungszentrum Juelich; Main focus: Core data model and backends. Paul Menczel; RIKEN; Main focus: Quantum control, non-Markovian solvers, MPI. Patrick Hopf; Technical University of Munich; Main focus: Quantum control. Board Members. Anton Frisk Kockum; Chalmers University of Technology. Daniel Burgarth; Macquarie University. Franco Nori; RIKEN / University of Michigan. Rob Johansson; Rakuten. Will Zeng; Unitary Fund. Core Contributors. Arne Grimsmo; Université de Sherbrooke. Chris Grenade; University of Sydney. Additional Developers. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/devs.html:922,optimiz,optimization,922,devs.html,https://qutip.org,https://qutip.org/devs.html,1,['optimiz'],['optimization']
Performance,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP Virtual Lab. Exploring simple quantum systems with QuTiP can help build intuition for them,; but there are many cases where writing code and Jupyter notebooks can get; in the way:. When teaching, coding can be a big distraction. Quantum mechanics is complex ; enough without your students having to struggle with installing software,; messing up their notebooks or learning QuTiP at the same time. When doing research, coding can be a big detour. You just want to do a quick; check to remind yourself how a simple system works, not spend the afternoon; fiddling in a text editor. You have papers to write and grant reports to fill; in. Time is precious. When at a party or while pitching your cool ideas, you don’t want to take out; your laptop to show people how cool your ideas are. It breaks the flow. You; need to be able to show them on your tablet. For all of these use cases, there is QuTiP Virtual Lab – a tablet and web; optimized graphical interface for building and exploring simple quantum systems.; It runs entirely in your browser, so there’s no server and nothing to install.; Click the button below to get started!; Enter QuTiP Virtual Lab.; There’s a handy tutorial with videos included in the virtual lab itself and some pre-built systems; to get you started. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/qutip-virtual-lab.html:1216,optimiz,optimized,1216,qutip-virtual-lab.html,https://qutip.org,https://qutip.org/qutip-virtual-lab.html,1,['optimiz'],['optimized']
Performance,"﻿. Saving QuTiP Objects and Data Sets — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename exte",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-saving.html:566,load,loading,566,docs/4.6/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html,4,['load'],['loading']
Safety," # XXX: This needs to be revised now that; # dpsi_t is the change for all stochastic collapse operators. # TODO: needs to be updated to support mutiple Weiner increments; dpsi_t_H = (-1.0j * dt) * spmv(H, psi_t). psi_t_1 = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt +; d2(A, psi_t)[0] * dW[a_idx, 0]); psi_t_p = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt +; d2(A, psi_t)[0] * sqrt_dt); psi_t_m = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt -; d2(A, psi_t)[0] * sqrt_dt). dpsi_t += (; 0.50 * (d1(A, psi_t_1) + d1(A, psi_t)) * dt +; 0.25 * (d2(A, psi_t_p)[0] + d2(A, psi_t_m)[0] +; 2 * d2(A, psi_t)[0]) * dW[a_idx, 0] +; 0.25 * (d2(A, psi_t_p)[0] - d2(A, psi_t_m)[0]) *; (dW[a_idx, 0] ** 2 - dt) / sqrt_dt; ). return dpsi_t. # -----------------------------------------------------------------------------; # Milstein rhs functions for the stochastic master equation; #; def _rhs_rho_milstein_homodyne_single(L, rho_t, t, A_ops, dt, dW, d1, d2,; args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection with single jump operator. """"""; A = A_ops[0]; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_t, 0). d2_vec = spmv(M, rho_t); d2_vec2 = spmv(M, d2_vec); e2 = cy_expect_rho_vec(M, d2_vec, 0). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += spmv(A[7], rho_t) * dt; drho_t += (d2_vec - e1 * rho_t) * dW[0, 0]; drho_t += 0.5 * (d2_vec2 - 2 * e1 * d2_vec + (-e2 + 2 * e1 * e1) *; rho_t) * (dW[0, 0] * dW[0, 0] - dt); return rho_t + drho_t. def _rhs_rho_milstein_homodyne(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection.; This implementation works for commuting stochastic jump operators.; TODO: optimizations: do calculation for n>m only. """"""; A_len = len(A_ops). M = np.array([A_ops[n][0] + A_ops[n][3] for n in range(A_len)]); e1 = np.array([cy_expect_rho_vec(M[n], rho_t, 0) for n in range(A_len)]). d1_vec = np.sum([spmv(A_ops[n][7], rho_t); for n in range(A_len)], axis=0). d2_vec = np.array([spmv(M[n], rho_t)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:50403,detect,detection,50403,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,5,['detect'],['detection']
Safety," 'general_stochastic']. def stochastic_solvers():; """"""Available solvers for ssesolve and smesolve; euler-maruyama:; A simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations.; Only solver which could take non-commuting sc_ops. *not tested*; -Order 0.5; -Code: 'euler-maruyama', 'euler', 0.5. milstein, Order 1.0 strong Taylor scheme:; Better approximate numerical solution to stochastic; differential equations.; -Order strong 1.0; -Code: 'milstein', 1.0; Numerical Solution of Stochastic Differential Equations; Chapter 10.3 Eq. (3.1), By Peter E. Kloeden, Eckhard Platen. milstein-imp, Order 1.0 implicit strong Taylor scheme:; Implicit milstein scheme for the numerical simulation of stiff; stochastic differential equations.; -Order strong 1.0; -Code: 'milstein-imp'; Numerical Solution of Stochastic Differential Equations; Chapter 12.2 Eq. (2.9), By Peter E. Kloeden, Eckhard Platen. predictor-corrector:; Generalization of the trapezoidal method to stochastic; differential equations. More stable than explicit methods.; -Order strong 0.5, weak 1.0; Only the stochastic part is corrected.; (alpha = 0, eta = 1/2); -Code: 'pred-corr', 'predictor-corrector', 'pc-euler'; Both the deterministic and stochastic part corrected.; (alpha = 1/2, eta = 1/2); -Code: 'pc-euler-imp', 'pc-euler-2', 'pred-corr-2'; Numerical Solution of Stochastic Differential Equations; Chapter 15.5 Eq. (5.4), By Peter E. Kloeden, Eckhard Platen. platen:; Explicit scheme, create the milstein using finite difference instead of; derivatives. Also contain some higher order terms, thus converge better; than milstein while staying strong order 1.0.; Do not require derivatives, therefore usable for; :func:`qutip.stochastic.general_stochastic`; -Order strong 1.0, weak 2.0; -Code: 'platen', 'platen1', 'explicit1'; The Theory of Open Quantum Systems; Chapter 7 Eq. (7.47), H.-P Breuer, F. Petruccione. rouchon:; Scheme keeping the positivity of the density matr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:3801,predict,predictor-corrector,3801,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,1,['predict'],['predictor-corrector']
Safety," = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [45]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [46]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [47]: args = {'A': 9, 'sig': 5}. In [48]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [49]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [50]: args = {'A': 9, 'sig': 5}. In [51]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.36s. Est. time left: 00:00:00:03; 20.0%. Run time: 0.64s. Est. time left: 00:00:00:02; 30.0%. Run time: 0.93s. Est. time left: 00:00:00:02; 40.0%. Run time: 1.21s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.48s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.76s. Est. time left: 00:00:00:01; 70.0%. Run time: 2.00s. Est. time left: 00:00:00:00; 80.0%. Run time: 2.23s. Est. time left: 00:00:00:00; 90.0%. Run time: 2.46s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:14374,avoid,avoid,14374,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,1,['avoid'],['avoid']
Safety," = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [45]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [46]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [47]: args = {'A': 9, 'sig': 5}. In [48]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [49]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [50]: args = {'A': 9, 'sig': 5}. In [51]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.95s. Est. time left: 00:00:00:08; 20.0%. Run time: 1.81s. Est. time left: 00:00:00:07; 30.0%. Run time: 2.67s. Est. time left: 00:00:00:06; 40.0%. Run time: 3.59s. Est. time left: 00:00:00:05; 50.0%. Run time: 4.42s. Est. time left: 00:00:00:04; 60.0%. Run time: 5.27s. Est. time left: 00:00:00:03; 70.0%. Run time: 6.10s. Est. time left: 00:00:00:02; 80.0%. Run time: 6.91s. Est. time left: 00:00:00:01; 90.0%. Run time: 7.74s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:13914,avoid,avoid,13914,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,1,['avoid'],['avoid']
Safety," A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, while \(S_n\) (sc_ops) are monitored operators. The deterministic part of the evolution, described by the \(d_1\) in Equation (1), takes into account all operators \(C_i\) and \(S_n\):. (9)¶\[d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,\]; The stochastic part, \(d_{2,n}\), is given solely by the operators \(S_n\). (10)¶\[d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \tr \left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; stor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:4980,detect,detection,4980,docs/4.6/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html,4,['detect'],['detection']
Safety," Array of length d2_len, containing scaling factors for each; measurement operator in m_ops. rhs¶; function – Function for calculating the deterministic and stochastic contributions; to the right-hand side of the stochastic differential equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops¶; function – Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise¶; function – Function for generate an array of pre-computed noise signal. homogeneous¶; bool (True) – Wheter or not the stochastic process is homogenous. Inhomogenous; processes are only supported for poisson distributions. solver¶; string – Name of the solver method to use for solving the stochastic; equations. Valid values are:; 1/2 order algorithms: ‘euler-maruyama’, ‘fast-euler-maruyama’,; ‘pc-euler’ is a predictor-corrector method which is more; stable than explicit methods,; 1 order algorithms: ‘milstein’, ‘fast-milstein’, ‘platen’,; ‘milstein-imp’ is semi-implicit Milstein method,; 3/2 order algorithms: ‘taylor15’,; ‘taylor15-imp’ is semi-implicit Taylor 1.5 method.; Implicit methods can adjust tolerance via args = {‘tol’:value},; default is {‘tol’:1e-6}. method¶; string (‘homodyne’, ‘heterodyne’, ‘photocurrent’) – The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution¶; string (‘normal’, ‘poission’) – The name of the distribution used for the stochastic increments. store_measurements¶; bool (default False) – Whether or not to store the measurement results in the; qutip.solver.SolverResult instance returned by the solver. noise¶; array – Vector specifying the noise. normalize¶; bool (default True) – Whether or not to normalize the wave function during",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:46790,predict,predictor-corrector,46790,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['predict'],['predictor-corrector']
Safety," BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (el",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/stats.html:2324,redund,redundant,2324,docs/4.1/modules/qutip/control/stats.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/stats.html,8,['redund'],['redundant']
Safety," Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.superop_reps. Source code for qutip.superop_reps; # -*- coding: utf-8 -*-; #; # This module was initially contributed by Ben Criger.; #; """"""; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms.; """""". __all__ = ['super_to_choi', 'choi_to_super', 'choi_to_kraus', 'kraus_to_choi',; 'kraus_to_super', 'choi_to_chi', 'chi_to_choi', 'to_choi',; 'to_chi', 'to_super', 'to_kraus', 'to_stinespring'; ]. # Python Standard Library; from itertools import starmap, product. # NumPy/SciPy; from numpy.core.multiarray import array, zeros; from numpy.core.shape_base import hstack; from numpy.matrixlib.defmatrix import matrix; from numpy import sqrt, floor, log2; from numpy import dot; from scipy.linalg import eig, svd; # Needed to avoid conflict with itertools.product.; import numpy as np. # Other QuTiP functions and classes; from qutip.superoperator import vec2mat, operator_to_vector, sprepost; from qutip.operators import identity, sigmax, sigmay, sigmaz; from qutip.tensor import tensor, flatten; from qutip.qobj import Qobj; from qutip.states import basis. # SPECIFIC SUPEROPERATORS -----------------------------------------------------. def _dep_super(pe):; """"""; Returns the superoperator corresponding to qubit depolarization for a; given parameter pe. TODO: if this is going into production (hopefully it isn't) then check; CPTP, expand to arbitrary dimensional systems, etc.; """"""; return Qobj(dims=[[[2], [2]], [[2], [2]]],; inpt=array([[1. - pe / 2., 0., 0., pe / 2.],; [0., 1. - pe, 0., 0.],; [0., 0., 1. - pe, 0.],; [pe / 2., 0., 0., 1. - pe / 2.]])). def _dep_choi(pe):; """"""; Returns the choi matrix corresponding to qubit depolarization for a; given parameter pe. TODO: if this is going into production (hopefull",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html:1130,avoid,avoid,1130,docs/4.7/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html,2,['avoid'],['avoid']
Safety," NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['liouvillian', 'liouvillian_ref', 'lindblad_dissipator',; 'operator_to_vector', 'vector_to_operator', 'mat2vec', 'vec2mat',; 'vec2mat_index', 'mat2vec_index', 'spost', 'spre', 'sprepost']. import scipy.sparse as sp; import numpy as np; from qutip.qobj import Qobj; from qutip.sparse import sp_reshape. [docs]def liouvillian(H, c_ops=[], data_only=False, chi=None):; """"""Assembles the Liouvillian superoperator from a Hamiltonian; and a ``list`` of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : array_like; A ``list`` or ``array`` of collapse operators. Returns; -------; L : qobj; Liouvillian superoperator. """""". if chi and len(chi) != len(c_ops):; raise ValueError('chi must be a list with same length as c_ops'). if H is not None:; if H.isoper:; op_dims = H.dims; op_shape = H.shape; elif H.issuper:; op_dims = H.dims[0]; op_shape = [np.prod(op_dims[0]), np.prod(op_dims[0])]; else:; raise TypeError(""Invalid type for Hamiltonian.""); else:; # no hamiltonian given, pick system size from a collapse operator; if isinstance(c_ops, list) and len(c_ops) > 0:; c = c_ops[0]; if c.isoper:; op_dims = c.dims; op_shape = c.shape; elif c.issuper:; op_dims = c.dims[0]; op_shape = [np.prod(op_dims[0]), np.prod(op_dims[0])]; else:; raise TypeError(""Invalid type for collapse operator.""); else:; raise TypeError(""Either H or c_ops must be given.""). sop_dims = [[op_d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/superoperator.html:3864,avoid,avoids,3864,docs/3.1.0/modules/qutip/superoperator.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/superoperator.html,1,['avoid'],['avoids']
Safety," QobjEvo. use_cython : bool; Flag to compile string to Cython or Python. safePickle : bool; Flag to not share pointers between thread.; """""". def __init__(self, Q_object=[], args={}, copy=True,; tlist=None, state0=None, e_ops=[]):; if isinstance(Q_object, QobjEvo):; if copy:; self._inplace_copy(Q_object); else:; self.__dict__ = Q_object.__dict__; if args:; self.arguments(args); for i, dargs in enumerate(self.dynamics_args):; e_int = dargs[1] == ""expect"" and isinstance(dargs[2], int); if e_ops and e_int:; self.dynamics_args[i] = (dargs[0], ""expect"",; e_ops[dargs[2]]); if state0 is not None:; self._dynamics_args_update(0., state0); return. self.const = False; self.dummy_cte = False; self.args = args.copy(); self.dynamics_args = []; self.cte = None; self.tlist = np.asarray(tlist) if tlist is not None else None; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.type = ""none""; self.omp = 0; self.coeff_files = []; self.use_cython = use_cython[0]; self.safePickle = safePickle[0]. # Attempt to determine if a 2-element list is a single, time-dependent; # operator, or a list with 2 possibly time-dependent elements.; if isinstance(Q_object, list) and len(Q_object) == 2:; try:; # Test if parsing succeeds on this as a single element.; self._td_op_type(Q_object); Q_object = [Q_object]; except (TypeError, ValueError):; pass. op_type = self._td_format_check(Q_object); self.ops = []. if isinstance(op_type, int):; if op_type == 0:; self.cte = Q_object; self.const = True; self.type = ""cte""; elif op_type == 1:; raise TypeError(""The Qobj must not already be a function""); elif op_type == -1:; pass; else:; op_type_count = [0, 0, 0, 0]; for type_, op in zip(op_type, Q_object):; if type_ == 0:; if self.cte is None:; self.cte = op; else:; self.cte += op; elif type_ == 1:; op_type_count[0] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""func"")); elif type_ == 2:; op_type_count[1] += 1; self.ops.append(EvoElement(op[0], _StrWrapper(op[1]),; op[1], ""string"")); e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:13678,safe,safePickle,13678,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,8,['safe'],['safePickle']
Safety," RuntimeError(""Safety check: d1(0., state0_vec) failed.:\n"" +; str(e)) from e; try:; out_d2 = d2(0., sso.rho0); except Exception as e:; raise RuntimeError(""Safety check: d2(0., state0_vec) failed:\n"" +; str(e)) from e. msg_d1 = (""d1 must return an 1d numpy array with the same number ""; ""of elements as the initial state as a vector.""); if not isinstance(out_d1, np.ndarray):; raise TypeError(msg_d1); if (out_d1.ndim != 1; or out_d1.shape[0] != l_vec or len(out_d1.shape) != 1):; raise ValueError(msg_d1). msg_d2 = (""Safety check: d2 must return a 2d numpy array ""; ""with the shape (len_d2, len(state0_vec) ).""); if not isinstance(out_d2, np.ndarray):; raise TypeError(msg_d2); if (out_d2.ndim != 2; or out_d2.shape[1] != l_vec or out_d2.shape[0] != len_d2):; raise ValueError(msg_d2); if out_d1.dtype != np.dtype('complex128') or \; out_d2.dtype != np.dtype('complex128'):; raise ValueError(""Safety check: d1 and d2 must return "" +; ""complex numpy array.""); msg_e_ops = (""Safety check: The shape of the e_ops ""; ""does not fit the intial state.""); for op in sso.e_ops:; shape_op = op.shape; if sso.me:; if shape_op[0]**2 != l_vec or shape_op[1]**2 != l_vec:; raise ValueError(msg_e_ops); else:; if shape_op[0] != l_vec or shape_op[1] != l_vec:; raise ValueError(msg_e_ops +; "" Expecting e_ops as superoperators.""). sso.m_ops = []; sso.cm_ops = []; if sso.store_measurement:; if not m_ops:; raise ValueError(""General stochastic needs explicit "" +; ""m_ops to store measurement.""); sso.m_ops = m_ops; sso.cm_ops = [QobjEvo(op) for op in sso.m_ops]; [op.compile() for op in sso.cm_ops]; if sso.dW_factors is None:; sso.dW_factors = [1.] * len(sso.m_ops); elif len(sso.dW_factors) == 1:; sso.dW_factors = sso.dW_factors * len(sso.m_ops); elif len(sso.dW_factors) != len(sso.m_ops):; raise ValueError(""The number of dW_factors must fit"" +; "" the number of m_ops.""). if sso.dW_factors is None:; sso.dW_factors = [1.] * len_d2; sso.sops = [None] * len_d2; sso.ce_ops = [QobjEvo(op) for op in sso.e_ops]; for ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:36738,Safe,Safety,36738,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,1,['Safe'],['Safety']
Safety," StepCoeffT(; self.ops, None, self.tlist); else:; self.coeff_get = InterCoeffT(; self.ops, None, self.tlist); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get). elif self.type == ""spline"":; self.coeff_get = InterpolateCoeff(self.ops, None, None); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get). else:; pass. coeff_files.clean(); if code:; return Code. def _get_coeff(self, t):; out = []; for part in self.ops:; out.append(part.get_coeff(t, self.args)); return out. def __getstate__(self):; _dict_ = {key: self.__dict__[key]; for key in self.__dict__ if key is not ""compiled_qobjevo""}; if self.compiled:; return (_dict_, self.compiled_qobjevo.__getstate__()); else:; return (_dict_,). def __setstate__(self, state):; self.__dict__ = state[0]; self.compiled_qobjevo = None; if self.compiled:; mat_type, threading, td = self.compiled.split(); if mat_type == ""csr"":; if self.safePickle:; # __getstate__ and __setstate__ of compiled_qobjevo pass pointers; # In 'safe' mod, these pointers are not used.; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte(); self.compiled_qobjevo.set_data(self.cte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp(); self.compiled_qobjevo.set_data(self.cte); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd(); self.compiled_qobjevo.set_data(self.cte, self.ops); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp(); self.compiled_qobjevo.set_data(self.cte, self.ops); self.compiled_qobjevo.set_threads(self.omp). if td == ""pyfunc"":; self.compiled_qobjevo.set_factor(func=self.coeff_get); elif td == ""cyfactor"":; self.compiled_qobjevo.set_factor(obj=self.coeff_get); else:; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte.__new__(CQobjCte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp.__new__(CQobjCt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:43876,safe,safePickle,43876,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,2,['safe'],"['safe', 'safePickle']"
Safety," Stochastic Solver; Homodyne detection. Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶. Homodyne detection¶; Homodyne detection is an extension of the photocurrent method where the output; is mixed with a strong external source allowing to get information about the; phase of the system. With this method, the resulting detection rate depends is. \[ \begin{align}\begin{aligned}:label: jump_rate\\\tau = tr \left((\gamma^2 + \gamma (C+C^\dag) + C^\dag C)\rho \right)\end{aligned}\end{align} \]; With \(\gamma\), the strength of the external beam and \(C\) the collapse; operator. When the beam is very strong \((\gamma >> C^\dag C)\),; the rate becomes a constant term plus a term proportional to the quadrature of; the system. Closed system¶; In closed systems, the resulting stochastic differential equation is. (1)¶\[\delta \psi(t) = - i H \psi(t) \delta t; - \sum_n \left( \frac{C_n^{+} C_n}{2} -\frac{e_n}{2} C_n; + \frac{e_n^2}{8} \right) \psi \delta t; + \sum_n \left( C_n - \frac{e_n}{2} \right) \psi \delta \omega\]; with. \[ \begin{align}\begin{aligned}:label: jump_rate\\e_n = \left<\psi(t)|C_n + C_n^{+}|\psi(t)\right>\end{aligned}\end{align} \]; Here \(\delta \omega\) is a Wiener increment.; In QuTiP, this is available with the function ssesolve.; In [1]: times = np.linspace(0.0, 10.0, 201). In [2]: p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-stochastic.html:1425,detect,detection,1425,docs/4.4/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-stochastic.html,1,['detect'],['detection']
Safety," TypeErrorQuantum operator is not square. extract_states(self, states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(self, order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(self, sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(self, bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:10285,safe,safe,10285,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['safe'],['safe']
Safety," TypeErrorQuantum operator is not square. extract_states(self, states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(self, order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(self, bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued mat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:10173,safe,safe,10173,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['safe'],['safe']
Safety," Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/changelog.html:3928,avoid,avoid,3928,docs/4.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.2/changelog.html,6,['avoid'],['avoid']
Safety," \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References¶; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes¶; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=, []data_only=False)¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters:H : qobj. System Hamiltonian. c_ops : array_like. A list or array of collapse operators. Returns:L : qobj. Liouvillian superoperator. spost(A)¶; Superoperator formed from post-multiplication by operator A. Parameters:A : qobj. Quantum operator for post multiplication. Returns:super : qobj. Superoperator formed from input qauntum object. spre(A)¶; Superoperator formed from pre-multiplication by operator A. Parameters:A : qobj. Quantum operator for pre-multiplication. Returns:super :qobj :. Superoperator formed from input quantum object. lindblad_dissipator(a, b=None, data_only=False)¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or for a single collapse operator (a) when b is not specified:. \[\mathcal{D}[a,b]\rho = a \rho b^\dagger -; \frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]. Parameters:a : qobj. Left part of collapse operator. b : qobj (optiona",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:21190,avoid,avoids,21190,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['avoid'],['avoids']
Safety," a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or for a single collapse operator (a) when b is not specified:. \[\mathcal{D}[a,b]\rho = a \rho b^\dagger -; \frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]. Parameters. aQobj or QobjEvoLeft part of collapse operator. bQobj or QobjEvo (optional)Right part of collapse operator. If not specified, b defaults to a. Returns. Dqobj, QobjEvoLindblad dissipator superoperator. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters. HQobj or QobjEvoSystem Hamiltonian. c_opsarray_like of Qobj or QobjEvoA list or array of collapse operators. Returns. LQobj or QobjEvoLiouvillian superoperator. operator_to_vector(op)[source]¶; Create a vector representation given a quantum operator in matrix form.; The passed object should have a Qobj.type of ‘oper’ or ‘super’; this; function is not designed for general-purpose matrix reshaping. Parameters. opQobj or QobjEvoQuantum operator in matrix form. This must have a type of ‘oper’ or; ‘super’. Returns. Qobj or QobjEvoThe same object, but re-cast into a column-stacked-vector form of type; ‘operator-ket’. The output is the same type as the passed object. spost(A)[source]¶; Superoperator formed from post-multiplication by operator A. Parameters. AQobj or QobjEvoQuantum operator for post multiplication. Returns. superQobj or QobjEvoSuperoperator formed from input qauntum object. spre(A)[source]¶;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:44836,avoid,avoids,44836,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['avoid'],['avoids']
Safety," compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenBLAS. (by Eric Giguère). Developer Changes¶. Converted more of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient compilation. (issue raised by nohchangsuk). Bug Fixes¶. Safer naming for temporary files. (by Eric Giguère); Fix clebsch function for half-integer (by Thomas Walker); Fix randint’s dtype to uint32 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in favour of scipy.sparse.csgraph. Developer Changes¶. Add Boxi Li to authors. (by Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (J",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:17316,unsafe,unsafe,17316,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,4,['unsafe'],['unsafe']
Safety," e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise ValueError(""Input rho has non-real eigenvalues.""); rvals = real(rvals); svals, svecs = sp_eigs(sigma.data, sigma.isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals) >= tol]; # Calculate S; S = nzrvals @ log_base(nzrvals) - rvals @ P @ log_base(svals); # the relative entropy is guaranteed to be >= 0, so we clamp the; # calculated value to 0 to avoid small violations of the lower bound.; return max(0, S). [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effectiv",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/entropy.html:9355,avoid,avoid,9355,docs/4.6/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html,6,"['Avoid', 'avoid']","['Avoid', 'avoid']"
Safety," eig_vec = np.linalg.eigh(H); else:; if sparse:; H = self._dyn_gen[k].toarray(); else:; H = self._dyn_gen[k]; # returns row vector of eigenvals, columns with the eigenvecs; eig_val, eig_vec = la.eigh(H). # assuming H is an nxn matrix, find n; n = self.get_drift_dim(). # Calculate the propagator in the diagonalised basis; eig_val_tau = -1j*eig_val*self.tau[k]; prop_eig = np.exp(eig_val_tau). # Generate the factor matrix through the differences; # between each of the eigenvectors and the exponentiations; # create nxn matrix where each eigen val is repeated n times; # down the columns; o = np.ones([n, n]); eig_val_cols = eig_val_tau*o; # calculate all the differences by subtracting it from its transpose; eig_val_diffs = eig_val_cols - eig_val_cols.T; # repeat for the propagator; prop_eig_cols = prop_eig*o; prop_eig_diffs = prop_eig_cols - prop_eig_cols.T; # the factor matrix is the elementwise quotient of the; # differeneces between the exponentiated eigen vals and the; # differences between the eigen vals; # need to avoid division by zero that would arise due to denegerate; # eigenvalues and the diagonals; degen_mask = np.abs(eig_val_diffs) < self.fact_mat_round_prec; eig_val_diffs[degen_mask] = 1; factors = prop_eig_diffs / eig_val_diffs; # for degenerate eigenvalues the factor is just the exponent; factors[degen_mask] = prop_eig_cols[degen_mask]. # Store eigenvectors, propagator and factor matric; # for use in propagator computations; self._decomp_curr[k] = True; if isinstance(factors, np.ndarray):; self._dyn_gen_factormatrix[k] = factors; else:; self._dyn_gen_factormatrix[k] = np.array(factors). if self.oper_dtype == Qobj:; self._prop_eigen[k] = Qobj(np.diagflat(prop_eig),; dims=self.dyn_dims); self._dyn_gen_eigenvectors[k] = Qobj(eig_vec,; dims=self.dyn_dims); # The _dyn_gen_eigenvectors_adj list is not used in; # memory optimised modes; if self._dyn_gen_eigenvectors_adj is not None:; self._dyn_gen_eigenvectors_adj[k] = \; self._dyn_gen_eigenvectors[k].dag(); else",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:44630,avoid,avoid,44630,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,6,['avoid'],['avoid']
Safety," equations to stochastic differential equations.; Only solver which could take non-commuting sc_ops. not tested; -Order 0.5; -Code: ‘euler-maruyama’, ‘euler’, 0.5. milstein, Order 1.0 strong Taylor scheme:Better approximate numerical solution to stochastic; differential equations.; -Order strong 1.0; -Code: ‘milstein’, 1.0; Numerical Solution of Stochastic Differential Equations; Chapter 10.3 Eq. (3.1), By Peter E. Kloeden, Eckhard Platen. milstein-imp, Order 1.0 implicit strong Taylor scheme:Implicit milstein scheme for the numerical simulation of stiff; stochastic differential equations.; -Order strong 1.0; -Code: ‘milstein-imp’; Numerical Solution of Stochastic Differential Equations; Chapter 12.2 Eq. (2.9), By Peter E. Kloeden, Eckhard Platen. predictor-corrector:Generalization of the trapezoidal method to stochastic; differential equations. More stable than explicit methods.; -Order strong 0.5, weak 1.0; Only the stochastic part is corrected. (alpha = 0, eta = 1/2); -Code: ‘pred-corr’, ‘predictor-corrector’, ‘pc-euler’. Both the deterministic and stochastic part corrected.(alpha = 1/2, eta = 1/2); -Code: ‘pc-euler-imp’, ‘pc-euler-2’, ‘pred-corr-2’. Numerical Solution of Stochastic Differential Equations; Chapter 15.5 Eq. (5.4), By Peter E. Kloeden, Eckhard Platen. platen:Explicit scheme, create the milstein using finite difference instead of; derivatives. Also contain some higher order terms, thus converge better; than milstein while staying strong order 1.0.; Do not require derivatives, therefore usable for; qutip.stochastic.general_stochastic; -Order strong 1.0, weak 2.0; -Code: ‘platen’, ‘platen1’, ‘explicit1’; The Theory of Open Quantum Systems; Chapter 7 Eq. (7.47), H.-P Breuer, F. Petruccione. rouchon:Scheme keeping the positivity of the density matrix. (smesolve only); -Order strong 1.0?; -Code: ‘rouchon’, ‘Rouchon’; Eq. 4 of arXiv:1410.5345 with eta=1; Efficient Quantum Filtering for Quantum Feedback Control; Pierre Rouchon, Jason F. Ralph; arXiv:1410.53",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:95223,predict,predictor-corrector,95223,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['predict'],['predictor-corrector']
Safety," example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-parfor.html:2536,avoid,avoid,2536,docs/4.2/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-parfor.html,5,['avoid'],['avoid']
Safety," function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.12s. Est. time left: 00:00:00:01; 20.0%. Run time: 0.20s. Est. time left: 00:00:00:00; 30.0%. Run time: 0.28s. Est. time left: 00:00:00:00; 40.0%. Run time: 0.36s. Est. time left: 00:00:00:00; 50.0%. Run time: 0.44s. Est. time left: 00:00:00:00; 60.0%. Run time: 0.52s. Est. time left: 00:00:00:00; 70.0%. Run time: 0.60s. Est. time left: 00:00:00:00; 80.0%. Run time: 0.68s. Est. time left: 00:00:00:00; 90.0%. Run time: 0.76s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:16964,avoid,avoid,16964,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,1,['avoid'],['avoid']
Safety," function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.13s. Est. time left: 00:00:00:01; 20.0%. Run time: 0.22s. Est. time left: 00:00:00:00; 30.0%. Run time: 0.31s. Est. time left: 00:00:00:00; 40.0%. Run time: 0.40s. Est. time left: 00:00:00:00; 50.0%. Run time: 0.49s. Est. time left: 00:00:00:00; 60.0%. Run time: 0.58s. Est. time left: 00:00:00:00; 70.0%. Run time: 0.67s. Est. time left: 00:00:00:00; 80.0%. Run time: 0.76s. Est. time left: 00:00:00:00; 90.0%. Run time: 0.86s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:16798,avoid,avoid,16798,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,1,['avoid'],['avoid']
Safety," function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.24s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.44s. Est. time left: 00:00:00:01; 30.0%. Run time: 0.62s. Est. time left: 00:00:00:01; 40.0%. Run time: 0.80s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.00s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.23s. Est. time left: 00:00:00:00; 70.0%. Run time: 1.42s. Est. time left: 00:00:00:00; 80.0%. Run time: 1.62s. Est. time left: 00:00:00:00; 90.0%. Run time: 1.82s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:16895,avoid,avoid,16895,docs/4.3/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html,1,['avoid'],['avoid']
Safety," keyword except check can be removed once scipy 1.1; # is a minimum requirement; try:; v, check = sp.linalg.bicgstab(A[-2], drho_t, x0=drho_t + a,; tol=args['tol'], atol='legacy'); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = sp.linalg.bicgstab(A[-2], drho_t, x0=drho_t + a,; tol=args['tol']). return v. def _rhs_rho_taylor_15_implicit(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; Drift implicit Taylor 1.5 (alpha = 1/2, beta = doesn't matter); Chaptert 12.2 Eq. (2.18) in Numerical Solution of Stochastic Differential Equations; By Peter E. Kloeden, Eckhard Platen; """""". dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = b * dW[0]; drho_t += Lb * dW[1] # Milstein term; xx0 = (drho_t + a * dt) + rho_t #starting vector for the linear solver (Milstein prediction); drho_t += (0.5 * dt) * a. # new terms:; drho_t += A[-1] * b * (dW[2] - 0.5*dW[0]*dt); drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]. drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]; drho_t += rho_t. #FIXME: This atol keyword except check can be removed once scipy 1.1; # is a minimum requirement; try:; v, check = sp.linalg.bicgstab(A[-2], drho_t, x0=xx0,; tol=args['tol'], atol='legacy'); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = sp.linalg.bicgstab(A[-2], drho_t, x0=xx0,; tol=args['tol']); return v. def _rhs_rho_pred_corr_homodyne_single(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; 1/2 predictor-corrector scheme for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]. #predictor. d_vec = (A[0][0] * rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_pred",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/stochastic.html:56768,predict,prediction,56768,docs/4.3/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/stochastic.html,1,['predict'],['prediction']
Safety," len(times)""); if noise.shape[2] < nsubsteps:; raise Exception(""'noise' does not have the right shape"" +; ""shape[2] >= nsubsteps""); if noise.shape[3] < len(self.sc_ops) * dw_len:; raise Exception(""'noise' does not have the right shape: "" +; ""shape[3] >= len(self.sc_ops)"" +; dw_len_str); self.noise_type = 1; self.noise = noise. else:; self.noise = np.random.randint(0, 2**32, ntraj).astype(""u4""); self.noise_type = 0. # Map; self.progress_bar = progress_bar; if self.ntraj > 1 and map_func:; self.map_func = map_func; else:; self.map_func = serial_map; self.map_kwargs = map_kwargs if map_kwargs is not None else {}. # Other; self.options = options; self.args = args; self.set_solver(); self.p = noiseDepth. def set_solver(self):; if self.solver in ['euler-maruyama', 'euler', 50, 0.5]:; self.solver_code = 50; self.solver = 'euler-maruyama'; elif self.solver in ['platen', 'platen1', 'explicit1', 100]:; self.solver_code = 100; self.solver = 'platen'; elif self.solver in ['pred-corr', 'predictor-corrector',; 'pc-euler', 101]:; self.solver_code = 101; self.solver = 'pred-corr'; elif self.solver in ['milstein', 102, 1.0]:; self.solver_code = 102; self.solver = 'milstein'; elif self.solver in ['milstein-imp', 103]:; self.solver_code = 103; self.solver = 'milstein-imp'; elif self.solver in ['pred-corr-2', 'pc-euler-2', 'pc-euler-imp', 104]:; self.solver_code = 104; self.solver = 'pred-corr-2'; elif self.solver in ['Rouchon', 'rouchon', 120]:; self.solver_code = 120; self.solver = 'rouchon'; if not all((op.const for op in self.sc_ops)):; raise Exception(""Rouchon only work with constant sc_ops""); elif self.solver in ['platen15', 'explicit1.5', 'explicit15', 150]:; self.solver_code = 150; self.solver = 'explicit1.5'; elif self.solver in ['taylor15', 'taylor1.5', None, 1.5, 152]:; self.solver_code = 152; self.solver = 'taylor1.5'; elif self.solver in ['taylor15-imp', 'taylor1.5-imp', 153]:; self.solver_code = 153; self.solver = 'taylor1.5-imp'; elif self.solver in ['taylor2.0', 'taylor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:15851,predict,predictor-corrector,15851,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,1,['predict'],['predictor-corrector']
Safety," mapping of `values` to the function `task`. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of ; ``task(value, *task_args, **task_kwargs)`` for ; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/parallel.html:8056,timeout,timeout,8056,docs/4.3/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/parallel.html,1,['timeout'],['timeout']
Safety," np.ndarray) and state.ndim == 2:; s1 = self.cte.shape[1]; new_l = int(np.sqrt(s1)); for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state.ravel(""F""); elif what == ""mat"":; self.args[name] = state; elif what == ""expect"":; self.args[name] = op.expect(t, state); elif state.shape[1] == 1:; self.args[name] = Qobj(state, dims=[self.cte.dims[1], [1]]); elif state.shape[1] == s1:; self.args[name] = Qobj(state, dims=self.cte.dims); else:; self.args[name] = Qobj(state). else:; raise TypeError(""state must be a Qobj or np.ndarray""). [docs] def copy(self):; """"""Return a copy of this object.""""""; new = QobjEvo(self.cte.copy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:20138,safe,safePickle,20138,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,2,['safe'],['safePickle']
Safety," qutip.operators import qeye; from qutip.semidefinite import dnorm_problem, dnorm_sparse_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger('qutip.metrics'). try:; import cvxpy; except ImportError:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; if B.isket or B.isbra:; # The fidelity for pure states reduces to the modulus of their; # inner product.; return np.abs(A.overlap(B)); # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = (sqrtmA * B * sqrtmA).eigenenergies(); return float(np.real(np.sqrt(eig_vals[eig_vals > 0]).sum())). [docs]def process_fidelity(U1, U2, normalize=True):; """"""; Calculate the process fidelity given two process operators.; """"""; if normalize:; return (U1 * U2).tr() / (U1.t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/metrics.html:2031,avoid,avoid,2031,docs/4.7/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html,2,['avoid'],['avoid']
Safety," simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum proce",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:2307,avoid,avoid,2307,docs/4.6/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html,2,['avoid'],['avoid']
Safety," that represents operators in for example an Hamiltonian, normalize; should be False. Returns:; q : Qobj; A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters:; order : str {‘C’, ‘F’}; Return array in C (default) or Fortran ordering. squeeze : bool {False, True}; Squeeze output array. Returns:; data : array; Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:; sparse : bool; Use sparse Eigensolver. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). safe : bool (default=True); Check for degenerate ground state. Returns:; eigval : float; Eigenvalue for the ground state of quantum operator. eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra : qobj; Quantum object of type ‘bra’ or ‘ket’. ket : qobj; Quantum object of type ‘ket’. Returns:; elem : complex; Complex valued matrix element. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:; norm : str; Which norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:10749,safe,safe,10749,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['safe'],['safe']
Safety," the class qutip.solver.Result. stochastic_solvers()[source]¶. Available solvers for ssesolve and smesolve; euler-maruyama:A simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations.; Only solver which could take non-commuting sc_ops. not tested; -Order 0.5; -Code: ‘euler-maruyama’, ‘euler’, 0.5. milstein, Order 1.0 strong Taylor scheme:Better approximate numerical solution to stochastic; differential equations.; -Order strong 1.0; -Code: ‘milstein’, 1.0; Numerical Solution of Stochastic Differential Equations; Chapter 10.3 Eq. (3.1), By Peter E. Kloeden, Eckhard Platen. milstein-imp, Order 1.0 implicit strong Taylor scheme:Implicit milstein scheme for the numerical simulation of stiff; stochastic differential equations.; -Order strong 1.0; -Code: ‘milstein-imp’; Numerical Solution of Stochastic Differential Equations; Chapter 12.2 Eq. (2.9), By Peter E. Kloeden, Eckhard Platen. predictor-corrector:Generalization of the trapezoidal method to stochastic; differential equations. More stable than explicit methods.; -Order strong 0.5, weak 1.0; Only the stochastic part is corrected. (alpha = 0, eta = 1/2); -Code: ‘pred-corr’, ‘predictor-corrector’, ‘pc-euler’. Both the deterministic and stochastic part corrected.(alpha = 1/2, eta = 1/2); -Code: ‘pc-euler-imp’, ‘pc-euler-2’, ‘pred-corr-2’. Numerical Solution of Stochastic Differential Equations; Chapter 15.5 Eq. (5.4), By Peter E. Kloeden, Eckhard Platen. platen:Explicit scheme, create the milstein using finite difference instead of; derivatives. Also contain some higher order terms, thus converge better; than milstein while staying strong order 1.0.; Do not require derivatives, therefore usable for; qutip.stochastic.general_stochastic; -Order strong 1.0, weak 2.0; -Code: ‘platen’, ‘platen1’, ‘explicit1’; The Theory of Open Quantum Systems; Chapter 7 Eq. (7.47), H.-P Breuer, F. Petruccione. rouchon:Scheme keeping the positivity of the density matrix. (smesolve on",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:94974,predict,predictor-corrector,94974,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['predict'],['predictor-corrector']
Safety," the dynamic arguments that the solvers will generate. These; are the magic names that were found in the ``args`` parameter. tlist : array_like; List of times at which the numpy-array coefficients are applied. compiled : str; A string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevo : ``CQobjCte`` or ``CQobjEvoTd``; Cython version of the QobjEvo. coeff_get : callable; Object called to obtain a list of all the coefficients at a particular; time. coeff_files : list; Runtime created files to delete with the instance. dummy_cte : bool; Is self.cte an empty Qobj. const : bool; Indicates if quantum object is constant. type : {""cte"", ""string"", ""func"", ""array"", ""spline"", ""mixed_callable"", \; ""mixed_compilable""}; Information about the type of coefficients used in the entire object. num_obj : int; Number of :obj:`~qutip.Qobj` in the QobjEvo. use_cython : bool; Flag to compile string to Cython or Python. safePickle : bool; Flag to not share pointers between thread.; """""". def __init__(self, Q_object=[], args={}, copy=True,; tlist=None, state0=None, e_ops=[]):; if isinstance(Q_object, QobjEvo):; if copy:; self._inplace_copy(Q_object); else:; self.__dict__ = Q_object.__dict__; if args:; self.arguments(args); for i, dargs in enumerate(self.dynamics_args):; e_int = dargs[1] == ""expect"" and isinstance(dargs[2], int); if e_ops and e_int:; self.dynamics_args[i] = (dargs[0], ""expect"",; e_ops[dargs[2]]); if state0 is not None:; self._dynamics_args_update(0., state0); return. self.const = False; self.dummy_cte = False; self.args = args.copy(); self.dynamics_args = []; self.cte = None; self.tlist = np.asarray(tlist) if tlist is not None else None; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.type = ""none""; self.omp = 0; self.coeff_files = []; self.use_cython = use_cython[0]; self.safePickle = safePickle[0]. # Attempt to determine if a 2-element list is a single, time-dependent; # operator, or a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:11105,safe,safePickle,11105,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,2,['safe'],['safePickle']
Safety," use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [5]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; In [6]: result = parallel_map(func1, range(10)). In [7]: result_array = np.array(result). In [8]: print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. In [9]: print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_map is not enforced to be NumPy arrays, which can avoid unnecessary copying if all that is needed is to iterate over the resulting list:; In [11]: result = parfor(func1, range(5)). In [12]: print(result); [array([0, 1, 2, 3, 4]), array([ 0, 1, 4, 9, 16]), array([ 0, 1, 8, 27, 64])]. In [13]: result = parallel_map(func1, range(5)). In [14]: print(result); [(0, 0, 0), (1, 1, 1), (2, 4, 8), (3, 9, 27), (4, 16, 64)]. The qutip.parallel.parallel_map and qutip.parallel.parfor functions are not limited to just numbers, but also works for a variety of outputs:; In [15]: def func2(x): return x, Qobj(x), 'a' * x. In [16]: a, b, c = parfor(func2, range(5)). In [17]: print(a); [0 1 2 3 4]. In [18]: print(b); [ Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 0.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 1.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 2.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = Tr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-parfor.html:3184,avoid,avoid,3184,docs/3.1.0/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-parfor.html,1,['avoid'],['avoid']
Safety," use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [5]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; In [6]: result = parallel_map(func1, range(10)). In [7]: result_array = np.array(result). In [8]: print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. In [9]: print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_map is not enforced to be NumPy arrays, which can avoid unnecessary copying if all that is needed is to iterate over the resulting list:; In [11]: result = parfor(func1, range(5)). In [12]: print(result); [array([0, 1, 2, 3, 4]), array([ 0, 1, 4, 9, 16]), array([ 0, 1, 8, 27, 64])]. In [13]: result = parallel_map(func1, range(5)). In [14]: print(result); [(0, 0, 0), (1, 1, 1), (2, 4, 8), (3, 9, 27), (4, 16, 64)]. The qutip.parallel.parallel_map and qutip.parallel.parfor functions are not limited to just numbers, but also works for a variety of outputs:; In [15]: def func2(x): return x, Qobj(x), 'a' * x. In [16]: a, b, c = parfor(func2, range(5)). In [17]: print(a); [0 1 2 3 4]. In [18]: print(b); [Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[1.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[2.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[3.]]; Quantum object: dims = [[1], [1]], shape = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-parfor.html:2425,avoid,avoid,2425,docs/4.5/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-parfor.html,1,['avoid'],['avoid']
Safety," {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the ; # main optmisation call sequence; self.set_coeffs(param_vals); ; def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]); ; def init_guess_pulse(self):; ; self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)); ; def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse; ; def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse; ; def _init_bounds(self):; add_guess_pulse_scale ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html:31775,avoid,avoided,31775,docs/4.1/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html,5,['avoid'],['avoided']
Safety,"""""Determines if given quantum object is a super-operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : qobj; Qobj one; B : qobj; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/qobj.html:56711,avoid,avoid,56711,docs/4.3/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qobj.html,1,['avoid'],['avoid']
Safety,"""Determines if given quantum object is a super-operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : qobj; Qobj one; B : qobj; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:53905,avoid,avoid,53905,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,1,['avoid'],['avoid']
Safety,"""Determines if given quantum object is a super-operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : qobj; Qobj one; B : qobj; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/qobj.html:53825,avoid,avoid,53825,docs/4.1/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/qobj.html,1,['avoid'],['avoid']
Safety,"#############################################################; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline; from functools import partial, wraps; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import _compile_str_single, _compiled_coeffs; from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi, spmv, cy_spmm_tr); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff); import pickle; import sys; import scipy; import os. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = False; if sys.platform == 'win32':; safePickle = True. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf+0j. str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """"""; def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_ + "".pyx""]. def clean(self):; for i, file_ in enumerate(self.files):; try:; os.remove(file_); except:; pass; if not os.path.isfile(file_):; # Don't exist anymore; del self.files[i]. def __del__(self):; self.clean(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html:2987,safe,safePickle,2987,docs/4.4/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"##########################################; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline, interp1d; from functools import partial; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import (_compile_str_single, _compiled_coeffs,; _compiled_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. try:; import cython; use_cython = [True]; except:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """"""; def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_ + "".pyx""]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; try:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:3023,safe,safePickle,3023,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,2,['safe'],['safePickle']
Safety,"########; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline, interp1d; from functools import partial, wraps; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import (_compile_str_single, _compiled_coeffs,; _compiled_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv, cy_spmm_tr); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import pickle; import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. try:; import cython; use_cython = [True]; except:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """"""; def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_ + "".pyx""]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; try:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:3037,safe,safePickle,3037,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"######; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline, interp1d; from functools import partial; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import (_compile_str_single, _compiled_coeffs,; _compiled_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. try:; import cython; use_cython = [True]; except:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """"""; def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_ + "".pyx""]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; try:; os.remove(file_); to_del.append(i);",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:3074,safe,safePickle,3074,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,2,['safe'],['safePickle']
Safety,")).astype(np.complex128). def _start(self, first: int):; """"""; Get the coherent state matrix corresponding to the first needed Fock; state.; """"""; if first == 0:; return self.prefactor.copy(); out = np.power(self.grid, first); out *= self.prefactor; return out. def __call__(self, first: int, last: int = None):; """"""; Get a 3D array of shape ``(yvec.size, xvec.size, last - first)`` of the; coherent-state vectors for all the Fock states in the range ``first``; to ``last``, excluding the end point. The first two axes are the y-; and x-coordinates of phase space (i.e. Cartesian indexing, like; ``numpy.meshgrid``), and the last runs over the selected range of; Fock-space dimensions.; """"""; ns = np.arange(first, last).reshape(1, 1, -1); # Technically we could avoid hitting the limits of floating-point; # exponents for longer by doing all this in logarithmic space (using; # scipy.special.gammaln), but that ends up involving more; # floating-point operations overall, and needs special care around the; # point alpha = 0 to avoid nan appearing, due to how Python handles; # mixed-width arithmetic operations.; out = np.empty(self.grid.shape + (ns.size,), dtype=np.complex128); out[:, :, 0] = self._start(ns.flat[0]); for i in range(ns.size - 1):; out[:, :, i+1] = out[:, :, i] * self.grid; out /= np.sqrt(scipy.special.factorial(ns)); return out. [docs]class QFunc:; r""""""; Class-based method of calculating the Husimi-Q function of many different; quantum states at fixed phase-space points ``0.5*g* (xvec + i*yvec)``.; This class has slightly higher first-usage costs than :obj:`.qfunc`, but; subsequent operations will be several times faster. However, it can require; quite a lot of memory. Call the created object as a function to retrieve; the Husimi-Q function. Parameters; ----------; xvec, yvec : array_like; x- and y-coordinates at which to calculate the Husimi-Q function. g : float, default sqrt(2); Scaling factor for ``a = 0.5 * g * (x + iy)``. The value of `g` is; related to the valu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/wigner.html:20480,avoid,avoid,20480,docs/4.6/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html,4,['avoid'],['avoid']
Safety,"* rho_t * (0.5 * dt); e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1). drho_t = b * dW[0] ; drho_t += a; drho_t += (A[0] * b - TrAb * rho_t - e0 * b) * dW[1] # Milstein term; drho_t += rho_t. v, check = sp.linalg.bicgstab(A[-2], drho_t, x0 = drho_t + a, tol=args['tol']). return v; ; def _rhs_rho_taylor_15_implicit(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; Drift implicit Taylor 1.5 (alpha = 1/2, beta = doesn't matter); Chaptert 12.2 Eq. (2.18) in Numerical Solution of Stochastic Differential Equations; By Peter E. Kloeden, Eckhard Platen; """"""; ; dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = b * dW[0] ; drho_t += Lb * dW[1] # Milstein term; xx0 = (drho_t + a * dt) + rho_t #starting vector for the linear solver (Milstein prediction); drho_t += (0.5 * dt) * a. # new terms: ; drho_t += A[-1] * b * (dW[2] - 0.5*dW[0]*dt); drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]. drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]; drho_t += rho_t. v, check = sp.linalg.bicgstab(A[-2], drho_t, x0 = xx0, tol=args['tol']). return v; ; def _rhs_rho_pred_corr_homodyne_single(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; 1/2 predictor-corrector scheme for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]; ; #predictor. d_vec = (A[0][0] * rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_pred = np.copy(d_vec[-1]); b_pred = - e[0] * rho_t; b_pred += d_vec[0]. pred_rho_t = np.copy(a_pred); pred_rho_t += b_pred * dW[0]; pred_rho_t += rho_t. a_pred -= ((d_vec[1] - e[1] * rho_t) - (2.0 * e[0]) * b_pred) * (0.5 * dt); ; #corrector. d_vec = (A[0][0] * pre",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:56544,predict,prediction,56544,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,3,['predict'],['prediction']
Safety,"* rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = b * dW[0]; drho_t += Lb * dW[1] # Milstein term; xx0 = (drho_t + a * dt) + rho_t #starting vector for the linear solver (Milstein prediction); drho_t += (0.5 * dt) * a. # new terms:; drho_t += A[-1] * b * (dW[2] - 0.5*dW[0]*dt); drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]. drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]; drho_t += rho_t. #FIXME: This atol keyword except check can be removed once scipy 1.1; # is a minimum requirement; try:; v, check = sp.linalg.bicgstab(A[-2], drho_t, x0=xx0,; tol=args['tol'], atol='legacy'); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = sp.linalg.bicgstab(A[-2], drho_t, x0=xx0,; tol=args['tol']); return v. def _rhs_rho_pred_corr_homodyne_single(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; 1/2 predictor-corrector scheme for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]. #predictor. d_vec = (A[0][0] * rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_pred = np.copy(d_vec[-1]); b_pred = - e[0] * rho_t; b_pred += d_vec[0]. pred_rho_t = np.copy(a_pred); pred_rho_t += b_pred * dW[0]; pred_rho_t += rho_t. a_pred -= ((d_vec[1] - e[1] * rho_t) - (2.0 * e[0]) * b_pred) * (0.5 * dt). #corrector. d_vec = (A[0][0] * pred_rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_corr = d_vec[-1]; b_corr = - e[0] * pred_rho_t; b_corr += d_vec[0]. a_corr -= ((d_vec[1] - e[1] * pred_rho_t) - (2.0 * e[0]) * b_corr) * (0.5 * dt); a_corr += a_pred; a_corr *= 0.5. b_corr += b_pred; b_corr *= 0.5 * dW[0]. corr_rho_t = a_corr; corr_rho_t += b_corr; corr_rho_t += rho_t. return corr_rho_t. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/stochastic.html:57462,predict,predictor-corrector,57462,docs/4.3/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/stochastic.html,2,"['detect', 'predict']","['detection', 'predictor-corrector']"
Safety,", k]); / (1 - np.abs(dot)**2)**0.5). subspace = vecs.conj().T @ ops[i].data @ vecs; eigvals, eigvecs = la.eig(subspace). perm = np.argsort(eigvals); eigvals = eigvals[perm]. vecs_new = vecs @ eigvecs[:, perm]; for k in range(len(eigvals)):; vecs_new[:, k] = vecs_new[:, k] / la.norm(vecs_new[:, k]). k = 0; while k < len(eigvals):; ttol = max(tol, tol * abs(eigvals[k])); inds, = np.where(abs(eigvals - eigvals[k]) < ttol); if len(inds) > 1: # if at least 2 eigvals are degenerate; vecs_new[:, inds] = _degen(tol, vecs_new[:, inds], ops, i+1); k = inds[-1] + 1; return vecs_new. [docs]def simdiag(ops, evals: bool = True, *,; tol: float = 1e-14, safe_mode: bool = True):; """"""Simultaneous diagonalization of commuting Hermitian matrices. Parameters; ----------; ops : list/array; ``list`` or ``array`` of qobjs representing commuting Hermitian; operators. evals : bool [True]; Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tol : float [1e-14]; Tolerance for detecting degenerate eigenstates. safe_mode : bool [True]; Whether to check that all ops are Hermitian and commuting. If set to; ``False`` and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns; --------; eigs : tuple; Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. """"""; if not ops:; raise ValueError(""No input matrices.""); N = ops[0].shape[0]; num_ops = len(ops) if safe_mode else 0; for jj in range(num_ops):; A = ops[jj]; shape = A.shape; if shape[0] != shape[1]:; raise TypeError('Matricies must be square.'); if shape[0] != N:; raise TypeError('All matrices. must be the same shape'); if not A.isherm:; raise TypeError('Matricies must be Hermitian'); for kk in range(jj):; B = ops[kk]; if (A * B - B * A).norm() / (A * B).norm() > tol:; raise TypeError('Matricies must commute.'). eigvals, eigvecs = la.eigh(ops[0].full()); p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/simdiag.html:3541,detect,detecting,3541,docs/4.6/modules/qutip/simdiag.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/simdiag.html,4,['detect'],['detecting']
Safety,", method=’dense’; is set as default.s. Returns:oper – Exponentiated quantum operator. Return type:qobj. Raises:TypeError – Quantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters:; states_inds (list of integer) – The states that should be kept.; normalize (True / False) – Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q – A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Return type:Qobj. Notes; Experimental. full(squeeze=False)[source]¶; Dense array from quantum object. Returns:data – Array of complex data from quantum objects data attribute. Return type:array. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:; sparse (bool) – Use sparse Eigensolver; tol (float) – Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used).; safe (bool (default=True)) – Check for degenerate ground state. Returns:; eigval (float) – Eigenvalue for the ground state of quantum operator.; eigvec (qobj) – Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra (qobj) – Quantum object of type ‘bra’.; ket (qobj) – Quantum object of type ‘ket’. Returns:elem – Comp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:10024,safe,safe,10024,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['safe'],['safe']
Safety,", n] + 2.0 * e1[n] * e1[n]) * rho_t) * (dW[n, 0]*dW[n, 0] - dt); for n in range(A_len)], axis=0). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; drho_t += 0.5 * np.sum(; [(d2_vec2[n, m] - e1[m] * d2_vec[n] - e1[n] * d2_vec[m] +; (-e2[n, m] + 2.0 * e1[n] * e1[m]) * rho_t) * (dW[n, 0] * dW[m, 0]); for (n, m) in np.ndindex(A_len, A_len) if n != m], axis=0). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_single_fast(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; fast Milstein for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with >2 stochastic operators; """"""; dW = ddW[:, 0]; sc_len = len(A); sc2_len = 2 * sc_len. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(d_vec[:-1].reshape(; -1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[sc2_len:-1] -= np.array(; [e[m] * d_vec[n] + e[n] * d_vec[m]; for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). e[sc_len:sc2_len] -= 2.0 * e[:sc_len] * e[:sc_len]; e[sc2_len:] -",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:49646,detect,detection,49646,docs/3.1.0/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html,1,['detect'],['detection']
Safety,", np.ndarray) and state.ndim == 2:; s1 = self.cte.shape[1]; new_l = int(np.sqrt(s1)); for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state.ravel(""F""); elif what == ""mat"":; self.args[name] = state; elif what == ""expect"":; self.args[name] = op.expect(t, state); elif state.shape[1] == 1:; self.args[name] = Qobj(state, dims=[self.cte.dims[1],[1]]); elif state.shape[1] == s1:; self.args[name] = Qobj(state, dims=self.cte.dims); else:; self.args[name] = Qobj(state). else:; raise TypeError(""state must be a Qobj or np.ndarray""). [docs] def copy(self):; """"""Return a copy of this object.""""""; new = QobjEvo(self.cte.copy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:21785,safe,safePickle,21785,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,2,['safe'],['safePickle']
Safety,",; self.cte.dims[1]]). elif isinstance(state, np.ndarray) and state.ndim == 2:; s1 = self.cte.shape[1]; new_l = int(np.sqrt(s1)); for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state.ravel(""F""); elif what == ""mat"":; self.args[name] = state; elif what == ""expect"":; self.args[name] = op.expect(t, state); elif state.shape[1] == 1:; self.args[name] = Qobj(state, dims=[self.cte.dims[1],[1]]); elif state.shape[1] == s1:; self.args[name] = Qobj(state, dims=self.cte.dims); else:; self.args[name] = Qobj(state). else:; raise TypeError(""state must be a Qobj or np.ndarray""). def copy(self):; new = QobjEvo(self.cte.copy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). def arguments(self, new_args):; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:21447,safe,safePickle,21447,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,",; type, local arguments ), ... ]; type :; 1: function; 2: string; 3: np.array; 4: Cubic_Spline. args : map; arguments of the coefficients. dynamics_args : list; arguments that change during evolution. tlist : array_like; List of times at which the numpy-array coefficients are applied. compiled : string; Has the cython version of the QobjEvo been created. compiled_qobjevo : cy_qobj (CQobjCte or CQobjEvoTd); Cython version of the QobjEvo. coeff_get : callable object; object called to obtain a list of coefficient at t. coeff_files : list; runtime created files to delete with the instance. dummy_cte : bool; is self.cte a empty Qobj. const : bool; Indicates if quantum object is Constant. type : string; information about the type of coefficient; ""string"", ""func"", ""array"",; ""spline"", ""mixed_callable"", ""mixed_compilable"". num_obj : int; number of Qobj in the QobjEvo : len(ops) + (1 if not dummy_cte). use_cython : bool; flag to compile string to cython or python. safePickle : bool; flag to not share pointers between thread. Methods; -------; copy() :; Create copy of Qobj. arguments(new_args):; Update the args of the object. Math:; +/- QobjEvo, Qobj, scalar:; Addition is possible between QobjEvo and with Qobj or scalar; -:; Negation operator; * Qobj, scalar:; Product is possible with Qobj or scalar; / scalar:; It is possible to divide by scalar only; conj(); Return the conjugate of quantum object. dag(); Return the adjoint (dagger) of quantum object. trans(); Return the transpose of quantum object. _cdc(); Return self.dag() * self. permute(order); Returns composite qobj with indices reordered. apply(f, *args, **kw_args); Apply the function f to every Qobj. f(Qobj) -> Qobj; Return a modified QobjEvo and let the original one untouched. apply_decorator(decorator, *args, str_mod=None,; inplace_np=False, **kw_args):; Apply the decorator to each function of the ops.; The *args and **kw_args are passed to the decorator.; new_coeff_function = decorator(coeff_function, *args, **kw_ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:10272,safe,safePickle,10272,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"-- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R0be8dcf25d86-1] . R0be8dcf25d86-1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters. HQobj or QobjEvoSystem Hamiltonian. c_opsarray_like of Qobj or QobjEvoA list or array of collapse operators. Returns. LQobj or QobjEvoLiouvillian superoperator. spost(A)[source]¶; Superoperator formed from post-multiplication by operator A. Parameters. AQobj or QobjEvoQuantum operator for post multiplication. Returns. superQobj or QobjEvoSuperoperator formed from input qauntum object. spre(A)[source]¶; Superoperator formed from pre-multiplication by operator A. Parameters. AQobj or QobjEvoQuantum operator for pre-multiplication. Returns. super :Qobj or QobjEvoSuperoperator formed from input quantum object. sprepost(A, B)[source]¶; Superoperator formed from pre-multiplication by operator A and post-; multiplication of operator B. Parameters. AQobj or QobjEvoQuantum operator for pre-multiplication. BQobj or QobjEvoQuantum operator for post-multiplication. Returns. superQobj or QobjEvoSuperoperator form",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:36065,avoid,avoids,36065,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['avoid'],['avoids']
Safety,"-------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters:H : qobj. System Hamiltonian. c_ops : array_like. A list or array of collapse operators. Returns:L : qobj. Liouvillian superoperator. spost(A)[source]¶; Superoperator formed from post-multiplication by operator A. Parameters:A : qobj. Quantum operator for post multiplication. Returns:super : qobj. Superoperator formed from input qauntum object. spre(A)[source]¶; Superoperator formed from pre-multiplication by operator A. Parameters:A : qobj. Quantum operator for pre-multiplication. Returns:super :qobj. Superoperator formed from input quantum object. sprepost(A, B)[source]¶; Superoperator formed from pre-multiplication by operator A and post-; multiplication of operator B. Parameters:A : Qobj. Quantum operator for pre-multiplication. B : Qobj. Quantum operator for post-multiplication. Returns:super : Qobj. Superoperator formed from input quantum objects. lindblad_dissipator(a, b=None, data_only=False)[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:36713,avoid,avoids,36713,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['avoid'],['avoids']
Safety,"------; |one> |two>. References; The naming of qutip operators follows the convention in [R0be8dcf25d86-1] . [R0be8dcf25d86-1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:; states : array; array of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:; ops : array; array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters:; H : qobj; System Hamiltonian. c_ops : array_like; A list or array of collapse operators. Returns:; L : qobj; Liouvillian superoperator. spost(A)[source]¶; Superoperator formed from post-multiplication by operator A. Parameters:; A : qobj; Quantum operator for post multiplication. Returns:; super : qobj; Superoperator formed from input qauntum object. spre(A)[source]¶; Superoperator formed from pre-multiplication by operator A. Parameters:; A : qobj; Quantum operator for pre-multiplication. Returns:; super :qobj; Superoperator formed from input quantum object. sprepost(A, B)[source]¶; Superoperator formed from pre-multiplication by operator A and post-; multiplication of operator B. Parameters:; A : Qobj; Quantum operator for pre-multiplication. B : Qobj; Quantum operator for post-multiplication. Returns:; super : Qobj; Superoperator formed from input quantum objects. lindblad_dissipator(a, b=None, d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:36982,avoid,avoids,36982,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['avoid'],['avoids']
Safety,"-----|one> ------- |three> -------; |one> |two>. References¶; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes¶; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters:H : qobj. System Hamiltonian. c_ops : array_like. A list or array of collapse operators. Returns:L : qobj. Liouvillian superoperator. spost(A)[source]¶; Superoperator formed from post-multiplication by operator A. Parameters:A : qobj. Quantum operator for post multiplication. Returns:super : qobj. Superoperator formed from input qauntum object. spre(A)[source]¶; Superoperator formed from pre-multiplication by operator A. Parameters:A : qobj. Quantum operator for pre-multiplication. Returns:super :qobj. Superoperator formed from input quantum object. sprepost(A, B)[source]¶; Superoperator formed from pre-multiplication by operator A and post-; multiplication of operator B. Parameters:A : Qobj. Quantum operator for pre-multiplication. B : Qobj. Quantum operator for post-multiplication. Returns:super : Qobj. Superoperator formed from input quantum objects. lindblad_dissipator(a, b=None, data_only=False)[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:26453,avoid,avoids,26453,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['avoid'],['avoids']
Safety,". . Stochastic Solver — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Homodyne detection. Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶. Homodyne detection¶; Homodyne detection is an extension of the photocurrent method where the output; is mixed with a strong external source allowing to get information about the; phase of the system. With this method, the resulting detection rate depends is. \[ \begin{align}\begin{aligned}:label: jump_rate\\\tau = tr \left((\gamma^2 + \gamma (C+C^\dag) + C^\dag C)\rho \right)\end{aligned}\end{align} \]; With \(\gamma\), the strength of the external beam and \(C\) the collapse; operator. When the beam is very strong \((\gamma >> C^\dag C)\),; the rate becomes a constant term plus a term proportional to the quadrature of; the system. Closed system¶; In closed systems, the resulting stochastic differential equation is. (1)¶\[\delta \psi(t) = - i H \psi(t) \delta t; - \sum_n \left( \frac{C_n^{+} C_n}{",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-stochastic.html:450,detect,detection,450,docs/4.4/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-stochastic.html,1,['detect'],['detection']
Safety,". . Stochastic Solver — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Homodyne detection. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶. Homodyne detection¶; Homodyne detection is an extension of the photocurrent method where the output; is mixed with a strong external source allowing to get information about the; phase of the system. With this method, the resulting detection rate depends is. \[ \begin{align}\begin{aligned}:label: jump_rate\\\tau = tr \left((\gamma^2 + \gamma (C+C^\dag) + C^\dag C)\rho \right)\end{aligned}\end{align} \]; With \(\gamma\), the strength of the external beam and \(C\) the collapse; operator. When the beam is very strong \((\gamma >> C^\dag C)\),; the rate becomes a constant term plus a term proportional to the quadrature of; the system. Closed system¶; In closed systems, the resulting stochastic differential equation is. (1)¶\[\delta \psi(t) = - i H \psi(t) \delta t; - \sum_n \",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-stochastic.html:454,detect,detection,454,docs/4.5/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-stochastic.html,1,['detect'],['detection']
Safety,". qutip.control.stats — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.stats. Source code for qutip.control.stats; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute : float; Total wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/stats.html:634,redund,redundant,634,docs/4.7/modules/qutip/control/stats.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/stats.html,2,['redund'],['redundant']
Safety,". qutip.tensor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.tensor. Source code for qutip.tensor; """"""; Module for the creation of composite quantum objects via the tensor product.; """""". __all__ = [; 'tensor', 'super_tensor', 'composite', 'tensor_swap', 'tensor_contract'; ]. import numpy as np; import scipy.sparse as sp; from qutip.cy.spmath import zcsr_kron; from qutip.qobj import Qobj; from qutip.permute import reshuffle; from qutip.superoperator import operator_to_vector; from qutip.dimensions import (; flatten, enumerate_flat, unflatten, deep_remove,; dims_to_tensor_shape, dims_idxs_to_tensor_idxs; ). import qutip.settings; import qutip.superop_reps # Avoid circular dependency here. [docs]def tensor(*args):; """"""Calculates the tensor product of input operators. Parameters; ----------; args : array_like; ``list`` or ``array`` of quantum objects for tensor product. Returns; -------; obj : qobj; A composite quantum object. Examples; --------; >>> tensor([sigmax(), sigmax()]) # doctest: +SKIP; Quantum object: dims = [[2, 2], [2, 2]], \; shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]; """""". if not args:; raise TypeError(""Requires at least one input argument""). if len(args) == 1 and isinstance(args[0], (list, np.ndarray)):; # this is the case when tensor is called on the form:; # tensor([q1, q2, q3, ...]); qlist = args[0]. elif len(args) == 1 and isinstance(args[0], Qobj):; # tensor is called with a single Qobj as an argument, do nothing; return args[0]. else:; # this is the case when tensor is called on the form:; # tensor(q1, q2, q3, ...); qlist = args. if not all([isinstance(q, Qobj) for q in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/tensor.html:908,Avoid,Avoid,908,docs/4.7/modules/qutip/tensor.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/tensor.html,1,['Avoid'],['Avoid']
Safety,".0 * e1[n] * e1[n]) * rho_t) * (dW[n, 0]*dW[n, 0] - dt); for n in range(A_len)], axis=0). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; drho_t += 0.5 * np.sum(; [(d2_vec2[n, m] - e1[m] * d2_vec[n] - e1[n] * d2_vec[m] +; (-e2[n, m] + 2.0 * e1[n] * e1[m]) * rho_t) * (dW[n, 0] * dW[m, 0]); for (n, m) in np.ndindex(A_len, A_len) if n != m], axis=0). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_single_fast(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; fast Milstein for homodyne detection with 1 stochastic operator; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with >2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]); sc_len = len(A); sc2_len = 2 * sc_len. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(d_vec[:-1].reshape(; -1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[sc2_len:-1] -= np.array(; [e[m] * d_vec[n] + e[n] * d_vec[m]; for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). e[sc_len:sc2_len] -= 2.0 * e[:sc_len] * e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:53016,detect,detection,53016,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,4,['detect'],['detection']
Safety,".scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/fidcomp.html:23776,avoid,avoids,23776,docs/4.5/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/fidcomp.html,1,['avoid'],['avoids']
Safety,".solver = 'taylor1.5-imp'; elif self.solver in ['taylor2.0', 'taylor20', 2.0, 202]:; self.solver_code = 202; self.solver = 'taylor2.0'; if not len(self.sc_ops) == 1 or \; not self.sc_ops[0].const or \; not self.method == ""homodyne"":; raise ValueError(""Taylor2.0 only works with 1 constant "" +; ""sc_ops and for homodyne method""); else:; raise ValueError((; ""The solver should be one of ""; ""[None, 'euler-maruyama', 'platen', 'pc-euler', ""; ""'pc-euler-imp', 'milstein', 'milstein-imp', ""; ""'rouchon', ""; ""'taylor1.5', 'taylor1.5-imp', 'explicit1.5' ""; ""'taylor2.0']"")). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/stochastic.html:18047,predict,predictor-corrector,18047,docs/4.5/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/stochastic.html,1,['predict'],['predictor-corrector']
Safety,"0]) * dW[a_idx, 0] +; 0.25 * (d2(A, psi_t_p)[0] - d2(A, psi_t_m)[0]) *; (dW[a_idx, 0] ** 2 - dt) / sqrt_dt; ). return dpsi_t. # -----------------------------------------------------------------------------; # Milstein rhs functions for the stochastic master equation; #; def _rhs_rho_milstein_homodyne_single(L, rho_t, t, A_ops, dt, dW, d1, d2,; args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection with single jump operator. """"""; A = A_ops[0]; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_t, 0). d2_vec = spmv(M, rho_t); d2_vec2 = spmv(M, d2_vec); e2 = cy_expect_rho_vec(M, d2_vec, 0). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += spmv(A[7], rho_t) * dt; drho_t += (d2_vec - e1 * rho_t) * dW[0, 0]; drho_t += 0.5 * (d2_vec2 - 2 * e1 * d2_vec + (-e2 + 2 * e1 * e1) *; rho_t) * (dW[0, 0] * dW[0, 0] - dt); return rho_t + drho_t. def _rhs_rho_milstein_homodyne(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection.; This implementation works for commuting stochastic jump operators.; TODO: optimizations: do calculation for n>m only. """"""; A_len = len(A_ops). M = np.array([A_ops[n][0] + A_ops[n][3] for n in range(A_len)]); e1 = np.array([cy_expect_rho_vec(M[n], rho_t, 0) for n in range(A_len)]). d1_vec = np.sum([spmv(A_ops[n][7], rho_t); for n in range(A_len)], axis=0). d2_vec = np.array([spmv(M[n], rho_t); for n in range(A_len)]). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; d2_vec2 = np.array([[spmv(M[n], d2_vec[m]); for m in range(A_len)] for n in range(A_len)]); e2 = np.array([[cy_expect_rho_vec(M[n], d2_vec[m], 0); for m in range(A_len)] for n in range(A_len)]). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += d1_vec * dt; drho_t += np.sum([(d2_vec[n] - e1[n] * rho_t) * dW[n, 0]; for n in range(A_len)], axis=0); drho_t += 0.5 * np.sum(; [(d2_vec2[n, n] - 2.0 * e1[n] * d2_vec[n] +; (-e2[n, n] + 2.0 * ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:51000,detect,detection,51000,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,5,['detect'],['detection']
Safety,"0]):; self.coeff_get = InterCoeffCte(self.ops, None,; self.tlist); else:; self.coeff_get = InterCoeffT(self.ops, None, self.tlist); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get); elif self.type == ""spline"":; self.coeff_get = InterpolateCoeff(self.ops, None, None); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get); else:; pass; coeff_files.clean(); if code:; return Code. def _get_coeff(self, t):; out = []; for part in self.ops:; out.append(part.get_coeff(t, self.args)); return out. def __getstate__(self):; _dict_ = {key: self.__dict__[key]; for key in self.__dict__ if key is not ""compiled_qobjevo""}; if self.compiled:; return (_dict_, self.compiled_qobjevo.__getstate__()); else:; return (_dict_,). def __setstate__(self, state):; self.__dict__ = state[0]; self.compiled_qobjevo = None; if self.compiled:; mat_type, threading, td = self.compiled.split(); if mat_type == ""csr"":; if safePickle:; # __getstate__ and __setstate__ of compiled_qobjevo pass pointers; # In 'safe' mod, these pointers are not used.; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte(); self.compiled_qobjevo.set_data(self.cte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp(); self.compiled_qobjevo.set_data(self.cte); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd(); self.compiled_qobjevo.set_data(self.cte, self.ops); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp(); self.compiled_qobjevo.set_data(self.cte, self.ops); self.compiled_qobjevo.set_threads(self.omp). if td == ""pyfunc"":; self.compiled_qobjevo.set_factor(obj=self.coeff_get); elif td == ""cyfactor"":; self.compiled_qobjevo.set_factor(func=self.coeff_get); else:; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte.__new__(CQobjCte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteO",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html:39446,safe,safePickle,39446,docs/4.4/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html,2,['safe'],"['safe', 'safePickle']"
Safety,"1.5'``, ``'explicit15'`` or ``'platen15'``. taylor2.0; Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]_. - Order strong 2.0; - Code: ``'taylor2.0'``, ``'taylor20'`` or ``2.0``. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; :func:`~general_stochastic` only accepts the derivative-free; solvers: ``'euler'``, ``'platen'`` and ``'explicit1.5'``. Available solvers for :obj:`~photocurrent_sesolve` and \; :obj:`~photocurrent_mesolve`; Photocurrent use ordinary differential equations between; stochastic ""jump/collapse"". euler; Euler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]_. - Order 1.0; - Code: ``'euler'``. predictor–corrector; predictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. - Order 2.0; - Code: ``'pred-corr'``. References; ----------; .. [1] Peter E. Kloeden and Exkhard Platen, *Numerical Solution of; Stochastic Differential Equations*.; .. [2] H.-P. Breuer and F. Petruccione, *The Theory of Open Quantum; Systems*.; .. [3] Pierre Rouchon and Jason F. Ralpha, *Efficient Quantum Filtering for; Quantum Feedback Control*, `arXiv:1410.5345 [quant-ph]; <https://arxiv.org/abs/1410.5345>`_, Phys. Rev. A 91, 012118,; (2015).; .. [4] Howard M. Wiseman, Gerard J. Milburn, *Quantum measurement and; control*.; """""". [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc. The stochastic solvers :func:`qutip.stochastic.general_stochastic`,; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`,; :func:`qutip.stochastic.photoc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:7011,predict,predictor,7011,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,8,['predict'],['predictor']
Safety,"2 * np.pi * sm.dag() * sm + 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a). In [6]: data = ssesolve(H, psi0, times, sc_ops=[np.sqrt(0.1) * a], e_ops=[a.dag() * a, sm.dag() * sm], method=""homodyne""); Total run time: 0.01s. In [7]: figure(); Out[7]: <Figure size 640x480 with 0 Axes>. In [8]: plot(times, data.expect[0], times, data.expect[1]); Out[8]: ; [<matplotlib.lines.Line2D at 0x1a25a75c18>,; <matplotlib.lines.Line2D at 0x1a25a755c0>]. In [9]: title('Homodyne time evolution'); Out[9]: Text(0.5,1,'Homodyne time evolution'). In [10]: xlabel('Time'); Out[10]: Text(0.5,0,'Time'). In [11]: ylabel('Expectation values'); Out[11]: Text(0,0.5,'Expectation values'). In [12]: legend((""cavity photon number"", ""atom excitation probability"")); Out[12]: <matplotlib.legend.Legend at 0x1a263e9860>. In [13]: show(). Open system¶; In open systems, 2 types of collapse operators are considered, \(S_i\); represent the dissipation in the environment, \(C_i\) are monitored operators.; The deterministic part of the evolution is the liouvillian with both types of; collapses. (2)¶\[L(\rho(t)) = - i[H(t),\rho(t)]; + \sum_n D(S_n, \rho); + \sum_i D(C_i, \rho),\]; with. (3)¶\[D(C, \rho) = \frac{1}{2} \left[2 C \rho(t) C^{+}; - \rho(t) C^{+} C - C^{+} C \rho(t) \right].\]; The stochastic part is given by. (4)¶\[d_2 = \left(C \rho(t) + \rho(t) C^{+} - \rm{tr}\left(C \times \rho; + \rho \times C^{+} \right)\rho(t) \right),\]; resulting in the stochastic differential equation. (5)¶\[\delta \rho(t) = L(\rho(t)) \delta t + d_2 \delta \omega\]; The function smesolve covert these cases in QuTiP. Heterodyne detection¶; With heterodyne detection, two measurements are made in order to obtain; information about 2 orthogonal quadratures at once. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-stochastic.html:4208,detect,detection,4208,docs/4.5/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-stochastic.html,2,['detect'],['detection']
Safety,"29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manual",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/installation.html:2692,detect,detect,2692,docs/4.6/installation.html,https://qutip.org,https://qutip.org/docs/4.6/installation.html,2,['detect'],['detect']
Safety,"2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with >2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]); sc_len = len(A); sc2_len = 2 * sc_len. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(d_vec[:-1].reshape(; -1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[sc2_len:-1] -= np.array(; [e[m] * d_vec[n] + e[n] * d_vec[m]; for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). e[sc_len:sc2_len] -= 2.0 * e[:sc_len] * e[:sc_len]; e[sc2_len:] -= 2.0 * np.array(; [e[n] * e[m] for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). drho_t = - np.inner(e, dW) * rho_t; dW[:sc_len] -= 2.0 * e[:sc_len] * dW[sc_len:sc2_len]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_taylor_15_one(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; strong order 1.5 Tylor scheme for homodyne detection with 1 stochastic operator; """""". dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = a * dt; drho_t += b * dW[0]; drho_t += Lb * dW[1] # Milstein term. # new terms: ; drho_t += A[-1] * b * dW[2]; drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]; drho_t += A[-1] * a * (0.5 * dt*dt); drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4] ; ; return rho_t + drho_t. #include _rhs_rho_Taylor_15_two#. def _rhs_rho_milstein_implicit(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; Drift implicit Milstein (theta = 1/2, eta = 0); Wang, X., Gan, S., & Wang, D. (2012). ; A family of fully implicit Milstein methods for stiff stochastic differential ; equations with multiplicative noise. ; BIT Numerical Mathema",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:54379,detect,detection,54379,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,3,['detect'],['detection']
Safety,"2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with >2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]); sc_len = len(A); sc2_len = 2 * sc_len. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(d_vec[:-1].reshape(; -1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[sc2_len:-1] -= np.array(; [e[m] * d_vec[n] + e[n] * d_vec[m]; for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). e[sc_len:sc2_len] -= 2.0 * e[:sc_len] * e[:sc_len]; e[sc2_len:] -= 2.0 * np.array(; [e[n] * e[m] for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). drho_t = - np.inner(e, dW) * rho_t; dW[:sc_len] -= 2.0 * e[:sc_len] * dW[sc_len:sc2_len]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_taylor_15_one(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; strong order 1.5 Tylor scheme for homodyne detection with 1 stochastic operator; """""". dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = a * dt; drho_t += b * dW[0]; drho_t += Lb * dW[1] # Milstein term. # new terms:; drho_t += A[-1] * b * dW[2]; drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]; drho_t += A[-1] * a * (0.5 * dt*dt); drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]. return rho_t + drho_t. #include _rhs_rho_Taylor_15_two#. def _rhs_rho_milstein_implicit(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; Drift implicit Milstein (theta = 1/2, eta = 0); Wang, X., Gan, S., & Wang, D. (2012).; A family of fully implicit Milstein methods for stiff stochastic differential; equations with multiplicative noise.; BIT Numerical Mathematics, 5",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/stochastic.html:54347,detect,detection,54347,docs/4.3/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/stochastic.html,1,['detect'],['detection']
Safety,": list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns; -------; rho : Qobj; A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution.; """"""; if dims is not None:; # TODO: check!; pass; else:; dims = [[[N], [N]], [[N], [N]]]. if rank is None:; rank = N**2; if rank > N**2:; raise ValueError(""Rank cannot exceed superoperator dimension.""). # We use mainly dense matrices here for speed in low; # dimensions. In the future, it would likely be better to switch off; # between sparse and dense matrices as the dimension grows. # We start with a Ginibre uniform matrix X of the appropriate rank,; # and use it to construct a positive semidefinite matrix X X⁺.; X = randnz((N**2, rank), norm='ginibre', seed=seed). # Precompute X X⁺, as we'll need it in two different places.; XXdag = np.dot(X, X.T.conj()). if enforce_tp:; # We do the partial trace over the first index by using dense reshape; # operations, so that we can avoid bouncing to a sparse representation; # and back.; Y = np.einsum('ijik->jk', XXdag.reshape((N, N, N, N))). # Now we have the matrix 𝟙 ⊗ Y^{-1/2}, which we can find by doing; # the square root and the inverse separately. As a possible; # improvement, iterative methods exist to find inverse square root; # matrices directly, as this is important in statistics.; Z = np.kron(; np.eye(N),; la.sqrtm(la.inv(Y)); ). # Finally, we dot everything together and pack it into a Qobj,; # marking the dimensions as that of a type=super (that is,; # with left and right compound indices, each representing; # left and right indices on the underlying Hilbert space).; D = Qobj(np.dot(Z, np.dot(XXdag, Z))); else:; D = N * Qobj(XXdag / np.trace(XXdag)). D.dims = [; # Left dims; [[N], [N]],; # Right dims; [[N], [N]]; ]. # Since [BCSZ08] gives a row-stacking Choi matrix, but QuTiP; # expects a column-stacking Choi matrix, we must permute the indices.; D = D.permute([[1], [0]])",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/random_objects.html:17754,avoid,avoid,17754,docs/4.6/modules/qutip/random_objects.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/random_objects.html,4,['avoid'],['avoid']
Safety,":Solver with more terms of the Stratonovich expansion.; -Order strong 2.0; -Code: ‘taylor2.0’, ‘taylor20’, 2.0; Numerical Solution of Stochastic Differential Equations; Chapter 10.5 Eq. (5.2), By Peter E. Kloeden, Eckhard Platen. —All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only work for 1 stochastic; operator not dependent of time with the homodyne method.; The qutip.stochastic.general_stochastic only accept derivatives; free solvers: [‘euler’, ‘platen’, ‘explicit1.5’]. Available solver for photocurrent_sesolve and photocurrent_mesolve:; Photocurrent use ordinary differential equations between; stochastic “jump/collapse”. euler:Euler method for ordinary differential equations between jumps.; Only 1 jumps per time interval.; Default solver; -Order 1.0; -Code: ‘euler’; Quantum measurement and control; Chapter 4, Eq 4.19, 4.40, By Howard M. Wiseman, Gerard J. Milburn. predictor–corrector:predictor–corrector method (PECE) for ordinary differential equations.; Use poisson distribution to obtain the number of jump at each timestep.; -Order 2.0; -Code: ‘pred-corr’. general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[], _safe_mode=True, len_d2=1, args={}, **kwargs)[source]¶; Solve stochastic general equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. state0qutip.QobjInitial state vector (ket) or density matrix as a vector. timeslist / arrayList of times for \(t\). Must be uniformly spaced. d1function, callable classFunction representing the deterministic evolution of the system. def d1(time (double), state (as a np.array vector)):return 1d np.array. d2function, callable classFunction representing the stochastic evolution of the system. def d2(time (double), state (as a np.array vector)):return 2d np.array (N_sc_ops, len(state0)). len_d2intNumber of output vector produced by d2. e_opslist of qutip.Qobjsingle operator or list of operators ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:98269,predict,predictor,98269,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,2,['predict'],['predictor']
Safety,"; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-settings.html:2756,detect,detect,2756,docs/4.0.2/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-settings.html,1,['detect'],['detect']
Safety,"; if noise.shape[1] < len(times):; raise ValueError(msg + ""shape[1] >= len(times)""); if noise.shape[2] < nsubsteps:; raise ValueError(msg + ""shape[2] >= nsubsteps""); if noise.shape[3] < len(self.sc_ops) * dw_len:; raise ValueError(msg + ""shape[3] >= len(self.sc_ops)"" +; dw_len_str); self.noise_type = 1; self.noise = noise. else:; self.noise = np.random.randint(0, 2**32, ntraj, dtype=np.uint32); self.noise_type = 0. # Map; self.progress_bar = progress_bar; if self.ntraj > 1 and map_func:; self.map_func = map_func; else:; self.map_func = serial_map; self.map_kwargs = map_kwargs if map_kwargs is not None else {}. # Other; self.options = options; self.args = args; self.set_solver(); self.p = noiseDepth. def set_solver(self):; if self.solver in ['euler-maruyama', 'euler', 50, 0.5]:; self.solver_code = 50; self.solver = 'euler-maruyama'; elif self.solver in ['platen', 'platen1', 'explicit1', 100]:; self.solver_code = 100; self.solver = 'platen'; elif self.solver in ['pred-corr', 'predictor-corrector',; 'pc-euler', 101]:; self.solver_code = 101; self.solver = 'pred-corr'; elif self.solver in ['milstein', 102, 1.0]:; self.solver_code = 102; self.solver = 'milstein'; elif self.solver in ['milstein-imp', 103]:; self.solver_code = 103; self.solver = 'milstein-imp'; elif self.solver in ['pred-corr-2', 'pc-euler-2', 'pc-euler-imp', 104]:; self.solver_code = 104; self.solver = 'pred-corr-2'; elif self.solver in ['Rouchon', 'rouchon', 120]:; self.solver_code = 120; self.solver = 'rouchon'; if not all((op.const for op in self.sc_ops)):; raise ValueError(""Rouchon only works with constant sc_ops""); elif self.solver in ['platen15', 'explicit1.5', 'explicit15', 150]:; self.solver_code = 150; self.solver = 'explicit1.5'; elif self.solver in ['taylor15', 'taylor1.5', None, 1.5, 152]:; self.solver_code = 152; self.solver = 'taylor1.5'; elif self.solver in ['taylor15-imp', 'taylor1.5-imp', 153]:; self.solver_code = 153; self.solver = 'taylor1.5-imp'; elif self.solver in ['taylor2.0', 'tayl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:16447,predict,predictor-corrector,16447,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,4,['predict'],['predictor-corrector']
Safety,"; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of ; ``task(value, *task_args, **task_kwargs)`` for ; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/parallel.html:8065,timeout,timeout,8065,docs/4.5/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/parallel.html,1,['timeout'],['timeout']
Safety,"; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:23729,avoid,avoids,23729,docs/4.6/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html,2,['avoid'],['avoids']
Safety,"AW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/copyright-1.html:2146,avoid,avoidance,2146,docs/4.7/copyright-1.html,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html,2,['avoid'],['avoidance']
Safety,Decomposition of the Toffoli gate in terms of CNOT and single-qubit rotations; Imports and Exports QASM circuit; QuTiP example: Quantum Gates and their usage; Quantum Teleportation Circuit. Pulse-level circuit simulation. Compiling and simulating a 10-qubit Quantum Fourier Transform (QFT) algorithm; Custimize the pulse-level simulation; Examples for OptPulseProcessor; Scheduler for quantum gates and instructions; Simulating randomized benchmarking; Simulating the Deutsch–Jozsa algorithm at the pulse level; measuring the relaxation time with the idling gate. Time evolution. QobjEvo: time-dependent quantum objects; Schrödinger Equation Solver: Larmor precession; Master Equation Solver: Single-Qubit Dynamics; Master Equation Solver: Vacuum Rabi oscillations; Master Equation Solver: Dynamics of a Spin Chain; Monte Carlo Solver: Birth and Death of Photons in a Cavity; Bloch-Redfield Solver: Two Level System; Bloch-Redfield Solver: Time dependent operators; Bloch-Redfield Solver: Dissipative Atom-Cavity system; Bloch-Redfield Solver: Phonon-assisted initialization; Floquet Solvers; Floquet Formalism; Time-dependent Master Equation: Landau-Zener transitions; Time-dependent Master Equation: Landau-Zener-Stuckelberg inteferometry; Stochastic Solver: Heterodyne Detection; Stochastic Solver: Mixing stochastic and deterministic equations; Stochastic Solver: Photo-current detection in a JC model; Stochastic vs. Monte-Carlo Solver: Cat states become coherent; Steady-State: Optomechanical System in the Single-Photon Strong-Coupling Regime; Steady-State: Homodyned Jaynes-Cummings emission; Steady-State: Time-dependent (periodic) quantum system. Optimal control. Overview ; Hadamard ; QFT ; Lindbladian ; Symplectic ; QFT (CRAB) ; State to state (CRAB) ; CNOT ; iSWAP ; Single-qubit rotation ; Toffoli gate . Tomography. Density matrix estimation with iterative maximum likelihood estimation . Permutational invariant Lindblad dynamics. Overview ; Superradiant light emission ; Steady stat,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/qutip-tutorials/index-v4.html:3310,detect,detection,3310,qutip-tutorials/index-v4.html,https://qutip.org,https://qutip.org/qutip-tutorials/index-v4.html,1,['detect'],['detection']
Safety,"F SUCH DAMAGE.; ###############################################################################; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline; from functools import partial, wraps; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import _compile_str_single, _compiled_coeffs; from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi, spmv, cy_spmm_tr); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff); import pickle; import sys; import scipy; import os. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = False; if sys.platform == 'win32':; safePickle = True. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf+0j. str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """"""; def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_ + "".pyx""]. def clean(self):; for i, file_ in enumerate(self.files):; try:; os.remove(file_); except:; pass; if not os.path.isfile(file_):; # Don't exist anymore; del self.files[i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html:2938,safe,safePickle,2938,docs/4.4/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list. with Python functions as time-dependence. Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under W",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/changelog.html:2625,safe,safety,2625,docs/4.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.2/changelog.html,4,['safe'],['safety']
Safety,"OCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; Module for the creation of composite quantum objects via the tensor product.; """""". __all__ = [; 'tensor', 'super_tensor', 'composite', 'tensor_swap', 'tensor_contract'; ]. import numpy as np; import scipy.sparse as sp; from qutip.cy.spmath import zcsr_kron; from qutip.qobj import Qobj; from qutip.permute import reshuffle; from qutip.superoperator import operator_to_vector; from qutip.dimensions import (; flatten, enumerate_flat, unflatten, deep_remove,; dims_to_tensor_shape, dims_idxs_to_tensor_idxs; ). import qutip.settings; import qutip.superop_reps # Avoid circular dependency here. [docs]def tensor(*args):; """"""Calculates the tensor product of input operators. Parameters; ----------; args : array_like; ``list`` or ``array`` of quantum objects for tensor product. Returns; -------; obj : qobj; A composite quantum object. Examples; --------; >>> tensor([sigmax(), sigmax()]) # doctest: +SKIP; Quantum object: dims = [[2, 2], [2, 2]], \; shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]; """""". if not args:; raise TypeError(""Requires at least one input argument""). if len(args) == 1 and isinstance(args[0], (list, np.ndarray)):; # this is the case when tensor is called on the form:; # tensor([q1, q2, q3, ...]); qlist = args[0]. elif len(args) == 1 and isinstance(args[0], Qobj):; # tensor is called with a single Qobj as an argument, do nothing; return args[0]. else:; # this is the case when tensor is called on the for",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/tensor.html:2643,Avoid,Avoid,2643,docs/4.6/modules/qutip/tensor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/tensor.html,1,['Avoid'],['Avoid']
Safety,"Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline, interp1d; from functools import partial, wraps; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import (_compile_str_single, _compiled_coeffs,; _compiled_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv, cy_spmm_tr); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import pickle; import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. try:; import cython; use_cython = [True]; except:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """"""; def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_ + "".pyx""]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; try:; os.remove(file_); to_del.append(i);",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:3088,safe,safePickle,3088,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`.; """""". if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if ""solver"" not in kwargs:; kwargs[""solver""] = 50. sso = StochasticSolverOptions(False, H=None, state0=state0, times=times,; e_ops=e_ops, args=args, **kwargs); if sso.solver_code not in [50, 100, 150]:; raise ValueError(""Only Euler, platen, platen15 can be "" +; ""used for the general stochastic solver.""). sso.d1 = d1; sso.d2 = d2; if _safe_mode:; # This state0_vec is computed as mat2vec(state0.full()).ravel(); # in the sso init.; state0_vec = sso.rho0; l_vec = state0_vec.shape[0]; try:; out_d1 = d1(0., sso.rho0); except Exception as e:; raise RuntimeError(""Safety check: d1(0., state0_vec) failed.:\n"" +; str(e)) from e; try:; out_d2 = d2(0., sso.rho0); except Exception as e:; raise RuntimeError(""Safety check: d2(0., state0_vec) failed:\n"" +; str(e)) from e. msg_d1 = (""d1 must return an 1d numpy array with the same number ""; ""of elements as the initial state as a vector.""); if not isinstance(out_d1, np.ndarray):; raise TypeError(msg_d1); if (out_d1.ndim != 1; or out_d1.shape[0] != l_vec or len(out_d1.shape) != 1):; raise ValueError(msg_d1). msg_d2 = (""Safety check: d2 must return a 2d numpy array ""; ""with the shape (len_d2, len(state0_vec) ).""); if not isinstance(out_d2, np.ndarray):; raise TypeError(msg_d2); if (out_d2.ndim != 2; or out_d2.shape[1] != l_vec or out_d2.shape[0] != len_d2):; raise ValueError(msg_d2); if out_d1.dtype != np.dtype('complex128') or \; out_d2.dtype != np.dtype('complex128'):; raise ValueError(""Safety check: d1 and d2 must return "" +; ""complex numpy array.""); msg_e_ops = (""Safety check: The shape of the e_ops ""; ""does not fit the initial state.""); for op in sso.e_ops:; shape_op = op.shape; if sso.me:; if shape_op[0]**2 != l_vec or shape",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/stochastic.html:34419,Safe,Safety,34419,docs/4.7/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html,1,['Safe'],['Safety']
Safety,"Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`.; """""". if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if ""solver"" not in kwargs:; kwargs[""solver""] = 50. sso = StochasticSolverOptions(False, H=None, state0=state0, times=times,; e_ops=e_ops, args=args, **kwargs); if sso.solver_code not in [50, 100, 150]:; raise ValueError(""Only Euler, platen, platen15 can be "" +; ""used for the general stochastic solver.""). sso.d1 = d1; sso.d2 = d2; if _safe_mode:; # This state0_vec is computed as mat2vec(state0.full()).ravel(); # in the sso init.; state0_vec = sso.rho0; l_vec = state0_vec.shape[0]; try:; out_d1 = d1(0., sso.rho0); except Exception as e:; raise RuntimeError(""Safety check: d1(0., state0_vec) failed.:\n"" +; str(e)) from e; try:; out_d2 = d2(0., sso.rho0); except Exception as e:; raise RuntimeError(""Safety check: d2(0., state0_vec) failed:\n"" +; str(e)) from e. msg_d1 = (""d1 must return an 1d numpy array with the same number ""; ""of elements as the initial state as a vector.""); if not isinstance(out_d1, np.ndarray):; raise TypeError(msg_d1); if (out_d1.ndim != 1; or out_d1.shape[0] != l_vec or len(out_d1.shape) != 1):; raise ValueError(msg_d1). msg_d2 = (""Safety check: d2 must return a 2d numpy array ""; ""with the shape (len_d2, len(state0_vec) ).""); if not isinstance(out_d2, np.ndarray):; raise TypeError(msg_d2); if (out_d2.ndim != 2; or out_d2.shape[1] != l_vec or out_d2.shape[0] != len_d2):; raise ValueError(msg_d2); if out_d1.dtype != np.dtype('complex128') or \; out_d2.dtype != np.dtype('complex128'):; raise ValueError(""Safety check: d1 and d2 must return "" +; ""complex numpy array.""); msg_e_ops = (""Safety check: The shape of the e_ops ""; ""does not fit the intial state.""); for op in sso.e_ops:; shape_op = op.shape; if sso.me:; if shape_op[0]**2 != l_vec or shape_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:35920,Safe,Safety,35920,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,1,['Safe'],['Safety']
Safety,"Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : :class:`qutip.Qobj`; Qobj one; B : :class:`qutip.Qobj`; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:58032,avoid,avoid,58032,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,1,['avoid'],['avoid']
Safety,"R BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['liouvillian', 'liouvillian_ref', 'lindblad_dissipator',; 'operator_to_vector', 'vector_to_operator', 'mat2vec', 'vec2mat',; 'vec2mat_index', 'mat2vec_index', 'spost', 'spre', 'sprepost']. import scipy.sparse as sp; import numpy as np; from qutip.qobj import Qobj; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.sparse import sp_reshape; from qutip.cy.spmath import zcsr_kron. [docs]def liouvillian(H, c_ops=[], data_only=False, chi=None):; """"""Assembles the Liouvillian superoperator from a Hamiltonian; and a ``list`` of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : array_like; A ``list`` or ``array`` of collapse operators. Returns; -------; L : qobj; Liouvillian superoperator. """""". if chi and len(chi) != len(c_ops):; raise ValueError('chi must be a list with same length as c_ops'). if H is not None:; if H.isoper:; op_dims = H.dims; op_shape = H.shape; elif H.issuper:; op_dims = H.dims[0]; op_shape = [np.prod(op_dims[0]), np.prod(op_dims[0])]; else:; raise TypeError(""Invalid type for Hamiltonian.""); else:; # no hamiltonian given, pick system size from a collapse operator; if isinstance(c_ops, list) and len(c_ops) > 0:; c = c_ops[0]; if c.isoper:; op_dims = c.dims; op_shape = c.shape; elif c.issuper:; op_dims = c.dims[0]; op_shape = [np.prod(op_dims[0]), np.prod(op_dims[0])]; else:; raise TypeError(""Invalid type for collapse operator.""); else:; raise TypeError(""Either H or c_ops must be given.""). sop_dims = [[op_d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/superoperator.html:2713,avoid,avoids,2713,docs/4.1/modules/qutip/superoperator.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/superoperator.html,4,['avoid'],['avoids']
Safety,"R CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['liouvillian', 'liouvillian_ref', 'lindblad_dissipator',; 'operator_to_vector', 'vector_to_operator', 'mat2vec', 'vec2mat',; 'vec2mat_index', 'mat2vec_index', 'spost', 'spre', 'sprepost']. import scipy.sparse as sp; import numpy as np; from qutip.qobj import Qobj; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.sparse import sp_reshape; from qutip.cy.spmath import zcsr_kron; from functools import partial. [docs]def liouvillian(H, c_ops=[], data_only=False, chi=None):; """"""Assembles the Liouvillian superoperator from a Hamiltonian; and a ``list`` of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters; ----------; H : Qobj or QobjEvo; System Hamiltonian. c_ops : array_like of Qobj or QobjEvo; A ``list`` or ``array`` of collapse operators. Returns; -------; L : Qobj or QobjEvo; Liouvillian superoperator. """"""; if isinstance(c_ops, (Qobj, QobjEvo)):; c_ops = [c_ops]; if chi and len(chi) != len(c_ops):; raise ValueError('chi must be a list with same length as c_ops'). h = None; if H is not None:; if isinstance(H, QobjEvo):; h = H.cte; else:; h = H; if h.isoper:; op_dims = h.dims; op_shape = h.shape; elif h.issuper:; op_dims = h.dims[0]; op_shape = [np.prod(op_dims[0]), np.prod(op_dims[0])]; else:; raise TypeError(""Invalid type for Hamiltonian.""); else:; # no hamiltonian given, pick system size from a collapse operator; if isinstance(c_ops, list) and len(c_ops) > 0:; if isinstance(c_ops[0], QobjEvo):; c = c_ops[0].cte; else:; c = c_ops[0]; if c.isoper:; op_dims = c.dims; op_shape = c.shape; elif c.issup",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/superoperator.html:2740,avoid,avoids,2740,docs/4.4/modules/qutip/superoperator.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/superoperator.html,4,['avoid'],['avoids']
Safety,"RACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; #; # This module was initially contributed by Ben Criger.; #; """"""; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms.; """""". __all__ = ['super_to_choi', 'choi_to_super', 'choi_to_kraus', 'kraus_to_choi',; 'kraus_to_super', 'choi_to_chi', 'chi_to_choi', 'to_choi',; 'to_chi', 'to_super', 'to_kraus', 'to_stinespring'; ]. # Python Standard Library; from itertools import starmap, product. # NumPy/SciPy; from numpy.core.multiarray import array, zeros; from numpy.core.shape_base import hstack; from numpy.matrixlib.defmatrix import matrix; from numpy import sqrt, floor, log2; from numpy import dot; from scipy.linalg import eig, svd; # Needed to avoid conflict with itertools.product.; import numpy as np. # Other QuTiP functions and classes; from qutip.superoperator import vec2mat, operator_to_vector, sprepost; from qutip.operators import identity, sigmax, sigmay, sigmaz; from qutip.tensor import tensor, flatten; from qutip.qobj import Qobj; from qutip.states import basis. # SPECIFIC SUPEROPERATORS -----------------------------------------------------. def _dep_super(pe):; """"""; Returns the superoperator corresponding to qubit depolarization for a; given parameter pe. TODO: if this is going into production (hopefully it isn't) then check; CPTP, expand to arbitrary dimensional systems, etc.; """"""; return Qobj(dims=[[[2], [2]], [[2], [2]]],; inpt=array([[1. - pe / 2., 0., 0., pe / 2.],; [0., 1. - pe, 0., 0.],; [0., 0., 1. - pe, 0.],; [pe / 2., 0., 0., 1. - pe / 2.]])). def _dep_choi(pe):; """"""; Returns the choi matrix corresponding to qubit depolarization for a; given parameter pe. TODO: if this is going into production (hopefull",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/superop_reps.html:2845,avoid,avoid,2845,docs/4.5/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/superop_reps.html,3,['avoid'],['avoid']
Safety,"RACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; #; # This module was initially contributed by Ben Criger.; #; """"""; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms.; """""". __all__ = ['super_to_choi', 'choi_to_super', 'choi_to_kraus', 'kraus_to_choi',; 'kraus_to_super', 'choi_to_chi', 'chi_to_choi', 'to_choi',; 'to_chi', 'to_super', 'to_kraus', 'to_stinespring'; ]. # Python Standard Library; from itertools import starmap, product. # NumPy/SciPy; from numpy.core.multiarray import array, zeros; from numpy.core.shape_base import hstack; from numpy.matrixlib.defmatrix import matrix; from numpy import sqrt, floor, log2; from numpy import dot; from scipy.linalg import eig, svd; # Needed to avoid conflict with itertools.product.; import numpy as np. # Other QuTiP functions and classes; from qutip.superoperator import vec2mat, spre, spost, operator_to_vector; from qutip.operators import identity, sigmax, sigmay, sigmaz; from qutip.tensor import tensor, flatten; from qutip.qobj import Qobj; from qutip.states import basis. # SPECIFIC SUPEROPERATORS -----------------------------------------------------. def _dep_super(pe):; """"""; Returns the superoperator corresponding to qubit depolarization for a; given parameter pe. TODO: if this is going into production (hopefully it isn't) then check; CPTP, expand to arbitrary dimensional systems, etc.; """"""; return Qobj(dims=[[[2], [2]], [[2], [2]]],; inpt=array([[1. - pe / 2., 0., 0., pe / 2.],; [0., 1. - pe, 0., 0.],; [0., 0., 1. - pe, 0.],; [pe / 2., 0., 0., 1. - pe / 2.]])). def _dep_choi(pe):; """"""; Returns the choi matrix corresponding to qubit depolarization for a; given parameter pe. TODO: if this is going into production (hopef",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/superop_reps.html:2836,avoid,avoid,2836,docs/4.1/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/superop_reps.html,5,['avoid'],['avoid']
Safety,"Rep. 6, 8 (2016). 240. Guo et al., ""Giant acoustic atom: A single quantum system with a deterministic time delay"", ; Phys. Rev. A 95, 053821 (2017). 239. Vermersch et al., ""Quantum State Transfer via Noisy Photonic and Phononic Waveguides"", ; Phys. Rev. Lett. 118, 133601 (2017). 238. Gudmundsson et al., ""Time-dependent current into and through multilevel parallel quantum dots in a photon cavity"", ; Phys. Rev. B 95, 195307 (2017). 237. Braumüller et al., ""Analog quantum simulation of the Rabi model in the ultra-strong coupling regime"", ; Nat. Commun. 8, 779 (2017). 236. Lagoudakis et al., ""Ultrafast coherent manipulation of trions in site-controlled nanowire quantum dots"", ; Optica 3, 1430 (2016). 235. Roghani et al., ""Dissipative Preparation of Entangled Many-Body States with Rydberg Atoms"", ; arXiv:1611.09612. 234. Lambert et al., ""Superradiance with an ensemble of superconducting flux qubits"", ; Phys. Rev. B 94, 224510 (2016). 233. Yanay et al., ""Shelving-style QND phonon-number detection in quantum optomechanics"", ; New J. Phys. 19, 033014 (2017). 232. Kirton et al., ""Suppressing and Restoring the Dicke Superradiance Transition by Dephasing and Decay"", ; Phys. Rev. Lett. 118, 123602 (2017). 231. Fischer et al., ""On-Chip Architecture for Self-Homodyned Nonclassical Light"", ; Phys. Rev. Applied 7, 044002 (2017).; Notebook. 230. Combes et al., ""The SLH framework for modeling quantum input-output networks"", ; Advances in Physics: X 2, 784 (2017). 229. Lucarelli, ""Quantum optimal control via gradient ascent in function space and the time-bandwidth quantum speed limit"", ; arXiv:1611.00188. 228. Bulutay, ""Cat-state generation and stabilization for a nuclear spin through electric quadrupole interaction"", ; Phys. Rev. A 96, 012312 (2017). 227. De Roeck et al., ""Step Density Profiles in Localized Chains"", ; J. Stat. Phys. 167, 1143 (2017). 226. Granade et al., ""QInfer: Statistical inference software for quantum applications"", ; Quantum 1, 5 (2017). 225. Cotrufo et al., ""Coh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:18199,detect,detection,18199,users.html,https://qutip.org,https://qutip.org/users.html,1,['detect'],['detection']
Safety,"RuntimeError(""Safety check: d1(0., state0_vec) failed.:\n"" +; str(e)) from e; try:; out_d2 = d2(0., sso.rho0); except Exception as e:; raise RuntimeError(""Safety check: d2(0., state0_vec) failed:\n"" +; str(e)) from e. msg_d1 = (""d1 must return an 1d numpy array with the same number ""; ""of elements as the initial state as a vector.""); if not isinstance(out_d1, np.ndarray):; raise TypeError(msg_d1); if (out_d1.ndim != 1; or out_d1.shape[0] != l_vec or len(out_d1.shape) != 1):; raise ValueError(msg_d1). msg_d2 = (""Safety check: d2 must return a 2d numpy array ""; ""with the shape (len_d2, len(state0_vec) ).""); if not isinstance(out_d2, np.ndarray):; raise TypeError(msg_d2); if (out_d2.ndim != 2; or out_d2.shape[1] != l_vec or out_d2.shape[0] != len_d2):; raise ValueError(msg_d2); if out_d1.dtype != np.dtype('complex128') or \; out_d2.dtype != np.dtype('complex128'):; raise ValueError(""Safety check: d1 and d2 must return "" +; ""complex numpy array.""); msg_e_ops = (""Safety check: The shape of the e_ops ""; ""does not fit the initial state.""); for op in sso.e_ops:; shape_op = op.shape; if sso.me:; if shape_op[0]**2 != l_vec or shape_op[1]**2 != l_vec:; raise ValueError(msg_e_ops); else:; if shape_op[0] != l_vec or shape_op[1] != l_vec:; raise ValueError(msg_e_ops +; "" Expecting e_ops as superoperators.""). sso.m_ops = []; sso.cm_ops = []; if sso.store_measurement:; if not m_ops:; raise ValueError(""General stochastic needs explicit "" +; ""m_ops to store measurement.""); sso.m_ops = m_ops; sso.cm_ops = [QobjEvo(op) for op in sso.m_ops]; [op.compile() for op in sso.cm_ops]; if sso.dW_factors is None:; sso.dW_factors = [1.] * len(sso.m_ops); elif len(sso.dW_factors) == 1:; sso.dW_factors = sso.dW_factors * len(sso.m_ops); elif len(sso.dW_factors) != len(sso.m_ops):; raise ValueError(""The number of dW_factors must fit"" +; "" the number of m_ops.""). if sso.dW_factors is None:; sso.dW_factors = [1.] * len_d2; sso.sops = [None] * len_d2; sso.ce_ops = [QobjEvo(op) for op in sso.e_ops]; for",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/stochastic.html:35237,Safe,Safety,35237,docs/4.7/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html,1,['Safe'],['Safety']
Safety,"Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threashold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/changelog.html:2266,avoid,avoid,2266,docs/4.1/changelog.html,https://qutip.org,https://qutip.org/docs/4.1/changelog.html,1,['avoid'],['avoid']
Safety,"] = '1'. import sys; import warnings. import qutip.settings; import qutip.version; from qutip.version import version as __version__; from qutip.utilities import _version2int. # -----------------------------------------------------------------------------; # Check if we're in IPython.; try:; __IPYTHON__; qutip.settings.ipython = True; except:; qutip.settings.ipython = False. # -----------------------------------------------------------------------------; # Check for minimum requirements of dependencies, give the user a warning; # if the requirements aren't fulfilled; #. numpy_requirement = ""1.6.0""; try:; import numpy; if _version2int(numpy.__version__) < _version2int(numpy_requirement):; print(""QuTiP warning: old version of numpy detected "" +; (""(%s), requiring %s."" %; (numpy.__version__, numpy_requirement))); except:; warnings.warn(""numpy not found.""). scipy_requirement = ""0.11.0""; try:; import scipy; if _version2int(scipy.__version__) < _version2int(scipy_requirement):; print(""QuTiP warning: old version of scipy detected "" +; (""(%s), requiring %s."" %; (scipy.__version__, scipy_requirement))); except:; warnings.warn(""scipy not found.""). # -----------------------------------------------------------------------------; # check to see if running from install directory for released versions.; #; top_path = os.path.dirname(os.path.dirname(__file__)); try:; setup_file = open(top_path + '/setup.py', 'r'); except:; pass; else:; if ('QuTiP' in setup_file.readlines()[1][3:]) and qutip.version.release:; print(""You are in the installation directory. "" +; ""Change directories before running QuTiP.""); setup_file.close(). del top_path. # -----------------------------------------------------------------------------; # setup the cython environment; #; _cython_requirement = ""0.15.0""; try:; import Cython; if _version2int(Cython.__version__) < _version2int(_cython_requirement):; print(""QuTiP warning: old version of cython detected "" +; (""(%s), requiring %s."" %; (Cython.__version__, _cytho",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip.html:4944,detect,detected,4944,docs/3.1.0/modules/qutip.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html,1,['detect'],['detected']
Safety,"_eigs; from qutip.states import ket2dm; from qutip.superop_reps import to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger(). try:; import cvxpy; except:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> fidelity(x,y); 0.24104350624628332. """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = (sqrtmA * B * sqrtmA).eigenenergies(); return float(np.real(np.sqrt(eig_vals[eig_vals > 0]).sum())). [docs]def process_fidelity(U1, U2, normalize=True):; """"""; Calculate",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/metrics.html:3476,avoid,avoid,3476,docs/4.2/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html,6,['avoid'],['avoid']
Safety,"ably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. Notes; It is slightly more computationally efficient to use a ket; vector for the ‘bra’ input. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:10736,safe,safebool,10736,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['safe'],['safebool']
Safety,"actors; (array) Array of length d2_len, containing scaling factors for each measurement operator in m_ops. rhs; (function) Function for calculating the deterministic and stochastic contributions to the right-hand side of the stochastic differential equation. This only needs to be specified when implementing a custom SDE solver. generate_A_ops; (function) Function that generates a list of pre-computed operators or super- operators. These precomputed operators are used in some d1 and d2 functions. generate_noise; (function) Function for generate an array of pre-computed noise signal. homogeneous; (bool (True)) Wheter or not the stochastic process is homogenous. Inhomogenous processes are only supported for poisson distributions. solver; (string) Name of the solver method to use for solving the stochastic equations. Valid values are: 1/2 order algorithms: ‘euler-maruyama’, ‘fast-euler-maruyama’, ‘pc-euler’ is a predictor-corrector method which is more stable than explicit methods, 1 order algorithms: ‘milstein’, ‘fast-milstein’, ‘platen’, ‘milstein-imp’ is semi-implicit Milstein method, 3/2 order algorithms: ‘taylor15’, ‘taylor15-imp’ is semi-implicit Taylor 1.5 method. Implicit methods can adjust tolerance via args = {‘tol’:value}, default is {‘tol’:1e-6}. method; (string (‘homodyne’, ‘heterodyne’, ‘photocurrent’)) The name of the type of measurement process that give rise to the stochastic equation to solve. Specifying a method with this keyword argument is a short-hand notation for using pre-defined d1 and d2 functions for the corresponding stochastic processes. distribution; (string (‘normal’, ‘poission’)) The name of the distribution used for the stochastic increments. store_measurements; (bool (default False)) Whether or not to store the measurement results in the qutip.solver.SolverResult instance returned by the solver. noise; (array) Vector specifying the noise. normalize; (bool (default True)) Whether or not to normalize the wave function during the evolution",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:43554,predict,predictor-corrector,43554,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['predict'],['predictor-corrector']
Safety,"aj""); if noise.shape[1] < len(times):; raise ValueError(msg + ""shape[1] >= len(times)""); if noise.shape[2] < nsubsteps:; raise ValueError(msg + ""shape[2] >= nsubsteps""); if noise.shape[3] < len(self.sc_ops) * dw_len:; raise ValueError(msg + ""shape[3] >= len(self.sc_ops)"" +; dw_len_str); self.noise_type = 1; self.noise = noise. else:; self.noise = np.random.randint(0, 2**32, ntraj).astype(""u4""); self.noise_type = 0. # Map; self.progress_bar = progress_bar; if self.ntraj > 1 and map_func:; self.map_func = map_func; else:; self.map_func = serial_map; self.map_kwargs = map_kwargs if map_kwargs is not None else {}. # Other; self.options = options; self.args = args; self.set_solver(); self.p = noiseDepth. def set_solver(self):; if self.solver in ['euler-maruyama', 'euler', 50, 0.5]:; self.solver_code = 50; self.solver = 'euler-maruyama'; elif self.solver in ['platen', 'platen1', 'explicit1', 100]:; self.solver_code = 100; self.solver = 'platen'; elif self.solver in ['pred-corr', 'predictor-corrector',; 'pc-euler', 101]:; self.solver_code = 101; self.solver = 'pred-corr'; elif self.solver in ['milstein', 102, 1.0]:; self.solver_code = 102; self.solver = 'milstein'; elif self.solver in ['milstein-imp', 103]:; self.solver_code = 103; self.solver = 'milstein-imp'; elif self.solver in ['pred-corr-2', 'pc-euler-2', 'pc-euler-imp', 104]:; self.solver_code = 104; self.solver = 'pred-corr-2'; elif self.solver in ['Rouchon', 'rouchon', 120]:; self.solver_code = 120; self.solver = 'rouchon'; if not all((op.const for op in self.sc_ops)):; raise ValueError(""Rouchon only works with constant sc_ops""); elif self.solver in ['platen15', 'explicit1.5', 'explicit15', 150]:; self.solver_code = 150; self.solver = 'explicit1.5'; elif self.solver in ['taylor15', 'taylor1.5', None, 1.5, 152]:; self.solver_code = 152; self.solver = 'taylor1.5'; elif self.solver in ['taylor15-imp', 'taylor1.5-imp', 153]:; self.solver_code = 153; self.solver = 'taylor1.5-imp'; elif self.solver in ['taylor2.0', 'tayl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/stochastic.html:16108,predict,predictor-corrector,16108,docs/4.5/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/stochastic.html,1,['predict'],['predictor-corrector']
Safety,"alculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters. rhoqobjDensity matrix for composite quantum systems. selAint/listint or list of first selected density matrix components. selBint/listint or list of second selected density matrix components. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_mutfloatMutual information between selected components. entropy_relative(rho, sigma, base=2.718281828459045, sparse=False, tol=1e-12)[source]¶; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters. rhoqutip.QobjFirst density matrix (or ket which will be converted to a density; matrix). sigmaqutip.QobjSecond density matrix (or ket which will be converted to a density; matrix). base{e,2}Base of logarithm. Defaults to e. sparseboolFlag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False. tolfloatTolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns. rel_entfloatValue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. References; See Nielsen & Chuang, “Quantum Computation and Quantum Information”,; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; Examples; First we define two density matrices:; >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. log2); and base e (i.e. log).; >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy of density matrix. Parameters. rhoqobjDensity matrix. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. entropyfloatVon-Neumann entropy of rho. E",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:60980,detect,detect,60980,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['detect'],['detect']
Safety,"allel execution of a mapping of `values` to the function `task`. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/parallel.html:6463,timeout,timeout,6463,docs/4.7/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/parallel.html,2,['timeout'],['timeout']
Safety,"and state.ndim == 2:; s1 = self.cte.shape[1]; new_l = int(np.sqrt(s1)); for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state.ravel(""F""); elif what == ""mat"":; self.args[name] = state; elif what == ""expect"":; self.args[name] = op.expect(t, state); elif state.shape[1] == 1:; self.args[name] = Qobj(state, dims=[self.cte.dims[1],[1]]); elif state.shape[1] == s1:; self.args[name] = Qobj(state, dims=self.cte.dims); else:; self.args[name] = Qobj(state). else:; raise TypeError(""state must be a Qobj or np.ndarray""). [docs] def copy(self):; """"""Return a copy of this object.""""""; new = QobjEvo(self.cte.copy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:21803,safe,safePickle,21803,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,2,['safe'],['safePickle']
Safety,"antum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : :class:`qutip.Qobj`; Qobj one; B : :class:`qutip.Qobj`; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobj.html:60260,avoid,avoid,60260,docs/4.5/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobj.html,1,['avoid'],['avoid']
Safety,"arameters; ----------; A : :class:`qutip.Qobj`; Density matrix or state vector.; B : :class:`qutip.Qobj`; Density matrix or state vector with same dimensions as A.; tol : float; Tolerance used by sparse eigensolver, if used. (0=Machine precision); sparse : {False, True}; Use sparse eigensolver. Returns; -------; hellinger_dist : float; Quantum Hellinger distance between A and B. Ranges from 0 to sqrt(2). Examples; --------; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(hellinger_dist(x,y), 1.3725145002591095); """"""; if A.isket or A.isbra:; sqrtmA = ket2dm(A); else:; sqrtmA = A.sqrtm(sparse=sparse, tol=tol); if B.isket or B.isbra:; sqrtmB = ket2dm(B); else:; sqrtmB = B.sqrtm(sparse=sparse, tol=tol). if sqrtmA.dims != sqrtmB.dims:; raise TypeError(""A and B do not have compatible dimensions.""). product = sqrtmA*sqrtmB; eigs = sp_eigs(product.data,; isherm=product.isherm, vecs=False, sparse=sparse, tol=tol); # np.maximum() is to avoid nan appearing sometimes due to numerical; # instabilities causing np.sum(eigs) slightly (~1e-8) larger than 1; # when hellinger_dist(A, B) is called for A=B; return np.sqrt(2.0 * np.maximum(0., (1.0 - np.real(np.sum(eigs))))). [docs]def dnorm(A, B=None, solver=""CVXOPT"", verbose=False, force_solve=False,; sparse=True):; """"""; Calculates the diamond norm of the quantum map q_oper, using; the simplified semidefinite program of [Wat13]_. The diamond norm SDP is solved by using CVXPY_. Parameters; ----------; A : Qobj; Quantum map to take the diamond norm of.; B : Qobj or None; If provided, the diamond norm of :math:`A - B` is taken instead.; solver : str; Solver to use with CVXPY. One of ""CVXOPT"" (default) or ""SCS"". The; latter tends to be significantly faster, but somewhat less accurate.; verbose : bool; If True, prints additional information about the solution.; force_solve : bool; If True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument.; sparse : bool; Whether to use",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/metrics.html:8033,avoid,avoid,8033,docs/4.7/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html,2,['avoid'],['avoid']
Safety,"arameters; ----------; A : :class:`qutip.Qobj`; Density matrix or state vector.; B : :class:`qutip.Qobj`; Density matrix or state vector with same dimensions as A.; tol : float; Tolerance used by sparse eigensolver, if used. (0=Machine precision); sparse : {False, True}; Use sparse eigensolver. Returns; -------; hellinger_dist : float; Quantum Hellinger distance between A and B. Ranges from 0 to sqrt(2). Examples; --------; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(hellinger_dist(x,y), 1.3725145002591095); """"""; if A.isket or A.isbra:; sqrtmA = ket2dm(A); else:; sqrtmA = A.sqrtm(sparse=sparse, tol=tol); if B.isket or B.isbra:; sqrtmB = ket2dm(B); else:; sqrtmB = B.sqrtm(sparse=sparse, tol=tol). if sqrtmA.dims != sqrtmB.dims:; raise TypeError(""A and B do not have compatible dimensions.""). product = sqrtmA*sqrtmB; eigs = sp_eigs(product.data,; isherm=product.isherm, vecs=False, sparse=sparse, tol=tol); # np.maximum() is to avoid nan appearing sometimes due to numerical; # instabilities causing np.sum(eigs) slightly (~1e-8) larger than 1; # when hellinger_dist(A, B) is called for A=B; return np.sqrt(2.0 * np.maximum(0., (1.0 - np.real(np.sum(eigs))))). def dnorm(A, B=None, solver=""CVXOPT"", verbose=False, force_solve=False,; sparse=True):; """"""; Calculates the diamond norm of the quantum map q_oper, using; the simplified semidefinite program of [Wat12]_. The diamond norm SDP is solved by using CVXPY_. Parameters; ----------; A : Qobj; Quantum map to take the diamond norm of.; B : Qobj or None; If provided, the diamond norm of :math:`A - B` is taken instead.; solver : str; Solver to use with CVXPY. One of ""CVXOPT"" (default) or ""SCS"". The; latter tends to be significantly faster, but somewhat less accurate.; verbose : bool; If True, prints additional information about the solution.; force_solve : bool; If True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument.; sparse : bool; Whether to use spars",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/metrics.html:9716,avoid,avoid,9716,docs/4.6/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html,2,['avoid'],['avoid']
Safety,"at; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = (sqrtmA * B * sqrtmA).eigenenergies(); return float(np.real(np.sqrt(eig_vals[eig_vals > 0]).sum())). [docs]def process_fidelity(U1, U2, normalize=True):; """"""; Calculate the process fidelity given two process operators.; """"""; if normalize:; return (U1 * U2).tr() / (U1.tr() * U2.tr()); else:; return (U1 * U2).tr(). [docs]def average_gate_fidelity(oper, target=None):; """"""; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters; ----------; A : Qobj; Quantum object representing a superoperator.; target : Qobj; Quantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns; -------; fid : float; Fidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary.; """"""; kraus_form = to_kraus(oper); d = kraus_form[0].shape[0]. if kraus_form",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/metrics.html:4287,avoid,avoid,4287,docs/4.6/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html,2,['avoid'],['avoid']
Safety,"ate0, times=times,; e_ops=e_ops, args=args, **kwargs); if sso.solver_code not in [50, 100, 150]:; raise ValueError(""Only Euler, platen, platen15 can be "" +; ""used for the general stochastic solver.""). sso.d1 = d1; sso.d2 = d2; if _safe_mode:; # This state0_vec is computed as mat2vec(state0.full()).ravel(); # in the sso init.; state0_vec = sso.rho0; l_vec = state0_vec.shape[0]; try:; out_d1 = d1(0., sso.rho0); except Exception as e:; raise RuntimeError(""Safety check: d1(0., state0_vec) failed.:\n"" +; str(e)) from e; try:; out_d2 = d2(0., sso.rho0); except Exception as e:; raise RuntimeError(""Safety check: d2(0., state0_vec) failed:\n"" +; str(e)) from e. msg_d1 = (""d1 must return an 1d numpy array with the same number ""; ""of elements as the initial state as a vector.""); if not isinstance(out_d1, np.ndarray):; raise TypeError(msg_d1); if (out_d1.ndim != 1; or out_d1.shape[0] != l_vec or len(out_d1.shape) != 1):; raise ValueError(msg_d1). msg_d2 = (""Safety check: d2 must return a 2d numpy array ""; ""with the shape (len_d2, len(state0_vec) ).""); if not isinstance(out_d2, np.ndarray):; raise TypeError(msg_d2); if (out_d2.ndim != 2; or out_d2.shape[1] != l_vec or out_d2.shape[0] != len_d2):; raise ValueError(msg_d2); if out_d1.dtype != np.dtype('complex128') or \; out_d2.dtype != np.dtype('complex128'):; raise ValueError(""Safety check: d1 and d2 must return "" +; ""complex numpy array.""); msg_e_ops = (""Safety check: The shape of the e_ops ""; ""does not fit the initial state.""); for op in sso.e_ops:; shape_op = op.shape; if sso.me:; if shape_op[0]**2 != l_vec or shape_op[1]**2 != l_vec:; raise ValueError(msg_e_ops); else:; if shape_op[0] != l_vec or shape_op[1] != l_vec:; raise ValueError(msg_e_ops +; "" Expecting e_ops as superoperators.""). sso.m_ops = []; sso.cm_ops = []; if sso.store_measurement:; if not m_ops:; raise ValueError(""General stochastic needs explicit "" +; ""m_ops to store measurement.""); sso.m_ops = m_ops; sso.cm_ops = [QobjEvo(op) for op in sso.m_ops]; [op.compil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/stochastic.html:34781,Safe,Safety,34781,docs/4.7/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html,1,['Safe'],['Safety']
Safety,"ate0, times=times,; e_ops=e_ops, args=args, **kwargs); if sso.solver_code not in [50, 100, 150]:; raise ValueError(""Only Euler, platen, platen15 can be "" +; ""used for the general stochastic solver.""). sso.d1 = d1; sso.d2 = d2; if _safe_mode:; # This state0_vec is computed as mat2vec(state0.full()).ravel(); # in the sso init.; state0_vec = sso.rho0; l_vec = state0_vec.shape[0]; try:; out_d1 = d1(0., sso.rho0); except Exception as e:; raise RuntimeError(""Safety check: d1(0., state0_vec) failed.:\n"" +; str(e)) from e; try:; out_d2 = d2(0., sso.rho0); except Exception as e:; raise RuntimeError(""Safety check: d2(0., state0_vec) failed:\n"" +; str(e)) from e. msg_d1 = (""d1 must return an 1d numpy array with the same number ""; ""of elements as the initial state as a vector.""); if not isinstance(out_d1, np.ndarray):; raise TypeError(msg_d1); if (out_d1.ndim != 1; or out_d1.shape[0] != l_vec or len(out_d1.shape) != 1):; raise ValueError(msg_d1). msg_d2 = (""Safety check: d2 must return a 2d numpy array ""; ""with the shape (len_d2, len(state0_vec) ).""); if not isinstance(out_d2, np.ndarray):; raise TypeError(msg_d2); if (out_d2.ndim != 2; or out_d2.shape[1] != l_vec or out_d2.shape[0] != len_d2):; raise ValueError(msg_d2); if out_d1.dtype != np.dtype('complex128') or \; out_d2.dtype != np.dtype('complex128'):; raise ValueError(""Safety check: d1 and d2 must return "" +; ""complex numpy array.""); msg_e_ops = (""Safety check: The shape of the e_ops ""; ""does not fit the intial state.""); for op in sso.e_ops:; shape_op = op.shape; if sso.me:; if shape_op[0]**2 != l_vec or shape_op[1]**2 != l_vec:; raise ValueError(msg_e_ops); else:; if shape_op[0] != l_vec or shape_op[1] != l_vec:; raise ValueError(msg_e_ops +; "" Expecting e_ops as superoperators.""). sso.m_ops = []; sso.cm_ops = []; if sso.store_measurement:; if not m_ops:; raise ValueError(""General stochastic needs explicit "" +; ""m_ops to store measurement.""); sso.m_ops = m_ops; sso.cm_ops = [QobjEvo(op) for op in sso.m_ops]; [op.compile",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:36282,Safe,Safety,36282,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,1,['Safe'],['Safety']
Safety,"ay; Array of length d2_len, containing scaling factors for each; measurement operator in m_ops. rhs : function; Function for calculating the deterministic and stochastic contributions; to the right-hand side of the stochastic differential equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops : function; Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise : function; Function for generate an array of pre-computed noise signal. homogeneous : bool (True); Wheter or not the stochastic process is homogenous. Inhomogenous; processes are only supported for poisson distributions. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are: ; 1/2 order algorithms: 'euler-maruyama', 'fast-euler-maruyama',; 'pc-euler' is a predictor-corrector method which is more ; stable than explicit methods,; 1 order algorithms: 'milstein', 'fast-milstein', 'platen',; 'milstein-imp' is semi-implicit Milstein method,; 3/2 order algorithms: 'taylor15', ; 'taylor15-imp' is semi-implicit Taylor 1.5 method.; Implicit methods can adjust tolerance via args = {'tol':value},; default is {'tol':1e-6}. method : string ('homodyne', 'heterodyne', 'photocurrent'); The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution : string ('normal', 'poission'); The name of the distribution used for the stochastic increments. store_measurements : bool (default False); Whether or not to store the measurement results in the; :class:`qutip.solver.SolverResult` instance returned by the solver. noise : array; Vector specifying the noise. normalize : bool (default True); Whether or not to normalize the wave function ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:6601,predict,predictor-corrector,6601,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,3,['predict'],['predictor-corrector']
Safety,"bj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(squeeze=False)[source]¶; Dense array from quantum object. Returns:data : array. Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). safe : bool (default=True). Check for degenerate ground state. Returns:eigval : float. Eigenvalue for the ground state of quantum operator. eigvec : qobj. Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex valued matrix element. Raises:TypeError. Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:norm : str. Which norm to use for ket/bra vectors",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/classes.html:10296,safe,safe,10296,docs/4.1/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/classes.html,1,['safe'],['safe']
Safety,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-settings.html:3556,detect,detect,3556,docs/3.1.0/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-settings.html,1,['detect'],['detect']
Safety,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-settings.html:3516,detect,detect,3516,docs/3.0.1/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-settings.html,1,['detect'],['detect']
Safety,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-settings.html:3454,detect,detect,3454,docs/3.0.0/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-settings.html,1,['detect'],['detect']
Safety,"chastic operator; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with >2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]); sc_len = len(A); sc2_len = 2 * sc_len. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(d_vec[:-1].reshape(; -1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[sc2_len:-1] -= np.array(; [e[m] * d_vec[n] + e[n] * d_vec[m]; for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). e[sc_len:sc2_len] -= 2.0 * e[:sc_len] * e[:sc_len]; e[sc2_len:] -= 2.0 * np.array(; [e[n] * e[m] for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). drho_t = - np.inner(e, dW) * rho_t; dW[:sc_len] -= 2.0 * e[:sc_len] * dW[sc_len:sc2_len]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_taylor_15_one(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; strong order 1.5 Tylor scheme for homodyne detection with 1 stochastic operator; """""". dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:53579,detect,detection,53579,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,4,['detect'],['detection']
Safety,"class-based version, more efficient if you want to calculate the; Husimi-Q function for several states over the same coordinates.; """"""; state = _qfunc_check_state(state); xvec, yvec = _qfunc_check_coordinates(xvec, yvec); required_memory = state.shape[0] * xvec.size * yvec.size * 16 / (1024 ** 2); enough_memory = (; precompute_memory is not None; and precompute_memory > required_memory; ); if state.isoper and enough_memory:; return QFunc(xvec, yvec, g)(state); if precompute_memory is not None and state.isoper:; warnings.warn(; ""Falling back to iterative algorithm due to lack of memory.""; f"" Needed {required_memory:.2f} MB, but only allowed to use""; f"" {precompute_memory:.2f} MB. Increase `precompute_memory` to""; "" raise limit, or set to `None` to suppress warning.""; ); alpha_grid = _QFuncCoherentGrid(xvec, yvec, g); if state.isket:; out = _qfunc_iterative_single(state.full().ravel(), alpha_grid, g); out /= np.pi; return out; # We don't use Qobj.eigenstates() to avoid building many unnecessary CSR; # versions of dense matrices.; values, vectors = eigh(state.full()); vectors = vectors.T; out = values[0] * _qfunc_iterative_single(vectors[0], alpha_grid, g); for value, vector in zip(values[1:], vectors[1:]):; out += value * _qfunc_iterative_single(vector, alpha_grid, g); out /= np.pi; return out. # -----------------------------------------------------------------------------; # PSEUDO DISTRIBUTION FUNCTIONS FOR SPINS; #; [docs]def spin_q_function(rho, theta, phi):; r""""""The Husimi Q function for spins is defined as ``Q(theta, phi) =; SCS.dag() * rho * SCS`` for the spin coherent state ``SCS = spin_coherent(; j, theta, phi)`` where j is the spin length.; The implementation here is more efficient as it doesn't; generate all of the SCS at theta and phi (see references). The spin Q function is normal when integrated over the surface of the; sphere. .. math:: \frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1. Parameters; ----------; stat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/wigner.html:27376,avoid,avoid,27376,docs/4.6/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html,4,['avoid'],['avoid']
Safety,"ct_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = b * dW[0]; drho_t += Lb * dW[1] # Milstein term; xx0 = (drho_t + a * dt) + rho_t #starting vector for the linear solver (Milstein prediction); drho_t += (0.5 * dt) * a. # new terms:; drho_t += A[-1] * b * (dW[2] - 0.5*dW[0]*dt); drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]. drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]; drho_t += rho_t. #FIXME: This atol keyword except check can be removed once scipy 1.1; # is a minimum requirement; try:; v, check = sp.linalg.bicgstab(A[-2], drho_t, x0=xx0,; tol=args['tol'], atol='legacy'); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = sp.linalg.bicgstab(A[-2], drho_t, x0=xx0,; tol=args['tol']); return v. def _rhs_rho_pred_corr_homodyne_single(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; 1/2 predictor-corrector scheme for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]. #predictor. d_vec = (A[0][0] * rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_pred = np.copy(d_vec[-1]); b_pred = - e[0] * rho_t; b_pred += d_vec[0]. pred_rho_t = np.copy(a_pred); pred_rho_t += b_pred * dW[0]; pred_rho_t += rho_t. a_pred -= ((d_vec[1] - e[1] * rho_t) - (2.0 * e[0]) * b_pred) * (0.5 * dt). #corrector. d_vec = (A[0][0] * pred_rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_corr = d_vec[-1]; b_corr = - e[0] * pred_rho_t; b_corr += d_vec[0]. a_corr -= ((d_vec[1] - e[1] * pred_rho_t) - (2.0 * e[0]) * b_corr) * (0.5 * dt); a_corr += a_pred; a_corr *= 0.5. b_corr += b_pred; b_corr *= 0.5 * dW[0]. corr_rho_t = a_corr; corr_rho_t += b_corr; corr_rho_t += rho_t. return corr_rho_t. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme prov",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/stochastic.html:57562,predict,predictor,57562,docs/4.3/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/stochastic.html,1,['predict'],['predictor']
Safety,"e a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Getting the Built Documentation¶; The documentation will have been built automatically for you by a GitHub Action when you merged the final pull request into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this is a patch release, unless there were changes within it.; Go to the “Actions” tab at the top of the qutip/qutip repository, and click the “Build HTML documentation” heading in the left column.; You should see a list of times this action has run; click the most recent one whose name is exactly “Build HTML documentation”, with the release branch name next to it (e.g. qutip-4.6.X).; Download the qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are all the HTML files for the built documentation; you should be able to open index.html in your own web browser and check that everything is working. Making a Release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version>”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:14928,safe,safe,14928,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['safe'],['safe']
Safety,"e, *task_args, **task_kwargs); results.append(result); progress_bar.finished(). return results. [docs]def parallel_map(task, values, task_args=tuple(), task_kwargs={}, **kwargs):; """"""; Parallel execution of a mapping of `values` to the function `task`. This; is functionally equivalent to:. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. progress_bar: ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for each; value in ``values``. """"""; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; pool.terminate(); pool.join(); raise e. progress_bar.finished(). return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/parallel.html:9120,timeout,timeout,9120,docs/3.1.0/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/parallel.html,1,['timeout'],['timeout']
Safety,"een A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; if B.isket or B.isbra:; # The fidelity for pure states reduces to the modulus of their; # inner product.; return np.abs(A.overlap(B)); # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = (sqrtmA * B * sqrtmA).eigenenergies(); return float(np.real(np.sqrt(eig_vals[eig_vals > 0]).sum())). [docs]def process_fidelity(U1, U2, normalize=True):; """"""; Calculate the process fidelity given two process operators.; """"""; if normalize:; return (U1 * U2).tr() / (U1.tr() * U2.tr()); else:; return (U1 * U2).tr(). [docs]def average_gate_fidelity(oper, target=None):; """"""; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters; ----------; A : Qobj; Quantum object representing a superoperator.; target : Qobj; Quantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns; -------; fid : float; Fidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary.; """"""; kraus_form = to_kraus(oper); d = kraus_form[0].shape[0]. if kraus_form",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/metrics.html:2598,avoid,avoid,2598,docs/4.7/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html,2,['avoid'],['avoid']
Safety,"ef groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; sh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:43561,safe,safe,43561,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,2,['safe'],['safe']
Safety,"el.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_map is not enforced to be NumPy arrays, which can avoid unnecessary copying if all that is needed is to iterate over the resulting list:; >>> result = parfor(func1, range(5)). >>> print(result); [array([0, 1, 2, 3, 4]), array([ 0, 1, 4, 9, 16]), array([ 0, 1, 8, 27, 64])]. >>> result = parallel_map(func1, range(5)). >>> print(result); [(0, 0, 0), (1, 1, 1), (2, 4, 8), (3, 9, 27), (4, 16, 64)]. The qutip.parallel.parallel_map and qutip.parallel.parfor functions are not limited to just numbers, but also works for a variety of outputs:; >>> def func2(x): return x, Qobj(x), 'a' * x. >>> a, b, c = parfor(func2, range(5)). >>> print(a); [0 1 2 3 4]. >>> print(b); [Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[1.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[2.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[3.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[4.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-parfor.html:2402,avoid,avoid,2402,docs/4.6/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-parfor.html,4,['avoid'],['avoid']
Safety,"elf._memory_mb} MB is allowed.""; ); if self._cache is None:; self._cache = self._coherent_grid(self._current_size, size); else:; self._cache = np.dstack(; [self._cache, self._coherent_grid(self._current_size, size)]; ); self._current_size = size; return self._cache. def _single(self, vector: np.ndarray, alphas: np.ndarray):; r""""""; Get the Q function (without the :math:`\pi` scaling factor) of a single; state vector.; """"""; return np.abs(np.dot(alphas, (self._g * 0.5) * vector)) ** 2. def __call__(self, state: Qobj):; """"""; Get the Husimi-Q function for the given state vector or density matrix,; over the coordinates used to initialise the class. If called multiple; times, the states do not need to have the same dimensions, but none of; them can have tensor-product structure.; """"""; state = _qfunc_check_state(state); alphas = self._alphas(state.shape[0]); if state.isket:; return self._single(state.full().ravel(), alphas) / np.pi; # We don't use Qobj.eigenstates() to avoid building many unnecessary; # CSR versions of dense matrices.; values, vectors = eigh(state.full()); vectors = vectors.T; out = values[0] * self._single(vectors[0], alphas); for value, vector in zip(values[1:], vectors[1:]):; out += value * self._single(vector, alphas); return out / np.pi. def _qfunc_iterative_single(; vector: np.ndarray, alpha_grid: _QFuncCoherentGrid, g: float,; ):; r""""""; Get the Q function (without the :math:`\pi` scaling factor) of a single; state vector, using the iterative algorithm which recomputes the powers of; the coherent-state matrix.; """"""; ns = np.arange(vector.shape[0]); out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha_grid.grid,; ); out *= alpha_grid.prefactor; return np.abs(out)**2. [docs]def qfunc(; state: Qobj,; xvec,; yvec,; g: float = sqrt(2),; precompute_memory: float = 1024,; ):; r""""""; Husimi-Q function of a given state vector or density matrix at phase-space; points ``0.5 * g * (xvec + i*yvec)``. Parameters; ----------; state ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/wigner.html:24310,avoid,avoid,24310,docs/4.6/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html,4,['avoid'],['avoid']
Safety,"elf.num_comp_waves = 20; try:; self.min_wavelen = self.pulse_time / 10.0; except:; self.min_wavelen = 0.1; try:; self.max_wavelen = 2*self.pulse_time; except:; self.max_wavelen = 10.0; self.apply_params(). def gen_pulse(self, num_comp_waves=None,; min_wavelen=None, max_wavelen=None):; """"""; Generate a random pulse by summing sine waves with random freq,; amplitude and phase offset; """""". if num_comp_waves is not None:; self.num_comp_waves = num_comp_waves; if min_wavelen is not None:; self.min_wavelen = min_wavelen; if max_wavelen is not None:; self.max_wavelen = max_wavelen. num_comp_waves = self.num_comp_waves; min_wavelen = self.min_wavelen; max_wavelen = self.max_wavelen. if min_wavelen > self.pulse_time:; raise ValueError(""Minimum wavelength cannot be greater than ""; ""the pulse time""); if max_wavelen <= min_wavelen:; raise ValueError(""Maximum wavelength must be greater than ""; ""the minimum wavelength""). if not self._pulse_initialised:; self.init_pulse(). # use some phase to avoid the first pulse being always 0. sum_wave = np.zeros(self.tau.shape). t = self.time; wl_range = max_wavelen - min_wavelen; amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves); for n in range(num_comp_waves):; amp = amp_scale*(np.random.rand()*2 - 1); phase_off = np.random.rand()*np.pi/2.0; wavelen = min_wavelen + np.random.rand()*wl_range; curr_wave = amp*np.sin(2*np.pi*t/wavelen + phase_off); sum_wave += curr_wave. return self._apply_bounds_and_offset(sum_wave). class PulseGenRndWalk1(PulseGen):; """"""; Generates pulses by using a random walk algorithm. Attributes; ----------; scaling : float; Used as the range for the starting amplitude; Note must used bounds if values must be restricted.; Also scales the max_d_amp value; (copied from Dynamics.initial_ctrl_scaling if given). max_d_amp : float; Maximum amount amplitude will change between timeslots; Note this is also factored by the scaling attribute; """"""; def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.res",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html:15055,avoid,avoid,15055,docs/4.1/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html,10,['avoid'],['avoid']
Safety,"ent norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; g = -2*self.scale_factor*np.real(; (evo_f_diff.dag()*evo_grad).tr()); else:; evo_grad = dyn._get_prop_grad(k, j).dot(fwd_evo); if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1].dot(evo_grad); g = -2*self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_grad))); if np.isnan(g):; g = np.Inf. grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiffApprox(FidCompTraceDiff):; """"""; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes; ----------; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude; ; """"""; [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of func",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:21718,avoid,avoids,21718,docs/4.3/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html,7,['avoid'],['avoids']
Safety,"ent norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; g = -2*self.scale_factor*np.real(; (evo_f_diff.dag()*evo_grad).tr()); else:; evo_grad = dyn._get_prop_grad(k, j).dot(fwd_evo); if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1].dot(evo_grad); g = -2*self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_grad))); if np.isnan(g):; g = np.Inf. grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiffApprox(FidCompTraceDiff):; """"""; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes; ----------; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude; ; """"""; def reset(self):; FidelityComputer.reset(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:21697,avoid,avoids,21697,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,3,['avoid'],['avoids']
Safety,"ents to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method run_analytically of Processor. (#1603 Boxi Li); The hadamard_transform was made much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state #1459), but the propagator function’s calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. propagator now calls mesolve with the correct dimensions set on the initial state. (#1588 by Simon Cross); Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (#1588 by Simon Cross); Fixed the ignoring of the random number seed passed to rand_dm in the case where pure was set to true. (#1600 Pontus Wikståhl); Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (#1621 by Simon Cross); Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:3845,sanity check,sanity checks,3845,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['sanity check'],['sanity checks']
Safety,"ents {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)). if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs,; self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs. [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(). [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the ; # main optmisation call sequence; self.set_coeffs(param_vals). def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]). def init_guess_pulse(self):. self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)). def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse. def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse. def _init_bounds(self):; add_guess_pulse_scale = False; if self.l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulsegen.html:31719,avoid,avoided,31719,docs/4.4/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulsegen.html,1,['avoid'],['avoided']
Safety,"er (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], se",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:43046,safe,safe,43046,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,2,['safe'],['safe']
Safety,"er (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:45880,safe,safe,45880,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,4,['safe'],['safe']
Safety,"er (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:39847,safe,safe,39847,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,3,['safe'],['safe']
Safety,"er (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print('WARNING: Ground state may be degenerate. Use Q.eigenstates()'); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] de",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:39641,safe,safe,39641,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['safe'],['safe']
Safety,"er = 'taylor2.0'; if not len(self.sc_ops) == 1 or \; not self.sc_ops[0].const or \; not self.method == ""homodyne"":; raise Exception(""Taylor2.0 only work with 1 constant sc_ops "" +; ""and for homodyne method""); else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler-maruyama', 'platen', 'pc-euler', "" +; ""'pc-euler-imp', 'milstein', 'milstein-imp', "" +; ""'rouchon', "" +; ""'taylor1.5', 'taylor1.5-imp', 'explicit1.5' "" +; ""'taylor2.0']""). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a determinist",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:17949,predict,predictor-corrector,17949,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,1,['predict'],['predictor-corrector']
Safety,"erated.; dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns; -------; rho : Qobj; A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution.; """"""; if dims is not None:; # TODO: check!; pass; else:; dims = [[[N],[N]], [[N],[N]]]. if rank is None:; rank = N**2; if rank > N**2:; raise ValueError(""Rank cannot exceed superoperator dimension.""). # We use mainly dense matrices here for speed in low; # dimensions. In the future, it would likely be better to switch off; # between sparse and dense matrices as the dimension grows. # We start with a Ginibre uniform matrix X of the appropriate rank,; # and use it to construct a positive semidefinite matrix X X⁺.; X = randnz((N**2, rank), norm='ginibre'); ; # Precompute X X⁺, as we'll need it in two different places.; XXdag = np.dot(X, X.T.conj()); ; if enforce_tp:; # We do the partial trace over the first index by using dense reshape; # operations, so that we can avoid bouncing to a sparse representation; # and back.; Y = np.einsum('ijik->jk', XXdag.reshape((N, N, N, N))). # Now we have the matrix 𝟙 ⊗ Y^{-1/2}, which we can find by doing; # the square root and the inverse separately. As a possible improvement,; # iterative methods exist to find inverse square root matrices directly,; # as this is important in statistics.; Z = np.kron(; np.eye(N),; sqrtm(la.inv(Y)); ). # Finally, we dot everything together and pack it into a Qobj,; # marking the dimensions as that of a type=super (that is,; # with left and right compound indices, each representing; # left and right indices on the underlying Hilbert space).; D = Qobj(np.dot(Z, np.dot(XXdag, Z))); else:; D = N * Qobj(XXdag / np.trace(XXdag)). D.dims = [; # Left dims; [[N], [N]],; # Right dims; [[N], [N]]; ]. # Since [BCSZ08] gives a row-stacking Choi matrix, but QuTiP; # expects a column-stacking Choi matrix, we must permute the indices.; D = D.permute([[1], [0]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/random_objects.html:15588,avoid,avoid,15588,docs/4.2/modules/qutip/random_objects.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/random_objects.html,4,['avoid'],['avoid']
Safety,"erator. Raises. TypeErrorQuantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwic",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:10357,safe,safe,10357,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['safe'],['safe']
Safety,"es if given quantum object is a super-operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended.; ; """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : qobj; Qobj one; B : qobj; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B.; ; """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended.; ; """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:53859,avoid,avoid,53859,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['avoid'],['avoid']
Safety,"et = StepCoeffT(; self.ops, None, self.tlist); else:; self.coeff_get = InterCoeffT(; self.ops, None, self.tlist); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get). elif self.type == ""spline"":; self.coeff_get = InterpolateCoeff(self.ops, None, None); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get). else:; pass. coeff_files.clean(); if code:; return Code. def _get_coeff(self, t):; out = []; for part in self.ops:; out.append(part.get_coeff(t, self.args)); return out. def __getstate__(self):; _dict_ = {key: self.__dict__[key]; for key in self.__dict__ if key != ""compiled_qobjevo""}; if self.compiled:; return (_dict_, self.compiled_qobjevo.__getstate__()); else:; return (_dict_,). def __setstate__(self, state):; self.__dict__ = state[0]; self.compiled_qobjevo = None; if self.compiled:; mat_type, threading, td = self.compiled.split(); if mat_type == ""csr"":; if self.safePickle:; # __getstate__ and __setstate__ of compiled_qobjevo pass pointers; # In 'safe' mod, these pointers are not used.; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte(); self.compiled_qobjevo.set_data(self.cte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp(); self.compiled_qobjevo.set_data(self.cte); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd(); self.compiled_qobjevo.set_data(self.cte, self.ops); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp(); self.compiled_qobjevo.set_data(self.cte, self.ops); self.compiled_qobjevo.set_threads(self.omp). if td == ""pyfunc"":; self.compiled_qobjevo.set_factor(; func=self.coeff_get); elif td == ""cyfactor"":; self.compiled_qobjevo.set_factor(; obj=self.coeff_get); else:; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte.__new__(CQobjCte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp.__new__(; C",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:46367,safe,safePickle,46367,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,4,['safe'],"['safe', 'safePickle']"
Safety,"et = StepCoeffT(; self.ops, None, self.tlist); else:; self.coeff_get = InterCoeffT(; self.ops, None, self.tlist); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get). elif self.type == ""spline"":; self.coeff_get = InterpolateCoeff(self.ops, None, None); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get). else:; pass. coeff_files.clean(); if code:; return Code. def _get_coeff(self, t):; out = []; for part in self.ops:; out.append(part.get_coeff(t, self.args)); return out. def __getstate__(self):; _dict_ = {key: self.__dict__[key]; for key in self.__dict__ if key != ""compiled_qobjevo""}; if self.compiled:; return (_dict_, self.compiled_qobjevo.__getstate__()); else:; return (_dict_,). def __setstate__(self, state):; self.__dict__ = state[0]; self.compiled_qobjevo = None; if self.compiled:; mat_type, threading, td = self.compiled.split(); if mat_type == ""csr"":; if self.safePickle:; # __getstate__ and __setstate__ of compiled_qobjevo pass pointers; # In 'safe' mod, these pointers are not used.; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte(); self.compiled_qobjevo.set_data(self.cte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp(); self.compiled_qobjevo.set_data(self.cte); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd(); self.compiled_qobjevo.set_data(self.cte, self.ops); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp(); self.compiled_qobjevo.set_data(self.cte, self.ops); self.compiled_qobjevo.set_threads(self.omp). if td == ""pyfunc"":; self.compiled_qobjevo.set_factor(func=self.coeff_get); elif td == ""cyfactor"":; self.compiled_qobjevo.set_factor(obj=self.coeff_get); else:; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte.__new__(CQobjCte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp.__new__(CQobjCt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:48015,safe,safePickle,48015,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,4,['safe'],"['safe', 'safePickle']"
Safety,"eturn results. [docs]def parallel_map(task, values, task_args=tuple(), task_kwargs={}, **kwargs):; """"""; Parallel execution of a mapping of `values` to the function `task`. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of ; ``task(value, *task_args, **task_kwargs)`` for ; each value in ``values``. """"""; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; pool.terminate(); pool.join(); raise e. progress_bar.finished(). return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/parallel.html:7886,timeout,timeout,7886,docs/4.0.2/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/parallel.html,1,['timeout'],['timeout']
Safety,"ext = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:23762,avoid,avoids,23762,docs/4.3/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html,1,['avoid'],['avoids']
Safety,"f Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. [docs]def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : :class:`qutip.Qobj`; Qobj one; B : :class:`qutip.Qobj`; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. [docs]def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:62120,avoid,avoid,62120,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,2,['avoid'],['avoid']
Safety,"f you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:6117,detect,detection,6117,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,4,['detect'],['detection']
Safety,"fficients.; [(Qobj, coefficient as a function, original coefficient,. type, local arguments ), … ]. type :1: function; 2: string; 3: np.array; 4: Cubic_Spline. argsmaparguments of the coefficients. dynamics_argslistarguments that change during evolution. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstringHas the cython version of the QobjEvo been created. compiled_qobjevocy_qobj (CQobjCte or CQobjEvoTd)Cython version of the QobjEvo. coeff_getcallable objectobject called to obtain a list of coefficient at t. coeff_fileslistruntime created files to delete with the instance. dummy_cteboolis self.cte a empty Qobj. constboolIndicates if quantum object is Constant. typestring; information about the type of coefficient“string”, “func”, “array”,; “spline”, “mixed_callable”, “mixed_compilable”. num_objintnumber of Qobj in the QobjEvo : len(ops) + (1 if not dummy_cte). use_cythonboolflag to compile string to cython or python. safePickleboolflag to not share pointers between thread. Methods. copy() :; Create copy of Qobj. arguments(new_args):; Update the args of the object. Math:; +/- QobjEvo, Qobj, scalar: Addition is possible between QobjEvo and with Qobj or scalar -: Negation operator * Qobj, scalar: Product is possible with Qobj or scalar / scalar: It is possible to divide by scalar only. conj(); Return the conjugate of quantum object. dag(); Return the adjoint (dagger) of quantum object. trans(); Return the transpose of quantum object. _cdc(); Return self.dag() * self. permute(order); Returns composite qobj with indices reordered. apply(f, *args, **kw_args); Apply the function f to every Qobj. f(Qobj) -> Qobj Return a modified QobjEvo and let the original one untouched. apply_decorator(decorator, *args, str_mod=None,; inplace_np=False, **kw_args): Apply the decorator to each function of the ops. The *args and **kw_args are passed to the decorator. new_coeff_function = decorator(coeff_function, *args, **kw_args) str_mod : list of 2",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:20778,safe,safePickleboolflag,20778,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['safe'],['safePickleboolflag']
Safety,"gs; list of y labels. title : string; title of the plot (optional). limits : list/array with two float numbers; The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers; The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance; The axes context in which the plot will be drawn. threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------; ValueError; Input argument is not valid. """""". if isinstance(M, Qobj):; # extract matrix data from Qobj; M = M.full(). n = np.size(M); xpos, ypos = np.meshgrid(range(M.shape[0]), range(M.shape[1])); xpos = xpos.T.flatten() - 0.5; ypos = ypos.T.flatten() - 0.5; zpos = np.zeros(n); dx = dy = 0.8 * np.ones(n); Mvec = M.flatten(); dz = abs(Mvec). # make small numbers real, to avoid random colors; idx, = np.where(abs(Mvec) < 0.001); Mvec[idx] = abs(Mvec[idx]). if phase_limits: # check that limits is a list type; phase_min = phase_limits[0]; phase_max = phase_limits[1]; else:; phase_min = -pi; phase_max = pi. norm = mpl.colors.Normalize(phase_min, phase_max); cmap = complex_phase_cmap(). colors = cmap(norm(angle(Mvec))); if threshold is not None:; colors[:, 3] = 1 * (dz > threshold). if ax is None:; fig = plt.figure(); ax = Axes3D(fig, azim=-35, elev=35). ax.bar3d(xpos, ypos, zpos, dx, dy, dz, color=colors). if title and fig:; ax.set_title(title). # x axis; ax.axes.w_xaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if xlabels:; ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ax.axes.w_yaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if ylabels:; ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use mi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/visualization.html:12878,avoid,avoid,12878,docs/4.1/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/visualization.html,7,['avoid'],['avoid']
Safety,"gs; list of y labels. title : string; title of the plot (optional). limits : list/array with two float numbers; The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers; The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance; The axes context in which the plot will be drawn. threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------; ValueError; Input argument is not valid. """""". if isinstance(M, Qobj):; # extract matrix data from Qobj; M = M.full(). n = np.size(M); xpos, ypos = np.meshgrid(range(M.shape[0]), range(M.shape[1])); xpos = xpos.T.flatten() - 0.5; ypos = ypos.T.flatten() - 0.5; zpos = np.zeros(n); dx = dy = 0.8 * np.ones(n); Mvec = M.flatten(); dz = abs(Mvec). # make small numbers real, to avoid random colors; idx, = np.where(abs(Mvec) < 0.001); Mvec[idx] = abs(Mvec[idx]). if phase_limits: # check that limits is a list type; phase_min = phase_limits[0]; phase_max = phase_limits[1]; else:; phase_min = -pi; phase_max = pi. norm = mpl.colors.Normalize(phase_min, phase_max); cmap = complex_phase_cmap(). colors = cmap(norm(angle(Mvec))); if threshold is not None:; colors[:, 3] = 1 * (dz > threshold). if ax is None:; fig = plt.figure(); ax = _axes3D(fig, azim=-35, elev=35). ax.bar3d(xpos, ypos, zpos, dx, dy, dz, color=colors). if title and fig:; ax.set_title(title). # x axis; xtics = -0.5 + np.arange(M.shape[0]); ax.axes.w_xaxis.set_major_locator(plt.FixedLocator(xtics)); if xlabels:; nxlabels = len(xlabels); if nxlabels != len(xtics):; raise ValueError(f""got {nxlabels} xlabels but needed {len(xtics)}""); ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ytics = -0.5 + np.arange(M.shape[1]); ax.axes.w_yaxis.set_major_locator(plt.FixedLocator(ytics))",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/visualization.html:16408,avoid,avoid,16408,docs/4.6/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/visualization.html,2,['avoid'],['avoid']
Safety,"gs; list of y labels. title : string; title of the plot (optional). limits : list/array with two float numbers; The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers; The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance; The axes context in which the plot will be drawn. threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------; ValueError; Input argument is not valid. """""". if isinstance(M, Qobj):; # extract matrix data from Qobj; M = M.full(). n = np.size(M); xpos, ypos = np.meshgrid(range(M.shape[0]), range(M.shape[1])); xpos = xpos.T.flatten() - 0.5; ypos = ypos.T.flatten() - 0.5; zpos = np.zeros(n); dx = dy = 0.8 * np.ones(n); Mvec = M.flatten(); dz = abs(Mvec). # make small numbers real, to avoid random colors; idx, = np.where(abs(Mvec) < 0.001); Mvec[idx] = abs(Mvec[idx]). if phase_limits: # check that limits is a list type; phase_min = phase_limits[0]; phase_max = phase_limits[1]; else:; phase_min = -pi; phase_max = pi. norm = mpl.colors.Normalize(phase_min, phase_max); cmap = complex_phase_cmap(). colors = cmap(norm(angle(Mvec))); if threshold is not None:; colors[:, 3] = 1 * (dz > threshold). if ax is None:; fig = plt.figure(); ax = _axes3D(fig, azim=-35, elev=35). ax.bar3d(xpos, ypos, zpos, dx, dy, dz, color=colors). if title:; ax.set_title(title). # x axis; xtics = -0.5 + np.arange(M.shape[0]); if parse_version(mpl.__version__) >= parse_version(""3.8""):; ax.axes.xaxis.set_major_locator(plt.FixedLocator(xtics)); else:; ax.axes.w_xaxis.set_major_locator(plt.FixedLocator(xtics)); if xlabels:; nxlabels = len(xlabels); if nxlabels != len(xtics):; raise ValueError(f""got {nxlabels} xlabels but needed {len(xtics)}""); ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/visualization.html:21994,avoid,avoid,21994,docs/4.7/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/visualization.html,2,['avoid'],['avoid']
Safety,"h fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:13886,avoid,avoided,13886,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,4,['avoid'],['avoided']
Safety,"he super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; In [20]: N = 10 ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:15801,avoid,avoid,15801,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,4,['avoid'],['avoid']
Safety,"hings in parallel. Should be set; # by user directly in a script or notebook if >1 is needed.; # Must be set BEFORE importing NumPy; if 'MKL_NUM_THREADS' not in os.environ:; os.environ['MKL_NUM_THREADS'] = '1'. if 'OPENBLAS_NUM_THREADS' not in os.environ:; os.environ['OPENBLAS_NUM_THREADS'] = '1'. import sys; import warnings. import qutip.settings; import qutip.version; from qutip.version import version as __version__; from qutip.utilities import _version2int. # -----------------------------------------------------------------------------; # Check if we're in IPython.; try:; __IPYTHON__; qutip.settings.ipython = True; except:; qutip.settings.ipython = False. # -----------------------------------------------------------------------------; # Check for minimum requirements of dependencies, give the user a warning; # if the requirements aren't fulfilled; #. numpy_requirement = ""1.6.0""; try:; import numpy; if _version2int(numpy.__version__) < _version2int(numpy_requirement):; print(""QuTiP warning: old version of numpy detected "" +; (""(%s), requiring %s."" %; (numpy.__version__, numpy_requirement))); except:; warnings.warn(""numpy not found.""). scipy_requirement = ""0.11.0""; try:; import scipy; if _version2int(scipy.__version__) < _version2int(scipy_requirement):; print(""QuTiP warning: old version of scipy detected "" +; (""(%s), requiring %s."" %; (scipy.__version__, scipy_requirement))); except:; warnings.warn(""scipy not found.""). # -----------------------------------------------------------------------------; # check to see if running from install directory for released versions.; #; top_path = os.path.dirname(os.path.dirname(__file__)); try:; setup_file = open(top_path + '/setup.py', 'r'); except:; pass; else:; if ('QuTiP' in setup_file.readlines()[1][3:]) and qutip.version.release:; print(""You are in the installation directory. "" +; ""Change directories before running QuTiP.""); setup_file.close(). del top_path. # --------------------------------------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip.html:4654,detect,detected,4654,docs/3.1.0/modules/qutip.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html,1,['detect'],['detected']
Safety,"ho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. [docs]def entropy_relative(rho, sigma, base=e, sparse=False, tol=1e-12):; """"""; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`qutip.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`qutip.Qobj`; Second density matrix (or ket which will be converted to a density; matrix).; base : {e,2}; Base of logarithm. Defaults to e.; sparse : bool; Flag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False.; tol : float; Tolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns; -------; rel_ent : float; Value of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho.isket:; rho = ket2dm(rho); if sigma.isket:; sigma = ket2dm(sigma); if not rho.isoper or not sigma.isoper:; raise TypeError(""Inputs must be density matrices.""); if rho.dims != sigma.dims:; raise ValueE",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/entropy.html:7056,detect,detect,7056,docs/4.6/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html,4,['detect'],['detect']
Safety,"ho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/entropy.html:2807,avoid,avoid,2807,docs/4.7/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html,2,['avoid'],['avoid']
Safety,"hod for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting ``sc_ops``. *not tested*. - Order 0.5; - Code: ``'euler-maruyama'``, ``'euler'`` or ``0.5``. milstein; An order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]_. - Order strong 1.0; - Code: ``'milstein'`` or ``1.0``. milstein-imp; An order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. - Order strong 1.0; - Code: ``'milstein-imp'``. predictor-corrector; Generalization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]_. - Order strong 0.5, weak 1.0; - Codes to only correct the stochastic part (:math:`\\alpha=0`,; :math:`\\eta=1/2`): ``'pred-corr'``, ``'predictor-corrector'`` or; ``'pc-euler'``; - Codes to correct both the stochastic and deterministic parts; (:math:`\\alpha=1/2`, :math:`\\eta=1/2`): ``'pc-euler-imp'``,; ``'pc-euler-2'`` or ``'pred-corr-2'``. platen; Explicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; :func:`~general_stochastic`. See eq. (7.47) of chapter 7 of [2]_. - Order strong 1.0, weak 2.0; - Code: ``'platen'``, ``'platen1'`` or ``'explicit1'``. rouchon; Scheme keeping the positivity of the density matrix; (:obj:`~smesolve` only). See eq. (4) with :math:`\\eta=1` of [3]_. - Order strong 1.0?; - Code: ``'rouchon'`` or ``'Rouchon'``. taylor1.5; Order 1.5 strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for :obj:`~smesolve` and; :obj:`~ssesolve`. See eq. (4.6) of chapter 10.4 of [1]_. - Order strong 1.5; - Code: ``'taylor1.5",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:4426,predict,predictor-corrector,4426,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,4,['predict'],['predictor-corrector']
Safety,"ht law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;; to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcate or otherwise identify that changes were made to; the original Work. For example, a translation could be marked “The; original work was translated from English to Spanish,” or a modification; could indicate “The original work has been modified.”;; to Distribute and Publicly Perform the Work including as incorporated in; Collections; and,; to Distribute and Publicly Perform Adaptations. For the avoidance of doubt:. Non-waivable Compulsory License Schemes. In those jurisdictions in; which the right to collect royalties through any statutory or; compulsory licensing scheme cannot be waived, the Licensor reserves; the exclusive right to collect such royalties for any exercise by You; of the rights granted under this License;; Waivable Compulsory License Schemes. In those jurisdictions in which; the right to collect royalties through any statutory or compulsory; licensing scheme can be waived, the Licensor waives the exclusive; right to collect such royalties for any exercise by You of the; rights granted under this License; and,; Voluntary License Schemes. The Licensor waives the right to collect; royalties, whether individually or, in the event that the Licensor; is a member of a collecting society that administers voluntary; licensing schemes, via that society, from any exercise by You of; the rights granted under this License. The above rights may be exercised in all media and form",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/copyright-1.html:7677,avoid,avoidance,7677,docs/4.7/copyright-1.html,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html,2,['avoid'],['avoidance']
Safety,"ients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)). if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs,; self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs. [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats; """"""; return self.coeffs.ravel().tolist(). [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the; # main optmisation call sequence; self.set_coeffs(param_vals). def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]). def init_guess_pulse(self):. self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)). def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse. def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse. def _init_bounds(self):; add_guess_pulse_scale = False; if self.l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:31718,avoid,avoided,31718,docs/4.6/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html,4,['avoid'],['avoided']
Safety,"iff_prop now _compute_diff_prop; compute_prop_grad now _compute_prop_grad. tslotcomp functions. get_timeslot_for_fidelity_calc now _get_timeslot_for_fidelity_calc. Miscellaneous. QuTiP Travis CI tests now use the Anaconda distribution.; The about box and ipynb version_table now display addition system information.; Updated Cython cleanup to remove depreciation warning in sysconfig.; Updated ipynb_parallel to look for ipyparallel module in V4 of the notebooks. Bug Fixes¶. Fixes for countstat and psuedo-inverse functions; Fixed Qobj division tests on 32-bit systems.; Removed extra call to Python in time-dependent Cython code.; Fixed issue with repeated Bloch sphere saving.; Fixed T_0 triplet state not normalized properly. (Fixed by Eric Hontz); Simplified compiler flags (support for ARM systems).; Fixed a decoding error in qload.; Fixed issue using complex.h math and np.kind_t variables.; Corrected output states mismatch for ntraj=1 in the mcf90 solver.; Qobj data is now copied by default to avoid a bug in multiplication. (Fixed by Richard Brierley); Fixed bug overwriting hardware_info in __init__. (Fixed by Johannes Feist); Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; Fixed integer depreciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015):¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; S",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/changelog.html:12405,avoid,avoid,12405,docs/4.4/changelog.html,https://qutip.org,https://qutip.org/docs/4.4/changelog.html,2,['avoid'],['avoid']
Safety,"iff_prop now _compute_diff_prop; compute_prop_grad now _compute_prop_grad. tslotcomp functions. get_timeslot_for_fidelity_calc now _get_timeslot_for_fidelity_calc. Miscellaneous. QuTiP Travis CI tests now use the Anaconda distribution.; The about box and ipynb version_table now display addition system information.; Updated Cython cleanup to remove depreciation warning in sysconfig.; Updated ipynb_parallel to look for ipyparallel module in V4 of the notebooks. Bug Fixes¶. Fixes for countstat and psuedo-inverse functions; Fixed Qobj division tests on 32-bit systems.; Removed extra call to Python in time-dependent Cython code.; Fixed issue with repeated Bloch sphere saving.; Fixed T_0 triplet state not normalized properly. (Fixed by Eric Hontz); Simplified compiler flags (support for ARM systems).; Fixed a decoding error in qload.; Fixed issue using complex.h math and np.kind_t variables.; Corrected output states mismatch for ntraj=1 in the mcf90 solver.; Qobj data is now copied by default to avoid a bug in multiplication. (Fixed by Richard Brierley); Fixed bug overwriting hardware_info in __init__. (Fixed by Johannes Feist); Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; Fixed integer depreciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; St",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:33256,avoid,avoid,33256,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['avoid'],['avoid']
Safety,"iff_prop now _compute_diff_prop; compute_prop_grad now _compute_prop_grad. tslotcomp functions; get_timeslot_for_fidelity_calc now _get_timeslot_for_fidelity_calc. Miscellaneous. QuTiP Travis CI tests now use the Anaconda distribution.; The about box and ipynb version_table now display addition system information.; Updated Cython cleanup to remove depreciation warning in sysconfig.; Updated ipynb_parallel to look for ipyparallel module in V4 of the notebooks. Bug Fixes¶. Fixes for countstat and psuedo-inverse functions; Fixed Qobj division tests on 32-bit systems.; Removed extra call to Python in time-dependent Cython code.; Fixed issue with repeated Bloch sphere saving.; Fixed T_0 triplet state not normalized properly. (Fixed by Eric Hontz); Simplified compiler flags (support for ARM systems).; Fixed a decoding error in qload.; Fixed issue using complex.h math and np.kind_t variables.; Corrected output states mismatch for ntraj=1 in the mcf90 solver.; Qobj data is now copied by default to avoid a bug in multiplication. (Fixed by Richard Brierley); Fixed bug overwriting hardware_info in __init__. (Fixed by Johannes Feist); Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; Fixed integer depreciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015):¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; S",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:6929,avoid,avoid,6929,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,4,['avoid'],['avoid']
Safety,"ight) \psi(t) dW_n,\]; where \(H\) is the Hamiltonian, \(S_n\) are the stochastic collapse operators, and \(e_n\) is. (3)¶\[e_n = \left<\psi(t)|S_n + S_n^\dagger|\psi(t)\right>\]; In QuTiP, this equation can be solved using the function qutip.stochastic.ssesolve, which is implemented by defining \(d_1\) and \(d_{2,n}\) from Equation (1) as. (4)¶\[d_1 = -iH - \frac{1}{2} \sum_n \left(S_n^\dagger S_n - e_n S_n + \frac{e_i^2}{4} \right),\]; and. (5)¶\[d_{2, n} = S_n - \frac{e_n}{2}.\]; The solver qutip.stochastic.ssesolve will construct the operators \(d_1\) and \(d_{2,n}\) once the user passes the Hamiltonian (H) and the stochastic operator list (sc_ops). As with the qutip.mcsolve, the number of trajectories and the seed for the noise realisation can be fixed using the arguments: ntraj and noise, respectively. If the user also requires the measurement output, the argument store_measurement=True should be included.; Additionally, homodyne and heterodyne detections can be easily simulated by passing the arguments method='homodyne' or method='heterodyne' to qutip.stochastic.ssesolve.; Examples of how to solve the stochastic Schrodinger equation using QuTiP can be found in this development notebook. Stochastic Master Equation¶; When the initial state of the system is a density matrix \(\rho\), the stochastic master equation solver qutip.stochastic.smesolve must be used. The stochastic master equation is given by (see section 4.4, [Wis09]). (6)¶\[ d \rho (t) = -i[H, \rho(t)] dt + D[A]\rho(t) dt + \mathcal{H}[A]\rho dW(t)\]; where. (7)¶\[D[A] \rho = \frac{1}{2} \left[2 A \rho A^\dagger; - \rho A^\dagger A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:3273,detect,detections,3273,docs/4.6/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html,4,['detect'],['detections']
Safety,"ill violate our line-length reporting if we do that.; """"""; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions. Notes; -----; Available solvers for :obj:`~ssesolve` and :obj:`~smesolve`; euler-maruyama; A simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting ``sc_ops``. *not tested*. - Order 0.5; - Code: ``'euler-maruyama'``, ``'euler'`` or ``0.5``. milstein; An order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]_. - Order strong 1.0; - Code: ``'milstein'`` or ``1.0``. milstein-imp; An order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. - Order strong 1.0; - Code: ``'milstein-imp'``. predictor-corrector; Generalization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]_. - Order strong 0.5, weak 1.0; - Codes to only correct the stochastic part (:math:`\\alpha=0`,; :math:`\\eta=1/2`): ``'pred-corr'``, ``'predictor-corrector'`` or; ``'pc-euler'``; - Codes to correct both the stochastic and deterministic parts; (:math:`\\alpha=1/2`, :math:`\\eta=1/2`): ``'pc-euler-imp'``,; ``'pc-euler-2'`` or ``'pred-corr-2'``. platen; Explicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; :func:`~general_stochastic`. See eq. (7.47) of chapter 7 of [2]_. - Order strong 1.0, weak 2.0; - Code: ``'platen'``, ``'platen1'`` or ``'explicit1'``. rouchon; Scheme keeping the positivity of the density matrix; (:obj:`~smesolve` only). See eq. (4) with :math:`\\",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:4115,predict,predictor-corrector,4115,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,4,['predict'],['predictor-corrector']
Safety,"interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained.; Here psi0 is the initial value used for tests before the evolution begins.; qutip.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.23s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.39s. Est. time left: 00:00:00:01; 30.0%. Run time: 0.54s. Est. time left: 00:00:00:01; 40.0%. Run time: 0.71s. Est. time left: 00:00:00:01; 50.0%. Run time: 0.85s. Est. time left: 00:00:00:00; 60.0%. Run time: 0.97s. Est. time left: 00:00:00:00; 70.0%. Run time: 1.12s. Est. time left: 00:00:00:00; 80.0%. Run time: 1.28s. Est. time left: 00:00:00:00; 90.0%. Run time: 1.46s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:18017,avoid,avoid,18017,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,1,['avoid'],['avoid']
Safety,"interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained.; Here psi0 is the initial value used for tests before the evolution begins.; qutip.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.31s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.59s. Est. time left: 00:00:00:02; 30.0%. Run time: 0.90s. Est. time left: 00:00:00:02; 40.0%. Run time: 1.13s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.38s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.62s. Est. time left: 00:00:00:01; 70.0%. Run time: 1.84s. Est. time left: 00:00:00:00; 80.0%. Run time: 2.07s. Est. time left: 00:00:00:00; 90.0%. Run time: 2.33s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html:17597,avoid,avoid,17597,docs/4.5/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html,1,['avoid'],['avoid']
Safety,"ion(""Invalid H type""). func, ode_args = ss.makefunc(ss, rho0, args, e_ops, options). if _safe_mode:; # This is to test safety of the function before starting the loop.; v = rho0.full().ravel('F'); func(0., v, *ode_args) + v. res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; progress_bar, dims=rho0.dims); res.num_collapse = len(c_ops). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #_mesolve_QobjEvo(H, c_ops, tlist, args, options); def _mesolve_QobjEvo(H, c_ops, tlist, args, opt):; """"""; Prepare the system for the solver, H can be an QobjEvo.; """"""; H_td = QobjEvo(H, args, tlist=tlist); if not issuper(H_td.cte):; L_td = liouvillian(H_td); else:; L_td = H_td; for op in c_ops:; # We want to avoid passing tlist where it isn't necessary, to allow a; # Hamiltonian/Liouvillian which already _has_ time-dependence not equal; # to the mesolve evaluation times to be used in conjunction with; # time-independent c_ops. If we _always_ pass it, it may appear to; # QobjEvo that there is a tlist mismatch, even though it is not used.; if isinstance(op, Qobj):; op_td = QobjEvo(op); elif isinstance(op, QobjEvo):; op_td = QobjEvo(op, args); else:; op_td = QobjEvo(op, args, tlist=tlist); if not issuper(op_td.cte):; op_td = lindblad_dissipator(op_td); L_td += op_td. if opt.rhs_with_state:; L_td._check_old_with_state(). nthread = opt.openmp_threads if opt.use_openmp else 0; L_td.compile(omp=nthread). ss = SolverSystem(); ss.H = L_td; ss.makefunc = _qobjevo_set; solver_safe[""mesolve""] = ss; return ss. def _test_liouvillian_dimensions(L_dims, rho_dims):; """"""; Raise ValueError if the dimensions of the Liouvillian and the density; matrix or superoperator state are incompatible with the master equation.; """"""; if L_dims[0] != L_dims[1]:; raise ValueError(""Liouvillia",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/mesolve.html:11283,avoid,avoid,11283,docs/4.6/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html,4,['avoid'],['avoid']
Safety,"ional Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Homodyne detection. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-dynamics.html:1590,detect,detection,1590,docs/4.5/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-dynamics.html,1,['detect'],['detection']
Safety,"ional-order switched systems and its digital implementation"", ; International Journal of Electronics and Communications (2017). 297. Yoshihara et al., ""Characteristic spectra of circuit quantum electrodynamics systems from the ultrastrong- to the deep-strong-coupling regime"", ; Phys. Rev. A 95, 053824 (2017). 296. Endo et al., ""Dynamics of an ultra-strongly-coupled system interacting with a driven nonlinear resonator"", ; arXiv:1705.08688. 295. Venkatesh et al., ""Cooperative Effects in Closely Packed Quantum Emitters with Collective Dephasing"", ; Phys. Rev. Lett. 120, 033602 (2018). 294. Snijders et al., ""A fiber coupled cavity QED source of identical single photons"", ; arXiv:1705.05876. 293. Zanker et al., ""Analyzing the spectral density of a perturbed analog quantum simulator using Keldysh formalism"", ; arXiv:1705.02325. 292. Csurgay et al., ""Toward engineering design of quantum circuits"", ; Int. J. Circ. Theor. Appl. (2017). 291. Megyeri et al., ""Why material slow light does not improve cavity-enhanced atom detection"", ; J. Mod. Phys. (2017). 290. Huembeli et al., ""Towards a heralded eigenstate-preserving measurement of multi-qubit parity in circuit QED"", ; Phys. Rev. A 96, 012313 (2017). 289. Shammah et al., ""Superradiance with local phase-breaking effects"", ; Phys. Rev. A 96, 023863 (2017). 288. Arenz et al., ""The roles of drift and control field constraints upon quantum control speed limits"", ; New J. Phys. 19, 103015 (2017). 287. Leroux et al., ""Simple variational ground state and pure-cat-state generation in the quantum Rabi model"", ; Phys. Rev. A 96, 043834 (2017). 286. Laflamme et al., ""Continuous measurement of an atomic current"", ; Phys. Rev. A 95, 043843 (2017). 285. de Assis et al., ""Negative response with an optical cavity and traveling wave fields"", ; Phys. Rev. A 96, 013821 (2017). 284. Gough, ""The Tyranny of Qubits - Quantum Technology's Scalability Bottleneck"", ; arXiv:1703.05342. 283. Hamsen et al., ""Two-Photon Blockade in an Atom-Driven Cavity QED",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:10708,detect,detection,10708,users.html,https://qutip.org,https://qutip.org/users.html,1,['detect'],['detection']
Safety,"is; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of ; ``task(value, *task_args, **task_kwargs)`` for ; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/parallel.html:8052,timeout,timeout,8052,docs/4.4/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/parallel.html,1,['timeout'],['timeout']
Safety,"isinstance(H, list) and isinstance(H[0], Qobj) and; issuper(H[0])); or (not isinstance(H, (Qobj, QobjEvo)) and callable(H) and; not options.rhs_with_state and issuper(H(0., args))); or (not isinstance(H, (Qobj, QobjEvo)) and callable(H) and; options.rhs_with_state)). if not use_mesolve:; return sesolve(H, rho0, tlist, e_ops=e_ops, args=args, options=options,; progress_bar=progress_bar, _safe_mode=_safe_mode). if isket(rho0):; rho0 = ket2dm(rho0); if (not (rho0.isoper or rho0.issuper)) or (rho0.dims[0] != rho0.dims[1]):; raise ValueError(; ""input state must be a pure state vector, square density matrix, ""; ""or superoperator""; ). if isinstance(H, SolverSystem):; ss = H; elif isinstance(H, (list, Qobj, QobjEvo)):; ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); elif callable(H):; ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options); else:; raise Exception(""Invalid H type""). func, ode_args = ss.makefunc(ss, rho0, args, e_ops, options). if _safe_mode:; # This is to test safety of the function before starting the loop.; v = rho0.full().ravel('F'); func(0., v, *ode_args) + v. res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; progress_bar, dims=rho0.dims); res.num_collapse = len(c_ops). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #_mesolve_QobjEvo(H, c_ops, tlist, args, options); def _mesolve_QobjEvo(H, c_ops, tlist, args, opt):; """"""; Prepare the system for the solver, H can be an QobjEvo.; """"""; H_td = QobjEvo(H, args, tlist=tlist); if not issuper(H_td.cte):; L_td = liouvillian(H_td); else:; L_td = H_td; for op in c_ops:; # We want to avoid passing tlist where it isn't necessary, to allow a; # Hamiltonian/Liouvillian which already _has_ time-dependence not equal; # to the mesolve evaluation times to be used in conjunction with",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/mesolve.html:10471,safe,safety,10471,docs/4.6/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html,4,['safe'],['safety']
Safety,"isplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array of qobjs representing commuting Hermitian; operators. evalsbool [True]Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tolfloat [1e-14]Tolerance for detecting degenerate eigenstates. safe_modebool [True]Whether to check that all ops are Hermitian and commuting. If set to; False and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns. eigstupleTuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:268536,detect,detecting,268536,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['detect'],['detecting']
Safety,"iter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:40347,safe,safe,40347,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,3,['safe'],['safe']
Safety,"iter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print('WARNING: Ground state may be degenerate. Use Q.eigenstates()'); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Retu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:40141,safe,safe,40141,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['safe'],['safe']
Safety,"ix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; qutip.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Running String-Based Time-Dependent Prob",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:18186,avoid,avoid,18186,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,2,['avoid'],['avoid']
Safety,"jump; r_jump, r_op = prng.rand(2). # deterministic evolution wihtout correction for norm decay; dsigma_t = spmv(L.data, sigma_t) * dt. # deterministic evolution with correction for norm decay; drho_t = spmv(L.data, rho_t) * dt. rho_t += drho_t. # increment density matrices; sigma_t += dsigma_t; rho_t += drho_t. return states_list, jump_times, jump_op_idx. # -----------------------------------------------------------------------------; # Helper-functions for stochastic DE; #; # d1 = deterministic part of the contribution to the DE RHS function, to be; # multiplied by the increament dt; #; # d1 = stochastic part of the contribution to the DE RHS function, to be; # multiplied by the increament dW; #. #; # For SSE; #. # Function sigurature:; #; # def d(A, psi):; #; # psi = wave function at the current time step; #; # A[0] = c; # A[1] = c + c.dag(); # A[2] = c - c.dag(); # A[3] = c.dag() * c; #; # where c is a collapse operator. The combinations of c's stored in A are; # precomputed before the time-evolution is started to avoid repeated; # computations. def _generate_psi_A_ops(sc_ops, H):; """"""; pre-compute superoperator operator combinations that are commonly needed; when evaluating the RHS of stochastic schrodinger equations; """""". A_ops = []; for c_idx, c in enumerate(sc_ops):; A_ops.append([c.data,; (c + c.dag()).data,; (c - c.dag()).data,; (c.dag() * c).data]). return A_ops. def d1_psi_homodyne(t, psi, A, args):; """"""; OK; Need to cythonize. .. math::. D_1(C, \psi) = \\frac{1}{2}(\\langle C + C^\\dagger\\rangle\\C psi -; C^\\dagger C\\psi - \\frac{1}{4}\\langle C + C^\\dagger\\rangle^2\\psi). """""". e1 = cy_expect_psi_csr(A[1].data, A[1].indices, A[1].indptr, psi, 0); return 0.5 * (e1 * spmv(A[0], psi) -; spmv(A[3], psi) -; 0.25 * e1 ** 2 * psi). def d2_psi_homodyne(t, psi, A, args):; """"""; OK; Need to cythonize. .. math::. D_2(\psi, t) = (C - \\frac{1}{2}\\langle C + C^\\dagger\\rangle)\\psi. """""". e1 = cy_expect_psi_csr(A[1].data, A[1].indices, A[1].indptr, psi, 0); retur",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:37108,avoid,avoid,37108,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,4,['avoid'],['avoid']
Safety,"jump; r_jump, r_op = prng.rand(2). # deterministic evolution wihtout correction for norm decay; dsigma_t = spmv(L.data, sigma_t) * dt. # deterministic evolution with correction for norm decay; drho_t = spmv(L.data, rho_t) * dt. rho_t += drho_t. # increment density matrices; sigma_t += dsigma_t; rho_t += drho_t. return states_list, jump_times, jump_op_idx. # -----------------------------------------------------------------------------; # Helper-functions for stochastic DE; #; # d1 = deterministic part of the contribution to the DE RHS function, to be; # multiplied by the increament dt; #; # d1 = stochastic part of the contribution to the DE RHS function, to be; # multiplied by the increament dW; #. #; # For SSE; #. # Function sigurature:; #; # def d(A, psi):; #; # psi = wave function at the current time step; #; # A[0] = c; # A[1] = c + c.dag(); # A[2] = c - c.dag(); # A[3] = c.dag() * c; #; # where c is a collapse operator. The combinations of c's stored in A are; # precomputed before the time-evolution is started to avoid repeated; # computations. def _generate_psi_A_ops(sc_ops, H):; """"""; pre-compute superoperator operator combinations that are commonly needed; when evaluating the RHS of stochastic schrodinger equations; """""". A_ops = []; for c_idx, c in enumerate(sc_ops):; A_ops.append([c.data,; (c + c.dag()).data,; (c - c.dag()).data,; (c.dag() * c).data]). return A_ops. def d1_psi_homodyne(t, psi, A, args):; """"""; OK; Todo: cythonize. .. math::. D_1(C, \psi) = \\frac{1}{2}(\\langle C + C^\\dagger\\rangle\\C psi -; C^\\dagger C\\psi - \\frac{1}{4}\\langle C + C^\\dagger\\rangle^2\\psi). """""". e1 = cy_expect_psi_csr(A[1].data, A[1].indices, A[1].indptr, psi, 0); return 0.5 * (e1 * spmv(A[0], psi) -; spmv(A[3], psi) -; 0.25 * e1 ** 2 * psi). def d2_psi_homodyne(t, psi, A, args):; """"""; OK; Todo: cythonize. .. math::. D_2(\psi, t) = (C - \\frac{1}{2}\\langle C + C^\\dagger\\rangle)\\psi. """""". e1 = cy_expect_psi_csr(A[1].data, A[1].indices, A[1].indptr, psi, 0); return [s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:36066,avoid,avoid,36066,docs/3.1.0/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html,1,['avoid'],['avoid']
Safety,"l equations.; Only solver which could take non-commuting sc_ops. *not tested*; -Order 0.5; -Code: 'euler-maruyama', 'euler', 0.5. milstein, Order 1.0 strong Taylor scheme:; Better approximate numerical solution to stochastic; differential equations.; -Order strong 1.0; -Code: 'milstein', 1.0; Numerical Solution of Stochastic Differential Equations; Chapter 10.3 Eq. (3.1), By Peter E. Kloeden, Eckhard Platen. milstein-imp, Order 1.0 implicit strong Taylor scheme:; Implicit milstein scheme for the numerical simulation of stiff; stochastic differential equations.; -Order strong 1.0; -Code: 'milstein-imp'; Numerical Solution of Stochastic Differential Equations; Chapter 12.2 Eq. (2.9), By Peter E. Kloeden, Eckhard Platen. predictor-corrector:; Generalization of the trapezoidal method to stochastic; differential equations. More stable than explicit methods.; -Order strong 0.5, weak 1.0; Only the stochastic part is corrected.; (alpha = 0, eta = 1/2); -Code: 'pred-corr', 'predictor-corrector', 'pc-euler'; Both the deterministic and stochastic part corrected.; (alpha = 1/2, eta = 1/2); -Code: 'pc-euler-imp', 'pc-euler-2', 'pred-corr-2'; Numerical Solution of Stochastic Differential Equations; Chapter 15.5 Eq. (5.4), By Peter E. Kloeden, Eckhard Platen. platen:; Explicit scheme, create the milstein using finite difference instead of; derivatives. Also contain some higher order terms, thus converge better; than milstein while staying strong order 1.0.; Do not require derivatives, therefore usable for; :func:`qutip.stochastic.general_stochastic`; -Order strong 1.0, weak 2.0; -Code: 'platen', 'platen1', 'explicit1'; The Theory of Open Quantum Systems; Chapter 7 Eq. (7.47), H.-P Breuer, F. Petruccione. rouchon:; Scheme keeping the positivity of the density matrix. (smesolve only); -Order strong 1.0?; -Code: 'rouchon', 'Rouchon'; Eq. 4 of arXiv:1410.5345 with eta=1; Efficient Quantum Filtering for Quantum Feedback Control; Pierre Rouchon, Jason F. Ralph; arXiv:1410.5345 [quant-ph",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:4053,predict,predictor-corrector,4053,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,2,['predict'],['predictor-corrector']
Safety,"l, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:15469,avoid,avoid,15469,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,4,['avoid'],['avoid']
Safety,"left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). For other examples on qutip.stochastic.smesolve, see the following notebook, as well as these notebooks available at QuTiP Tutorials page: heterodyne detection, inneficient detection, and feedback control. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:6539,detect,detection,6539,docs/4.7/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html,5,"['Detect', 'detect']","['Detection', 'detection']"
Safety,"lf.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html:23746,avoid,avoids,23746,docs/4.4/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html,1,['avoid'],['avoids']
Safety,"lor1.5-imp'; elif self.solver in ['taylor2.0', 'taylor20', 2.0, 202]:; self.solver_code = 202; self.solver = 'taylor2.0'; if not len(self.sc_ops) == 1 or \; not self.sc_ops[0].const or \; not self.method == ""homodyne"":; raise ValueError(; ""Taylor2.0 only works with 1 constant sc_ops and for""; "" homodyne method""; ); else:; known = [; None, 'euler-maruyama', 'platen', 'pc-euler', 'pc-euler-imp',; 'milstein', 'milstein-imp', 'rouchon', 'taylor1.5',; 'taylor1.5-imp', 'explicit1.5', 'taylor2.0',; ]; raise ValueError(""The solver should be one of {!r}"".format(known)). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:18400,predict,predictor-corrector,18400,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,4,['predict'],['predictor-corrector']
Safety,"lse). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q – A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Return type:Qobj. Notes; Experimental. full(squeeze=False)[source]¶; Dense array from quantum object. Returns:data – Array of complex data from quantum objects data attribute. Return type:array. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:; sparse (bool) – Use sparse Eigensolver; tol (float) – Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used).; safe (bool (default=True)) – Check for degenerate ground state. Returns:; eigval (float) – Eigenvalue for the ground state of quantum operator.; eigvec (qobj) – Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra (qobj) – Quantum object of type ‘bra’.; ket (qobj) – Quantum object of type ‘ket’. Returns:elem – Complex valued matrix element. Return type:complex. Raises:TypeError – Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:; norm (str) – Which norm to use for ket/br",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:10424,safe,safe,10424,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['safe'],['safe']
Safety,"lue of the args dictionary passed into the; constructor. dynamics_argslistNames of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstrA string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obtain a list of all the coefficients at a particular; time. coeff_fileslistRuntime created files to delete with the instance. dummy_cteboolIs self.cte an empty Qobj. constboolIndicates if quantum object is constant. type{“cte”, “string”, “func”, “array”, “spline”, “mixed_callable”, “mixed_compilable”}Information about the type of coefficients used in the entire object. num_objintNumber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:22867,safe,safePickleboolFlag,22867,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['safe'],['safePickleboolFlag']
Safety,"lver = 'taylor1.5-imp'; elif self.solver in ['taylor2.0', 'taylor20', 2.0, 202]:; self.solver_code = 202; self.solver = 'taylor2.0'; if not len(self.sc_ops) == 1 or \; not self.sc_ops[0].const or \; not self.method == ""homodyne"":; raise Exception(""Taylor2.0 only work with 1 constant sc_ops "" +; ""and for homodyne method""); else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler-maruyama', 'platen', 'pc-euler', "" +; ""'pc-euler-imp', 'milstein', 'milstein-imp', "" +; ""'rouchon', "" +; ""'taylor1.5', 'taylor1.5-imp', 'explicit1.5' "" +; ""'taylor2.0']""). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:17791,predict,predictor-corrector,17791,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,1,['predict'],['predictor-corrector']
Safety,"magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting dynamics.oper_dtype = <type>; Note this can be done by passing dyn_params={'oper_dtype':<type>} in any of the pulseoptim functions.; Some other properties and methods were renamed at the same time. A full list is given here. All modules; - function: set_log_level -> property: log_level; dynamics functions. _init_lists now _init_evo; get_num_ctrls now property: num_ctrls; get_owd_evo_target now property: onto_evo_target; combine_dyn_gen now _combine_dyn_gen (no longer returns a value); get_dyn_gen now _get_phased_dyn_gen; get_ctrl_den_gen now _get_phased_ctrl_dyn_gen; ensure_decom",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/changelog.html:9960,avoid,avoided,9960,docs/4.4/changelog.html,https://qutip.org,https://qutip.org/docs/4.4/changelog.html,4,['avoid'],['avoided']
Safety,"magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting dynamics.oper_dtype = <type>; Note this can be done by passing dyn_params={'oper_dtype':<type>} in any of the pulseoptim functions.; Some other properties and methods were renamed at the same time. A full list is given here. All modules; - function: set_log_level -> property: log_level; dynamics functions; _init_lists now _init_evo; get_num_ctrls now property: num_ctrls; get_owd_evo_target now property: onto_evo_target; combine_dyn_gen now _combine_dyn_gen (no longer returns a value); get_dyn_gen now _get_phased_dyn_gen; get_ctrl_den_gen now _get_phased_ctrl_dyn_gen; ensure_decom",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:4484,avoid,avoided,4484,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,4,['avoid'],['avoided']
Safety,"mand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:43413,safe,safe,43413,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,2,['safe'],['safe']
Safety,"mand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:46247,safe,safe,46247,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,4,['safe'],['safe']
Safety,"mapping of `values` to the function `task`. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of ; ``task(value, *task_args, **task_kwargs)`` for ; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/parallel.html:8056,timeout,timeout,8056,docs/4.2/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/parallel.html,1,['timeout'],['timeout']
Safety,"mapping of `values` to the function `task`. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of ; ``task(value, *task_args, **task_kwargs)`` for ; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/parallel.html:8056,timeout,timeout,8056,docs/4.1/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/parallel.html,1,['timeout'],['timeout']
Safety,"mes of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the ``args`` parameter. tlist : array_like; List of times at which the numpy-array coefficients are applied. compiled : str; A string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevo : ``CQobjCte`` or ``CQobjEvoTd``; Cython version of the QobjEvo. coeff_get : callable; Object called to obtain a list of all the coefficients at a particular; time. coeff_files : list; Runtime created files to delete with the instance. dummy_cte : bool; Is self.cte an empty Qobj. const : bool; Indicates if quantum object is constant. type : {""cte"", ""string"", ""func"", ""array"", ""spline"", ""mixed_callable"", \; ""mixed_compilable""}; Information about the type of coefficients used in the entire object. num_obj : int; Number of :obj:`~Qobj` in the QobjEvo. use_cython : bool; Flag to compile string to Cython or Python. safePickle : bool; Flag to not share pointers between thread.; """""". def __init__(self, Q_object=[], args={}, copy=True,; tlist=None, state0=None, e_ops=[]):; if isinstance(Q_object, QobjEvo):; if copy:; self._inplace_copy(Q_object); else:; self.__dict__ = Q_object.__dict__; if args:; self.arguments(args); for i, dargs in enumerate(self.dynamics_args):; e_int = dargs[1] == ""expect"" and isinstance(dargs[2], int); if e_ops and e_int:; self.dynamics_args[i] = (dargs[0], ""expect"",; e_ops[dargs[2]]); if state0 is not None:; self._dynamics_args_update(0., state0); return. self.const = False; self.dummy_cte = False; self.args = args.copy(); self.dynamics_args = []; self.cte = None; self.tlist = np.asarray(tlist) if tlist is not None else None; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.type = ""none""; self.omp = 0; self.coeff_files = []; self.use_cython = use_cython[0]; self.safePickle = safePickle[0]. # Attempt to determine if a 2-element list is a single, time-dependent; # operator, or a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:12764,safe,safePickle,12764,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,2,['safe'],['safePickle']
Safety,"ms[1]]). elif isinstance(state, np.ndarray) and state.ndim == 2:; s1 = self.cte.shape[1]; new_l = int(np.sqrt(s1)); for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state.ravel(""F""); elif what == ""mat"":; self.args[name] = state; elif what == ""expect"":; self.args[name] = op.expect(t, state); elif state.shape[1] == 1:; self.args[name] = Qobj(state, dims=[self.cte.dims[1],[1]]); elif state.shape[1] == s1:; self.args[name] = Qobj(state, dims=self.cte.dims); else:; self.args[name] = Qobj(state). else:; raise TypeError(""state must be a Qobj or np.ndarray""). def copy(self):; new = QobjEvo(self.cte.copy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). def arguments(self, new_args):; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:21465,safe,safePickle,21465,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"n case of; # commuting jump operators.; d2_vec2 = np.array([[spmv(M[n], d2_vec[m]); for m in range(A_len)] for n in range(A_len)]); e2 = np.array([[cy_expect_rho_vec(M[n], d2_vec[m], 0); for m in range(A_len)] for n in range(A_len)]). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += d1_vec * dt; drho_t += np.sum([(d2_vec[n] - e1[n] * rho_t) * dW[n, 0]; for n in range(A_len)], axis=0); drho_t += 0.5 * np.sum(; [(d2_vec2[n, n] - 2.0 * e1[n] * d2_vec[n] +; (-e2[n, n] + 2.0 * e1[n] * e1[n]) * rho_t) * (dW[n, 0]*dW[n, 0] - dt); for n in range(A_len)], axis=0). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; drho_t += 0.5 * np.sum(; [(d2_vec2[n, m] - e1[m] * d2_vec[n] - e1[n] * d2_vec[m] +; (-e2[n, m] + 2.0 * e1[n] * e1[m]) * rho_t) * (dW[n, 0] * dW[m, 0]); for (n, m) in np.ndindex(A_len, A_len) if n != m], axis=0). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_single_fast(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; fast Milstein for homodyne detection with 1 stochastic operator; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homod",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:52530,detect,detection,52530,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,4,['detect'],['detection']
Safety,"n of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence.; Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:26586,safe,safety,26586,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['safe'],['safety']
Safety,"n the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array of qobjs representing commuting Hermitian; operators. evalsbool [True]Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tolfloat [1e-14]Tolerance for detecting degenerate eigenstates. safe_modebool [True]Whether to check that all ops are Hermitian and commuting. If set to; False and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns. eigstupleTuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:256335,detect,detecting,256335,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['detect'],['detecting']
Safety,"n, A_len) if n != m], axis=0). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_single_fast(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; fast Milstein for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with >2 stochastic operators; """"""; dW = ddW[:, 0]; sc_len = len(A); sc2_len = 2 * sc_len. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(d_vec[:-1].reshape(; -1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[sc2_len:-1] -= np.array(; [e[m] * d_vec[n] + e[n] * d_vec[m]; for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). e[sc_len:sc2_len] -= 2.0 * e[:sc_len] * e[:sc_len]; e[sc2_len:] -= 2.0 * np.array(; [e[n] * e[m] for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[:sc_len] -= 2.0 * e[:sc_len] * dW[sc_len:sc2_len]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:50198,detect,detection,50198,docs/3.1.0/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html,1,['detect'],['detection']
Safety,"n. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.superoperator. Source code for qutip.superoperator; __all__ = ['liouvillian', 'liouvillian_ref', 'lindblad_dissipator',; 'operator_to_vector', 'vector_to_operator', 'mat2vec', 'vec2mat',; 'vec2mat_index', 'mat2vec_index', 'spost', 'spre', 'sprepost']. import scipy.sparse as sp; import numpy as np; from qutip.qobj import Qobj; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.sparse import sp_reshape; from qutip.cy.spmath import zcsr_kron; from functools import partial. [docs]def liouvillian(H, c_ops=[], data_only=False, chi=None):; """"""Assembles the Liouvillian superoperator from a Hamiltonian; and a ``list`` of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters; ----------; H : Qobj or QobjEvo; System Hamiltonian. c_ops : array_like of Qobj or QobjEvo; A ``list`` or ``array`` of collapse operators. Returns; -------; L : Qobj or QobjEvo; Liouvillian superoperator. """"""; if isinstance(c_ops, (Qobj, QobjEvo)):; c_ops = [c_ops]; if chi and len(chi) != len(c_ops):; raise ValueError('chi must be a list with same length as c_ops'). h = None; if H is not None:; if isinstance(H, QobjEvo):; h = H.cte; else:; h = H; if h.isoper:; op_dims = h.dims; op_shape = h.shape; elif h.issuper:; op_dims = h.dims[0]; op_shape = [np.prod(op_dims[0]), np.prod(op_dims[0])]; else:; raise TypeError(""Invalid type for Hamiltonian.""); else:; # no hamiltonian given, pick system size from a collapse operator; if isinstance(c_ops, list) and len(c_ops) > 0:; if isinstance(c_ops[0], QobjEvo):; c = c_ops[0].cte; else:; c = c_ops[0]; if c.isoper:; op_dims = c.dims; op_shape = c.shape; elif c.issup",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/superoperator.html:1038,avoid,avoids,1038,docs/4.7/modules/qutip/superoperator.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superoperator.html,2,['avoid'],['avoids']
Safety,"n2, n3, ...)) for a system with dimensions given by dims. Example:. >>> for state in state_number_enumerate([2,2]): # doctest: +SKIP; >>> print(state) # doctest: +SKIP; ( 0 0 ); ( 0 1 ); ( 1 0 ); ( 1 1 ). Parameters; ----------; dims : list or array; The quantum state dimensions array, as it would appear in a Qobj. excitations : integer (None); Restrict state space to states with excitation numbers below or; equal to this value. Returns; -------; state_number : tuple; Successive state number tuples that can be used in loops and other; iterations, using standard state enumeration *by definition*. """""". if excitations is None:; # in this case, state numbers are a direct product; yield from itertools.product(*(range(d) for d in dims)); return. # From here on, excitations is not None. # General idea of algorithm: add excitations one by one in last mode (idx =; # len(dims)-1), and carry over to the next index when the limit is reached.; # Keep track of the number of excitations while doing so to avoid having to; # do explicit sums over the states.; state = (0,)*len(dims); nexc = 0; while True:; yield state; idx = len(dims) - 1; state = state[:idx] + (state[idx]+1,); nexc += 1; while nexc > excitations or state[idx] >= dims[idx]:; # remove all excitations in mode idx, add one in idx-1; idx -= 1; if idx < 0:; return; nexc -= state[idx+1] - 1; state = state[:idx] + (state[idx]+1, 0) + state[idx+2:]. [docs]def state_number_index(dims, state):; """"""; Return the index of a quantum state corresponding to state,; given a system with dimensions given by dims. Example:. >>> state_number_index([2, 2, 2], [1, 1, 0]); 6. Parameters; ----------; dims : list or array; The quantum state dimensions array, as it would appear in a Qobj. state : list; State number array. Returns; -------; idx : int; The index of the state given by `state` in standard enumeration; ordering. """"""; return np.ravel_multi_index(state, dims). [docs]def state_index_number(dims, index):; """"""; Return a quantum number r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/states.html:19814,avoid,avoid,19814,docs/4.7/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/states.html,2,['avoid'],['avoid']
Safety,"nalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; """"""; H = self.H[k]; # assuming H is an nxn matrix, find n; n = H.shape[0]; # returns row vector of eigen values,; # columns with the eigenvectors; eig_val, eig_vec = np.linalg.eig(H). # Calculate the propagator in the diagonalised basis; eig_val_tau = -1j*eig_val*self.tau[k]; prop_eig = np.exp(eig_val_tau). # Generate the factor matrix through the differences; # between each of the eigenvectors and the exponentiations; # create nxn matrix where each eigen val is repeated n times; # down the columns; o = np.ones([n, n]); eig_val_cols = eig_val_tau*o; # calculate all the differences by subtracting it from its transpose; eig_val_diffs = eig_val_cols - eig_val_cols.T; # repeat for the propagator; prop_eig_cols = prop_eig*o; prop_eig_diffs = prop_eig_cols - prop_eig_cols.T; # the factor matrix is the elementwise quotient of the; # differeneces between the exponentiated eigen vals and the; # differences between the eigen vals; # need to avoid division by zero that would arise due to denegerate; # eigenvalues and the diagonals; degen_mask = np.abs(eig_val_diffs) < self.fact_mat_round_prec; eig_val_diffs[degen_mask] = 1; factors = prop_eig_diffs / eig_val_diffs; # for degenerate eigenvalues the factor is just the exponent; factors[degen_mask] = prop_eig_cols[degen_mask]. # Store eigenvals and eigenvectors for use by other functions, e.g.; # gradient_exact; self.decomp_curr[k] = True; self.prop_eigen[k] = prop_eig; self.dyn_gen_eigenvectors[k] = eig_vec; self.dyn_gen_factormatrix[k] = factors. [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; """""". def reset(self):; Dynamics.reset(self); sel",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:26195,avoid,avoid,26195,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['avoid'],['avoid']
Safety,"nd state.ndim == 2:; s1 = self.cte.shape[1]; new_l = int(np.sqrt(s1)); for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state.ravel(""F""); elif what == ""mat"":; self.args[name] = state; elif what == ""expect"":; self.args[name] = op.expect(t, state); elif state.shape[1] == 1:; self.args[name] = Qobj(state, dims=[self.cte.dims[1], [1]]); elif state.shape[1] == s1:; self.args[name] = Qobj(state, dims=self.cte.dims); else:; self.args[name] = Qobj(state). else:; raise TypeError(""state must be a Qobj or np.ndarray""). [docs] def copy(self):; """"""Return a copy of this object.""""""; new = QobjEvo(self.cte.copy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:20156,safe,safePickle,20156,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,2,['safe'],['safePickle']
Safety,"nential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns:oper : qobj. Exponentiated quantum operator. Raises:TypeError. Quantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters:states_inds : list of integer. The states that should be kept. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(squeeze=False)[source]¶; Dense array from quantum object. Returns:data : array. Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). safe : bool (default=True). Check for degenerate ground state. Returns:eigval : float. Eigenvalue for the ground state of quantum operator. eigvec : qobj. Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex value",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/classes.html:9903,safe,safe,9903,docs/4.1/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/classes.html,1,['safe'],['safe']
Safety,"ntum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters:; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:; q : Qobj; A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters:; order : str {‘C’, ‘F’}; Return array in C (default) or Fortran ordering. squeeze : bool {False, True}; Squeeze output array. Returns:; data : array; Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:; sparse : bool; Use sparse Eigensolver. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). safe : bool (default=True); Check for degenerate ground state. Returns:; eigval : float; Eigenvalue for the ground state of quantum operator. eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra : qobj; Quantum object of type ‘bra’ or ‘ket’. ket : qobj; Quantum object of type ‘ket’. Returns:; elem : compl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:10354,safe,safe,10354,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['safe'],['safe']
Safety,"o0; l_vec = state0_vec.shape[0]; try:; out_d1 = d1(0., sso.rho0); except Exception as e:; raise RuntimeError(""Safety check: d1(0., state0_vec) failed.:\n"" +; str(e)) from e; try:; out_d2 = d2(0., sso.rho0); except Exception as e:; raise RuntimeError(""Safety check: d2(0., state0_vec) failed:\n"" +; str(e)) from e. msg_d1 = (""d1 must return an 1d numpy array with the same number ""; ""of elements as the initial state as a vector.""); if not isinstance(out_d1, np.ndarray):; raise TypeError(msg_d1); if (out_d1.ndim != 1; or out_d1.shape[0] != l_vec or len(out_d1.shape) != 1):; raise ValueError(msg_d1). msg_d2 = (""Safety check: d2 must return a 2d numpy array ""; ""with the shape (len_d2, len(state0_vec) ).""); if not isinstance(out_d2, np.ndarray):; raise TypeError(msg_d2); if (out_d2.ndim != 2; or out_d2.shape[1] != l_vec or out_d2.shape[0] != len_d2):; raise ValueError(msg_d2); if out_d1.dtype != np.dtype('complex128') or \; out_d2.dtype != np.dtype('complex128'):; raise ValueError(""Safety check: d1 and d2 must return "" +; ""complex numpy array.""); msg_e_ops = (""Safety check: The shape of the e_ops ""; ""does not fit the initial state.""); for op in sso.e_ops:; shape_op = op.shape; if sso.me:; if shape_op[0]**2 != l_vec or shape_op[1]**2 != l_vec:; raise ValueError(msg_e_ops); else:; if shape_op[0] != l_vec or shape_op[1] != l_vec:; raise ValueError(msg_e_ops +; "" Expecting e_ops as superoperators.""). sso.m_ops = []; sso.cm_ops = []; if sso.store_measurement:; if not m_ops:; raise ValueError(""General stochastic needs explicit "" +; ""m_ops to store measurement.""); sso.m_ops = m_ops; sso.cm_ops = [QobjEvo(op) for op in sso.m_ops]; [op.compile() for op in sso.cm_ops]; if sso.dW_factors is None:; sso.dW_factors = [1.] * len(sso.m_ops); elif len(sso.dW_factors) == 1:; sso.dW_factors = sso.dW_factors * len(sso.m_ops); elif len(sso.dW_factors) != len(sso.m_ops):; raise ValueError(""The number of dW_factors must fit"" +; "" the number of m_ops.""). if sso.dW_factors is None:; sso.dW_factors ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/stochastic.html:35157,Safe,Safety,35157,docs/4.7/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html,1,['Safe'],['Safety']
Safety,"o0; l_vec = state0_vec.shape[0]; try:; out_d1 = d1(0., sso.rho0); except Exception as e:; raise RuntimeError(""Safety check: d1(0., state0_vec) failed.:\n"" +; str(e)) from e; try:; out_d2 = d2(0., sso.rho0); except Exception as e:; raise RuntimeError(""Safety check: d2(0., state0_vec) failed:\n"" +; str(e)) from e. msg_d1 = (""d1 must return an 1d numpy array with the same number ""; ""of elements as the initial state as a vector.""); if not isinstance(out_d1, np.ndarray):; raise TypeError(msg_d1); if (out_d1.ndim != 1; or out_d1.shape[0] != l_vec or len(out_d1.shape) != 1):; raise ValueError(msg_d1). msg_d2 = (""Safety check: d2 must return a 2d numpy array ""; ""with the shape (len_d2, len(state0_vec) ).""); if not isinstance(out_d2, np.ndarray):; raise TypeError(msg_d2); if (out_d2.ndim != 2; or out_d2.shape[1] != l_vec or out_d2.shape[0] != len_d2):; raise ValueError(msg_d2); if out_d1.dtype != np.dtype('complex128') or \; out_d2.dtype != np.dtype('complex128'):; raise ValueError(""Safety check: d1 and d2 must return "" +; ""complex numpy array.""); msg_e_ops = (""Safety check: The shape of the e_ops ""; ""does not fit the intial state.""); for op in sso.e_ops:; shape_op = op.shape; if sso.me:; if shape_op[0]**2 != l_vec or shape_op[1]**2 != l_vec:; raise ValueError(msg_e_ops); else:; if shape_op[0] != l_vec or shape_op[1] != l_vec:; raise ValueError(msg_e_ops +; "" Expecting e_ops as superoperators.""). sso.m_ops = []; sso.cm_ops = []; if sso.store_measurement:; if not m_ops:; raise ValueError(""General stochastic needs explicit "" +; ""m_ops to store measurement.""); sso.m_ops = m_ops; sso.cm_ops = [QobjEvo(op) for op in sso.m_ops]; [op.compile() for op in sso.cm_ops]; if sso.dW_factors is None:; sso.dW_factors = [1.] * len(sso.m_ops); elif len(sso.dW_factors) == 1:; sso.dW_factors = sso.dW_factors * len(sso.m_ops); elif len(sso.dW_factors) != len(sso.m_ops):; raise ValueError(""The number of dW_factors must fit"" +; "" the number of m_ops.""). if sso.dW_factors is None:; sso.dW_factors =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:36658,Safe,Safety,36658,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,1,['Safe'],['Safety']
Safety,"objevo; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline, interp1d; from functools import partial; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import (_compile_str_single, _compiled_coeffs,; _compiled_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. if qset.has_cython:; import cython; use_cython = [True]; else:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """""". def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; try:; os.remove(file_); to_del.append",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:1339,safe,safePickle,1339,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,2,['safe'],['safePickle']
Safety,"ochastic. See eq. (2.13) of chapter 11.2 of; [1]. Order strong 1.5; Code: 'explicit1.5', 'explicit15' or 'platen15'. taylor2.0Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]. Order strong 2.0; Code: 'taylor2.0', 'taylor20' or 2.0. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; general_stochastic only accepts the derivative-free; solvers: 'euler', 'platen' and 'explicit1.5'. Available solvers for photocurrent_sesolve and photocurrent_mesolvePhotocurrent use ordinary differential equations between; stochastic “jump/collapse”. eulerEuler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]. Order 1.0; Code: 'euler'. predictor–correctorpredictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. Order 2.0; Code: 'pred-corr'. References. 1(1,2,3,4,5,6); Peter E. Kloeden and Exkhard Platen, Numerical Solution of; Stochastic Differential Equations. 2; H.-P. Breuer and F. Petruccione, The Theory of Open Quantum; Systems. 3; Pierre Rouchon and Jason F. Ralpha, Efficient Quantum Filtering for; Quantum Feedback Control, arXiv:1410.5345 [quant-ph], Phys. Rev. A 91, 012118,; (2015). 4; Howard M. Wiseman, Gerard J. Milburn, Quantum measurement and; control. Correlation Functions¶. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolutio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:111648,predict,predictor,111648,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['predict'],['predictor']
Safety,"olver = 'taylor2.0'; if not len(self.sc_ops) == 1 or \; not self.sc_ops[0].const or \; not self.method == ""homodyne"":; raise ValueError(""Taylor2.0 only works with 1 constant "" +; ""sc_ops and for homodyne method""); else:; raise ValueError((; ""The solver should be one of ""; ""[None, 'euler-maruyama', 'platen', 'pc-euler', ""; ""'pc-euler-imp', 'milstein', 'milstein-imp', ""; ""'rouchon', ""; ""'taylor1.5', 'taylor1.5-imp', 'explicit1.5' ""; ""'taylor2.0']"")). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a determinist",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/stochastic.html:18205,predict,predictor-corrector,18205,docs/4.5/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/stochastic.html,1,['predict'],['predictor-corrector']
Safety,"omodyne detection. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶. Homodyne detection¶; Homodyne detection is an extension of the photocurrent method where the output; is mixed with a strong external source allowing to get information about the; phase of the system. With this method, the resulting detection rate depends is. \[ \begin{align}\begin{aligned}:label: jump_rate\\\tau = tr \left((\gamma^2 + \gamma (C+C^\dag) + C^\dag C)\rho \right)\end{aligned}\end{align} \]; With \(\gamma\), the strength of the external beam and \(C\) the collapse; operator. When the beam is very strong \((\gamma >> C^\dag C)\),; the rate becomes a constant term plus a term proportional to the quadrature of; the system. Closed system¶; In closed systems, the resulting stochastic differential equation is. (1)¶\[\delta \psi(t) = - i H \psi(t) \delta t; - \sum_n \left( \frac{C_n^{+} C_n}{2} -\frac{e_n}{2} C_n; + \frac{e_n^2}{8} \right) \psi \delta t; + \sum_n \left( C_n - \frac{e_n}{2} \right) \psi \delta \omega\]; with. \[ \begin{align}\begin{aligned}:label: jump_rate\\e_n = \left<\psi(t)|C_n + C_n^{+}|\psi(t)\right>\end{aligned}\end{align} \]; Here \(\delta \omega\) is a Wiener increment.; In QuTiP, this is available with the function ssesolve.; In [1]: times = np.linspace(0.0, 10.0, 201). In [2]: p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-stochastic.html:1450,detect,detection,1450,docs/4.5/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-stochastic.html,1,['detect'],['detection']
Safety,"onte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) and \(E[dW^2] = dt\). Stochastic evolution is implemented with the qutip.stochastic.general_stochastic function. Stochastic Schrodinger Equation¶; The stochastic Schrodinger equation is given by (see section 4.4, [Wis09]). (2)¶\[d \psi(t) = - i H \psi(t) dt; - \sum_n \left( \frac{S_n^\dagger S_n}{2} -\frac{e_n}{2} S_n; + \frac{e_n^2}{8} \right) \psi(t) dt; + \sum_n \left( S_n - \frac{e_n}{2} \right) \psi(t) dW_n,\]; where \(H\) is the Hamiltonian, \(S_n\) a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:1357,detect,detection,1357,docs/4.6/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html,2,['detect'],['detection']
Safety,"oper_dtype == np.ndarray:; H = self._dyn_gen[k]; # returns row vector of eigenvals, columns with the eigenvecs; eig_val, eig_vec = eigh(H). else:; assert False, f""Unknown oper_dtype {self.oper_dtype!r}"". # assuming H is an nxn matrix, find n; n = self.get_drift_dim(). # Calculate the propagator in the diagonalised basis; eig_val_tau = -1j*eig_val*self.tau[k]; prop_eig = np.exp(eig_val_tau). # Generate the factor matrix through the differences; # between each of the eigenvectors and the exponentiations; # create nxn matrix where each eigen val is repeated n times; # down the columns; o = np.ones([n, n]); eig_val_cols = eig_val_tau*o; # calculate all the differences by subtracting it from its transpose; eig_val_diffs = eig_val_cols - eig_val_cols.T; # repeat for the propagator; prop_eig_cols = prop_eig*o; prop_eig_diffs = prop_eig_cols - prop_eig_cols.T; # the factor matrix is the elementwise quotient of the; # differeneces between the exponentiated eigen vals and the; # differences between the eigen vals; # need to avoid division by zero that would arise due to denegerate; # eigenvalues and the diagonals; degen_mask = np.abs(eig_val_diffs) < self.fact_mat_round_prec; eig_val_diffs[degen_mask] = 1; factors = prop_eig_diffs / eig_val_diffs; # for degenerate eigenvalues the factor is just the exponent; factors[degen_mask] = prop_eig_cols[degen_mask]. # Store eigenvectors, propagator and factor matric; # for use in propagator computations; self._decomp_curr[k] = True; if isinstance(factors, np.ndarray):; self._dyn_gen_factormatrix[k] = factors; else:; self._dyn_gen_factormatrix[k] = np.array(factors). if self.oper_dtype == Qobj:; self._prop_eigen[k] = Qobj(np.diagflat(prop_eig),; dims=self.dyn_dims); self._dyn_gen_eigenvectors[k] = Qobj(eig_vec,; dims=self.dyn_dims); # The _dyn_gen_eigenvectors_adj list is not used in; # memory optimised modes; if self._dyn_gen_eigenvectors_adj is not None:; self._dyn_gen_eigenvectors_adj[k] = \; self._dyn_gen_eigenvectors[k].dag(); elif",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:48936,avoid,avoid,48936,docs/4.6/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html,4,['avoid'],['avoid']
Safety,"opy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshed; self.dynamics_args = [dargs for dargs in self.dynamics_args; if dargs[0] not in new_args]; self.args.update(new_args); self._args_checks(); if self.compiled and self.compiled.split()[2] != ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). def solver_set_args(self, new_args, state, e_ops):; self.dynamics_args = []; self.args.update(new_args)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:22429,safe,safePickle,22429,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,4,['safe'],['safePickle']
Safety,"opy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). def arguments(self, new_args):; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshed; self.dynamics_args = [dargs for dargs in self.dynamics_args; if dargs[0] not in new_args]; self.args.update(new_args); self._args_checks(); if self.compiled and self.compiled.split()[2] is not ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). def solver_set_args(self, new_args, state, e_ops):; self.dynamics_args = []; self.args.update(new_args); self._args_checks(); for i, dargs in enumerate(self.dynamics_args):; if dargs[1] == ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:22091,safe,safePickle,22091,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"or. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. [docs]def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : :class:`qutip.Qobj`; Qobj one; B : :class:`qutip.Qobj`; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. [docs]def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobj.html:60581,avoid,avoid,60581,docs/4.7/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html,2,['avoid'],['avoid']
Safety,"ore terms of the Stratonovich expansion.; -Order strong 2.0; -Code: 'taylor2.0', 'taylor20', 2.0; Numerical Solution of Stochastic Differential Equations; Chapter 10.5 Eq. (5.2), By Peter E. Kloeden, Eckhard Platen. ---All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only work for 1 stochastic; operator not dependent of time with the homodyne method.; The :func:`qutip.stochastic.general_stochastic` only accept derivatives; free solvers: ['euler', 'platen', 'explicit1.5']. Available solver for photocurrent_sesolve and photocurrent_mesolve:; Photocurrent use ordinary differential equations between; stochastic ""jump/collapse"".; euler:; Euler method for ordinary differential equations between jumps.; Only 1 jumps per time interval.; Default solver; -Order 1.0; -Code: 'euler'; Quantum measurement and control; Chapter 4, Eq 4.19, 4.40, By Howard M. Wiseman, Gerard J. Milburn. predictor–corrector:; predictor–corrector method (PECE) for ordinary differential equations.; Use poisson distribution to obtain the number of jump at each timestep.; -Order 2.0; -Code: 'pred-corr'. """"""; pass. [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc. The stochastic solvers :func:`qutip.stochastic.general_stochastic`,; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`,; :func:`qutip.stochastic.photocurrent_sesolve` and; :func:`qutip.stochastic.photocurrent_mesolve`; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class. Attributes; ----------. H : :class:`qutip.Qobj`, time-dependent Qobj as a list*; System Hamiltonian. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix. times : *list* / *array*; List ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:7109,predict,predictor,7109,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,4,['predict'],['predictor']
Safety,"ort scipy; if _version2int(scipy.__version__) < _version2int(scipy_requirement):; print(""QuTiP warning: old version of scipy detected "" +; (""(%s), requiring %s."" %; (scipy.__version__, scipy_requirement))); except:; warnings.warn(""scipy not found.""). # -----------------------------------------------------------------------------; # check to see if running from install directory for released versions.; #; top_path = os.path.dirname(os.path.dirname(__file__)); try:; setup_file = open(top_path + '/setup.py', 'r'); except:; pass; else:; if ('QuTiP' in setup_file.readlines()[1][3:]) and qutip.version.release:; print(""You are in the installation directory. "" +; ""Change directories before running QuTiP.""); setup_file.close(). del top_path. # -----------------------------------------------------------------------------; # setup the cython environment; #; _cython_requirement = ""0.15.0""; try:; import Cython; if _version2int(Cython.__version__) < _version2int(_cython_requirement):; print(""QuTiP warning: old version of cython detected "" +; (""(%s), requiring %s."" %; (Cython.__version__, _cython_requirement))). import pyximport; os.environ['CFLAGS'] = '-O3 -w -ffast-math -march=native -mfpmath=sse'; pyximport.install(setup_args={'include_dirs': [numpy.get_include()]}). except Exception as e:; print(""QuTiP warning: Cython setup failed: "" + str(e)); else:; del Cython, pyximport. # -----------------------------------------------------------------------------; # Load user configuration if present: override defaults.; #; try:; if os.name == ""nt"":; qutip_rc_file = os.path.join(; os.getenv('APPDATA'), 'qutip', ""qutiprc""; ); else:; qutip_rc_file = os.path.join(; # This should possibly be changed to ~/.config/qutiprc,; # to follow XDG specs. Also, OS X uses a different naming; # convention as well.; os.environ['HOME'], "".qutiprc""; ); qutip.settings.load_rc_file(qutip_rc_file). except Exception as e:; try:; qutip.settings._logger.warning(""Error loading RC file."", exc_info=1); except:; pass",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip.html:5849,detect,detected,5849,docs/3.1.0/modules/qutip.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html,1,['detect'],['detected']
Safety,p.; Quantum circuits and algorithms. Decomposition of the Toffoli gate in terms of CNOT and single-qubit rotations; Imports and Exports QASM circuit; QuTiP example: Quantum Gates and their usage; Quantum Teleportation Circuit. Pulse-level circuit simulation. Compiling and simulating a 10-qubit Quantum Fourier Transform (QFT) algorithm; Custimize the pulse-level simulation; Examples for OptPulseProcessor; Scheduler for quantum gates and instructions; Simulating randomized benchmarking; Simulating the Deutsch–Jozsa algorithm at the pulse level; measuring the relaxation time with the idling gate. Time evolution. QobjEvo: time-dependent quantum objects; Schrödinger Equation Solver: Larmor precession; Master Equation Solver: Single-Qubit Dynamics; Master Equation Solver: Vacuum Rabi oscillations; Master Equation Solver: Dynamics of a Spin Chain; Monte Carlo Solver: Birth and Death of Photons in a Cavity; Bloch-Redfield Solver: Two Level System; Bloch-Redfield Solver: Time dependent operators; Bloch-Redfield Solver: Dissipative Atom-Cavity system; Bloch-Redfield Solver: Phonon-assisted initialization; Floquet Solvers; Floquet Formalism; Non-Markovian Monte Carlo Solver: Two Physical Examples; Stochastic Solver: Heterodyne Detection; Stochastic Solver: Mixing stochastic and deterministic equations; Stochastic Solver: Photo-current detection in a JC model; Stochastic vs. Monte-Carlo Solver: Cat states become coherent; Steady-State: Optomechanical System in the Single-Photon Strong-Coupling Regime; Steady-State: Homodyned Jaynes-Cummings emission; Steady-State: Time-dependent (periodic) quantum system. Optimal control. Overview ; Hadamard ; QFT ; Lindbladian ; Symplectic ; QFT (CRAB) ; State to state (CRAB) ; CNOT ; iSWAP ; Single-qubit rotation ; Toffoli gate . Tomography. Density matrix estimation with iterative maximum likelihood estimation . Permutational invariant Lindblad dynamics. Overview ; Superradiant light emission ; Steady state superradiance ; Open Dicke model ; ,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/qutip-tutorials/index.html:3254,detect,detection,3254,qutip-tutorials/index.html,https://qutip.org,https://qutip.org/qutip-tutorials/index.html,1,['detect'],['detection']
Safety,"params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(se",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:19478,avoid,avoids,19478,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,10,['avoid'],['avoids']
Safety,"pecified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). (png, hires.png, pdf). For other examples on qutip.stochastic.smesolve, see the following notebook, as well as these notebooks available at QuTiP Tutorials page: heterodyne detection, inneficient detection, and feedback control. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:6474,detect,detection,6474,docs/4.6/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html,5,"['Detect', 'detect']","['Detection', 'detection']"
Safety,"perators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`.; """""". if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if ""solver"" not in kwargs:; kwargs[""solver""] = 50. sso = StochasticSolverOptions(False, H=None, state0=state0, times=times,; e_ops=e_ops, args=args, **kwargs); if sso.solver_code not in [50, 100, 150]:; raise ValueError(""Only Euler, platen, platen15 can be "" +; ""used for the general stochastic solver.""). sso.d1 = d1; sso.d2 = d2; if _safe_mode:; # This state0_vec is computed as mat2vec(state0.full()).ravel(); # in the sso init.; state0_vec = sso.rho0; l_vec = state0_vec.shape[0]; try:; out_d1 = d1(0., sso.rho0); except Exception as e:; raise RuntimeError(""Safety check: d1(0., state0_vec) failed.:\n"" +; str(e)) from e; try:; out_d2 = d2(0., sso.rho0); except Exception as e:; raise RuntimeError(""Safety check: d2(0., state0_vec) failed:\n"" +; str(e)) from e. msg_d1 = (""d1 must return an 1d numpy array with the same number ""; ""of elements as the initial state as a vector.""); if not isinstance(out_d1, np.ndarray):; raise TypeError(msg_d1); if (out_d1.ndim != 1; or out_d1.shape[0] != l_vec or len(out_d1.shape) != 1):; raise ValueError(msg_d1). msg_d2 = (""Safety check: d2 must return a 2d numpy array ""; ""with the shape (len_d2, len(state0_vec) ).""); if not isinstance(out_d2, np.ndarray):; raise TypeError(msg_d2); if (out_d2.ndim != 2; or out_d2.shape[1] != l_vec or out_d2.shape[0] != len_d2):; raise ValueError(msg_d2); if out_d1.dtype != np.dtype('complex128') or \; out_d2.dtype != np.dtype('complex128'):; raise ValueError(""Safety check: d1 and d2 must return "" +; ""complex numpy array.""); msg_e_ops = (""Safety check: The shape o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:35779,Safe,Safety,35779,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,2,['Safe'],['Safety']
Safety,"port to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem, dnorm_sparse_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger(). try:; import cvxpy; except ImportError:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = (sqrtmA * B * sqrtmA).eigenenergies(); return float(np.real(np.sqrt(eig_vals[eig_vals > 0]).sum())). [docs]def process_fidelity(U1, U2, normalize=True):; """"""; Calculate",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/metrics.html:3616,avoid,avoid,3616,docs/4.6/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html,2,['avoid'],['avoid']
Safety,"r the stochastic Schrodinger and master; # equations; #. def _rhs_psi_euler_maruyama(H, psi_t, t, A_ops, dt, dW, d1, d2, args):; """"""; Euler-Maruyama rhs function for wave function solver.; """"""; dW_len = len(dW[0, :]); dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args). for a_idx, A in enumerate(A_ops):; d2_vec = d2(t, psi_t, A, args); dpsi_t += d1(t, psi_t, A, args) * dt + \; np.sum([d2_vec[n] * dW[a_idx, n]; for n in range(dW_len) if dW[a_idx, n] != 0], axis=0). return psi_t + dpsi_t. def _rhs_rho_euler_maruyama(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """"""; Euler-Maruyama rhs function for density matrix solver.; """"""; dW_len = len(dW[0, :]). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args). for a_idx, A in enumerate(A_ops):; d2_vec = d2(t, rho_t, A, args); drho_t += d1(t, rho_t, A, args) * dt; drho_t += np.sum([d2_vec[n] * dW[a_idx, n]; for n in range(dW_len) if dW[a_idx, n] != 0], axis=0). return rho_t + drho_t. def _rhs_rho_euler_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; Fast Euler-Maruyama for homodyne detection.; """""". dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2). drho_t = d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]); drho_t += (1.0 - np.inner(np.real(e), dW)) * rho_t; return drho_t. # -----------------------------------------------------------------------------; # Platen method; #; def _rhs_psi_platen(H, psi_t, t, A_ops, dt, dW, d1, d2, args):; """"""; TODO: support multiple stochastic increments. .. note::. Experimental. """""". sqrt_dt = np.sqrt(dt). dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args). for a_idx, A in enumerate(A_ops):; # XXX: This needs to be revised now that; # dpsi_t is the change for all stochastic collapse operators. # TODO: needs to be updated to support mutiple Weiner increments; dpsi_t_H = (-1.0j * dt) * spmv(H, psi_t). psi_t_1 = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt +; d2(A, psi_t)[0] * dW[a_idx, 0]); psi_t_p = (psi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:48768,detect,detection,48768,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,5,['detect'],['detection']
Safety,"r you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:5862,detect,detect,5862,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,4,['detect'],['detect']
Safety,"r2.0'; if not len(self.sc_ops) == 1 or \; not self.sc_ops[0].const or \; not self.method == ""homodyne"":; raise ValueError(; ""Taylor2.0 only works with 1 constant sc_ops and for""; "" homodyne method""; ); else:; known = [; None, 'euler-maruyama', 'platen', 'pc-euler', 'pc-euler-imp',; 'milstein', 'milstein-imp', 'rouchon', 'taylor1.5',; 'taylor1.5-imp', 'explicit1.5', 'taylor2.0',; ]; raise ValueError(""The solver should be one of {!r}"".format(known)). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a determinist",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:18558,predict,predictor-corrector,18558,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,4,['predict'],['predictor-corrector']
Safety,"ral_stochastic']. [docs]def stochastic_solvers():; """"""Available solvers for ssesolve and smesolve; euler-maruyama:; A simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations.; Only solver which could take non-commuting sc_ops. *not tested*; -Order 0.5; -Code: 'euler-maruyama', 'euler', 0.5. milstein, Order 1.0 strong Taylor scheme:; Better approximate numerical solution to stochastic; differential equations.; -Order strong 1.0; -Code: 'milstein', 1.0; Numerical Solution of Stochastic Differential Equations; Chapter 10.3 Eq. (3.1), By Peter E. Kloeden, Eckhard Platen. milstein-imp, Order 1.0 implicit strong Taylor scheme:; Implicit milstein scheme for the numerical simulation of stiff; stochastic differential equations.; -Order strong 1.0; -Code: 'milstein-imp'; Numerical Solution of Stochastic Differential Equations; Chapter 12.2 Eq. (2.9), By Peter E. Kloeden, Eckhard Platen. predictor-corrector:; Generalization of the trapezoidal method to stochastic; differential equations. More stable than explicit methods.; -Order strong 0.5, weak 1.0; Only the stochastic part is corrected.; (alpha = 0, eta = 1/2); -Code: 'pred-corr', 'predictor-corrector', 'pc-euler'; Both the deterministic and stochastic part corrected.; (alpha = 1/2, eta = 1/2); -Code: 'pc-euler-imp', 'pc-euler-2', 'pred-corr-2'; Numerical Solution of Stochastic Differential Equations; Chapter 15.5 Eq. (5.4), By Peter E. Kloeden, Eckhard Platen. platen:; Explicit scheme, create the milstein using finite difference instead of; derivatives. Also contain some higher order terms, thus converge better; than milstein while staying strong order 1.0.; Do not require derivatives, therefore usable for; :func:`qutip.stochastic.general_stochastic`; -Order strong 1.0, weak 2.0; -Code: 'platen', 'platen1', 'explicit1'; The Theory of Open Quantum Systems; Chapter 7 Eq. (7.47), H.-P Breuer, F. Petruccione. rouchon:; Scheme keeping the positivity of the density matr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/stochastic.html:3820,predict,predictor-corrector,3820,docs/4.5/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/stochastic.html,1,['predict'],['predictor-corrector']
Safety,"random coefficients. Attributes; ----------; scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). min_wavelen : float; Minimum wavelength of any component wave; Set by default to 1/10th of the pulse time; """""". def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.random = True; try:; self.min_wavelen = self.pulse_time / 10.0; except:; self.min_wavelen = 0.1. def gen_pulse(self, min_wavelen=None):; """"""; Generate a random pulse based on a Fourier series with a minimum; wavelength; """""". if min_wavelen is not None:; self.min_wavelen = min_wavelen; min_wavelen = self.min_wavelen. if min_wavelen > self.pulse_time:; raise ValueError(""Minimum wavelength cannot be greater than ""; ""the pulse time""); if not self._pulse_initialised:; self.init_pulse(). # use some phase to avoid the first pulse being always 0. sum_wave = np.zeros(self.tau.shape); wavelen = 2.0*self.pulse_time. t = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; t[k+1] = t[k] + self.tau[k]. wl = []; while wavelen > min_wavelen:; wl.append(wavelen); wavelen = wavelen/2.0. num_comp_waves = len(wl); amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves). for wavelen in wl:; amp = amp_scale*(np.random.rand()*2 - 1); phase_off = np.random.rand()*np.pi/2.0; curr_wave = amp*np.sin(2*np.pi*t/wavelen + phase_off); sum_wave += curr_wave. return self._apply_bounds_and_offset(sum_wave). class PulseGenRndWaves(PulseGen):; """"""; Generates pulses by summing sine waves with random frequencies; amplitudes and phase offset. Attributes; ----------; scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). nu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html:11354,avoid,avoid,11354,docs/3.1.0/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html,1,['avoid'],['avoid']
Safety,"ree> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:states – array of three level atom basis vectors. Return type:array. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:ops – array of three level operators. Return type:array. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters:; H (qobj) – System Hamiltonian.; c_ops (array_like) – A list or array of collapse operators. Returns:L – Liouvillian superoperator. Return type:qobj. spost(A)[source]¶; Superoperator formed from post-multiplication by operator A. Parameters:A (qobj) – Quantum operator for post multiplication. Returns:super – Superoperator formed from input qauntum object. Return type:qobj. spre(A)[source]¶; Superoperator formed from pre-multiplication by operator A. Parameters:A (qobj) – Quantum operator for pre-multiplication. Returns:super – Superoperator formed from input quantum object. Return type:qobj. sprepost(A, B)[source]¶; Superoperator formed from pre-multiplication by operator A and post-; multiplication of operator B. Parameters:; A (Qobj) – Quantum operator for pre-multiplication.; B (Qobj) – Quantum operator for post-multiplication. Returns:super – Superoperator formed from input quantum objects. Retur",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:38051,avoid,avoids,38051,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['avoid'],['avoids']
Safety,"requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:40199,safe,safe,40199,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,3,['safe'],['safe']
Safety,"requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print('WARNING: Ground state may be degenerate. Use Q.eigenstates()'); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors norm",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:39993,safe,safe,39993,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['safe'],['safe']
Safety,"res and Hellinger distances""; arXiv:1611.03449. Parameters; ----------; A : :class:`qutip.Qobj`; Density matrix or state vector.; B : :class:`qutip.Qobj`; Density matrix or state vector with same dimensions as A.; tol : float; Tolerance used by sparse eigensolver, if used. (0=Machine precision); sparse : {False, True}; Use sparse eigensolver. Returns; -------; hellinger_dist : float; Quantum Hellinger distance between A and B. Ranges from 0 to sqrt(2). Examples; --------; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> hellinger_dist(x,y); 1.3725145002591095. """"""; if A.dims != B.dims:; raise TypeError(""A and B do not have same dimensions.""). if A.isket or A.isbra:; sqrtmA = ket2dm(A); else:; sqrtmA = A.sqrtm(sparse=sparse, tol=tol); if B.isket or B.isbra:; sqrtmB = ket2dm(B); else:; sqrtmB = B.sqrtm(sparse=sparse, tol=tol). product = sqrtmA*sqrtmB. eigs = sp_eigs(product.data,; isherm=product.isherm, vecs=False, sparse=sparse, tol=tol); #np.maximum() is to avoid nan appearing sometimes due to numerical; #instabilities causing np.sum(eigs) slightly (~1e-8) larger than 1; #when hellinger_dist(A, B) is called for A=B; return np.sqrt(2.0 * np.maximum(0., (1.0 - np.real(np.sum(eigs))))). def dnorm(A, B=None, solver=""CVXOPT"", verbose=False, force_solve=False):; """"""; Calculates the diamond norm of the quantum map q_oper, using; the simplified semidefinite program of [Wat12]_. The diamond norm SDP is solved by using CVXPY_. Parameters; ----------; A : Qobj; Quantum map to take the diamond norm of.; B : Qobj or None; If provided, the diamond norm of :math:`A - B` is; taken instead.; solver : str; Solver to use with CVXPY. One of ""CVXOPT"" (default); or ""SCS"". The latter tends to be significantly faster,; but somewhat less accurate.; verbose : bool; If True, prints additional information about the; solution.; force_solve : bool; If True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument. Returns; -------; dn : float; Diamond norm of q_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/metrics.html:9536,avoid,avoid,9536,docs/4.4/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/metrics.html,2,['avoid'],['avoid']
Safety,"res,; psi0,; expt_callback,; e_0,; n_expt_op,; e_ops,; e_m_0,; ). if (options.store_final_state) and (not options.store_states):; res.states = [psi0]. progress_bar.update(1); progress_bar.finished(); return res. def _happy_breakdown(; tlist, options, res, psi0, expt_callback, e_0, n_expt_op, e_ops, e_m_0; ):; """"""; Dummy evolves the system if a happy breakdown of an eigenstate occurs.; """"""; for i in range(1, len(tlist)):; if options.store_states:; res.states.append(psi0); if expt_callback:; res.expect.append(e_0). for m in range(n_expt_op):; op = e_ops[m]; res.expect[m][i] = e_m_0[m]; return res. def _optimize_lanczos_timestep_size(T, krylov_basis, tlist, options):; """"""; Solves the equation defined to optimize the number of Lanczos; iterations to be performed inside Krylov's algorithm.; """""". f = _lanczos_error_equation_to_optimize_delta_t(; T,; krylov_basis=krylov_basis,; t0=tlist[0],; tf=tlist[-1],; target_tolerance=options.atol,; ). # To avoid the singularity at t0, we add a small epsilon value; t_min = (tlist[-1] - tlist[0]) / options.nsteps + tlist[0]; bracket = [t_min, tlist[-1]]. if (np.sign(f(bracket[0])) == -1) and (np.sign(f(bracket[-1])) == -1):; delta_t = tlist[-1] - tlist[0]; return delta_t. elif (np.sign(f(bracket[0])) == 1) and (np.sign(f(bracket[-1])) == 1):; raise ValueError(; ""No solution exists with the given combination of parameters 'krylov_dim', ""; ""tolerance = 'options.atol', maximum number allowed of krylov internal ""; ""partitions = 'options.nsteps' and 'tlist'. Try reducing the tolerance, or ""; ""increasing 'krylov_dim'. If nothing works, then a deeper analysis of the ""; ""problem is recommended.""; ). else:; sol = root_scalar(f=f, bracket=bracket, method=""brentq"", xtol=options.atol); if sol.converged:; delta_t = sol.root; return delta_t; else:; raise Exception(; ""Method did not converge, try increasing 'krylov_dim', ""; ""taking a lesser final time 'tlist[-1]' or decreasing the ""; ""tolerance via Options().atol. ""; ""If nothing works, this problem m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:14444,avoid,avoid,14444,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,2,['avoid'],['avoid']
Safety,"rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""to",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html:5677,avoid,avoid,5677,docs/3.1.0/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html,1,['avoid'],['avoid']
Safety,"rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/entropy.html:4489,avoid,avoid,4489,docs/4.2/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/entropy.html,8,['avoid'],['avoid']
Safety,"ror. Quantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters:states_inds : list of integer. The states that should be kept. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters:order : str {‘C’, ‘F’}. Return array in C (default) or Fortran ordering. squeeze : bool {False, True}. Squeeze output array. Returns:data : array. Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). safe : bool (default=True). Check for degenerate ground state. Returns:eigval : float. Eigenvalue for the ground state of quantum operator. eigvec : qobj. Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex value",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:10059,safe,safe,10059,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,1,['safe'],['safe']
Safety,"roundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:46395,safe,safe,46395,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,4,['safe'],['safe']
Safety,"rray; Array of length d2_len, containing scaling factors for each; measurement operator in m_ops. rhs : function; Function for calculating the deterministic and stochastic contributions; to the right-hand side of the stochastic differential equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops : function; Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise : function; Function for generate an array of pre-computed noise signal. homogeneous : bool (True); Wheter or not the stochastic process is homogenous. Inhomogenous; processes are only supported for poisson distributions. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are:; 1/2 order algorithms: 'euler-maruyama', 'fast-euler-maruyama',; 'pc-euler' is a predictor-corrector method which is more; stable than explicit methods,; 1 order algorithms: 'milstein', 'fast-milstein', 'platen',; 'milstein-imp' is semi-implicit Milstein method,; 3/2 order algorithms: 'taylor15',; 'taylor15-imp' is semi-implicit Taylor 1.5 method.; Implicit methods can adjust tolerance via args = {'tol':value},; default is {'tol':1e-6}. method : string ('homodyne', 'heterodyne', 'photocurrent'); The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution : string ('normal', 'poission'); The name of the distribution used for the stochastic increments. store_measurements : bool (default False); Whether or not to store the measurement results in the; :class:`qutip.solver.SolverResult` instance returned by the solver. noise : array; Vector specifying the noise. normalize : bool (default True); Whether or not to normalize the wave function du",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/stochastic.html:6600,predict,predictor-corrector,6600,docs/4.3/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/stochastic.html,1,['predict'],['predictor-corrector']
Safety,"rray; Array of length d2_len, containing scaling factors for each; measurement operator in m_ops. rhs : function; Function for calculating the deterministic and stochastic contributions; to the right-hand side of the stochastic differential equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops : function; Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise : function; Function for generate an array of pre-computed noise signal. homogeneous : bool (True); Wheter or not the stochastic process is homogenous. Inhomogenous; processes are only supported for poisson distributions. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are:; 1/2 order algorithms: ‘euler-maruyama’, ‘fast-euler-maruyama’,; ‘pc-euler’ is a predictor-corrector method which is more; stable than explicit methods,; 1 order algorithms: ‘milstein’, ‘fast-milstein’, ‘platen’,; ‘milstein-imp’ is semi-implicit Milstein method,; 3/2 order algorithms: ‘taylor15’,; ‘taylor15-imp’ is semi-implicit Taylor 1.5 method.; Implicit methods can adjust tolerance via args = {‘tol’:value},; default is {‘tol’:1e-6}. method : string (‘homodyne’, ‘heterodyne’, ‘photocurrent’); The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution : string (‘normal’, ‘poission’); The name of the distribution used for the stochastic increments. store_measurements : bool (default False); Whether or not to store the measurement results in the; qutip.solver.SolverResult instance returned by the solver. noise : array; Vector specifying the noise. normalize : bool (default True); Whether or not to normalize the wave function during the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:44591,predict,predictor-corrector,44591,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['predict'],['predictor-corrector']
Safety,"rror:; return False. def _is_inline_backend(self):; backend = matplotlib.get_backend(); return backend == ""module://matplotlib_inline.backend_inline"". [docs] def render(self):; """"""; Render the Bloch sphere and its data sets in on given figure and axes.; """"""; if not self._ext_fig and not self._is_inline_backend():; # If no external figure was supplied, we check to see if the; # figure we created in a previous call to .render() has been; # closed, and re-create if has been. This has the unfortunate; # side effect of losing any modifications made to the axes or; # figure, but the alternative is to crash the matplotlib backend.; #; # The inline backend used by, e.g. jupyter notebooks, is happy to; # use closed figures so we leave those figures intact.; if (; self.fig is not None and; not plt.fignum_exists(self.fig.number); ):; self.fig = None; self.axes = None. if self.fig is None:; self.fig = plt.figure(figsize=self.figsize); if self._is_inline_backend():; # We immediately close the inline figure do avoid displaying; # the figure twice when .show() calls display.; plt.close(self.fig). if self.axes is None:; self.axes = _axes3D(self.fig, azim=self.view[0], elev=self.view[1]). # Clearing the axes is horrifically slow and loses a lot of the; # axes state, but matplotlib doesn't seem to provide a better way; # to redraw Axes3D. :/; self.axes.clear(); self.axes.grid(False); if self.background:; self.axes.set_xlim3d(-1.3, 1.3); self.axes.set_ylim3d(-1.3, 1.3); self.axes.set_zlim3d(-1.3, 1.3); else:; self.axes.set_axis_off(); self.axes.set_xlim3d(-0.7, 0.7); self.axes.set_ylim3d(-0.7, 0.7); self.axes.set_zlim3d(-0.7, 0.7); # Manually set aspect ratio to fit a square bounding box.; # Matplotlib did this stretching for < 3.3.0, but not above.; if parse_version(matplotlib.__version__) >= parse_version('3.3'):; self.axes.set_box_aspect((1, 1, 1)); if not self.background:; self.plot_axes(). self.plot_back(); self.plot_points(); self.plot_vectors(); self.plot_front(); self.plot_axe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/bloch.html:15702,avoid,avoid,15702,docs/4.6/modules/qutip/bloch.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch.html,2,['avoid'],['avoid']
Safety,"rror:; return False. def _is_inline_backend(self):; backend = matplotlib.get_backend(); return backend == ""module://matplotlib_inline.backend_inline"". [docs] def render(self):; """"""; Render the Bloch sphere and its data sets in on given figure and axes.; """"""; if not self._ext_fig and not self._is_inline_backend():; # If no external figure was supplied, we check to see if the; # figure we created in a previous call to .render() has been; # closed, and re-create if has been. This has the unfortunate; # side effect of losing any modifications made to the axes or; # figure, but the alternative is to crash the matplotlib backend.; #; # The inline backend used by, e.g. jupyter notebooks, is happy to; # use closed figures so we leave those figures intact.; if (; self.fig is not None and; not plt.fignum_exists(self.fig.number); ):; self.fig = None; self.axes = None. if self.fig is None:; self.fig = plt.figure(figsize=self.figsize); if self._is_inline_backend():; # We immediately close the inline figure do avoid displaying; # the figure twice when .show() calls display.; plt.close(self.fig). if self.axes is None:; self.axes = _axes3D(self.fig, azim=self.view[0], elev=self.view[1]). # Clearing the axes is horrifically slow and loses a lot of the; # axes state, but matplotlib doesn't seem to provide a better way; # to redraw Axes3D. :/; self.axes.clear(); self.axes.grid(False); if self.background:; self.axes.set_xlim3d(-1.3, 1.3); self.axes.set_ylim3d(-1.3, 1.3); self.axes.set_zlim3d(-1.3, 1.3); else:; self.axes.set_axis_off(); self.axes.set_xlim3d(-0.7, 0.7); self.axes.set_ylim3d(-0.7, 0.7); self.axes.set_zlim3d(-0.7, 0.7); # Manually set aspect ratio to fit a square bounding box.; # Matplotlib did this stretching for < 3.3.0, but not above.; if parse_version(matplotlib.__version__) >= parse_version('3.3'):; self.axes.set_box_aspect((1, 1, 1)); if not self.background:; self.plot_axes(). self.plot_back(); self.plot_points(); self.plot_vectors(); self.plot_lines(); self.plot_arc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/bloch.html:18772,avoid,avoid,18772,docs/4.7/modules/qutip/bloch.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html,2,['avoid'],['avoid']
Safety,"s : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns; -------; rho : Qobj; A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution.; """"""; if dims is not None:; # TODO: check!; pass; else:; dims = [[[N],[N]], [[N],[N]]]. if rank is None:; rank = N**2; if rank > N**2:; raise ValueError(""Rank cannot exceed superoperator dimension.""). # We use mainly dense matrices here for speed in low; # dimensions. In the future, it would likely be better to switch off; # between sparse and dense matrices as the dimension grows. # We start with a Ginibre uniform matrix X of the appropriate rank,; # and use it to construct a positive semidefinite matrix X X⁺.; X = randnz((N**2, rank), norm='ginibre', seed=seed). # Precompute X X⁺, as we'll need it in two different places.; XXdag = np.dot(X, X.T.conj()). if enforce_tp:; # We do the partial trace over the first index by using dense reshape; # operations, so that we can avoid bouncing to a sparse representation; # and back.; Y = np.einsum('ijik->jk', XXdag.reshape((N, N, N, N))). # Now we have the matrix 𝟙 ⊗ Y^{-1/2}, which we can find by doing; # the square root and the inverse separately. As a possible improvement,; # iterative methods exist to find inverse square root matrices directly,; # as this is important in statistics.; Z = np.kron(; np.eye(N),; sqrtm(la.inv(Y)); ). # Finally, we dot everything together and pack it into a Qobj,; # marking the dimensions as that of a type=super (that is,; # with left and right compound indices, each representing; # left and right indices on the underlying Hilbert space).; D = Qobj(np.dot(Z, np.dot(XXdag, Z))); else:; D = N * Qobj(XXdag / np.trace(XXdag)). D.dims = [; # Left dims; [[N], [N]],; # Right dims; [[N], [N]]; ]. # Since [BCSZ08] gives a row-stacking Choi matrix, but QuTiP; # expects a column-stacking Choi matrix, we must permute the indices.; D = D.permute([[1], [0]]). D",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/random_objects.html:16088,avoid,avoid,16088,docs/4.4/modules/qutip/random_objects.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/random_objects.html,1,['avoid'],['avoid']
Safety,"s : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns; -------; rho : Qobj; A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution.; """"""; if dims is not None:; # TODO: check!; pass; else:; dims = [[[N],[N]], [[N],[N]]]. if rank is None:; rank = N**2; if rank > N**2:; raise ValueError(""Rank cannot exceed superoperator dimension.""). # We use mainly dense matrices here for speed in low; # dimensions. In the future, it would likely be better to switch off; # between sparse and dense matrices as the dimension grows. # We start with a Ginibre uniform matrix X of the appropriate rank,; # and use it to construct a positive semidefinite matrix X X⁺.; X = randnz((N**2, rank), norm='ginibre', seed=seed). # Precompute X X⁺, as we'll need it in two different places.; XXdag = np.dot(X, X.T.conj()). if enforce_tp:; # We do the partial trace over the first index by using dense reshape; # operations, so that we can avoid bouncing to a sparse representation; # and back.; Y = np.einsum('ijik->jk', XXdag.reshape((N, N, N, N))). # Now we have the matrix 𝟙 ⊗ Y^{-1/2}, which we can find by doing; # the square root and the inverse separately. As a possible; # improvement, iterative methods exist to find inverse square root; # matrices directly, as this is important in statistics.; Z = np.kron(; np.eye(N),; sqrtm(la.inv(Y)); ). # Finally, we dot everything together and pack it into a Qobj,; # marking the dimensions as that of a type=super (that is,; # with left and right compound indices, each representing; # left and right indices on the underlying Hilbert space).; D = Qobj(np.dot(Z, np.dot(XXdag, Z))); else:; D = N * Qobj(XXdag / np.trace(XXdag)). D.dims = [; # Left dims; [[N], [N]],; # Right dims; [[N], [N]]; ]. # Since [BCSZ08] gives a row-stacking Choi matrix, but QuTiP; # expects a column-stacking Choi matrix, we must permute the indices.; D = D.permute([[1], [0]]). D",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/random_objects.html:17322,avoid,avoid,17322,docs/4.5/modules/qutip/random_objects.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/random_objects.html,1,['avoid'],['avoid']
Safety,"s A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> fidelity(x,y); 0.24104350624628332. """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = (sqrtmA * B * sqrtmA).eigenenergies(); return float(np.real(np.sqrt(eig_vals[eig_vals > 0]).sum())). [docs]def process_fidelity(U1, U2, normalize=True):; """"""; Calculate the process fidelity given two process operators.; """"""; if normalize:; return (U1 * U2).tr() / (U1.tr() * U2.tr()); else:; return (U1 * U2).tr(). [docs]def average_gate_fidelity(oper, target=None):; """"""; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters; ----------; A : Qobj; Quantum object representing a superoperator.; target : Qobj; Quantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns; -------; fid : float; Fidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary.; """"""; kraus_form = to_kraus(oper); d = kraus_form[0].shape[0]. if kraus_form",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/metrics.html:4147,avoid,avoid,4147,docs/4.2/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html,6,['avoid'],['avoid']
Safety,"s Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Homodyne detection. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶. Homodyne detection¶; Homodyne detection is an extension of the photocurrent method where the output; is mixed with a strong external source allowing to get information about the; phase of the system. With this method, the resulting detection rate depends is. \[ \begin{align}\begin{aligned}:label: jump_rate\\\tau = tr \left((\gamma^2 + \gamma (C+C^\dag) + C^\dag C)\rho \right)\end{aligned}\end{align} \]; With \(\gamma\), the strength of the external beam and \(C\) the collapse; operator. When the beam is very strong \((\gamma >> C^\dag C)\),; the rate becomes a constant term plus a term proportional to the quadrature of; the system. Closed system¶; In closed systems, the resulting stochastic differential equation is. (1)¶\[\delta \psi(t) = - i H \psi(t) \delta t; - \sum_n \left( \frac{C_n^{+} C_n}{2} -\frac{e_n}{2} C_n; + \frac{e_n^2}{8} \right) \psi \delta t; + \sum_n \left( C_n - \frac{e_n}{2} \right) \psi \delta \omega\]; with. \[ \begin{align}\begin{aligned}:label: jump_rate\\e_n = \left<\psi(t)|C_n + C_n^{+}|\psi(t)\right>\end{aligned}\end{align} \]; Here \(\delta \omega\) is a ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-stochastic.html:1227,detect,detection,1227,docs/4.5/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-stochastic.html,2,['detect'],['detection']
Safety,"s(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:42644,safe,safe,42644,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,2,['safe'],['safe']
Safety,"s(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:45478,safe,safe,45478,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,4,['safe'],['safe']
Safety,"s(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Groun",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:39445,safe,safe,39445,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,3,['safe'],['safe']
Safety,"s(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print('WARNING: Groun",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:39239,safe,safe,39239,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['safe'],['safe']
Safety,"scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). min_wavelen : float; Minimum wavelength of any component wave; Set by default to 1/10th of the pulse time; """""". def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.random = True; self._uses_time = True; try:; self.min_wavelen = self.pulse_time / 10.0; except:; self.min_wavelen = 0.1; self.apply_params(). def gen_pulse(self, min_wavelen=None):; """"""; Generate a random pulse based on a Fourier series with a minimum; wavelength; """""". if min_wavelen is not None:; self.min_wavelen = min_wavelen; min_wavelen = self.min_wavelen. if min_wavelen > self.pulse_time:; raise ValueError(""Minimum wavelength cannot be greater than ""; ""the pulse time""); if not self._pulse_initialised:; self.init_pulse(). # use some phase to avoid the first pulse being always 0. sum_wave = np.zeros(self.tau.shape); wavelen = 2.0*self.pulse_time. t = self.time; wl = []; while wavelen > min_wavelen:; wl.append(wavelen); wavelen = wavelen/2.0. num_comp_waves = len(wl); amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves). for wavelen in wl:; amp = amp_scale*(np.random.rand()*2 - 1); phase_off = np.random.rand()*np.pi/2.0; curr_wave = amp*np.sin(2*np.pi*t/wavelen + phase_off); sum_wave += curr_wave. return self._apply_bounds_and_offset(sum_wave). class PulseGenRndWaves(PulseGen):; """"""; Generates pulses by summing sine waves with random frequencies; amplitudes and phase offset. Attributes; ----------; scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). num_comp_waves : integer; Number of component waves. That is the number of waves that; are summe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html:12659,avoid,avoid,12659,docs/4.1/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html,10,['avoid'],['avoid']
Safety,"se of; # commuting jump operators.; d2_vec2 = np.array([[spmv(M[n], d2_vec[m]); for m in range(A_len)] for n in range(A_len)]); e2 = np.array([[cy_expect_rho_vec(M[n], d2_vec[m], 0); for m in range(A_len)] for n in range(A_len)]). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += d1_vec * dt; drho_t += np.sum([(d2_vec[n] - e1[n] * rho_t) * dW[n, 0]; for n in range(A_len)], axis=0); drho_t += 0.5 * np.sum(; [(d2_vec2[n, n] - 2.0 * e1[n] * d2_vec[n] +; (-e2[n, n] + 2.0 * e1[n] * e1[n]) * rho_t) * (dW[n, 0]*dW[n, 0] - dt); for n in range(A_len)], axis=0). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; drho_t += 0.5 * np.sum(; [(d2_vec2[n, m] - e1[m] * d2_vec[n] - e1[n] * d2_vec[m] +; (-e2[n, m] + 2.0 * e1[n] * e1[m]) * rho_t) * (dW[n, 0] * dW[m, 0]); for (n, m) in np.ndindex(A_len, A_len) if n != m], axis=0). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_single_fast(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; fast Milstein for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = (1.0 - np.inner(e, dW)) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:49171,detect,detection,49171,docs/3.1.0/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html,1,['detect'],['detection']
Safety,"self.random = True; self.num_comp_waves = 20; try:; self.min_wavelen = self.pulse_time / 10.0; except:; self.min_wavelen = 0.1; try:; self.max_wavelen = 2*self.pulse_time; except:; self.max_wavelen = 10.0. def gen_pulse(self, num_comp_waves=None,; min_wavelen=None, max_wavelen=None):; """"""; Generate a random pulse by summing sine waves with random freq,; amplitude and phase offset; """""". if num_comp_waves is not None:; self.num_comp_waves = num_comp_waves; if min_wavelen is not None:; self.min_wavelen = min_wavelen; if max_wavelen is not None:; self.max_wavelen = max_wavelen. num_comp_waves = self.num_comp_waves; min_wavelen = self.min_wavelen; max_wavelen = self.max_wavelen. if min_wavelen > self.pulse_time:; raise ValueError(""Minimum wavelength cannot be greater than ""; ""the pulse time""); if max_wavelen <= min_wavelen:; raise ValueError(""Maximum wavelength must be greater than ""; ""the minimum wavelength""). if not self._pulse_initialised:; self.init_pulse(). # use some phase to avoid the first pulse being always 0. sum_wave = np.zeros(self.tau.shape). t = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; t[k+1] = t[k] + self.tau[k]. wl_range = max_wavelen - min_wavelen; amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves); for n in range(num_comp_waves):; amp = amp_scale*(np.random.rand()*2 - 1); phase_off = np.random.rand()*np.pi/2.0; wavelen = min_wavelen + np.random.rand()*wl_range; curr_wave = amp*np.sin(2*np.pi*t/wavelen + phase_off); sum_wave += curr_wave. return self._apply_bounds_and_offset(sum_wave). class PulseGenRndWalk1(PulseGen):; """"""; Generates pulses by using a random walk algorithm. Attributes; ----------; scaling : float; Used as the range for the starting amplitude; Note must used bounds if values must be restricted.; Also scales the max_d_amp value; (copied from Dynamics.initial_ctrl_scaling if given). max_d_amp : float; Maximum amount amplitude will change between timeslots; Note this is also factored by the scalin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html:13799,avoid,avoid,13799,docs/3.1.0/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html,1,['avoid'],['avoid']
Safety,"ses with strongly magnetic atoms"", ; Phys. Rev. A 96, 033602 (2017). 261. Poonia et al., ""Functional window of the avian compass"", ; Phys. Rev. E 95, 052417 (2017). 260. Su et al., ""Generating double NOON states of photons in circuit QED"", ; Phys. Rev. A 95, 022339 (2017). 259. Kiukas et al., ""Remote parameter estimation in a quantum spin chain enhanced by local control"", ; Phys. Rev. A 95, 052132 (2017). 258. Gely et al., ""Convergence of the multimode quantum Rabi model of circuit quantum electrodynamics"", ; Phys. Rev. B 95, 245115 (2017). 257. Radtke et al., ""Photonic Quantum Operations via the Quantum Carburettor Effect"", ; arXiv:1701.04251. 256. Lagoudakis et al., ""Observation of Mollow Triplets with Tunable Interactions in Double Lambda Systems of Individual Hole Spins"", ; Phys. Rev. Lett. 118, 013602 (2017). 255. Pucci et al., ""Quantum effects in the cooperative scattering of light by atomic clouds"", ; Phys. Rev. A 95, 053625 (2017). 254. Gessner et al., ""Resolution-enhanced entanglement detection"", ; Phys. Rev. A 95, 032326 (2017). 253. Nigg et al., ""Superconducting Grid-Bus Surface Code Architecture for Hole-Spin Qubits"", ; Phys. Rev. Lett. 118, 147701 (2017). 252. Lüer et al., ""Lévy Defects in Matrix-Immobilized J Aggregates: Tracing Intra-and Intersegmental Exciton Relaxation"", ; J. Phys. Chem. Lett. 8, 547 (2017). 251. Dive et al., ""In situ upgrade of quantum simulators to universal computers"", ; arXiv:1701.01723. 250. Barnes et al., ""Fast microwave-driven three-qubit gates for cavity-coupled superconducting qubits"", ; Phys. Rev. B 96, 024504 (2017). 249. Hu, ""Spin-based single-photon transistor, dynamic random access memory, diodes, and routers in semiconductors"", ; Phys. Rev. B 94, 245307 (2016). 248. Leung et al., ""Speedup for quantum optimal control from automatic differentiation based on graphics processing units"", ; Phys. Rev. A 95, 042318 (2017). 247. Bruhat et al., ""Strong coupling between an electron in a quantum dot circuit and a photon in a cavi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:15384,detect,detection,15384,users.html,https://qutip.org,https://qutip.org/users.html,1,['detect'],['detection']
Safety,"sesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=1/2\), \(\eta=1/2\)): 'pc-euler-imp',; 'pc-euler-2' or 'pred-corr-2'. platenExplicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; general_stochastic. See eq. (7.47) of chapter 7 of [2]. Order strong 1.0, weak 2.0; Code: 'platen', 'platen1' or 'explicit1'. rouchonScheme keeping the positivity of the density matrix; (smesolve only). See eq. (4) with \(\eta=1\) of [3]. Order strong 1.0?; Code: 'rouchon' or 'Rouchon'. taylor1.5Order 1.5 strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for smesolve and; ssesolve. See eq. (4.6) of chapter 10.4 of [1]. Order strong 1.5; Code: 'taylor1.5', 'taylor15', 1.5, or None. taylor1.5-impOrder 1.5 implicit strong Taylor scheme. Implicit Taylor 1.5; (",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:109317,predict,predictor-corrector,109317,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['predict'],['predictor-corrector']
Safety,"simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum proce",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2351,avoid,avoid,2351,docs/4.7/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html,2,['avoid'],['avoid']
Safety,"st = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshed; self.dynamics_args = [dargs for dargs in self.dynamics_args; if dargs[0] not in new_args]; self.args.update(new_args); self._args_checks(); if self.compiled and self.compiled.split()[2] != ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). def solver_set_args(self, new_args, state, e_ops):; self.dynamics_args = []; self.args.update(new_args); self._args_ch",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:22448,safe,safePickle,22448,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,4,['safe'],['safePickle']
Safety,"st = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). def arguments(self, new_args):; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshed; self.dynamics_args = [dargs for dargs in self.dynamics_args; if dargs[0] not in new_args]; self.args.update(new_args); self._args_checks(); if self.compiled and self.compiled.split()[2] is not ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). def solver_set_args(self, new_args, state, e_ops):; self.dynamics_args = []; self.args.update(new_args); self._args_checks(); for i, dargs in enumerate(self.dynamics_args):; if dargs[1] == ""expect"" and is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:22110,safe,safePickle,22110,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['safe'],['safePickle']
Safety,"stic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) and \(E[dW^2] = dt\). Stochastic evolution is implemented with the qutip.stochastic.general_stochastic function. Stochastic Schrodinger Equation¶; The stochastic Schrodinger equation is given by (see section 4.4, [Wis09]). (2)¶\[d \psi(t) = - i H \psi(t) dt; - \sum_n \left( \frac{S_n^\dagger S_n}{2} -\frac{e_n}{2} S_n; + \frac{e_n^2}{8} \right) \psi(t) dt; + \sum_n \left( S_n - \frac{e_n}{2} \right) \psi(t) dW_n,\]; where \(H\) is the Hamiltonian, \(S_n\) a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:1445,detect,detection,1445,docs/4.7/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html,2,['detect'],['detection']
Safety,"t 12.2 Eq. (2.18) in Numerical Solution of Stochastic Differential Equations; By Peter E. Kloeden, Eckhard Platen; """"""; ; dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = b * dW[0] ; drho_t += Lb * dW[1] # Milstein term; xx0 = (drho_t + a * dt) + rho_t #starting vector for the linear solver (Milstein prediction); drho_t += (0.5 * dt) * a. # new terms: ; drho_t += A[-1] * b * (dW[2] - 0.5*dW[0]*dt); drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]. drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]; drho_t += rho_t. v, check = sp.linalg.bicgstab(A[-2], drho_t, x0 = xx0, tol=args['tol']). return v; ; def _rhs_rho_pred_corr_homodyne_single(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; 1/2 predictor-corrector scheme for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]; ; #predictor. d_vec = (A[0][0] * rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_pred = np.copy(d_vec[-1]); b_pred = - e[0] * rho_t; b_pred += d_vec[0]. pred_rho_t = np.copy(a_pred); pred_rho_t += b_pred * dW[0]; pred_rho_t += rho_t. a_pred -= ((d_vec[1] - e[1] * rho_t) - (2.0 * e[0]) * b_pred) * (0.5 * dt); ; #corrector. d_vec = (A[0][0] * pred_rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_corr = d_vec[-1]; b_corr = - e[0] * pred_rho_t; b_corr += d_vec[0]. a_corr -= ((d_vec[1] - e[1] * pred_rho_t) - (2.0 * e[0]) * b_corr) * (0.5 * dt); a_corr += a_pred; a_corr *= 0.5. b_corr += b_pred; b_corr *= 0.5 * dW[0]. corr_rho_t = a_corr; corr_rho_t += b_corr; corr_rho_t += rho_t. return corr_rho_t. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchf",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:56975,predict,predictor-corrector,56975,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,9,"['detect', 'predict']","['detection', 'predictor', 'predictor-corrector']"
Safety,"t = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/parallel.html:8179,timeout,timeout,8179,docs/4.6/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/parallel.html,2,['timeout'],['timeout']
Safety,"t to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters:order : str {‘C’, ‘F’}. Return array in C (default) or Fortran ordering. squeeze : bool {False, True}. Squeeze output array. Returns:data : array. Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). safe : bool (default=True). Check for degenerate ground state. Returns:eigval : float. Eigenvalue for the ground state of quantum operator. eigvec : qobj. Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex valued matrix element. Raises:TypeError. Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:norm : str. Which norm to use for ket/bra vectors",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:10452,safe,safe,10452,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,1,['safe'],['safe']
Safety,"t(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/fidcomp.html:22010,avoid,avoids,22010,docs/4.7/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/fidcomp.html,2,['avoid'],['avoids']
Safety,"t) dt + \mathcal{H}[A]\rho dW(t)\]; where. (7)¶\[D[A] \rho = \frac{1}{2} \left[2 A \rho A^\dagger; - \rho A^\dagger A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, while \(S_n\) (sc_ops) are monitored operators. The deterministic part of the evolution, described by the \(d_1\) in Equation (1), takes into account all operators \(C_i\) and \(S_n\):. (9)¶\[d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,\]; The stochastic part, \(d_{2,n}\), is given solely by the operators \(S_n\). (10)¶\[d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \tr \left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:4811,detect,detection,4811,docs/4.6/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html,4,['detect'],['detection']
Safety,"table of simulation times for the single-photon example using the different time-dependent formats and both the master equation and Monte Carlo solver. Format; Master Equation; Monte Carlo. Python Function; 2.1 sec; 27 sec. Cython String; 1.4 sec; 9 sec. Hamiltonian Function; 1.0 sec; 238 sec. For the current example, the table indicates that the Hamiltonian function method is in fact the fastest when using the master equation solver. This is because the simulation is quite small. In contrast, the Hamiltonian function is over 26x slower than the compiled string version when using the Monte Carlo solver. In this case, the 500 trajectories needed in the simulation highlights the inefficient nature of the Python function calls. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do:; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). In this case, the second call to qutip.mcsolve takes 3 seconds less than the first. Of course our parameters are different, but this also shows how much time one can save by not reorganizing the data, and in the case of the string format, not recompiling the code. If you need to call the solvers many times for different parameters, this savings will obviously start to add",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:15359,avoid,avoid,15359,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['avoid'],['avoid']
Safety,"tates, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects¶. data layer abstraction¶. tag; dl-abs. status; completed. admin lead; Eric. main dev; Jake Lishman. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some research groups.; Abstraction of the linear algebra data from code qutip components, allowing; for alternatives, such as sparse, dense etc. Difficult to summarize. Almost; every file in qutip affected in some way. A major milestone for qutip.; Significant performance improvements ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:12734,avoid,avoid,12734,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,2,['avoid'],['avoid']
Safety,"tates, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full releas",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:15017,avoid,avoid,15017,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,2,['avoid'],['avoid']
Safety,"tem Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Homodyne detection. Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶. Homodyne detection¶; Homodyne detection is an extension of the photocurrent method where the output; is mixed with a strong external source allowing to get information about the; phase of the system. With this method, the resulting detection rate depends is. \[ \begin{align}\begin{aligned}:label: jump_rate\\\tau = tr \left((\gamma^2 + \gamma (C+C^\dag) + C^\dag C)\rho \right)\end{aligned}\end{align} \]; With \(\gamma\), the strength of the external beam and \(C\) the collapse; operator. When the beam is very strong \((\gamma >> C^\dag C)\),; the rate becomes a constant term plus a term proportional to the quadrature of; the system. Closed system¶; In closed systems, the resulting stochastic differential equation is. (1)¶\[\delta \psi(t) = - i H \psi(t) \delta t; - \sum_n \left( \frac{C_n^{+} C_n}{2} -\frac{e_n}{2} C_n; + \frac{e_n^2}{8} \right) \psi \delta t; + \sum_n \left( C_n - \frac{e_n}{2} \right) \psi \delta \omega\]; with. \[ \begin{align}\begin{aligned}:label: jump_rate\\e_n = \left<\psi(t)|C_n + C_n^{+}|\psi(t)\right>\end{aligned}\end{align} \]; Here \(\delta \omega\) is a ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-stochastic.html:1202,detect,detection,1202,docs/4.4/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-stochastic.html,2,['detect'],['detection']
Safety,"ter equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Homodyne detection. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-dynamics.html:1565,detect,detection,1565,docs/4.4/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-dynamics.html,1,['detect'],['detection']
Safety,"th psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; qutip.bloch_redfield.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.solver.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Next ; Previous. © Copyright 2011",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:17948,avoid,avoid,17948,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,2,['avoid'],['avoid']
Safety,"ticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=1/2\), \(\eta=1/2\)): 'pc-euler-imp',; 'pc-euler-2' or 'pred-corr-2'. platenExplicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; general_stochastic. See eq. (7.47) of chapter 7 of [2]. Order strong 1.0, weak 2.0; Code: 'platen', 'platen1' or 'explicit1'. rouchonScheme keeping the positivity of the density matrix; (smesolve only). See eq. (4) with \(\eta=1\) of [3]. Order strong 1.0?; Code: 'rouchon' or 'Rouchon'. taylor1.5Order 1.5 strong Taylo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:109029,predict,predictor-correctorGeneralization,109029,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['predict'],['predictor-correctorGeneralization']
Safety,"tip.qobjevo. Source code for qutip.qobjevo; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline, interp1d; from functools import partial; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import (_compile_str_single, _compiled_coeffs,; _compiled_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. if qset.has_cython:; import cython; use_cython = [True]; else:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """""". def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:1288,safe,safePickle,1288,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,2,['safe'],['safePickle']
Safety,"to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(self, order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(self, sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(self, bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. norm(self, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:10664,safe,safebool,10664,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['safe'],['safebool']
Safety,"to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(self, order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(self, bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. norm(self, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters. normstrWhich norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:10552,safe,safebool,10552,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['safe'],['safebool']
Safety,"tum object (if operator,; no check) and state psi.; Return only the real part if herm.; *Faster after compilation. to_list():; Return the time-dependent quantum object as a list; """""". def __init__(self, Q_object=[], args={}, copy=True,; tlist=None, state0=None, e_ops=[]):; if isinstance(Q_object, QobjEvo):; if copy:; self._inplace_copy(Q_object); else:; self.__dict__ = Q_object.__dict__; if args:; self.arguments(args); for i, dargs in enumerate(self.dynamics_args):; e_int = dargs[1] == ""expect"" and isinstance(dargs[2], int); if e_ops and e_int:; self.dynamics_args[i] = (dargs[0], ""expect"",; e_ops[dargs[2]]); if state0 is not None:; self._dynamics_args_update(0., state0); return. self.const = False; self.dummy_cte = False; self.args = args.copy(); self.dynamics_args = []; self.cte = None; self.tlist = tlist; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.type = ""none""; self.omp = 0; self.coeff_files = []; self.use_cython = use_cython[0]; self.safePickle = safePickle[0]. if isinstance(Q_object, list) and len(Q_object) == 2:; if isinstance(Q_object[0], Qobj) and not isinstance(Q_object[1],; (Qobj, list)):; # The format is [Qobj, f/str]; Q_object = [Q_object]. op_type = self._td_format_check_single(Q_object, tlist); self.ops = []. if isinstance(op_type, int):; if op_type == 0:; self.cte = Q_object; self.const = True; self.type = ""cte""; elif op_type == 1:; raise Exception(""The Qobj must not already be a function""); elif op_type == -1:; pass; else:; op_type_count = [0, 0, 0, 0]; for type_, op in zip(op_type, Q_object):; if type_ == 0:; if self.cte is None:; self.cte = op; else:; self.cte += op; elif type_ == 1:; op_type_count[0] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""func"")); elif type_ == 2:; op_type_count[1] += 1; self.ops.append(EvoElement(op[0], _StrWrapper(op[1]),; op[1], ""string"")); elif type_ == 3:; op_type_count[2] += 1; self.ops.append(EvoElement(; op[0],; _CubicSplineWrapper(tlist, op[1], args=self.args),; op[1].copy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:13654,safe,safePickle,13654,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,2,['safe'],['safePickle']
Safety,"two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master eqautions with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructued.; QuTiP is now using continous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose func",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/changelog.html:5476,avoid,avoiding,5476,docs/3.0.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html,2,['avoid'],['avoiding']
Safety,"two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose fu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/changelog.html:8039,avoid,avoiding,8039,docs/3.1.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html,7,['avoid'],['avoiding']
Safety,"two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose fun",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:39795,avoid,avoiding,39795,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['avoid'],['avoiding']
Safety,"uce the adjoint of the coherent states to save an operation; # later when computing dot products, hence the negative imaginary part.; self.grid.imag = -y; self.prefactor = np.exp(-0.5 * (x * x + y * y)).astype(np.complex128). def _start(self, first: int):; """"""; Get the coherent state matrix corresponding to the first needed Fock; state.; """"""; if first == 0:; return self.prefactor.copy(); out = np.power(self.grid, first); out *= self.prefactor; return out. def __call__(self, first: int, last: int = None):; """"""; Get a 3D array of shape ``(yvec.size, xvec.size, last - first)`` of the; coherent-state vectors for all the Fock states in the range ``first``; to ``last``, excluding the end point. The first two axes are the y-; and x-coordinates of phase space (i.e. Cartesian indexing, like; ``numpy.meshgrid``), and the last runs over the selected range of; Fock-space dimensions.; """"""; ns = np.arange(first, last).reshape(1, 1, -1); # Technically we could avoid hitting the limits of floating-point; # exponents for longer by doing all this in logarithmic space (using; # scipy.special.gammaln), but that ends up involving more; # floating-point operations overall, and needs special care around the; # point alpha = 0 to avoid nan appearing, due to how Python handles; # mixed-width arithmetic operations.; out = np.empty(self.grid.shape + (ns.size,), dtype=np.complex128); out[:, :, 0] = self._start(ns.flat[0]); for i in range(ns.size - 1):; out[:, :, i+1] = out[:, :, i] * self.grid; out /= np.sqrt(scipy.special.factorial(ns)); return out. [docs]class QFunc:; r""""""; Class-based method of calculating the Husimi-Q function of many different; quantum states at fixed phase-space points ``0.5*g* (xvec + i*yvec)``.; This class has slightly higher first-usage costs than :obj:`.qfunc`, but; subsequent operations will be several times faster. However, it can require; quite a lot of memory. Call the created object as a function to retrieve; the Husimi-Q function. Parameters; ----------; xvec, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/wigner.html:20214,avoid,avoid,20214,docs/4.6/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html,4,['avoid'],['avoid']
Safety,"uch URI does not refer to the copyright notice or; licensing information for the Work; and (iv) , consistent with Section; 3(b), in the case of an Adaptation, a credit identifying the use of the; Work in the Adaptation (e.g., “French translation of the Work by Original; Author,” or “Screenplay based on original Work by Original Author”). The; credit required by this Section 4 (b) may be implemented in any; reasonable manner; provided, however, that in the case of a Adaptation or; Collection, at a minimum such credit will appear, if a credit for all; contributing authors of the Adaptation or Collection appears, then as; part of these credits and in a manner at least as prominent as the; credits for the other contributing authors. For the avoidance of doubt,; You may only use the credit required by this Section for the purpose of; attribution in the manner set out above and, by exercising Your rights; under this License, You may not implicitly or explicitly assert or imply; any connection with, sponsorship or endorsement by the Original Author,; Licensor and/or Attribution Parties, as appropriate, of You or Your use; of the Work, without the separate, express prior written permission of; the Original Author, Licensor and/or Attribution Parties.; Except as otherwise agreed in writing by the Licensor or as may be; otherwise permitted by applicable law, if You Reproduce, Distribute or; Publicly Perform the Work either by itself or as part of any Adaptations; or Collections, You must not distort, mutilate, modify or take other; derogatory action in relation to the Work which would be prejudicial to; the Original Author’s honor or reputation. Licensor agrees that in those; jurisdictions (e.g. Japan), in which any exercise of the right granted in; Section 3(b) of this License (the right to make Adaptations) would be; deemed to be a distortion, mutilation, modification or other derogatory; action prejudicial to the Original Author’s honor and reputation, the; Licensor will w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/copyright-1.html:12115,avoid,avoidance,12115,docs/4.7/copyright-1.html,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html,2,['avoid'],['avoidance']
Safety,"vements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.1.0 (in dev)¶. Improvements¶; Core libraries. erf supported function in td strings. QIP. Gate object can be used to instantiate another identical gate. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:1562,avoid,avoid,1562,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,1,['avoid'],['avoid']
Safety,"xt = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:23734,avoid,avoids,23734,docs/4.0.2/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html,1,['avoid'],['avoids']
Safety,"xt = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:23734,avoid,avoids,23734,docs/4.2/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html,1,['avoid'],['avoids']
Safety,"xt = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:23734,avoid,avoids,23734,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,1,['avoid'],['avoids']
Safety,"ython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=""avconv"", codec=""libx264""). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = video.encode(""base64""); video_tag = '<video controls src=""data:video/x-m4v;base64,{0}"">'.format(; video_encoded); r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/ipynbtools.html:11973,timeout,timeout,11973,docs/3.1.0/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/ipynbtools.html,1,['timeout'],['timeout']
Safety,"ython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<video controls src=""data:video/x-m4v;ba",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html:11379,timeout,timeout,11379,docs/4.2/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html,3,['timeout'],['timeout']
Safety,"ython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<video controls src=""data:video/x",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:11377,timeout,timeout,11377,docs/4.3/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html,7,['timeout'],['timeout']
Security," (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float. Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:Instance of an Optimizer, through which the. Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer. The optimisation can be run through the optimizer.run_optimization. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:; LIN - Linear,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:147865,access,accessed,147865,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['access'],['accessed']
Security," 256. Lagoudakis et al., ""Observation of Mollow Triplets with Tunable Interactions in Double Lambda Systems of Individual Hole Spins"", ; Phys. Rev. Lett. 118, 013602 (2017). 255. Pucci et al., ""Quantum effects in the cooperative scattering of light by atomic clouds"", ; Phys. Rev. A 95, 053625 (2017). 254. Gessner et al., ""Resolution-enhanced entanglement detection"", ; Phys. Rev. A 95, 032326 (2017). 253. Nigg et al., ""Superconducting Grid-Bus Surface Code Architecture for Hole-Spin Qubits"", ; Phys. Rev. Lett. 118, 147701 (2017). 252. Lüer et al., ""Lévy Defects in Matrix-Immobilized J Aggregates: Tracing Intra-and Intersegmental Exciton Relaxation"", ; J. Phys. Chem. Lett. 8, 547 (2017). 251. Dive et al., ""In situ upgrade of quantum simulators to universal computers"", ; arXiv:1701.01723. 250. Barnes et al., ""Fast microwave-driven three-qubit gates for cavity-coupled superconducting qubits"", ; Phys. Rev. B 96, 024504 (2017). 249. Hu, ""Spin-based single-photon transistor, dynamic random access memory, diodes, and routers in semiconductors"", ; Phys. Rev. B 94, 245307 (2016). 248. Leung et al., ""Speedup for quantum optimal control from automatic differentiation based on graphics processing units"", ; Phys. Rev. A 95, 042318 (2017). 247. Bruhat et al., ""Strong coupling between an electron in a quantum dot circuit and a photon in a cavity"", ; arXiv:1612.05214. 246. Zanoci et al., ""Entanglement and thermalization in open fermion systems"", ; arXiv:1612.04840. 245. Volokitin et al., ""Computation of the asymptotic states of modulated open quantum systems with a numerically exact realization of the quantum trajectory method"", ; Phys. Rev. E 96, 053313 (2017). 244. Montenegro et al., ""Macroscopic nonclassical-state preparation via postselection"", ; Phys. Rev. A 96, 053851 (2017). 243. Cirio et al., ""Amplified Optomechanical Transduction of Virtual Radiation Pressure"", ; Phys. Rev. Lett. 119, 053601 (2017). 242. Romero et al., ""Quantum autoencoders for efficient compression of quan",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:16025,access,access,16025,users.html,https://qutip.org,https://qutip.org/users.html,1,['access'],['access']
Security," 512 (2016). 207. Fischer et al., ""Dynamical modeling of pulsed two-photon interference"", ; New J. Phys. 18, 113053 (2016).; Notebook1; Notebook2. 206. Seifoory et al., ""The properties of squeezed optical states created in lossy cavities"", ; arXiv:1608.05005. 205. Qin et al., ""Heralded quantum controlled-phase gates with dissipative dynamics in macroscopically distant resonators"", ; Phys. Rev. A 96, 012315 (2017). 204. Cruzeiro et al., ""Interactively Applying the Variational Method to the Dihydrogen Molecule: Exploring Bonding and Antibonding"", ; Journal of Chemical Education (2016). 203. Pleinert et al., ""Quantum signatures of collective behavior of a coherently driven two atom system coupled to a single-mode of the electromagnetic field"", ; arXiv:1608.00137. 202. Wang et al., ""Multiple-output microwave single-photon source using superconducting circuits with longitudinal and transverse couplings"", ; Phys. Rev. A 94, 053858 (2016). 201. Marshall et al., ""Continuous-variable quantum computing on encrypted data"", ; Nat. Comm. 7, 13795 (2016). 200. Dajka et al., ""Leggett–Garg inequalities for a quantum top affected by classical noise"", ; J. Quantum Inf. Process. (2016). 199. Rouxinol et al., ""Measurements of nanoresonator-qubit interactions in a hybrid quantum electromechanical system"", ; Nanotechnology 27, 364003 (2016). 198. Hocker et al., ""PEET: a Matlab tool for estimating physical gate errors in quantum information processing systems"", ; Quantum Information Processing (2016). 197. Daskin, ""Quantum eigenvalue estimation for irreducible non-negative matrices"", ; Int. J. Quantum Inform. 14, 1650005 (2016). 196. Dlaska et al., ""Robust quantum state transfer via topologically protected edge channels in dipolar arrays"", ; Quantum Sci. Technol. 2, 015001 (2017). 195. Juliusson et al., ""Manipulating Fock states of a harmonic oscillator while preserving its linearity"", ; Phys. Rev. A 94, 063861 (2016). 194. Banchi et al., ""Quantum gate learning in qubit networks: Toffoli g",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:22561,encrypt,encrypted,22561,users.html,https://qutip.org,https://qutip.org/users.html,1,['encrypt'],['encrypted']
Security," =; [[0.]; [0.]; [0.]; [1.]; [0.]]. >>> coherent(5,0.5-0.5j); Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.7788017 +0.j ]; [ 0.38939142-0.38939142j]; [ 0. -0.27545895j]; [-0.07898617-0.07898617j]; [-0.04314271+0.j ]]. >>> destroy(4); Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. ]; [0. 0. 1.41421356 0. ]; [0. 0. 0. 1.73205081]; [0. 0. 0. 0. ]]. >>> sigmaz(); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. >>> jmat(5/2.0,'+'); Quantum object: dims = [[6], [6]], shape = (6, 6), type = oper, isherm = False; Qobj data =; [[0. 2.23606798 0. 0. 0. 0. ]; [0. 0. 2.82842712 0. 0. 0. ]; [0. 0. 0. 3. 0. 0. ]; [0. 0. 0. 0. 2.82842712 0. ]; [0. 0. 0. 0. 0. 2.23606798]; [0. 0. 0. 0. 0. 0. ]]. Qobj attributes¶; We have seen that a quantum object has several internal attributes, such as data, dims, and shape. These can be accessed in the following way:; >>> q = destroy(4). >>> q.dims; [[4], [4]]. >>> q.shape; (4, 4). In general, the attributes (properties) of a Qobj object (or any Python object) can be retrieved using the Q.attribute notation.; In addition to the those shown with the print function, an instance of the Qobj class also has the following attributes:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties needed to characterize a quantum operator or state vector.¶. For the destruction operator above:; >>> q.type; 'oper'. >>> q.isherm; False. >>> q.data; <4x4 sparse matrix of type '<class 'numpy.complex1",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-basics.html:7366,access,accessed,7366,docs/4.6/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html,4,['access'],['accessed']
Security," CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:2812,access,accessible,2812,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['access'],['accessible']
Security," CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it use",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:2841,access,accessible,2841,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['access'],['accessible']
Security," Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.pulseoptim. Source code for qutip.control.pulseoptim; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it use",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:1122,access,accessible,1122,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,2,['access'],['accessible']
Security," Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure-qutip_org. Tree-diagram of the 361 user accessible functions and classes in QuTiP 4.3. A vector image of the code tree is in qutip_tree.pdf. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-overview.html:1737,access,accessible,1737,docs/4.3/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-overview.html,1,['access'],['accessible']
Security," Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by type='super':; print(S). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; print(S.iscp, S.istp, S.iscptp). Output:; True True True. In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-states.html:19523,expose,exposed,19523,docs/4.6/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html,2,['expose'],['exposed']
Security," Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by type='super':; print(S). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; print(S.iscp, S.istp, S.iscptp). Output:; True True True. In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-states.html:19581,expose,exposed,19581,docs/4.7/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html,2,['expose'],['exposed']
Security," The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; args = {""_step_func_coeff"": True}. Examples of array-format usage are:; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; QobjEvo that contains different tlist values, however.; Passing arguments; args is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string.; There are some “magic” names that can be specified, whose objects will be; overwritten when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first paramete",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:19821,access,access,19821,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['access'],['access']
Security," The figure canvas on which the plot will be drawn.; ax (a matplotlib axis instance) – The axis context in which the plot will be drawn.; figsize ((width, height)) – The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. plot_qubism(ket, theme='light', how='pairs', grid_iteration=1, legend_iteration=0, fig=None, ax=None, figsize=(6, 6))[source]¶; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest.; More information:. J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; “Qubism: self-similar visualization of many-body wavefunctions”,; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters:; ket (Qobj) – Pure state for plotting.; theme ('light' (default) or 'dark') – Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb.; how ('pairs' (default), 'pairs_skewed' or 'before_after') – Type of Qubism plotting.; Options:. ‘pairs’ - typical coordinates,; ‘pairs_skewed’ - for ferromagnetic/antriferromagnetic plots,; ‘before_after’ - related to Schmidt plot (see also: plot_schmidt). grid_iteration (int (default 1)) – Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others.; legend_iteration (int (default 0) or 'grid_iteration' or 'all') – Show labels for first 2*legend_iteration particles.; Option ‘grid_iteration’ sets the same number of particles. as for grid_iteration.; Option ‘all’ makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. fig (a matplotlib figure instance) – The figure canvas on which the plot will be drawn.; ax (a matplotlib axis instance) – T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:124123,access,access,124123,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['access'],['access']
Security," a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/copyright-1.html:5812,access,access,5812,docs/4.7/copyright-1.html,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html,2,['access'],['access']
Security," basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:4713,access,access,4713,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,2,['access'],['access']
Security," deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:2633,hash,hash,2633,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,2,['hash'],['hash']
Security," figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis context in which the plot will be drawn. figsize : (width, height). The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. plot_qubism(ket, theme='light', how='pairs', grid_iteration=1, legend_iteration=0, fig=None, ax=None, figsize=(6, 6))[source]¶; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest. More information:; J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; “Qubism: self-similar visualization of many-body wavefunctions”,; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters:ket : Qobj. Pure state for plotting. theme : ‘light’ (default) or ‘dark’. Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : ‘pairs’ (default), ‘pairs_skewed’ or ‘before_after’. Type of Qubism plotting.; Options:. ‘pairs’ - typical coordinates,; ‘pairs_skewed’ - for ferromagnetic/antriferromagnetic plots,; ‘before_after’ - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1). Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or ‘grid_iteration’ or ‘all’. Show labels for first 2*legend_iteration particles.; Option ‘grid_iteration’ sets the same number of particles. as for grid_iteration. Option ‘all’ makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis contex",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:109645,access,access,109645,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['access'],['access']
Security," for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:181896,access,accessed,181896,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,4,['access'],['accessed']
Security," from the main repository.; Checkout a new private branch, starting from the head of the release branch (git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X).; You can call this branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use git log to find the relevant commits, going from oldest to newest (their “age” is when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:8445,hash,hash,8445,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['hash'],['hash']
Security," in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs':num_coeffs,; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:48497,access,accessible,48497,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['access'],['accessible']
Security," in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~qutip.control.optimresult.OptimResult`,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc.; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs':num_coeffs,; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take preced",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:47569,access,accessible,47569,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,2,['access'],['accessible']
Security," in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict. Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None. files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt : OptimResult. Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWAL",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:185403,access,accessible,185403,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['access'],['accessible']
Security," in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict. Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None. files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt : OptimResult. Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:160434,access,accessible,160434,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['access'],['accessible']
Security," in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict. Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None. files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt : OptimResult. Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are g",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:177254,access,accessible,177254,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['access'],['accessible']
Security," in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict. Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None. files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt : OptimResult. Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dyn",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:152181,access,accessible,152181,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['access'],['accessible']
Security," it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; self.rates = np.array([]); self.ampl = np.array([]); for ur_key in unique_rates.keys():; total_ampl = np.sum(np.asarray(ampl_dict[ur_key], dtype=object)). if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl, total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl,; np.asarray([total_ampl],; dtype=object)). return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/eseries.html:10322,access,accessing,10322,docs/4.5/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/eseries.html,1,['access'],['accessing']
Security," modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:183630,access,accessed,183630,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['access'],['accessed']
Security," operators for which to evaluate; expectation values. learningtimes : array_like; list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like; optional list of precomputed tensors \(T_k\). kwargs : dictionary; Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:; output: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelde",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:156942,access,accessible,156942,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['access'],['accessible']
Security," or list of operators for which to evaluate; expectation values. learningtimes : array_like. list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like. optional list of precomputed tensors \(T_k\). kwargs : dictionary. Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output: qutip.solver.Result. An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelde",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:142155,access,accessible,142155,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['access'],['accessible']
Security," the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector.¶. For the destruction operator above:; In [18]: q.type; Out[18]: 'oper'. In [19]: q.isherm; Out[19]: False. In [20]: q.data; Out[20]: ; <4x4 sparse matrix of type '<class 'numpy.complex128'>'; 	with 3 stored elements in Compressed Sparse Row format>. The data attribute returns a message stating that the data is a sparse matrix. All Qobj instances store their data as a sparse matrix to save memory. To access the underlying dense matrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; In [21]: q = destroy(4). In [22]: x = sigmax(). In [23]: q + 5; Out[23]: ; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. In [24]: x * x; Out[24]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. In [25]: q ** 3; Out[25]: ; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. In [26]: x / np.sqrt(2); Out[26]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible sha",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-basics.html:8705,access,access,8705,docs/4.5/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-basics.html,1,['access'],['access']
Security," to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:9184,hash,hashes,9184,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['hash'],['hashes']
Security," v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time']",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:25644,access,accessible,25644,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['access'],['accessible']
Security," value will be added; to any initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, gu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:219726,access,accessible,219726,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['access'],['accessible']
Security," ‘gray’. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.point_mode; Type of point markers to draw; sphere. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; ‘#808080’. b.size; Sets size of figure window; [500,500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45,65 ]. b.xlabel; Labels for x-axis; [‘|x>’, ‘’] +x and -x. b.xlpos; Position of x-axis labels; [1.07,-1.07]. b.ylabel; Labels for y-axis; [‘$y$’,’‘] +y and -y. b.ylpos; Position of y-axis labels; [1.07,-1.07]. b.zlabel; Labels for z-axis; [‘|0>’, ‘|1>’] +z and -z. b.zlpos; Position of z-axis labels; [1.07,-1.07]. These properties can also be accessed via the print command:; In [50]: b=Bloch(). In [51]: print(b); Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,... The Bloch sphere will automatically number the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-bloch.html:12817,access,accessed,12817,docs/3.0.0/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html,2,['access'],['accessed']
Security,", which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict. Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt : Optimizer. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:168831,access,accessed,168831,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['access'],['accessed']
Security,"- pe / 2., 0., 0., 1. - pe],; [0., pe / 2., 0., 0.],; [0., 0., pe / 2., 0.],; [1. - pe, 0., 0., 1. - pe / 2.]]),; superrep='choi'). # CHANGE OF BASIS FUNCTIONS ---------------------------------------------------; # These functions find change of basis matrices, and are useful in converting; # between (for instance) Choi and chi matrices. At some point, these should; # probably be moved out to another module. _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigmaz()). def _pauli_basis(nq=1):; # NOTE: This is slow as can be.; # TODO: Make this sparse. CSR format was causing problems for the [idx, :]; # slicing below.; B = zeros((4 ** nq, 4 ** nq), dtype=complex); dims = [[[2] * nq] * 2] * 2. for idx, op in enumerate(starmap(tensor,; product(_SINGLE_QUBIT_PAULI_BASIS,; repeat=nq))):; B[:, idx] = operator_to_vector(op).dag().full(). return Qobj(B, dims=dims). # PRIVATE CONVERSION FUNCTIONS ------------------------------------------------; # These functions handle the main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); dims = q_oper.dims; new_dims = [[dims[1][1], dims[0][1]], [dims[1][0], dims[0][0]]]; d0 = np.prod(np.ravel(new_dims[0])); d1 = np.prod(np.ravel(new_dims[1])); s0 = np.prod(dims[0][0]); s1 = np.prod(dims[1][1]); return Qobj(dims=new_dims,; inpt=data.reshape([s0, s1, s0, s1]).; transpose(3, 1, 2, 0).reshape((d0, d1))). def _isqubitdims(dims):; """"""Checks whether all entries ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html:5055,expose,exposed,5055,docs/4.6/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html,4,['expose'],['exposed']
Security,"-Phonon Interaction through Mode Field Coupling in Hybrid Optomechanical Systems"", ; Phys. Rev. Lett. 118, 133603 (2017). 224. Jonsson et al., ""Efficient determination of the Markovian time-evolution towards a steady-state of a complex open quantum system"", ; Comput. Phys. Commun. 220, 81 (2017). 223. Lahoz-Beltra, ""Quantum Genetic Algorithms for Computer Scientists"", ; Computers 5, 24 (2016). 222. Davis-Tilley et al., ""Synchronization of micromasers"", ; Phys. Rev. A 94, 063819 (2016). 221. Weinberg et al., ""QuSpin: a Python package for dynamics and exact diagonalisation of quantum many body systems part I: spin chains"", ; SciPost Phys. 2, 003 (2017). 220. Dory et al., ""Tuning the photon statistics of a strongly coupled nanophotonic system"", ; Phys. Rev. A 95, 023804 (2017). 219. Lachance-Quirion et al., ""Resolving quanta of collective spin excitations in a millimeter-sized ferromagnet"", ; Science Advances 3, (2017). 218. Doyeux et al., ""Excitation injector in an atomic chain: Long-range transport and efficiency amplification"", ; Phys. Rev. A 95, 012138 (2017). 217. Roulet et al., ""Autonomous Rotor Heat Engine"", ; Phys. Rev. E 95, 062131 (2017). 216. Nigg et al., ""Robust quantum optimizer with full connectivity"", ; Science Advances 3, 1602273 (2017). 215. Puri et al., ""Quantum annealing with all-to-all connected nonlinear oscillators"", ; Nat. Commun. 8, 15785 (2017).>. 214. Shi et al., ""Model reduction of cavity nonlinear optics for photonic logic: a quasi-principal components approach"", ; J. Phys. D: Appl. Phys. 49, 465501 (2016). 213. McNally et al., ""Performance of 1D quantum cellular automata in the presence of error"", ; AIP Advances 6, 095115 (2016). 212. Zhong et al., ""Towards quantum entanglement of micromirrors via a two-level atom and radiation pressure"", ; arXiv:1609.00590. 211. Roth et al., ""Synchronization of active atomic clocks via quantum and classical channels"", ; Phys. Rev. A 94, 043841 (2016). 210. Jarlov et al., ""Effect of Pure Dephasing and Phono",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:20177,inject,injector,20177,users.html,https://qutip.org,https://qutip.org/users.html,1,['inject'],['injector']
Security,"-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-overview.html:2470,access,accessible,2470,docs/3.0.1/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-overview.html,2,['access'],['accessible']
Security,". Dynamics Simulation Results — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class, the Result class has a collection of properties for storing information. However, in contrast to the Qobj class, this structure contains no methods, and is therefore nothing but a container object. A generic Result object result contains the following properties for storing simulation data:. Property; Description. resu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html:372,Access,Accessing,372,docs/4.6/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html,1,['Access'],['Accessing']
Security,". Dynamics Simulation Results — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class, the Result class has a collection of properties for storing information. However, in contrast to the Qobj class, this structure contains no methods, and is therefore nothing but a container object. A generic Result object result con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:386,Access,Accessing,386,docs/4.7/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html,1,['Access'],['Accessing']
Security,". Modifying Internal QuTiP Settings — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These setting",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-settings.html:638,Access,Accessible,638,docs/4.6/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-settings.html,1,['Access'],['Accessible']
Security,". Modifying Internal QuTiP Settings — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite sim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-settings.html:672,Access,Accessible,672,docs/4.7/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html,1,['Access'],['Accessible']
Security,". Wood, J. Biamonte, D. G. Cory, Tensor networks and graphical calculus for; open quantum systems. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Wis09; Wiseman, H. M. & Milburn, G. J. Quantum Measurement and Control, (Cambridge University Press, 2009). Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/biblio.html:2678,access,access,2678,docs/4.6/biblio.html,https://qutip.org,https://qutip.org/docs/4.6/biblio.html,1,['access'],['access']
Security,"., 0., 0., 1. - pe],; [0., pe / 2., 0., 0.],; [0., 0., pe / 2., 0.],; [1. - pe, 0., 0., 1. - pe / 2.]]),; superrep='choi'). # CHANGE OF BASIS FUNCTIONS ---------------------------------------------------; # These functions find change of basis matrices, and are useful in converting; # between (for instance) Choi and chi matrices. At some point, these should; # probably be moved out to another module. _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigmaz()). def _pauli_basis(nq=1):; # NOTE: This is slow as can be.; # TODO: Make this sparse. CSR format was causing problems for the [idx, :]; # slicing below.; B = zeros((4 ** nq, 4 ** nq), dtype=complex); dims = [[[2] * nq] * 2] * 2. for idx, op in enumerate(starmap(tensor,; product(_SINGLE_QUBIT_PAULI_BASIS,; repeat=nq))):; B[:, idx] = operator_to_vector(op).dag().data.todense(). return Qobj(B, dims=dims). # PRIVATE CONVERSION FUNCTIONS ------------------------------------------------; # These functions handle the main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); dims = q_oper.dims; new_dims = [[dims[1][1], dims[0][1]], [dims[1][0], dims[0][0]]]; d0 = np.prod(np.ravel(new_dims[0])); d1 = np.prod(np.ravel(new_dims[1])); s0 = np.prod(dims[0][0]); s1 = np.prod(dims[1][1]); return Qobj(dims=new_dims,; inpt=data.reshape([s0, s1, s0, s1]).; transpose(3, 1, 2, 0).reshape((d0, d1))). def _isqubitdims(dims):; """"""Checks whether all entries ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/superop_reps.html:5043,expose,exposed,5043,docs/4.5/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/superop_reps.html,1,['expose'],['exposed']
Security,"., 0., 0., 1. - pe],; [0., pe / 2., 0., 0.],; [0., 0., pe / 2., 0.],; [1. - pe, 0., 0., 1. - pe / 2.]]),; superrep='choi'). # CHANGE OF BASIS FUNCTIONS ---------------------------------------------------; # These functions find change of basis matrices, and are useful in converting; # between (for instance) Choi and chi matrices. At some point, these should; # probably be moved out to another module. _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigmaz()). def _pauli_basis(nq=1):; # NOTE: This is slow as can be.; # TODO: Make this sparse. CSR format was causing problems for the [idx, :]; # slicing below.; B = zeros((4 ** nq, 4 ** nq), dtype=complex); dims = [[[2] * nq] * 2] * 2. for idx, op in enumerate(starmap(tensor,; product(_SINGLE_QUBIT_PAULI_BASIS,; repeat=nq))):; B[:, idx] = operator_to_vector(op).dag().data.todense(). return Qobj(B, dims=dims). # PRIVATE CONVERSION FUNCTIONS ------------------------------------------------; # These functions handle the main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); sqrt_shape = int(sqrt(data.shape[0])); return Qobj(dims=q_oper.dims,; inpt=data.reshape([sqrt_shape] * 4).; transpose(3, 1, 2, 0).reshape(q_oper.data.shape)). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/superop_reps.html:5037,expose,exposed,5037,docs/4.1/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/superop_reps.html,5,['expose'],['exposed']
Security,"., 0., 0., 1. - pe],; [0., pe / 2., 0., 0.],; [0., 0., pe / 2., 0.],; [1. - pe, 0., 0., 1. - pe / 2.]]),; superrep='choi'). # CHANGE OF BASIS FUNCTIONS ---------------------------------------------------; # These functions find change of basis matrices, and are useful in converting; # between (for instance) Choi and chi matrices. At some point, these should; # probably be moved out to another module. _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigmaz()). def _pauli_basis(nq=1):; # NOTE: This is slow as can be.; # TODO: Make this sparse. CSR format was causing problems for the [idx, :]; # slicing below.; B = zeros((4 ** nq, 4 ** nq), dtype=complex); dims = [[[2] * nq] * 2] * 2. for idx, op in enumerate(starmap(tensor,; product(_SINGLE_QUBIT_PAULI_BASIS,; repeat=nq))):; B[:, idx] = operator_to_vector(op).dag().data.todense(). return Qobj(B, dims=dims). # PRIVATE CONVERSION FUNCTIONS ------------------------------------------------; # These functions handle the main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); sqrt_shape = int(sqrt(data.shape[0])); return Qobj(dims=q_oper.dims,; inpt=data.reshape([sqrt_shape] * 4).; transpose(3, 1, 2, 0).reshape(q_oper.data.shape)). def super_to_choi(q_oper):; # TODO: deprecate and make private in favor of to_choi,; # which looks at Qobj.type to determine the right conversion function.; """"""; Takes a superoperator to a Choi matrix; TODO: Sanitiz",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/superop_reps.html:6115,expose,exposed,6115,docs/3.1.0/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/superop_reps.html,1,['expose'],['exposed']
Security,"0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g.; optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; """""". # check parameters; if not isinstance(drift, Qobj):; raise TypeError(""drift must be a Qobj""); else:; drift = drift.full(). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; j = 0; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""); else:; ctrls[j] = ctrl.full(); j += 1. if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""); else:; initial = initial.full(). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); else:; target = target.full(). cfg = optimconfig.OptimConfig(); cfg.optim_alg = optim_alg; cfg.max_metric_corr = max_metric_corr; cfg.accuracy_factor = accuracy_factor; cfg.amp_update_mode = amp_update_mode; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:25747,access,accessed,25747,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['access'],['accessed']
Security,"2], [2]], [1]], shape = [4, 1], type = operator-ket; Qobj data =; [[ 0.]; [ 2.]; [ 1.]; [ 3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called supermatrices.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [93]: X = sigmax(). In [94]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [95]: S2 = to_super(X). In [96]: (S - S2).norm(); Out[96]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [97]: S; Out[97]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [98]: S.iscp, S.istp, S.iscptp; Out[98]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [99]: H = 10 * sigmaz(). In [100]: c1 = destroy(2). In [101]: L = liouvillian(H, [c1]). In [102]: L; Out[102]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = False; Qobj data =; [[ 0.0 +0.j 0.0 +0.j 0.0 +0.j 1.0 +0.j]; [ 0.0 +0.j -0.5+20.j 0.0 +0.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j -0.5-20.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j 0.0 +0.j -1.0 +0.j]]. In [103]: S = (12 * L).expm(). Once a superoperator has been obtained, it can be converted between the; supermatrix, Kraus and Choi formalisms by u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-states.html:20575,expose,exposed,20575,docs/3.1.0/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-states.html,1,['expose'],['exposed']
Security,"2], [2]], [1]], shape = [4, 1], type = operator-ket; Qobj data =; [[ 0.]; [ 2.]; [ 1.]; [ 3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called supermatrices.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [94]: X = sigmax(). In [95]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [96]: S2 = to_super(X). In [97]: (S - S2).norm(); Out[97]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [98]: S; Out[98]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [99]: S.iscp, S.istp, S.iscptp; Out[99]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [100]: H = 10 * sigmaz(). In [101]: c1 = destroy(2). In [102]: L = liouvillian(H, [c1]). In [103]: L; Out[103]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = False; Qobj data =; [[ 0.0 +0.j 0.0 +0.j 0.0 +0.j 1.0 +0.j]; [ 0.0 +0.j -0.5+20.j 0.0 +0.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j -0.5-20.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j 0.0 +0.j -1.0 +0.j]]. In [104]: S = (12 * L).expm(). Once a superoperator has been obtained, it can be converted between the; supermatrix, Kraus and Choi formalisms by ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-states.html:20355,expose,exposed,20355,docs/3.0.0/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html,2,['expose'],['exposed']
Security,"6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-settings.html:995,Access,Accessible,995,docs/4.6/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-settings.html,1,['Access'],['Accessible']
Security,"7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-settings.html:1054,Access,Accessible,1054,docs/4.7/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html,1,['Access'],['Accessible']
Security,"CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to ``None`` will suppress the output; of files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs': num_coeffs,; 'init_coeff_scaling': init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:38167,access,accessible,38167,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['access'],['accessible']
Security,"E: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_chi(q_oper)[source]¶; Converts a Choi matrix to a Chi matrix in the Pauli basis.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_kraus(q_oper, tol=1e-09)[source]¶; Takes a Choi matrix and returns a list of Kraus operators.; TODO: Create a new class structure for quantum channels, perhaps as a; strict sub-class of Qobj. choi_to_super(q_oper)[source]¶; Takes a Choi matrix to a superoperator; TODO: Sanitize input, Abstract-ify application of channels to states. kraus_to_choi(kraus_list)[source]¶; Takes a list of Kraus operators and returns the Choi matrix for the channel; represented by the Kraus operators in kraus_list. kraus_to_super(kraus_list)[source]¶; Converts a list of Kraus operators and returns a super operator. super_to_choi(q_oper)[source]¶; Takes a superoperator to a Choi matrix; TODO: Sanitize input, incorporate as method on Qobj if type==’super’. to_chi(q_oper)[source]¶; Converts a Qobj representing a quantum map to a representation as a chi; (process) matrix in the Pauli basis, such that the trace of the returned; operator is equal to the dimension of the system. Parameters. q_operQobjSuperoperator to be converted to Chi representation. If; q_oper is type=""oper"", then it is taken to act by conjugation,; such that to_chi(A) == to_chi(sprepost(A, A.dag())). Returns. chiQobjA quantum object representing the same map as q_oper, such that; chi.superrep == ""chi"". Raises. TypeError: if the given quantum object is not a map, or cannot be convertedto Chi representation. to_choi(q_oper)[source]¶; Converts a Qobj representing a quantum map to the Choi representation,; such that the trace of the returned operator is equal to the dimension; of the system. Parameters. q_operQobjSuperoperator to be converted to Choi representation. If; q_oper is type=""oper"", then it is t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:48139,Sanitiz,Sanitize,48139,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['Sanitiz'],['Sanitize']
Security,"Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float. Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:Instance of an Optimizer, through which the. Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer. The optimisation can be run through the optimizer.run_optimization. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:147762,access,accessed,147762,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['access'],['accessed']
Security,"Out[11]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.7788017 +0.j ]; [ 0.38939142-0.38939142j]; [ 0. -0.27545895j]; [-0.07898617-0.07898617j]; [-0.04314271+0.j ]]. In [12]: destroy(4); Out[12]: ; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. ]; [0. 0. 1.41421356 0. ]; [0. 0. 0. 1.73205081]; [0. 0. 0. 0. ]]. In [13]: sigmaz(); Out[13]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. In [14]: jmat(5/2.0,'+'); Out[14]: ; Quantum object: dims = [[6], [6]], shape = (6, 6), type = oper, isherm = False; Qobj data =; [[0. 2.23606798 0. 0. 0. 0. ]; [0. 0. 2.82842712 0. 0. 0. ]; [0. 0. 0. 3. 0. 0. ]; [0. 0. 0. 0. 2.82842712 0. ]; [0. 0. 0. 0. 0. 2.23606798]; [0. 0. 0. 0. 0. 0. ]]. Qobj attributes¶; We have seen that a quantum object has several internal attributes, such as data, dims, and shape. These can be accessed in the following way:; In [15]: q = destroy(4). In [16]: q.dims; Out[16]: [[4], [4]]. In [17]: q.shape; Out[17]: (4, 4). In general, the attributes (properties) of a Qobj object (or any Python class) can be retrieved using the Q.attribute notation. In addition to the attributes shown with the print function, the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector.¶. For the destruction operator above:; In [18]: q.type; Out[18]: 'oper'. In [19]: q.isherm; Out[19]: False. In [20]: q.data; Out[20]: ; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-basics.html:7416,access,accessed,7416,docs/4.5/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-basics.html,1,['access'],['accessed']
Security,"Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP cir",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html:1112,access,accessible,1112,docs/4.6/development/ideas/qutip-interactive.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html,2,['access'],['accessible']
Security,"The maximum depth for the hierarchy is {self.max_depth} but""; f"" {n} levels of excitation filters were given.""; ); if level is None:; if not filters:; # fast path for when there are no excitation filters; return self.labels[:]; else:; if not filters:; # fast path for when there are no excitation filters; return [label for label in self.labels if sum(label) == level]; if level != n:; raise ValueError(; f""The level parameter is {level} but {n} levels of""; "" excitation filters were given.""; ). filtered_dims = [1] * len(self.exponents); for lvl in range(n):; level_filters = [; (attr, f[lvl]) for attr, f in filters; if f[lvl] is not None; ]; for j, exp in enumerate(self.exponents):; if any(getattr(exp, attr) != f for attr, f in level_filters):; continue; filtered_dims[j] += 1; filtered_dims[j] = min(self.dims[j], filtered_dims[j]). return [; label for label in state_number_enumerate(filtered_dims, n); if sum(label) == n; ]. [docs]class HierarchyADOsState:; """"""; Provides convenient access to the full hierarchy ADO state at a particular; point in time, ``t``. Parameters; ----------; rho : :class:`~qutip.Qobj`; The current state of the system (i.e. the 0th component of the; hierarchy).; ados : :class:`HierarchyADOs`; The description of the hierarchy.; ado_state : numpy.array; The full state of the hierarchy. Attributes; ----------; rho : Qobj; The system state. In addition, all of the attributes of the hierarchy description,; i.e. ``HierarchyADOs``, are provided directly on this class for; convenience. E.g. one can access ``.labels``, or ``.exponents`` or; call ``.idx(label)`` directly. See :class:`HierarchyADOs` for a full list of the available attributes; and methods.; """"""; def __init__(self, rho, ados, ado_state):; self.rho = rho; self._ado_state = ado_state; self._ados = ados. def __getattr__(self, name):; return getattr(self._ados, name). [docs] def extract(self, idx_or_label):; """"""; Extract a Qobj representing specified ADO from a full representation of; the ADO state",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html:9063,access,access,9063,docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,2,['access'],['access']
Security,"], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[ 0.]; [ 2.]; [ 1.]; [ 3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [93]: X = sigmax(). In [94]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [95]: S2 = to_super(X). In [96]: (S - S2).norm(); Out[96]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [97]: S; Out[97]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [98]: S.iscp, S.istp, S.iscptp; Out[98]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [99]: H = 10 * sigmaz(). In [100]: c1 = destroy(2). In [101]: L = liouvillian(H, [c1]). In [102]: L; Out[102]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0.0 +0.j 0.0 +0.j 0.0 +0.j 1.0 +0.j]; [ 0.0 +0.j -0.5+20.j 0.0 +0.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j -0.5-20.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j 0.0 +0.j -1.0 +0.j]]. In [103]: S = (12 * L).expm(). For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-states.html:20370,expose,exposed,20370,docs/4.2/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-states.html,3,['expose'],['exposed']
Security,"_key; break. if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; self.rates = np.array([]); self.ampl = np.array([]); for ur_key in unique_rates.keys():; total_ampl = np.sum(np.asarray(ampl_dict[ur_key], dtype=object)). if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl, total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl,; np.asarray(total_ampl,; dtype=object)). return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/eseries.html:10436,access,accessing,10436,docs/4.3/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/eseries.html,1,['access'],['accessing']
Security,"added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:181999,access,accessed,181999,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,4,['access'],['accessed']
Security,"alculus for; open quantum systems. arXiv:1111.6950. [dAless08]; d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). [Kha05]; Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. [Byrd95]. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. [Flo12]. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. [Lloyd14]; Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. [Doria11]; Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. [Caneva11]; Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. [Rach15]; Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. [DYNAMO]; Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/biblio.html:3250,access,access,3250,docs/4.3/biblio.html,https://qutip.org,https://qutip.org/docs/4.3/biblio.html,1,['access'],['access']
Security,"antum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-overview.html:1775,access,accessible,1775,docs/4.6/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-overview.html,2,['access'],['accessible']
Security,"any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dic",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:58192,access,accessible,58192,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security,"any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:58274,access,accessible,58274,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['access'],['accessible']
Security,"any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(""drift should be a Qobj or a list of Qobj""). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""). if not isinstance(initial, Qobj):; ra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:58370,access,accessible,58370,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['access'],['accessible']
Security,"apses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~Qobj` or :class:`~QobjEvo`; The time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of ``[Qobj, time_dependence]`` pairs that are; summed to make the whole object. The ``time_dependence`` can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the ``Qobj`` instead; of the 2-element list. args : dict, optional; Mapping of ``{str: object}``, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the ""magic""; names used to access solver internals. tlist : array_like, optional; List of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in ``Q_object`` is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes; ----------; cte : :class:`~Qobj`; Constant part of the QobjEvo. ops : list of :class:`.EvoElement`; Internal representation of the time-dependence structure of the; elements. args : dict; The current value of the ``args`` dictionary passed into the; constructor. dynamics_args : list; Names of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the ``args`` parameter. tlist : array_like; List of times at which the numpy-array coefficients are applied. compiled : str; A string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevo : ``CQobjCt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:11180,access,access,11180,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,2,['access'],['access']
Security,"ation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _pa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:58108,access,accessed,58108,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,2,['access'],['accessed']
Security,"atter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure-qutip_org. Tree-diagram of the 361 user accessible functions and classes in QuTiP 4.4. A vector image of the code tree is in qutip_tree.pdf. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-overview.html:1733,access,accessible,1733,docs/4.4/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-overview.html,1,['access'],['accessible']
Security,"ave; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~qutip.Qobj` or :class:`~qutip.QobjEvo`; The time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of ``[Qobj, time_dependence]`` pairs that are; summed to make the whole object. The ``time_dependence`` can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the ``Qobj`` instead; of the 2-element list. args : dict, optional; Mapping of ``{str: object}``, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the ""magic""; names used to access solver internals. tlist : array_like, optional; List of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in ``Q_object`` is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes; ----------; cte : :class:`~qutip.Qobj`; Constant part of the QobjEvo. ops : list of :class:`.EvoElement`; Internal representation of the time-dependence structure of the; elements. args : dict; The current value of the ``args`` dictionary passed into the; constructor. dynamics_args : list; Names of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the ``args`` parameter. tlist : array_like; List of times at which the numpy-array coefficients are applied. compiled : str; A string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevo : ``C",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:9509,access,access,9509,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,2,['access'],['access']
Security,"ay'. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; ['r', 'g', 'b', 'y']. b.point_mode; Type of point markers to draw; 'sphere'. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; '#808080'. b.size; Sets size of figure window; [500, 500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; ['r', 'g', 'b', 'y']. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45, 65]. b.xlabel; Labels for x-axis; ['|x>', ''] +x and -x. b.xlpos; Position of x-axis labels; [1.07, -1.07]. b.ylabel; Labels for y-axis; ['$y$', ''] +y and -y. b.ylpos; Position of y-axis labels; [1.07, -1.07]. b.zlabel; Labels for z-axis; ['|0>', '|1>'] +z and -z. b.zlpos; Position of z-axis labels; [1.07, -1.07]. These properties can also be accessed via the print command:; >>> b = qutip.Bloch(). >>> print(b) ; Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,… The Bloch sphere will automatically number the o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-bloch.html:11064,access,accessed,11064,docs/4.6/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html,4,['access'],['accessed']
Security,"be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iterationint (default 0) or ‘grid_iteration’ or ‘all’Show labels for first 2*legend_iteration particles. Option; ‘grid_iteration’ sets the same number of particles as for; grid_iteration. Option ‘all’ makes label for all particles. Typically; it should be 0, 1, 2 or perhaps 3. figa matplotlib figure instanceThe figure canvas on which the plot will be drawn. axa matplotlib axis instanceThe axis context in which the plot will be drawn. figsize(width, height)The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Notes; See also [1].; References. 1; J. Rodriguez-Laguna, P. Migdal, M. Ibanez Berganza, M. Lewenstein; and G. Sierra, Qubism: self-similar visualization of many-body; wavefunctions, New J. Phys. 14 053028, arXiv:1112.3560; (2012), open access. plot_schmidt(ket, splitting=None, labels_iteration=(3, 2), theme='light', fig=None, ax=None, figsize=(6, 6))[source]¶; Plotting scheme related to Schmidt decomposition.; Converts a state into a matrix (A_ij -> A_i^j),; where rows are first particles and columns - last.; See also: plot_qubism with how=’before_after’ for a similar plot. Parameters. ketQobjPure state for plotting. splittingintPlot for a number of first particles versus the rest.; If not given, it is (number of particles + 1) // 2. theme‘light’ (default) or ‘dark’Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. labels_iterationint or pair of ints (default (3,2))Number of particles to be shown as tick labels,; for first (vertical) and last (horizontal) particles, respectively. figa matplotlib figure instanceThe figure canvas on which the plot will be drawn. axa matplotlib axis instanceThe axis context in which the plot will be drawn. figsize(width, height)The size of the m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:172550,access,access,172550,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['access'],['access']
Security,"bject result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. result.seeds; Seeds used in generating random numbers for Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-data.html:3173,access,access,3173,docs/4.2/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-data.html,7,['access'],['access']
Security,"bject result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. result.seeds; Seeds used in generating random numbers for Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html:2851,access,access,2851,docs/4.6/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html,6,"['Access', 'access']","['Accessing', 'access']"
Security,"cle. style : 'ket' (default), 'bra' or 'bare'; Style of LaTeX (i.e. |01> or <01| or 01, respectively). Returns; -------; latex : str; LaTeX output. """"""; if style == 'ket':; latex = ""$\\left|{0}\\right\\rangle$""; elif style == 'bra':; latex = ""$\\left\\langle{0}\\right|$""; elif style == 'bare':; latex = ""${0}$""; else:; raise Exception(""No such style.""); return latex.format("""".join(map(str, seq))). [docs]def plot_qubism(ket, theme='light', how='pairs',; grid_iteration=1, legend_iteration=0,; fig=None, ax=None, figsize=(6, 6)):; """"""; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest. More information:; J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; ""Qubism: self-similar visualization of many-body wavefunctions"",; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters; ----------; ket : Qobj; Pure state for plotting. theme : 'light' (default) or 'dark'; Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : 'pairs' (default), 'pairs_skewed' or 'before_after'; Type of Qubism plotting.; Options:; 'pairs' - typical coordinates,; 'pairs_skewed' - for ferromagnetic/antriferromagnetic plots,; 'before_after' - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1); Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or 'grid_iteration' or 'all'; Show labels for first 2*legend_iteration particles.; Option 'grid_iteration' sets the same number of particles; as for grid_iteration.; Option 'all' makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance; T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html:33758,access,access,33758,docs/3.1.0/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html,1,['access'],['access']
Security,"d in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:186973,access,accessible,186973,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['access'],['accessible']
Security,"d in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:162168,access,accessible,162168,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['access'],['accessible']
Security,"d in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:178887,access,accessible,178887,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['access'],['accessible']
Security,"d in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:153973,access,accessible,153973,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['access'],['accessible']
Security,"d_iteration' or 'all'; Show labels for first ``2*legend_iteration`` particles. Option; 'grid_iteration' sets the same number of particles as for; grid_iteration. Option 'all' makes label for all particles. Typically; it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance; The axis context in which the plot will be drawn. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no 'fig' and 'ax' arguments are passed). Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Notes; -----; See also [1]_. References; ----------; .. [1] J. Rodriguez-Laguna, P. Migdal, M. Ibanez Berganza, M. Lewenstein; and G. Sierra, *Qubism: self-similar visualization of many-body; wavefunctions*, `New J. Phys. 14 053028; <https://dx.doi.org/10.1088/1367-2630/14/5/053028>`_, arXiv:1112.3560; (2012), open access.; """""". if not isket(ket):; raise Exception(""Qubism works only for pure states, i.e. kets.""); # add for dm? (perhaps a separate function, plot_qubism_dm). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). dim_list = ket.dims[0]; n = len(dim_list). # for odd number of particles - pixels are rectangular; if n % 2 == 1:; ket = tensor(ket, Qobj([1] * dim_list[-1])); dim_list = ket.dims[0]; n += 1. ketdata = ket.full(). if how == 'pairs':; dim_list_y = dim_list[::2]; dim_list_x = dim_list[1::2]; elif how == 'pairs_skewed':; dim_list_y = dim_list[::2]; dim_list_x = dim_list[1::2]; if dim_list_x != dim_list_y:; raise Exception(""For 'pairs_skewed' pairs "" +; ""of dimensions need to be the same.""); elif how == 'before_after':; dim_list_y = list(reversed(dim_list[:(n // 2)])); dim_list_x = dim_list[(n // 2):]; else:; raise Exception(""No such 'how'.""). size_x = np.prod(dim_list_x); size_y = np.prod(dim_list_y). qub = np.zeros([size_x, size_y], dtype=complex); for i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/visualization.html:42916,access,access,42916,docs/4.7/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/visualization.html,2,['access'],['access']
Security,"dd it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; self.rates = np.array([]); self.ampl = np.array([]); for ur_key in unique_rates.keys():; total_ampl = np.sum(np.asarray(ampl_dict[ur_key], dtype=object)). if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl, total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl,; np.asarray([total_ampl],; dtype=object)). return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/eseries.html:10309,access,accessing,10309,docs/4.4/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/eseries.html,1,['access'],['accessing']
Security,"dded; to any initial / guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:58768,access,accessible,58768,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['access'],['accessible']
Security,"dded; to any initial / guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:183436,access,accessible,183436,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['access'],['accessible']
Security,"derneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:16804,access,access,16804,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['access'],['access']
Security,"do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:; expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; times = result.times. we can plot the resulting expectation values:; plot(times, expt0, times, expt1); show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html:3898,access,access,3898,docs/4.6/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html,4,['access'],['access']
Security,"e print function, an instance of the Qobj class also has the following attributes:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties needed to characterize a quantum operator or state vector.¶. For the destruction operator above:; >>> q.type; 'oper'. >>> q.isherm; False. >>> q.data; <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. The data attribute returns a message stating that the data is a sparse matrix. All Qobj instances store their data as a sparse matrix to save memory. To access the underlying dense matrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; >>> print(q * x); -----------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-basics.html:8602,access,access,8602,docs/4.6/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html,4,['access'],['access']
Security,"e(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (see PulseGen classes for details). pulse_scaling : float; Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g.; optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; """""". # check parameters; if not isinstance(drift, Qobj):; raise TypeError(""drift must be a Qobj""); else:; drift = drift.full(). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; j = 0; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""); else:; ctrls[j] = ctrl.full(); j += 1. if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""); else:; initial = initial.full(). if not isinstance(target, Qobj):; raise TypeEr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:25459,access,accessible,25459,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security,"e. label) match the given filters or level. idx(label)[source]¶; Return the index of the ADO label within the list of labels,; i.e. within self.labels. Parameters. labeltupleThe label to look up. Returns. intThe index of the label within the list of ADO labels. next(label, k)[source]¶; Return the ADO label with one more excitation in the k’th exponent; dimension or None if adding the excitation would exceed the; dimension or maximum depth of the hierarchy. Parameters. labeltupleThe ADO label to add an excitation to. kintThe exponent to add the excitation to. Returns. tuple or NoneThe next label. prev(label, k)[source]¶; Return the ADO label with one fewer excitation in the k’th; exponent dimension or None if the label has no exciations in the; k’th exponent. Parameters. labeltupleThe ADO label to remove the excitation from. kintThe exponent to remove the excitation from. Returns. tuple or NoneThe previous label. class HierarchyADOsState(rho, ados, ado_state)[source]¶; Provides convenient access to the full hierarchy ADO state at a particular; point in time, t. Parameters. rhoQobjThe current state of the system (i.e. the 0th component of the; hierarchy). adosHierarchyADOsThe description of the hierarchy. ado_statenumpy.arrayThe full state of the hierarchy. Attributes. rhoQobjThe system state. In addition, all of the attributes of the hierarchy description,; i.e. ``HierarchyADOs``, are provided directly on this class for; convenience. E.g. one can access ``.labels``, or ``.exponents`` or; call ``.idx(label)`` directly.; See :class:`HierarchyADOs` for a full list of the available attributes; and methods. extract(idx_or_label)[source]¶; Extract a Qobj representing specified ADO from a full representation of; the ADO states. Parameters. idxint or labelThe index of the ADO to extract. If an ADO label, e.g.; (0, 1, 0, ...) is supplied instead, then the ADO; is extracted by label instead. Returns. QobjA Qobj representing the state of the specified ADO. class HSolverDL(H_sys,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:67292,access,access,67292,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,2,['access'],['access']
Security,"e. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:183733,access,accessed,183733,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['access'],['accessed']
Security,"e. style : 'ket' (default), 'bra' or 'bare'; Style of LaTeX (i.e. |01> or <01| or 01, respectively). Returns; -------; latex : str; LaTeX output. """"""; if style == 'ket':; latex = ""$\\left|{0}\\right\\rangle$""; elif style == 'bra':; latex = ""$\\left\\langle{0}\\right|$""; elif style == 'bare':; latex = ""${0}$""; else:; raise Exception(""No such style.""); return latex.format("""".join(map(str, seq))). [docs]def plot_qubism(ket, theme='light', how='pairs',; grid_iteration=1, legend_iteration=0,; fig=None, ax=None, figsize=(6, 6)):; """"""; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest. More information:; ; J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; ""Qubism: self-similar visualization of many-body wavefunctions"",; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters; ----------; ket : Qobj; Pure state for plotting. theme : 'light' (default) or 'dark'; Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : 'pairs' (default), 'pairs_skewed' or 'before_after'; Type of Qubism plotting.; Options:; ; 'pairs' - typical coordinates,; 'pairs_skewed' - for ferromagnetic/antriferromagnetic plots,; 'before_after' - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1); Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or 'grid_iteration' or 'all'; Show labels for first 2*legend_iteration particles.; Option 'grid_iteration' sets the same number of particles; as for grid_iteration.; Option 'all' makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/visualization.html:31932,access,access,31932,docs/4.1/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/visualization.html,6,['access'],['access']
Security,"e_tol:; idx = ur_key; break; if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; rates, ampl = [], []; for ur_key in unique_rates.keys():; total_ampl = sum(ampl_dict[ur_key]); if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); self.rates = np.array(rates); self.ampl = np.empty((len(ampl),), dtype=object); self.ampl[:] = ampl; return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/eseries.html:10363,access,accessing,10363,docs/4.6/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/eseries.html,2,['access'],['accessing']
Security,"ed for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:220017,access,accessed,220017,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['access'],['accessed']
Security,"ed in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr'",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:14209,access,accessible,14209,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['access'],['accessible']
Security,"ed in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~qutip.control.optimresult.OptimResult`,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc.; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecatio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:12724,access,accessible,12724,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,2,['access'],['accessible']
Security,"ed; to any initial / guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:57906,access,accessible,57906,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,2,['access'],['accessible']
Security,"ededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initialQobjThe evolution operator from t=0 to t=T based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:89408,access,access,89408,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,6,['access'],['access']
Security,"edfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide.html:3106,Access,Accessible,3106,docs/4.7/guide/guide.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html,1,['Access'],['Accessible']
Security,em Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permu,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-dynamics.html:1299,Access,Accessing,1299,docs/4.6/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-dynamics.html,1,['Access'],['Accessing']
Security,"em Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-overview.html:2408,access,accessible,2408,docs/3.0.0/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-overview.html,2,['access'],['accessible']
Security,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:38032,access,accessible,38032,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,10,['access'],['accessible']
Security,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs':num_coeffs,; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:37665,access,accessible,37665,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,2,['access'],['accessible']
Security,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' para",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:13968,access,accessible,13968,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:13869,access,accessible,13869,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,5,['access'],['accessible']
Security,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # check parameters here, as names are different than in; # create_pulse_optimizer, so TypeErrors would be confusing. if not isinstance(H_d, Qobj):; if not isinstance(H_d, (list, tuple)):; raise TypeError(""H_d should be a Qobj or a list of Qobj""); else:; for H in H_d:; if not isinstance(H, Qobj):; raise TypeError(""H_d should be a Qobj or a list of Qobj""). if not isinstance(H_c, (list, tuple)):; raise TypeError(""H_c should be a list of Qobj""); else:; for ctrl in H_c:; if not isinstance(ctrl, Qobj):; raise TypeError(""H_c should be a list of Qobj""). if not isinstance(U_0, Qobj):; raise TypeError(""U_0 must be a Qobj""). if not isinstance(U_targ, Qobj):; raise TypeError(""U_targ must be a Qobj""); ; # The deprecation",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:26651,access,accessible,26651,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['access'],['accessible']
Security,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # parameters are checked in create pulse optimiser. # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'acc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:26843,access,accessible,26843,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # parameters are checked in create pulse optimiser; ; # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if no",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:26872,access,accessible,26872,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['access'],['accessible']
Security,"erty; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector. For the destruction operator above:; In [14]: q.type; Out[14]: 'oper'. In [15]: q.isherm; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-basics.html:10126,access,access,10126,docs/4.2/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-basics.html,4,['access'],['access']
Security,"fetch upstream to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X).; You can call this branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use git log to find the relevant commits, going from oldest to newest (their “age” is when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:8388,hash,hash,8388,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['hash'],['hash']
Security,"figa matplotlib figure instanceThe figure canvas on which the plot will be drawn. axa matplotlib axis instanceThe axis context in which the plot will be drawn. figsize(width, height)The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. plot_qubism(ket, theme='light', how='pairs', grid_iteration=1, legend_iteration=0, fig=None, ax=None, figsize=(6, 6))[source]¶; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest.; More information:. J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; “Qubism: self-similar visualization of many-body wavefunctions”,; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters. ketQobjPure state for plotting. theme‘light’ (default) or ‘dark’Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how‘pairs’ (default), ‘pairs_skewed’ or ‘before_after’Type of Qubism plotting.; Options:. ‘pairs’ - typical coordinates,; ‘pairs_skewed’ - for ferromagnetic/antriferromagnetic plots,; ‘before_after’ - related to Schmidt plot (see also: plot_schmidt). grid_iterationint (default 1)Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iterationint (default 0) or ‘grid_iteration’ or ‘all’Show labels for first 2*legend_iteration particles.; Option ‘grid_iteration’ sets the same number of particles. as for grid_iteration. Option ‘all’ makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. figa matplotlib figure instanceThe figure canvas on which the plot will be drawn. axa matplotlib axis instanceThe axis context in which the plot will be drawn.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:137086,access,access,137086,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['access'],['access']
Security,"figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis context in which the plot will be drawn. figsize : (width, height). The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. plot_qubism(ket, theme='light', how='pairs', grid_iteration=1, legend_iteration=0, fig=None, ax=None, figsize=(6, 6))[source]¶; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest.; More information:. J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; “Qubism: self-similar visualization of many-body wavefunctions”,; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters:ket : Qobj. Pure state for plotting. theme : ‘light’ (default) or ‘dark’. Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : ‘pairs’ (default), ‘pairs_skewed’ or ‘before_after’. Type of Qubism plotting.; Options:. ‘pairs’ - typical coordinates,; ‘pairs_skewed’ - for ferromagnetic/antriferromagnetic plots,; ‘before_after’ - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1). Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or ‘grid_iteration’ or ‘all’. Show labels for first 2*legend_iteration particles.; Option ‘grid_iteration’ sets the same number of particles. as for grid_iteration. Option ‘all’ makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis contex",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:122913,access,access,122913,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['access'],['access']
Security,"generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). optim = create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=num_tslots, evo_time=evo_time, tau=tau,; amp_lbound=amp_lbound, amp_ubound=amp_ubound,; fid_err_targ=fid_err_targ, min_grad=min_grad,; max_iter=max_iter, max_wall_time=max_wall_time,; optim_alg=optim_alg, max_metric_corr=max_metric_corr,; accuracy_factor=accuracy_factor,; dyn_type=dyn_type, prop_type=prop_type,; fid_type=fid_type, phase_option=phase_option,; fid_err_scale_factor=fid_err_scale_factor,; amp_update_mode=amp_update_mode, init_pulse_type=init_pulse_type,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:10629,access,accessible,10629,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security,"generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # check parameters here, as names are different than in; # create_pulse_optimizer, so TypeErrors would be confusing. if not isinstance(H_d, Qobj):; raise TypeError(""H_d must be a Qobj""). if not isinstance(H_c, (list, tuple)):; raise TypeError(""H_c should be a list of Qobj""); else:; for ctrl in H_c:; if not isinstance(ctrl, Qobj):; raise TypeError(""H_c should be a list of Qobj""). if not isinstance(U_0, Qobj):; raise TypeError(""U_0 must be a Qobj""). if not isinstance(U_targ, Qobj):; raise TypeError(""U_targ must be a Qobj""). return optimize_pulse(drift=H_d, ctrls=H_c, initial=U_0, target=U_targ,; num_tslots=num_tslots, evo_time=evo_time, tau=tau,; amp_lbound=amp_lbound, amp_ubound=amp_ubound,; fid_err_targ=fid_err_targ, min_grad=mi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:18369,access,accessible,18369,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['access'],['accessible']
Security,"gure instance; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance; The axis context in which the plot will be drawn. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. plot_qubism(ket, theme='light', how='pairs', grid_iteration=1, legend_iteration=0, fig=None, ax=None, figsize=(6, 6))[source]¶; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest.; More information:. J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; “Qubism: self-similar visualization of many-body wavefunctions”,; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters:; ket : Qobj; Pure state for plotting. theme : ‘light’ (default) or ‘dark’; Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : ‘pairs’ (default), ‘pairs_skewed’ or ‘before_after’; Type of Qubism plotting.; Options:. ‘pairs’ - typical coordinates,; ‘pairs_skewed’ - for ferromagnetic/antriferromagnetic plots,; ‘before_after’ - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1); Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or ‘grid_iteration’ or ‘all’; Show labels for first 2*legend_iteration particles.; Option ‘grid_iteration’ sets the same number of particles. as for grid_iteration. Option ‘all’ makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance; The axis cont",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:137569,access,access,137569,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['access'],['access']
Security,"heir filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in setup.cfg, and that any changes to the build process are reflected in meta.yml.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:18820,checksum,checksum,18820,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['checksum'],['checksum']
Security,"hon. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Code of conduct; As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities.; We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality.; Examples of unacceptable behavior by participants include:. The use of sexualized language or imagery; Personal attacks; Trolling or insulting/derogatory comments; Public or private harassment; Publishing other’s private information, such as physical or electronic addresses, without explicit permission; Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team.; This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community.; Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers.; This Code of Conduct is adapted from the Contributor Covenant, version",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/cofc.html:995,attack,attacks,995,cofc.html,https://qutip.org,https://qutip.org/cofc.html,1,['attack'],['attacks']
Security,"id_iteration' or 'all'; Show labels for first ``2*legend_iteration`` particles. Option; 'grid_iteration' sets the same number of particles as for; grid_iteration. Option 'all' makes label for all particles. Typically; it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance; The axis context in which the plot will be drawn. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no 'fig' and 'ax' arguments are passed). Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Notes; -----; See also [1]_. References; ----------; .. [1] J. Rodriguez-Laguna, P. Migdal, M. Ibanez Berganza, M. Lewenstein; and G. Sierra, *Qubism: self-similar visualization of many-body; wavefunctions*, `New J. Phys. 14 053028; <http://dx.doi.org/10.1088/1367-2630/14/5/053028>`_, arXiv:1112.3560; (2012), open access.; """""". if not isket(ket):; raise Exception(""Qubism works only for pure states, i.e. kets.""); # add for dm? (perhaps a separate function, plot_qubism_dm). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). dim_list = ket.dims[0]; n = len(dim_list). # for odd number of particles - pixels are rectangular; if n % 2 == 1:; ket = tensor(ket, Qobj([1] * dim_list[-1])); dim_list = ket.dims[0]; n += 1. ketdata = ket.full(). if how == 'pairs':; dim_list_y = dim_list[::2]; dim_list_x = dim_list[1::2]; elif how == 'pairs_skewed':; dim_list_y = dim_list[::2]; dim_list_x = dim_list[1::2]; if dim_list_x != dim_list_y:; raise Exception(""For 'pairs_skewed' pairs "" +; ""of dimensions need to be the same.""); elif how == 'before_after':; dim_list_y = list(reversed(dim_list[:(n // 2)])); dim_list_x = dim_list[(n // 2):]; else:; raise Exception(""No such 'how'.""). size_x = np.prod(dim_list_x); size_y = np.prod(dim_list_y). qub = np.zeros([size_x, size_y], dtype=complex); for i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/visualization.html:37109,access,access,37109,docs/4.6/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/visualization.html,2,['access'],['access']
Security,"ide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-overview.html:1834,access,accessible,1834,docs/4.7/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html,2,['access'],['accessible']
Security,"idelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())). if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed. if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None. if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False. if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/tslotcomp.html:8736,access,access,8736,docs/4.4/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/tslotcomp.html,1,['access'],['access']
Security,"iew of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-overview.html:2509,access,accessible,2509,docs/3.1.0/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-overview.html,2,['access'],['accessible']
Security,"ing : float; Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g.; optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; """""". # check parameters; if not isinstance(drift, Qobj):; raise TypeError(""drift must be a Qobj""); else:; drift = drift.full(). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; j = 0; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""); else:; ctrls[j] = ctrl.full(); j += 1. if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""); else:; initial = initial.full(). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); else:; target = target.full(). cfg = optimconfig.OptimConfig(); cfg.optim_alg = optim_alg; cfg.max_metric_corr = max_metric_corr; cfg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:25644,access,accessed,25644,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['access'],['accessed']
Security,"ing modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. Return type:Optimizer. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[sour",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:170506,access,accessed,170506,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['access'],['accessed']
Security,"interpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the map as. (2)\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{mn} \chi_{mn} B_m \rho_{\rm in} B_n^\dagger.\]; where \(\chi_{mn} = \sum_{ij} b_{im}b_{jn}^*\) and \(A_i = \sum_{m} b_{im}B_{m}\). Here, matrix \(\chi\) is the transformation matrix we are after, since it describes how much \(B_m \rho_{\rm in} B_n^\dagger\) contributes to \(\rho_{\rm out}\).; In a numerical simulation of a quantum process we usually do not have access to the quantum map in the form Eq. (1). Instead, what we usually can do is to calculate the propagator \(U\) for the density matrix in superoperator form, using for example the QuTiP function qutip.propagator.propagator. We can then write. \[\epsilon(\tilde{\rho}_{\rm in}) = U \tilde{\rho}_{\rm in} = \tilde{\rho}_{\rm out}\]; where \(\tilde{\rho}\) is the vector representation of the density matrix \(\rho\). If we write Eq. (2) in superoperator form as well we obtain. \[\tilde{\rho}_{\rm out} = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger \tilde{\rho}_{\rm in} = U \tilde{\rho}_{\rm in}.\]; so we can identify. \[U = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger.\]; Now this is a linear equation systems for the \(N^2 \times N^2\) elements in \(\chi\). We can solve it by writing \(\chi\) and the superoperator propagator as \([N^4]\) vectors, and likewise write the superoperator product \(\tilde{B}_m\tilde{B}_n^\dagger\) as a \([N^4\times N^4]\) matrix \(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-visualization.html:13401,access,access,13401,docs/3.0.0/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-visualization.html,3,['access'],['access']
Security,"ion; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP cir",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:1155,access,accessible,1155,docs/4.7/development/ideas/qutip-interactive.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html,2,['access'],['accessible']
Security,"ious version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in setup.cfg, and that any changes to the build process are reflected in meta.yml.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:19257,checksum,checksum,19257,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['checksum'],['checksum']
Security,"is purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. Return type:Optimizer. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combine",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:170609,access,accessed,170609,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['access'],['accessed']
Security,"is value will be added; to any initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, gue",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:181708,access,accessible,181708,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,4,['access'],['accessible']
Security,"it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use git log to find the relevant commits, going from oldest to newest (their “age” is when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a ver",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:8663,hash,hash,8663,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['hash'],['hash']
Security,"ity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html:8758,access,access,8758,docs/4.1/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html,9,['access'],['access']
Security,"key; break. if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; self.rates = np.array([]); self.ampl = np.array([]); for ur_key in unique_rates.keys():; total_ampl = np.sum(np.asarray(ampl_dict[ur_key], dtype=object)). if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl, total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl,; np.asarray(total_ampl,; dtype=object)). return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/eseries.html:10436,access,accessing,10436,docs/4.0.2/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/eseries.html,1,['access'],['accessing']
Security,"key; break. if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; self.rates = np.array([]); self.ampl = np.array([]); for ur_key in unique_rates.keys():; total_ampl = np.sum(np.asarray(ampl_dict[ur_key], dtype=object)). if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl, total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl,; np.asarray(total_ampl,; dtype=object)). return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/eseries.html:10436,access,accessing,10436,docs/4.2/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/eseries.html,1,['access'],['accessing']
Security,"key; break. if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; self.rates = np.array([]); self.ampl = np.array([]); for ur_key in unique_rates.keys():; total_ampl = np.sum(np.asarray(ampl_dict[ur_key], dtype=object)). if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl, total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl,; np.asarray(total_ampl,; dtype=object)). return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/eseries.html:10436,access,accessing,10436,docs/4.1/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/eseries.html,1,['access'],['accessing']
Security,"lapsed during the optimisation. wall_time_limit_exceeded; (boolean) True if the wall time limit was reached. time; (array[num_tslots+1] of float) Time are the start of each timeslot with the final value being the total evolution time. initial_amps; (array[num_tslots, n_ctrls]) The amplitudes at the start of the optimisation. final_amps; (array[num_tslots, n_ctrls]) The amplitudes at the end of the optimisation. evo_full_final; (Qobj) The evolution operator from t=0 to t=T based on the final amps. stats; (Stats) Object contaning the stats for the run (if any collected). optimizer; (Optimizer) Instance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However; Attributes. num_ctrls. dyn_gen. prop. prop_grad. fwd_evo. onwd_evo. onto_evo. dumping. log_level; (integer) level of messaging output from the logger. Options are attributes of qutip.logging_utils, in decreasing levels of messaging, are: DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL Anything WARN or above is effectively ‘quiet’ execution, assuming everything runs as expected. The default NOTSET implies that the level will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:72650,access,access,72650,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['access'],['access']
Security,"lculus for; open quantum systems. arXiv:1111.6950. [dAless08]; d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). [Kha05]; Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. [Byrd95]. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. [Flo12]. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. [Lloyd14]; Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. [Doria11]; Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. [Caneva11]; Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. [Rach15]; Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. [DYNAMO]; Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/biblio.html:3250,access,access,3250,docs/4.2/biblio.html,https://qutip.org,https://qutip.org/docs/4.2/biblio.html,1,['access'],['access']
Security,"legend(loc=0, fontsize=12). The plot above is not very exciting. What we would really like to see in; this case are the currents between the system and the two baths. We will plot; these in the next section using the auxiliary density operators (ADOs); returned by the solver. Determining currents¶; The currents between the system and a fermionic bath may be calculated from the; first level auxiliary density operators (ADOs) associated with the exponents; of that bath.; The contribution to the current into a given bath from each exponent in that; bath is:. \[\mathrm{Contribution from Exponent} = \pm i \mathrm{Tr}(Q^\pm \cdot A)\]; where the \(\pm\) sign is the sign of the exponent (see the; description later in Padé expansion coefficients) and; \(Q^\pm\) is \(Q\) for + exponents and \(Q^{\dagger}\) for; - exponents.; The first-level exponents for the left bath are retrieved by calling; .filter(tags=[""L""]) on ado_state which is an instance of; HierarchyADOsState and also provides access to; the methods of HierarchyADOs which describes the; structure of the hierarchy for a given problem.; Here the tag “L” matches the tag passed when constructing bath_L earlier; in this example.; Similarly, we may calculate the current to the right bath from the exponents; tagged with “R”.; def exp_current(aux, exp):; """""" Calculate the current for a single exponent. """"""; sign = 1 if exp.type == exp.types[""+""] else -1; op = exp.Q if exp.type == exp.types[""+""] else exp.Q.dag(); return 1j * sign * (op * aux).tr(). def heom_current(tag, ado_state):; """""" Calculate the current between the system and the given bath. """"""; level_1_ados = [; (ado_state.extract(label), ado_state.exps(label)[0]); for label in ado_state.filter(tags=[tag]); ]; return np.real(sum(exp_current(aux, exp) for aux, exp in level_1_ados)). heom_left_current = lambda t, ado_state: heom_current(""L"", ado_state); heom_right_current = lambda t, ado_state: heom_current(""R"", ado_state). Once we have defined functions for retrieving",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/fermionic.html:6956,access,access,6956,docs/4.7/guide/heom/fermionic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html,2,['access'],['access']
Security,"lf.oper_dtype = None; self.cache_phased_dyn_gen = None; self.cache_prop_grad = None; self.cache_dyn_gen_eigenvectors_adj = None; self.sparse_eigen_decomp = None; self.dyn_dims = None; self.dyn_shape = None; self.sys_dims = None; self.sys_shape = None; self.time_depend_drift = False; self.time_depend_ctrl_dyn_gen = False; # These internal attributes will be of the internal operator data type; # used to compute the evolution; # Note this maybe ndarray, Qobj or some other depending on oper_dtype; self._drift_dyn_gen = None; self._ctrl_dyn_gen = None; self._phased_ctrl_dyn_gen = None; self._dyn_gen_phase = None; self._phase_application = None; self._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._evo_initialized = False; self._timeslots_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = Non",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:15388,access,accessors,15388,docs/4.3/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html,3,['access'],['accessors']
Security,"m object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.77880170+0.j ]; [ 0.38939142-0.38939142j]; [ 0.00000000-0.27545895j]; [-0.07898617-0.07898617j]; [-0.04314271+0.j ]]. In [11]: destroy(4); Out[11]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. ]; [ 0. 0. 1.41421356 0. ]; [ 0. 0. 0. 1.73205081]; [ 0. 0. 0. 0. ]]. In [12]: sigmaz(); Out[12]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. In [13]: jmat(5/2.0,'+'); Out[13]: ; Quantum object: dims = [[6], [6]], shape = [6, 6], type = oper, isherm = False; Qobj data =; [[ 0. 2.23606798 0. 0. 0. 0. ]; [ 0. 0. 2.82842712 0. 0. 0. ]; [ 0. 0. 0. 3. 0. 0. ]; [ 0. 0. 0. 0. 2.82842712 0. ]; [ 0. 0. 0. 0. 0. 2.23606798]; [ 0. 0. 0. 0. 0. 0. ]]. Qobj attributes¶; We have seen that a quantum object has several internal attributes, such as data, dims, and shape. These can be accessed in the following way:; In [14]: q = destroy(4). In [15]: q.dims; Out[15]: [[4], [4]]. In [16]: q.shape; Out[16]: [4, 4]. In general, the attributes (properties) of a Qobj object (or any Python class) can be retrieved using the Q.attribute notation. In addition to the attributes shown with the print function, the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector. For the destruction operator above:; In [17]: q.type; Out[17]: 'oper'. In [18]: q.isherm; Out[18]: False. In [19]: q.data; Out[19]: ; <4",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-basics.html:7393,access,accessed,7393,docs/3.0.0/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html,3,['access'],['accessed']
Security,"mensions. choi_to_kraus(q_oper, tol=1e-09)[source]¶; Takes a Choi matrix and returns a list of Kraus operators.; TODO: Create a new class structure for quantum channels, perhaps as a; strict sub-class of Qobj. choi_to_super(q_oper)[source]¶; Takes a Choi matrix to a superoperator; TODO: Sanitize input, Abstract-ify application of channels to states. kraus_to_choi(kraus_ops)[source]¶; Convert a list of Kraus operators into Choi representation of the channel.; Essentially, kraus operators are a decomposition of a Choi matrix,; so in this function we build Choi matrix from vector representation of Kraus operators. Parameters. kraus_opslist[Qobj]The list of Kraus operators to be converted to Choi representation. Returns. choiQobjA quantum object representing the same map as kraus_ops, such that; choi.superrep == ""choi"". kraus_to_super(kraus_list)[source]¶; Converts a list of Kraus operators and returns a super operator. super_to_choi(q_oper)[source]¶; Takes a superoperator to a Choi matrix; TODO: Sanitize input, incorporate as method on Qobj if type==’super’. to_chi(q_oper)[source]¶; Converts a Qobj representing a quantum map to a representation as a chi; (process) matrix in the Pauli basis, such that the trace of the returned; operator is equal to the dimension of the system. Parameters. q_operQobjSuperoperator to be converted to Chi representation. If; q_oper is type=""oper"", then it is taken to act by conjugation,; such that to_chi(A) == to_chi(sprepost(A, A.dag())). Returns. chiQobjA quantum object representing the same map as q_oper, such that; chi.superrep == ""chi"". Raises. TypeError: if the given quantum object is not a map, or cannot be convertedto Chi representation. to_choi(q_oper)[source]¶; Converts a Qobj representing a quantum map to the Choi representation,; such that the trace of the returned operator is equal to the dimension; of the system. Parameters. q_operQobjSuperoperator to be converted to Choi representation. If; q_oper is type=""oper"", then it is t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:48374,Sanitiz,Sanitize,48374,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['Sanitiz'],['Sanitize']
Security,"mes of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; ``args = {""_step_func_coeff"": True}``. Examples of array-format usage are:. .. code-block:: python. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; ``QobjEvo`` that contains different ``tlist`` values, however. **Passing arguments**. ``args`` is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string. There are some ""magic"" names that can be specified, whose objects will be; overwritten when used within :func:`.sesolve`, :func:`.mesolve` and; :func:`.mcsolve`. This allows access to the solvers' internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. - ``""state""``: the current state as a :class:`~Qobj`; - ``""state_vec""``: the current state as a column-stacked 1D ``np.ndarray``; - ``""state_mat""``: the current state as a 2D ``np.ndarray``; - ``""expect_op_<n>""``: the current expectation value of the element; ``e_ops[n]``, which is an argument to the solvers. Replace ``<n>`` with; an integer literal, e.g. ``""expect_op_0""``. This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; - ``""collapse""``: (:func:`.mcsolve` only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:9428,access,access,9428,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,2,['access'],['access']
Security,"mes of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; ``args = {""_step_func_coeff"": True}``. Examples of array-format usage are:. .. code-block:: python. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; ``QobjEvo`` that contains different ``tlist`` values, however. **Passing arguments**. ``args`` is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string. There are some ""magic"" names that can be specified, whose objects will be; overwritten when used within :func:`.sesolve`, :func:`.mesolve` and; :func:`.mcsolve`. This allows access to the solvers' internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. - ``""state""``: the current state as a :class:`~qutip.Qobj`; - ``""state_vec""``: the current state as a column-stacked 1D ``np.ndarray``; - ``""state_mat""``: the current state as a 2D ``np.ndarray``; - ``""expect_op_<n>""``: the current expectation value of the element; ``e_ops[n]``, which is an argument to the solvers. Replace ``<n>`` with; an integer literal, e.g. ``""expect_op_0""``. This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; - ``""collapse""``: (:func:`.mcsolve` only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :cl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:7739,access,access,7739,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,2,['access'],['access']
Security,"mit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps. stats : Stats; Object contaning the stats for the run (if any collected). optimizer : Optimizer; Instance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:83648,access,access,83648,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['access'],['access']
Security,"mplemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:200208,access,accessible,200208,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['access'],['accessible']
Security,"mplemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:175227,access,accessible,175227,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['access'],['accessible']
Security,"mplemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:192055,access,accessible,192055,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['access'],['accessible']
Security,"mplemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:166970,access,accessible,166970,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['access'],['accessible']
Security,"ms. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Wis09; Wiseman, H. M. & Milburn, G. J. Quantum Measurement and Control, (Cambridge University Press, 2009). NKanej; N Khaneja et. al. Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005). doi:10.1016/j.jmr.2004.11.004. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/biblio.html:2703,access,access,2703,docs/4.7/biblio.html,https://qutip.org,https://qutip.org/docs/4.7/biblio.html,1,['access'],['access']
Security,"ms. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Kha05. Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/biblio.html:3229,access,access,3229,docs/4.5/biblio.html,https://qutip.org,https://qutip.org/docs/4.5/biblio.html,1,['access'],['access']
Security,"n CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils` in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to ``None`` will suppress the output; of files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """""". # parameters are checked in create pulse optimiser. # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:27265,access,accessible,27265,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['access'],['accessible']
Security,"n CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils` in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to ``None`` will suppress the output; of files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~qutip.control.optimresult.OptimResult`,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc.; """""". # parameters are checked in create pulse optimiser. # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:25969,access,accessible,25969,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,2,['access'],['accessible']
Security,"n, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:58395,access,accessed,58395,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['access'],['accessed']
Security,"n, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:58477,access,accessed,58477,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['access'],['accessed']
Security,"n, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(""drift should be a Qobj or a list of Qobj""). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:58573,access,accessed,58573,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['access'],['accessed']
Security,"nd the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[\begin{split}i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\end{split}\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:3138,access,accessible,3138,docs/3.0.0/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html,3,['access'],['accessible']
Security,"ng_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:59073,access,accessed,59073,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['access'],['accessed']
Security,"nique_rates.keys():; if abs(self.rates[r_idx] - unique_rates[ur_key]) < rate_tol:; idx = ur_key; break; if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; rates, ampl = [], []; for ur_key in unique_rates.keys():; total_ampl = sum(ampl_dict[ur_key]); if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); self.rates = np.array(rates); self.ampl = np.empty((len(ampl),), dtype=object); self.ampl[:] = ampl; return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/eseries.html:8634,access,accessing,8634,docs/4.7/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/eseries.html,2,['access'],['accessing']
Security,"nsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelde",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:155819,access,accessible,155819,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,4,['access'],['accessible']
Security,"nts); for lvl in range(n):; level_filters = [; (attr, f[lvl]) for attr, f in filters; if f[lvl] is not None; ]; for j, exp in enumerate(self.exponents):; if any(getattr(exp, attr) != f for attr, f in level_filters):; continue; filtered_dims[j] += 1; filtered_dims[j] = min(self.dims[j], filtered_dims[j]). return [; label for label in state_number_enumerate(filtered_dims, n); if sum(label) == n; ]. [docs]class HierarchyADOsState:; """"""; Provides convenient access to the full hierarchy ADO state at a particular; point in time, ``t``. Parameters; ----------; rho : :class:`~qutip.Qobj`; The current state of the system (i.e. the 0th component of the; hierarchy).; ados : :class:`HierarchyADOs`; The description of the hierarchy.; ado_state : numpy.array; The full state of the hierarchy. Attributes; ----------; rho : Qobj; The system state. In addition, all of the attributes of the hierarchy description,; i.e. ``HierarchyADOs``, are provided directly on this class for; convenience. E.g. one can access ``.labels``, or ``.exponents`` or; call ``.idx(label)`` directly. See :class:`HierarchyADOs` for a full list of the available attributes; and methods.; """"""; def __init__(self, rho, ados, ado_state):; self.rho = rho; self._ado_state = ado_state; self._ados = ados. def __getattr__(self, name):; return getattr(self._ados, name). [docs] def extract(self, idx_or_label):; """"""; Extract a Qobj representing specified ADO from a full representation of; the ADO states. Parameters; ----------; idx : int or label; The index of the ADO to extract. If an ADO label, e.g.; ``(0, 1, 0, ...)`` is supplied instead, then the ADO; is extracted by label instead. Returns; -------; Qobj; A :obj:`~qutip.Qobj` representing the state of the specified ADO.; """"""; if isinstance(idx_or_label, int):; idx = idx_or_label; else:; idx = self._ados.idx(idx_or_label); return Qobj(self._ado_state[idx, :].T, dims=self.rho.dims). [docs]class HEOMSolver:; """"""; HEOM solver that supports multiple baths. The baths must be al",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html:9605,access,access,9605,docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,2,['access'],['access']
Security,"ny initial / guess pulses generated. ramping_pulse_type : string. Type of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict. Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt : Optimizer. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:168639,access,accessible,168639,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['access'],['accessible']
Security,"o methods, and is therefore nothing but a container object. A generic Result object result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html:3520,access,access,3520,docs/3.0.0/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html,2,['access'],['access']
Security,"o not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To access the data for the two expectation values one can do:; >>> expt0 = result.expect[0]; >>> expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; >>> times = result.times. we can plot the resulting expectation values:; >>> plot(times, expt0, times, expt1); >>> show(). Data for expectation values extracted from the result Result object. State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html:4566,access,access,4566,docs/3.0.0/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html,2,['access'],['access']
Security,"o not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To access the data for the two expectation values one can do:; >>> expt0 = result.expect[0]; >>> expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; >>> times = result.times. we can plot the resulting expectation values:; >>> plot(times, expt0, times, expt1); >>> show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qut",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-data.html:4219,access,access,4219,docs/4.2/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-data.html,7,['access'],['access']
Security,"of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:11017,access,access,11017,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,2,['access'],['access']
Security,olver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutation,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-dynamics.html:1401,Access,Accessing,1401,docs/4.7/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html,1,['Access'],['Accessing']
Security,"om the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:; expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; times = result.times. we can plot the resulting expectation values:; plot(times, expt0, times, expt1); show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a “.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_res",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html:4387,access,accessed,4387,docs/4.6/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html,4,['access'],['accessed']
Security,"on, the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector. For the destruction operator above:; In [17]: q.type; Out[17]: 'oper'. In [18]: q.isherm; Out[18]: False. In [19]: q.data; Out[19]: ; <4x4 sparse matrix of type '<type 'numpy.complex128'>'; 	with 3 stored elements in Compressed Sparse Row format>. The data attribute returns a message stating that the data is a sparse matrix. All Qobj instances store their data as a sparse matrix to save memory. To access the underlying dense matrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; In [20]: q = destroy(4). In [21]: x = sigmax(). In [22]: q + 5; Out[22]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 5. 1. 0. 0. ]; [ 0. 5. 1.41421356 0. ]; [ 0. 0. 5. 1.73205081]; [ 0. 0. 0. 5. ]]. In [23]: x * x; Out[23]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 1.]]. In [24]: q ** 3; Out[24]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 0. 0. 2.44948974]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]]. In [25]: x / np.sqrt(2); Out[25]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.70710678]; [ 0.70710678 0. ]]. Of course, like matrices, multiplying two objects of inco",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-basics.html:8791,access,access,8791,docs/3.1.0/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-basics.html,1,['access'],['access']
Security,"on, the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector. For the destruction operator above:; In [17]: q.type; Out[17]: 'oper'. In [18]: q.isherm; Out[18]: False. In [19]: q.data; Out[19]: ; <4x4 sparse matrix of type '<type 'numpy.complex128'>'; 	with 3 stored elements in Compressed Sparse Row format>. The data attribute returns a message stating that the data is a sparse matrix. All Qobj instances store their data as a sparse matrix to save memory. To access the underlying dense matrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; In [20]: q = destroy(4). In [21]: x = sigmax(). In [22]: q + 5; Out[22]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 5. 1. 0. 0. ]; [ 0. 5. 1.41421356 0. ]; [ 0. 0. 5. 1.73205081]; [ 0. 0. 0. 5. ]]. In [23]: x * x; Out[23]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 1.]]. In [24]: q ** 3; Out[24]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 0. 0. 2.44948974]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]]. In [25]: x / sqrt(2); Out[25]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.70710678]; [ 0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-basics.html:8679,access,access,8679,docs/3.0.0/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html,2,['access'],['access']
Security,"only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:224052,access,accessible,224052,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['access'],['accessible']
Security,"only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:232530,access,accessible,232530,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['access'],['accessible']
Security,"only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:236167,access,accessible,236167,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['access'],['accessible']
Security,"only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:244648,access,accessible,244648,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['access'],['accessible']
Security,"only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:216080,access,accessible,216080,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['access'],['accessible']
Security,"operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the “magic”; names used to access solver internals. tlistarray_like, optionalList of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in Q_object is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes. cteQobjConstant part of the QobjEvo. opslist of EvoElementInternal representation of the time-dependence structure of the; elements. argsdictThe current value of the args dictionary passed into the; constructor. dynamics_argslistNames of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstrA string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obta",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:21421,access,access,21421,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['access'],['access']
Security,"operator-ket’. Returns. Qobj or QobjEvoThe same object, but re-cast into “standard” operator form. The output; is the same type as the passed object. Superoperator Representations¶; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms. chi_to_choi(q_oper)[source]¶; Converts a Chi matrix to a Choi matrix.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_chi(q_oper)[source]¶; Converts a Choi matrix to a Chi matrix in the Pauli basis.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_kraus(q_oper, tol=1e-09)[source]¶; Takes a Choi matrix and returns a list of Kraus operators.; TODO: Create a new class structure for quantum channels, perhaps as a; strict sub-class of Qobj. choi_to_super(q_oper)[source]¶; Takes a Choi matrix to a superoperator; TODO: Sanitize input, Abstract-ify application of channels to states. kraus_to_choi(kraus_list)[source]¶; Takes a list of Kraus operators and returns the Choi matrix for the channel; represented by the Kraus operators in kraus_list. kraus_to_super(kraus_list)[source]¶; Converts a list of Kraus operators and returns a super operator. super_to_choi(q_oper)[source]¶; Takes a superoperator to a Choi matrix; TODO: Sanitize input, incorporate as method on Qobj if type==’super’. to_chi(q_oper)[source]¶; Converts a Qobj representing a quantum map to a representation as a chi; (process) matrix in the Pauli basis, such that the trace of the returned; operator is equal to the dimension of the system. Parameters. q_operQobjSuperoperator to be converted to Chi representation. If; q_oper is type=""oper"", then it is taken to act by conjugation,; such that to_chi(A) == to_chi(sprepost(A, A.dag())). Returns. chiQobjA quantum object representing the same map as q_oper, such that; chi.superrep == ""chi"".",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:47732,Sanitiz,Sanitize,47732,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['Sanitiz'],['Sanitize']
Security,"operator-ket’. Returns. Qobj or QobjEvoThe same object, but re-cast into “standard” operator form. The output; is the same type as the passed object. Superoperator Representations¶; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms. chi_to_choi(q_oper)[source]¶; Converts a Chi matrix to a Choi matrix.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_chi(q_oper)[source]¶; Converts a Choi matrix to a Chi matrix in the Pauli basis.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_kraus(q_oper, tol=1e-09)[source]¶; Takes a Choi matrix and returns a list of Kraus operators.; TODO: Create a new class structure for quantum channels, perhaps as a; strict sub-class of Qobj. choi_to_super(q_oper)[source]¶; Takes a Choi matrix to a superoperator; TODO: Sanitize input, Abstract-ify application of channels to states. kraus_to_choi(kraus_ops)[source]¶; Convert a list of Kraus operators into Choi representation of the channel.; Essentially, kraus operators are a decomposition of a Choi matrix,; so in this function we build Choi matrix from vector representation of Kraus operators. Parameters. kraus_opslist[Qobj]The list of Kraus operators to be converted to Choi representation. Returns. choiQobjA quantum object representing the same map as kraus_ops, such that; choi.superrep == ""choi"". kraus_to_super(kraus_list)[source]¶; Converts a list of Kraus operators and returns a super operator. super_to_choi(q_oper)[source]¶; Takes a superoperator to a Choi matrix; TODO: Sanitize input, incorporate as method on Qobj if type==’super’. to_chi(q_oper)[source]¶; Converts a Qobj representing a quantum map to a representation as a chi; (process) matrix in the Pauli basis, such that the trace of the returned; operator is equal to the dimension o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:47654,Sanitiz,Sanitize,47654,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['Sanitiz'],['Sanitize']
Security,"or a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a contro",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:219914,access,accessed,219914,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['access'],['accessed']
Security,"ors for which to evaluate; expectation values.; learningtimes (array_like) – list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\).; tensors (array_like) – optional list of precomputed tensors \(T_k\); kwargs (dictionary) – Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output – An instance of the class qutip.solver.Result. Return type:qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelde",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:144004,access,accessible,144004,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['access'],['accessible']
Security,"ose. ramping_pulse_params : dict. Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt : Optimizer. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:168934,access,accessed,168934,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['access'],['accessed']
Security,"ould be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:5889,access,access,5889,docs/4.2/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html,8,['access'],['access']
Security,"ow to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:2136,hash,hash,2136,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,2,['hash'],['hash']
Security,"pulse_params : dict; Parameters for the ramping pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:58211,access,accessed,58211,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,2,['access'],['accessed']
Security,"pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:58498,access,accessed,58498,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['access'],['accessed']
Security,"pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:58580,access,accessed,58580,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['access'],['accessed']
Security,"pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(""drift should be a Qobj or a list of Qobj""). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not ma",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:58676,access,accessed,58676,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['access'],['accessed']
Security,"pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float. Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None. files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:Returns instance of OptimResult, which has attributes giving the. reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=-inf, amp_ubound=inf, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=10000000.0, dyn_type='GEN_MAT', prop_type='DEF', fid_type='DEF', phase_option=None, fid_err_scale_factor=None, amp_update_mode='ALL', init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the alg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:141683,access,accessible,141683,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['access'],['accessible']
Security,"pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float. Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None. files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:Returns instance of OptimResult, which has attributes giving the. reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=-inf, amp_ubound=inf, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=10000000.0, phase_option='PSU', amp_update_mode='ALL', init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0, log_level=0, out_file_ext='.txt', gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:136137,access,accessible,136137,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['access'],['accessible']
Security,"r offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ramping_pulse_type (string) – Type of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. Return type:Optimizer. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, g",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:170325,access,accessible,170325,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['access'],['accessible']
Security,"rator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.transfertensor.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelde",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:210357,access,accessible,210357,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['access'],['accessible']
Security,"requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:11099,access,accessible,11099,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,4,['access'],['accessible']
Security,"ributes used for processing evolution; self.memory_optimization = 0; self.oper_dtype = None; self.cache_phased_dyn_gen = None; self.cache_prop_grad = None; self.cache_dyn_gen_eigenvectors_adj = None; self.sparse_eigen_decomp = None; self.dyn_dims = None; self.dyn_shape = None; self.sys_dims = None; self.sys_shape = None; self.time_depend_drift = False; # These internal attributes will be of the internal operator data type; # used to compute the evolution; # Note this maybe ndarray, Qobj or some other depending on oper_dtype; self._drift_dyn_gen = None; self._ctrl_dyn_gen = None; self._phased_ctrl_dyn_gen = None; self._dyn_gen_phase = None; self._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._timeslots_initialized = False; self._ctrls_initialized = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computer",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:14141,access,accessors,14141,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,2,['access'],['accessors']
Security,"rview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure-qutip_org. Tree-diagram of the 361 user accessible functions and classes in QuTiP 4.4. A vector image of the code tree is in qutip_tree.pdf. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-overview.html:1778,access,accessible,1778,docs/4.5/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-overview.html,1,['access'],['accessible']
Security,"s = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [93]: X = sigmax(). In [94]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [95]: S2 = to_super(X). In [96]: (S - S2).norm(); Out[96]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [97]: S; Out[97]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [98]: S.iscp, S.istp, S.iscptp; Out[98]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [99]: H = 10 * sigmaz(). In [100]: c1 = destroy(2). In [101]: L = liouvillian(H, [c1]). In [102]: L; Out[102]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. In [103]: S = (12 * L).expm(). For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S_{\mu,\nu} = \",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-states.html:20205,expose,exposed,20205,docs/4.3/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html,1,['expose'],['exposed']
Security,"s = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [94]: X = sigmax(). In [95]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [96]: S2 = to_super(X). In [97]: (S - S2).norm(); Out[97]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [98]: S; Out[98]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [99]: S.iscp, S.istp, S.iscptp; Out[99]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [100]: H = 10 * sigmaz(). In [101]: c1 = destroy(2). In [102]: L = liouvillian(H, [c1]). In [103]: L; Out[103]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. In [104]: S = (12 * L).expm(). For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S_{\mu,\nu} = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-states.html:20516,expose,exposed,20516,docs/4.4/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-states.html,2,['expose'],['exposed']
Security,"s branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use git log to find the relevant commits, going from oldest to newest (their “age” is when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will eith",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:8619,hash,hash,8619,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['hash'],['hash']
Security,"s only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RN",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:240603,access,accessible,240603,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['access'],['accessible']
Security,"s only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RN",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:252721,access,accessible,252721,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['access'],['accessible']
Security,"s only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_extstring or Nonefiles containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RN",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:198116,access,accessible,198116,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['access'],['accessible']
Security,"s only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_extstring or Nonefiles containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:173706,access,accessible,173706,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['access'],['accessible']
Security,"s only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_extstring or Nonefiles containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:190140,access,accessible,190140,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['access'],['accessible']
Security,"s only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_extstring or Nonefiles containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:165641,access,accessible,165641,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['access'],['accessible']
Security,"s to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Windows¶. Important; Installation on Windows has changed substantially as of QuTiP 4.1. The only supported installation configuration is using the Conda environment with Python 3.5+ and Visual Studio 2015. We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work, but are not supported.; As of QuTiP 4.1, recommended installation on Windows requires Python 3.5+, as well as Visual Studio 2015. With this configuration, one can install QuTiP using any of the above mentioned receipes. Visual Studio 2015 is not required for the install of the conda-forge package, but it is required at runtime for the string format time-dependence solvers. When installing Visual Studio 2015 be sure to select options for the C++ compiler.; The ‘Community’ edition of Visual Studio 2015 is free to download use, however it does require ap",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:5877,access,access,5877,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,5,['access'],['access']
Security,"s. labeltupleThe ADO label to add an excitation to. kintThe exponent to add the excitation to. Returns. tuple or NoneThe next label. prev(label, k)[source]¶; Return the ADO label with one fewer excitation in the k’th; exponent dimension or None if the label has no exciations in the; k’th exponent. Parameters. labeltupleThe ADO label to remove the excitation from. kintThe exponent to remove the excitation from. Returns. tuple or NoneThe previous label. class HierarchyADOsState(rho, ados, ado_state)[source]¶; Provides convenient access to the full hierarchy ADO state at a particular; point in time, t. Parameters. rhoQobjThe current state of the system (i.e. the 0th component of the; hierarchy). adosHierarchyADOsThe description of the hierarchy. ado_statenumpy.arrayThe full state of the hierarchy. Attributes. rhoQobjThe system state. In addition, all of the attributes of the hierarchy description,; i.e. ``HierarchyADOs``, are provided directly on this class for; convenience. E.g. one can access ``.labels``, or ``.exponents`` or; call ``.idx(label)`` directly.; See :class:`HierarchyADOs` for a full list of the available attributes; and methods. extract(idx_or_label)[source]¶; Extract a Qobj representing specified ADO from a full representation of; the ADO states. Parameters. idxint or labelThe index of the ADO to extract. If an ADO label, e.g.; (0, 1, 0, ...) is supplied instead, then the ADO; is extracted by label instead. Returns. QobjA Qobj representing the state of the specified ADO. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For prac",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:67759,access,access,67759,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,2,['access'],['access']
Security,"self.memory_optimization = 0; self.oper_dtype = None; self.cache_phased_dyn_gen = None; self.cache_prop_grad = None; self.cache_dyn_gen_eigenvectors_adj = None; self.sparse_eigen_decomp = None; self.dyn_dims = None; self.dyn_shape = None; self.sys_dims = None; self.sys_shape = None; self.time_depend_drift = False; self.time_depend_ctrl_dyn_gen = False; # These internal attributes will be of the internal operator data type; # used to compute the evolution; # Note this maybe ndarray, Qobj or some other depending on oper_dtype; self._drift_dyn_gen = None; self._ctrl_dyn_gen = None; self._phased_ctrl_dyn_gen = None; self._dyn_gen_phase = None; self._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._timeslots_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:15356,access,accessors,15356,docs/4.2/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html,1,['access'],['accessors']
Security,"self.memory_optimization = 0; self.oper_dtype = None; self.cache_phased_dyn_gen = None; self.cache_prop_grad = None; self.cache_dyn_gen_eigenvectors_adj = None; self.sparse_eigen_decomp = None; self.dyn_dims = None; self.dyn_shape = None; self.sys_dims = None; self.sys_shape = None; self.time_depend_drift = False; self.time_depend_ctrl_dyn_gen = False; # These internal attributes will be of the internal operator data type; # used to compute the evolution; # This will be either ndarray or Qobj; self._drift_dyn_gen = None; self._ctrl_dyn_gen = None; self._phased_ctrl_dyn_gen = None; self._dyn_gen_phase = None; self._phase_application = None; self._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._evo_initialized = False; self._timeslots_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = Non",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:15316,access,accessors,15316,docs/4.6/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html,4,['access'],['accessors']
Security,"ses it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html:2689,access,accessible,2689,docs/4.2/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html,6,['access'],['accessible']
Security,"ses it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code; >>> H = 2*np.pi * 0.1 * sigmax(); >>> psi0 =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:2828,access,accessible,2828,docs/4.6/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html,2,['access'],['accessible']
Security,"ses it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.sesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code; >>> H = 2*np.pi * 0.1 * sigmax(); >>> psi0 =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:2915,access,accessible,2915,docs/4.7/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html,2,['access'],['accessible']
Security,"solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To access the data for the two expectation values one can do:; >>> expt0 = result.expect[0]; >>> expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; >>> times = result.times. we can plot the resulting expectation values:; >>> plot(times, expt0, times, expt1); >>> show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; >>> qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a “.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html:4754,access,accessed,4754,docs/4.3/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html,3,['access'],['accessed']
Security,"solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To access the data for the two expectation values one can do:; >>> expt0 = result.expect[0]; >>> expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; >>> times = result.times. we can plot the resulting expectation values:; >>> plot(times, expt0, times, expt1); >>> show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; >>> qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a ”.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-data.html:4728,access,accessed,4728,docs/4.2/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-data.html,4,['access'],['accessed']
Security,"suming qubit dimensions). This is an internal function, as QuTiP does not currently have; a way to mark that superoperators are represented in the Pauli; basis as opposed to the column-stacking basis; a Pauli-basis; ``type='super'`` would thus break other conversion functions.; """"""; # Ensure we start with a column-stacking-basis superoperator.; sqobj = to_super(q_oper); if not _isqubitdims(sqobj.dims):; raise ValueError(""Pauli basis is only defined for qubits.""); nq = int(log2(sqobj.shape[0]) / 2); B = _pauli_basis(nq) / sqrt(2**nq); # To do this, we have to hack a bit and force the dims to match,; # since the _pauli_basis function makes different assumptions; # about indices than we need here.; B.dims = sqobj.dims; return (B.dag() * sqobj * B). [docs]def super_to_choi(q_oper):; # TODO: deprecate and make private in favor of to_choi,; # which looks at Qobj.type to determine the right conversion function.; """"""; Takes a superoperator to a Choi matrix; TODO: Sanitize input, incorporate as method on Qobj if type=='super'; """"""; q_oper = _super_tofrom_choi(q_oper); q_oper.superrep = 'choi'; return q_oper. [docs]def choi_to_super(q_oper):; # TODO: deprecate and make private in favor of to_super,; # which looks at Qobj.type to determine the right conversion function.; """"""; Takes a Choi matrix to a superoperator; TODO: Sanitize input, Abstract-ify application of channels to states; """"""; q_oper = super_to_choi(q_oper); q_oper.superrep = 'super'; return q_oper. [docs]def choi_to_kraus(q_oper, tol=1e-9):; """"""; Takes a Choi matrix and returns a list of Kraus operators.; TODO: Create a new class structure for quantum channels, perhaps as a; strict sub-class of Qobj.; """"""; vals, vecs = eig(q_oper.full()); vecs = [array(_) for _ in zip(*vecs)]; shape = [np.prod(q_oper.dims[0][i]) for i in range(2)][::-1]; return [Qobj(inpt=sqrt(val)*vec2mat(vec, shape=shape),; dims=q_oper.dims[0][::-1]); for val, vec in zip(vals, vecs) if abs(val) >= tol]. [docs]def kraus_to_choi(kraus_list):; """""";",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html:7412,Sanitiz,Sanitize,7412,docs/4.6/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html,1,['Sanitiz'],['Sanitize']
Security,"suming qubit dimensions). This is an internal function, as QuTiP does not currently have; a way to mark that superoperators are represented in the Pauli; basis as opposed to the column-stacking basis; a Pauli-basis; ``type='super'`` would thus break other conversion functions.; """"""; # Ensure we start with a column-stacking-basis superoperator.; sqobj = to_super(q_oper); if not _isqubitdims(sqobj.dims):; raise ValueError(""Pauli basis is only defined for qubits.""); nq = int(log2(sqobj.shape[0]) / 2); B = _pauli_basis(nq) / sqrt(2**nq); # To do this, we have to hack a bit and force the dims to match,; # since the _pauli_basis function makes different assumptions; # about indices than we need here.; B.dims = sqobj.dims; return (B.dag() * sqobj * B). [docs]def super_to_choi(q_oper):; # TODO: deprecate and make private in favor of to_choi,; # which looks at Qobj.type to determine the right conversion function.; """"""; Takes a superoperator to a Choi matrix; TODO: Sanitize input, incorporate as method on Qobj if type=='super'; """"""; q_oper = _super_tofrom_choi(q_oper); q_oper.superrep = 'choi'; return q_oper. [docs]def choi_to_super(q_oper):; # TODO: deprecate and make private in favor of to_super,; # which looks at Qobj.type to determine the right conversion function.; """"""; Takes a Choi matrix to a superoperator; TODO: Sanitize input, Abstract-ify application of channels to states; """"""; q_oper = super_to_choi(q_oper); q_oper.superrep = 'super'; return q_oper. [docs]def choi_to_kraus(q_oper, tol=1e-9):; """"""; Takes a Choi matrix and returns a list of Kraus operators.; TODO: Create a new class structure for quantum channels, perhaps as a; strict sub-class of Qobj.; """"""; vals, vecs = q_oper.eigenstates(phase_fix=0); elements_to_keep = abs(vals) >= tol; sqrt_vals, vecs = np.sqrt(vals[elements_to_keep]), vecs[elements_to_keep]; shape = (np.prod(q_oper.dims[0][1]), np.prod(q_oper.dims[0][0])); dims = q_oper.dims[0][::-1]; return [; Qobj(inpt=sqrt_val * vec.data.reshape(shape, order",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html:5677,Sanitiz,Sanitize,5677,docs/4.7/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html,1,['Sanitiz'],['Sanitize']
Security,"t Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide.html:2886,Access,Accessible,2886,docs/4.6/guide/guide.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide.html,1,['Access'],['Accessible']
Security,"t it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Dev",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:12269,access,accessible,12269,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,2,['access'],['accessible']
Security,"t it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:14552,access,accessible,14552,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,2,['access'],['accessible']
Security,"tems. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Kha05. Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/biblio.html:3216,access,access,3216,docs/4.4/biblio.html,https://qutip.org,https://qutip.org/docs/4.4/biblio.html,1,['access'],['access']
Security,"terpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)¶\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the map as. (2)¶\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{mn} \chi_{mn} B_m \rho_{\rm in} B_n^\dagger.\]; where \(\chi_{mn} = \sum_{ij} b_{im}b_{jn}^*\) and \(A_i = \sum_{m} b_{im}B_{m}\). Here, matrix \(\chi\) is the transformation matrix we are after, since it describes how much \(B_m \rho_{\rm in} B_n^\dagger\) contributes to \(\rho_{\rm out}\).; In a numerical simulation of a quantum process we usually do not have access to the quantum map in the form Eq. (1). Instead, what we usually can do is to calculate the propagator \(U\) for the density matrix in superoperator form, using for example the QuTiP function qutip.propagator.propagator. We can then write. \[\epsilon(\tilde{\rho}_{\rm in}) = U \tilde{\rho}_{\rm in} = \tilde{\rho}_{\rm out}\]; where \(\tilde{\rho}\) is the vector representation of the density matrix \(\rho\). If we write Eq. (2) in superoperator form as well we obtain. \[\tilde{\rho}_{\rm out} = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger \tilde{\rho}_{\rm in} = U \tilde{\rho}_{\rm in}.\]; so we can identify. \[U = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger.\]; Now this is a linear equation systems for the \(N^2 \times N^2\) elements in \(\chi\). We can solve it by writing \(\chi\) and the superoperator propagator as \([N^4]\) vectors, and likewise write the superoperator product \(\tilde{B}_m\tilde{B}_n^\dagger\) as a \([N^4\times N^4]\) matrix \(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-visualization.html:12713,access,access,12713,docs/4.2/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-visualization.html,10,['access'],['access']
Security,"the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To access the data for the two expectation values one can do:; >>> expt0 = result.expect[0]; >>> expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; >>> times = result.times. we can plot the resulting expectation values:; >>> plot(times, expt0, times, expt1); >>> show(). Data for expectation values extracted from the result Result object. State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; >>> qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a ”.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html:5144,access,accessed,5144,docs/3.0.0/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html,2,['access'],['accessed']
Security,"to initialise the; the control amplitudes. Options include:. RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW. (see PulseGen classes for details). pulse_scaling : float. Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float. Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:Instance of an Optimizer, through which the. Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer. The optimisation can be run through the optimizer.run_optimization. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:147587,access,accessible,147587,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['access'],['accessible']
Security,"tplotlib figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis context in which the plot will be drawn. figsize : (width, height). The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. plot_qubism(ket, theme='light', how='pairs', grid_iteration=1, legend_iteration=0, fig=None, ax=None, figsize=(6, 6))¶; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest. More information:; J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; “Qubism: self-similar visualization of many-body wavefunctions”,; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters:ket : Qobj. Pure state for plotting. theme : ‘light’ (default) or ‘dark’. Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : ‘pairs’ (default), ‘pairs_skewed’ or ‘before_after’. Type of Qubism plotting.; Options: ‘pairs’ - typical coordinates, ‘pairs_skewed’ - for; ferromagnetic/antriferromagnetic plots, ‘before_after’ - related to; Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1). Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or ‘grid_iteration’ or ‘all’. Show labels for first 2*legend_iteration particles. Option; ‘grid_iteration’ sets the same number of particles as for; grid_iteration. Option ‘all’ makes label for all particles. Typically; it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis context",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:87550,access,access,87550,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,1,['access'],['access']
Security,"tplotlib figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis context in which the plot will be drawn. figsize : (width, height). The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. plot_qubism(ket, theme='light', how='pairs', grid_iteration=1, legend_iteration=0, fig=None, ax=None, figsize=(6, 6))¶; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest. More information:; J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; “Qubism: self-similar visualization of many-body wavefunctions”,; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters:ket : Qobj. Pure state for plotting. theme : ‘light’ (default) or ‘dark’. Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : ‘pairs’ (default), ‘pairs_skewed’ or ‘before_after’. Type of Qubism plotting.; Options:. ‘pairs’ - typical coordinates,; ‘pairs_skewed’ - for ferromagnetic/antriferromagnetic plots,; ‘before_after’ - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1). Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or ‘grid_iteration’ or ‘all’. Show labels for first 2*legend_iteration particles.; Option ‘grid_iteration’ sets the same number of particles. as for grid_iteration. Option ‘all’ makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis contex",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/functions.html:87610,access,access,87610,docs/3.0.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html,1,['access'],['access']
Security,"tum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-overview.html:1719,access,accessible,1719,docs/4.0.2/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-overview.html,2,['access'],['accessible']
Security,"tum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/guide-overview.html:1719,access,accessible,1719,docs/4.1/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.1/guide/guide-overview.html,2,['access'],['accessible']
Security,"tum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-overview.html:1719,access,accessible,1719,docs/4.2/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-overview.html,2,['access'],['accessible']
Security,"ty; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector.¶. For the destruction operator above:; In [18]: q.type; Out[18]: 'oper'. In [19]: q.isherm; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-basics.html:10552,access,access,10552,docs/4.4/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-basics.html,1,['access'],['access']
Security,"ulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _par",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:58970,access,accessed,58970,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['access'],['accessed']
Security,"uper(q_oper); if not _isqubitdims(sqobj.dims):; raise ValueError(""Pauli basis is only defined for qubits.""); nq = int(log2(sqobj.shape[0]) / 2); B = _pauli_basis(nq) / sqrt(2**nq); # To do this, we have to hack a bit and force the dims to match,; # since the _pauli_basis function makes different assumptions; # about indices than we need here.; B.dims = sqobj.dims; return (B.dag() * sqobj * B). [docs]def super_to_choi(q_oper):; # TODO: deprecate and make private in favor of to_choi,; # which looks at Qobj.type to determine the right conversion function.; """"""; Takes a superoperator to a Choi matrix; TODO: Sanitize input, incorporate as method on Qobj if type=='super'; """"""; q_oper = _super_tofrom_choi(q_oper); q_oper.superrep = 'choi'; return q_oper. [docs]def choi_to_super(q_oper):; # TODO: deprecate and make private in favor of to_super,; # which looks at Qobj.type to determine the right conversion function.; """"""; Takes a Choi matrix to a superoperator; TODO: Sanitize input, Abstract-ify application of channels to states; """"""; q_oper = super_to_choi(q_oper); q_oper.superrep = 'super'; return q_oper. [docs]def choi_to_kraus(q_oper, tol=1e-9):; """"""; Takes a Choi matrix and returns a list of Kraus operators.; TODO: Create a new class structure for quantum channels, perhaps as a; strict sub-class of Qobj.; """"""; vals, vecs = eig(q_oper.full()); vecs = [array(_) for _ in zip(*vecs)]; shape = [np.prod(q_oper.dims[0][i]) for i in range(2)][::-1]; return [Qobj(inpt=sqrt(val)*vec2mat(vec, shape=shape),; dims=q_oper.dims[0][::-1]); for val, vec in zip(vals, vecs) if abs(val) >= tol]. [docs]def kraus_to_choi(kraus_list):; """"""; Takes a list of Kraus operators and returns the Choi matrix for the channel; represented by the Kraus operators in `kraus_list`; """"""; kraus_mat_list = list(map(lambda x: x.data.toarray(), kraus_list)); op_rng = range(kraus_mat_list[0].shape[0]); choi_blocks = array([[sum([; np.outer(op[:, c_ix],; np.transpose(np.conjugate(op))[r_ix, :]); for op in kraus_mat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html:7774,Sanitiz,Sanitize,7774,docs/4.6/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html,1,['Sanitiz'],['Sanitize']
Security,"uper(q_oper); if not _isqubitdims(sqobj.dims):; raise ValueError(""Pauli basis is only defined for qubits.""); nq = int(log2(sqobj.shape[0]) / 2); B = _pauli_basis(nq) / sqrt(2**nq); # To do this, we have to hack a bit and force the dims to match,; # since the _pauli_basis function makes different assumptions; # about indices than we need here.; B.dims = sqobj.dims; return (B.dag() * sqobj * B). [docs]def super_to_choi(q_oper):; # TODO: deprecate and make private in favor of to_choi,; # which looks at Qobj.type to determine the right conversion function.; """"""; Takes a superoperator to a Choi matrix; TODO: Sanitize input, incorporate as method on Qobj if type=='super'; """"""; q_oper = _super_tofrom_choi(q_oper); q_oper.superrep = 'choi'; return q_oper. [docs]def choi_to_super(q_oper):; # TODO: deprecate and make private in favor of to_super,; # which looks at Qobj.type to determine the right conversion function.; """"""; Takes a Choi matrix to a superoperator; TODO: Sanitize input, Abstract-ify application of channels to states; """"""; q_oper = super_to_choi(q_oper); q_oper.superrep = 'super'; return q_oper. [docs]def choi_to_kraus(q_oper, tol=1e-9):; """"""; Takes a Choi matrix and returns a list of Kraus operators.; TODO: Create a new class structure for quantum channels, perhaps as a; strict sub-class of Qobj.; """"""; vals, vecs = q_oper.eigenstates(phase_fix=0); elements_to_keep = abs(vals) >= tol; sqrt_vals, vecs = np.sqrt(vals[elements_to_keep]), vecs[elements_to_keep]; shape = (np.prod(q_oper.dims[0][1]), np.prod(q_oper.dims[0][0])); dims = q_oper.dims[0][::-1]; return [; Qobj(inpt=sqrt_val * vec.data.reshape(shape, order=""F""), dims=dims); for sqrt_val, vec in zip(sqrt_vals, vecs); ]. [docs]def kraus_to_choi(kraus_ops):; r""""""; Convert a list of Kraus operators into Choi representation of the channel. Essentially, kraus operators are a decomposition of a Choi matrix,; so in this function we build Choi matrix from vector representation of Kraus operators. Parameters; ---------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html:6039,Sanitiz,Sanitize,6039,docs/4.7/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html,1,['Sanitiz'],['Sanitize']
Security,"uring the optimisation. wall_time_limit_exceeded¶; boolean – True if the wall time limit was reached. time¶; array[num_tslots+1] of float – Time are the start of each timeslot; with the final value being the total evolution time. initial_amps¶; array[num_tslots, n_ctrls] – The amplitudes at the start of the optimisation. final_amps¶; array[num_tslots, n_ctrls] – The amplitudes at the end of the optimisation. evo_full_final¶; Qobj – The evolution operator from t=0 to t=T based on the final amps. stats¶; Stats – Object contaning the stats for the run (if any collected). optimizer¶; Optimizer – Instance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:75653,access,access,75653,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['access'],['access']
Security,"when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the las",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:8961,hash,hash,8961,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['hash'],['hash']
Security,"with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the “Base” branch to qutip-4.6.X (or whatever ve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:9313,hash,hashes,9313,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['hash'],['hashes']
Security,"‘gray’. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.point_mode; Type of point markers to draw; sphere. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; ‘#808080’. b.size; Sets size of figure window; [500,500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45,65 ]. b.xlabel; Labels for x-axis; [‘|x>’, ‘’] +x and -x. b.xlpos; Position of x-axis labels; [1.07,-1.07]. b.ylabel; Labels for y-axis; [‘$y$’,’‘] +y and -y. b.ylpos; Position of y-axis labels; [1.07,-1.07]. b.zlabel; Labels for z-axis; [‘|0>’, ‘|1>’] +z and -z. b.zlpos; Position of z-axis labels; [1.07,-1.07]. These properties can also be accessed via the print command:; In [50]: b = Bloch(). In [51]: print(b); Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,... The Bloch sphere will automatically number the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-bloch.html:12130,access,accessed,12130,docs/4.2/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-bloch.html,4,['access'],['accessed']
Security,"‘gray’. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.point_mode; Type of point markers to draw; sphere. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; ‘#808080’. b.size; Sets size of figure window; [500,500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45,65 ]. b.xlabel; Labels for x-axis; [‘|x>’, ‘’] +x and -x. b.xlpos; Position of x-axis labels; [1.07,-1.07]. b.ylabel; Labels for y-axis; [‘$y$’,’‘] +y and -y. b.ylpos; Position of y-axis labels; [1.07,-1.07]. b.zlabel; Labels for z-axis; [‘|0>’, ‘|1>’] +z and -z. b.zlpos; Position of z-axis labels; [1.07,-1.07]. These properties can also be accessed via the print command:; In [50]: b = Bloch(). In [51]: print(b); Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,… The Bloch sphere will automatically number the o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-bloch.html:12130,access,accessed,12130,docs/4.3/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-bloch.html,1,['access'],['accessed']
Security,"‘gray’. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.point_mode; Type of point markers to draw; sphere. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; ‘#808080’. b.size; Sets size of figure window; [500,500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45,65 ]. b.xlabel; Labels for x-axis; [‘|x>’, ‘’] +x and -x. b.xlpos; Position of x-axis labels; [1.07,-1.07]. b.ylabel; Labels for y-axis; [‘$y$’,’‘] +y and -y. b.ylpos; Position of y-axis labels; [1.07,-1.07]. b.zlabel; Labels for z-axis; [‘|0>’, ‘|1>’] +z and -z. b.zlpos; Position of z-axis labels; [1.07,-1.07]. These properties can also be accessed via the print command:; In [53]: b = Bloch(). In [54]: print(b); Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,… The Bloch sphere will automatically number the o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-bloch.html:12547,access,accessed,12547,docs/4.4/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-bloch.html,1,['access'],['accessed']
Security,"‘gray’. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.point_mode; Type of point markers to draw; sphere. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; ‘#808080’. b.size; Sets size of figure window; [500,500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45,65 ]. b.xlabel; Labels for x-axis; [‘|x>’, ‘’] +x and -x. b.xlpos; Position of x-axis labels; [1.07,-1.07]. b.ylabel; Labels for y-axis; [‘$y$’,’’] +y and -y. b.ylpos; Position of y-axis labels; [1.07,-1.07]. b.zlabel; Labels for z-axis; [‘|0>’, ‘|1>’] +z and -z. b.zlpos; Position of z-axis labels; [1.07,-1.07]. These properties can also be accessed via the print command:; In [53]: b = Bloch(). In [54]: print(b); Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,… The Bloch sphere will automatically number the o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-bloch.html:11646,access,accessed,11646,docs/4.5/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-bloch.html,1,['access'],['accessed']
Security,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Citing QuTiP; QuTiP is developed by several physicists in their spare time.; As with anyone in academics,; their life and death is determined entirely by citations and paper count. ; Therefore, if you find QuTiP useful, please consider citing this project as:. J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP 2: A Python framework for the dynamics of open quantum systems.”, Comp. Phys. Comm. 184, 1234 (2013), DOI: 10.1016/j.cpc.2012.11.019. J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP: An open-source Python framework for the dynamics of open quantum systems.”, Comp. Phys. Comm. 183, 1760–1772 (2012), DOI: 10.1016/j.cpc.2012.02.021. This will also help us secure future funding supporting the development of this software.; PDF versions of these papers may be found on the ArXiv preprint server; here and here.; If you do use QuTiP in a publication, please take a few minutes and let us know; by posting on the QuTiP message board.; We would love to hear how QuTiP is being used as a research tool. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/citing.html:950,secur,secure,950,citing.html,https://qutip.org,https://qutip.org/citing.html,1,['secur'],['secure']
Testability," ""; ""'onto_evo_target' property""); return self.onto_evo_target. def _get_onto_evo_target(self):; """"""; Get the inverse of the target.; Used for calculating the 'onto target' evolution; This is actually only relevant for unitary dynamics where; the target.dag() is what is required; However, for completeness, in general the inverse of the target; operator is is required; For state-to-state, the bra corresponding to the is required ket; """"""; if self.target.shape[0] == self.target.shape[1]:; #Target is operator; targ = la.inv(self.target.full()); if self.oper_dtype == Qobj:; rev_dims = [self.target.dims[1], self.target.dims[0]]; self._onto_evo_target = Qobj(targ, dims=rev_dims); elif self.oper_dtype == np.ndarray:; self._onto_evo_target = targ; else:; assert False, f""Unknown oper_dtype {self.oper_dtype!r}""; else:; if self.oper_dtype == Qobj:; self._onto_evo_target = self.target.dag(); elif self.oper_dtype == np.ndarray:; self._onto_evo_target = self.target.dag().full(); else:; assert False, f""Unknown oper_dtype {self.oper_dtype!r}"". return self._onto_evo_target. [docs] def combine_dyn_gen(self, k):; """"""; Computes the dynamics generator for a given timeslot; The is the combined Hamiltion for unitary systems; """"""; _func_deprecation(""'combine_dyn_gen' has been replaced by ""; ""'_combine_dyn_gen'""); self._combine_dyn_gen(k); return self._dyn_gen(k). def _combine_dyn_gen(self, k):; """"""; Computes the dynamics generator for a given timeslot; The is the combined Hamiltion for unitary systems; Also applies the phase (if any required by the propagation); """"""; if self.time_depend_drift:; dg = self._drift_dyn_gen[k]; else:; dg = self._drift_dyn_gen; for j in range(self._num_ctrls):; if self.time_depend_ctrl_dyn_gen:; dg = dg + self.ctrl_amps[k, j]*self._ctrl_dyn_gen[k, j]; else:; dg = dg + self.ctrl_amps[k, j]*self._ctrl_dyn_gen[j]. self._dyn_gen[k] = dg; if self.cache_phased_dyn_gen:; self._phased_dyn_gen[k] = self._apply_phase(dg). [docs] def get_dyn_gen(self, k):; """"""; Get the com",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:36617,assert,assert,36617,docs/4.6/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html,4,['assert'],['assert']
Testability," ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:18567,log,logging,18567,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,5,['log'],['logging']
Testability," ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:18892,log,logging,18892,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['log'],['logging']
Testability," ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:18646,log,logging,18646,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['log'],['logging']
Testability," # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html:3173,log,logging,3173,docs/4.4/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html,3,['log'],"['logger', 'logging']"
Testability," # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:3177,log,logging,3177,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,12,['log'],"['logger', 'logging']"
Testability," 'steady', 'build_preconditioner',; 'pseudo_inverse']. import warnings; import time; import scipy; import numpy as np; from numpy.linalg import svd; from scipy import prod; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (use_solver, splu, spilu, spsolve, eigs,; LinearOperator, gmres, lgmres, bicgstab); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_reshape, sp_profile. from qutip.superoperator import liouvillian, vec2mat; from qutip.sparse import (sp_permute, sp_bandwidth, sp_reshape,; sp_profile); from qutip.cy.spmath import zcsr_kron; from qutip.graph import reverse_cuthill_mckee, weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.utilities import _version2int; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). # test if scipy is recent enought to get L & U factors from superLU; _scipy_check = _version2int(scipy.__version__) >= _version2int('0.14.0'). def _empty_info_dict():; def_info = {'perm': [], 'solution_time': None,; 'residual_norm': None,; 'solver': None, 'method': None}. return def_info. def _default_steadystate_args():; def_args = {'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'use_precond': False,; 'all_states': False, 'M': None, 'x0': None, 'drop_tol': 1e-4,; 'fill_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000,; 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2',; 'restart': 20,; 'max_iter_refine': 10,; 'scaling_vectors': True,; 'weighted_matching': True,; 'return_info': False, 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'scipy', 'weight': None,; 'tol': 1e-12, 'matol': 1e-15, 'mto",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/steadystate.html:3283,log,logger,3283,docs/4.5/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/steadystate.html,1,['log'],['logger']
Testability," 'steady', 'build_preconditioner',; 'pseudo_inverse']. import warnings; import time; import scipy; import numpy as np; from numpy.linalg import svd; from scipy import prod; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (use_solver, splu, spilu, spsolve, eigs,; LinearOperator, gmres, lgmres, bicgstab); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_reshape, sp_profile. from qutip.superoperator import liouvillian, vec2mat; from qutip.sparse import (sp_permute, sp_bandwidth, sp_reshape,; sp_profile); from qutip.cy.spmath import zcsr_kron; from qutip.graph import reverse_cuthill_mckee, weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.utilities import _version2int; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). # test if scipy is recent enought to get L & U factors from superLU; _scipy_check = _version2int(scipy.__version__) >= _version2int('0.14.0'). def _empty_info_dict():; def_info = {'perm': [], 'solution_time': None,; 'residual_norm': None,; 'solver': None, 'method': None}. return def_info. def _default_steadystate_args():; def_args = {'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'weight': None, 'use_precond': False,; 'all_states': False, 'M': None, 'x0': None, 'drop_tol': 1e-4,; 'fill_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000,; 'tol': 1e-12, 'matol': 1e-15, 'mtol': None,; 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2',; 'restart': 20, 'return_info': False,; 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'scipy'}. return def_args. def _mkl_steadystate_args():; def_args = {'max_ite",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:3274,log,logger,3274,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,2,['log'],['logger']
Testability," * alpha * u[r, j, m, best_k] * dt. if beta:; # penalty term for late control signals u; du += -2 * beta * k ** 2 * u[r, j, k] * dt. for k, eps_val in enumerate(eps_vec):; u[r + 1, j, m, k] = u[r, j, m, k] + eps_val * du.real. if u_limits:; if u[r + 1, j, m, k] < u_limits[0]:; u[r + 1, j, m, k] = u_limits[0]; elif u[r + 1, j, m, k] > u_limits[1]:; u[r + 1, j, m, k] = u_limits[1]. u[r + 1, j, -1, :] = u[r + 1, j, -2, :]. logger.debug(""Time 3: %fs"" % (time.time() - _t0)); _t0 = time.time(). for k, eps_val in enumerate(eps_vec):. def _H_idx(idx):; return H0 + sum([u[r + 1, j, idx, k] * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_idx(idx) * dt).expm() for idx in range(M-1)]. Uf[k] = gate_sequence_product(U_list); _k_overlap[k] = _fidelity_function(cy_overlap(Uf[k].data,; U.data)).real. best_k = np.argmax(_k_overlap); logger.debug(""k_overlap: "", _k_overlap, best_k). if _prev_overlap > _k_overlap[best_k]:; logger.debug(""Regression, stepping back with smaller eps.""). u[r + 1, :, :, :] = u[r, :, :, :]; eps_vec /= 2; else:. if best_k == 0:; eps_vec /= 2. elif best_k == 2:; eps_vec *= 2. _prev_overlap = _k_overlap[best_k]. overlap_log[r] = _k_overlap[best_k]. if overlap_terminate < 1.0:; if _k_overlap[best_k] > overlap_terminate:; logger.info(""Reached target fidelity, terminating.""); break. logger.debug(""Time 4: %fs"" % (time.time() - _t0)); _t0 = time.time(). if use_interp:; ip_funcs = [interp1d(times, u[_r, j, :, best_k], kind=interp_kind,; bounds_error=False, fill_value=u[R - 1, j, -1]); for j in range(J)]. H_td_func = [H0] + [[H_ops[j], lambda t, args, j=j: ip_funcs[j](t)]; for j in range(J)]; else:; H_td_func = [H0] + [[H_ops[j], u[_r, j, :, best_k]] for j in range(J)]. progress_bar.finished(). result = GRAPEResult(u=u[:_r, :, :, best_k], U_f=Uf[best_k],; H_t=H_td_func). result.eps = eps_log; result.overlap = overlap_log. return result. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:16797,log,logger,16797,docs/3.1.0/modules/qutip/control/grape.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html,2,['log'],['logger']
Testability," ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)). if _scipy_check:; L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precondition(L, n, ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; Use",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:18467,log,logger,18467,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,6,['log'],['logger']
Testability," ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)). if _scipy_check:; L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = prod(L.dims[0][0]); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True, useUmfpack=ss_args['use_umfpack']). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precondition(L, n, ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning faile",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:18588,log,logger,18588,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['log'],['logger']
Testability," - 1); return num_coeffs. [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats; """"""; return self.coeffs.ravel().tolist(). [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the; # main optmisation call sequence; self.set_coeffs(param_vals). def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]). def init_guess_pulse(self):. self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)). def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse. def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse. def _init_bounds(self):; add_guess_pulse_scale = False; if self.lbound is None and self.ubound is None:; # no bounds to apply; self._bound_scale_cond = None; elif self.lbound is None:; # only upper bound; if self.ubound > 0:; self._bound_mean = 0.0; self._bound_scale = self.ubound; else:; add_guess_pulse_scale = True; self._bound_scale = self.scaling*self.num_coeffs + \; self.get_guess_pulse_scale(); self._bound_mean = -abs(self._bound_scale) + self.ubound; self._bound_scale_cond = self._BSC_GT_MEAN. elif self.ubound is None:; # only lower bound; if self.lbound < 0:; self._bound_mean = 0.0; self._bound_scale = abs(self.lbound); else:; self._bound_scale = self.scaling*self.num_coeffs + \; self.get_gu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:32282,log,logger,32282,docs/4.6/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html,4,['log'],['logger']
Testability," 1); return num_coeffs. [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(). [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the ; # main optmisation call sequence; self.set_coeffs(param_vals). def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]). def init_guess_pulse(self):. self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)). def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse. def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse. def _init_bounds(self):; add_guess_pulse_scale = False; if self.lbound is None and self.ubound is None:; # no bounds to apply; self._bound_scale_cond = None; elif self.lbound is None:; # only upper bound; if self.ubound > 0:; self._bound_mean = 0.0; self._bound_scale = self.ubound; else:; add_guess_pulse_scale = True; self._bound_scale = self.scaling*self.num_coeffs + \; self.get_guess_pulse_scale(); self._bound_mean = -abs(self._bound_scale) + self.ubound; self._bound_scale_cond = self._BSC_GT_MEAN. elif self.ubound is None:; # only lower bound; if self.lbound < 0:; self._bound_mean = 0.0; self._bound_scale = abs(self.lbound); else:; self._bound_scale = self.scaling*self.num_coeffs + \; self.get_gu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulsegen.html:32284,log,logger,32284,docs/4.4/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulsegen.html,1,['log'],['logger']
Testability," : str; Default file extension for any file names that are auto generated. fname_base : str; First part of any auto generated file names.; This is usually overridden in the subclass. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. """"""; def __init__(self):; self.reset(). def reset(self):; if self.parent:; self.log_level = self.parent.log_level; self.write_to_file = self.parent.dump_to_file; else:; self.write_to_file = False; self._dump_dir = None; self.dump_file_ext = ""txt""; self._fname_base = 'dump'; self.dump_summary = True; self.summary_sep = ' '; self.data_sep = ' '; self._summary_file_path = None; self._summary_file_specified = False. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def level(self):; """"""; The level of data dumping that will occur. SUMMARY; A summary will be recorded. FULL; All possible dumping. CUSTOM; Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped; """"""; lvl = 'CUSTOM'; if (self.dump_summary and not self.dump_any):; lvl = 'SUMMARY'; elif (self.dump_summary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsD",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dump.html:4758,log,logger,4758,docs/4.6/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html,4,['log'],['logger']
Testability," : str; Default file extension for any file names that are auto generated. fname_base : str; First part of any auto generated file names.; This is usually overridden in the subclass. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. """"""; def __init__(self):; self.reset(). def reset(self):; if self.parent:; self.log_level = self.parent.log_level; self.write_to_file = self.parent.dump_to_file; else:; self.write_to_file = False; self._dump_dir = None; self.dump_file_ext = ""txt""; self._fname_base = 'dump'; self.dump_summary = True; self.summary_sep = ' '; self.data_sep = ' '; self._summary_file_path = None; self._summary_file_specified = False. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def level(self):; """"""; The level of data dumping that will occur; - SUMMARY : A summary will be recorded; - FULL : All possible dumping; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped; """"""; lvl = 'CUSTOM'; if (self.dump_summary and not self.dump_any):; lvl = 'SUMMARY'; elif (self.dump_summary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dump.html:4729,log,logger,4729,docs/4.1/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dump.html,6,['log'],['logger']
Testability," ; (see PulseGen classes for details); For the CRAB the this the guess_pulse_type. . init_pulse_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:57898,log,logger,57898,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['log'],['logger']
Testability," = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html:14704,log,logger,14704,docs/4.1/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html,10,['log'],['logger']
Testability," = True; self.dump_grad = True; else:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_iter_summary(self):; """"""add copy of current optimizer iteration summary""""""; optim = self.parent; if optim.iter_summary is None:; raise RuntimeError(""Cannot add iter_summary as not available""); ois = copy.copy(optim.iter_summary); ois.idx = len(self.iter_summary); self.iter_summary.append(ois); if self.write_to_file:; if ois.idx == 0:; f = open(self.summary_file, 'w'); f.write(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(; ois.get_value_line(self.summary_sep))). f.close(); return ois. @property; def fid_err_file(self):; if self._fid_err_file is None:; fname = ""{}-fid_err_log.{}"".format(self.fname_base,; self.dump_file_ext); self._fid_err_file = os.path.join(self.dump_dir, fname); return self._fid_err_file. [docs] def update_fid_err_log(self, fid_err):; """"""add an entry to the fid_err log""""""; self.fid_err_log.append(fid_err); if self.write_to_file:; if len(self.fid_err_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.fid_err_file, mode); f.write(""{}\n"".format(fid_err)); f.close(). @property; def grad_norm_file(self):; if self._grad_norm_file is None:; fname = ""{}-grad_norm_log.{}"".format(self.fname_base,; self.dump_file_ext); self._grad_norm_file = os.path.join(self.dump_dir, fname); return self._grad_norm_file. [docs] def update_grad_norm_log(self, grad_norm):; """"""add an entry to the grad_norm log""""""; self.grad_norm_log.append(grad_norm); if self.write_to_file:; if len(self.grad_norm_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.grad_norm_file, mode); f.write(""{}\n"".format(grad_norm)); f.close(). [docs] def update_grad_log(self, grad):; """"""add an entry to the grad log""""""; self.grad_log.append(grad); if self.write_to_file:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; len(self.grad_log),; self.dump_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dump.html:10581,log,log,10581,docs/4.1/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dump.html,10,['log'],['log']
Testability," = np.loadtxt(file_name, delimiter='\t'); if not inctime:; self.coeffs = data.T; return self.coeffs; else:; tlist = data[:, 0]; self.set_all_tlist(tlist); self.coeffs = data[:, 1:].T; return self.get_full_tlist, self.coeffs. [docs] def get_noisy_pulses(self, device_noise=False, drift=False):; """"""; It takes the pulses defined in the `Processor` and; adds noise according to `Processor.noise`. It does not modify the; pulses saved in `Processor.pulses` but returns a new list.; The length of the new list of noisy pulses might be longer; because of drift Hamiltonian and device noise. They will be; added to the end of the pulses list. Parameters; ----------; device_noise: bool, optional; If true, include pulse independent noise such as single qubit; Relaxation. Default is False.; drift: bool, optional; If true, include drift Hamiltonians. Default is False. Returns; -------; noisy_pulses: list of :class""`qutip.qip.Pulse`/:class:`qutip.qip.Drift`; A list of noisy pulses.; """"""; # TODO add tests; pulses = deepcopy(self.pulses); noisy_pulses = process_noise(; pulses, self.noise, self.dims, t1=self.t1, t2=self.t2,; device_noise=device_noise); if drift:; noisy_pulses += [self.drift]; return noisy_pulses. [docs] def get_qobjevo(self, args=None, noisy=False):; """"""; Create a :class:`qutip.QobjEvo` representation of the evolution.; It calls the method `get_noisy_pulses` and create the `QobjEvo`; from it. Parameters; ----------; args: dict, optional; Arguments for :class:`qutip.QobjEvo`; noisy: bool, optional; If noise are included. Default is False. Returns; -------; qobjevo: :class:`qutip.QobjEvo`; The :class:`qutip.QobjEvo` representation of the unitary evolution.; c_ops: list of :class:`qutip.QobjEvo`; A list of lindblad operators is also returned. if ``noisy==Flase``,; it is always an empty list.; """"""; # TODO test it for non array-like coeff; # check validity; self._is_pulses_valid(). if args is None:; args = {}; else:; args = args; # set step function. if not noisy:; dynamics = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html:14455,test,tests,14455,docs/4.5/modules/qutip/qip/device/processor.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html,1,['test'],['tests']
Testability," = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(). # Initialise the starting amplitudes; dyn.initialize_controls(init_amps). if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:18347,log,logging,18347,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,5,['log'],['logging']
Testability," = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]. [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs"""""". if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeError(""Unable to determine drift attributes, "";",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:33416,log,log,33416,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,12,['log'],"['log', 'logging']"
Testability," = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]; ; [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs""""""; ; if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeError(""Unable to determine drift attributes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:28915,log,log,28915,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,8,['log'],"['log', 'logging']"
Testability," = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp,_temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_args['permc_spec'],; drop_tol=ss_args['drop_tol'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; fill_factor=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). P_x = lambda x: P.solve(x); M = LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)). if _scipy_check:; L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:17130,log,logger,17130,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['log'],['logger']
Testability," = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec, np.inf); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp, _temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_arg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:18207,log,logger,18207,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['log'],['logger']
Testability," = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; round(old_band/rcm_band, 1)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec, np.inf); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]. data = vec2mat(eigvec); data = 0.5 * (data + data.conj().T); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_args['permc_spec'],; drop_tol=ss_args['drop_tol'],; diag_pivo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:16433,log,logger,16433,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['log'],['logger']
Testability," = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if ss_args['solver'] == 'mkl':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.deb",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:25504,log,logger,25504,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['log'],['logger']
Testability," = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if ss_args['solver'] == 'mkl':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0];",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:25075,log,logger,25075,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,2,['log'],['logger']
Testability," >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if ss_args['solver'] == 'mkl':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); with warnings.catch_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/steadystate.html:24227,log,logger,24227,docs/4.7/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html,2,['log'],['logger']
Testability," ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; """"""; import numpy as np; # QuTiP; from qutip import Qobj; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', prop_type='DEF',; fid_type='DEF', phase_option=None, fid_err_scale_factor=None,; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to mi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:4019,log,logging,4019,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,4,['log'],"['logger', 'logging']"
Testability, Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; options = Options(). the properties and default values of this class can be view via the print function:; print(options). Output:; Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are ,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html:1044,Log,Log,1044,docs/4.6/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html,1,['Log'],['Log']
Testability, Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield ,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-dynamics.html:1046,Log,Log,1046,docs/4.6/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-dynamics.html,1,['Log'],['Log']
Testability," Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""). anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True. if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True. if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""). [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, ne",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/tslotcomp.html:5960,log,logger,5960,docs/4.4/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/tslotcomp.html,2,['log'],['logger']
Testability," Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html:5964,log,logger,5964,docs/4.1/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html,18,['log'],['logger']
Testability," HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power']. from numpy import e, real, sort, sqrt; from scipy import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.qip.gates import swap; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/entropy.html:2244,log,log,2244,docs/4.2/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/entropy.html,5,['log'],['log']
Testability," L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['lu_fill_factor'] = (L_nnz + U_nnz)/L.nnz; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz + U_nnz)/orig_nnz)). else:; # Use umfpack solver; _direct_start = time.time(); v = spsolve(L, b); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end-_direct_start. if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf). if (not ss_args['use_umfpack']) and ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_direct_dense(L, ss_args):; """"""; Direct solver that use numpy dense matrices. Suitable for; small system, with a few states.; """"""; if settings.debug:; logger.debug('Starting direct dense solver.'). dims = L.dims[0]; n = prod(L.dims[0][0]); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L = L.data.todense(); L[0, :] = np.diag(ss_args['weight']*np.ones(n)).reshape((1, n ** 2)); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:15176,log,logger,15176,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['log'],['logger']
Testability," LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precondition(L, n, ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; Use",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:20740,log,logger,20740,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,2,['log'],['logger']
Testability," Lishman); Fix gate resolution of the FREDKIN gate. (by Bo Yang); Fix broken formatting in docstrings. (by Jake Lishman). Deprecations¶. eseries, essolve and ode2es are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and their functionality is now better achieved with QobjEvo or mesolve. Developer Changes¶. MAJOR Overhaul of setup and packaging code to make it satisfy PEP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by Jake Lishman); Default arguments in Qobj are now None rather than mutable types. (by Jake Lishman); Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by Jake Lishman); Remove unused imports, simplify some floats and remove unnecessary list conversions. (by jakobjakobson13); Improve Travis jobs matrix for specifying the testing containers. (by Jake Lishman); Fix coverage reporting on Travis. (by Jake Lishman); Added a pyproject.toml file. (by Simon Humpohl and Eric Giguère); Add doctests to documentation. (by Sidhant Saraogi); Fix all warnings in the documentation build. (by Jake Lishman). Version 4.5.3 (February 19, 2021)¶; This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:15546,test,testing,15546,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['test'],['testing']
Testability," List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if isinstance(times, string_types):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). if not self.tslot_computer.compare_amps(new_amps):; if self.config.test_out_amps:; fname = ""amps_{}_{}_{}_call{}{}"".format(; self.id_text,; self.prop_computer.id_text,; self.fid_computer.id_text,; self.stats.num_ctrl_amp_updates,; self.config.test_out_f_ext). fpath = os.path.join(self.config.test_out_dir, fname); self.save_amps(fpath, verbose=True). [docs] def flag_system_cha",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:17595,log,logger,17595,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['log'],['logger']
Testability," New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/changelog.html:1798,test,testing,1798,docs/4.5/changelog.html,https://qutip.org,https://qutip.org/docs/4.5/changelog.html,2,['test'],"['test', 'testing']"
Testability," None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if isinstance(times, string_types):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). if not self.tslot_computer.compare_amps(new_amps):; if self.config.test_out_amps:; fname = ""amps_{}_{}_{}_call{}{}"".format(; self.id_text,; self.prop_computer.id_text,; self.fid_computer.id_text,; self.stats.num_ctrl_amp_updates,; self.config.test_out_f_ext). fpath = os.path.join(self.config.test_out_dir, fname); self.save_amps(fpath, verbose=True). [docs] def flag_system_changed(self):; """"""; Flag eveolution, fidelity and gr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:17674,log,logger,17674,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['log'],['logger']
Testability," None is given then it is caculated as 1/2N, where N; is the dimension of the drift. amp_update_mode : string. determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string. type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:. RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW. (see PulseGen classes for details). pulse_scaling : float. Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float. Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None. files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:Returns instance of OptimResult, which has attributes giving the. reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=-inf, amp_ubound=inf, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, optim_alg='LBFGSB', max",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:135467,log,logging,135467,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['log'],['logging']
Testability," None is given then it is caculated as 1/2N, where N; is the dimension of the drift. amp_update_mode : string. determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string. type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:. RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW. (see PulseGen classes for details). pulse_scaling : float. Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float. Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:Instance of an Optimizer, through which the. Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer. The optimisation can be run through the optimizer.run_optimization. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:147116,log,logging,147116,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['log'],['logging']
Testability," None is given then it is caculated as 1/2N, where N; is the dimension of the drift. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (see PulseGen classes for details). pulse_scaling : float; Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). optim ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:9959,log,logging,9959,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['log'],['logging']
Testability," None is given then it is caculated as 1/2N, where N; is the dimension of the drift. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (see PulseGen classes for details). pulse_scaling : float; Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------. Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g.; optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; """""". # check parameters; if not isinstance(drift, Qobj):; raise TypeError(""drift must be a Qobj""); else:; drift = drift.full(). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:24988,log,logging,24988,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['log'],['logging']
Testability," None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._timeslots_initialized = False; self._ctrls_initialized = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def dumping(self):; """"""; The level of data dumping that will occur during the time evolution; calculation.; - NONE : No processing data dumped (Default); - SUMMARY : A summary of each time evolution will be recorded; - FULL : All operators used or created in the calculation dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which operators are dumped; WARNING: FULL could consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; se",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:15708,log,logger,15708,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,2,['log'],['logger']
Testability," OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""The Quantum Object (Qobj) class, for representing quantum states and; operators, and related functions.; """""". __all__ = ['Qobj', 'qobj_list_evaluate', 'ptrace', 'dag', 'isequal',; 'issuper', 'isoper', 'isoperket', 'isoperbra', 'isket', 'isbra',; 'isherm', 'shape', 'dims']. import warnings; import types; import numbers. try:; import builtins; except ImportError:; import __builtin__ as builtins. # import math functions from numpy.math: required for td string evaluation; from numpy import (arccos, arccosh, arcsin, arcsinh, arctan, arctan2, arctanh,; ceil, copysign, cos, cosh, degrees, e, exp, expm1, fabs,; floor, fmod, frexp, hypot, isinf, isnan, ldexp, log, log10,; log1p, modf, pi, radians, sin, sinh, sqrt, tan, tanh). import numpy as np; import scipy.sparse as sp; import qutip.settings as settings; from qutip import __version__; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.cy.ptrace import _ptrace; from qutip.permute import _permute; from qutip.sparse import (; sp_eigs, sp_expm, sp_fro_norm, sp_max_norm, sp_one_norm, sp_L2_norm,; ); from qutip.dimensions import (; type_from_dims, enumerate_flat, collapse_dims_super,; ); from qutip.cy.spmath import (; zcsr_transpose, zcsr_adjoint, zcsr_isherm, zcsr_trace, zcsr_proj,; zcsr_inner,; ); from qutip.cy.spmatfuncs import zcsr_mat_elem; from qutip.cy.sparse_utils import cy_tidyup; import sys; if sys.version_info.major >= 3:; from itertools import zip_longest; elif sys.version_info.major < 3:; from itertools import izip_longest; zip_longest = izip_longest. # OPENMP stuff; from qutip.cy.o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:2734,log,log,2734,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,2,['log'],['log']
Testability," Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._ge",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:20537,log,logging,20537,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,10,['log'],['logging']
Testability," QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Papers Using QuTiP; Found QuTiP useful for your own work? Please consider helping out by donating an example notebook highlighting how QuTiP was used in your publication. Paper; Journal; Notebook. 371. Fischer et al., ""Scattering into one-dimensional waveguides from a coherently-driven quantum-optical system"", ; Quantum 2, 69 (2018).; Notebook. 370. Fischer et al., ""Particle emission from open quantum systems"", ; arXiv:1803.04648; Notebook. 369. Sonar et al., ""Squeezing Enhances Quantum Synchronization"", ; arXiv:1801.10383. 368. Bergfield et al., ""Signatures of Plexitonic States in Molecular Electroluminescence"", ; Sci. Rep. 8, 2314 (2018). 367. Benedetti et al., ""A generative modeling approach for benchmarking and training shallow quantum circuits"", ; arXiv:1801.07686. 366. Botzem et al., ""Tuning methods for semiconductor spin--qubits"", ; arXiv:1801.03755. 365. Schneider et al., ""Local Sensing with an AC Stark Spectrum Analyzer"", ; arXiv:1801.05144. 364. Seah et al., ""Work production of quantum rotor engines"", ; arXiv:1801.02820. 363. Susa et al., ""Exponential Speedup of Quantum Annealing by Inhomogeneous Driving of the Transverse Field"", ; arXiv:1801.02005. 362. Hanschke et al., ""Quantum dot single photon sources with ultra-low multi-photon probability"", ; arXiv:1801.01672; Notebook. 361. Vermersch et al., ""Unitary n-designs via random quenches in atomic Hubbard and Spin models: Application to the measurement of Renyi entropies"", ; arXiv:1801.00999. 360. Krastanov et al., ""Optimized Entanglement Purification"", ; arXiv:1712.09762. 359. Dahlberg et al., ""SimulaQron - A simulator for developing quantum internet software"", ; arXiv:1712.08032. 358. Abdel-Wahab et al., ""Dynamic evolution of double",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:988,benchmark,benchmarking,988,users.html,https://qutip.org,https://qutip.org/users.html,1,['benchmark'],['benchmarking']
Testability," QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threashold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/changelog.html:2064,test,tests,2064,docs/4.1/changelog.html,https://qutip.org,https://qutip.org/docs/4.1/changelog.html,1,['test'],['tests']
Testability," Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Contributing to QuTiP Development. Contributing to QuTiP Development¶. Quick Start¶; QuTiP is developed through wide collaboration using the git version-control system, with the main repositories hosted in the qutip organisation on GitHub.; You will need to be familiar with git as a tool, and the GitHub Flow workflow for branching and making pull requests.; The exact details of environment set-up, build process and testing vary by repository and are discussed below, however in overview, the steps to contribute are:. Consider creating an issue on the GitHub page of the relevant repository, describing the change you think should be made and why, so we can discuss details with you and make sure it is appropriate.; (If this is your first contribution.) Make a fork of the relevant repository on GitHub and clone it to your local computer. Also add our copy as a remote (git remote add qutip https://github.com/qutip/<repo>); Begin on the master branch (git checkout master), and pull in changes from the main QuTiP repository to make sure you have an up-to-date copy (git pull qutip master).; Switch to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can check your changes work sensibly.; Run the tests for the repository (if ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:1049,test,testing,1049,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,2,['test'],['testing']
Testability," Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:16078,log,logger,16078,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,9,['log'],['logger']
Testability," Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html:16077,log,logger,16077,docs/4.4/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html,1,['log'],['logger']
Testability," Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Generating Random Quantum States & Operators; Composite random objects. « Saving QuTiP Obj... Modifying Intern... ». Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state generators for simulations, theorem evaluation, and code testing:. Function; Description. rand_ket; Random ket-vector. rand_dm; Random density matrix. rand_herm; Random Hermitian matrix. rand_unitary; Random Unitary matrix. See the API documentation: Random Operators and States for details.; In all cases, these functions can be called with a single parameter \(N\) that indicates a \(NxN\) matrix (rand_dm, rand_herm, rand_unitary), or a \(Nx1\) vector (rand_ket), should be generated. For example:; In [1]: rand_ket(5); Out[1]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[-0.37899439-0.03246954j]; [-0.09389192-0.30281261j]; [-0.41147565-0.20947105j]; [-0.41769426-0.02916778j]; [-0.54640563+0.26024817j]]. or; In [2]: rand_herm(5); Out[2]: ; Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = True; Qobj data =; [[-0.29514824+0.j 0.00000000+0.j -0.27781445-0.15337652j; -0.35652395-0.05592461j 0.00000000+0.j ]; [ 0.00000000+",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-random.html:1814,test,testing,1814,docs/3.1.0/guide/guide-random.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-random.html,1,['test'],['testing']
Testability," THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual',; 'concurrence', 'entropy_conditional', 'entangling_power']. from numpy import e, real, sort, sqrt; from scipy import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.qip.gates import swap. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html:3487,log,log,3487,docs/3.1.0/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html,1,['log'],['log']
Testability," TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators.; """""". __all__ = ['fidelity', 'tracedist', 'bures_dist', 'bures_angle',; 'hellinger_dist', 'hilbert_dist', 'average_gate_fidelity',; 'process_fidelity', 'unitarity', 'dnorm']. import numpy as np; from scipy import linalg as la; import scipy.sparse as sp; from qutip.sparse import sp_eigs; from qutip.states import ket2dm; from qutip.superop_reps import to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger(). try:; import cvxpy; except:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> fidelity(x,y); 0.24104350624628332. """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/metrics.html:2836,log,logging,2836,docs/4.4/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/metrics.html,6,['log'],"['logger', 'logging']"
Testability," Toolbox in Python. »; Change Log. Change Log¶. Version 4.6.3 (February ?, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method run_analytically of Processor. (#1603 Boxi Li); The hadamard_transform was made much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad init",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:2980,test,testing,2980,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,1,['test'],['testing']
Testability," True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now = (evo_init2t_recomp_now[1:]; | evo_t2ta",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html:16530,log,log,16530,docs/4.1/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html,20,['log'],"['log', 'logging']"
Testability," WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs':num_coeffs,; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type:; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and; not 'pulse_action' in guess_pulse_params",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:48926,log,logger,48926,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['log'],['logger']
Testability," Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:26636,log,logger,26636,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['log'],['logger']
Testability," [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:28122,log,logger,28122,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,10,['log'],['logger']
Testability," [self.sys_dims[1], self.sys_dims[0]]; self._onto_evo_target_qobj = Qobj(self._onto_evo_target,; dims=rev_dims). return self._onto_evo_target_qobj. def get_owd_evo_target(self):; _func_deprecation(""'get_owd_evo_target' has been replaced by ""; ""'onto_evo_target' property""); return self.onto_evo_target. def _get_onto_evo_target(self):; """"""; Get the inverse of the target.; Used for calculating the 'onto target' evolution; This is actually only relevant for unitary dynamics where; the target.dag() is what is required; However, for completeness, in general the inverse of the target; operator is is required; For state-to-state, the bra corresponding to the is required ket; """"""; if self.target.shape[0] == self.target.shape[1]:; #Target is operator; targ = la.inv(self.target.full()); if self.oper_dtype == Qobj:; rev_dims = [self.target.dims[1], self.target.dims[0]]; self._onto_evo_target = Qobj(targ, dims=rev_dims); elif self.oper_dtype == np.ndarray:; self._onto_evo_target = targ; else:; assert False, f""Unknown oper_dtype {self.oper_dtype!r}""; else:; if self.oper_dtype == Qobj:; self._onto_evo_target = self.target.dag(); elif self.oper_dtype == np.ndarray:; self._onto_evo_target = self.target.dag().full(); else:; assert False, f""Unknown oper_dtype {self.oper_dtype!r}"". return self._onto_evo_target. [docs] def combine_dyn_gen(self, k):; """"""; Computes the dynamics generator for a given timeslot; The is the combined Hamiltion for unitary systems; """"""; _func_deprecation(""'combine_dyn_gen' has been replaced by ""; ""'_combine_dyn_gen'""); self._combine_dyn_gen(k); return self._dyn_gen(k). def _combine_dyn_gen(self, k):; """"""; Computes the dynamics generator for a given timeslot; The is the combined Hamiltion for unitary systems; Also applies the phase (if any required by the propagation); """"""; if self.time_depend_drift:; dg = self._drift_dyn_gen[k]; else:; dg = self._drift_dyn_gen; for j in range(self._num_ctrls):; if self.time_depend_ctrl_dyn_gen:; dg = dg + self.ctrl_amps[k, j]*se",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:36387,assert,assert,36387,docs/4.6/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html,4,['assert'],['assert']
Testability," \(Q(t)\), then it is constructed from a set; of constant:obj:~qutip.Qobj \(\{Q_k\}\) and time-dependent scalars; \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples; for how to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype np.float64 or; np.complex128. A list of times (np.float64) at which the; coeffients must be given as tlist. The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; args = {""_step_func_coeff"": True}. Examples of array-format usage are:; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; QobjEvo that contains different tlist values, however.;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:18453,log,log,18453,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,2,['log'],['log']
Testability," `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------; cov_mat : ndarray; A 2-dimensional array of covariance values. """"""; if R is not None:. if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=object); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=object). elif a1 is not None and a2 is not None:. if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""). else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """""". A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2. sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu). return logneg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/continuous_variables.html:8242,log,logarithmic,8242,docs/4.5/modules/qutip/continuous_variables.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/continuous_variables.html,1,['log'],['logarithmic']
Testability," a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ecs in self.evo_summary:; if ecs.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ecs.get_header_line(self.summary_sep),; ecs.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ecs.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Dynamics dump summary saved to {}"".format(; self.summary_file)). for di in self.evo_dumps:; di.writeout(fall). if closefall:; fall.close(); logger.info(""Dynamics dump saved to {}"".format(f)); else:; if fall:; logger.info(""Dynamics dump saved to specified stream""); else:; logger.info(""Dynamics dump saved to {}"".format(self.dump_dir)). [docs]class DumpItem(object):; """"""; An item in a dump list; """"""; def __init__(self):; pass. [docs]class EvoCompDumpItem(DumpItem):; """"""; A copy of all objects generated to calculate one time evolution; Note the attributes are only set if the corresponding; :class:`DynamicsDump` dump_ attribute is set.; """"""; def __init__(self, dump):; if not isinstance(dump, DynamicsDump):; raise TypeError(""Must instantiate with {} type"".format(; DynamicsDump)); self.parent = dump; self.reset(). def reset(self):; self.idx = None; # self.num_ctrls = None; # self.num_tslots = None; self.ctrl_amps = None; self.dyn_gen = None; self.prop = None; self.prop_grad = None; self.fwd_evo = None; self.onwd_evo = None; self.onto_evo = None. [docs] def writeout(self, f=None):; """""" write all the objects out to files. Paramete",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dump.html:19909,log,logger,19909,docs/4.1/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dump.html,6,['log'],['logger']
Testability," a byte; mode file as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ecs in self.evo_summary:; if ecs.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ecs.get_header_line(self.summary_sep),; ecs.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ecs.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Dynamics dump summary saved to {}"".format(; self.summary_file)). for di in self.evo_dumps:; di.writeout(fall). if closefall:; fall.close(); logger.info(""Dynamics dump saved to {}"".format(f)); else:; if fall:; logger.info(""Dynamics dump saved to specified stream""); else:; logger.info(""Dynamics dump saved to {}"".format(self.dump_dir)). [docs]class DumpItem:; """"""; An item in a dump list; """"""; def __init__(self):; pass. [docs]class EvoCompDumpItem(DumpItem):; """"""; A copy of all objects generated to calculate one time evolution. Note the; attributes are only set if the corresponding :class:`DynamicsDump`; ``dump_*`` attribute is set.; """"""; def __init__(self, dump):; if not isinstance(dump, DynamicsDump):; raise TypeError(""Must instantiate with {} type"".format(; DynamicsDump)); self.parent = dump; self.reset(). def reset(self):; self.idx = None; # self.num_ctrls = None; # self.num_tslots = None; self.ctrl_amps = None; self.dyn_gen = None; self.prop = None; self.prop_grad = None; self.fwd_evo = None; self.onwd_evo = None; self.onto_evo = None. [docs] def writeout(self, f=None):; """""" write all the objects out to files. Parameters",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dump.html:19930,log,logger,19930,docs/4.6/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html,4,['log'],['logger']
Testability," a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in educa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:13635,log,logging,13635,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,4,['log'],['logging']
Testability," a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. [docs]def entropy_relative(rho, sigma, base=e, sparse=False, tol=1e-12):; """"""; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`qutip.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`qutip.Qobj`; Second density matrix (or ket which will be convert",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/entropy.html:5833,log,logarithm,5833,docs/4.6/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html,4,['log'],['logarithm']
Testability," a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. def _entropy_relative(rho, sigma, base=e, sparse=False):; """"""; ****NEEDS TO BE WORKED ON****. Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : qobj; First density matrix.; sigma : qobj; Second density matrix.; base : {e,2}; Base of logarithm. Returns; -------; rel_ent : float; Value of relative entropy. """,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/entropy.html:5781,log,logarithm,5781,docs/4.2/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/entropy.html,6,['log'],['logarithm']
Testability," and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init__(self, dynamics, params=None):; from qutip.control.dynamics import Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:4317,log,logger,4317,docs/4.5/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html,1,['log'],['logger']
Testability," and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation. - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:12708,log,logs,12708,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,4,['log'],['logs']
Testability," and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:11755,log,logs,11755,docs/4.3/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html,3,['log'],['logs']
Testability," and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:11755,log,logs,11755,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,3,['log'],['logs']
Testability," applied to the pulse; (copied from Dynamics.initial_ctrl_scaling if given). offset¶; float – linear offset applied to the pulse; (copied from Dynamics.initial_ctrl_offset if given). tau¶; array[num_tslots] of float – Duration of each timeslot; (copied from Dynamics if given). lbound¶; float – Lower boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is -Inf. ubound¶; float – Upper boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is Inf. periodic¶; boolean – True if the pulse generator produces periodic pulses. random¶; boolean – True if the pulse generator produces random pulses. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value. gen_pulse()[source]¶; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass. init_pulse()[source]¶; Initialise the pulse parameters. reset()[source]¶; reset attributes to default values. class PulseGenRandom(dyn=None, params=None)[source]¶; Generates random pulses as simply random values for each timeslot. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:103058,log,logger,103058,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['log'],['logger']
Testability," are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of tslotcomp.EvoCompSummarySummary items are appended if dump_summary is True; at each recomputation of the evolution. dump_ampsboolIf True control amplitudes are dumped. dump_dyn_genboolIf True the dynamics generators (Hamiltonians) are dumped. dump_propboolIf True propagators are dumped. dump_prop_gradboolIf True propagator gradients are dumped. dump_fwd_evoboolIf True forward evolution operators are dumped. dump_onwd_evoboolIf True onward evolution oper",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:245209,log,logs,245209,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['log'],['logs']
Testability," are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html:6562,log,logger,6562,docs/4.1/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html,9,['log'],['logger']
Testability," args[“w2”]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={“w1”:1., “w2”:2.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. sin cos tan asin acos atan pi; sinh cosh tanh asinh acosh atanh; exp log log10 erf zerf sqrt; real imag conj abs norm arg proj; numpy as np, and scipy.special as spe. Examples; H = QobjEvo([H0, [H1, ‘exp(-1j*w1*t)’], [H2, ‘cos(w2*t)’]],args={“w1”:1.,”w2”:2.}). For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; By default, a cubic spline interpolation will be used for the coefficient; at time t.; If the coefficients are to be treated as step function, use the arguments; args = {“_step_func_coeff”: True}; Examples. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],. tlist=tlist). args is a dict of (name:object). The name must be a valid variables string.; Some solvers support arguments that update at each call:; sesolve, mesolve, mcsolve:. state can be obtained with:“state_vec”:psi0, args[“state_vec”] = state as 1D np.ndarray; “state_mat”:psi0, args[“state_mat”] = state as 2D np.ndarray; “state”:psi0, args[“state”] = state as Qobj; This Qobj is the initial value. expectation values:“expect_op_n”:0, args[“expect_op_n”] = expect(e_ops[int(n)], state); expect is <phi|O|psi> or tr(state * O) depending on state dimensions. mcsolve:; collapse can be obtained with:“collapse”:list => args[name] == list of collapse; each collapse will be appended to the list as (time, which c_ops). Mixing the formats is possible, but not recommended.; Mixing tlist will cause problem. Parameters. QobjEvo(Q_object=[], args={}, tlist=None); Q_objectarray_likeData for vector/matrix representation of the quantum o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:18509,log,logspace,18509,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['log'],['logspace']
Testability," based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_com",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:89958,log,logger,89958,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,6,['log'],['logger']
Testability," because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:15427,log,logging,15427,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,10,['log'],['logging']
Testability," build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:12773,test,tests,12773,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,5,"['Test', 'test']","['Testing', 'test', 'tests']"
Testability," by using these optimized tools. As these libraries are multi-threaded, you can change the number of threads used in these packages by adding:; >>> import os; >>> os.environ['OPENBLAS_NUM_THREADS'] = '4'; >>> os.environ['MKL_NUM_THREADS'] = '4'. at the top of your Python script files, or iPython notebooks, and then loading the QuTiP framework. If these commands are not present, then QuTiP automatically sets the number of threads to one. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; Paul D. Nation & Robert J. Johansson. QuTiP Version: 3.1.0; Numpy Version: 1.9.1; Scipy Version: 0.14.0; Cython Version: 0.21.1; Matplotlib Version: 1.4.2; Fortran mcsolver: True; scikits.umfpack: False; Python Version: 2.7.9; Platform Info: Darwin (x86_64); Installation path: /opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/qutip. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:13014,test,tests,13014,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,1,['test'],['tests']
Testability," case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. epsilon¶; float – control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summary¶; EvoCompSummary – A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dump_current()[source]¶; Store a copy of the current time evolution. class TSlotCo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:99714,log,logger,99714,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['log'],['logger']
Testability," check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction facto",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:11213,log,logger,11213,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['log'],['logger']
Testability," code; resulting in a complex. The following symbols are defined:. .. code-block::. pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:. .. code-block:: python. H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype ``np.float64`` or; ``np.complex128``. A list of times (``np.float64``) at which the; coeffients must be given as ``tlist``. The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; ``args = {""_step_func_coeff"": True}``. Examples of array-format usage are:. .. code-block:: python. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; ``QobjEvo`` that contains different ``tlist`` values, however. **Passing arguments**. ``args`` is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string. There are some ""magic"" names that can be specified, whose objects will be; overwritten when used within :func:`.sesolve`, :func:`.mesolve` and; :func:`.mcsolve`. This allows access to the solvers' internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. - ``""state""``: the current state as a :class:`~Qobj`; - ``""state_vec""``: the current state as a column-stacked 1D ``np.ndarray``; - ``""state_mat""``: the current state as a 2D ``np.ndarray``; - ``""expect_op_<n>""``: the curre",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:8802,log,logspace,8802,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,2,['log'],['logspace']
Testability," code; resulting in a complex. The following symbols are defined:. .. code-block::. pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:. .. code-block:: python. H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype ``np.float64`` or; ``np.complex128``. A list of times (``np.float64``) at which the; coeffients must be given as ``tlist``. The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; ``args = {""_step_func_coeff"": True}``. Examples of array-format usage are:. .. code-block:: python. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; ``QobjEvo`` that contains different ``tlist`` values, however. **Passing arguments**. ``args`` is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string. There are some ""magic"" names that can be specified, whose objects will be; overwritten when used within :func:`.sesolve`, :func:`.mesolve` and; :func:`.mcsolve`. This allows access to the solvers' internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. - ``""state""``: the current state as a :class:`~qutip.Qobj`; - ``""state_vec""``: the current state as a column-stacked 1D ``np.ndarray``; - ``""state_mat""``: the current state as a 2D ``np.ndarray``; - ``""expect_op_<n>""``: the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:7113,log,logspace,7113,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,2,['log'],['logspace']
Testability," directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities betw",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/docs.html:2337,test,testcode,2337,docs/4.6/development/docs.html,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html,4,['test'],['testcode']
Testability," do the installation from source using python3 instead of python.; Optional, but recommended, dependencies can be installed using:; sudo apt-get install texlive-latex-extra # recommended for plotting; sudo apt-get install mayavi2 # optional, for Bloch3d only; sudo apt-get install libblas-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install liblapack-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install gfortran # optional, for Fortran Monte Carlo solver. Installation on Mac OS X (10.8+)¶. Setup Using Homebrew¶; The latest version of QuTiP can be quickly installed on OS X using Homebrew and the automated installation shell scripts. Python 2.7 installation script; Python 3.4 installation script. Having downloaded the script corresponding to the version of Python you want to use, the installation script can be run from the terminal using (replacing X with 2 or 3); sh install_qutip_pyX.sh. The script will then install Homebrew and the required QuTiP dependencies before installing QuTiP itself and running the built in test suite. Any errors in the homebrew configuration will be displayed at the end. Using Python 2.7 or 3.4, the python commend-line and IPython interpreter can be run by calling python and ipython or python3 and ipython3, respectively.; If you have installed other packages in the /usr/local/ directory, or have changed the permissions of any of its sub-directories, then this script may fail to install all the necessary tools automatically. Setup Using Macports¶; If you have not done so already, install the Apple Xcode developer tools from the Apple App Store. After installation, open Xcode and go to: Preferences -> Downloads, and install the ‘Command Line Tools’.; On the Mac OS, you can install the required libraries via MacPorts. After installation, the necessary “ports” for QuTiP may be installed via (Replace ‘34’ with ‘27’ if you want Python 2.7); sudo port install py34-scipy; sudo port install py34-matplotlib +latex; sudo p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:7129,test,test,7129,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,1,['test'],['test']
Testability," doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (jake@binhbar.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; https://www.tensorflow.org/. 2; https://github.com/tehruhn/bofin. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html:2516,benchmark,benchmark,2516,docs/4.6/development/ideas/tensorflow-data-backend.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html,6,['benchmark'],['benchmark']
Testability," dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm¶; float – Normalisation constant. fid_norm_func¶; function – Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func¶; function – Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo¶; boolean – flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo¶; boolean –. flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err¶; float – Last computed value of the fidelity error. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:92102,log,logger,92102,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['log'],['logger']
Testability," e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise ValueError(""Input rho has non-real eigenvalues.""); rvals = real(rvals); svals, svecs = sp_eigs(sigma.data, sigma.isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals) >= tol]; # Calculate S; S = nzrvals @ log_base(nzrvals) - rvals @ P @ log_base(svals); # the relative entropy is guaranteed to be >= 0, so we clamp the; # calculated value to 0 to avoid small violations of the lower bound.; return max(0, S). [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effectiv",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/entropy.html:9053,log,log,9053,docs/4.6/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html,4,['log'],['log']
Testability," each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:28540,log,logger,28540,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,10,['log'],['logger']
Testability," entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:rho : qobj. Density matrix of composite object. selB : int/list. Selected components for density matrix B. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_cond : float. Value of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:rho : qobj. sensity matrix or ket/bra vector. Returns:entropy : float. Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters:rho : qobj. Density matrix for composite quantum systems. selA : int/list. int or list of first selected density matrix components. selB : int/list. int or list of second selected density matrix components. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_mut : float. Mutual information between selected components. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy of density matrix. Parameters:rho : qobj. Density matrix. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:entropy : float. Von-Neumann entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. Density Matrix Metrics¶; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators. fidelity(A, B)[source]¶; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters:A : qobj. Density matrix or state vector. B : qobj. Density matrix or state vector with same dimensions as A. Returns:fid : float. Fidelity pseudo-metric between A and B. Examples; >>> x = f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:45168,log,logarithm,45168,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['log'],['logarithm']
Testability," exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""). anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True. if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True. if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""). [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent. if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/tslotcomp.html:6550,log,logger,6550,docs/4.4/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/tslotcomp.html,1,['log'],['logger']
Testability," fill_factor=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). P_x = lambda x: P.solve(x); M = LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precond",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:20627,log,logger,20627,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,2,['log'],['logger']
Testability," for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). optim = create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=num_tslots, evo_time=evo_time, tau=tau,; amp_lbound=amp_lbound, amp_ubound=amp_ubound,; fid_err_targ=fid_err_targ, min_grad=min_grad,; max_iter=max_iter, max_wall_time=max_wall_time,; optim_alg=optim_alg, max_metric_corr=max_metric_corr,; accuracy_factor=accuracy_factor,; dyn_type=dyn_type, prop_type=prop_type,; fid_type=fid_type, phase_option=phase_option,; fid_err_scale_factor=fid_err_scale_factor,; amp_update_mode=amp_update_mode, init_pulse_type=init_pulse_type,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics; p_gen = optim.pulse_generator. if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial operator:\n""; msg += str(dyn.initial); msg += ""\nTarget operator:\n""; msg += str(dyn.target); logger.info(msg). # Generate pulses for each control; init_amps = np.zeros([num_tslots, dyn.num_ctrls]); for j in range(dyn.num_ctrls):; init_amps[:, j] = p_gen.gen_pulse(). # Initialise the starting amplitudes; dyn.initialize_controls(init_amps). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:11776,log,logging,11776,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['log'],['logging']
Testability," for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:187462,log,logger,187462,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['log'],['logger']
Testability," graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/steadystate.html:25504,log,logger,25504,docs/4.7/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html,2,['log'],['logger']
Testability," if np.isnan(g):; g = np.Inf. grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiffApprox(FidCompTraceDiff):; """"""; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes; ----------; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude; ; """"""; [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:23023,log,logging,23023,docs/4.3/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html,7,['log'],['logging']
Testability," if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:26175,log,logger,26175,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,2,['log'],['logger']
Testability," if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if has_mkl:; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='cs",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:21513,log,logger,21513,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['log'],['logger']
Testability," import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instanti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:3626,log,logger,3626,docs/4.5/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html,5,['log'],['logger']
Testability," import scipy.sparse as sp; from qutip.sparse import sp_eigs; from qutip.states import ket2dm; from qutip.superop_reps import to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem, dnorm_sparse_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger('qutip.metrics'). try:; import cvxpy; except ImportError:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; if B.isket or B.isbra:; # The fidelity for pure states reduces to the modulus of their; # inner product.; return np.abs(A.overlap(B)); # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/metrics.html:1720,test,testing,1720,docs/4.7/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html,2,['test'],['testing']
Testability," in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28)¶; This is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes¶. Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace always return density matrix (#2185, issue by udevd); mesolve can support mixed callable and Qobj for e_ops (#2184 issue by balopat). Version 4.7.1 (December 11, 2022)¶; This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features¶. Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes¶. Change floquet_master_equation_rates(…) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:4699,log,logger,4699,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['log'],['logger']
Testability," in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the sa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/docs.html:2082,test,test,2082,docs/4.6/development/docs.html,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html,4,['test'],['test']
Testability," initialised, otherwise they will all be equal to self.scaling; """"""; def __init__(self, dyn=None, num_coeffs=None, params=None):; self.parent = dyn; self.num_coeffs = num_coeffs; self.params = params; self.reset(); ; [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.NUM_COEFFS_WARN_LVL = 20; self.DEF_NUM_COEFFS = 4; self._BSC_ALL = 1; self._BSC_GT_MEAN = 2; self._BSC_LT_MEAN = 3; ; self._uses_time = True; self.time = None; self.num_basis_funcs = 2; self.num_optim_vars = 0; self.coeffs = None; self.randomize_coeffs = True; self._num_coeffs_estimated = False; self.guess_pulse_action = 'MODULATE'; self.guess_pulse = None; self.guess_pulse_func = None; self.apply_params(); ; [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGen.init_pulse(self); self.init_coeffs(num_coeffs=num_coeffs); ; if self.guess_pulse is not None:; self.init_guess_pulse(); self._init_bounds(); ; if self.log_level <= logging.DEBUG and not self._num_coeffs_estimated:; logger.debug(; ""CRAB pulse initialised with {} coefficients per basis ""; ""function, which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html:29082,log,logging,29082,docs/4.1/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html,5,['log'],['logging']
Testability," initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:19166,log,log,19166,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,6,['log'],"['log', 'logging']"
Testability," installation alternatives are given below. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). Installation on MS Windows¶; We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also wor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/installation.html:5883,test,tests,5883,docs/4.0.2/installation.html,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html,2,['test'],"['testing', 'tests']"
Testability," inverse target; self.evo_t2targ = [np.empty(shp, dtype=complex); for x in range(self.num_tslots + 1)]; self.evo_t2targ[-1] = self.get_owd_evo_target(). if isinstance(self.prop_computer, propcomp.PropCompDiag):; self._create_decomp_lists(). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; shp = self.drift_dyn_gen.shape; n_ts = self.num_tslots; self.decomp_curr = [False for x in range(n_ts)]; self.prop_eigen = \; [np.empty(shp[0], dtype=complex) for x in range(n_ts)]; self.dyn_gen_eigenvectors = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]; self.dyn_gen_factormatrix = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]. def _check_test_out_files(self):; cfg = self.config; if cfg.any_test_files():; if not cfg.check_create_test_out_dir():; cfg.reset_test_out_files(); else:; if self.stats is None:; logger.warn(""Cannot output test files when stats""; "" attribute is not set.""); self.config.test_out_amps = False; self.config.test_out_prop = False; self.config.test_out_prop_grad = False; self.config.test_out_evo = False. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; self._check_test_out_files(). if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FideliyComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:14597,test,test,14597,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['test'],['test']
Testability," is described; by symplectic matrices, e.g. coupled oscillators, quantum optics; Attributes. omega; (array[drift_dyn_gen.shape]) matrix used in the calculation of propagators (time evolution) with symplectic systems. dyn_gen_phase¶; The prephasing operator for the symplectic group generators; usually refered to as Omega. class PropagatorComputer(dynamics, params=None)[source]¶; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application; Attributes. log_level; (integer) level of messaging output from the logger. Options are attributes of qutip_utils.logging, in decreasing levels of messaging, are: DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL Anything WARN or above is effectively ‘quiet’ execution, assuming everything runs as expected. The default NOTSET implies that the level will be taken from the QuTiP settings file, which by default is WARN. grad_exact; (boolean) indicates whether the computer class instance is capable of computing propagator gradients. It is used to determine whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:85684,log,logging,85684,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['log'],['logging']
Testability," is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_options attribute may already contain items.; These values will NOT be overridden; """"""; tc = self.termination_conditions; if self.method_options is None:; self.method_options = {}; mo = self.method_options. if 'max_metric_corr' in mo and not 'maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(self, 'max_metric_corr') and not 'maxcor' in mo:; mo['maxcor'] = self.max_metric_corr; if 'accuracy_factor' in mo and not 'ftol' in mo:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:14040,log,logger,14040,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['log'],['logger']
Testability," is used for; adding the missing coefficient according to `spline_kind`. Returns; -------; coeffs: array-like 2d; The coefficients for all ideal pulses.; """"""; # TODO add tests; self._is_pulses_valid(); if not self.pulses:; return np.array((0, 0), dtype=float); full_tlist = self.get_full_tlist(); coeffs_list = []; for pulse in self.pulses:; if isinstance(pulse.coeff, bool):; if pulse.coeff:; coeffs_list.append(np.ones(full_tlist)); else:; coeffs_list.append(np.zeros(full_tlist)); if not isinstance(pulse.coeff, np.ndarray):; raise ValueError(; ""get_full_coeffs only works for ""; ""NumPy array or bool coeff.""); if self.spline_kind == ""step_func"":; arg = {""_step_func_coeff"": True}; coeffs_list.append(; _fill_coeff(pulse.coeff, pulse.tlist, full_tlist, arg)); elif self.spline_kind == ""cubic"":; coeffs_list.append(; _fill_coeff(pulse.coeff, pulse.tlist, full_tlist, {})); else:; raise ValueError(""Unknown spline kind.""); return np.array(coeffs_list). [docs] def set_all_tlist(self, tlist):; # TODO add tests; """"""; Set `tlist` for all the pulses. It can be used to set `tlist` if; all pulses are controlled by the same time sequence. Parameters; ----------; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied. See :class:`qutip.qip.Pulse` for detailed information`; """"""; for pulse in self.pulses:; pulse.tlist = tlist. [docs] def add_pulse(self, pulse):; """"""; Add a new pulse to the device. Parameters; ----------; pulse: :class:`qutip.qip.Pulse`; `Pulse` object to be added.; """"""; if isinstance(pulse, Pulse):; if pulse.spline_kind is None:; pulse.spline_kind = self.spline_kind; self.pulses.append(pulse); else:; raise ValueError(""Invalid input, pulse must be a Pulse object""). [docs] def remove_pulse(self, indices):; """"""; Remove the control pulse with given indices. Parameters; ----------; indices: int or list of int; The indices of the control Hamiltonians to be removed.; """"""; if not isinstance(indices, Iterable):; indices = [indices]; indices",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html:9908,test,tests,9908,docs/4.5/modules/qutip/qip/device/processor.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html,1,['test'],['tests']
Testability," iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; optim_var_vals, cost, grad, invHess, nFCalls, nGCalls, warn = \; spopt.fmin_bfgs(self.fid_err_func_wrapper,; self.optim_var_vals,; fprime=fprime,; # approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:27081,log,logger,27081,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['log'],['logger']
Testability," libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.4+ is highly recommended. Numpy; 1.8+; Not tested on lower versions. Scipy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. gfortran; 4.2+; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Needed for using the Bloch3d class. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are tested only on the Linux and OS X platforms.; We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platforms. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/installation.html:1600,test,test,1600,docs/4.0.2/installation.html,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html,1,['test'],['test']
Testability," logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], 'csc'); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, 'csc'); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % round(; old_band/rcm_band, 1)); logger.debug('Profile reduction factor: %f' % round(; old_pro/rcm_pro, 1)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-6, itertol=1e-5, method='solve',; use_umfpack=False, use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_umfpack=use_umfpack, use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = prod(L.dims[0][0]); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(pe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:12390,log,logger,12390,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['log'],['logger']
Testability," logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], 'csc'); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, 'csc'); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % round(; old_band/rcm_band, 1)); logger.debug('Profile reduction factor: %f' % round(; old_pro/rcm_pro, 1)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-6, itertol=1e-5, method='solve',; use_umfpack=False, use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_umfpack=use_umfpack, use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = prod(L.dims[0][0]); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=Tr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:12470,log,logger,12470,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['log'],['logger']
Testability," logger.debug('Starting direct dense solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L = L.data.todense(); L[0, :] = np.diag(ss_args['weight']*np.ones(n)).reshape((1, n ** 2)); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec, np.inf); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp, _temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:17959,log,logger,17959,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['log'],['logger']
Testability," max_wall_time=max_wall_time,; alg=alg, alg_params=alg_params, optim_params=optim_params,; optim_method=optim_method, method_params=method_params,; dyn_type=dyn_type, dyn_params=dyn_params, ; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics. dyn.init_timeslots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]); ; if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:17532,log,logging,17532,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,5,['log'],['logging']
Testability," means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)). # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse. [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values. Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs. self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs. if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)). if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs,; self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; --",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:30186,log,logger,30186,docs/4.6/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html,4,['log'],['logger']
Testability," method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. Time-dependent coefficients using any of the following functions, or combinations thereof (including constants) can be compiled directly into C-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'conj',; 'cos', 'cosh','exp', 'imag', 'log', 'pow', 'proj, 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the numpy math library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. The available functions can be found using; In [1]: import numpy as np. In [2]: np.array(dir(np.math)[6:]); Out[2]: ; array(['asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign',; 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1',; 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma',; 'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10',; 'log1p', 'modf', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh', 'trunc'], ; dtype='|S9'). Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:4842,log,log,4842,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,1,['log'],['log']
Testability," mode = 'a'; f = open(self.fid_err_file, mode); f.write(""{}\n"".format(fid_err)); f.close(). @property; def grad_norm_file(self):; if self._grad_norm_file is None:; fname = ""{}-grad_norm_log.{}"".format(self.fname_base,; self.dump_file_ext); self._grad_norm_file = os.path.join(self.dump_dir, fname); return self._grad_norm_file. [docs] def update_grad_norm_log(self, grad_norm):; """"""add an entry to the grad_norm log""""""; self.grad_norm_log.append(grad_norm); if self.write_to_file:; if len(self.grad_norm_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.grad_norm_file, mode); f.write(""{}\n"".format(grad_norm)); f.close(). [docs] def update_grad_log(self, grad):; """"""add an entry to the grad log""""""; self.grad_log.append(grad); if self.write_to_file:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; len(self.grad_log),; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). [docs] def writeout(self, f=None):; """"""write all the logs and the summary out to file(s). Parameters; ----------; f : filename or filehandle; If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ois in self.iter_summary:; if ois.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.ge",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dump.html:11706,log,logs,11706,docs/4.1/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dump.html,10,['log'],['logs']
Testability," norm of. BQobj or NoneIf provided, the diamond norm of \(A - B\) is taken instead. solverstrSolver to use with CVXPY. One of “CVXOPT” (default) or “SCS”. The; latter tends to be significantly faster, but somewhat less accurate. verboseboolIf True, prints additional information about the solution. force_solveboolIf True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument. sparseboolWhether to use sparse matrices in the convex optimisation problem.; Default True. Returns. dnfloatDiamond norm of q_oper. Raises. ImportErrorIf CVXPY cannot be imported. fidelity(A, B)[source]¶; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. fidfloatFidelity pseudo-metric between A and B. Examples; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332). hellinger_dist(A, B, sparse=False, tol=0)[source]¶; Calculates the quantum Hellinger distance between two density matrices.; Formula:; hellinger_dist(A, B) = sqrt(2-2*Tr(sqrt(A)*sqrt(B))); See: D. Spehner, F. Illuminati, M. Orszag, and W. Roga, “Geometric; measures of quantum correlations with Bures and Hellinger distances”; arXiv:1611.03449. Parameters. Aqutip.QobjDensity matrix or state vector. Bqutip.QobjDensity matrix or state vector with same dimensions as A. tolfloatTolerance used by sparse eigensolver, if used. (0=Machine precision). sparse{False, True}Use sparse eigensolver. Returns. hellinger_distfloatQuantum Hellinger distance between A and B. Ranges from 0 to sqrt(2). Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(hellinger_dist(x,y), 1.3725145002591095). hilbert_dist(A, B)[source]¶; Returns the Hilbert-Schmidt distance between two density matrices A & B. Parameters. AqobjD",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:64894,test,testing,64894,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['test'],['testing']
Testability," of a selected density matrix component. Parameters:; rho (qobj) – Density matrix of composite object; selB (int/list) – Selected components for density matrix B; base ({e,2}) – Base of logarithm.; sparse ({False,True}) – Use sparse eigensolver. Returns:ent_cond – Value of conditional entropy. Return type:float. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:rho (qobj) – sensity matrix or ket/bra vector. Returns:entropy – Linear entropy of rho. Return type:float. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters:; rho (qobj) – Density matrix for composite quantum systems; selA (int/list) – int or list of first selected density matrix components.; selB (int/list) – int or list of second selected density matrix components.; base ({e,2}) – Base of logarithm.; sparse ({False,True}) – Use sparse eigensolver. Returns:ent_mut – Mutual information between selected components. Return type:float. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy of density matrix. Parameters:; rho (qobj) – Density matrix.; base ({e,2}) – Base of logarithm.; sparse ({False,True}) – Use sparse eigensolver. Returns:entropy – Von-Neumann entropy of rho. Return type:float. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. Density Matrix Metrics¶; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators. fidelity(A, B)[source]¶; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters:; A (qobj) – Density matrix or state vector.; B (qobj) – Density matrix or state vector with same dimensions as A. Returns:fid – Fidelity pseudo-metr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:46772,log,logarithm,46772,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['log'],['logarithm']
Testability," of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to ``None`` will suppress the output; of files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs': num_coeffs,; 'init_coeff_scaling': init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type:; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_acti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:38523,log,logging,38523,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['log'],['logging']
Testability," of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). optim = create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=num_tslots, evo_time=evo_time, tau=tau,; amp_lbound=amp_lbound, amp_ubound=amp_ubound,; fid_err_targ=fid_err_targ, min_grad=min_grad,; max_iter=max_iter, max_wall_time=max_wall_time,; optim_alg=optim_alg, max_metric_corr=max_metric_corr,; accuracy_factor=accuracy_factor,; dyn_type=dyn_type, prop_type=prop_type,; fid_type=fid_type, phase_option=phase_option,; fid_err_scale_factor=fid_err_scale_factor,; amp_update_mode=amp_update_mode, init_pulse_type=init_pulse_type,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics; p_gen = optim.pulse_generator. if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:10996,log,logger,10996,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['log'],['logger']
Testability," of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient compilation. (issue raised by nohchangsuk). Bug Fixes¶. Safer naming for temporary files. (by Eric Giguère); Fix clebsch function for half-integer (by Thomas Walker); Fix randint’s dtype to uint32 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in favour of scipy.sparse.csgraph. Developer Changes¶. Add Boxi Li to authors. (by Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:18254,test,testing,18254,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['test'],['testing']
Testability," on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are detailed instructions on how to contribute code and documentation in the developers’ section of this guide.; You can also help out our users by answering questions in the QuTiP discussion mailing list, or by raising issues in the main GitHub repository if you find any bugs.; Anyone who contributes code will be duly recognized.; Even small contributions are noted.; See Contributors for a list of people who have helped in one way or another. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/frontmatter.html:6011,test,test,6011,docs/4.6/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html,1,['test'],['test']
Testability," on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Pulser; Pulser is a framework for composing, simulating and executing pulse sequences for neutral-atom quantum devices. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are detailed instructions on how to contribute code and documentation in the developers’ section of this guide.; You can also help out our users by answering questions in the QuTiP discussion mailing list, or by raising issues in the main GitHub repository if you find any bugs.; Anyone who contributes code will be duly recognized.; Even small contributions are noted.; See Contributors for a list of people who have helped in one way or another. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/frontmatter.html:6266,test,test,6266,docs/4.7/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html,1,['test'],['test']
Testability," operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)). if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)). if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)). if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)). if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)). def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken from Qobj.expm(); # if method is not explicitly given, try to make a good choice; # between sparse and dense solvers by considering the size of the; # system and the number of non-zero elements.; if self.time_depend_drift:; dg = self.drift_dyn_gen[0]; else:; dg = self.drift_dyn_gen; if self.time_depend_ctrl_dyn_gen:; ctrls = self.ctrl_dyn_gen[0, :]; else:; ctrls = self.ctrl_dyn_gen; for c in ctrls:; dg = dg + c. N = dg.data.shape[0]; n = dg.data.nnz. if N ** 2 < 100 * n:; # large number of nonzero elements, revert to dense solver; self.oper_dtype = np.ndarray; elif N > 400:; # large system, and quite sparse -> qutips sparse method; self.oper_dtype = Qobj; else:; # small system, but quite sparse -> qutips sparse/dense meth",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:22108,log,logger,22108,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,6,['log'],['logger']
Testability," optional; If true, include drift Hamiltonians. Default is False. Returns; -------; noisy_pulses: list of :class:`.Pulse`; A list of noisy pulses.; """"""; pulses = deepcopy(self.pulses); noisy_pulses = process_noise(; pulses, self.noise, self.dims, t1=self.t1, t2=self.t2,; device_noise=device_noise); if drift:; noisy_pulses += [self.drift]; return noisy_pulses. [docs] def get_qobjevo(self, args=None, noisy=False):; """"""; Create a :class:`qutip.QobjEvo` representation of the evolution.; It calls the method `get_noisy_pulses` and create the `QobjEvo`; from it. Parameters; ----------; args: dict, optional; Arguments for :class:`qutip.QobjEvo`; noisy: bool, optional; If noise are included. Default is False. Returns; -------; qobjevo: :class:`qutip.QobjEvo`; The :class:`qutip.QobjEvo` representation of the unitary evolution.; c_ops: list of :class:`qutip.QobjEvo`; A list of lindblad operators is also returned. if ``noisy==Flase``,; it is always an empty list.; """"""; # TODO test it for non array-like coeff; # check validity; self._is_pulses_valid(). if args is None:; args = {}; else:; args = args; # set step function. if not noisy:; dynamics = self.pulses; else:; dynamics = self.get_noisy_pulses(; device_noise=True, drift=True). qu_list = []; c_ops = []; for pulse in dynamics:; if noisy:; qu, new_c_ops = pulse.get_noisy_qobjevo(dims=self.dims); c_ops += new_c_ops; else:; qu = pulse.get_ideal_qobjevo(dims=self.dims); qu_list.append(qu). final_qu = _merge_qobjevo(qu_list); final_qu.args.update(args). # bring all c_ops to the same tlist, won't need it in QuTiP 5; full_tlist = self.get_full_tlist(); temp = []; for c_op in c_ops:; temp.append(_merge_qobjevo([c_op], full_tlist)); c_ops = temp. if noisy:; return final_qu, c_ops; else:; return final_qu, []. [docs] def run_analytically(self, init_state=None, qc=None):; """"""; Simulate the state evolution under the given `qutip.QubitCircuit`; with matrice exponentiation. It will calculate the propagator; with matrix exponentiation and ret",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html:16746,test,test,16746,docs/4.6/modules/qutip/qip/device/processor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html,4,['test'],['test']
Testability," or a numpy array. For function format, the function signature must be f(t, args).; *Examples*; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; sin cos tan asin acos atan pi; sinh cosh tanh asinh acosh atanh; exp log log10 erf zerf sqrt; real imag conj abs norm arg proj; numpy as np, and scipy.special as spe.; *Examples*; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; *Examples*; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). args is a dict of (name:object). The name must be a valid variables string.; Some solvers support arguments that update at each call:; sesolve, mesolve, mcsolve:; state can be obtained with:; name+""=vec"":Qobj => args[name] == state as 1D np.ndarray; name+""=mat"":Qobj => args[name] == state as 2D np.ndarray; name+""=Qobj"":Qobj => args[name] == state as Qobj. This Qobj is the initial value. expectation values:; name+""=expect"":O (Qobj/QobjEvo) => args[name] == expect(O, state); expect is <phi|O|psi> or tr(state * O) depending on state dimensions. mcsolve:; collapse can be obtained with:; name+""=collapse"":list => args[name] == list of collapse; each collapse will be appended to the list as (time, which c_ops). Mixing the formats is possible, but not recommended.; Mixing tlist will cause problem. Parameters; ----------; QobjEvo(Q_object=[], args={}, tlist=None). Q_object : array_like; Data for vector/matrix represe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html:7041,log,logspace,7041,docs/4.4/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html,1,['log'],['logspace']
Testability," or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Function converged (w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:38237,log,logger,38237,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['log'],['logger']
Testability," or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Func",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:38222,log,logging,38222,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['log'],['logging']
Testability," parameters; if not isinstance(drift, Qobj):; raise TypeError(""drift must be a Qobj""); else:; drift = drift.full(). if not isinstance(ctrls, (list, tuple)):; raise TypeError(""ctrls should be a list of Qobj""); else:; j = 0; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""ctrls should be a list of Qobj""); else:; ctrls[j] = ctrl.full(); j += 1. if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""); else:; initial = initial.full(). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); else:; target = target.full(). cfg = optimconfig.OptimConfig(); cfg.optim_alg = optim_alg; cfg.max_metric_corr = max_metric_corr; cfg.accuracy_factor = accuracy_factor; cfg.amp_update_mode = amp_update_mode; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.pulse_type = init_pulse_type; cfg.phase_option = phase_option; cfg.amp_lbound = amp_lbound; cfg.amp_ubound = amp_ubound. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type). # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_type == 'AUG_MAT':; if not isinstance(dyn.prop_computer, pro",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:26920,log,logger,26920,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['log'],['logger']
Testability," pulses.""); for i, coeff in enumerate(coeffs_list):; self.pulses[i].coeff = coeff. [docs] def get_full_tlist(self):; """"""; Return the full tlist of the ideal pulses.; It means that if different `tlist`s are present, they will be merged; to one with all time points stored in a sorted array. Returns; -------; full_tlist: array-like 1d; The full time sequence for the ideal evolution.; """"""; all_tlists = [pulse.tlist; for pulse in self.pulses if pulse.tlist is not None]; if not all_tlists:; return None; return np.unique(np.sort(np.hstack(all_tlists))). [docs] def get_full_coeffs(self):; """"""; Return the full coefficients in a 2d matrix form.; Each row corresponds to one pulse. If the `tlist` are; different for different pulses, the length of each row; will be same as the `full_tlist` (see method; `get_full_tlist`). Interpolation is used for; adding the missing coefficient according to `spline_kind`. Returns; -------; coeffs: array-like 2d; The coefficients for all ideal pulses.; """"""; # TODO add tests; self._is_pulses_valid(); if not self.pulses:; return np.array((0, 0), dtype=float); full_tlist = self.get_full_tlist(); coeffs_list = []; for pulse in self.pulses:; if isinstance(pulse.coeff, bool):; if pulse.coeff:; coeffs_list.append(np.ones(full_tlist)); else:; coeffs_list.append(np.zeros(full_tlist)); if not isinstance(pulse.coeff, np.ndarray):; raise ValueError(; ""get_full_coeffs only works for ""; ""NumPy array or bool coeff.""); if self.spline_kind == ""step_func"":; arg = {""_step_func_coeff"": True}; coeffs_list.append(; _fill_coeff(pulse.coeff, pulse.tlist, full_tlist, arg)); elif self.spline_kind == ""cubic"":; coeffs_list.append(; _fill_coeff(pulse.coeff, pulse.tlist, full_tlist, {})); else:; raise ValueError(""Unknown spline kind.""); return np.array(coeffs_list). [docs] def set_all_tlist(self, tlist):; # TODO add tests; """"""; Set `tlist` for all the pulses. It can be used to set `tlist` if; all pulses are controlled by the same time sequence. Parameters; ----------; tlist: ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html:9073,test,tests,9073,docs/4.5/modules/qutip/qip/device/processor.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html,1,['test'],['tests']
Testability," requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradien",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:16208,log,logging,16208,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,9,['log'],['logging']
Testability," requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html:16207,log,logging,16207,docs/4.4/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html,1,['log'],['logging']
Testability," scipy.sparse.linalg import (use_solver, splu, spilu, spsolve, eigs,; LinearOperator, gmres, lgmres, bicgstab); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_reshape, sp_profile. from qutip.superoperator import liouvillian, vec2mat; from qutip.sparse import (sp_permute, sp_bandwidth, sp_reshape, ; sp_profile); from qutip.cy.spmath import zcsr_kron; from qutip.graph import reverse_cuthill_mckee, weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.utilities import _version2int; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). # test if scipy is recent enought to get L & U factors from superLU; _scipy_check = _version2int(scipy.__version__) >= _version2int('0.14.0'). def _empty_info_dict():; def_info = {'perm': [], 'solution_time': None, 'iterations': None,; 'residual_norm': None, 'rcm_time': None, 'wbm_time': None,; 'iter_time': None, 'precond_time': None, 'ILU_MILU': None,; 'fill_factor': None, 'diag_pivot_thresh': None, ; 'drop_tol': None, 'permc_spec': None, 'weight': None}; ; return def_info. def _default_steadystate_args():; def_args = {'method': 'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'weight': None, 'use_precond': False, ; 'all_states': False, 'M': None, 'x0': None, 'drop_tol': 1e-4, ; 'fill_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000, ; 'tol': 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', ; 'restart': 20, 'return_info': False, 'info': _empty_info_dict(), ; 'verbose': False}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:3456,test,test,3456,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['test'],['test']
Testability," scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure¶; With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:3683,test,testing,3683,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,4,['test'],['testing']
Testability," second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. def _entropy_relative(rho, sigma, base=e, sparse=False):; """"""; ****NEEDS TO BE WORKED ON**** (after 2.0 release). Calculates the relative entropy S(rho||sigma) between two density; matrices.. Parameters; ----------; rho : qobj; First density matrix.; sigma : qobj; Second density matrix.; base : {e,2}; Base of logarithm. Returns; -------; rel_ent : float; Value of relative entropy. """"""; if rho.type != 'oper' or sigma.type != 'oper':; raise TypeError(""Inputs must be density matrices..""); # sigma terms; svals = sp_eigs(sigma.data, sigma.isherm, vecs=False, sparse=sparse); snzvals = svals[svals != 0]; if base == 2:; slogvals = log2(snzvals); elif base == e:; slogvals = log(snzvals); else:; raise ValueError(""Base must be 2 or e.""); # rho terms; rvals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); rnzvals = rvals[rvals != 0]; # calculate tr(rho*log sigma); rel_trace = float(real(sum(rnzvals * slogvals))); return -entropy_vn(rho, base, sparse) - rel_trace. [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a slected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of lo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html:7235,log,logarithm,7235,docs/3.1.0/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html,1,['log'],['logarithm']
Testability," self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:7394,log,logger,7394,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,9,['log'],['logger']
Testability," self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html:7388,log,logger,7388,docs/4.4/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html,1,['log'],['logger']
Testability," self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs. [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats; """"""; return self.coeffs.ravel().tolist(). [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the; # main optmisation call sequence; self.set_coeffs(param_vals). def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]). def init_guess_pulse(self):. self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)). def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse. def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse. def _init_bounds(self):; add_guess_pulse_scale = False; if self.lbound is None and self.ubound is None:; # no bounds to apply; self._bound_scale_cond = None; elif self.lbound is None:; # only upper bound; if self.ubound > 0:; self._bound_mean = 0.0; self._bound_scale = self.ubound; else:; add_guess_pulse_scale = True; self._bound_scale = self.scaling*self.num_coeffs + \; self.get_guess_pulse_scale(); self._bound_mean = -abs(self._bound_scal",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:32017,log,logger,32017,docs/4.6/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html,4,['log'],['logger']
Testability," self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:20561,log,logger,20561,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,10,['log'],['logger']
Testability," set Q.isherm, Q.type, and Q.superrep.; Fixed integer depreciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015):¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady sta",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:8079,log,logging,8079,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,6,['log'],['logging']
Testability," some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:18579,log,logging,18579,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['log'],['logging']
Testability," source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). Installation on MS Windows¶; We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work.; QuTiP uses dynamic compilation of C for some of its time-dependant dynamics solvers. For MS Windows users the additional challenge is the need for a ANSI C99 compliant C compiler. Unlike other platforms, no C c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/installation.html:6090,test,tests,6090,docs/4.0.2/installation.html,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html,1,['test'],['tests']
Testability," ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precondition(L, n, ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). # Select iterative solver type; _iter_start = time.time(); if ss_args['method'] == 'iterative-gmres':; v, check = gmres(L, b, tol=ss_args['tol'], atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'iterative-lgmres':; v, check = lgmres(L, b, tol=ss_args['tol'], atol=ss_args['matol'],; M=ss_a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:21182,log,logger,21182,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,2,['log'],['logger']
Testability," ssesolve(H, psi0, times, sc_ops, e_ops, **kwargs):; """"""; Solve the stochastic Schrödinger equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj`; Single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`; An instance of the class :class:`qutip.solver.SolverResult`.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=psi0, times=times,; sc_ops=sc_ops, e_ops=e_ops, **kwargs). if sso.generate_A_ops is None:; sso.generate_A_ops = _generate_psi_A_ops. if (sso.d1 is None) or (sso.d2 is None):. if sso.method == 'homodyne':; sso.d1 = d1_psi_homodyne; sso.d2 = d2_psi_homodyne; sso.d2_len = 1; sso.homogeneous = True; sso.distribution = 'normal'; if ""dW_factors"" not in kwargs:; sso.dW_factors = np.array([1]); if ""m_ops"" not in kwargs:; sso.m_ops = [[c + c.dag()] for c in sso.sc_ops]. elif sso.method == 'heterodyne':; sso.d1 = d1_psi_heterodyne; sso.d2 = d2_psi_heterodyne; sso.d2_len = 2; sso.homogeneous = True; sso.distribution = 'normal'; if ""dW_factors"" not in kwargs:; sso.dW_factors = np.array([np.sqrt(2), np.sqrt(2)]); if ""m_ops"" not in kwargs:; sso.m_ops = [[(c + c.dag()), (-1j) * (c - c.dag())]; for idx, c in ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:11316,log,logger,11316,docs/3.1.0/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html,1,['log'],['logger']
Testability," starting amplitudes; dyn.initialize_controls(init_amps). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; phase_option='PSU',; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext='.txt', gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------. H_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:13394,log,logging,13394,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['log'],['logging']
Testability," state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/entropy.html:3040,log,logarithmic,3040,docs/4.7/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html,2,['log'],['logarithmic']
Testability," state density matrix. Examples; --------; >>> thermal_dm(5, 1); Quantum object: dims = [[5], [5]], \; shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], \; shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. Notes; -----; The 'operator' method (default) generates; the thermal state using the truncated number operator ``num(N)``. This; is the method that should be used in computations. The; 'analytic' method uses the analytic coefficients derived in; an infinite Hilbert space. The analytic form is not necessarily normalized,; if truncated too aggressively. """"""; if n == 0:; return fock_dm(N, 0); else:; i = arange(N); if method == 'operator':; beta = np.log(1.0 / n + 1.0); diags = np.exp(-beta * i); diags = diags / np.sum(diags); # populates diagonal terms using truncated operator expression; rm = sp.spdiags(diags, 0, N, N, format='csr'); elif method == 'analytic':; # populates diagonal terms using analytic values; rm = sp.spdiags((1.0 + n) ** (-1.0) * (n / (1.0 + n)) ** (i),; 0, N, N, format='csr'); else:; raise ValueError(; ""'method' keyword argument must be 'operator' or 'analytic'""); return Qobj(rm). [docs]def maximally_mixed_dm(N):; """"""; Returns the maximally mixed density matrix for a Hilbert space of; dimension N. Parameters; ----------; N : int; Number of basis states in Hilbert space. Returns; -------; dm : qobj; Thermal state density matrix.; """"""; if (not isinstance(N, (int, np.int64))) or N <= 0:; raise ValueError(""N must be integer N > 0""). dm = sp.spdiags(np.ones(N, dtype=complex)/float(N), 0, N, N, format='csr'). return Qobj(dm, isherm=True). [docs]def ket2dm(Q):; """"""Takes input ket or bra vector and returns density matrix;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/states.html:10885,log,log,10885,docs/4.2/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/states.html,6,['log'],['log']
Testability," state density matrix. Examples; --------; >>> thermal_dm(5, 1); Quantum object: dims = [[5], [5]], \; shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], \; shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. Notes; -----; The 'operator' method (default) generates; the thermal state using the truncated number operator ``num(N)``. This; is the method that should be used in computations. The; 'analytic' method uses the analytic coefficients derived in; an infinite Hilbert space. The analytic form is not necessarily normalized,; if truncated too aggressively. """"""; if n == 0:; return fock_dm(N, 0); else:; i = arange(N); if method == 'operator':; beta = np.log(1.0 / n + 1.0); diags = np.exp(-beta * i); diags = diags / np.sum(diags); # populates diagonal terms using truncated operator expression; rm = sp.spdiags(diags, 0, N, N, format='csr'); elif method == 'analytic':; # populates diagonal terms using analytic values; rm = sp.spdiags((1.0 + n) ** (-1.0) * (n / (1.0 + n)) ** (i),; 0, N, N, format='csr'); else:; raise ValueError(; ""'method' keyword argument must be 'operator' or 'analytic'""); return Qobj(rm). def maximally_mixed_dm(N):; """"""; Returns the maximally mixed density matrix for a Hilbert space of; dimension N. Parameters; ----------; N : int; Number of basis states in Hilbert space. Returns; -------; dm : qobj; Thermal state density matrix.; """"""; if (not isinstance(N, (int, np.int64))) or N <= 0:; raise ValueError(""N must be integer N > 0""). dm = sp.spdiags(np.ones(N, dtype=complex)/float(N), 0, N, N, format='csr'). return Qobj(dm, isherm=True). [docs]def ket2dm(Q):; """"""Takes input ket or bra vector and returns density matrix; forme",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/states.html:11944,log,log,11944,docs/3.1.0/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/states.html,1,['log'],['log']
Testability," state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['total_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = prod(rhoss.shape); L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); L.sort_indices(); orig_nnz = L.nnz. # start with all ones as RHS; v = np.ones(n, dtype=complex). if ss_args['use_rcm']:; if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); v = v[np.ix_(perm,)]; if settings.debug:; new_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' %; round(old_band/new_band, 2)). _power_start = time.time(); # Get LU factors; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:22420,log,logger,22420,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['log'],['logger']
Testability," that the _apply_phase method has been; set to a custom function. Type; phase_application. property prop¶; List of propagators (Qobj) for each timeslot. property prop_grad¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs(self)[source]¶; Reset the dyn_shape, dyn_dims and time_depend_drift attribs. save_amps(self, file_name=None, times=None, amps=None, verbose=False)[source]¶; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters. file_namestringName of the file; If None given the def_amps_fname attribuite will be used. timesList type (or string)List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If ‘exclude’ then times will not be saved in the file, just; the amplitudes. ampsArray[num_tslots, num_ctrls]Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verboseBooleanIf True then an info message will be logged. unitarity_check(self)[source]¶; Checks whether all propagators are unitary. update_ctrl_amps(self, new_amps)[source]¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer. class DynamicsGenMat(optimconfig, params=None)[source]¶; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Lindbladian. class DynamicsUnitary(optimconfig, params=None)[source]¶; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes. drift_hamQobjThis is the drift Ha",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:100928,log,logged,100928,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['log'],['logged']
Testability," the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:19156,log,logging,19156,docs/4.3/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html,7,['log'],['logging']
Testability," the eigenvectors; of the density matrices. Defaults to False. tolfloatTolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns. rel_entfloatValue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. References; See Nielsen & Chuang, “Quantum Computation and Quantum Information”,; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; Examples; First we define two density matrices:; >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. log2); and base e (i.e. log).; >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy of density matrix. Parameters. rhoqobjDensity matrix. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. entropyfloatVon-Neumann entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. Density Matrix Metrics¶; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators. average_gate_fidelity(oper, target=None)[source]¶; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters. AQobjQuantum object representing a superoperator. targetQobjQuantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns. fidfloatFidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary. bures_angle(A, B)[source]¶; Returns the Bures Angle between two density matrices A & B.; The Bures angle ranges from 0, for states with unit fidelity, to pi/2. Parameters. AqobjDensity matrix o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:61893,log,logarithm,61893,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['log'],['logarithm']
Testability," the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:15451,log,logger,15451,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,10,['log'],['logger']
Testability," the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-states.html:15174,test,testing,15174,docs/4.6/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html,2,['test'],['testing']
Testability," the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-states.html:15232,test,testing,15232,docs/4.7/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html,2,['test'],['testing']
Testability," the physical implementation of a quantum; program/algorithm on a dispersive cavity-QED system. dispersive_gate_correction(qc1, rwa=True)[source]¶; Method to resolve ISWAP and SQRTISWAP gates in a cQED system by adding; single qubit gates to get the correct output matrix. Parameters:; qc (Qobj) – The circular spin chain circuit to be resolved; rwa (Boolean) – Specify if RWA is used or not. Returns:qc – Returns QubitCircuit of resolved gates for the qubit circuit in the; desired basis. Return type:QubitCircuit. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg¶; string – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params¶; Dictionary – options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg¶; bool – Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method¶; string – a scipy.optimize.minimize method tha",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:59664,log,logger,59664,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['log'],['logger']
Testability," the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/docs.html:2180,test,testcode,2180,docs/4.6/development/docs.html,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html,4,['test'],['testcode']
Testability," through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dumping¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:61597,log,logs,61597,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,4,['log'],['logs']
Testability," time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; def qobj_list_evaluate(qobj_list, t, args):; """"""; Depracated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used to determine the type of quantum objects, and some; # functions for increased compatibility with quantum optics toolbox.; #. def dag(A):; """"""Adjont operator (dagger) of a quantum object. Parameters; ----------; A : :class:`qutip.Qobj`; Input quantum object. Returns; -------; oper : :class:`qutip.Qobj`; Adjoint of input operator. Notes; -----; This function is for legacy compatibility only. It is recommended to use; the ``dag()`` Qobj method. """"""; if not isinstance(A, Qobj):; raise TypeError(""Input is not a quantum object""). return A.dag(). def ptrace(Q, sel):; """"""Partial trace of the Qobj with selected components remaining. Parameters; ----------; Q : :class:`qutip.Qobj`; Composite quantum object.; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace. Returns; -------; oper : :class:`qutip.Qobj`; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is for legacy compatibility only. It is recommended to use; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:52152,test,tests,52152,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,1,['test'],['tests']
Testability," time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; def qobj_list_evaluate(qobj_list, t, args):; """"""; Depracated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used to determine the type of quantum objects, and some; # functions for increased compatibility with quantum optics toolbox.; #. def dag(A):; """"""Adjont operator (dagger) of a quantum object. Parameters; ----------; A : qobj; Input quantum object. Returns; -------; oper : qobj; Adjoint of input operator. Notes; -----; This function is for legacy compatibility only. It is recommended to use; the ``dag()`` Qobj method. """"""; if not isinstance(A, Qobj):; raise TypeError(""Input is not a quantum object""). return A.dag(). def ptrace(Q, sel):; """"""Partial trace of the Qobj with selected components remaining. Parameters; ----------; Q : qobj; Composite quantum object.; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace. Returns; -------; oper : qobj; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is for legacy compatibility only. It is recommended to use; the ``ptrace()`` Qobj method. """"""; if not isinstance(Q, Qobj",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:48250,test,tests,48250,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,3,['test'],['tests']
Testability," time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; def qobj_list_evaluate(qobj_list, t, args):; """"""; Depracated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used to determine the type of quantum objects, and some; # functions for increased compatibility with quantum optics toolbox.; #. def dag(A):; """"""Adjont operator (dagger) of a quantum object. Parameters; ----------; A : qobj; Input quantum object. Returns; -------; oper : qobj; Adjoint of input operator. Notes; -----; This function is for legacy compatibility only. It is recommended to use; the ``dag()`` Qobj method.; ; """"""; if not isinstance(A, Qobj):; raise TypeError(""Input is not a quantum object""). return A.dag(). def ptrace(Q, sel):; """"""Partial trace of the Qobj with selected components remaining. Parameters; ----------; Q : qobj; Composite quantum object.; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace. Returns; -------; oper : qobj; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is for legacy compatibility only. It is recommended to use; the ``ptrace()`` Qobj method.; ; """"""; if not isinstance(Q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:48168,test,tests,48168,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['test'],['tests']
Testability," time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; def qobj_list_evaluate(qobj_list, t, args):; """"""; Depracated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used to determine the type of quantum objects, and some; # functions for increased compatibility with quantum optics toolbox.; #; def dag(A):; """"""Adjont operator (dagger) of a quantum object. Parameters; ----------; A : :class:`qutip.Qobj`; Input quantum object. Returns; -------; oper : :class:`qutip.Qobj`; Adjoint of input operator. Notes; -----; This function is for legacy compatibility only. It is recommended to use; the ``dag()`` Qobj method. """"""; if not isinstance(A, Qobj):; raise TypeError(""Input is not a quantum object""). return A.dag(). def ptrace(Q, sel):; """"""Partial trace of the Qobj with selected components remaining. Parameters; ----------; Q : :class:`qutip.Qobj`; Composite quantum object.; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace. Returns; -------; oper : :class:`qutip.Qobj`; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is for legacy compatibility only. It is recommended to use; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobj.html:53652,test,tests,53652,docs/4.5/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobj.html,1,['test'],['tests']
Testability," tranposed. Parameters:; rho (qutip.qobj) – A density matrix.; mask (list / array) – A mask that selects which subsystems should be transposed.; method (str) – choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr – A density matrix with the selected subsystems transposed. Return type:qutip.qobj. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state (qobj) – Ket, bra, or density matrix for a two-qubit state. Returns:concur – Concurrence. Return type:float. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:; rho (qobj) – Density matrix of composite object; selB (int/list) – Selected components for density matrix B; base ({e,2}) – Base of logarithm.; sparse ({False,True}) – Use sparse eigensolver. Returns:ent_cond – Value of conditional entropy. Return type:float. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:rho (qobj) – sensity matrix or ket/bra vector. Returns:entropy – Linear entropy of rho. Return type:float. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters:; rho (qobj) – Density matrix for composite quantum systems; selA (int/list) – int or list of first selected density matrix components.; selB (int/list) – int or list of second selected density matrix components.; base ({e,2}) – Base of logarithm.; sparse ({False,True}) – Use sparse eigensolver. Returns:ent_mut – Mutual information between selec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:45950,log,logarithm,45950,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['log'],['logarithm']
Testability," understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init__(self, dynamics, params=None):; from qutip.control.dynamics import Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:4326,log,logger,4326,docs/4.6/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html,4,['log'],['logger']
Testability," used for solving steady state solutions. We have an updated scikits.umfpack module available at http://github.com/nonhermitian/umfpack that can be installed to have SciPy find and use the umfpack library. Optimized BLAS Libraries¶; QuTiP is designed to take advantage of some of the optimized BLAS libraries that are available for NumPy. At present, this includes the OPENBLAS and MKL libraries. If NumPy is built against these libraries, then QuTiP will take advantage of the performance gained by using these optimized tools. As these libraries are multi-threaded, you can change the number of threads used in these packages by adding:; >>> import os; >>> os.environ['OPENBLAS_NUM_THREADS'] = '4'; >>> os.environ['MKL_NUM_THREADS'] = '4'. at the top of your Python script files, or iPython notebooks, and then loading the QuTiP framework. If these commands are not present, then QuTiP automatically sets the number of threads to one. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; Paul D. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:12467,test,test,12467,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,1,['test'],['test']
Testability," used for solving steady state solutions. We have an updated scikits.umfpack module available at http://github.com/nonhermitian/umfpack that can be installed to have SciPy find and use the umfpack library. Optimized BLAS Libraries¶; QuTiP is designed to take advantage of some of the optimized BLAS libraries that are available for NumPy. At present, this includes the OPENBLAS and MKL libraries. If NumPy is built against these libraries, then QuTiP will take advantage of the performance gained by using these optimized tools. As these libraries are multi-threaded, you can change the number of threads used in these packages by adding:; >>> import os; >>> os.environ['OPENBLAS_NUM_THREADS'] = '4'; >>> os.environ['MKL_NUM_THREADS'] = '4'. at the top of your Python script files, or iPython notebooks, and then loading the QuTiP framework. If these commands are not present, then QuTiP automatically sets the number of threads to one. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that your have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; Paul D.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:11478,test,test,11478,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,1,['test'],['test']
Testability," with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C code, the second option (string based) tends to be more efficient and will run faster. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. If you can write you time-dependent coefficients using any of the following functions, or combinations thereof (including constants) then you may use this method:; 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil',; 'copysign', 'cos', 'cosh', 'degrees', 'erf', 'erfc', 'exp', 'expm1',; 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma',; 'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p',; 'modf', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'. Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:4307,log,log,4307,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['log'],['log']
Testability," ‘time’ based on the tau values. initialize_controls(amps, init_tslots=True)[source]¶; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. save_amps(file_name=None, times=None, amps=None, verbose=False)[source]¶; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters:file_name : string. Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string). List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If ‘exclude’ then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]. Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean. If True then an info message will be logged. set_log_level(lvl)[source]¶; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl). spectral_decomp(k)[source]¶; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the ‘factormatrix’ used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type. update_ctrl_amps(new_amps)[source]¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer. class DynamicsUnitary(optimconfig)[source]¶; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header); Attributes. drift_ham; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/classes.html:53397,log,logger,53397,docs/3.1.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html,2,['log'],['logger']
Testability,"""""""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:35600,log,logger,35600,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,6,['log'],['logger']
Testability,"""""""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1]_, [2]_.; It uses the ``scipy.optimize.fmin`` function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB. References; ----------; .. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 19",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:36615,log,logger,36615,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,4,['log'],['logger']
Testability,"# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""The Quantum Object (Qobj) class, for representing quantum states and; operators, and related functions.; """""". __all__ = ['Qobj', 'qobj_list_evaluate', 'ptrace', 'dag', 'isequal',; 'issuper', 'isoper', 'isoperket', 'isoperbra', 'isket', 'isbra',; 'isherm', 'shape', 'dims']. import warnings; import types. try:; import builtins; except:; import __builtin__ as builtins. # import math functions from numpy.math: required for td string evaluation; from numpy import (arccos, arccosh, arcsin, arcsinh, arctan, arctan2, arctanh,; ceil, copysign, cos, cosh, degrees, e, exp, expm1, fabs,; floor, fmod, frexp, hypot, isinf, isnan, ldexp, log, log10,; log1p, modf, pi, radians, sin, sinh, sqrt, tan, tanh, trunc). import numpy as np; import scipy.sparse as sp; import scipy.linalg as la; import qutip.settings as settings; from qutip import __version__; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.cy.ptrace import _ptrace; from qutip.permute import _permute; from qutip.sparse import (sp_eigs, sp_expm, sp_fro_norm, sp_max_norm,; sp_one_norm, sp_L2_norm); from qutip.dimensions import (type_from_dims, enumerate_flat,; collapse_dims_super); from qutip.cy.spmath import (zcsr_transpose, zcsr_adjoint, zcsr_isherm,; zcsr_trace, zcsr_proj, zcsr_inner); from qutip.cy.spmatfuncs import zcsr_mat_elem; from qutip.cy.sparse_utils import cy_tidyup; import sys; if sys.version_info.major >= 3:; from itertools import zip_longest; elif sys.version_info.major < 3:; from itertools import izip_longest; zip_longest = izip_longest. # OPENMP stuff",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobj.html:2686,log,log,2686,docs/4.5/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobj.html,1,['log'],['log']
Testability,"# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""The Quantum Object (Qobj) class, for representing quantum states and; operators, and related functions.; """""". __all__ = ['Qobj', 'qobj_list_evaluate', 'ptrace', 'dag', 'isequal',; 'issuper', 'isoper', 'isoperket', 'isoperbra', 'isket', 'isbra',; 'isherm', 'shape', 'dims']. import warnings; import types. try:; import builtins; except:; import __builtin__ as builtins. # import math functions from numpy.math: required for td string evaluation; from numpy import (arccos, arccosh, arcsin, arcsinh, arctan, arctan2, arctanh,; ceil, copysign, cos, cosh, degrees, e, exp, expm1, fabs,; floor, fmod, frexp, hypot, isinf, isnan, ldexp, log, log10,; log1p, modf, pi, radians, sin, sinh, sqrt, tan, tanh, trunc). import numpy as np; import scipy.sparse as sp; import scipy.linalg as la; import qutip.settings as settings; from qutip import __version__; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.cy.ptrace import _ptrace; from qutip.permute import _permute; from qutip.sparse import (sp_eigs, sp_expm, sp_fro_norm, sp_max_norm,; sp_one_norm, sp_L2_norm); from qutip.dimensions import type_from_dims, enumerate_flat, collapse_dims_super; from qutip.cy.spmath import (zcsr_transpose, zcsr_adjoint, zcsr_isherm). import sys; if sys.version_info.major >= 3:; from itertools import zip_longest; elif sys.version_info.major < 3:; from itertools import izip_longest; zip_longest = izip_longest. [docs]class Qobj(object):; """"""A class for representing quantum objects, such as quantum operators; and states. The Qobj class is the QuTiP repres",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/qobj.html:2677,log,log,2677,docs/4.1/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/qobj.html,1,['log'],['log']
Testability,"# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""The Quantum Object (Qobj) class, for representing quantum states and; operators, and related functions.; """""". __all__ = ['Qobj', 'qobj_list_evaluate', 'ptrace', 'dag', 'isequal',; 'issuper', 'isoper', 'isoperket', 'isoperbra', 'isket', 'isbra',; 'isherm', 'shape', 'dims']. import warnings; import types. try:; import builtins; except:; import __builtin__ as builtins. # import math functions from numpy.math: required for td string evaluation; from numpy import (arccos, arccosh, arcsin, arcsinh, arctan, arctan2, arctanh,; ceil, copysign, cos, cosh, degrees, e, exp, expm1, fabs,; floor, fmod, frexp, hypot, isinf, isnan, ldexp, log, log10,; log1p, modf, pi, radians, sin, sinh, sqrt, tan, tanh, trunc). import numpy as np; import scipy.sparse as sp; import scipy.linalg as la; import qutip.settings as settings; from qutip import __version__; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.cy.ptrace import _ptrace; from qutip.permute import _permute; from qutip.sparse import (sp_eigs, sp_expm, sp_fro_norm, sp_max_norm,; sp_one_norm, sp_L2_norm); from qutip.dimensions import type_from_dims, enumerate_flat, collapse_dims_super; from qutip.cy.spmath import (zcsr_transpose, zcsr_adjoint, zcsr_isherm); from qutip.cy.sparse_utils import cy_tidyup; import sys; if sys.version_info.major >= 3:; from itertools import zip_longest; elif sys.version_info.major < 3:; from itertools import izip_longest; zip_longest = izip_longest. [docs]class Qobj(object):; """"""A class for representing quantum objects, such as quantum operators; a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:2677,log,log,2677,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,1,['log'],['log']
Testability,"# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""The Quantum Object (Qobj) class, for representing quantum states and; operators, and related functions.; """""". __all__ = ['Qobj', 'qobj_list_evaluate', 'ptrace', 'dag', 'isequal',; 'issuper', 'isoper', 'isoperket', 'isoperbra', 'isket', 'isbra',; 'isherm', 'shape', 'dims']. import warnings; import types. try:; import builtins; except:; import __builtin__ as builtins. # import math functions from numpy.math: required for td string evaluation; from numpy import (arccos, arccosh, arcsin, arcsinh, arctan, arctan2, arctanh,; ceil, copysign, cos, cosh, degrees, e, exp, expm1, fabs,; floor, fmod, frexp, hypot, isinf, isnan, ldexp, log, log10,; log1p, modf, pi, radians, sin, sinh, sqrt, tan, tanh, trunc). import numpy as np; import scipy.sparse as sp; import scipy.linalg as la; import qutip.settings as settings; from qutip import __version__; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.cy.ptrace import _ptrace; from qutip.permute import _permute; from qutip.sparse import (sp_eigs, sp_expm, sp_fro_norm, sp_max_norm,; sp_one_norm, sp_L2_norm); from qutip.dimensions import type_from_dims, enumerate_flat, collapse_dims_super; from qutip.cy.spmath import (zcsr_transpose, zcsr_adjoint, zcsr_isherm,; zcsr_trace, zcsr_proj, zcsr_inner); from qutip.cy.spmatfuncs import zcsr_mat_elem; from qutip.cy.sparse_utils import cy_tidyup; import sys; if sys.version_info.major >= 3:; from itertools import zip_longest; elif sys.version_info.major < 3:; from itertools import izip_longest; zip_longest = izip_longest. #OPENMP stuff; fr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/qobj.html:2677,log,log,2677,docs/4.3/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qobj.html,2,['log'],['log']
Testability,"# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""The Quantum Object (Qobj) class, for representing quantum states and; operators, and related functions.; """""". __all__ = ['Qobj', 'qobj_list_evaluate', 'ptrace', 'dag', 'isequal',; 'issuper', 'isoper', 'isoperket', 'isoperbra', 'isket', 'isbra',; 'isherm', 'shape', 'dims']. import warnings; import types. try:; import builtins; except:; import __builtin__ as builtins. # import math functions from numpy.math: required for td string evaluation; from numpy import (arccos, arccosh, arcsin, arcsinh, arctan, arctan2, arctanh,; ceil, copysign, cos, cosh, degrees, e, exp, expm1, fabs,; floor, fmod, frexp, hypot, isinf, isnan, ldexp, log, log10,; log1p, modf, pi, radians, sin, sinh, sqrt, tan, tanh, trunc). import numpy as np; import scipy.sparse as sp; import scipy.linalg as la; import qutip.settings as settings; from qutip import __version__; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.ptrace import _ptrace; from qutip.permute import _permute; from qutip.sparse import (sp_eigs, sp_expm, sp_fro_norm, sp_max_norm,; sp_one_norm, sp_L2_norm); from qutip.dimensions import type_from_dims, enumerate_flat, collapse_dims_super; from qutip.cy.spmath import (zcsr_transpose, zcsr_adjoint). import sys; if sys.version_info.major >= 3:; from itertools import zip_longest; elif sys.version_info.major < 3:; from itertools import izip_longest; zip_longest = izip_longest. [docs]class Qobj(object):; """"""A class for representing quantum objects, such as quantum operators; and states. The Qobj class is the QuTiP representation of quan",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:2677,log,log,2677,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['log'],['log']
Testability,"##################################. __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual',; 'concurrence', 'entropy_conditional', 'entangling_power']. from numpy import e, real, sort, sqrt; from scipy import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.qip.gates import swap. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html:4257,log,logvals,4257,docs/3.1.0/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html,3,['log'],"['log', 'logvals']"
Testability,"#################################; """"""; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators.; """""". __all__ = ['steadystate', 'steady', 'build_preconditioner',; 'pseudo_inverse']. import warnings; import time; import scipy; import numpy as np; from numpy.linalg import svd; from scipy import prod; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (use_solver, splu, spilu, spsolve, eigs,; LinearOperator, gmres, lgmres, bicgstab); from qutip.qobj import Qobj, issuper, isoper; from qutip.superoperator import liouvillian, vec2mat; from qutip.sparse import sp_permute, sp_bandwidth, sp_reshape, sp_profile; from qutip.graph import reverse_cuthill_mckee, weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.utilities import _version2int; import qutip.logging. logger = qutip.logging.get_logger(); logger.setLevel('DEBUG'). # test if scipy is recent enought to get L & U factors from superLU; _scipy_check = _version2int(scipy.__version__) >= _version2int('0.14.0'). def _default_steadystate_args():; def_args = {'method': 'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'use_umfpack': False, 'weight': None,; 'use_precond': False, 'all_states': False,; 'M': None, 'x0': None, 'drop_tol': 1e-4, 'fill_factor': 100,; 'diag_pivot_thresh': None, 'maxiter': 1000, 'tol': 1e-9,; 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', 'restart': 20,; 'return_info': False, 'info': {'perm': []}}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:4278,log,logging,4278,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['log'],['logging']
Testability,"#####################; """"""; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators.; """""". __all__ = ['steadystate', 'steady', 'build_preconditioner',; 'pseudo_inverse']. import warnings; import time; import scipy; import numpy as np; from numpy.linalg import svd; from scipy import prod; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (use_solver, splu, spilu, spsolve, eigs,; LinearOperator, gmres, lgmres, bicgstab); from qutip.qobj import Qobj, issuper, isoper; from qutip.superoperator import liouvillian, vec2mat; from qutip.sparse import sp_permute, sp_bandwidth, sp_reshape, sp_profile; from qutip.graph import reverse_cuthill_mckee, weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.utilities import _version2int; import qutip.logging. logger = qutip.logging.get_logger(); logger.setLevel('DEBUG'). # test if scipy is recent enought to get L & U factors from superLU; _scipy_check = _version2int(scipy.__version__) >= _version2int('0.14.0'). def _default_steadystate_args():; def_args = {'method': 'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'use_umfpack': False, 'weight': None,; 'use_precond': False, 'all_states': False,; 'M': None, 'x0': None, 'drop_tol': 1e-4, 'fill_factor': 100,; 'diag_pivot_thresh': None, 'maxiter': 1000, 'tol': 1e-9,; 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', 'restart': 20,; 'return_info': False, 'info': {'perm': []}}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:4287,log,logger,4287,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['log'],['logger']
Testability,"#########. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]cla",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:3105,log,logging,3105,docs/4.6/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html,2,['log'],['logging']
Testability,"#########; """"""; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators.; """""". __all__ = ['steadystate', 'steady', 'build_preconditioner',; 'pseudo_inverse']. import warnings; import time; import scipy; import numpy as np; from numpy.linalg import svd; from scipy import prod; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (use_solver, splu, spilu, spsolve, eigs,; LinearOperator, gmres, lgmres, bicgstab); from qutip.qobj import Qobj, issuper, isoper; from qutip.superoperator import liouvillian, vec2mat; from qutip.sparse import sp_permute, sp_bandwidth, sp_reshape, sp_profile; from qutip.graph import reverse_cuthill_mckee, weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.utilities import _version2int; import qutip.logging. logger = qutip.logging.get_logger(); logger.setLevel('DEBUG'). # test if scipy is recent enought to get L & U factors from superLU; _scipy_check = _version2int(scipy.__version__) >= _version2int('0.14.0'). def _default_steadystate_args():; def_args = {'method': 'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'use_umfpack': False, 'weight': None,; 'use_precond': False, 'all_states': False,; 'M': None, 'x0': None, 'drop_tol': 1e-4, 'fill_factor': 100,; 'diag_pivot_thresh': None, 'maxiter': 1000, 'tol': 1e-9,; 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', 'restart': 20,; 'return_info': False, 'info': {'perm': []}}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindbl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:4302,log,logging,4302,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['log'],['logging']
Testability,"'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:18789,log,logger,18789,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,3,['log'],['logger']
Testability,"'Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with al",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:26104,log,logger,26104,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,2,['log'],['logger']
Testability,"'entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power']. from numpy import e, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/entropy.html:3056,log,logvals,3056,docs/4.5/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/entropy.html,3,['log'],"['log', 'logvals']"
Testability,"'method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; data = data / la.norm(v). data = dense2D_to_fastcsr_fmode(vec2mat(data), rhoss.shape[0], rhoss.shape[0]); rhoss.data = 0.5 * (data + data.H); rhoss.isherm = True; if ss_args['return_info']:; return rhoss, ss_args['info']; else:; return rhoss. [docs]def build_preconditioner(A, c_op_list=[], **kwargs):; """"""Constructs a iLU preconditioner necessary for solving for; the steady state density matrix using the iterative linear solvers; in the 'steadystate' function. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcm : bool, optional, default = False; Use reverse Cuthil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:26781,log,logger,26781,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['log'],['logger']
Testability,"'steady', 'build_preconditioner',; 'pseudo_inverse']. import warnings; import time; import scipy; import numpy as np; from numpy.linalg import svd; from scipy import prod; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (use_solver, splu, spilu, spsolve, eigs,; LinearOperator, gmres, lgmres, bicgstab); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_reshape, sp_profile. from qutip.superoperator import liouvillian, vec2mat; from qutip.sparse import (sp_permute, sp_bandwidth, sp_reshape, ; sp_profile); from qutip.cy.spmath import zcsr_kron; from qutip.graph import reverse_cuthill_mckee, weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.utilities import _version2int; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). # test if scipy is recent enought to get L & U factors from superLU; _scipy_check = _version2int(scipy.__version__) >= _version2int('0.14.0'). def _empty_info_dict():; def_info = {'perm': [], 'solution_time': None, 'iterations': None,; 'residual_norm': None, 'rcm_time': None, 'wbm_time': None,; 'iter_time': None, 'precond_time': None, 'ILU_MILU': None,; 'fill_factor': None, 'diag_pivot_thresh': None, ; 'drop_tol': None, 'permc_spec': None, 'weight': None}; ; return def_info. def _default_steadystate_args():; def_args = {'method': 'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'weight': None, 'use_precond': False, ; 'all_states': False, 'M': None, 'x0': None, 'drop_tol': 1e-4, ; 'fill_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000, ; 'tol': 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 's",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:3275,log,logger,3275,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['log'],['logger']
Testability,"(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = prod(rhoss.shape); L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); L.sort_indices(); orig_nnz = L.nnz. # start with all ones as RHS; v = np.ones(n, dtype=complex). if ss_args['use_rcm']:; if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); v = v[np.ix_(perm,)]; if settings.debug:; new_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' %; round(old_band/new_band, 2)). _power_start = time.time(); # Get LU factors; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; v = lu.solve(v); v = v / la.norm(v, np.inf); it += 1; if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'). _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v, np.inf); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = sp.eye(rhoss.shape[0], rhoss.shape[0], format='coo'); trow = sp_reshape(trow, (1, n)); data = v / sum(trow.dot(v)); else:; data = data / la.norm(v). data = sp.csr_matrix(vec2mat(data)); rhoss.data = 0.5 * (data + data.conj().T); rhoss.isherm = True; if ss_args['return_info']",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:23546,log,logger,23546,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['log'],['logger']
Testability,"(data, dims=dims, isherm=True). def _steadystate_direct_dense(L, ss_args):; """"""; Direct solver that uses numpy arrays. Suitable for small systems with few; states.; """"""; if settings.debug:; logger.debug('Starting direct dense solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L = L.full(); L[0, :] += np.diag(ss_args['weight']*np.ones(n)).reshape(n ** 2); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L@v, np.inf); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = sp.csgraph.reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec, np.inf); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp, _temp.shape[0], _temp.shape[1]); data = 0.5",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/steadystate.html:17278,log,logger,17278,docs/4.7/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html,2,['log'],['logger']
Testability,"(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = prod(rhoss.shape); L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); L.sort_indices(); orig_nnz = L.nnz. # start with all ones as RHS; v = np.ones(n, dtype=complex). if ss_args['use_rcm']:; if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); v = v[np.ix_(perm,)]; if settings.debug:; new_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' %; round(old_band/new_band, 2)). _power_start = time.time(); # Get LU factors; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; v = lu.solve(v); v = v / la.norm(v, np.inf); it += 1; if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'). _power_end = time.time(); ss_arg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:22936,log,logger,22936,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['log'],['logger']
Testability,"(quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls = np.array(ctrls, dtype=object); except:; pass. if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:3295,log,logging,3295,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,3,['log'],"['logger', 'logging']"
Testability,"(quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:3299,log,logging,3299,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,6,['log'],"['logger', 'logging']"
Testability,"(quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False; ; def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls = np.array(ctrls); except:; pass; ; if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; raise TypeE",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:3299,log,logging,3299,docs/4.2/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html,6,['log'],"['logger', 'logging']"
Testability,"(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html:7829,log,logger,7829,docs/4.1/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html,9,['log'],['logger']
Testability,")). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary. def _transform_L_t_shift(H, c_ops, args={}):; """"""; Time shift the Hamiltonian with private time-shift variable _t0; """""". # while this list doesn't seem exhaustive, mesolve has already been called; # and has hence called _td_format_check from qutip.rhs_generate. important; # to keep in mind is that mesolve already requires the types of; # time-dependence to be the same for the hamiltonian as for the collapse; # operators. if isinstance(H, Qobj):; # constant hamiltonian; H_shifted = H # not shifted!. c_ops_is_td = False; if isinstance(c_ops, list):; for i in range(len(c_ops)):; # test is collapse operators are time-dependent; if isinstance(c_ops[i], list):; c_ops_is_td = True. if not c_ops_is_td:; # constant collapse operators; c_ops_shifted = c_ops # not shifted!. if isinstance(H, Qobj) and not c_ops_is_td:; # constant hamiltonian and collapse operators; _args = args # not shifted!. if isinstance(H, types.FunctionType):; # function-callback based time-dependence; if isinstance(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""). if isinstance(H, list) or c_ops_is_td:; # string/function-list based time-dependence; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. if isinstance(H, list):; # hamiltonian is time-dependent; H_shifted = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:38620,test,test,38620,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,5,['test'],['test']
Testability,"), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if has_mkl:; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro); ; if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; ne",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:22629,log,logger,22629,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['log'],['logger']
Testability,"), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_args['permc_spec'],; drop_tol=ss_args['drop_tol'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; fill_factor=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). M = LinearOperator((n ** 2, n ** 2), matvec=P.solve); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except Exception:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/steadystate.html:19387,log,logger,19387,docs/4.7/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html,2,['log'],['logger']
Testability,"). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; log",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:11150,log,logger,11150,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['log'],['logger']
Testability,"). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option +NORMALIZE_WHITESPACE. Plot¶; Since the doctest directive cannot render matplotlib figures, we use Matplotlib’s; Plot; directive when rendering to LaTeX or HTML.; The plot directive can also be used in the doctest format. In this case,; when running doctests (which is enabled by specifying all statements with the; >>> prompts), tests also include those specified under the plot directive.; Example:; First we specify some data:. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/docs.html:3247,test,tested,3247,docs/4.6/development/docs.html,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html,4,['test'],['tested']
Testability,").T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # using np.real, just",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:20696,log,logger,20696,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,10,['log'],['logger']
Testability,").eigenenergies()). Output:; [0. 0.04861218 0.1 1.85138782]. Finally, the last superoperator representation supported by QuTiP is; the \(\chi\)-matrix representation,. \[\Lambda(\rho) = \sum_{\alpha,\beta} \chi_{\alpha,\beta} B_{\alpha} \rho B_{\beta}^\dagger,\]; where \(\{B_\alpha\}\) is a basis for the space of matrices acting; on \(\mathcal{H}\). In QuTiP, this basis is taken to be the Pauli; basis \(B_\alpha = \sigma_\alpha / \sqrt{2}\). Conversion to the; \(\chi\) formalism is handled by the to_chi; function.; chi = to_chi(S); print(chi). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = chi; Qobj data =; [[3.7+0.j 0. +0.j 0. +0.j 0.1+0.j ]; [0. +0.j 0.1+0.j 0. +0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the \(\chi\) matrix is that the average; gate fidelity with the identity map can be read off directly from; the \(\chi_{00}\) element:; np.testing.assert_almost_equal(average_gate_fidelity(S), 0.9499999999999998). print(chi[0, 0] / 4). Output:; (0.925+0j). Here, the factor of 4 comes from the dimension of the underlying; Hilbert space \(\mathcal{H}\). As with the superoperator; and Choi representations, the \(\chi\) representation is; denoted by the superrep, such that to_super,; to_choi, to_kraus,; to_stinespring and to_chi; all convert from the \(\chi\) representation appropriately. Properties of Quantum Maps¶; In addition to converting between the different representations of quantum maps,; QuTiP also provides attributes to make it easy to check if a map is completely; positive, trace preserving and/or hermicity preserving. Each of these attributes; uses superrep to automatically perform any needed conversions.; In particular, a quantum map is said to be positive (but not necessarily completely; positive) if it maps all positive operators to positive operators. For instance, the; transpose map \(\Lambda(\rho) = \rho^{\math",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-states.html:29752,test,testing,29752,docs/4.6/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html,4,['test'],['testing']
Testability,"):; self.eps = np.array([eps * 2 * np.pi] * N); else:; self.eps = np.array(eps). if delta is None:; self.delta = np.array([0.0 * 2 * np.pi] * N); elif not isinstance(delta, list):; self.delta = np.array([delta * 2 * np.pi] * N); else:; self.delta = np.array(delta). if g is None:; self.g = np.array([0.01 * 2 * np.pi] * N); elif not isinstance(g, list):; self.g = np.array([g * 2 * np.pi] * N); else:; self.g = np.array(g). if wq is not None:; if not isinstance(wq, list):; self.wq = np.array([wq] * N); else:; self.wq = np.array(wq). if wq is None:; if eps is None:; self.eps = np.array([9.5 * 2 * np.pi] * N); elif not isinstance(eps, list):; self.eps = np.array([eps] * N); else:; self.eps = np.array(eps). if delta is None:; self.delta = np.array([0.0 * 2 * np.pi] * N); elif not isinstance(delta, list):; self.delta = np.array([delta] * N); else:; self.delta = np.array(delta). # computed; self.wq = np.sqrt(self.eps ** 2 + self.delta ** 2); self.Delta = self.wq - self.w0. # rwa/dispersive regime tests; if any(self.g / (self.w0 - self.wq) > 0.05):; warnings.warn(""Not in the dispersive regime""). if any((self.w0 - self.wq) / (self.w0 + self.wq) > 0.05):; warnings.warn(; ""The rotating-wave approximation might not be valid.""). self.sx_ops = [tensor([identity(self.Nres)] +; [sigmax() if m == n else identity(2); for n in range(N)]); for m in range(N)]; self.sz_ops = [tensor([identity(self.Nres)] +; [sigmaz() if m == n else identity(2); for n in range(N)]); for m in range(N)]. self.a = tensor([destroy(self.Nres)] + [identity(2) for n in range(N)]). self.cavityqubit_ops = []; for n in range(N):; sm = tensor([identity(self.Nres)] +; [destroy(2) if m == n else identity(2); for m in range(N)]); self.cavityqubit_ops.append(self.a.dag() * sm + self.a * sm.dag()). self.psi_proj = tensor([basis(self.Nres, 0)] +; [identity(2) for n in range(N)]). [docs] def get_ops_and_u(self):; H0 = self.a.dag() * self.a; return ([H0] + self.sx_ops + self.sz_ops + self.cavityqubit_ops,; np.hstack((self.w0 ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/qip/models/cqed.html:4892,test,tests,4892,docs/4.3/modules/qutip/qip/models/cqed.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qip/models/cqed.html,2,['test'],['tests']
Testability,"):; self.eps = np.array([eps * 2 * np.pi] * N); else:; self.eps = np.array(eps). if delta is None:; self.delta = np.array([0.0 * 2 * np.pi] * N); elif not isinstance(delta, list):; self.delta = np.array([delta * 2 * np.pi] * N); else:; self.delta = np.array(delta). if g is None:; self.g = np.array([0.01 * 2 * np.pi] * N); elif not isinstance(g, list):; self.g = np.array([g * 2 * np.pi] * N); else:; self.g = np.array(g). if wq is not None:; if not isinstance(wq, list):; self.wq = np.array([wq] * N); else:; self.wq = np.array(wq). if wq is None:; if eps is None:; self.eps = np.array([9.5 * 2 * np.pi] * N); elif not isinstance(eps, list):; self.eps = np.array([eps] * N); else:; self.eps = np.array(eps). if delta is None:; self.delta = np.array([0.0 * 2 * np.pi] * N); elif not isinstance(delta, list):; self.delta = np.array([delta] * N); else:; self.delta = np.array(delta). # computed; self.wq = np.sqrt(self.eps ** 2 + self.delta ** 2); self.Delta = self.wq - self.w0. # rwa/dispersive regime tests; if any(self.g / (self.w0 - self.wq) > 0.05):; warnings.warn(""Not in the dispersive regime""). if any((self.w0 - self.wq) / (self.w0 + self.wq) > 0.05):; warnings.warn(; ""The rotating-wave approximation might not be valid.""). self.sx_ops = [tensor([identity(self.Nres)] +; [sigmax() if m == n else identity(2); for n in range(N)]); for m in range(N)]; self.sz_ops = [tensor([identity(self.Nres)] +; [sigmaz() if m == n else identity(2); for n in range(N)]); for m in range(N)]. self.a = tensor([destroy(self.Nres)] + [identity(2) for n in range(N)]). self.cavityqubit_ops = []; for n in range(N):; sm = tensor([identity(self.Nres)] +; [destroy(2) if m == n else identity(2); for m in range(N)]); self.cavityqubit_ops.append(self.a.dag() * sm + self.a * sm.dag()). self.psi_proj = tensor([basis(self.Nres, 0)] +; [identity(2) for n in range(N)]). def get_ops_and_u(self):; H0 = self.a.dag() * self.a; return ([H0] + self.sx_ops + self.sz_ops + self.cavityqubit_ops,; np.hstack((self.w0 * np.ze",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/qip/models/cqed.html:4892,test,tests,4892,docs/4.1/modules/qutip/qip/models/cqed.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/qip/models/cqed.html,4,['test'],['tests']
Testability,"):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True; ; def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the ; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overridden here; """"""; logger.info(""Setting memory optimisations for level {}"".format(; self.memory_optimization)); ; if self.oper_dtype is None:; self._choose_oper_dtype(); logger.info(""Internal operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)); ; if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)); ; if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True ; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)); ; if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True ; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)); ; if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False ; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)); ; def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken from Qobj.expm(); # if method is not explicitly given, try to make a good choice; # between sparse and dense solvers by considering the size of the; # system and the number of non-zero elements.; if self.time_depend_drift:; dg = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:21636,log,logger,21636,docs/4.3/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html,1,['log'],['logger']
Testability,"); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. def _entropy_relative(rho, sigma, base=e, sparse=False):; """"""; ****NEEDS TO BE WORKED ON****. Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : qobj; First density matrix.; sigma : qobj; Second density matrix.; base : {e,2}; Base of logarithm. Returns; -------; rel_ent : float; Value of relative entropy. """"""; if rho.type != 'oper' or sigma.type != 'oper':; raise TypeError(""Inputs must be density matrices..""); # sigma terms; svals = sp_eigs(sigma.data, sigma.isherm, vecs=False, sparse=sparse); snzvals = svals[svals != 0]; if base == 2:; slogvals = log2(snzvals); elif base == e:; slogvals = log(snzvals); else:; raise ValueError(""Base must be 2 or e.""); # rho terms; rvals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); rnzvals = rvals[rvals != 0]; # calculate tr(rho*log sigma); rel_trace = float(real(sum(rnzvals * slogvals))); return -entropy_vn(rho, base, sparse) - rel_trace. [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/entropy.html:7253,log,log,7253,docs/4.2/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/entropy.html,6,['log'],['log']
Testability,")]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True, useUmfpack=ss_args['use_umfpack']); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not ss_args['use_umfpack']:; # Use superLU solver; orig_nnz = L.nnz; _direct_start = time.time(); lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])); v = lu.solve(b); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end - _direct_start; if (settings.debug or ss_args['return_info']) and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['lu_fill_factor'] = (L_nnz + U_nnz)/L.nnz; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz + U_nnz)/orig_nnz)). else:; # Use umfpack solver; _direct_start = time.time(); v = spsolve(L, b); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end-_direct_start. if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf). if (not ss_args['use_umfpack']) and ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_direct_dense(L, ss_args):; """"""; Direct solver that use numpy dense matrices. Suitable for; small system, with a few states.; """"""; if settings.debug:; logger.debug('Starting direct dense solver.'). dims = L.dims[0]; n = prod(L.dims[0][0]); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L = L.data.todense(); L[0, :] = np.diag(ss_arg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:14359,log,logger,14359,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['log'],['logger']
Testability,"* dt; dW[a_idx, t_idx, j, :] = np.random.poisson(dw_expect,; d2_len). psi_t = sso.rhs(H_data, psi_t, t + dt * j,; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args). # optionally renormalize the wave function; if sso.normalize:; psi_t /= norm(psi_t). if sso.store_measurement:; for m_idx, m in enumerate(sso.m_ops):; for dW_idx, dW_factor in enumerate(sso.dW_factors):; if m[dW_idx]:; m_data = m[dW_idx].data; m_expt = cy_expect_psi_csr(m_data.data,; m_data.indices,; m_data.indptr,; psi_t, 0); else:; m_expt = 0; mm = (m_expt + dW_factor *; dW[m_idx, t_idx, :, dW_idx].sum() /; (dt * sso.N_substeps)); measurements[t_idx, m_idx, dW_idx] = mm. if d2_len == 1:; measurements = measurements.squeeze(axis=(2)). return states_list, dW, measurements, expect, ss. # -----------------------------------------------------------------------------; # Generic parameterized stochastic master equation solver; #; def _smesolve_generic(sso, options, progress_bar):; """"""; Internal function. See smesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; sso.L = liouvillian(sso.H, sso.c_ops). # pre-compute suporoperator operator combinations that are commonly needed; # when evaluating the RHS of stochastic master equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.L.data, sso.dt). # use .data instead of Qobj ?; sso.s_e_ops = [spre(e) for e in sso.e_ops]. if sso.m_ops:; sso.s_m_ops = [[spre(m) if m else None for m in m_op]; for m_op in sso.m_ops]; else:; sso.s_m_ops = [[spre(c) for _ in range(sso.d2_len)]; for c in sso.sc_ops]. map_kwargs",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:25983,log,logger,25983,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,5,['log'],['logger']
Testability,"*kwargs); return evo_result. [docs] def load_circuit(self, qc):; """"""; Translate an :class:`qutip.qip.QubitCircuit` to its; corresponding Hamiltonians. (Defined in subclasses); """"""; raise NotImplementedError(""Use the function in the sub-class""). [docs] def eliminate_auxillary_modes(self, U):; """"""; Eliminate the auxillary modes like the cavity modes in cqed.; (Defined in subclasses); """"""; return U. [docs] def plot_pulses(self, title=None, figsize=None, dpi=None):; """"""; Plot the pulse amplitude. Parameters; ----------; noisy: bool, optional; If true, plot the noisy pulses. title: str; Title for the plot. figsize: tuple; The size of the figure. dpi: int; The dpi of the figure. Returns; -------; fig: matplotlib.figure.Figure; The `Figure` object for the plot. ax: matplotlib.axes._subplots.AxesSubplot; The axes for the plot. Notes; -----; ``plot_pulses`` only works for array_like coefficients; """"""; import matplotlib.pyplot as plt. fig, ax = plt.subplots(1, 1, figsize=figsize, dpi=dpi); ax.set_ylabel(""Control pulse amplitude""); ax.set_xlabel(""Time""). # TODO add test; coeffs = self.coeffs; tlist = self.get_full_tlist(). for i in range(len(coeffs)):; if not isinstance(coeffs[i], (Iterable, np.ndarray)):; raise ValueError(; ""plot_pulse only accepts array_like coefficients.""); if self.spline_kind == ""step_func"":; if len(coeffs[i]) == len(tlist) - 1:; coeffs[i] = np.hstack(; [coeffs[i], coeffs[i][-1:]]); else:; coeffs[i][-1] = coeffs[i][-2]; ax.step(tlist, coeffs[i], where='post'); elif self.spline_kind == ""cubic"":; sp = CubicSpline(tlist, coeffs[i]); t_line = np.linspace(tlist[0], tlist[-1], 200); c_line = [sp(t) for t in t_line]; ax.plot(t_line, c_line); if title is not None:; ax.set_title(title); fig.tight_layout(); return fig, ax. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html:21108,test,test,21108,docs/4.5/modules/qutip/qip/device/processor.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html,1,['test'],['test']
Testability,"*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:20568,log,log,20568,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,20,['log'],"['log', 'logging']"
Testability,", 1, 0]. Parameters; ----------; dims : list or array; The quantum state dimensions array, as it would appear in a Qobj. index : integer; The index of the state in standard enumeration ordering. Returns; -------; state : tuple; The state number tuple corresponding to index `index` in standard; enumeration ordering. """"""; return np.unravel_index(index, dims). [docs]def state_number_qobj(dims, state):; """"""; Return a Qobj representation of a quantum state specified by the state; array `state`. Example:. >>> state_number_qobj([2, 2, 2], [1, 0, 1]) # doctest: +SKIP; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], \; shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]. Parameters; ----------; dims : list or array; The quantum state dimensions array, as it would appear in a Qobj. state : list; State number array. Returns; -------; state : :class:`qutip.Qobj`; The state as a :class:`qutip.Qobj` instance. """"""; assert len(state) == len(dims); return tensor([fock(d, s) for d, s in zip(dims, state)]). #; # Excitation-number restricted (enr) states; #; [docs]def enr_state_dictionaries(dims, excitations):; """"""; Return the number of states, and lookup-dictionaries for translating; a state tuple to a state index, and vice versa, for a system with a given; number of components and maximum number of excitations. Parameters; ----------; dims: list; A list with the number of states in each sub-system. excitations : integer; The maximum numbers of dimension. Returns; -------; nstates, state2idx, idx2state: integer, dict, list; The number of states `nstates`, a dictionary for looking up state; indices from a state tuple, and a list containing the state tuples; ordered by state indices. state2idx and idx2state are reverses of; each other, i.e., state2idx[idx2state[idx]] = idx and; idx2state[state2idx[state]] = state.; """"""; idx2state = list(state_number_enumerate(dims, excitations)); state2idx = {state: idx for idx, state in enumerate(idx2state)};",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/states.html:21907,assert,assert,21907,docs/4.7/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/states.html,2,['assert'],['assert']
Testability,", dynamics.Dynamics):; dyn = self.parent; self.num_tslots = dyn.num_tslots; self.pulse_time = dyn.evo_time; self.scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None. self.apply_params(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots. if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]. self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubou",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulsegen.html:8138,log,logger,8138,docs/4.4/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulsegen.html,1,['log'],['logger']
Testability,", full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if ss_args['solver'] == 'mkl':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); with warnings.catch_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/steadystate.html:24176,log,logger,24176,docs/4.7/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html,2,['log'],['logger']
Testability,", two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions:; psi = basis(2, 0). rho = ket2dm(psi). print(rho). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. vec_rho = operator_to_vector(rho). print(vec_rho). Output:; Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The type attribute indicates whether a quantum object is; a vector corresponding to an operator (operator-ket), or its Hermitian; conjugate (operator-bra).; Note that QuTiP uses the column-stacking convention for the isomorphism; between \(\mathcal{L}(\mathcal{H})\) and \(\mathcal{H} \otimes \mathcal{H}\):; A = Qobj(np.arange(4).reshape((2, 2))). print(A). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. print(operator_to_vector(A)). Output:; Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; X = sigmax(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-states.html:17935,test,testing,17935,docs/4.6/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html,2,['test'],['testing']
Testability,", two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions:; psi = basis(2, 0). rho = ket2dm(psi). print(rho). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. vec_rho = operator_to_vector(rho). print(vec_rho). Output:; Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The type attribute indicates whether a quantum object is; a vector corresponding to an operator (operator-ket), or its Hermitian; conjugate (operator-bra).; Note that QuTiP uses the column-stacking convention for the isomorphism; between \(\mathcal{L}(\mathcal{H})\) and \(\mathcal{H} \otimes \mathcal{H}\):; A = Qobj(np.arange(4).reshape((2, 2))). print(A). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. print(operator_to_vector(A)). Output:; Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; X = sigmax(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-states.html:17993,test,testing,17993,docs/4.7/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html,2,['test'],['testing']
Testability,", which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html:30218,log,logging,30218,docs/4.1/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html,5,['log'],['logging']
Testability,"-------; >>> thermal_dm(5, 1) # doctest: +SKIP; Quantum object: dims = [[5], [5]], \; shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic') # doctest: +SKIP; Quantum object: dims = [[5], [5]], \; shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. Notes; -----; The 'operator' method (default) generates; the thermal state using the truncated number operator ``num(N)``. This; is the method that should be used in computations. The; 'analytic' method uses the analytic coefficients derived in; an infinite Hilbert space. The analytic form is not necessarily normalized,; if truncated too aggressively. """"""; if n == 0:; return fock_dm(N, 0); else:; i = arange(N); if method == 'operator':; beta = np.log(1.0 / n + 1.0); diags = np.exp(-beta * i); diags = diags / np.sum(diags); # populates diagonal terms using truncated operator expression; rm = sp.spdiags(diags, 0, N, N, format='csr'); elif method == 'analytic':; # populates diagonal terms using analytic values; rm = sp.spdiags((1.0 + n) ** (-1.0) * (n / (1.0 + n)) ** (i),; 0, N, N, format='csr'); else:; raise ValueError(""The method option can only take ""; ""values 'operator' or 'analytic'""); return Qobj(rm). [docs]def maximally_mixed_dm(N):; """"""; Returns the maximally mixed density matrix for a Hilbert space of; dimension N. Parameters; ----------; N : int; Number of basis states in Hilbert space. Returns; -------; dm : qobj; Thermal state density matrix.; """"""; if (not isinstance(N, (int, np.int64))) or N <= 0:; raise ValueError(""N must be integer N > 0""). dm = sp.spdiags(np.ones(N, dtype=complex)/float(N), 0, N, N, format='csr'). return Qobj(dm, isherm=True). [docs]def ket2dm(Q):; """"""Takes input ket or bra vector and returns density ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/states.html:13606,log,log,13606,docs/4.6/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/states.html,4,['log'],['log']
Testability,"-; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs. self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs. if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)). if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs,; self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs. [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(). [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generatio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulsegen.html:30585,log,logger,30585,docs/4.4/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulsegen.html,1,['log'],['logger']
Testability,"-; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs. self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs. if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)). if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs,; self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs. [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats; """"""; return self.coeffs.ravel().tolist(). [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:30585,log,logger,30585,docs/4.6/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html,4,['log'],['logger']
Testability,". """"""; Classes that define the dynamics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls = np.array(ctrls, dtype=object); except:; pass. if isinstance(c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:3256,log,logging,3256,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,1,['log'],['logging']
Testability,". """"""; Classes that define the dynamics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Us",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:3260,log,logging,3260,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,2,['log'],['logging']
Testability,". """"""; Classes that define the dynamics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False; ; def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls = np.array(ctrls); except:; pass; ; if isinstance(ctrls, np.n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:3260,log,logging,3260,docs/4.2/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html,2,['log'],['logging']
Testability,". . Installation — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Verifying the Installation; Checking Version Information using the About Function; Installation on MS Windows. Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.4+ is highly recommended. Numpy; 1.8+; Not tested on lower versions. Scipy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. gfortran; 4.2+; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Needed for using the Bloch3d class. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are tested only on the Linux and OS X platforms.; We would not recom",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/installation.html:810,test,tested,810,docs/4.0.2/installation.html,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html,1,['test'],['tested']
Testability,". . Installation — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platforms. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:834,test,tested,834,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,1,['test'],['tested']
Testability,". . Installation — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/installation.html:834,test,tested,834,docs/4.2/installation.html,https://qutip.org,https://qutip.org/docs/4.2/installation.html,1,['test'],['tested']
Testability,". . Installation — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/installation.html:834,test,tested,834,docs/4.3/installation.html,https://qutip.org,https://qutip.org/docs/4.3/installation.html,1,['test'],['tested']
Testability,". . Installation — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when usin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/installation.html:830,test,tested,830,docs/4.4/installation.html,https://qutip.org,https://qutip.org/docs/4.4/installation.html,1,['test'],['tested']
Testability,". . Installation — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. pytest; 5.3+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/installation.html:843,test,tested,843,docs/4.5/installation.html,https://qutip.org,https://qutip.org/docs/4.5/installation.html,1,['test'],['tested']
Testability,". API documentation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Classes; Functions. Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; API documentation. API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; QobjEvo; eseries; Bloch sphere; Distributions; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Quantum Objects; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations; Operators and Superoperator Dimensions. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Measurement; Measurement of quantum states. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Krylov Subspace Solver; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Lattice; Lattice Properties; Topology. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms; Circuit. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; Semidefinite Programming; IPyt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/apidoc.html:189,Log,Log,189,docs/4.7/apidoc/apidoc.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/apidoc.html,1,['Log'],['Log']
Testability,". Basic Operations on Quantum Objects — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify st",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-basics.html:879,Log,Log,879,docs/4.6/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html,1,['Log'],['Log']
Testability,". Basic Operations on Quantum Objects — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators inste",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-basics.html:913,Log,Log,913,docs/4.7/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-basics.html,1,['Log'],['Log']
Testability,". Basic use of Processor — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Gallery »; Basic use of Processor. Note; Click here; to download the full example code. Basic use of Processor¶; This example contains the basic functions of qutip.qip.device.Processor. We define a simulator with control Hamiltonian, pulse amplitude and time slice for each pulse. The two figures illustrate the pulse shape for two different setup: step function or continuous pulse. Out:; (<Figure size 1200x600 with 1 Axes>, [<AxesSubplot:>]). import copy; import numpy as np; import matplotlib.pyplot as plt; pi = np.pi; from qutip.qip.device import Processor; from qutip.operators import sigmaz; from qutip.states import basis. processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""step_func""); processor.add_control(sigmaz(), 0); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""cubic""); processor.add_control(sigmaz()); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). Total running time of the script: ( 0 minutes 1.187 seconds). Download Python source code: plot_qip_intro_processor.py. Download Jupyter notebook: plot_qip_intro_processor.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on F",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_intro_processor.html:270,Log,Log,270,docs/4.6/gallery/build/qip/plot_qip_intro_processor.html,https://qutip.org,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_intro_processor.html,1,['Log'],['Log']
Testability,". Basic use of Processor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Basic use of Processor. Note; Click here; to download the full example code. Basic use of Processor¶; This example contains the basic functions of qutip.qip.device.Processor. We define a simulator with control Hamiltonian, pulse amplitude and time slice for each pulse. The two figures illustrate the pulse shape for two different setup: step function or continuous pulse. Out:; (<Figure size 1200x600 with 1 Axes>, [<AxesSubplot:>]). import copy; import numpy as np; import matplotlib.pyplot as plt; pi = np.pi; from qutip.qip.device import Processor; from qutip.operators import sigmaz; from qutip.states import basis. processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""step_func""); processor.add_control(sigmaz(), 0); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""cubic""); processor.add_control(sigmaz()); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). Total running time of the script: ( 0 minutes 0.814 seconds). Download Python source code: plot_qip_intro_processor.py. Download Jupyter notebook: plot_qip_intro_processor.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Doc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html:270,Log,Log,270,docs/4.7/gallery/build/qip/plot_qip_intro_processor.html,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html,1,['Log'],['Log']
Testability,". Classes — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Classes; Qobj; QobjEvo; eseries; Bloch sphere; Distributions; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions. Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; API documentation »; Classes. Classes¶. Qobj¶. class Qobj(inpt=None, dims=None, shape=None, type=None, isherm=None, copy=True, fast=False, superrep=None, isunitary=None)[source]¶; A class for representing quantum objects, such as quantum operators; and states.; The Qobj class is the QuTiP representation of quantum operators and state; vectors. This class also implements math operations +,-,* between Qobj; instances (and / by a C-number), as well as a collection of common; operator/state operations. The Qobj constructor optionally takes a; dimension list and/or shape list as arguments. Parameters. inptarray_likeData for vector/matrix representation of the quantum object. dimslistDimensions of object used for tensor products. shapelistShape of underlying data structure (matrix shape). copyboolFlag specifying whether Qobj should get a copy of the; input data, or use the original. fastboolFlag for fast qobj creation when running ode solvers.; This parameter is used internally only. Attributes. dataarray_likeSparse matrix characterizing the quantum object. dimslistList of dimensions keeping track of the tensor structure. shapelistShape of the underlying data array. typestrType of quantum object: ‘bra’, ‘ket’, ‘oper’, ‘operator-ket’,; ‘operator-bra’, or ‘super’. superrepstrRepresentation used if type is ‘super’. One of ‘super’; (Liouville form) or ‘choi’ (Choi matrix with tr = dimension). ishermboolIndicates if quantum object represents Hermitian operator. isunitaryb",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:421,Log,Log,421,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,1,['Log'],['Log']
Testability,". Classes — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Classes; Qobj; QobjEvo; eseries; Bloch sphere; Distributions; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions. Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; API documentation »; Classes. Classes¶. Qobj¶. class Qobj(inpt=None, dims=None, shape=None, type=None, isherm=None, copy=True, fast=False, superrep=None, isunitary=None)[source]¶; A class for representing quantum objects, such as quantum operators; and states.; The Qobj class is the QuTiP representation of quantum operators and state; vectors. This class also implements math operations +,-,* between Qobj; instances (and / by a C-number), as well as a collection of common; operator/state operations. The Qobj constructor optionally takes a; dimension list and/or shape list as arguments. Parameters. inptarray_likeData for vector/matrix representation of the quantum object. dimslistDimensions of object used for tensor products. shapelistShape of underlying data structure (matrix shape). copyboolFlag specifying whether Qobj should get a copy of the; input data, or use the original. fastboolFlag for fast qobj creation when running ode solvers.; This parameter is used internally only. Attributes. dataarray_likeSparse matrix characterizing the quantum object. dimslistList of dimensions keeping track of the tensor structure. shapelistShape of the underlying data array. typestrType of quantum object: ‘bra’, ‘ket’, ‘oper’, ‘operator-ket’,; ‘operator-bra’, or ‘super’. superrepstrRepresentation used if type is ‘super’. One of ‘super’; (Liouville form) or ‘choi’ (Choi matrix with tr = dimension). ishermboolIndicates if quantum object represents Hermi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:421,Log,Log,421,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['Log'],['Log']
Testability,". Contributing to QuTiP Development — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Contributing to QuTiP Development. Contributing to QuTiP Development¶. Quick Start¶; QuTiP is developed through wide collaboration using the git version-control system, with the main repositories hosted in the qutip organisation on GitHub.; You will need to be familiar with git as a tool, and the GitHub Flow workflow for branching and making pull requests.; The exact details of environment set-up, build process and testing vary by repository and are discussed below, however in overview, the steps to contribute are:. Consider creating an issue on the GitHub page of the relevant repository, describing the change you think should be made and why, so we can discuss details with you and make sure it is appropriate.; (If this is your first contribution.) Make a fork of the relevant repository on GitHub and clone it to your local computer. Also add our copy as a remote (git remote add qutip https://github.com/qutip/<repo>); Begin on the master branch (git checkout master), and pull in changes from the main QuTiP repository to make sure you have an up-to-date copy (git pull qutip master).; Switch to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can che",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:185,Log,Log,185,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,3,"['Log', 'Test']","['Log', 'Testing']"
Testability,". Contributing to QuTiP Development — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing; Changelog Generation. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Contributing to QuTiP Development. Contributing to QuTiP Development¶. Quick Start¶; QuTiP is developed through wide collaboration using the git version-control system, with the main repositories hosted in the qutip organisation on GitHub.; You will need to be familiar with git as a tool, and the GitHub Flow workflow for branching and making pull requests.; The exact details of environment set-up, build process and testing vary by repository and are discussed below, however in overview, the steps to contribute are:. Consider creating an issue on the GitHub page of the relevant repository, describing the change you think should be made and why, so we can discuss details with you and make sure it is appropriate.; (If this is your first contribution.) Make a fork of the relevant repository on GitHub and clone it to your local computer. Also add our copy as a remote (git remote add qutip https://github.com/qutip/<repo>); Begin on the master branch (git checkout master), and pull in changes from the main QuTiP repository to make sure you have an up-to-date copy (git pull qutip master).; Switch to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/contributing.html:185,Log,Log,185,docs/4.7/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html,3,"['Log', 'Test']","['Log', 'Testing']"
Testability,". Control Amplitude Noise — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Gallery »; Control Amplitude Noise. Note; Click here; to download the full example code. Control Amplitude Noise¶; This example demonstrates how to add Gaussian noise to the control pulse. Out:; [<matplotlib.lines.Line2D object at 0x7f24ea6622b0>]. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.qip.noise import RandomNoise; from qutip.operators import sigmaz, sigmay. # add control Hamiltonians; processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). # define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, ax2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); ax2[0].step(qobjevo.tlist, noisy_coeff). Total running time of the script: ( 0 minutes 0.094 seconds). Download Python source code: plot_qip_amplitude_noise.py. Download Jupyter notebook: plot_qip_amplitude_noise.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_amplitude_noise.html:271,Log,Log,271,docs/4.6/gallery/build/qip/plot_qip_amplitude_noise.html,https://qutip.org,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_amplitude_noise.html,1,['Log'],['Log']
Testability,". Control Amplitude Noise — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Control Amplitude Noise. Note; Click here; to download the full example code. Control Amplitude Noise¶; This example demonstrates how to add Gaussian noise to the control pulse. Out:; [<matplotlib.lines.Line2D object at 0x7f0268569e80>]. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.qip.noise import RandomNoise; from qutip.operators import sigmaz, sigmay. # add control Hamiltonians; processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). # define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, ax2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); ax2[0].step(qobjevo.tlist, noisy_coeff). Total running time of the script: ( 0 minutes 0.081 seconds). Download Python source code: plot_qip_amplitude_noise.py. Download Jupyter notebook: plot_qip_amplitude_noise.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Bui",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html:271,Log,Log,271,docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html,1,['Log'],['Log']
Testability,". Development Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation bui",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/development.html:177,Log,Log,177,docs/4.6/development/development.html,https://qutip.org,https://qutip.org/docs/4.6/development/development.html,3,"['Log', 'Test']","['Log', 'Testing']"
Testability,". Development Documentation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing; Changelog Generation. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; Solver data layer integration; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. Completed Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; QIP migration; HEOM revamp. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects; TensorFlow Data Backend. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Setting Up The Release Branch; Updating the Ch",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/development.html:177,Log,Log,177,docs/4.7/development/development.html,https://qutip.org,https://qutip.org/docs/4.7/development/development.html,3,"['Log', 'Test']","['Log', 'Testing']"
Testability,". Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) and \(E[dW^2] = dt\). Stochastic evolution is implemented with the qutip.stochastic.general_stochastic function. Stochastic Schrodinger Equation¶; The stochastic Schrodinger equation ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:1083,Log,Log,1083,docs/4.6/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html,1,['Log'],['Log']
Testability,". Gallery — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Gallery. Gallery¶; This is the gallery for QuTiP examples, you can click on the image to see the source code. Quantum Information Processing¶. Basic use of Processor¶. T2 Relaxation¶. Control Amplitude Noise¶. Download all examples in Python source code: build_python.zip. Download all examples in Jupyter notebooks: build_jupyter.zip. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/gallery/build/index.html:255,Log,Log,255,docs/4.6/gallery/build/index.html,https://qutip.org,https://qutip.org/docs/4.6/gallery/build/index.html,1,['Log'],['Log']
Testability,". Gallery — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery. Gallery¶; This is the gallery for QuTiP examples, you can click on the image to see the source code. Quantum Information Processing¶. Basic use of Processor¶. T2 Relaxation¶. Control Amplitude Noise¶. Download all examples in Python source code: build_python.zip. Download all examples in Jupyter notebooks: build_jupyter.zip. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/gallery/build/index.html:255,Log,Log,255,docs/4.7/gallery/build/index.html,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/index.html,1,['Log'],['Log']
Testability,". Generating Random Quantum States & Operators — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Generating Random Quantum States & Operators. Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state, unitary and channel generators for simulations, Monte Carlo evaluation, theorem evaluation, and code testing.; Each of these objects can be sampled from one of several different distributions including the default distributions; used by QuTiP versions prior to 3.2.0.; For example, a random Hermitian operator can be sampled by calling rand_herm function:; >>> rand_herm(5) ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[-0.25091976+0.j 0. +0.j 0. +0.j; -0.21793701+0.47037633j -0.23212846-0.61607187j]; [ 0. +0.j -0.88383278+0.j 0.836086 -0.23956218j; -0.09464275+0.45370863j -0.15243356+0.65392096j]; [ 0. +0.j 0.836086 +0.23956218j 0.66488528+0.j; -0.26290446+0.64984451j -0.52603038-0.07991553j]; [-0.21793701-0.47037633j -0.09464275-0.45370863j -0.26290446-0.64984451j; -0.13610996+0.j -0.34240902-0.2879303j ]; [-0.23212846+0.61607187j -0.15243356-0.65392096j -0.52603038+0.07991553j; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-random.html:813,Log,Log,813,docs/4.6/guide/guide-random.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-random.html,1,['Log'],['Log']
Testability,". Generating Random Quantum States & Operators — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Generating Random Quantum States & Operators. Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state, unitary and channel generators for simulations, Monte Carlo evaluation, theorem evaluation, and code testing.; Each of these objects can be sampled from one of several different distributions including the default distributions; used by QuTiP versions prior to 3.2.0.; For example, a random Hermitian operator can be sampled by calling rand_herm function:; >>> rand_herm(5) ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[-0.25091976+0.j 0. +0.j 0. +0.j; -0.21793701+0.47037633j -0.23212846-0.61607187j]; [ 0. +0.j -0.88383278+0.j 0.836086 -0.23956218j; -0.09464275+0.45370863j -0.15243356+0.65392096j]; [ 0. +0.j 0.836086 +0.23956218j 0.66488528+0.j; -0.26290446+0.64984451j -0.52603038-0.07991553j]; [-0.21793701-0.47037633j -0.09464275-0.45370863j -0.26290446-0.64984451j; -0.13610996+0.j -0.34240902-0.2879303j ]; [-0.23212846+0.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-random.html:847,Log,Log,847,docs/4.7/guide/guide-random.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-random.html,1,['Log'],['Log']
Testability,". Hierarchical Equations of Motion — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion. Hierarchical Equations of Motion¶. Introduction; Bosonic Environments; Describing the system and bath; System and bath dynamics; Steady-state; Matsubara Terminator; Matsubara expansion coefficients; Multiple baths. Fermionic Environments; Describing the system and bath; System and bath dynamics; Determining currents; Steady state currents; Padé expansion coefficients. Previous implementations; HSolverDL; BoFiN-HEOM; Current implementation. References. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-heom.html:863,Log,Log,863,docs/4.7/guide/guide-heom.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-heom.html,1,['Log'],['Log']
Testability,". Ideas for future QuTiP development — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development. Ideas for future QuTiP development¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas.html:186,Log,Log,186,docs/4.6/development/ideas.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas.html,1,['Log'],['Log']
Testability,". Ideas for future QuTiP development — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects; TensorFlow Data Backend. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development. Ideas for future QuTiP development¶; Ideas for significant new features are listed here. For the general roadmap,; see QuTiP Development Roadmap. QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Google Summer of Code¶; Many possible extensions and improvements to QuTiP have been documented as; part of Google Summer of Code:. GSoC 2021; GSoC 2022. Completed Projects¶; These projects have been completed:. TensorFlow Data Backend. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas.html:186,Log,Log,186,docs/4.7/development/ideas.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas.html,1,['Log'],['Log']
Testability,". Introduction — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Introduction. Introduction¶; The Hierarchical Equations of Motion (HEOM) method was originally developed by; Tanimura and Kubo [TK89] in the context of physical chemistry to; ‘’exactly’’ solve a quantum system in contact with a bosonic environment,; encapsulated in the Hamiltonian:. \[H = H_s + \sum_k \omega_k a_k^{\dagger}a_k + \hat{Q} \sum_k g_k \left(a_k + a_k^{\dagger}\right).\]; As in other solutions to this problem, the properties of the bath are; encapsulated by its temperature and its spectral density,. \[J(\omega) = \pi \sum_k g_k^2 \delta(\omega-\omega_k).\]; In the HEOM, for bosonic baths, one typically chooses a Drude-Lorentz spectral; density:. \[J_D = \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},\]; or an under-damped Brownian motion spectral density:. \[J_U = \frac{\alpha^2 \Gamma \omega}{[(\omega_c^2 - \omega^2)^2 + \Gamma^2 \omega^2]}.\]; Given the spectral density, the HEOM requires a decomposition of the bath; correlation functions in terms of ex",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/intro.html:843,Log,Log,843,docs/4.7/guide/heom/intro.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/intro.html,1,['Log'],['Log']
Testability,". Measurement of Quantum Objects — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-measurement.html:925,Log,Log,925,docs/4.6/guide/guide-measurement.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html,1,['Log'],['Log']
Testability,". Measurement of Quantum Objects — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-measurement.html:959,Log,Log,959,docs/4.7/guide/guide-measurement.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html,1,['Log'],['Log']
Testability,". Modifying Internal QuTiP Settings — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These setting",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-settings.html:809,Log,Log,809,docs/4.6/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-settings.html,1,['Log'],['Log']
Testability,". Modifying Internal QuTiP Settings — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite sim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-settings.html:843,Log,Log,843,docs/4.7/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html,1,['Log'],['Log']
Testability,". Operator-level circuit simulation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Operator-level circuit simulation. Operator-level circuit simulation¶. Note; New in QuTiP 4.6. Run a quantum circuit¶; Let’s start off by defining a simple circuit which we use to demonstrate a few; examples of circuit evolution.; We take a circuit from OpenQASM 2; from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.operations import controlled_gate, hadamard_transform; def controlled_hadamard():; # Controlled Hadamard; return controlled_gate(; hadamard_transform(1), 2, control=0, target=1, control_value=1); qc = QubitCircuit(N=3, num_cbits=3); qc.user_gates = {""cH"": controlled_hadamard}; qc.add_gate(""QASMU"", targets=[0], arg_value=[1.91063, 0, 0]); qc.add_gate(""cH"", targets=[0,1]); qc.add_gate(""TOFFOLI"", targets=[2], controls=[0, 1]); qc.add_gate(""X"", targets=[0]); qc.add_gate(""X"", targets=[1]); qc.add_gate(""CNOT"", targets=[1], controls=0). It corresponds to the follow",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-simulator.html:962,Log,Log,962,docs/4.6/guide/qip/qip-simulator.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-simulator.html,1,['Log'],['Log']
Testability,. Overview: module code — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.topology; qutip.utilities; qutip.visualization; qutip.wigner. © Copyr,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/index.html:173,Log,Log,173,docs/4.6/modules/index.html,https://qutip.org,https://qutip.org/docs/4.6/modules/index.html,1,['Log'],['Log']
Testability,. Overview: module code — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch3d; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.krylovsolve; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.bofin_baths; qutip.nonmarkov.bofin_solvers; qutip.nonmarkov.dlheom_solver; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qut,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/index.html:173,Log,Log,173,docs/4.7/modules/index.html,https://qutip.org,https://qutip.org/docs/4.7/modules/index.html,1,['Log'],['Log']
Testability,". Parallel computation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-parfor.html:783,Log,Log,783,docs/4.6/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-parfor.html,1,['Log'],['Log']
Testability,". Parallel computation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-parfor.html:817,Log,Log,817,docs/4.7/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html,1,['Log'],['Log']
Testability,". Plotting on the Bloch Sphere — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Differences Between Bloch and Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay. Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.bloch.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.bloch3d.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.bloch.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.bloch3d.Bloch3d version. Before gettin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-bloch.html:974,Log,Log,974,docs/4.7/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html,1,['Log'],['Log']
Testability,". Previous implementations — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; HSolverDL; BoFiN-HEOM; Current implementation. References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Previous implementations. Previous implementations¶; The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL¶; The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford and is still available as; qutip.nonmarkov.dlheom_solver.HSolverDL and only directly provided; support for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/history.html:902,Log,Log,902,docs/4.7/guide/heom/history.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html,1,['Log'],['Log']
Testability,". Quantum Information Processing — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Quantum Information Processing. Quantum Information Processing¶. Introduction¶; The Quantum Information Processing (QIP) module aims at providing basic tools for quantum computing simulation both for simple quantum algorithm design and for experimental realization. It offers two different approaches, one with QubitCircuit calculating unitary evolution under quantum gates by matrix product, another called Processor using open system solvers in QuTiP to simulate noisy quantum device. Quantum Circuit¶; The most common model for quantum computing is the quantum circuit model.; In QuTiP, we use QubitCircuit to represent a quantum circuit.; The circuit is characterized by registers and gates:. Registers: The argument N specifies the number of qubit registers in the circuit; and the argument num_cbits (optional) specifies the number of classical bits available for measurement; and control.; Gates: Each quantum gate is saved a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-basics.html:925,Log,Log,925,docs/4.6/guide/qip/qip-basics.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html,1,['Log'],['Log']
Testability,". Quantum Information Processing — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing. Quantum Information Processing¶. Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-qip.html:828,Log,Log,828,docs/4.6/guide/guide-qip.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-qip.html,1,['Log'],['Log']
Testability,". Quantum Information Processing — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Quantum Information Processing. Quantum Information Processing¶. Introduction¶; The Quantum Information Processing (QIP) module aims at providing basic tools for quantum computing simulation both for simple quantum algorithm design and for experimental realization. It offers two different approaches, one with QubitCircuit calculating unitary evolution under quantum gates by matrix product, another called Processor using open system solvers in QuTiP to simulate noisy quantum device. Quantum Circuit¶; The most common model for quantum computing is the quantum circuit model.; In QuTiP, we use QubitCircuit to represent a quantum circuit.; The circuit is characterized by registers and gates:. Registers: The argument N specifies the number of qubit registers in the circuit; and the argument num_cbits (optional) specifies the number of classical bits available for mea",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/qip/qip-basics.html:959,Log,Log,959,docs/4.7/guide/qip/qip-basics.html,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html,1,['Log'],['Log']
Testability,". Quantum Information Processing — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing. Quantum Information Processing¶. Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-qip.html:862,Log,Log,862,docs/4.7/guide/guide-qip.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-qip.html,1,['Log'],['Log']
Testability,". Quantum Optimal Control — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Optimal Control. Quantum Optimal Control¶. Introduction¶; In quantum control we look to prepare some specific state, effect some state-to-state transfer, or effect some transformation (or gate) on a quantum system. For a given quantum system there will always be factors that effect the dynamics that are outside of our control. As examples, the interactions between elements of the system or a magnetic field required to trap the system. However, there may be methods of affecting the dynamics in a controlled way, such as the time varying amplitude of the electric component of an interacting laser field. And so this leads to some questions; given a specific quantum system with known time-independent dynamics generator (referred to as the drift dynamics generators) and set of externally controllable fields for which the interaction can be described by control dynamics generators:. what states or transformations can we achieve (if any)?; what is the shape of the control pulse required to achieve this?. Thes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-control.html:867,Log,Log,867,docs/4.6/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html,1,['Log'],['Log']
Testability,". Quantum Optimal Control — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Optimal Control. Quantum Optimal Control¶. Introduction¶; In quantum control we look to prepare some specific state, effect some state-to-state transfer, or effect some transformation (or gate) on a quantum system. For a given quantum system there will always be factors that effect the dynamics that are outside of our control. As examples, the interactions between elements of the system or a magnetic field required to trap the system. However, there may be methods of affecting the dynamics in a controlled way, such as the time varying amplitude of the electric component of an interacting laser field. And so this leads to some questions; given a specific quantum system with known time-independent dynamics generator (referred to as the drift dynamics generators) and set of externally controllable fields for which the interaction can be described by control dynamics generators:. What states or transformations can we achieve (if any)?; What is the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:901,Log,Log,901,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,1,['Log'],['Log']
Testability,". References — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; References. References¶. LACN19; Neill Lambert, Shahnawaz Ahmed, Mauro Cirio, and Franco Nori. Virtual excitations in the ultra-strongly-coupled spin-boson model: physical results from unphysical modes. arXiv preprint arXiv:1903.05892, 2019. Tan20; Yoshitaka Tanimura. Numerically “exact” approach to open quantum dynamics: the hierarchical equations of motion (heom). The Journal of Chemical Physics, 153(2):020901, 2020. URL: https://doi.org/10.1063/5.0011599, doi:10.1063/5.0011599. TK89; Yoshitaka Tanimura and Ryogo Kubo. Time evolution of a quantum system in contact with a nearly gaussian-markoffian noise bath. J. Phys. Soc. Jpn., 58(1):101–114, 1989. doi:10.1143/jpsj.58.101. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/references.html:841,Log,Log,841,docs/4.7/guide/heom/references.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/references.html,1,['Log'],['Log']
Testability,". Saving QuTiP Objects and Data Sets — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parame",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-saving.html:832,Log,Log,832,docs/4.7/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html,1,['Log'],['Log']
Testability,". Solving for Steady-State Solutions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Solving for Steady-State Solutions. Solving for Steady-State Solutions¶. Introduction¶; For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as \(t\rightarrow\infty\) that satisfies the equation. \[\frac{d\hat{\rho}_{ss}}{dt}=\mathcal{L}\hat{\rho}_{ss}=0.\]; Although the requirement for time-independence seems quite resitrictive, one can often employ a transformation to the interaction picture that yields a time-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-steady.html:917,Log,Log,917,docs/4.7/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html,1,['Log'],['Log']
Testability,". T2 Relaxation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Gallery »; T2 Relaxation. Note; Click here; to download the full example code. T2 Relaxation¶; Simulating the T2 relaxation of a single qubit with qutip.qip.device.Processor. The single qubit is driven by a rotation around z axis. We measure the population of the plus state as a function of time to see the Ramsey signal. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.operators import sigmaz, destroy; from qutip.qip.operations import snot; from qutip.states import basis. a = destroy(2); Hadamard = snot(); plus_state = (basis(2,1) + basis(2,0)).unit(); tlist = np.arange(0.00, 20.2, 0.2). T2 = 5; processor = Processor(1, t2=T2); processor.add_control(sigmaz()); processor.pulses[0].coeff = np.ones(len(tlist)); processor.pulses[0].tlist = tlist; result = processor.run_state(; plus_state, e_ops=[a.dag()*a, Hadamard*a.dag()*a*Hadamard]). fig, ax = plt.subplots(); # detail about length of tlist needs to be fixed; ax.plot(tlist[:-1], result.expect[1][:-1], '.', label=""simulation""); ax.plot(tlist[:-1], np.exp(-1./T2*tlist[:-1])*0.5 + 0.5, label=""theory""); ax.set_xlabel(""t""); ax.set_ylabel(""Ramsey signal""); ax.legend(); ax.set_title(""Relaxation T2=5""); ax.grid(); fig.tight_layout(); fig.show(). Total running time of the script: ( 0 minutes 0.147 seconds). Download Python source code: plot_qip_relaxation.py. Download Jupyter notebook: plot_qip_relaxation.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_relaxation.html:261,Log,Log,261,docs/4.6/gallery/build/qip/plot_qip_relaxation.html,https://qutip.org,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_relaxation.html,1,['Log'],['Log']
Testability,". T2 Relaxation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; T2 Relaxation. Note; Click here; to download the full example code. T2 Relaxation¶; Simulating the T2 relaxation of a single qubit with qutip.qip.device.Processor. The single qubit is driven by a rotation around z axis. We measure the population of the plus state as a function of time to see the Ramsey signal. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.operators import sigmaz, destroy; from qutip.qip.operations import snot; from qutip.states import basis. a = destroy(2); Hadamard = snot(); plus_state = (basis(2,1) + basis(2,0)).unit(); tlist = np.arange(0.00, 20.2, 0.2). T2 = 5; processor = Processor(1, t2=T2); processor.add_control(sigmaz()); processor.pulses[0].coeff = np.ones(len(tlist)); processor.pulses[0].tlist = tlist; result = processor.run_state(; plus_state, e_ops=[a.dag()*a, Hadamard*a.dag()*a*Hadamard]). fig, ax = plt.subplots(); # detail about length of tlist needs to be fixed; ax.plot(tlist[:-1], result.expect[1][:-1], '.', label=""simulation""); ax.plot(tlist[:-1], np.exp(-1./T2*tlist[:-1])*0.5 + 0.5, label=""theory""); ax.set_xlabel(""t""); ax.set_ylabel(""Ramsey signal""); ax.legend(); ax.set_title(""Relaxation T2=5""); ax.grid(); fig.tight_layout(); fig.show(). Total running time of the script: ( 0 minutes 0.136 seconds). Download Python source code: plot_qip_relaxation.py. Download Jupyter notebook: plot_qip_relaxation.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html:261,Log,Log,261,docs/4.7/gallery/build/qip/plot_qip_relaxation.html,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html,1,['Log'],['Log']
Testability,". Two-time correlation functions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Two-time correlation functions. Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of same-time operators.; To calculate two-time correlation functions on the form \(\left<A(t+\tau)B(t)\right>\), we can use the quantum regression theorem (see, e.g., [Gar03]) to write. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-correlation.html:953,Log,Log,953,docs/4.7/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html,1,['Log'],['Log']
Testability,". Users Guide — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide. Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide.html:710,Log,Log,710,docs/4.6/guide/guide.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide.html,1,['Log'],['Log']
Testability,". Users Guide — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide. Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-Stat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide.html:744,Log,Log,744,docs/4.7/guide/guide.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html,1,['Log'],['Log']
Testability,". Using Tensor Products and Partial Traces — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Two coupled qubits; Three coupled qubits; A two-level system coupled to a cavity: The Jaynes-Cummings model. Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Using Tensor Products and Partial Traces. Using Tensor Products and Partial Traces¶. Tensor products¶; To describe the states of multipartite quantum systems - such as two coupled qubits, a qubit coupled to an oscillator, etc. - we need to expand the Hilbert space by taking the tensor product of the state vectors for each of the system components. Similarly, the operators acting on the state vectors in the combined Hilbert space (describing the coupled system) are formed by taking the tensor product of the individual operators.; In QuTiP the function qutip.tensor.tensor is used to accomplish this task. This function takes as argument a collection:; >>> tensor(op1, op2, op3) . or a list:; >>> tensor([op1, op2, op3]) . of state vectors or operators and returns a composite quantum object for the combined Hilbert space. The function accepts an arbitray number of states or operators as argument. The type returned qu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-tensor.html:967,Log,Log,967,docs/4.6/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-tensor.html,1,['Log'],['Log']
Testability,". Value of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:rho : qobj. sensity matrix or ket/bra vector. Returns:entropy : float. Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters:rho : qobj. Density matrix for composite quantum systems. selA : int/list. int or list of first selected density matrix components. selB : int/list. int or list of second selected density matrix components. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_mut : float. Mutual information between selected components. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy of density matrix. Parameters:rho : qobj. Density matrix. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:entropy : float. Von-Neumann entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. Density Matrix Metrics¶; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators. fidelity(A, B)[source]¶; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters:A : qobj. Density matrix or state vector. B : qobj. Density matrix or state vector with same dimensions as A. Returns:fid : float. Fidelity pseudo-metric between A and B. Examples; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> fidelity(x,y); 0.24104350624628332. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters:A : qobj. Density matrix o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:45463,log,logarithm,45463,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['log'],['logarithm']
Testability,". Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). « Functions. Developers ». Change Log¶. Version 3.1.0 (January 1, 2015):¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now su",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/changelog.html:2681,log,logging,2681,docs/3.1.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html,1,['log'],['logging']
Testability,". Visualization of quantum states and processes — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Wigner function; Husimi Q-function. Visualizing operators; Quantum process tomography; Implementation in QuTiP. Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Visualization of quantum states and processes. Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. Fock-basis probability distribution¶; In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a prob",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-visualization.html:960,Log,Log,960,docs/4.7/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-visualization.html,1,['Log'],['Log']
Testability,". Working with the QuTiP Documentation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/docs.html:188,Log,Log,188,docs/4.7/development/docs.html,https://qutip.org,https://qutip.org/docs/4.7/development/docs.html,1,['Log'],['Log']
Testability,". ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other. Included are the trace distance qutip.metrics.tracedist, fidelity qutip.metrics.fidelity, Hilbert-Schmidt distance qutip.metrics.hilbert_dist, Bures distance qutip.metrics.bures_dist, Bures angle qutip.metrics.bures_angle, and quantum Hellinger distance qutip.metrics.hellinger_dist.; x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\), while the quantum Hellinger distance (QHE) between two pure states \(\left|\psi\right>\) and \(\left|\phi\right>\) is given by \(QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}\).; np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?; vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators qutip.operators.sigmax, qutip.operators.sigmay, qutip.operators.si",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-states.html:10765,test,testing,10765,docs/4.6/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html,4,['test'],['testing']
Testability,". def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_args['permc_spec'],; drop_tol=ss_args['drop_tol'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; fill_factor=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). M = LinearOperator((n ** 2, n ** 2), matvec=P.solve); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except Exception:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/steadystate.html:19431,log,logger,19431,docs/4.7/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html,2,['log'],['logger']
Testability,". main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have slider",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:14208,log,logging,14208,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,4,['log'],['logging']
Testability,". qutip.about — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.about. Source code for qutip.about; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #######",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/about.html:163,Log,Log,163,docs/4.6/modules/qutip/about.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/about.html,1,['Log'],['Log']
Testability,". qutip.about — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.about. Source code for qutip.about; """"""; Command line output of information on QuTiP and dependencies.; """"""; __all__ = ['about']. import sys; import os; import platform; import numpy; import scipy; import inspect; from qutip.utilities import _blas_info, available_cpu_count; import qutip.settings. [docs]def about():; """"""; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib.; """"""; print(""""); print(""QuTiP: Quantum Toolbox in Python""); print(""================================""); print(""Copyright (c) QuTiP team 2011 and later.""); print(; ""Current admin team: Alexander Pitchford, ""; ""Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, ""; ""Boxi Li, Jake Lishman, Simon Cross and Asier Galicia.""; ); print(; ""Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, ""; ""Franco Nori and Will Zeng.""; ); print(""Original developers: R. J. Johansson & P. D. Nation.""); print(""Previous lead developers: Chris Granade & A. Grimsmo.""); print(""Currently developed through wide collaboration. ""; ""See https://github.com/qutip for details.""); print(""""); print(""QuTiP Version: %s"" % qutip.__version__); print(""Numpy Version: %s"" % numpy.__version__); print(""Scipy Version: %s"" % scipy.__version__); try:; import Cython; cython_ver = Cython.__version__; except ImportError:; cython_ver = 'None'; print(""Cython Version: %s"" % cython_ver); try:; import matplotlib; matplotlib_ver = matplotlib.__version__; except ImportError:; matplotlib_ver = 'None'; print(""Matplotlib Version: %s"" % matplotlib_ver); print(""Python Version: %d.%d.%d"" % sys.version_info[0:3]); print(""Number of CPUs: %s"" % available_cpu_count()); print(""BLAS Info: %s"" % _blas_info());",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/about.html:163,Log,Log,163,docs/4.7/modules/qutip/about.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/about.html,1,['Log'],['Log']
Testability,". qutip.bloch — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch. Source code for qutip.bloch; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #######",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/bloch.html:163,Log,Log,163,docs/4.6/modules/qutip/bloch.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch.html,1,['Log'],['Log']
Testability,". qutip.bloch — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch. Source code for qutip.bloch; __all__ = ['Bloch']. import os. from numpy import (ndarray, array, linspace, pi, outer, cos, sin, ones, size,; sqrt, real, mod, append, ceil, arange); import numpy as np. from packaging.version import parse as parse_version. from qutip.qobj import Qobj; from qutip.expect import expect; from qutip.operators import sigmax, sigmay, sigmaz. try:; import matplotlib; import matplotlib.pyplot as plt; from mpl_toolkits.mplot3d import Axes3D; from matplotlib.patches import FancyArrowPatch; from mpl_toolkits.mplot3d import proj3d. # Define a custom _axes3D function based on the matplotlib version.; # The auto_add_to_figure keyword is new for matplotlib>=3.4.; if parse_version(matplotlib.__version__) >= parse_version('3.4'):; def _axes3D(fig, *args, **kwargs):; ax = Axes3D(fig, *args, auto_add_to_figure=False, **kwargs); return fig.add_axes(ax); else:; def _axes3D(*args, **kwargs):; return Axes3D(*args, **kwargs). class Arrow3D(FancyArrowPatch):; def __init__(self, xs, ys, zs, *args, **kwargs):; FancyArrowPatch.__init__(self, (0, 0), (0, 0), *args, **kwargs). self._verts3d = xs, ys, zs. def draw(self, renderer):; xs3d, ys3d, zs3d = self._verts3d; xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M). self.set_positions((xs[0], ys[0]), (xs[1], ys[1])); FancyArrowPatch.draw(self, renderer). def do_3d_projection(self, renderer=None):; # only called by matplotlib >= 3.5; xs3d, ys3d, zs3d = self._verts3d; xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M); self.set_positions((xs[0], ys[0]), (xs[1], ys[1])); return np.min(zs); except ImportError:; pass. try:; from IPython.display import display; except ImportError:; pass. [",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/bloch.html:163,Log,Log,163,docs/4.7/modules/qutip/bloch.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html,1,['Log'],['Log']
Testability,". qutip.bloch3d — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch3d. Source code for qutip.bloch3d; __all__ = ['Bloch3d']. import numpy as np; from qutip.qobj import Qobj; from qutip.expect import expect; from qutip.operators import sigmax, sigmay, sigmaz. [docs]class Bloch3d:; """"""Class for plotting data on a 3D Bloch sphere using mayavi.; Valid data can be either points, vectors, or qobj objects; corresponding to state vectors or density matrices. for; a two-state system (or subsystem). Attributes; ----------; fig : instance {None}; User supplied Matplotlib Figure instance for plotting Bloch sphere.; font_color : str {'black'}; Color of font used for Bloch sphere labels.; font_scale : float {0.08}; Scale for font used for Bloch sphere labels.; frame : bool {True}; Draw frame for Bloch sphere; frame_alpha : float {0.05}; Sets transparency of Bloch sphere frame.; frame_color : str {'gray'}; Color of sphere wireframe.; frame_num : int {8}; Number of frame elements to draw.; frame_radius : floats {0.005}; Width of wireframe.; point_color : list {['r', 'g', 'b', 'y']}; List of colors for Bloch sphere point markers to cycle through.; i.e. By default, points 0 and 4 will both be blue ('r').; point_mode : string {'sphere','cone','cube','cylinder','point'}; Point marker shapes.; point_size : float {0.075}; Size of points on Bloch sphere.; sphere_alpha : float {0.1}; Transparency of Bloch sphere itself.; sphere_color : str {'#808080'}; Color of Bloch sphere.; size : list {[500,500]}; Size of Bloch sphere plot in pixels. Best to have both numbers the same; otherwise you will have a Bloch sphere that looks like a football.; vector_color : list {['r', 'g', 'b', 'y']}; List of vector colors to cycle through.; vector_width : int {3}; Width",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/bloch3d.html:165,Log,Log,165,docs/4.7/modules/qutip/bloch3d.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch3d.html,1,['Log'],['Log']
Testability,". qutip.bloch_redfield — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch_redfield. Source code for qutip.bloch_redfield; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, QuSTaR; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #############",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:172,Log,Log,172,docs/4.6/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html,1,['Log'],['Log']
Testability,". qutip.bloch_redfield — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch_redfield. Source code for qutip.bloch_redfield; __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; import scipy.integrate; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.superoperator import spre, spost, vec2mat, mat2vec; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:172,Log,Log,172,docs/4.7/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html,1,['Log'],['Log']
Testability,". qutip.continuous_variables — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.continuous_variables. Source code for qutip.continuous_variables; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISE",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html:178,Log,Log,178,docs/4.6/modules/qutip/continuous_variables.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html,1,['Log'],['Log']
Testability,". qutip.continuous_variables — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.continuous_variables. Source code for qutip.continuous_variables; """"""; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields.; """""". __all__ = ['correlation_matrix', 'covariance_matrix',; 'correlation_matrix_field', 'correlation_matrix_quadrature',; 'wigner_covariance_matrix', 'logarithmic_negativity']. from qutip.expect import expect; import numpy as np. [docs]def correlation_matrix(basis, rho=None):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the correlation; matrix:. .. math::. C_{mn} = \langle a_m a_n \rangle. Parameters; ----------; basis : list; List of operators that defines the basis for the correlation matrix.; rho : Qobj; Density matrix for which to calculate the correlation matrix. If; `rho` is `None`, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns; -------; corr_mat : ndarray; A 2-dimensional *array* of correlation values or operators. """"""; if rho is None:; # return array of operators; out = np.empty((len(basis), len(basis)), dtype=object); for i, op2 in enumerate(basis):; out[i, :] = [op1 * op2 for op1 in basis]; return out; else:; # return array of expectation values; return np.array([[expect(op1 * op2, rho); for op1 in basis] for op2 in basis]). [docs]def covariance_matrix(basis, rho, symmetrized=True):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the covariance; matrix:. .. math::. V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle. or, if of the optional argument `symmetrized=False`,.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:178,Log,Log,178,docs/4.7/modules/qutip/continuous_variables.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html,1,['Log'],['Log']
Testability,". qutip.control.dump — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.dump. Source code for qutip.control.dump; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2016 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIB",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dump.html:170,Log,Log,170,docs/4.6/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html,1,['Log'],['Log']
Testability,". qutip.control.dump — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.dump. Source code for qutip.control.dump; # -*- coding: utf-8 -*-. """"""; Classes that enable the storing of historical objects created during the; pulse optimisation.; These are intented for debugging.; See the optimizer and dynamics objects for instrutcions on how to enable; data dumping.; """""". import os; import numpy as np; import copy; # QuTiP logging; import qutip.logging_utils; logger = qutip.logging_utils.get_logger('qutip.control.dump'); # QuTiP control modules; import qutip.control.io as qtrlio; from numpy.compat import asbytes. DUMP_DIR = ""~/.qtrl_dump"". def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Dump(object):; """"""; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes; ----------; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level : string; level of data dumping: SUMMARY, FULL or CUSTOM; See property docstring for details; Set automatically if dump is created by the setting host dumping attrib. write_to_file : bool; When set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/dump.html:667,log,logging,667,docs/4.7/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/dump.html,5,"['Log', 'log']","['Log', 'logger', 'logging']"
Testability,". qutip.control.dynamics — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.dynamics. Source code for qutip.control.dynamics; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED O",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:174,Log,Log,174,docs/4.6/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html,1,['Log'],['Log']
Testability,". qutip.control.dynamics — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.dynamics. Source code for qutip.control.dynamics; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes that define the dynamics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; from qutip.sparse import sp_eigs, eigh; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, bas",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/dynamics.html:174,Log,Log,174,docs/4.7/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/dynamics.html,1,['Log'],['Log']
Testability,". qutip.control.fidcomp — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.fidcomp. Source code for qutip.control.fidcomp; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:173,Log,Log,173,docs/4.6/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html,1,['Log'],['Log']
Testability,". qutip.control.fidcomp — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.fidcomp. Source code for qutip.control.fidcomp; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling wi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/fidcomp.html:173,Log,Log,173,docs/4.7/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/fidcomp.html,1,['Log'],['Log']
Testability,". qutip.control.optimizer — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISE",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:175,Log,Log,175,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,1,['Log'],['Log']
Testability,". qutip.control.optimizer — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the H",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/optimizer.html:175,Log,Log,175,docs/4.7/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/optimizer.html,1,['Log'],['Log']
Testability,". qutip.control.optimresult — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.optimresult. Source code for qutip.control.optimresult; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimresult.html:177,Log,Log,177,docs/4.6/modules/qutip/control/optimresult.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimresult.html,1,['Log'],['Log']
Testability,". qutip.control.optimresult — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.optimresult. Source code for qutip.control.optimresult; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[nu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/optimresult.html:177,Log,Log,177,docs/4.7/modules/qutip/control/optimresult.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/optimresult.html,1,['Log'],['Log']
Testability,". qutip.control.propcomp — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.propcomp. Source code for qutip.control.propcomp; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED O",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:174,Log,Log,174,docs/4.6/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html,1,['Log'],['Log']
Testability,". qutip.control.propcomp — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.propcomp. Source code for qutip.control.propcomp; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing lev",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/propcomp.html:174,Log,Log,174,docs/4.7/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/propcomp.html,1,['Log'],['Log']
Testability,". qutip.control.pulsegen — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.pulsegen. Source code for qutip.control.pulsegen; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED O",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:174,Log,Log,174,docs/4.6/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html,1,['Log'],['Log']
Testability,". qutip.control.pulsegen — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.pulsegen. Source code for qutip.control.pulsegen; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0. These are the periodic options. SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave. If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied over. """""". if pulse_type",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulsegen.html:878,log,logging,878,docs/4.7/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulsegen.html,7,"['Log', 'log']","['Log', 'logger', 'logging']"
Testability,". qutip.control.pulseoptim — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.pulseoptim. Source code for qutip.control.pulseoptim; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADV",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:176,Log,Log,176,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['Log'],['Log']
Testability,". qutip.control.pulseoptim — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.pulseoptim. Source code for qutip.control.pulseoptim; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:176,Log,Log,176,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['Log'],['Log']
Testability,". qutip.control.stats — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.stats. Source code for qutip.control.stats; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POS",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/stats.html:171,Log,Log,171,docs/4.6/modules/qutip/control/stats.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html,1,['Log'],['Log']
Testability,". qutip.control.stats — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.stats. Source code for qutip.control.stats; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute : float; Total wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/stats.html:171,Log,Log,171,docs/4.7/modules/qutip/control/stats.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/stats.html,1,['Log'],['Log']
Testability,". qutip.control.termcond — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.termcond. Source code for qutip.control.termcond; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED O",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/termcond.html:174,Log,Log,174,docs/4.6/modules/qutip/control/termcond.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/termcond.html,1,['Log'],['Log']
Testability,". qutip.control.termcond — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.termcond. Source code for qutip.control.termcond; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/termcond.html:174,Log,Log,174,docs/4.7/modules/qutip/control/termcond.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/termcond.html,1,['Log'],['Log']
Testability,". qutip.control.tslotcomp — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.tslotcomp. Source code for qutip.control.tslotcomp; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISE",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:175,Log,Log,175,docs/4.6/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html,1,['Log'],['Log']
Testability,". qutip.control.tslotcomp — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.tslotcomp. Source code for qutip.control.tslotcomp; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/tslotcomp.html:175,Log,Log,175,docs/4.7/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/tslotcomp.html,1,['Log'],['Log']
Testability,". qutip.correlation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.correlation. Source code for qutip.correlation; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUC",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:169,Log,Log,169,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,1,['Log'],['Log']
Testability,". qutip.correlation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.correlation. Source code for qutip.correlation; __all__ = ['correlation_2op_1t', 'correlation_2op_2t', 'correlation_3op_1t',; 'correlation_3op_2t', 'coherence_function_g1',; 'coherence_function_g2', 'spectrum', 'spectrum_correlation_fft',; 'correlation_ss', 'correlation', 'correlation_4op_1t',; 'correlation_4op_2t', 'spectrum_ss', 'spectrum_pi']. from re import sub; from warnings import warn; import warnings; import types. import numpy as np; import scipy.fftpack. from qutip.eseries import esval, esspec; from qutip.essolve import ode2es; from qutip.expect import expect; from qutip.mesolve import mesolve; from qutip.mcsolve import mcsolve; from qutip.operators import qeye; from qutip.qobj import Qobj, isket, issuper; from qutip.qobjevo import QobjEvo; from qutip.rhs_generate import rhs_clear, _td_wrap_array_str; from qutip.cy.utilities import _cython_build_cleanup; from qutip.settings import debug; from qutip.solver import Options, config; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.superoperator import liouvillian, spre, mat2vec; from qutip.tensor import tensor. if debug:; import inspect. # -----------------------------------------------------------------------------; # PUBLIC API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along one time axis using the quantum regression theorem and the evolution; solver indicated by t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/correlation.html:169,Log,Log,169,docs/4.7/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html,1,['Log'],['Log']
Testability,". qutip.dimensions — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.dimensions. Source code for qutip.dimensions; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH D",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/dimensions.html:168,Log,Log,168,docs/4.6/modules/qutip/dimensions.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/dimensions.html,1,['Log'],['Log']
Testability,". qutip.dimensions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.dimensions. Source code for qutip.dimensions; """"""; Internal use module for manipulating dims specifications.; """""". __all__ = [] # Everything should be explicitly imported, not made available; # by default. import numpy as np; from operator import getitem; from functools import partial. [docs]def is_scalar(dims):; """"""; Returns True if a dims specification is effectively; a scalar (has dimension 1).; """"""; return np.prod(flatten(dims)) == 1. def is_vector(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], (int, np.integer)); ). def is_vectorized_oper(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], list); ). def type_from_dims(dims, enforce_square=False):; bra_like, ket_like = map(is_scalar, dims). if bra_like:; if is_vector(dims[1]):; return 'bra'; elif is_vectorized_oper(dims[1]):; return 'operator-bra'. if ket_like:; if is_vector(dims[0]):; return 'ket'; elif is_vectorized_oper(dims[0]):; return 'operator-ket'. elif is_vector(dims[0]) and (dims[0] == dims[1] or not enforce_square):; return 'oper'. elif (; is_vectorized_oper(dims[0]) and; (; (; dims[0] == dims[1] and; dims[0][0] == dims[1][0]; ) or not enforce_square; ); ):; return 'super'. return 'other'. [docs]def flatten(l):; """"""Flattens a list of lists to the first level. Given a list containing a mix of scalars and lists,; flattens down to a list of the scalars within the original; list. Examples; --------. >>> flatten([[[0], 1], 2]) # doctest: +SKIP; [0, 1, 2]. """"""; if not isinstance(l, list):; return [l]; else:; return sum(map(flatten, l), []). [docs]def deep_remove(l, *what):; """"""Removes scalars from all levels of a nested list. Given a list containing a mix of scalars and li",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/dimensions.html:168,Log,Log,168,docs/4.7/modules/qutip/dimensions.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/dimensions.html,1,['Log'],['Log']
Testability,". qutip.distributions — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.distributions. Source code for qutip.distributions; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/distributions.html:171,Log,Log,171,docs/4.6/modules/qutip/distributions.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/distributions.html,1,['Log'],['Log']
Testability,". qutip.distributions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.distributions. Source code for qutip.distributions; """"""; This module provides classes and functions for working with spatial; distributions, such as Wigner distributions, etc. .. note::. Experimental. """""". __all__ = ['Distribution', 'WignerDistribution', 'QDistribution',; 'TwoModeQuadratureCorrelation',; 'HarmonicOscillatorWaveFunction',; 'HarmonicOscillatorProbabilityFunction']. import numpy as np; from numpy import pi, exp, sqrt. from scipy.special import hermite, factorial. from qutip.qobj import isket; from qutip.wigner import wigner, qfunc; from qutip.states import ket2dm, state_number_index. try:; import matplotlib as mpl; import matplotlib.pyplot as plt; from mpl_toolkits.mplot3d import Axes3D; except:; pass. [docs]class Distribution:; """"""A class for representation spatial distribution functions. The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far). It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters; ----------; data : array_like; Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs.; xvecs : list; List of arrays that spans the space for each coordinate.; xlabels : list; List of labels for each coordinate. """""". def __init__(self, data=None, xvecs=[], xlabels=[]):; self.data = data; self.xvecs = xvecs; self.xlabels = xlabels. [docs] def visualize(self, fig=None, ax=None, figsize=(8, 6),; colorbar=True, cmap=None, styl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/distributions.html:171,Log,Log,171,docs/4.7/modules/qutip/distributions.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html,1,['Log'],['Log']
Testability,". qutip.entropy — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.entropy. Source code for qutip.entropy; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/entropy.html:165,Log,Log,165,docs/4.6/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html,1,['Log'],['Log']
Testability,". qutip.entropy — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.entropy. Source code for qutip.entropy; __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/entropy.html:595,log,log,595,docs/4.7/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html,5,"['Log', 'log']","['Log', 'log', 'logarithm']"
Testability,". qutip.eseries — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.eseries. Source code for qutip.eseries; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/eseries.html:165,Log,Log,165,docs/4.6/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/eseries.html,1,['Log'],['Log']
Testability,". qutip.eseries — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.eseries. Source code for qutip.eseries; __all__ = ['eseries', 'esval', 'esspec', 'estidy']. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj. import warnings. [docs]class eseries():; """"""; Class representation of an exponential-series expansion of; time-dependent quantum objects. .. deprecated:: 4.6.0; :obj:`~eseries` will be removed in QuTiP 5.; Please use :obj:`~qutip.QobjEvo` for general time-dependence. Attributes; ----------; ampl : ndarray; Array of amplitudes for exponential series.; rates : ndarray; Array of rates for exponential series.; dims : list; Dimensions of exponential series components; shape : list; Shape corresponding to exponential series components. Methods; -------; value(tlist); Evaluate an exponential series at the times listed in tlist; spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist.; tidyup(); Returns a tidier version of the exponential series. """"""; __array_priority__ = 101. def __init__(self, q=None, s=np.array([])):; warnings.warn(; ""eseries is to be removed in QuTiP 5.0,""; "" consider swapping to QobjEvo for general time dependence."",; DeprecationWarning, stacklevel=2,; ). if isinstance(s, (int, float, complex)):; s = np.array([s]). if q is None:; self.ampl = np.array([]); self.rates = np.array([]); self.dims = [[1, 1]]; self.shape = [1, 1]. elif (len(s) == 0):; if isinstance(q, eseries):; self.ampl = q.ampl; self.rates = q.rates; self.dims = q.dims; self.shape = q.shape; elif isinstance(q, (np.ndarray, list)):; num = len(q) # number of elements in q; if any([Qobj(x).shape != Qobj(q[0]).shape for x in q]):; raise TypeError('All amplitudes must have same dimension.'); self.ampl =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/eseries.html:165,Log,Log,165,docs/4.7/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/eseries.html,1,['Log'],['Log']
Testability,". qutip.essolve — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.essolve. Source code for qutip.essolve; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/essolve.html:165,Log,Log,165,docs/4.6/modules/qutip/essolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/essolve.html,1,['Log'],['Log']
Testability,". qutip.essolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.essolve. Source code for qutip.essolve; __all__ = ['essolve', 'ode2es']. import numpy as np; import scipy.linalg as la; import scipy.sparse as sp. from qutip.qobj import Qobj, issuper, isket, isoper; from qutip.eseries import eseries, estidy, esval; from qutip.expect import expect; from qutip.superoperator import liouvillian, mat2vec, vec2mat; from qutip.solver import Result; from qutip.operators import qzero. # Only used for deprecation warnings.; import functools; import warnings. def _deprecate(alternative):; def decorated(f):; message = (; f""{f.__name__} is to be removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolve` will be removed in QuTiP 5. Please use; :obj:`~qutip.sesolve` or :obj:`~qutip.mesolve` for general-purpose; integration of the Schroedinger/Lindblad master equation.; This will likely be faster than :obj:`~essolve` for you. Parameters; -------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/essolve.html:165,Log,Log,165,docs/4.7/modules/qutip/essolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html,1,['Log'],['Log']
Testability,". qutip.expect — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.expect. Source code for qutip.expect; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ####",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/expect.html:164,Log,Log,164,docs/4.6/modules/qutip/expect.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/expect.html,1,['Log'],['Log']
Testability,". qutip.expect — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.expect. Source code for qutip.expect; __all__ = ['expect', 'variance']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj, isoper; from qutip.eseries import eseries; from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi, cy_spmm_tr,; expect_csr_ket). expect_rho_vec = cy_expect_rho_vec; expect_psi = cy_expect_psi. [docs]def expect(oper, state):; '''Calculates the expectation value for operator(s) and state(s). Parameters; ----------; oper : qobj/array-like; A single or a `list` or operators for expectation value. state : qobj/array-like; A single or a `list` of quantum states or density matrices. Returns; -------; expt : float/complex/array-like; Expectation value. ``real`` if `oper` is Hermitian, ``complex``; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Examples; --------; >>> expect(num(4), basis(4, 3)) == 3 # doctest: +NORMALIZE_WHITESPACE; True. '''; if isinstance(state, Qobj) and isinstance(oper, Qobj):; return _single_qobj_expect(oper, state). elif isinstance(oper, Qobj) and isinstance(state, eseries):; return _single_eseries_expect(oper, state). elif isinstance(oper, (list, np.ndarray)):; if isinstance(state, Qobj):; if (all([op.isherm for op in oper]) and; (state.isket or state.isherm)):; return np.array([_single_qobj_expect(o, state) for o in oper]); else:; return np.array([_single_qobj_expect(o, state) for o in oper],; dtype=complex); else:; return [expect(o, state) for o in oper]. elif isinstance(state, (list, np.ndarray)):; if oper.isherm and all([(op.isherm or op.type == 'ket'); for op in state]):; return np.array([_single_qobj_expect(oper, x) for x in state]); else:; return np.ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/expect.html:164,Log,Log,164,docs/4.7/modules/qutip/expect.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/expect.html,1,['Log'],['Log']
Testability,". qutip.fileio — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.fileio. Source code for qutip.fileio; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ####",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/fileio.html:164,Log,Log,164,docs/4.6/modules/qutip/fileio.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/fileio.html,1,['Log'],['Log']
Testability,". qutip.fileio — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.fileio. Source code for qutip.fileio; __all__ = ['file_data_store', 'file_data_read', 'qsave', 'qload']. import pickle; import numpy as np; import sys; from pathlib import Path. # -----------------------------------------------------------------------------; # Write matrix data to a file; #; [docs]def file_data_store(filename, data, numtype=""complex"", numformat=""decimal"",; sep="",""):; """"""Stores a matrix of data to a file to be read by an external program. Parameters; ----------; filename : str or pathlib.Path; Name of data file to be stored, including extension.; data: array_like; Data to be written to file.; numtype : str {'complex, 'real'}; Type of numerical data.; numformat : str {'decimal','exp'}; Format for written data.; sep : str; Single-character field seperator. Usually a tab, space, comma,; or semicolon. """"""; if filename is None or data is None:; raise ValueError(""filename or data is unspecified""). M, N = np.shape(data). f = open(filename, ""w""). f.write(""# Generated by QuTiP: %dx%d %s matrix "" % (M, N, numtype) +; ""in %s format ['%s' separated values].\n"" % (numformat, sep)). if numtype == ""complex"":. if numformat == ""exp"":. for m in range(M):; for n in range(N):; if np.imag(data[m, n]) >= 0.0:; f.write(""%.10e+%.10ej"" % (np.real(data[m, n]),; np.imag(data[m, n]))); else:; f.write(""%.10e%.10ej"" % (np.real(data[m, n]),; np.imag(data[m, n]))); if n != N - 1:; f.write(sep); f.write(""\n""). elif numformat == ""decimal"":. for m in range(M):; for n in range(N):; if np.imag(data[m, n]) >= 0.0:; f.write(""%.10f+%.10fj"" % (np.real(data[m, n]),; np.imag(data[m, n]))); else:; f.write(""%.10f%.10fj"" % (np.real(data[m, n]),; np.imag(data[m, n]))); if n != N - 1:; f.write(sep);",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/fileio.html:164,Log,Log,164,docs/4.7/modules/qutip/fileio.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/fileio.html,1,['Log'],['Log']
Testability,". qutip.floquet — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.floquet. Source code for qutip.floquet; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/floquet.html:165,Log,Log,165,docs/4.6/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html,1,['Log'],['Log']
Testability,". qutip.floquet — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.floquet. Source code for qutip.floquet; __all__ = ['floquet_modes', 'floquet_modes_t', 'floquet_modes_table',; 'floquet_modes_t_lookup', 'floquet_states', 'floquet_states_t',; 'floquet_wavefunction', 'floquet_wavefunction_t',; 'floquet_state_decomposition', 'fsesolve',; 'floquet_master_equation_rates', 'floquet_collapse_operators',; 'floquet_master_equation_tensor',; 'floquet_master_equation_steadystate', 'floquet_basis_transform',; 'floquet_markov_mesolve', 'fmmesolve']. import numpy as np; import scipy.linalg as la; import scipy; import warnings; from copy import copy; from numpy import angle, pi, exp, sqrt; from types import FunctionType; from qutip.qobj import Qobj, isket; from qutip.superoperator import vec2mat_index, mat2vec, vec2mat; #from qutip.mesolve import mesolve; from qutip.sesolve import sesolve; from qutip.rhs_generate import rhs_clear; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.states import projection; from qutip.solver import Options; from qutip.propagator import propagator; from qutip.solver import Result, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None, options=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:165,Log,Log,165,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,1,['Log'],['Log']
Testability,". qutip.graph — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.graph. Source code for qutip.graph; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #######",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/graph.html:163,Log,Log,163,docs/4.6/modules/qutip/graph.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/graph.html,1,['Log'],['Log']
Testability,". qutip.graph — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.graph. Source code for qutip.graph; """"""; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers.; """""". __all__ = ['graph_degree', 'column_permutation', 'breadth_first_search',; 'reverse_cuthill_mckee', 'maximum_bipartite_matching',; 'weighted_bipartite_matching']. import numpy as np; import scipy.sparse as sp; from qutip.cy.graph_utils import (; _breadth_first_search, _node_degrees,; _reverse_cuthill_mckee, _maximum_bipartite_matching,; _weighted_bipartite_matching); import warnings. def _deprecate():; warnings.warn((""qutip graph functions are deprecated.""; "" Consider using scipy.sparse.csgraph instead.""),; DeprecationWarning). [docs]def graph_degree(A):; """"""; Returns the degree for the nodes (rows) of a symmetric graph in sparse CSR; or CSC format, or a qobj. Parameters; ----------; A : qobj, csr_matrix, csc_matrix; Input quantum object or csr_matrix. Returns; -------; degree : array; Array of integers giving the degree for each node (row).; """"""; _deprecate(); if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A)):; raise TypeError('Input must be CSC or CSR sparse matrix.'); return np.asarray(_node_degrees(A.indices, A.indptr, A.shape[0])). [docs]def breadth_first_search(A, start):; """"""; Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting; from a given node (row). Takes Qobjs and CSR or CSC matrices as inputs. This function requires a matrix with symmetric structure. Use A+trans(A); if original matrix is not symmetric or not sure. Parameters; ----------; A : csc_matrix, csr_matrix; Input graph in CSC or CSR matrix format; start : int; Staring node for BFS traversal. Returns; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/graph.html:163,Log,Log,163,docs/4.7/modules/qutip/graph.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/graph.html,1,['Log'],['Log']
Testability,". qutip.interpolate — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.interpolate. Source code for qutip.interpolate; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ################################",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/interpolate.html:169,Log,Log,169,docs/4.6/modules/qutip/interpolate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/interpolate.html,1,['Log'],['Log']
Testability,". qutip.interpolate — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.interpolate. Source code for qutip.interpolate; import numpy as np; import scipy.linalg as la; from qutip.cy.interpolate import (interp, arr_interp,; zinterp, arr_zinterp). __all__ = ['Cubic_Spline']. [docs]class Cubic_Spline(object):; '''; Calculates coefficients for a cubic spline; interpolation of a given data set.; ; This function assumes that the data is sampled; uniformly over a given interval. Parameters; ----------; a : float; Lower bound of the interval.; b : float; Upper bound of the interval.; y : ndarray; Function values at interval points.; alpha : float; Second-order derivative at a. Default is 0.; beta : float; Second-order derivative at b. Default is 0.; ; Attributes; ----------; a : float; Lower bound of the interval.; b : float; Upper bound of the interval.; coeffs : ndarray; Array of coeffcients defining cubic spline.; ; Notes; -----; This object can be called like a normal function with a; single or array of input points at which to evaluate; the interplating function.; ; Habermann & Kindermann, ""Multidimensional Spline Interpolation: ; Theory and Applications"", Comput Econ 30, 153 (2007). ; ; '''; ; def __init__(self, a, b, y, alpha=0, beta=0):; y = np.asarray(y); n = y.shape[0] - 1; h = (b - a)/n. coeff = np.zeros(n + 3, dtype=y.dtype); # Solutions to boundary coeffcients of spline; coeff[1] = 1/6. * (y[0] - (alpha * h**2)/6) #C2 in paper; coeff[n + 1] = 1/6. * (y[n] - (beta * h**2)/6) #cn+2 in paper. # Compressed tridiagonal matrix ; ab = np.ones((3, n - 1), dtype=float); ab[0,0] = 0 # Because top row is upper diag with one less elem; ab[1, :] = 4; ab[-1,-1] = 0 # Because bottom row is lower diag with one less elem; ; B = y[1:-1].copy() #gr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/interpolate.html:169,Log,Log,169,docs/4.7/modules/qutip/interpolate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/interpolate.html,1,['Log'],['Log']
Testability,". qutip.ipynbtools — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.ipynbtools. Source code for qutip.ipynbtools; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH D",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:168,Log,Log,168,docs/4.6/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html,1,['Log'],['Log']
Testability,". qutip.ipynbtools — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.ipynbtools. Source code for qutip.ipynbtools; """"""; This module contains utility functions for using QuTiP with IPython notebooks.; """"""; from qutip.ui.progressbar import BaseProgressBar; from qutip.utilities import _blas_info, available_cpu_count; import IPython. #IPython parallel routines moved to ipyparallel in V4; #IPython parallel routines not in Anaconda by default; if IPython.version_info[0] >= 4:; try:; from ipyparallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']; else:; try:; from IPython.parallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']. from IPython.display import HTML, Javascript, display. import matplotlib.pyplot as plt; from matplotlib import animation; from base64 import b64encode. import datetime; import uuid; import sys; import os; import time; import inspect. import qutip; import numpy; import scipy; import Cython; import matplotlib; import IPython. [docs]def version_table(verbose=False):; """"""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns; --------; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. """""". html = ""<table>""; html += ""<tr><th>Software</th><th>Version</th></tr>""",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:168,Log,Log,168,docs/4.7/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html,1,['Log'],['Log']
Testability,". qutip.krylovsolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.krylovsolve. Source code for qutip.krylovsolve; __all__ = [""krylovsolve""]; """"""; This module provides approximations of the time evolution operator; using small dimensional Krylov subspaces.; """""". from scipy.optimize import root_scalar; from math import ceil; import numpy as np; import warnings. from qutip.expect import expect; from qutip.qobj import Qobj; from qutip.solver import Result, Options; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.sparse import eigh. [docs]def krylovsolve(; H: Qobj,; psi0: Qobj,; tlist: np.array,; krylov_dim: int,; e_ops=None,; options=None,; progress_bar: bool = None,; sparse: bool = False,; ):; """"""; Time evolution of state vectors for time independent Hamiltonians.; Evolve the state vector (""psi0"") finding an approximation for the time; evolution operator of Hamiltonian (""H"") by obtaining the projection of; the time evolution operator on a set of small dimensional Krylov; subspaces (m << dim(H)). The output is either the state vector or the expectation values of; supplied operators (""e_ops"") at arbitrary points at (""tlist""). **Additional options**. Additional options to krylovsolve can be set with the following:. * ""store_states"": stores states even though expectation values are; requested via the ""e_ops"" argument. * ""store_final_state"": store final state even though expectation values are; requested via the ""e_ops"" argument. Parameters; ----------; H : :class:`qutip.Qobj`; System Hamiltonian.; psi0 : :class: `qutip.Qobj`; Initial state vector (ket).; tlist : None / *list* / *array*; List of times on which to evolve the initial state. If None, nothing; happens but the code won't break.; krylov_dim: int",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:169,Log,Log,169,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,1,['Log'],['Log']
Testability,". qutip.lattice — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.lattice. Source code for qutip.lattice; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, The QuTiP Project.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ######################",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/lattice.html:165,Log,Log,165,docs/4.6/modules/qutip/lattice.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/lattice.html,1,['Log'],['Log']
Testability,". qutip.lattice — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.lattice. Source code for qutip.lattice; import numpy as np; from scipy.sparse import (csr_matrix). from qutip import (Qobj, tensor, basis, qeye, isherm, sigmax, sigmay, sigmaz). try:; import matplotlib.pyplot as plt; except ImportError:; pass. __all__ = ['Lattice1d', 'cell_structures']. [docs]def cell_structures(val_s=None, val_t=None, val_u=None):; """"""; Returns two matrices H_cell and cell_T to help the user form the inputs for; defining an instance of Lattice1d and Lattice2d classes. The two matrices; are the intra and inter cell Hamiltonians with the tensor structure of the; specified site numbers and/or degrees of freedom defined by the user. Parameters; ==========; val_s : list of str/str; The first list of str's specifying the sites/degrees of freedom in the; unitcell. val_t : list of str/str; The second list of str's specifying the sites/degrees of freedom in the; unitcell. val_u : list of str/str; The third list of str's specifying the sites/degrees of freedom in the; unitcell. Returns; -------; H_cell_s : list of list of str; tensor structure of the cell Hamiltonian elements; T_inter_cell_s : list of list of str; tensor structure of the inter cell Hamiltonian elements; H_cell : Qobj; A Qobj initiated with all 0s with proper shape for an input as; Hamiltonian_of_cell in Lattice1d.__init__(); T_inter_cell : Qobj; A Qobj initiated with all 0s with proper shape for an input as; inter_hop in Lattice1d.__init__(); """"""; Er0_str = ""At least one list of str necessary for using cell_structures!""; Er1_str = ""val_s is required to be a list of str's or a str""; Er2_str = ""val_t is required to be a list of str's or a str.""; Er3_str = ""val_u is required to be a list of str'",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/lattice.html:165,Log,Log,165,docs/4.7/modules/qutip/lattice.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/lattice.html,1,['Log'],['Log']
Testability,". qutip.matplotlib_utilities — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.matplotlib_utilities. Source code for qutip.matplotlib_utilities; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISE",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/matplotlib_utilities.html:178,Log,Log,178,docs/4.6/modules/qutip/matplotlib_utilities.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/matplotlib_utilities.html,1,['Log'],['Log']
Testability,". qutip.matplotlib_utilities — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.matplotlib_utilities. Source code for qutip.matplotlib_utilities; """"""; This module contains utility functions that enhance Matplotlib; in one way or another.; """""". __all__ = ['wigner_cmap', 'MidpointNorm', 'complex_phase_cmap']. import numpy as np. try:; import matplotlib as mpl; from matplotlib import cm; from matplotlib.colors import (Normalize, ColorConverter); except:; class Normalize(object):; def __init__(self, vmin=None, vmax=None, clip=False):; pass. [docs]def wigner_cmap(W, levels=1024, shift=0, max_color='#09224F',; mid_color='#FFFFFF', min_color='#530017',; neg_color='#FF97D4', invert=False):; """"""A custom colormap that emphasizes negative values by creating a; nonlinear colormap. Parameters; ----------; W : array; Wigner function array, or any array.; levels : int; Number of color levels to create.; shift : float; Shifts the value at which Wigner elements are emphasized.; This parameter should typically be negative and small (i.e -1e-5).; max_color : str; String for color corresponding to maximum value of data. Accepts; any string format compatible with the Matplotlib.colors.ColorConverter.; mid_color : str; Color corresponding to zero values. Accepts any string format; compatible with the Matplotlib.colors.ColorConverter.; min_color : str; Color corresponding to minimum data values. Accepts any string format; compatible with the Matplotlib.colors.ColorConverter.; neg_color : str; Color that starts highlighting negative values. Accepts any string; format compatible with the Matplotlib.colors.ColorConverter.; invert : bool; Invert the color scheme for negative values so that smaller negative; values have darker color. Returns; -------; Returns ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/matplotlib_utilities.html:178,Log,Log,178,docs/4.7/modules/qutip/matplotlib_utilities.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/matplotlib_utilities.html,1,['Log'],['Log']
Testability,". qutip.mcsolve — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.mcsolve. Source code for qutip.mcsolve; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:165,Log,Log,165,docs/4.6/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html,1,['Log'],['Log']
Testability,". qutip.mcsolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.mcsolve. Source code for qutip.mcsolve; __all__ = ['mcsolve']. import os; import numpy as np; from numpy.random import RandomState, randint; import scipy.sparse as sp; from scipy.integrate import ode; from scipy.integrate._ode import zvode. from types import FunctionType, BuiltinFunctionType; from functools import partial; from qutip.fastsparse import csr2fast; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.mcsolve import CyMcOde, CyMcOdeDiag; from qutip.cy.spconvert import dense1D_to_fastcsr_ket; from qutip.sesolve import sesolve; from qutip.solver import (Options, Result, ExpectOps,; solver_safe, SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:165,Log,Log,165,docs/4.7/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html,1,['Log'],['Log']
Testability,". qutip.measurement — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.measurement. Source code for qutip.measurement; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, The QuTiP Project; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###########",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/measurement.html:169,Log,Log,169,docs/4.6/modules/qutip/measurement.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/measurement.html,1,['Log'],['Log']
Testability,". qutip.measurement — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.measurement. Source code for qutip.measurement; """"""; Module for measuring quantum objects.; """""". import numpy as np; from qutip.qobj import Qobj; from qutip import identity; from qutip.qip.operations.gates import expand_operator. def _verify_input(op, state):; if not isinstance(op, Qobj):; raise TypeError(""op must be a Qobj""); if not op.isoper:; raise ValueError(""op must be all operators or all kets""); if not isinstance(state, Qobj):; raise TypeError(""state must be a Qobj""); if state.isket:; if op.dims[-1] != state.dims[0]:; raise ValueError(; ""op and state dims should be compatible when state is a ket""); elif state.isoper:; if op.dims != state.dims:; raise ValueError(; ""op and state dims should match""; "" when state is a density matrix""); else:; raise ValueError(""state must be a ket or a density matrix""). def _measurement_statistics_povm_ket(state, ops):; r""""""; Returns measurement statistics (resultant states and probabilities); for a measurements specified by a set of positive operator valued; measurements on a specified ket. Parameters; ----------; state : :class:`.Qobj` (ket); The ket specifying the state to measure. ops : list of :class:`.Qobj`; List of measurement operators :math:`M_i` (specifying a POVM such that; :math:`E_i = M_i^\dagger M_i`). Returns; -------; collapsed_states : list of :class:`.Qobj` (kets); The collapsed states (kets) obtained after measuring the qubits and; obtaining the qubit specified by the target in the state specified by; the index. probabilities : list of floats; The probability of measuring a state in a the state specified by the; index.; """"""; probabilities = []; collapsed_states = []. for i, op in enumerate(ops):; p = np.absol",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/measurement.html:169,Log,Log,169,docs/4.7/modules/qutip/measurement.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/measurement.html,1,['Log'],['Log']
Testability,". qutip.mesolve — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.mesolve. Source code for qutip.mesolve; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/mesolve.html:165,Log,Log,165,docs/4.6/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html,1,['Log'],['Log']
Testability,". qutip.mesolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.mesolve. Source code for qutip.mesolve; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve']. import numpy as np; import scipy.integrate; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, vec2mat, lindblad_dissipator; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, solver_safe, SolverSystem; from qutip.cy.spmatfuncs import spmv; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/mesolve.html:165,Log,Log,165,docs/4.7/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html,1,['Log'],['Log']
Testability,". qutip.metrics — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.metrics. Source code for qutip.metrics; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSI",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/metrics.html:165,Log,Log,165,docs/4.6/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html,1,['Log'],['Log']
Testability,". qutip.metrics — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.metrics. Source code for qutip.metrics; # -*- coding: utf-8 -*-. """"""; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators.; """""". __all__ = ['fidelity', 'tracedist', 'bures_dist', 'bures_angle',; 'hellinger_dist', 'hilbert_dist', 'average_gate_fidelity',; 'process_fidelity', 'unitarity', 'dnorm']. import numpy as np; from scipy import linalg as la; import scipy.sparse as sp; from qutip.sparse import sp_eigs; from qutip.states import ket2dm; from qutip.superop_reps import to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem, dnorm_sparse_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger('qutip.metrics'). try:; import cvxpy; except ImportError:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; if B.isket or B.isbra:; # The fidelity for pure states reduces to the modulus of their; # inner product.; return np.abs(A.overlap(B)); # Take advantage of the fact that the density operat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/metrics.html:165,Log,Log,165,docs/4.7/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html,1,['Log'],['Log']
Testability,". qutip.nonmarkov.bofin_baths — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.nonmarkov.bofin_baths. Source code for qutip.nonmarkov.bofin_baths; """"""; This module provides utilities for describing baths when using the; HEOM (hierarchy equations of motion) to model system-bath interactions. See the ``qutip.nonmarkov.bofin_solvers`` module for the associated solver. The implementation is derived from the BoFiN library (see; https://github.com/tehruhn/bofin) which was itself derived from an earlier; implementation in QuTiP itself.; """""". import enum. import numpy as np; from scipy.linalg import eigvalsh. from qutip.qobj import Qobj; from qutip.superoperator import spre, spost. [docs]class BathExponent:; """"""; Represents a single exponent (naively, an excitation mode) within the; decomposition of the correlation functions of a bath. Parameters; ----------; type : {""R"", ""I"", ""RI"", ""+"", ""-""} or BathExponent.ExponentType; The type of bath exponent. ""R"" and ""I"" are bosonic bath exponents that appear in the real and; imaginary parts of the correlation expansion. ""RI"" is combined bosonic bath exponent that appears in both the real; and imaginary parts of the correlation expansion. The combined exponent; has a single ``vk``. The ``ck`` is the coefficient in the real; expansion and ``ck2`` is the coefficient in the imaginary expansion. ""+"" and ""-"" are fermionic bath exponents. These fermionic bath; exponents must specify ``sigma_bar_k_offset`` which specifies; the amount to add to ``k`` (the exponent index within the bath of this; exponent) to determine the ``k`` of the corresponding exponent with; the opposite sign (i.e. ""-"" or ""+""). dim : int or None; The dimension (i.e. maximum number of excitations for this exponent).; Usually ``2`` for fe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:179,Log,Log,179,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,1,['Log'],['Log']
Testability,". qutip.nonmarkov.bofin_solvers — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.nonmarkov.bofin_solvers. Source code for qutip.nonmarkov.bofin_solvers; """"""; This module provides solvers for system-bath evoluation using the; HEOM (hierarchy equations of motion). See https://en.wikipedia.org/wiki/Hierarchical_equations_of_motion for a very; basic introduction to the technique. The implementation is derived from the BoFiN library (see; https://github.com/tehruhn/bofin) which was itself derived from an earlier; implementation in QuTiP itself.; """""". from copy import deepcopy. import numpy as np; import scipy.sparse as sp; import scipy.integrate; from scipy.sparse.linalg import spsolve. from qutip import settings; from qutip import state_number_enumerate; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.superoperator import liouvillian, spre, spost, vec2mat; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.solver import Options, Result; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.fastsparse import fast_identity, fast_csr_matrix; from qutip.nonmarkov.bofin_baths import (; BathExponent, DrudeLorentzBath,; ). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import mkl_spsolve; else:; mkl_spsolve = None. [docs]class HierarchyADOs:; """"""; A description of ADOs (auxilliary density operators) with the; hierarchical equations of motion. The list of ADOs is constructed from a list of bath exponents; (corresponding to one or more baths). Each ADO is referred to by a label; that lists the number of ""excitations"" of each bath exponent. The; level of a label within the hierarchy is the sum of the ""ex",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html:181,Log,Log,181,docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,1,['Log'],['Log']
Testability,". qutip.nonmarkov.dlheom_solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.nonmarkov.dlheom_solver. Source code for qutip.nonmarkov.dlheom_solver; """"""; This module provides exact solvers for a system-bath setup using the; hierarchy equations of motion (HEOM).; """""". # Authors: Neill Lambert, Anubhav Vardhan, Alexander Pitchford; # Contact: nwlambert@gmail.com. import timeit; import numpy as np; #from scipy.special import factorial; import scipy.sparse as sp; import scipy.integrate; from copy import copy; from qutip import Qobj, qeye; from qutip.states import enr_state_dictionaries; from qutip.superoperator import liouvillian, spre, spost; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.solver import Options, Result, Stats; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.heom import cy_pad_csr; from qutip.cy.spmath import zcsr_kron; from qutip.fastsparse import fast_csr_matrix, fast_identity. [docs]class HEOMSolver(object):; """"""; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve). This class should be treated as abstract. Currently the only subclass; implemented is t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/dlheom_solver.html:181,Log,Log,181,docs/4.7/modules/qutip/nonmarkov/dlheom_solver.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/dlheom_solver.html,1,['Log'],['Log']
Testability,". qutip.nonmarkov.heom — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.nonmarkov.heom. Source code for qutip.nonmarkov.heom; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson,; # Neill Lambert, Anubhav Vardhan, Alexander Pitchford.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE U",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:172,Log,Log,172,docs/4.6/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html,1,['Log'],['Log']
Testability,". qutip.nonmarkov.memorycascade — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.nonmarkov.memorycascade. Source code for qutip.nonmarkov.memorycascade; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2015 and later, Arne L. Grimsmo; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:181,Log,Log,181,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html,1,['Log'],['Log']
Testability,". qutip.nonmarkov.memorycascade — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.nonmarkov.memorycascade. Source code for qutip.nonmarkov.memorycascade; # -*- coding: utf-8 -*-. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/memorycascade.html:181,Log,Log,181,docs/4.7/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/memorycascade.html,1,['Log'],['Log']
Testability,". qutip.nonmarkov.transfertensor — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.nonmarkov.transfertensor. Source code for qutip.nonmarkov.transfertensor; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2015 and later, Arne L. Grimsmo; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, E",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:182,Log,Log,182,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html,1,['Log'],['Log']
Testability,". qutip.nonmarkov.transfertensor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.nonmarkov.transfertensor. Source code for qutip.nonmarkov.transfertensor; # -*- coding: utf-8 -*-; # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module contains an implementation of the non-Markovian transfer tensor; method (TTM), introduced in [1]. [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014); """""". import numpy as np. from qutip import (Options, spre, vector_to_operator, operator_to_vector,; ket2dm, isket); from qutip.solver import Result; from qutip.expect import expect_rho_vec. [docs]class TTMSolverOptions:; """"""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):; if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/transfertensor.html:182,Log,Log,182,docs/4.7/modules/qutip/nonmarkov/transfertensor.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/transfertensor.html,1,['Log'],['Log']
Testability,". qutip.operators — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.operators. Source code for qutip.operators; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMA",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/operators.html:167,Log,Log,167,docs/4.6/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html,1,['Log'],['Log']
Testability,". qutip.operators — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.operators. Source code for qutip.operators; """"""; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators.; """""". __all__ = ['jmat', 'spin_Jx', 'spin_Jy', 'spin_Jz', 'spin_Jm', 'spin_Jp',; 'spin_J_set', 'sigmap', 'sigmam', 'sigmax', 'sigmay', 'sigmaz',; 'destroy', 'create', 'qeye', 'identity', 'position', 'momentum',; 'num', 'squeeze', 'squeezing', 'displace', 'commutator',; 'qutrit_ops', 'qdiags', 'phase', 'qzero', 'enr_destroy',; 'enr_identity', 'charge', 'tunneling']. import numbers; import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.dimensions import flatten. #; # Spin operators; #; [docs]def jmat(j, *args):; """"""Higher-order spin operators:. Parameters; ----------; j : float; Spin of operator. args : str; Which operator to return 'x','y','z','+','-'.; If no args given, then output is ['x','y','z']. Returns; -------; jmat : qobj / ndarray; ``qobj`` for requested spin operator(s). Examples; --------; >>> jmat(1) # doctest: +SKIP; [ Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0. 0.70710678 0. ]; [ 0.70710678 0. 0.70710678]; [ 0. 0.70710678 0. ]]; Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.-0.70710678j 0.+0.j ]; [ 0.+0.70710678j 0.+0.j 0.-0.70710678j]; [ 0.+0.j 0.+0.70710678j 0.+0.j ]]; Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 1. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. -1.]]]. Notes; -----; If no 'args' input, then returns array of ['x','y','z'] ope",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/operators.html:167,Log,Log,167,docs/4.7/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/operators.html,1,['Log'],['Log']
Testability,". qutip.orbital — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.orbital. Source code for qutip.orbital; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/orbital.html:165,Log,Log,165,docs/4.6/modules/qutip/orbital.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/orbital.html,1,['Log'],['Log']
Testability,". qutip.orbital — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.orbital. Source code for qutip.orbital; __all__ = ['orbital']. import numpy as np; from scipy.special import sph_harm. [docs]def orbital(theta, phi, *args):; r""""""Calculates an angular wave function on a sphere.; ``psi = orbital(theta,phi,ket1,ket2,...)`` calculates; the angular wave function on a sphere at the mesh of points; defined by theta and phi which is; :math:`\sum_{lm} c_{lm} Y_{lm}(theta,phi)` where :math:`C_{lm}` are the; coefficients specified by the list of kets. Each ket has 2l+1 components; for some integer l. The first entry of the ket defines the coefficient; c_{l,-l}, while the last entry of the ket defines the; coefficient c_{l, l}. Parameters; ----------; theta : int/float/list/array; Polar angles in [0, pi]. phi : int/float/list/array; Azimuthal angles in [0, 2*pi]. args : list/array; ``list`` of ket vectors. Returns; -------; ``array`` for angular wave function evaluated at all; possible combinations of theta and phi. """"""; if isinstance(args[0], list):; # use the list in args[0]; args = args[0]. # convert to numpy array; theta = np.atleast_1d(theta); phi = np.atleast_1d(phi); # check that arrays are only 1D; if len(theta.shape) != 1:; raise ValueError('Polar angles theta must be 1D list'); if len(phi.shape) != 1:; raise ValueError('Azimuthal angles phi must be 1D list'). # make meshgrid; phi_mesh, theta_mesh = np.meshgrid(phi, theta); # setup empty wavefunction; psi = np.zeros([theta.shape[0], phi.shape[0]], dtype=complex); # iterate through provided kets; for k in range(len(args)):; ket = args[k]; if ket.type == 'bra':; ket = ket.conj(); elif not ket.type == 'ket':; raise TypeError('Invalid type for input ket in orbital'); # Extract l value from",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/orbital.html:165,Log,Log,165,docs/4.7/modules/qutip/orbital.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/orbital.html,1,['Log'],['Log']
Testability,". qutip.parallel — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.parallel. Source code for qutip.parallel; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/parallel.html:166,Log,Log,166,docs/4.6/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/parallel.html,1,['Log'],['Log']
Testability,". qutip.parallel — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.parallel. Source code for qutip.parallel; """"""; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing.; """"""; __all__ = ['parfor', 'parallel_map', 'serial_map']. from numpy import array; import multiprocessing; from functools import partial; import os; import sys; import signal; import qutip.settings as qset; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. if sys.platform == 'darwin':; Pool = multiprocessing.get_context('fork').Pool; else:; Pool = multiprocessing.Pool. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1, we recommend to use :func:`qutip.parallel.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/parallel.html:166,Log,Log,166,docs/4.7/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/parallel.html,1,['Log'],['Log']
Testability,". qutip.partial_transpose — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.partial_transpose. Source code for qutip.partial_transpose; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:175,Log,Log,175,docs/4.6/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html,1,['Log'],['Log']
Testability,". qutip.partial_transpose — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.partial_transpose. Source code for qutip.partial_transpose; __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.da",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:175,Log,Log,175,docs/4.7/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html,1,['Log'],['Log']
Testability,". qutip.piqs — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.piqs. Source code for qutip.piqs; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson,; # and the QuTiP Developers.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILIT",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/piqs.html:162,Log,Log,162,docs/4.6/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html,1,['Log'],['Log']
Testability,". qutip.piqs — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.piqs. Source code for qutip.piqs; """"""Permutational Invariant Quantum Solver (PIQS). This module calculates the Liouvillian for the dynamics of ensembles of; identical two-level systems (TLS) in the presence of local and collective; processes by exploiting permutational symmetry and using the Dicke basis.; It also allows to characterize nonlinear functions of the density matrix.; """""". # Authors: Nathan Shammah, Shahnawaz Ahmed; # Contact: nathan.shammah@gmail.com, shahnawaz.ahmed95@gmail.com. from math import factorial; from decimal import Decimal. import numpy as np; from scipy.integrate import odeint; from scipy.linalg import eigvalsh; from scipy.special import entr; from scipy.sparse import dok_matrix, block_diag, lil_matrix; from qutip.solver import Options, Result; from qutip import (; Qobj,; spre,; spost,; tensor,; identity,; ket2dm,; ); from qutip import sigmax, sigmay, sigmaz, sigmap, sigmam; from qutip.cy.piqs import Dicke as _Dicke; from qutip.cy.piqs import (; jmm1_dictionary,; _num_dicke_states,; _num_dicke_ladders,; get_blocks,; j_min,; j_vals,; ). __all__ = [; ""num_dicke_states"",; ""num_dicke_ladders"",; ""num_tls"",; ""isdiagonal"",; ""dicke_blocks"",; ""dicke_blocks_full"",; ""dicke_function_trace"",; ""purity_dicke"",; ""entropy_vn_dicke"",; ""Dicke"",; ""state_degeneracy"",; ""m_degeneracy"",; ""energy_degeneracy"",; ""ap"",; ""am"",; ""spin_algebra"",; ""jspin"",; ""collapse_uncoupled"",; ""dicke_basis"",; ""dicke"",; ""excited"",; ""superradiant"",; ""css"",; ""ghz"",; ""ground"",; ""identity_uncoupled"",; ""block_matrix"",; ""tau_column"",; ""Pim"",; ]. def _ensure_int(x):; """"""; Ensure that a floating-point value `x` is exactly an integer, and return it; as an int.; """"""; out = int(x); if out != x:; raise ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/piqs.html:162,Log,Log,162,docs/4.7/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/piqs.html,1,['Log'],['Log']
Testability,". qutip.propagator — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.propagator. Source code for qutip.propagator; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH D",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/propagator.html:168,Log,Log,168,docs/4.6/modules/qutip/propagator.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/propagator.html,1,['Log'],['Log']
Testability,". qutip.propagator — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.propagator. Source code for qutip.propagator; __all__ = ['propagator', 'propagator_steadystate']. import types; import numpy as np; import scipy.linalg as la; import functools; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.tensor import tensor; from qutip.operators import qeye; from qutip.rhs_generate import rhs_clear, _td_format_check; from qutip.superoperator import (vec2mat, mat2vec,; vector_to_operator, operator_to_vector); from qutip.sparse import sp_reshape; from qutip.cy.sparse_utils import unit_row_norm; from qutip.mesolve import mesolve; from qutip.sesolve import sesolve; from qutip.states import basis, projection; from qutip.solver import Options, _solver_safety_check, config; from qutip.parallel import parallel_map, _default_kwargs; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. [docs]def propagator(H, t, c_op_list=[], args={}, options=None,; unitary_mode='batch', parallel=False,; progress_bar=None, _safe_mode=True,; **kwargs):; r""""""; Calculate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)`; where :math:`\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback func",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/propagator.html:168,Log,Log,168,docs/4.7/modules/qutip/propagator.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/propagator.html,1,['Log'],['Log']
Testability,". qutip.qip.algorithms.qft — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.algorithms.qft. Source code for qutip.qip.algorithms.qft; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/algorithms/qft.html:176,Log,Log,176,docs/4.6/modules/qutip/qip/algorithms/qft.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/algorithms/qft.html,1,['Log'],['Log']
Testability,". qutip.qip.algorithms.qft — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.algorithms.qft. Source code for qutip.qip.algorithms.qft; """"""; This module provides the circuit implementation for Quantum Fourier Transform.; """""". import numpy as np; from qutip.qip.operations.gates import snot, cphase, swap; from qutip.qip.circuit import QubitCircuit; from qutip.qobj import Qobj. __all__ = ['qft', 'qft_steps', 'qft_gate_sequence']. [docs]def qft(N=1):; """"""; Quantum Fourier Transform operator on N qubits. Parameters; ----------; N : int; Number of qubits. Returns; -------; QFT: qobj; Quantum Fourier transform operator. """"""; if N < 1:; raise ValueError(""Minimum value of N can be 1""). N2 = 2 ** N; phase = 2.0j * np.pi / N2; arr = np.arange(N2); L, M = np.meshgrid(arr, arr); L = phase * (L * M); L = np.exp(L); dims = [[2] * N, [2] * N]; return Qobj(1.0 / np.sqrt(N2) * L, dims=dims). [docs]def qft_steps(N=1, swapping=True):; """"""; Quantum Fourier Transform operator on N qubits returning the individual; steps as unitary matrices operating from left to right. Parameters; ----------; N: int; Number of qubits.; swap: boolean; Flag indicating sequence of swap gates to be applied at the end or not. Returns; -------; U_step_list: list of qobj; List of Hadamard and controlled rotation gates implementing QFT. """"""; if N < 1:; raise ValueError(""Minimum value of N can be 1""). U_step_list = []; if N == 1:; U_step_list.append(snot()); else:; for i in range(N):; for j in range(i):; U_step_list.append(cphase(np.pi / (2 ** (i - j)), N,; control=i, target=j)); U_step_list.append(snot(N, i)); if swapping:; for i in range(N // 2):; U_step_list.append(swap(N, [N - i - 1, i])). return U_step_list. [docs]def qft_gate_sequence(N=1, swapping=True):; """"""; Quantum F",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/algorithms/qft.html:176,Log,Log,176,docs/4.7/modules/qutip/qip/algorithms/qft.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/algorithms/qft.html,1,['Log'],['Log']
Testability,". qutip.qip.circuit — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.circuit. Source code for qutip.qip.circuit; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in sourc e and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SU",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html:169,Log,Log,169,docs/4.6/modules/qutip/qip/circuit.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html,1,['Log'],['Log']
Testability,". qutip.qip.circuit — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.circuit. Source code for qutip.qip.circuit; from collections.abc import Iterable; from itertools import product; import numbers. import warnings; import inspect. import numpy as np; from copy import deepcopy. from qutip.qip import circuit_latex as _latex; from qutip.qip.operations.gates import (rx, ry, rz, sqrtnot, snot, phasegate,; x_gate, y_gate, z_gate, cy_gate,; cz_gate, s_gate, t_gate, cs_gate,; qasmu_gate, ct_gate, cphase, cnot,; csign, berkeley, swapalpha, swap,; iswap, sqrtswap, sqrtiswap, fredkin,; toffoli, controlled_gate, globalphase,; expand_operator, gate_sequence_product); from qutip import tensor, basis, identity, ket2dm; from qutip.qobj import Qobj; from qutip.measurement import measurement_statistics. try:; from IPython.display import Image as DisplayImage, SVG as DisplaySVG; except ImportError:; # If IPython doesn't exist, then we set the nice display hooks to be simple; # pass-throughs.; def DisplayImage(data, *args, **kwargs):; return data. def DisplaySVG(data, *args, **kwargs):; return data. __all__ = ['Gate', 'QubitCircuit', 'Measurement',; 'CircuitResult', 'CircuitSimulator']. _single_qubit_gates = [""RX"", ""RY"", ""RZ"", ""SNOT"", ""SQRTNOT"", ""PHASEGATE"",; ""X"", ""Y"", ""Z"", ""S"", ""T"", ""QASMU""]; _para_gates = [""RX"", ""RY"", ""RZ"", ""CPHASE"", ""SWAPalpha"", ""PHASEGATE"",; ""GLOBALPHASE"", ""CRX"", ""CRY"", ""CRZ"", ""QASMU""]; _ctrl_gates = [""CNOT"", ""CSIGN"", ""CRX"", ""CRY"", ""CRZ"", ""CY"", ""CZ"",; ""CS"", ""CT"", ""CPHASE""]; _swap_like = [""SWAP"", ""ISWAP"", ""SQRTISWAP"", ""SQRTSWAP"", ""BERKELEY"",; ""SWAPalpha""]; _toffoli_like = [""TOFFOLI""]; _fredkin_like = [""FREDKIN""]. [docs]class Gate:; """"""; Representation of a quantum gate, with its required parameters, and target; and control qub",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/circuit.html:169,Log,Log,169,docs/4.7/modules/qutip/qip/circuit.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/circuit.html,1,['Log'],['Log']
Testability,". qutip.qip.compiler.cavityqedcompiler — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.compiler.cavityqedcompiler. Source code for qutip.qip.compiler.cavityqedcompiler; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/cavityqedcompiler.html:188,Log,Log,188,docs/4.6/modules/qutip/qip/compiler/cavityqedcompiler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/cavityqedcompiler.html,1,['Log'],['Log']
Testability,". qutip.qip.compiler.cavityqedcompiler — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.compiler.cavityqedcompiler. Source code for qutip.qip.compiler.cavityqedcompiler; import numpy as np. from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.compiler import GateCompiler, Instruction. __all__ = ['CavityQEDCompiler']. [docs]class CavityQEDCompiler(GateCompiler):; """"""; Decompose a :class:`.QubitCircuit` into; the pulse sequence for the processor. Parameters; ----------; N: int; The number of qubits in the system. params: dict; A Python dictionary contains the name and the value of the parameters.; See :meth:`.DispersiveCavityQED.set_up_params` for the definition. global_phase: float, optional; Record of the global phase change and will be returned. pulse_dict: dict, optional; A map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; ``(pulse_label, coeff)``, instead of ``(pulse_index, coeff)``.; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer ``pulse_index`` needs to be used; in the compiling routine saved under the attributes ``gate_compiler``. Attributes; ----------; N: int; The number of the component systems. params: dict; A Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dict; A map between the pulse label and its index in the pulse list. gate_compiler: dict; The Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate.; """"""; def __init__(self, N, params, pulse_dict, global_phase=0.):; super(CavityQEDCompiler, self).__init__(; N=N, params=params, pulse_dict=pulse_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/cavityqedcompiler.html:188,Log,Log,188,docs/4.7/modules/qutip/qip/compiler/cavityqedcompiler.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/cavityqedcompiler.html,1,['Log'],['Log']
Testability,". qutip.qip.compiler.gatecompiler — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.compiler.gatecompiler. Source code for qutip.qip.compiler.gatecompiler; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:183,Log,Log,183,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,1,['Log'],['Log']
Testability,". qutip.qip.compiler.gatecompiler — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.compiler.gatecompiler. Source code for qutip.qip.compiler.gatecompiler; import numpy as np; from .instruction import Instruction; from .scheduler import Scheduler; from ..circuit import QubitCircuit, Gate. __all__ = ['GateCompiler']. [docs]class GateCompiler(object):; """"""; Base class. It compiles a :class:`.QubitCircuit` into; the pulse sequence for the processor. The core member function; `compile` calls compiling method from the sub-class and concatenate; the compiled pulses. Parameters; ----------; N: int; The number of the component systems. params: dict, optional; A Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optional; A map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; ``(pulse_label, coeff)``, instead of ``(pulse_index, coeff)``.; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer ``pulse_index`` needs to be used; in the compiling routine saved under the attributes ``gate_compiler``. Attributes; ----------; gate_compiler: dict; The Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dict; Arguments for individual compiling routines.; It adds more flexibility in customizing compiler.; """"""; def __init__(self, N, params=None, pulse_dict=None):; self.gate_compiler = {}; self.N = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/gatecompiler.html:183,Log,Log,183,docs/4.7/modules/qutip/qip/compiler/gatecompiler.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/gatecompiler.html,1,['Log'],['Log']
Testability,". qutip.qip.compiler.instruction — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.compiler.instruction. Source code for qutip.qip.compiler.instruction; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EV",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/instruction.html:182,Log,Log,182,docs/4.6/modules/qutip/qip/compiler/instruction.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/instruction.html,1,['Log'],['Log']
Testability,". qutip.qip.compiler.instruction — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.compiler.instruction. Source code for qutip.qip.compiler.instruction; from copy import deepcopy; import numpy as np. __all__ = ['Instruction']. [docs]class Instruction():; """"""; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters; ----------; gate: :class:`.Gate`; The quantum gate.; duration: list, optional; The execution time needed for the instruction.; tlist: array_like, optional; A list of time at which the time-dependent coefficients are; applied. See :class:`.Pulse` for detailed information`; pulse_info: list, optional; A list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes; ----------; targets: list, optional; The target qubits.; controls: list, optional; The control qubits.; used_qubits: set; Union of the control and target qubits.; """"""; def __init__(; self, gate, tlist=None,; pulse_info=(), duration=1):; self.gate = deepcopy(gate); self.used_qubits = set(); if self.targets is not None:; self.targets.sort() # Used when comparing the instructions; self.used_qubits |= set(self.targets); if self.controls is not None:; self.controls.sort(); self.used_qubits |= set(self.controls); self.tlist = tlist; if self.tlist is not None:; if np.isscalar(self.tlist):; self.duration = self.tlist; elif abs(self.tlist[0]) > 1.e-8:; raise ValueError(""Pulse time sequence must start from 0""); else:; self.duration = self.tlist[-1]; else:; self.duration = duration; self.pulse_info = pulse_info. @property; def name(self):; return self.gate.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/instruction.html:182,Log,Log,182,docs/4.7/modules/qutip/qip/compiler/instruction.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/instruction.html,1,['Log'],['Log']
Testability,". qutip.qip.compiler.scheduler — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.compiler.scheduler. Source code for qutip.qip.compiler.scheduler; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:180,Log,Log,180,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,1,['Log'],['Log']
Testability,". qutip.qip.compiler.scheduler — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.compiler.scheduler. Source code for qutip.qip.compiler.scheduler; from collections import deque; from copy import deepcopy; from functools import cmp_to_key; from random import shuffle. from ..circuit import QubitCircuit, Gate; from .instruction import Instruction. class InstructionsGraph():; """"""; A directed acyclic graph (DAG) representation; of the quantum instruction dependency.; An example is Fig3(b) in https://doi.org/10.1117/12.666419.; It contains methods of generating the instruction dependency graph,; a list-schedule algorithm to find the topological order; and the computation of the distance in the weighted graph; (circuit latency). It uses the `Instruction` object as a representation of node; and adds the following attributes to it:. predecessors, successors: dependency arrow of the DAG; distance_to_start, distance_to_end: longest distance to the start and end. Parameters; ----------; instructions: list; A list of instructions. Attributes; ----------; nodes: list; The input list of instruction with additional graph information.; start, end: list; List of indices of nodes connected to the start or end nodes.; """"""; def __init__(self, instructions):; instructions = deepcopy(instructions); self.nodes = []; for instruction in instructions:; if isinstance(instruction, Gate):; self.nodes.append(Instruction(instruction)); else:; self.nodes.append(instruction); for node in self.nodes:; if node.duration is None:; node.duration = 1; self.start = None; self.end = None. def generate_dependency_graph(self, commuting):; """"""; Generate the instruction dependency graph.; It modifies the class attribute `nodes`, where each element (node); is an `Instructio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/scheduler.html:180,Log,Log,180,docs/4.7/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/scheduler.html,1,['Log'],['Log']
Testability,". qutip.qip.compiler.spinchaincompiler — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.compiler.spinchaincompiler. Source code for qutip.qip.compiler.spinchaincompiler; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/spinchaincompiler.html:188,Log,Log,188,docs/4.6/modules/qutip/qip/compiler/spinchaincompiler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/spinchaincompiler.html,1,['Log'],['Log']
Testability,". qutip.qip.compiler.spinchaincompiler — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.compiler.spinchaincompiler. Source code for qutip.qip.compiler.spinchaincompiler; import numpy as np. from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.compiler import GateCompiler, Instruction. __all__ = ['SpinChainCompiler']. [docs]class SpinChainCompiler(GateCompiler):; """"""; Compile a :class:`.QubitCircuit` into; the pulse sequence for the processor. Parameters; ----------; N: int; The number of qubits in the system. params: dict; A Python dictionary contains the name and the value of the parameters.; See :meth:`.SpinChain.set_up_params` for the definition. setup: string; ""linear"" or ""circular"" for two sub-classes. global_phase: bool; Record of the global phase change and will be returned. pulse_dict: dict, optional; A map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; ``(pulse_label, coeff)``, instead of ``(pulse_index, coeff)``.; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer ``pulse_index`` needs to be used; in the compiling routine saved under the attributes ``gate_compiler``. Attributes; ----------; N: int; The number of the component systems. params: dict; A Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dict; A map between the pulse label and its index in the pulse list. gate_compiler: dict; The Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate. setup: string; ""linear"" or ""circular"" for two sub-classes. global_phase: bool; Record of the global phase chan",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/spinchaincompiler.html:188,Log,Log,188,docs/4.7/modules/qutip/qip/compiler/spinchaincompiler.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/spinchaincompiler.html,1,['Log'],['Log']
Testability,". qutip.qip.device.cavityqed — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.device.cavityqed. Source code for qutip.qip.device.cavityqed; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISE",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html:178,Log,Log,178,docs/4.6/modules/qutip/qip/device/cavityqed.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html,1,['Log'],['Log']
Testability,". qutip.qip.device.cavityqed — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.device.cavityqed. Source code for qutip.qip.device.cavityqed; import warnings; from copy import deepcopy. import numpy as np. from qutip.operators import tensor, identity, destroy, sigmax, sigmaz; from qutip.states import basis; from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.device.processor import Processor; from qutip.qip.device.modelprocessor import ModelProcessor; from qutip.qip.operations import expand_operator; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.qip.pulse import Pulse; from qutip.qip.compiler.gatecompiler import GateCompiler; from qutip.qip.compiler import CavityQEDCompiler. __all__ = ['DispersiveCavityQED']. [docs]class DispersiveCavityQED(ModelProcessor):; """"""; The processor based on the physical implementation of; a dispersive cavity QED system.; The available Hamiltonian of the system is predefined.; For a given pulse amplitude matrix, the processor can; calculate the state evolution under the given control pulse,; either analytically or numerically.; (Only additional attributes are documented here, for others please; refer to the parent class :class:`.ModelProcessor`). Parameters; ----------; N: int; The number of qubits in the system. correct_global_phase: float, optional; Save the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. num_levels: int, optional; The number of energy levels in the resonator. deltamax: int or list, optional; The coefficients of sigma-x for each of the qubits in the system. epsmax: int or list, optional; The coefficients of sigma-z for each of the qubits in the system. w0: int, optional; The ba",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/device/cavityqed.html:178,Log,Log,178,docs/4.7/modules/qutip/qip/device/cavityqed.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/device/cavityqed.html,1,['Log'],['Log']
Testability,". qutip.qip.device.modelprocessor — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.device.modelprocessor. Source code for qutip.qip.device.modelprocessor; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/modelprocessor.html:183,Log,Log,183,docs/4.6/modules/qutip/qip/device/modelprocessor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/modelprocessor.html,1,['Log'],['Log']
Testability,". qutip.qip.device.modelprocessor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.device.modelprocessor. Source code for qutip.qip.device.modelprocessor; from collections.abc import Iterable; import numbers. import numpy as np. from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.qip.operations.gates import globalphase; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.processor import Processor. __all__ = ['ModelProcessor']. [docs]class ModelProcessor(Processor):; """"""; The base class for a circuit processor simulating a physical device,; e.g cavityQED, spinchain.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It cannot be used alone, please refer to the sub-classes.; (Only additional attributes are documented here, for others please; refer to the parent class :class:`.Processor`). Parameters; ----------; N: int; The number of component systems. correct_global_phase: boolean, optional; If true, the analytical solution will track the global phase. It; has no effect on the numerical solution. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. Attributes; ----------; params: dict; A Python dictionary contains the name and the value of the parameters; in the physical realization, such as laser frequency, detuning etc. correct_global_phase: float; Save the global phase, the analytical solution; will track th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/device/modelprocessor.html:183,Log,Log,183,docs/4.7/modules/qutip/qip/device/modelprocessor.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/device/modelprocessor.html,1,['Log'],['Log']
Testability,". qutip.qip.device.optpulseprocessor — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.device.optpulseprocessor. Source code for qutip.qip.device.optpulseprocessor; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html:186,Log,Log,186,docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,1,['Log'],['Log']
Testability,". qutip.qip.device.optpulseprocessor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.device.optpulseprocessor. Source code for qutip.qip.device.optpulseprocessor; from collections.abc import Iterable; import warnings; import numbers. import numpy as np. from qutip.qobj import Qobj; import qutip.control.pulseoptim as cpo; from qutip.operators import identity; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.processor import Processor; from qutip.qip.operations.gates import gate_sequence_product. __all__ = ['OptPulseProcessor']. [docs]class OptPulseProcessor(Processor):; """"""; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; `qutip.control.optimize_pulse_unitary` function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using :func:`qutip.mesolve`.; (For attributes documentation, please; refer to the parent class :class:`.Processor`). Parameters; ----------; N: int; The number of component systems. drift: `:class:`qutip.Qobj`; The drift Hamiltonian. The size must match the whole quantum system. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. dims: list; The dimension of each component system.; Default value is a; qubit system of ``dim=[2,2,2,...,2]``; """"""; def __init__(self, N, drift=None, t1=None, t2=None, dims=None):; super(OptPulseProcessor, self).__init__(; N, t1=t1, t2=t2, dims=dims); if drift is not None:;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/device/optpulseprocessor.html:186,Log,Log,186,docs/4.7/modules/qutip/qip/device/optpulseprocessor.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/device/optpulseprocessor.html,1,['Log'],['Log']
Testability,". qutip.qip.device.processor — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.device.processor. Source code for qutip.qip.device.processor; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISE",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html:178,Log,Log,178,docs/4.6/modules/qutip/qip/device/processor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html,1,['Log'],['Log']
Testability,". qutip.qip.device.processor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.device.processor. Source code for qutip.qip.device.processor; from collections.abc import Iterable; import warnings; from copy import deepcopy. import numpy as np; from scipy.interpolate import CubicSpline. from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.operators import identity; from qutip.qip.operations.gates import expand_operator, globalphase; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.mcsolve import mcsolve; from qutip import Options; from qutip.qip.circuit import QubitCircuit; from qutip.qip.noise import (; Noise, RelaxationNoise, DecoherenceNoise,; ControlAmpNoise, RandomNoise, process_noise); from qutip.qip.pulse import Pulse, Drift, _merge_qobjevo, _fill_coeff. __all__ = ['Processor']. [docs]class Processor(object):; """"""; A simulator of a quantum device based on the QuTiP solver; :func:`qutip.mesolve`. It is defined by the available driving Hamiltonian; and the decoherence time for each component systems. The processor can; simulate the evolution under the given control pulses. Noisy evolution is; supported by :class:`.Noise` and can be added to the processor. Parameters; ----------; N: int; The number of component systems. t1: list or float, optional; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float, optional; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. dims: list, optional; The dimension of each component system.; Default value is a; qubit system of ``dim=[2,2,2,...,2]``. spline_kind: str, optional; Type of the coefficient interpolation",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/device/processor.html:178,Log,Log,178,docs/4.7/modules/qutip/qip/device/processor.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/device/processor.html,1,['Log'],['Log']
Testability,". qutip.qip.device.spinchain — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.device.spinchain. Source code for qutip.qip.device.spinchain; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISE",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html:178,Log,Log,178,docs/4.6/modules/qutip/qip/device/spinchain.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html,1,['Log'],['Log']
Testability,". qutip.qip.device.spinchain — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.device.spinchain. Source code for qutip.qip.device.spinchain; from copy import deepcopy. import numpy as np. from qutip.operators import sigmax, sigmay, sigmaz; from qutip.tensor import tensor; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.modelprocessor import ModelProcessor; from qutip.qip.pulse import Pulse; from qutip.qip.compiler.spinchaincompiler import SpinChainCompiler. __all__ = ['SpinChain', 'LinearSpinChain', 'CircularSpinChain']. [docs]class SpinChain(ModelProcessor):; """"""; The processor based on the physical implementation of; a spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It is a base class and should not be used directly, please; refer the the subclasses :class:`qutip.qip.device.LinearSpinChain` and; :class:`qutip.qip.device.CircularSpinChain`.; (Only additional attributes are documented here, for others please; refer to the parent class :class:`.ModelProcessor`). Parameters; ----------; N: int; The number of qubits in the system. correct_global_phase: float; Save the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or list; The delta for each of the qubits in the system. sz: int or list; The epsilon for each of the qubits in the system. sxsy: int or list; The interaction strength for each of the qubit pair in the system. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float; Characterize the decoherence o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/device/spinchain.html:178,Log,Log,178,docs/4.7/modules/qutip/qip/device/spinchain.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/device/spinchain.html,1,['Log'],['Log']
Testability,". qutip.qip.noise — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.noise. Source code for qutip.qip.noise; import numbers; from collections.abc import Iterable; from copy import deepcopy; import numpy as np. from qutip.qobjevo import QobjEvo; from qutip.qip.operations import expand_operator; from qutip.qobj import Qobj; from qutip.operators import sigmaz, destroy, num; from qutip.qip.pulse import Pulse. __all__ = [""Noise"", ""DecoherenceNoise"", ""RelaxationNoise"",; ""ControlAmpNoise"", ""RandomNoise"", ""process_noise""]. def process_noise(pulses, noise_list, dims, t1=None, t2=None,; device_noise=False):; """"""; Apply noise to the input list of pulses. It does not modify the input; pulse, but return a new one containing the noise. Parameters; ----------; pulses: list of :class:`.Pulse`; The input pulses, on which the noise object will be applied.; noise_list: list of :class:`.Noise`; A list of noise objects.; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems.; t1: list or float, optional; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits.; t2: list of float, optional; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits.; device_noise: bool; If pulse independent noise such as relaxation are included.; Default is False. Returns; -------; noisy_pulses: list of :class:`qutip.qip.Pulse`; The noisy pulses, including the system noise.; """"""; noisy_pulses = deepcopy(pulses); systematic_noise = Pulse(None, None, label=""systematic_noise""). if (t1 is not None) or (t2 is not None):; noise_list.append(RelaxationNoise(t1, t2)). for noise in noise_list:; if ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/noise.html:167,Log,Log,167,docs/4.6/modules/qutip/qip/noise.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/noise.html,1,['Log'],['Log']
Testability,". qutip.qip.noise — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.noise. Source code for qutip.qip.noise; import numbers; from collections.abc import Iterable; from copy import deepcopy; import numpy as np. from qutip.qobjevo import QobjEvo; from qutip.qip.operations import expand_operator; from qutip.qobj import Qobj; from qutip.operators import sigmaz, destroy, num; from qutip.qip.pulse import Pulse. __all__ = [""Noise"", ""DecoherenceNoise"", ""RelaxationNoise"",; ""ControlAmpNoise"", ""RandomNoise"", ""process_noise""]. def process_noise(pulses, noise_list, dims, t1=None, t2=None,; device_noise=False):; """"""; Apply noise to the input list of pulses. It does not modify the input; pulse, but return a new one containing the noise. Parameters; ----------; pulses: list of :class:`.Pulse`; The input pulses, on which the noise object will be applied.; noise_list: list of :class:`.Noise`; A list of noise objects.; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems.; t1: list or float, optional; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits.; t2: list of float, optional; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits.; device_noise: bool; If pulse independent noise such as relaxation are included.; Default is False. Returns; -------; noisy_pulses: list of :class:`qutip.qip.Pulse`; The noisy pulses, including the system noise.; """"""; noisy_pulses = deepcopy(pulses); systematic_noise = Pulse(None, None, label=""systematic_noise""). if (t1 is not None) or (t2 is not None):; noise_list.append(RelaxationNoise(t1, t2)). for ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/noise.html:167,Log,Log,167,docs/4.7/modules/qutip/qip/noise.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/noise.html,1,['Log'],['Log']
Testability,". qutip.qip.operations.gates — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.operations.gates. Source code for qutip.qip.operations.gates; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISE",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html:178,Log,Log,178,docs/4.6/modules/qutip/qip/operations/gates.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html,1,['Log'],['Log']
Testability,". qutip.qip.operations.gates — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.operations.gates. Source code for qutip.qip.operations.gates; import numbers; from collections.abc import Iterable; from itertools import product, chain; from functools import partial, reduce; from operator import mul. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.operators import identity, qeye, sigmax, sigmay, sigmaz; from qutip.tensor import tensor; from qutip.states import fock_dm. __all__ = ['rx', 'ry', 'rz', 'sqrtnot', 'snot', 'phasegate', 'qrot',; 'x_gate', 'y_gate', 'z_gate', 'cy_gate', 'cz_gate', 's_gate',; 't_gate', 'qasmu_gate', 'cs_gate', 'ct_gate', 'cphase', 'cnot',; 'csign', 'berkeley', 'swapalpha', 'swap', 'iswap', 'sqrtswap',; 'sqrtiswap', 'fredkin', 'molmer_sorensen',; 'toffoli', 'rotation', 'controlled_gate',; 'globalphase', 'hadamard_transform', 'gate_sequence_product',; 'gate_expand_1toN', 'gate_expand_2toN', 'gate_expand_3toN',; 'qubit_clifford_group', 'expand_operator']. #; # Single Qubit Gates; #. def x_gate(N=None, target=0):; """"""Pauli-X gate or sigmax operator. Returns; -------; result : :class:`qutip.Qobj`; Quantum object for operator describing; a single-qubit rotation through pi radians around the x-axis. """"""; if N is not None:; return gate_expand_1toN(x_gate(), N, target); return sigmax(). def y_gate(N=None, target=0):; """"""Pauli-Y gate or sigmay operator. Returns; -------; result : :class:`qutip.Qobj`; Quantum object for operator describing; a single-qubit rotation through pi radians around the y-axis. """"""; if N is not None:; return gate_expand_1toN(y_gate(), N, target); return sigmay(). def cy_gate(N=None, control=0, target=1):; """"""Controlled Y gate. Returns; -------; result : :cl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/operations/gates.html:178,Log,Log,178,docs/4.7/modules/qutip/qip/operations/gates.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/operations/gates.html,1,['Log'],['Log']
Testability,". qutip.qip.pulse — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.pulse. Source code for qutip.qip.pulse; import numpy as np; from scipy.interpolate import CubicSpline. from qutip.qobjevo import QobjEvo; from qutip.qobj import Qobj; from qutip.qip.operations import expand_operator; from qutip.operators import identity. __all__ = [""Pulse"", ""Drift""]. class _EvoElement():; """"""; The class object saving the information of one evolution element.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. For documentation and use instruction of the attributes, please; refer to :class:`.Pulse`.; """"""; def __init__(self, qobj, targets, tlist=None, coeff=None):; self.qobj = qobj; self.targets = targets; self.tlist = tlist; self.coeff = coeff. def get_qobj(self, dims):; """"""; Get the `Qobj` representation of the element. If `qobj` is None,; a zero :class:`qutip.Qobj` with the corresponding dimension is; returned. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobj: :class:`qutip.Qobj`; The operator of this element.; """"""; if isinstance(dims, (int, np.integer)):; dims = [2] * dims; if self.qobj is None:; qobj = identity(dims[0]) * 0.; targets = 0; else:; qobj = self.qobj; targets = self.targets; return expand_operator(qobj, len(dims), targets, dims). def _get_qobjevo_helper(self, spline_kind, dims):; """"""; Please refer to `_Evoelement.get_qobjevo` for documentation.; """"""; mat = self.get_qobj(dims); if self.tlist is None and self.coeff is None:; qu = QobjEvo(mat) * 0.; elif isinstance(self.coeff, bool):; if self.coeff:; if self.tlist is None:; qu = QobjEvo(mat, tlist=self.tl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:167,Log,Log,167,docs/4.6/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html,1,['Log'],['Log']
Testability,". qutip.qip.pulse — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.pulse. Source code for qutip.qip.pulse; import numpy as np; from scipy.interpolate import CubicSpline. from qutip.qobjevo import QobjEvo; from qutip.qobj import Qobj; from qutip.qip.operations import expand_operator; from qutip.operators import identity. __all__ = [""Pulse"", ""Drift""]. class _EvoElement():; """"""; The class object saving the information of one evolution element.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. For documentation and use instruction of the attributes, please; refer to :class:`.Pulse`.; """"""; def __init__(self, qobj, targets, tlist=None, coeff=None):; self.qobj = qobj; self.targets = targets; self.tlist = tlist; self.coeff = coeff. def get_qobj(self, dims):; """"""; Get the `Qobj` representation of the element. If `qobj` is None,; a zero :class:`qutip.Qobj` with the corresponding dimension is; returned. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobj: :class:`qutip.Qobj`; The operator of this element.; """"""; if isinstance(dims, (int, np.integer)):; dims = [2] * dims; if self.qobj is None:; qobj = identity(dims[0]) * 0.; targets = 0; else:; qobj = self.qobj; targets = self.targets; return expand_operator(qobj, len(dims), targets, dims). def _get_qobjevo_helper(self, spline_kind, dims):; """"""; Please refer to `_Evoelement.get_qobjevo` for documentation.; """"""; mat = self.get_qobj(dims); if self.tlist is None and self.coeff is None:; qu = QobjEvo(mat) * 0.; elif isinstance(self.coeff, bool):; if self.coeff:; if self.tlist is None:; qu = Q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/pulse.html:167,Log,Log,167,docs/4.7/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/pulse.html,1,['Log'],['Log']
Testability,". qutip.qip.qasm — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.qasm. Source code for qutip.qip.qasm; import re; import os; from itertools import chain; from copy import deepcopy; import warnings. from math import pi; import numpy as np. from qutip.qip.circuit import QubitCircuit; from qutip.qip.operations import (; controlled_gate, qasmu_gate, rz, snot, gate_sequence_product,; ). __all__ = [""read_qasm"", ""save_qasm"", ""print_qasm"", ""circuit_to_qasm_str""]. class QasmGate:; '''; Class which stores the gate definitions as specified in the QASM file.; '''. def __init__(self, name, gate_args, gate_regs):; self.name = name; self.gate_args = gate_args; self.gate_regs = gate_regs; self.gates_inside = []. def _get_qiskit_gates():; '''; Create and return a dictionary containing custom gates needed; for ""qiskit"" mode. These include a subset of gates usually defined; in the file ""qelib1.inc"". Returns a dictionary mapping gate names to QuTiP gates.; '''. def u2(args):; return qasmu_gate([np.pi/2, args[0], args[1]]). def id():; return qasmu_gate([0, 0, 0]). def sdg():; return rz(-1 * np.pi/2). def tdg():; return rz(-1 * np.pi/4). def cu3(args):; return controlled_gate(qasmu_gate(args)). def ch():; return controlled_gate(snot()). return {""ch"": ch, ""tdg"": tdg, ""id"": id, ""u2"": u2, ""sdg"": sdg, ""cu3"": cu3}. def _tokenize_line(command):; '''; Tokenize (break into several parts a string of) a single line of QASM code. Parameters; ----------; command : str; One line of QASM code to be broken into ""tokens"". Returns; -------; tokens : list of str; The tokens (parts) corresponding to the qasm line taken as input.; '''. # for gates without arguments; if ""("" not in command:; tokens = list(chain(*[a.split() for a in command.split("","")])); tokens = [token.strip() for token in to",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/qasm.html:166,Log,Log,166,docs/4.6/modules/qutip/qip/qasm.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/qasm.html,1,['Log'],['Log']
Testability,". qutip.qip.qasm — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.qasm. Source code for qutip.qip.qasm; import re; import os; from itertools import chain; from copy import deepcopy; import warnings. from math import pi; import numpy as np. from qutip.qip.circuit import QubitCircuit; from qutip.qip.operations import (; controlled_gate, qasmu_gate, rz, snot, gate_sequence_product,; ). __all__ = [""read_qasm"", ""save_qasm"", ""print_qasm"", ""circuit_to_qasm_str""]. class QasmGate:; '''; Class which stores the gate definitions as specified in the QASM file.; '''. def __init__(self, name, gate_args, gate_regs):; self.name = name; self.gate_args = gate_args; self.gate_regs = gate_regs; self.gates_inside = []. def _get_qiskit_gates():; '''; Create and return a dictionary containing custom gates needed; for ""qiskit"" mode. These include a subset of gates usually defined; in the file ""qelib1.inc"". Returns a dictionary mapping gate names to QuTiP gates.; '''. def u2(args):; return qasmu_gate([np.pi/2, args[0], args[1]]). def id():; return qasmu_gate([0, 0, 0]). def sdg():; return rz(-1 * np.pi/2). def tdg():; return rz(-1 * np.pi/4). def cu3(args):; return controlled_gate(qasmu_gate(args)). def ch():; return controlled_gate(snot()). return {""ch"": ch, ""tdg"": tdg, ""id"": id, ""u2"": u2, ""sdg"": sdg, ""cu3"": cu3}. def _tokenize_line(command):; '''; Tokenize (break into several parts a string of) a single line of QASM code. Parameters; ----------; command : str; One line of QASM code to be broken into ""tokens"". Returns; -------; tokens : list of str; The tokens (parts) corresponding to the qasm line taken as input.; '''. # for gates without arguments; if ""("" not in command:; tokens = list(chain(*[a.split() for a in command.split("","")])); tokens = [toke",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/qasm.html:166,Log,Log,166,docs/4.7/modules/qutip/qip/qasm.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/qasm.html,1,['Log'],['Log']
Testability,". qutip.qip.qubits — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.qubits. Source code for qutip.qip.qubits; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH D",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/qubits.html:168,Log,Log,168,docs/4.6/modules/qutip/qip/qubits.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/qubits.html,1,['Log'],['Log']
Testability,". qutip.qip.qubits — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.qubits. Source code for qutip.qip.qubits; __all__ = ['qubit_states']. from qutip.tensor import tensor; from numpy import sqrt; from qutip.states import basis. [docs]def qubit_states(N=1, states=[0]):; """"""; Function to define initial state of the qubits. Parameters; ----------; N : Integer; Number of qubits in the register.; states : List; Initial state of each qubit. Returns; ----------; qstates : Qobj; List of qubits. """"""; state_list = []; for i in range(N):; if N > len(states) and i >= len(states):; state_list.append(0); else:; state_list.append(states[i]). return tensor([alpha * basis(2, 1) + sqrt(1 - alpha**2) * basis(2, 0); for alpha in state_list]). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/qubits.html:168,Log,Log,168,docs/4.7/modules/qutip/qip/qubits.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/qubits.html,1,['Log'],['Log']
Testability,". qutip.qobj — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qobj. Source code for qutip.qobj; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ##########",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:162,Log,Log,162,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,1,['Log'],['Log']
Testability,". qutip.qobj — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qobj. Source code for qutip.qobj; """"""The Quantum Object (Qobj) class, for representing quantum states and; operators, and related functions.; """""". __all__ = ['Qobj', 'qobj_list_evaluate', 'ptrace', 'dag', 'isequal',; 'issuper', 'isoper', 'isoperket', 'isoperbra', 'isket', 'isbra',; 'isherm', 'shape', 'dims']. import warnings; import types; import numbers. try:; import builtins; except ImportError:; import __builtin__ as builtins. # import math functions from numpy.math: required for td string evaluation; from numpy import (arccos, arccosh, arcsin, arcsinh, arctan, arctan2, arctanh,; ceil, copysign, cos, cosh, degrees, e, exp, expm1, fabs,; floor, fmod, frexp, hypot, isinf, isnan, ldexp, log, log10,; log1p, modf, pi, radians, sin, sinh, sqrt, tan, tanh). import numpy as np; import scipy.sparse as sp; import qutip.settings as settings; from qutip import __version__; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.cy.ptrace import _ptrace; from qutip.permute import _permute; from qutip.dimensions import flatten; from qutip.sparse import (; sp_eigs, sp_expm, sp_fro_norm, sp_max_norm, sp_one_norm, sp_L2_norm,; ); from qutip.dimensions import (; type_from_dims, enumerate_flat, collapse_dims_super,; ); from qutip.cy.spmath import (; zcsr_transpose, zcsr_adjoint, zcsr_isherm, zcsr_trace, zcsr_proj,; zcsr_inner,; ); from qutip.cy.spmatfuncs import zcsr_mat_elem; from qutip.cy.sparse_utils import cy_tidyup; import sys; if sys.version_info.major >= 3:; from itertools import zip_longest; elif sys.version_info.major < 3:; from itertools import izip_longest; zip_longest = izip_longest. # OPENMP stuff; from qutip.cy.openmp.utilities import use_openmp; if settin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobj.html:999,log,log,999,docs/4.7/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html,3,"['Log', 'log']","['Log', 'log']"
Testability,". qutip.qobjevo — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qobjevo. Source code for qutip.qobjevo; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:165,Log,Log,165,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,1,['Log'],['Log']
Testability,". qutip.qobjevo — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qobjevo. Source code for qutip.qobjevo; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline, interp1d; from functools import partial; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import (_compile_str_single, _compiled_coeffs,; _compiled_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. if qset.has_cython:; import cython; use_cython = [True]; else:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:165,Log,Log,165,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,1,['Log'],['Log']
Testability,". qutip.random_objects — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.random_objects. Source code for qutip.random_objects; # -*- coding: utf-8 -*-; # The above line is so that UTF-8 comments won't break Py2. # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) AR",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/random_objects.html:172,Log,Log,172,docs/4.6/modules/qutip/random_objects.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/random_objects.html,1,['Log'],['Log']
Testability,". qutip.random_objects — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.random_objects. Source code for qutip.random_objects; # -*- coding: utf-8 -*-; """"""; This module is a collection of random state and operator generators.; The sparsity of the ouput Qobj's is controlled by varing the; `density` parameter.; """""". __all__ = [; 'rand_herm', 'rand_unitary', 'rand_ket', 'rand_dm',; 'rand_unitary_haar', 'rand_ket_haar', 'rand_dm_ginibre',; 'rand_dm_hs', 'rand_super_bcsz', 'rand_stochastic', 'rand_super'; ]. import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.operators import create, destroy, jmat; from qutip.states import basis; import qutip.superop_reps as sr. UNITS = np.array([1, 1j]). def rand_jacobi_rotation(A, seed=None):; """"""Random Jacobi rotation of a sparse matrix. Parameters; ----------; A : spmatrix; Input sparse matrix. Returns; -------; spmatrix; Rotated sparse matrix.; """"""; if seed is not None:; np.random.seed(seed=seed); if A.shape[0] != A.shape[1]:; raise ValueError('Input matrix must be square.'); n = A.shape[0]; angle = 2*np.random.random()*np.pi; a = 1.0/np.sqrt(2)*np.exp(-1j*angle); b = 1.0/np.sqrt(2)*np.exp(1j*angle); i = int(np.floor(np.random.random()*n)); j = i; while i == j:; j = int(np.floor(np.random.random()*n)); data = np.hstack((np.array([a, -b, a, b], dtype=complex),; np.ones(n-2, dtype=complex))); diag = np.delete(np.arange(n), [i, j]); rows = np.hstack(([i, i, j, j], diag)); cols = np.hstack(([i, j, i, j], diag)); R = sp.coo_matrix(; (data, (rows, cols)), shape=(n, n), dtype=complex,; ).tocsr(); A = R*A*R.conj().transpose(); return A. def randnz(shape, norm=1 / np.sqrt(2), seed=None):; # This function is intended for internal use.; """"""; Return",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/random_objects.html:172,Log,Log,172,docs/4.7/modules/qutip/random_objects.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/random_objects.html,1,['Log'],['Log']
Testability,". qutip.rhs_generate — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.rhs_generate. Source code for qutip.rhs_generate; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:170,Log,Log,170,docs/4.6/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html,1,['Log'],['Log']
Testability,". qutip.rhs_generate — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.rhs_generate. Source code for qutip.rhs_generate; __all__ = ['rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:170,Log,Log,170,docs/4.7/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html,1,['Log'],['Log']
Testability,". qutip.scattering — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.scattering. Source code for qutip.scattering; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH D",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/scattering.html:168,Log,Log,168,docs/4.6/modules/qutip/scattering.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/scattering.html,1,['Log'],['Log']
Testability,". qutip.scattering — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.scattering. Source code for qutip.scattering; """"""; Photon scattering in quantum optical systems. This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875).; """"""; # Author: Ben Bartlett; # Contact: benbartlett@stanford.edu. import numpy as np; from itertools import product, combinations_with_replacement; from qutip import propagator, Options, basis, tensor, zero_ket, Qobj. __all__ = ['temporal_basis_vector',; 'temporal_scattered_state',; 'scattering_probability']. class Evolver:; """"""; A caching class which takes a Hamiltonian and a list of times to calculate; and memoize propagators for the system between any two times as demanded. Parameters; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in `Qobj` or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and c_ops.; times : list-like; List of times to evaluate propagators over.; options : :class: qutip.Options; Solver options to use when computing propagators. Attributes; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian, may be time-dependent.; tlist : list-like; List of times to evaluate propagators over.; propagators : (dict of float: (dict of float: :class: qutip.Qobj)); Dictionary of dictionaries of propagator objects with keys of; evaluation times, e.g.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/scattering.html:168,Log,Log,168,docs/4.7/modules/qutip/scattering.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/scattering.html,1,['Log'],['Log']
Testability,". qutip.sesolve — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.sesolve. Source code for qutip.sesolve; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/sesolve.html:165,Log,Log,165,docs/4.6/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html,1,['Log'],['Log']
Testability,". qutip.sesolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.sesolve. Source code for qutip.sesolve; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; import numpy as np; import scipy.integrate; from scipy.linalg import norm as la_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` cannot be used in conjunction; with solving the Schrodinger opera",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/sesolve.html:165,Log,Log,165,docs/4.7/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html,1,['Log'],['Log']
Testability,". qutip.simdiag — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.simdiag. Source code for qutip.simdiag; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/simdiag.html:165,Log,Log,165,docs/4.6/modules/qutip/simdiag.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/simdiag.html,1,['Log'],['Log']
Testability,". qutip.simdiag — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.simdiag. Source code for qutip.simdiag; __all__ = ['simdiag']. import numpy as np; import scipy.linalg as la; from qutip.qobj import Qobj. def _degen(tol, vecs, ops, i=0):; """"""; Private function that finds eigen vals and vecs for degenerate matrices..; """"""; if len(ops) == i:; return vecs. # New eigenvectors are sometime not orthogonal.; for j in range(1, vecs.shape[1]):; for k in range(j):; dot = vecs[:, j].dot(vecs[:, k].conj()); if np.abs(dot) > tol:; vecs[:, j] = ((vecs[:, j] - dot * vecs[:, k]); / (1 - np.abs(dot)**2)**0.5). subspace = vecs.conj().T @ ops[i].data @ vecs; eigvals, eigvecs = la.eig(subspace). perm = np.argsort(eigvals); eigvals = eigvals[perm]. vecs_new = vecs @ eigvecs[:, perm]; for k in range(len(eigvals)):; vecs_new[:, k] = vecs_new[:, k] / la.norm(vecs_new[:, k]). k = 0; while k < len(eigvals):; ttol = max(tol, tol * abs(eigvals[k])); inds, = np.where(abs(eigvals - eigvals[k]) < ttol); if len(inds) > 1: # if at least 2 eigvals are degenerate; vecs_new[:, inds] = _degen(tol, vecs_new[:, inds], ops, i+1); k = inds[-1] + 1; return vecs_new. [docs]def simdiag(ops, evals: bool = True, *,; tol: float = 1e-14, safe_mode: bool = True):; """"""Simultaneous diagonalization of commuting Hermitian matrices. Parameters; ----------; ops : list/array; ``list`` or ``array`` of qobjs representing commuting Hermitian; operators. evals : bool [True]; Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tol : float [1e-14]; Tolerance for detecting degenerate eigenstates. safe_mode : bool [True]; Whether to check that all ops are Hermitian and commuting. If set to; ``False`` and operators are not commuting, the eigenvectors return",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/simdiag.html:165,Log,Log,165,docs/4.7/modules/qutip/simdiag.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/simdiag.html,1,['Log'],['Log']
Testability,". qutip.solver — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.solver. Source code for qutip.solver; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson,; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ####",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/solver.html:164,Log,Log,164,docs/4.6/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html,1,['Log'],['Log']
Testability,". qutip.solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.solver. Source code for qutip.solver; from __future__ import print_function. __all__ = ['Options', 'Odeoptions', 'Odedata', 'ExpectOps']. import os; import sys; import warnings; import datetime; import numpy as np; from qutip.qobjevo import QobjEvo; from collections import OrderedDict; from qutip import __version__; from qutip.qobj import Qobj; import qutip.settings as qset; from types import FunctionType, BuiltinFunctionType. solver_safe = {}. class SolverSystem():; pass. [docs]class ExpectOps:; """"""; Contain and compute expectation values; """"""; def __init__(self, e_ops=[], super_=False):; # take care of expectation values, if any; self.isfunc = False; self.e_ops_dict = False; self.raw_e_ops = e_ops; self.e_ops_qoevo = []; self.e_num = 0; self.e_ops_isherm = []. if isinstance(e_ops, (Qobj, QobjEvo)):; e_ops = [e_ops]; elif isinstance(e_ops, dict):; self.e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]. self.e_ops = e_ops; if isinstance(e_ops, list):; self.e_num = len(e_ops); e_ops_qoevo = []; e_ops_isherm = []; for e in e_ops:; if isinstance(e, (Qobj, QobjEvo)):; e_ops_isherm.append(e.isherm); e_ops_qoevo_entry = None; if not super_:; e_ops_qoevo_entry = QobjEvo(e); else:; e_ops_qoevo_entry = QobjEvo(spre(e)); e_ops_qoevo_entry.compile(); e_ops_qoevo.append(e_ops_qoevo_entry); elif callable(e):; e_ops_isherm.append(None); e_ops_qoevo.append(e); else:; raise TypeError(""Expectation value list entry needs to be ""; ""either a function either an operator""); self.e_ops_isherm = e_ops_isherm; self.e_ops_qoevo = np.array(e_ops_qoevo, dtype=object); elif callable(e_ops):; self.isfunc = True; self.e_num = 1. def init(self, tlist):; self.tlist = tlist; if self.isfunc:; sel",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/solver.html:164,Log,Log,164,docs/4.7/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html,1,['Log'],['Log']
Testability,". qutip.states — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.states. Source code for qutip.states; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ####",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/states.html:164,Log,Log,164,docs/4.6/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/states.html,1,['Log'],['Log']
Testability,". qutip.states — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.states. Source code for qutip.states; __all__ = ['basis', 'qutrit_basis', 'coherent', 'coherent_dm', 'fock_dm',; 'fock', 'thermal_dm', 'maximally_mixed_dm', 'ket2dm', 'projection',; 'qstate', 'ket', 'bra', 'state_number_enumerate',; 'state_number_index', 'state_index_number', 'state_number_qobj',; 'phase_basis', 'zero_ket', 'spin_state', 'spin_coherent',; 'bell_state', 'singlet_state', 'triplet_states', 'w_state',; 'ghz_state', 'enr_state_dictionaries', 'enr_fock',; 'enr_thermal_dm']. import numbers; import numpy as np; from numpy import arange, conj; import scipy.sparse as sp; import itertools. from qutip.qobj import Qobj; from qutip.operators import destroy, jmat; from qutip.tensor import tensor. from qutip.fastsparse import fast_csr_matrix. def _promote_to_zero_list(arg, length):; """"""; Ensure `arg` is a list of length `length`. If `arg` is None it is promoted; to `[0]*length`. All other inputs are checked that they match the correct; form. Returns; -------; list_ : list; A list of integers of length `length`.; """"""; if arg is None:; arg = [0]*length; elif not isinstance(arg, list):; arg = [arg]; if not len(arg) == length:; raise ValueError(""All list inputs must be the same length.""); if all(isinstance(x, numbers.Integral) for x in arg):; return arg; raise TypeError(""Dimensions must be an integer or list of integers.""). [docs]def basis(dimensions, n=None, offset=None):; """"""Generates the vector representation of a Fock state. Parameters; ----------; dimensions : int or list of ints; Number of Fock states in Hilbert space. If a list, then the resultant; object will be a tensor product over spaces with those dimensions. n : int or list of ints, optional (default 0 for a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/states.html:164,Log,Log,164,docs/4.7/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/states.html,1,['Log'],['Log']
Testability,". qutip.steadystate — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.steadystate. Source code for qutip.steadystate; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUC",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:169,Log,Log,169,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,1,['Log'],['Log']
Testability,". qutip.steadystate — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.steadystate. Source code for qutip.steadystate; """"""; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators.; """""". __all__ = ['steadystate', 'steady', 'steadystate_floquet',; 'build_preconditioner', 'pseudo_inverse']. import functools; import time; import warnings. from packaging.version import parse as _parse_version; import numpy as np; from numpy.linalg import svd; import scipy; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (; use_solver, splu, spilu, eigs, LinearOperator, gmres, lgmres, bicgstab,; ); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_profile; from qutip.cy.spmath import zcsr_kron; from qutip.graph import weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger('qutip.steadystate'); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). def _eat_kwargs(function, names):; """"""; Return a wrapped version of `function` that simply removes any keyword; arguments with one of the given names.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for name in names:; if name in kwargs:; del kwargs[name]; return function(*args, **kwargs); return out. def _rename_kwargs(function, names_pairs):; """"""; Return a wra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/steadystate.html:169,Log,Log,169,docs/4.7/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html,1,['Log'],['Log']
Testability,". qutip.stochastic — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.stochastic. Source code for qutip.stochastic; # -*- coding: utf-8 -*-; #; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:168,Log,Log,168,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,1,['Log'],['Log']
Testability,". qutip.stochastic — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.stochastic. Source code for qutip.stochastic; # -*- coding: utf-8 -*-. import numpy as np; from qutip.cy.stochastic import (; SSESolver, SMESolver, PcSSESolver, PcSMESolver, PmSMESolver,; GenericSSolver,; ); from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.states import ket2dm; from qutip.solver import Result; from qutip.qobjevo import QobjEvo; from qutip.superoperator import spre, spost, mat2vec, liouvillian; from qutip.solver import Options; from qutip.parallel import serial_map; from qutip.ui.progressbar import TextProgressBar; from qutip.pdpsolve import main_ssepdpsolve, main_smepdpsolve. __all__ = ['ssesolve', 'photocurrent_sesolve', 'smepdpsolve',; 'smesolve', 'photocurrent_mesolve', 'ssepdpsolve',; 'stochastic_solvers', 'general_stochastic']. [docs]def stochastic_solvers():; # This docstring contains several literal backslash characters inside LaTeX; # blocks, but it cannot be declared as a raw string because we also need to; # use a line continuation. At one point we need a restructured text; # ""definition list"", where the heading _must_ be entirely on one line,; # however it will violate our line-length reporting if we do that.; """"""; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions. Notes; -----; Available solvers for :obj:`~ssesolve` and :obj:`~smesolve`; euler-maruyama; A simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting ``sc_ops``. *not tested*. - Order 0.5; - Code: ``'euler-maruyama'``, ``'euler'`` or ``0.5``. milstein; An order 1.0 strong Taylor scheme. Be",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/stochastic.html:168,Log,Log,168,docs/4.7/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html,1,['Log'],['Log']
Testability,". qutip.superop_reps — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.superop_reps. Source code for qutip.superop_reps; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVIS",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html:170,Log,Log,170,docs/4.6/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html,1,['Log'],['Log']
Testability,". qutip.superop_reps — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.superop_reps. Source code for qutip.superop_reps; # -*- coding: utf-8 -*-; #; # This module was initially contributed by Ben Criger.; #; """"""; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms.; """""". __all__ = ['super_to_choi', 'choi_to_super', 'choi_to_kraus', 'kraus_to_choi',; 'kraus_to_super', 'choi_to_chi', 'chi_to_choi', 'to_choi',; 'to_chi', 'to_super', 'to_kraus', 'to_stinespring'; ]. # Python Standard Library; from itertools import starmap, product. # NumPy/SciPy; from numpy.core.multiarray import array, zeros; from numpy.core.shape_base import hstack; from numpy.matrixlib.defmatrix import matrix; from numpy import sqrt, floor, log2; from numpy import dot; from scipy.linalg import eig, svd; # Needed to avoid conflict with itertools.product.; import numpy as np. # Other QuTiP functions and classes; from qutip.superoperator import vec2mat, operator_to_vector, sprepost; from qutip.operators import identity, sigmax, sigmay, sigmaz; from qutip.tensor import tensor, flatten; from qutip.qobj import Qobj; from qutip.states import basis. # SPECIFIC SUPEROPERATORS -----------------------------------------------------. def _dep_super(pe):; """"""; Returns the superoperator corresponding to qubit depolarization for a; given parameter pe. TODO: if this is going into production (hopefully it isn't) then check; CPTP, expand to arbitrary dimensional systems, etc.; """"""; return Qobj(dims=[[[2], [2]], [[2], [2]]],; inpt=array([[1. - pe / 2., 0., 0., pe / 2.],; [0., 1. - pe, 0., 0.],; [0., 0., 1. - pe, 0.],; [pe / 2., 0., 0., 1. - pe / 2.]])). def _dep_choi(pe):; """"""; Returns the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html:170,Log,Log,170,docs/4.7/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html,1,['Log'],['Log']
Testability,". qutip.superoperator — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.superoperator. Source code for qutip.superoperator; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/superoperator.html:171,Log,Log,171,docs/4.6/modules/qutip/superoperator.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superoperator.html,1,['Log'],['Log']
Testability,". qutip.superoperator — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.superoperator. Source code for qutip.superoperator; __all__ = ['liouvillian', 'liouvillian_ref', 'lindblad_dissipator',; 'operator_to_vector', 'vector_to_operator', 'mat2vec', 'vec2mat',; 'vec2mat_index', 'mat2vec_index', 'spost', 'spre', 'sprepost']. import scipy.sparse as sp; import numpy as np; from qutip.qobj import Qobj; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.sparse import sp_reshape; from qutip.cy.spmath import zcsr_kron; from functools import partial. [docs]def liouvillian(H, c_ops=[], data_only=False, chi=None):; """"""Assembles the Liouvillian superoperator from a Hamiltonian; and a ``list`` of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters; ----------; H : Qobj or QobjEvo; System Hamiltonian. c_ops : array_like of Qobj or QobjEvo; A ``list`` or ``array`` of collapse operators. Returns; -------; L : Qobj or QobjEvo; Liouvillian superoperator. """"""; if isinstance(c_ops, (Qobj, QobjEvo)):; c_ops = [c_ops]; if chi and len(chi) != len(c_ops):; raise ValueError('chi must be a list with same length as c_ops'). h = None; if H is not None:; if isinstance(H, QobjEvo):; h = H.cte; else:; h = H; if h.isoper:; op_dims = h.dims; op_shape = h.shape; elif h.issuper:; op_dims = h.dims[0]; op_shape = [np.prod(op_dims[0]), np.prod(op_dims[0])]; else:; raise TypeError(""Invalid type for Hamiltonian.""); else:; # no hamiltonian given, pick system size from a collapse operator; if isinstance(c_ops, list) and len(c_ops) > 0:; if isinstance(c_ops[0], QobjEvo):; c = c_ops[0].cte; else:; c = c_ops[0]; if c.isoper:; op_d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/superoperator.html:171,Log,Log,171,docs/4.7/modules/qutip/superoperator.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superoperator.html,1,['Log'],['Log']
Testability,". qutip.tensor — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.tensor. Source code for qutip.tensor; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ####",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/tensor.html:164,Log,Log,164,docs/4.6/modules/qutip/tensor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/tensor.html,1,['Log'],['Log']
Testability,". qutip.tensor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.tensor. Source code for qutip.tensor; """"""; Module for the creation of composite quantum objects via the tensor product.; """""". __all__ = [; 'tensor', 'super_tensor', 'composite', 'tensor_swap', 'tensor_contract'; ]. import numpy as np; import scipy.sparse as sp; from qutip.cy.spmath import zcsr_kron; from qutip.qobj import Qobj; from qutip.permute import reshuffle; from qutip.superoperator import operator_to_vector; from qutip.dimensions import (; flatten, enumerate_flat, unflatten, deep_remove,; dims_to_tensor_shape, dims_idxs_to_tensor_idxs; ). import qutip.settings; import qutip.superop_reps # Avoid circular dependency here. [docs]def tensor(*args):; """"""Calculates the tensor product of input operators. Parameters; ----------; args : array_like; ``list`` or ``array`` of quantum objects for tensor product. Returns; -------; obj : qobj; A composite quantum object. Examples; --------; >>> tensor([sigmax(), sigmax()]) # doctest: +SKIP; Quantum object: dims = [[2, 2], [2, 2]], \; shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]; """""". if not args:; raise TypeError(""Requires at least one input argument""). if len(args) == 1 and isinstance(args[0], (list, np.ndarray)):; # this is the case when tensor is called on the form:; # tensor([q1, q2, q3, ...]); qlist = args[0]. elif len(args) == 1 and isinstance(args[0], Qobj):; # tensor is called with a single Qobj as an argument, do nothing; return args[0]. else:; # this is the case when tensor is called on the form:; # tensor(q1, q2, q3, ...); qlist = args. if not all([isinstance(q, Qobj) for q in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/tensor.html:164,Log,Log,164,docs/4.7/modules/qutip/tensor.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/tensor.html,1,['Log'],['Log']
Testability,". qutip.three_level_atom — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.three_level_atom. Source code for qutip.three_level_atom; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POS",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/three_level_atom.html:174,Log,Log,174,docs/4.6/modules/qutip/three_level_atom.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/three_level_atom.html,1,['Log'],['Log']
Testability,". qutip.three_level_atom — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.three_level_atom. Source code for qutip.three_level_atom; r'''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. import numpy as np; from qutip.states import qutrit_basis. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of three level operators. '''; out = np.empty((5,), dtype=object); one, two, three = qutrit_basis(); # Note that the three level operators are different; # from the qutrit operators. A three level atom only; # has transitions 1 <-> 2 <-> 3, so we define the; # operators seperately from ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/three_level_atom.html:174,Log,Log,174,docs/4.7/modules/qutip/three_level_atom.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/three_level_atom.html,1,['Log'],['Log']
Testability,". qutip.tomography — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.tomography. Source code for qutip.tomography; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH D",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/tomography.html:168,Log,Log,168,docs/4.6/modules/qutip/tomography.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/tomography.html,1,['Log'],['Log']
Testability,". qutip.tomography — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.tomography. Source code for qutip.tomography; __all__ = ['qpt_plot', 'qpt_plot_combined', 'qpt']. from qutip.tensor import tensor; from qutip.superoperator import spre, spost, mat2vec, vec2mat; from numpy import hstack, real, imag; import scipy.linalg as la; from qutip.visualization import matrix_histogram, matrix_histogram_complex. try:; import matplotlib.pyplot as plt; except:; pass. def _index_permutations(size_list, perm=[]):; """"""; Generate a list with all index permutations. Parameters; ----------; size_list : list; A list that contains the sizes for each composite system.; perm : list; A list of permutations. Returns; -------; perm_idx : list; List containing index permutations. """"""; if len(size_list) == 0:; yield perm; else:; for n in range(size_list[0]):; for ip in _index_permutations(size_list[1:], perm + [n]):; yield ip. [docs]def qpt_plot(chi, lbls_list, title=None, fig=None, axes=None):; """"""; Visualize the quantum process tomography chi matrix. Plot the real and; imaginary parts separately. Parameters; ----------; chi : array; Input QPT chi matrix.; lbls_list : list; List of labels for QPT plot axes.; title : string; Plot title.; fig : figure instance; User defined figure instance used for generating QPT plot.; axes : list of figure axis instance; User defined figure axis instance (list of two axes) used for; generating QPT plot. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. """""". if axes is None or len(axes) != 2:; if fig is None:; fig = plt.figure(figsize=(16, 8)). ax1 = fig.add_subplot(1, 2, 1, projection='3d', position=[0, 0, 1, 1]); ax2 = fig.add_subplot(1, 2, 2, projection='3d',",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/tomography.html:168,Log,Log,168,docs/4.7/modules/qutip/tomography.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/tomography.html,1,['Log'],['Log']
Testability,". qutip.topology — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.topology. Source code for qutip.topology; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, The QuTiP Project.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###################",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/topology.html:166,Log,Log,166,docs/4.6/modules/qutip/topology.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/topology.html,1,['Log'],['Log']
Testability,". qutip.topology — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.topology. Source code for qutip.topology; __all__ = ['berry_curvature', 'plot_berry_curvature']. from qutip import (Qobj, tensor, basis, qeye, isherm, sigmax, sigmay, sigmaz); import numpy as np. try:; import matplotlib.pyplot as plt; except:; pass. [docs]def berry_curvature(eigfs):; """"""Computes the discretized Berry curvature on the two dimensional grid; of parameters. The function works well for cases with no band mixing. Parameters; ==========; eigfs : numpy ndarray; 4 dimensional numpy ndarray where the first two indices are for the two; discrete values of the two parameters and the third is the index of the; occupied bands. The fourth dimension holds the eigenfunctions. Returns; -------; b_curv : numpy ndarray; A two dimensional array of the discretized Berry curvature defined for; the values of the two parameters defined in the eigfs.; """"""; nparam0 = eigfs.shape[0]; nparam1 = eigfs.shape[1]; nocc = eigfs.shape[2]; b_curv = np.zeros((nparam0-1, nparam1-1), dtype=float). for i in range(nparam0-1):; for j in range(nparam1-1):; rect_prd = np.identity(nocc, dtype=complex); innP0 = np.zeros([nocc, nocc], dtype=complex); innP1 = np.zeros([nocc, nocc], dtype=complex); innP2 = np.zeros([nocc, nocc], dtype=complex); innP3 = np.zeros([nocc, nocc], dtype=complex). for k in range(nocc):; for l in range(nocc):; wf0 = eigfs[i, j, k, :]; wf1 = eigfs[i+1, j, l, :]; innP0[k, l] = np.dot(wf0.conjugate(), wf1). wf1 = eigfs[i+1, j, k, :]; wf2 = eigfs[i+1, j+1, l, :]; innP1[k, l] = np.dot(wf1.conjugate(), wf2). wf2 = eigfs[i+1, j+1, k, :]; wf3 = eigfs[i, j+1, l, :]; innP2[k, l] = np.dot(wf2.conjugate(), wf3). wf3 = eigfs[i, j+1, k, :]; wf0 = eigfs[i, j, l, :]; innP3[k, l] = np.dot(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/topology.html:166,Log,Log,166,docs/4.7/modules/qutip/topology.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/topology.html,1,['Log'],['Log']
Testability,". qutip.utilities — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.utilities. Source code for qutip.utilities; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMA",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/utilities.html:167,Log,Log,167,docs/4.6/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html,1,['Log'],['Log']
Testability,". qutip.utilities — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.utilities. Source code for qutip.utilities; """"""; This module contains utility functions that are commonly needed in other; qutip modules.; """""". __all__ = ['n_thermal', 'clebsch', 'convert_unit']. import numpy as np. [docs]def n_thermal(w, w_th):; """"""; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency 'w', at the temperature described by; 'w_th' where :math:`\\omega_{\\rm th} = k_BT/\\hbar`. Parameters; ----------. w : *float* or *array*; Frequency of the oscillator. w_th : *float*; The temperature in units of frequency (or the same units as `w`). Returns; -------. n_avg : *float* or *array*. Return the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. """""". if isinstance(w, np.ndarray):; return 1.0 / (np.exp(w / w_th) - 1.0). else:; if (w_th > 0) and np.exp(w / w_th) != 1.0:; return 1.0 / (np.exp(w / w_th) - 1.0); else:; return 0.0. def _factorial_prod(N, arr):; arr[:int(N)] += 1. def _factorial_div(N, arr):; arr[:int(N)] -= 1. def _to_long(arr):; prod = 1; for i, v in enumerate(arr):; prod *= (i+1)**int(v); return prod. [docs]def clebsch(j1, j2, j3, m1, m2, m3):; """"""Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters; ----------; j1 : float; Total angular momentum 1. j2 : float; Total angular momentum 2. j3 : float; Total angular momentum 3. m1 : float; z-component of angular momentum 1. m2 : float; z-component of angular momentum 2. m3 : float; z-component of angular momentum 3. Returns; -------; cg_coeff : float; Requested Clebsch-Gordan coefficient. """"""; if m3 != m1 + m2:; return 0; vmin = int(np.max(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/utilities.html:167,Log,Log,167,docs/4.7/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html,1,['Log'],['Log']
Testability,". qutip.visualization — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.visualization. Source code for qutip.visualization; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/visualization.html:171,Log,Log,171,docs/4.6/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/visualization.html,1,['Log'],['Log']
Testability,". qutip.visualization — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.visualization. Source code for qutip.visualization; """"""; Functions for visualizing results of quantum dynamics simulations,; visualizations of quantum states and processes.; """""". __all__ = ['hinton', 'sphereplot', 'energy_level_diagram',; 'plot_energy_levels', 'fock_distribution',; 'plot_fock_distribution', 'wigner_fock_distribution',; 'plot_wigner_fock_distribution', 'plot_wigner',; 'plot_expectation_values', 'plot_spin_distribution_2d',; 'plot_spin_distribution_3d', 'plot_qubism', 'plot_schmidt',; 'complex_array_to_rgb', 'matrix_histogram',; 'matrix_histogram_complex', 'sphereplot', 'plot_wigner_sphere']. import warnings; import itertools as it; import numpy as np; from numpy import pi, array, sin, cos, angle, log2. from packaging.version import parse as parse_version. from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.wigner import wigner; from qutip.tensor import tensor; from qutip.matplotlib_utilities import complex_phase_cmap; from qutip.superoperator import vector_to_operator; from qutip.superop_reps import _super_to_superpauli, _isqubitdims. from qutip import settings. try:; import matplotlib.pyplot as plt; import matplotlib as mpl; from matplotlib import cm; from mpl_toolkits.mplot3d import Axes3D. # Define a custom _axes3D function based on the matplotlib version.; # The auto_add_to_figure keyword is new for matplotlib>=3.4.; if parse_version(mpl.__version__) >= parse_version('3.4'):; def _axes3D(fig, *args, **kwargs):; ax = Axes3D(fig, *args, auto_add_to_figure=False, **kwargs); return fig.add_axes(ax); else:; def _axes3D(*args, **kwargs):; return Axes3D(*args, **kwargs); except:; pass. [docs]def plot_wigner_sphere(fig, a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/visualization.html:171,Log,Log,171,docs/4.7/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/visualization.html,1,['Log'],['Log']
Testability,". qutip.wigner — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.wigner. Source code for qutip.wigner; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ####",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/wigner.html:164,Log,Log,164,docs/4.6/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html,1,['Log'],['Log']
Testability,". qutip.wigner — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.wigner. Source code for qutip.wigner; __all__ = [; 'wigner', 'qfunc', 'QFunc', 'spin_q_function', 'spin_wigner',; 'wigner_transform',; ]. import numpy as np; import warnings; from numpy import (; zeros, array, arange, exp, real, conj, pi, copy, sqrt, meshgrid, cos, sin,; ); import scipy.sparse as sp; import scipy.fftpack as ft; import scipy.linalg as la; import scipy.special; from scipy.special import genlaguerre, binom, sph_harm, factorial. import qutip; from qutip import Qobj, ket2dm, jmat; from qutip.parallel import parfor; from qutip.cy.sparse_utils import _csr_get_diag; from qutip.sparse import eigh. def wigner_transform(psi, j, fullparity, steps, slicearray):; """"""takes the density matrix or state vector of any finite state and; generates the Wigner function for that state on a sphere, generating a spin; Wigner function useful for displaying the quasi-probability for a qubit or; any qudit. For the standard, continuous-variable Wigner function for; position and momentum variables, wigner() should be used. Parameters; ----------; psi : qobj; a state vector or density matrix.; j : int; the total angular momentum of the quantum state.; fullparity : bool; should the parity of the full SU space be used?; steps : int; number of points at which the Wigner transform is calculated.; slicearray : list of str; the angle slice to be used for each particle in case of a; multi-particle quantum state. 'l' yields an equal angle; slice. 'x', 'y' and 'z' angle slices can also be chosen. Returns; ----------; wigner : list of float; the wigner transformation at `steps` different theta and phi. Raises; ------; ComplexWarning; This can be ignored as it is caused due to rounding errors.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/wigner.html:164,Log,Log,164,docs/4.7/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/wigner.html,1,['Log'],['Log']
Testability,". sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=1/2\), \(\eta=1/2\)): 'pc-euler-imp',; 'pc-euler-2' or 'pred-corr-2'. platenExplicit scheme, creates the Milstein using finite differences; instead",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:108572,test,tested,108572,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['test'],['tested']
Testability,".'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; log",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:12647,log,logger,12647,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['log'],['logger']
Testability,".'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:12997,log,logger,12997,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,2,['log'],['logger']
Testability,".'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); with warnings.catch_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].app",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/steadystate.html:12051,log,logger,12051,docs/4.7/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html,2,['log'],['logger']
Testability,".1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.8+); Setup Using Homebrew; Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Optional Installation Options; UMFPACK Linear Solver; Optimized BLAS Libraries. Verifying the Installation; Checking Version Information using the About Function. « Frontmatter. Users Guide ». Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.3+ is highly recommended. Numpy; 1.7+; Not tested on lower versions. Scipy; 0.14+; Lower versions have missing features. Matplotlib; 1.2.0+; Some plotting does not work on lower versions. Cython; 0.15+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Fortran; Compiler; Fortran 90; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Optional. Needed for using the Bloch3d class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. scikits.umfpack; 5.2.0+; Optional. Faster (~2-5x) steady state calculations. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:2357,test,tested,2357,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,1,['test'],['tested']
Testability,".7’ compiler will not work with QuTiP. You will have to use the g++ compiler in mingw32. If you need to create a Python 2.7 conda environment see building-conda-environment, including adding-conda-forge; Then run:; conda install mingwpy. To specify the use of the mingw compiler you will need to create the following file:; <path to my Python env>/Lib/distutils/distutils.cfg. with the following contents:; [build]; compiler=mingw32; [build_ext]; compiler=mingw32. <path to my Python env> will be something like C:\Ananconda2\ or C:\Ananconda2\envs\qutip-env\ depending on where you installed Anaconda or Miniconda, and whether you created a specific environment.; You can then install QuTiP using either the install-via_pip or install-get-it method. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the pytest testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/installation.html:8491,test,testing,8491,docs/4.5/installation.html,https://qutip.org,https://qutip.org/docs/4.5/installation.html,3,['test'],"['testing', 'tests']"
Testability,".]; [ 0. 1.]]. In [24]: q ** 3; Out[24]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 0. 0. 2.44948974]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]]. In [25]: x / np.sqrt(2); Out[25]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.70710678]; [ 0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; In [26]: q * x; ---------------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-26-c5138e004127> in <module>(); ----> 1 q * x. /opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/qutip/qobj.py in __mul__(self, other); 433 ; 434 else:; --> 435 raise TypeError(""Incompatible Qobj shapes""); 436 ; 437 elif isinstance(other, (list, np.ndarray)):. TypeError: Incompatible Qobj shapes. In addition, the logic operators is equal == and is not equal != are also supported. Functions operating on Qobj class¶; Like attributes, the quantum object class has defined functions (methods) that operate on Qobj class instances. For a general quantum object Q:. Function; Command; Description. Check Hermicity; Q.check_herm(); Check if quantum object is Hermitian. Conjugate; Q.conj(); Conjugate of quantum object. Dagger (adjoint); Q.dag(); Returns adjoint (dagger) of object. Diagonal; Q.diag(); Returns the diagonal elements. Eigenenergies; Q.eigenenergies(); Eigenenergies (values) of operator. Eigenstates; Q.eigenstates(); Returns eigenvalues and eigenvectors. Eliminate States; Q.eliminate_states(inds); Returns quantum object with states in; list inds removed. Exponential; Q.expm(); Matrix exponential of operator. Extract States; Q.extract_states(inds); Qobj with states listed in inds only. Full; Q.full(); Returns full (not sparse) array of; Q’s data. Groundstate; Q.groundstate(); Eigenval & eigket of Qobj groundstate. Matri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-basics.html:10359,log,logic,10359,docs/3.1.0/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-basics.html,1,['log'],['logic']
Testability,"._num_tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True. def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overridden here; """"""; logger.info(""Setting memory optimisations for level {}"".format(; self.memory_optimization)). if self.oper_dtype is None:; self._choose_oper_dtype(); logger.info(""Internal operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)). if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)). if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)). if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)). if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)). def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken from Qobj.ex",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:21389,log,logger,21389,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,6,['log'],['logger']
Testability,"._onwd_evo_qobj. @property; def evo_t2targ(self):; _attrib_deprecation(; ""'evo_t2targ' has been replaced by '_onto_evo'""); return self._onto_evo. @property; def onto_evo(self):; """"""; List of evolution operators (Qobj) from the initial to the given; timeslot; """"""; if self._onto_evo is not None:; if self._onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:38267,log,logging,38267,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,10,['log'],['logging']
Testability,".debug('Original profile: %i' % old_pro); ; if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:23702,log,logger,23702,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['log'],['logger']
Testability,".debug:; logger.debug('Starting direct dense solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L = L.data.todense(); L[0, :] = np.diag(ss_args['weight']*np.ones(n)).reshape((1, n ** 2)); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp,_temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, n, ss_arg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:16015,log,logger,16015,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['log'],['logger']
Testability,".debug:; logger.debug('Starting direct dense solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L = L.full(); L[0, :] = np.diag(ss_args['weight']*np.ones(n)).reshape((1, n ** 2)); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L@v, np.inf); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = sp.csgraph.reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec, np.inf); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp, _temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_preco",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:18286,log,logger,18286,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,2,['log'],['logger']
Testability,".evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html:16499,log,logging,16499,docs/4.1/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html,10,['log'],['logging']
Testability,".evo_t2targ_recalc[-1] = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html:14680,log,logging,14680,docs/4.1/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html,10,['log'],['logging']
Testability,".fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an Opti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:29347,log,logging,29347,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['log'],['logging']
Testability,".fmin_l_bfgs_b); def fmin_l_bfgs_b(*args, **kwargs):; with warnings.catch_warnings():; message = r""tostring\(\) is deprecated\. Use tobytes\(\) instead\.""; warnings.filterwarnings(""ignore"", message=message,; category=DeprecationWarning); return spopt.fmin_l_bfgs_b(*args, **kwargs); else:; fmin_l_bfgs_b = spopt.fmin_l_bfgs_b. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. - ``OptimConfig`` instance - various configuration options; - ``Dynamics`` instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the pulse optim algorithm ``alg``. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:6574,log,logger,6574,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,4,['log'],['logger']
Testability,".g. in apply_params; then they will not be overridden here; """"""; logger.info(""Setting memory optimisations for level {}"".format(; self.memory_optimization)); ; if self.oper_dtype is None:; self._choose_oper_dtype(); logger.info(""Internal operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)); ; if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)); ; if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True ; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)); ; if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True ; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)); ; if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False ; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)); ; def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken from Qobj.expm(); # if method is not explicitly given, try to make a good choice; # between sparse and dense solvers by considering the size of the; # system and the number of non-zero elements.; if self.time_depend_drift:; dg = self.drift_dyn_gen[0]; else:; dg = self.drift_dyn_gen; if self.time_depend_ctrl_dyn_gen:; ctrls = self.ctrl_dyn_gen[0, :]; else:; ctrls = self.ctrl_dyn_gen; for c in ctrls:; dg = dg + c. N = dg.data.shape[0]; n = dg.data.nnz. if N ** 2 < 100 * n:; # lar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:21896,log,logger,21896,docs/4.3/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html,1,['log'],['logger']
Testability,".get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:68906,log,logging,68906,docs/4.5/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html,2,['log'],"['logger', 'logging']"
Testability,".isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals) >= tol]; # Calculate S; S = nzrvals @ log_base(nzrvals) - rvals @ P @ log_base(svals); # the relative entropy is guaranteed to be >= 0, so we clamp the; # calculated value to 0 to avoid small violations of the lower bound.; return max(0, S). [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/entropy.html:9743,log,logarithm,9743,docs/4.6/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html,4,['log'],['logarithm']
Testability,".num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html:9144,log,logging,9144,docs/4.1/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html,9,['log'],['logging']
Testability,".oper_dtype == np.ndarray:; self._prop_eigen[k] = np.diagflat(prop_eig); self._dyn_gen_eigenvectors[k] = eig_vec; # The _dyn_gen_eigenvectors_adj list is not used in; # memory optimised modes; if self._dyn_gen_eigenvectors_adj is not None:; self._dyn_gen_eigenvectors_adj[k] = \; self._dyn_gen_eigenvectors[k].conj().T; else:; assert False, f""Unknown oper_dtype {self.oper_dtype!r}"". def _get_dyn_gen_eigenvectors_adj(self, k):; # The _dyn_gen_eigenvectors_adj list is not used in; # memory optimised modes; if self._dyn_gen_eigenvectors_adj is not None:; return self._dyn_gen_eigenvectors_adj[k]; else:; if self.oper_dtype == Qobj:; return self._dyn_gen_eigenvectors[k].dag(); else:; return self._dyn_gen_eigenvectors[k].conj().T. [docs] def check_unitarity(self):; """"""; Checks whether all propagators are unitary; For propagators found not to be unitary, the potential underlying; causes are investigated.; """"""; for k in range(self.num_tslots):; prop_unit = self._is_unitary(self._prop[k]); if not prop_unit:; logger.warning(; ""Progator of timeslot {} is not unitary"".format(k)); if not prop_unit or self.unitarity_check_level > 1:; # Check Hamiltonian; H = self._dyn_gen[k]; if isinstance(H, Qobj):; herm = H.isherm; else:; diff = np.abs(H.T.conj() - H); herm = False if np.any(diff > settings.atol) else True; eigval_unit = self._is_unitary(self._prop_eigen[k]); eigvec_unit = self._is_unitary(self._dyn_gen_eigenvectors[k]); if self._dyn_gen_eigenvectors_adj is not None:; eigvecadj_unit = self._is_unitary(; self._dyn_gen_eigenvectors_adj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omeg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:50923,log,logger,50923,docs/4.6/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html,4,['log'],['logger']
Testability,".reshape((1, n ** 2)); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L@v, np.inf); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = sp.csgraph.reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec, np.inf); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp, _temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:18499,log,logger,18499,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,2,['log'],['logger']
Testability,".scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None; ; if not self.ubound is None and not self.lbound is None:; if self.ubou",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html:8272,log,logger,8272,docs/4.1/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html,10,['log'],['logger']
Testability,"//github.com/nonhermitian/umfpack that can be installed to have SciPy find and use the umfpack library. Optimized BLAS Libraries¶; QuTiP is designed to take advantage of some of the optimized BLAS libraries that are available for NumPy. At present, this includes the OPENBLAS and MKL libraries. If NumPy is built against these libraries, then QuTiP will take advantage of the performance gained by using these optimized tools. As these libraries are multi-threaded, you can change the number of threads used in these packages by adding:; >>> import os; >>> os.environ['OPENBLAS_NUM_THREADS'] = '4'; >>> os.environ['MKL_NUM_THREADS'] = '4'. at the top of your Python script files, or iPython notebooks, and then loading the QuTiP framework. If these commands are not present, then QuTiP automatically sets the number of threads to one. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; Paul D. Nation & Robert J. Johansson. QuTiP Version: 3.1.0; Numpy Version: 1.9.1; Scipy Version: 0.14.0; Cyth",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:12547,test,tests,12547,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,2,['test'],"['testing', 'tests']"
Testability,"//github.com/nonhermitian/umfpack that can be installed to have SciPy find and use the umfpack library. Optimized BLAS Libraries¶; QuTiP is designed to take advantage of some of the optimized BLAS libraries that are available for NumPy. At present, this includes the OPENBLAS and MKL libraries. If NumPy is built against these libraries, then QuTiP will take advantage of the performance gained by using these optimized tools. As these libraries are multi-threaded, you can change the number of threads used in these packages by adding:; >>> import os; >>> os.environ['OPENBLAS_NUM_THREADS'] = '4'; >>> os.environ['MKL_NUM_THREADS'] = '4'. at the top of your Python script files, or iPython notebooks, and then loading the QuTiP framework. If these commands are not present, then QuTiP automatically sets the number of threads to one. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that your have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; Paul D. Nation & Robert J. Johansson. ('QuTiP Version: ', '3.0.1'); ('Numpy Version: ', '1.8.0'); ('Scipy Ve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:11558,test,tests,11558,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,2,['test'],"['testing', 'tests']"
Testability,"/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32. [build_ext]; compiler = mingw32. The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above. Obtain the QuTiP source code and installed it following the instructions given above. Note; In some cases, to get the dynamic compilation of Cython code to work, it; might be necessary to edit the PATH variable and make sure that; C:\MinGW32-xy\bin appears either first in the PATH list, or possibly; right after C:\Python27\Lib\site-packages\PyQt4. This is to make sure; that the right version of the MinGW compiler is used if more than one; is installed (not uncommon under Windows, since many packages are; distributed and installed with their own version of all dependencies). Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that your have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; >>> from qutip import *; >>> about(). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/installation.html:10011,test,tests,10011,docs/3.0.0/installation.html,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html,5,['test'],"['testing', 'tests']"
Testability,"0'],; maxiter=ss_args['maxiter'],; callback=_iter_count). elif ss_args['method'] == 'iterative-bicgstab':; try:; v, check = bicgstab(L, b, tol=ss_args['tol'],; atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = bicgstab(L, b, tol=ss_args['tol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if 'precond_time' in ss_args['info'].keys():; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrice",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:23419,log,logger,23419,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['log'],['logger']
Testability,"0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions:; psi = basis(2, 0). rho = ket2dm(psi). print(rho). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. vec_rho = operator_to_vector(rho). print(vec_rho). Output:; Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = ope",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-states.html:16842,test,testing,16842,docs/4.6/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html,2,['test'],['testing']
Testability,"0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions:; psi = basis(2, 0). rho = ket2dm(psi). print(rho). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. vec_rho = operator_to_vector(rho). print(vec_rho). Output:; Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = ope",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-states.html:16900,test,testing,16900,docs/4.7/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html,2,['test'],['testing']
Testability,"0] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""func"")); elif type_ == 2:; op_type_count[1] += 1; self.ops.append(EvoElement(op[0], _StrWrapper(op[1]),; op[1], ""string"")); elif type_ == 3:; op_type_count[2] += 1; self.ops.append(EvoElement(op[0], _CubicSplineWrapper(tlist, op[1]),; op[1].copy(), ""array"")); elif type_ == 4:; op_type_count[3] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""spline"")). nops = sum(op_type_count); if op_type_count[0] == nops:; self.type = ""func""; elif op_type_count[1] == nops:; self.type = ""string""; elif op_type_count[2] == nops:; self.type = ""array""; elif op_type_count[3] == nops:; self.type = ""spline""; elif op_type_count[0]:; self.type = ""mixed_callable""; else:; self.type = ""mixed_compilable"". try:; if not self.cte:; self.cte = self.ops[0].qobj; # test is all qobj are compatible (shape, dims); for op in self.ops[1:]:; self.cte += op.qobj; self.cte *= 0.; self.dummy_cte = True; else:; cte_copy = self.cte.copy(); # test is all qobj are compatible (shape, dims); for op in self.ops:; cte_copy += op.qobj; except Exception as e:; raise TypeError(""Qobj not compatible."") from e. if not self.ops:; self.const = True; self.num_obj = (len(self.ops) if self.dummy_cte else len(self.ops) + 1); self._args_checks(). def _td_format_check_single(self, Q_object, tlist=None):; op_type = []. if isinstance(Q_object, Qobj):; op_type = 0; elif isinstance(Q_object, (FunctionType,; BuiltinFunctionType, partial)):; op_type = 1; elif isinstance(Q_object, list):; if (len(Q_object) == 0):; op_type = -1; for op_k in Q_object:; if isinstance(op_k, Qobj):; op_type.append(0); elif isinstance(op_k, list):; if not isinstance(op_k[0], Qobj):; raise TypeError(""Incorrect Q_object specification""); elif len(op_k) == 2:; if isinstance(op_k[1], Cubic_Spline):; op_type.append(4); elif callable(op_k[1]):; op_type.append(1); elif isinstance(op_k[1], str):; op_type.append(2); elif isinstance(op_k[1], np.ndarray):; if not isinstance(tlist, np.ndarray) or not \; len(op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html:13916,test,test,13916,docs/4.4/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html,1,['test'],['test']
Testability,"1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype np.float64 or; np.complex128. A list of times (np.float64) at which the; coeffients must be given as tlist. The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; args = {""_step_func_coeff"": True}. Examples of array-format usage are:; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; QobjEvo that contains different tlist values, however.; Passing arguments; args is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string.; There are some “magic” names that can be specified, whose objects will be; overwritten when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:19236,log,logspace,19236,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['log'],['logspace']
Testability,"1, p_1, q_2, p_2)^T\) is the vector with quadrature operators; for the two modes.; Alternatively, if R = None, and if annihilation operators a1 and a2; for the two modes are supplied instead, the quadrature correlation matrix; is constructed from the annihilation operators before then the covariance; matrix is calculated. Parameters:a1 : Qobj. Field operator for mode 1. a2 : Qobj. Field operator for mode 2. R : ndarray. The quadrature correlation matrix. rho : Qobj. Density matrix for which to calculate the covariance matrix. Returns:cov_mat : ndarray. A 2-dimensional array of covariance values. logarithmic_negativity(V)[source]¶; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters:V : 2d array. The covariance matrix. Returns:N : float. The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, rho0, tlist, e_ops=[], args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object>, _safe_mode=True)[source]¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. Parameters:H : qutip.qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.qobj. initial density m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:52365,log,logarithmic,52365,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['log'],['logarithmic']
Testability,"1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.6+); Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. « Frontmatter. Users Guide ». Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.3+ is highly recommended. Numpy; 1.7+; Not tested on lower versions. Scipy; 0.13+; Lower versions have missing features. Matplotlib; 1.2.0+; Some plotting does not work on lower versions. Cython; 0.15+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Fortran; Compiler; Fortran 90; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Optional. Needed for using the Bloch3d class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has a substantial performance benefit when compared with the Python-based solver. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/installation.html:2153,test,tested,2153,docs/3.0.0/installation.html,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html,1,['test'],['tested']
Testability,"13+; Lower versions have missing features. Matplotlib; 1.2.0+; Some plotting does not work on lower versions. Cython; 0.15+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Fortran; Compiler; Fortran 90; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Optional. Needed for using the Bloch3d class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has a substantial performance benefit when compared with the Python-based solver. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are only tested on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; sudo pip install qutip. However, when installing QuTiP this way the Fortran-based Monte Carlo solver is not included.; More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository. Installing from source¶; Installing QuTiP from source requires that all the dependencies are satisfied. The installation of these dependencies is different on each platfo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/installation.html:3187,test,tested,3187,docs/3.0.0/installation.html,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html,1,['test'],['tested']
Testability,"1675 by Simon Cross); Fixed the description of random number usage in the Monte Carlo solver guide. (#1677 by Ian Thorvaldson); Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the installation requirements in the documentation to match what is specified in setup.py. (#1715 by Asier Galicia); Fixed a typo in the chi_to_choi documentation. Previously the documentation mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:7079,test,test,7079,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['test'],['test']
Testability,"2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. Note the use of the NORMALIZE_WHITESPACE option to ensure that the; multiline output matches.; Render:; >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] ; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]); >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. (png, hires.png, pdf). A few notes on using the plot directive:. A useful argument to specify in plot blocks is that of context which ensures; that the code is being run in the namespace of the previous plot block within the; same file.; By default, each rendered figure in one plot block (when using :context:); is carried over to the next block.; When the context argument is specified with the reset option; as :context: reset, the namespace is reset to a new one and all figures are; erased.; When the context argument is specified with the close-figs option; as :context: reset, the namespace is reset to a new one and all figures are; erased. The Plot directive cannot be used in conjunction with Doctest because they do not; share the same namespace when used in the same file.; Since Plot can also be used in doctest mode, in; the case where code examples require both testing and rendering figures, it is; easier to use the Plot directive. To learn more about each directive, it is useful; to refer to their individual pages. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/docs.html:5485,test,testing,5485,docs/4.6/development/docs.html,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html,2,['test'],['testing']
Testability,"2 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in favour of scipy.sparse.csgraph. Developer Changes¶. Add Boxi Li to authors. (by Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:18694,test,testing,18694,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,4,['test'],"['test', 'testing']"
Testability,"2109 0.26343512 0.17449684 0.1500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. print(thermal_dm(5, 1.25)). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other. Included are the trace distance qutip.metrics.tracedist, fidelity qutip.metrics.fidelity, Hilbert-Schmidt distance qutip.metrics.hilbert_dist, Bures distance qutip.metrics.bures_dist, Bures angle qutip.metrics.bures_angle, and quantum Hellinger distance qutip.metrics.hellinger_dist.; x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\), while the quantum Hellinger distance (QHE) between two pure states \(\left|\psi\right>\) and \(\left|\phi\right>\) is given by \(QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}\).; np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; spin = basis(2, 0). Now at this point one may ask ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-states.html:10376,test,testing,10376,docs/4.6/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html,4,['test'],['testing']
Testability,"27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.6+); Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Optional Installation Options; UMFPACK Linear Solver; Optimized BLAS Libraries. Verifying the Installation; Checking Version Information using the About Function. « Frontmatter. Users Guide ». Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.3+ is highly recommended. Numpy; 1.7+; Not tested on lower versions. Scipy; 0.13+; Lower versions have missing features. Matplotlib; 1.2.0+; Some plotting does not work on lower versions. Cython; 0.15+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Fortran; Compiler; Fortran 90; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Optional. Needed for using the Bloch3d class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. scikits.umfpack; 5.2.0+; Optional. Faster (~2-5x) steady state calculations. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has a substantial performance benefit when compared with the Python-based solver. In order to install this package you must have a Fortra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:2295,test,tested,2295,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,1,['test'],['tested']
Testability,"29292109 0.19402805 0.16684347]; [0.23509686 0.29292109 0.26343512 0.17449684 0.1500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. print(thermal_dm(5, 1.25)). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other. Included are the trace distance qutip.metrics.tracedist, fidelity qutip.metrics.fidelity, Hilbert-Schmidt distance qutip.metrics.hilbert_dist, Bures distance qutip.metrics.bures_dist, Bures angle qutip.metrics.bures_angle, and quantum Hellinger distance qutip.metrics.hellinger_dist.; x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\), while the quantum Hellinger distance (QHE) between two pure states \(\left|\psi\right>\) and \(\left|\phi\right>\) is given by \(QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}\).; np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-states.html:10325,test,testing,10325,docs/4.6/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html,4,['test'],['testing']
Testability,"32). hilbert_dist(A, B)[source]¶; Returns the Hilbert-Schmidt distance between two density matrices A & B. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. distfloatHilbert-Schmidt distance between density matrices. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. tolfloatTolerance used by sparse eigensolver, if used. (0=Machine precision). sparse{False, True}Use sparse eigensolver. Returns. tracedistfloatTrace distance between A and B. Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(tracedist(x,y), 0.9705143161472971). Continuous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters. basislistList of operators that defines the basis for the correlation matrix. rhoQobjDensity matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns. corr_matndarrayA 2-dimensional array of correlation values or operators. correlation_matrix_field(a1, a2, rho=None)[source]¶; Calculates the correlation matrix for given field operators \(a_1\) and; \(a_2\). If a density matrix is given the expectation values are; calculated, otherwise a matrix with",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:64821,test,testing,64821,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['test'],['testing']
Testability,"3:; return self.type. [docs]class QobjEvo:; """"""A class for representing time-dependent quantum objects,; such as quantum operators and states. The QobjEvo class is a representation of time-dependent Qutip quantum; objects (Qobj). This class implements math operations :; +,- : QobjEvo, Qobj; * : Qobj, C-number; / : C-number; and some common linear operator/state operations. The QobjEvo; are constructed from a nested list of Qobj with their time-dependent; coefficients. The time-dependent coefficients are either a funciton, a; string or a numpy array. For function format, the function signature must be f(t, args).; *Examples*; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; sin cos tan asin acos atan pi; sinh cosh tanh asinh acosh atanh; exp log log10 erf zerf sqrt; real imag conj abs norm arg proj; numpy as np, and scipy.special as spe.; *Examples*; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; *Examples*; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). args is a dict of (name:object). The name must be a valid variables string.; Some solvers support arguments that update at each call:; sesolve, mesolve, mcsolve:; state can be obtained with:; name+""=vec"":Qobj => args[name] == state as 1D np.ndarray; name+""=mat"":Qobj => args[name] == state as 2D np.ndarray; name+""=Qobj"":Qobj => args[name] == state as Qobj. This Qobj is the initial ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html:6538,log,log,6538,docs/4.4/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html,1,['log'],['log']
Testability,"3:; return self.type. [docs]class QobjEvo:; """"""A class for representing time-dependent quantum objects,; such as quantum operators and states. The QobjEvo class is a representation of time-dependent Qutip quantum; objects (Qobj). This class implements math operations :; +,- : QobjEvo, Qobj; * : Qobj, C-number; / : C-number; and some common linear operator/state operations. The QobjEvo; are constructed from a nested list of Qobj with their time-dependent; coefficients. The time-dependent coefficients are either a funciton, a; string or a numpy array. For function format, the function signature must be f(t, args).; *Examples*; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; sin cos tan asin acos atan pi; sinh cosh tanh asinh acosh atanh; exp log log10 erf zerf sqrt; real imag conj abs norm arg proj; numpy as np, and scipy.special as spe.; *Examples*; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; By default, a cubic spline interpolation will be used for the coefficient; at time t.; If the coefficients are to be treated as step function, use the arguments; args = {""_step_func_coeff"": True}; *Examples*; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). args is a dict of (name:object). The name must be a valid variables string.; Some solvers support arguments that update at each call:; sesolve, mesolve, mcsolve:; state can be obtained w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:7186,log,log,7186,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['log'],['log']
Testability,"45, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters. rhoqobjsensity matrix or ket/bra vector. Returns. entropyfloatLinear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters. rhoqobjDensity matrix for composite quantum systems. selAint/listint or list of first selected density matrix components. selBint/listint or list of second selected density matrix components. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_mutfloatMutual information between selected components. entropy_relative(rho, sigma, base=2.718281828459045, sparse=False, tol=1e-12)[source]¶; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters. rhoqutip.QobjFirst density matrix (or ket which will be converted to a density; matrix). sigmaqutip.QobjSecond density matrix (or ket which will be converted to a density; matrix). base{e,2}Base of logarithm. Defaults to e. sparseboolFlag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False. tolfloatTolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns. rel_entfloatValue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. References; See Nielsen & Chuang, “Quantum Computation and Quantum Information”,; Section 11.3.1, pg. 511",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:60314,log,logarithm,60314,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['log'],['logarithm']
Testability,"45, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters. rhoqobjsensity matrix or ket/bra vector. Returns. entropyfloatLinear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters. rhoqobjDensity matrix for composite quantum systems. selAint/listint or list of first selected density matrix components. selBint/listint or list of second selected density matrix components. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_mutfloatMutual information between selected components. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy of density matrix. Parameters. rhoqobjDensity matrix. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. entropyfloatVon-Neumann entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. Density Matrix Metrics¶; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators. fidelity(A, B)[source]¶; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. fidfloatFidelity pseudo-metric between A and B. Examples; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:44476,log,logarithm,44476,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['log'],['logarithm']
Testability,"6 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simon Cross); Updated the version of cibuildwheel used to build wheels to 2.3.0. (#1747, #1751 by Simon Cross); Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (#1779 by Simon Cross); Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (#1777 by Simon Cross); Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X impor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:7872,test,tests,7872,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['test'],['tests']
Testability,"95). hilbert_dist(A, B)[source]¶; Returns the Hilbert-Schmidt distance between two density matrices A & B. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. distfloatHilbert-Schmidt distance between density matrices. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. tolfloatTolerance used by sparse eigensolver, if used. (0=Machine precision). sparse{False, True}Use sparse eigensolver. Returns. tracedistfloatTrace distance between A and B. Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(tracedist(x,y), 0.9705143161472971). unitarity(oper)[source]¶; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map’s superoperator representation. Parameters. operQobjQuantum map under consideration. Returns. ufloatUnitarity of oper. Continuous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters. basislistList of operators that defines the basis for the correlation matrix. rhoQobjDensity matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns. corr_matndarrayA 2-dimensional array of correlation ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:66769,test,testing,66769,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['test'],['testing']
Testability,"98j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuT",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-states.html:16477,test,testing,16477,docs/4.6/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html,2,['test'],['testing']
Testability,"98j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuT",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-states.html:16535,test,testing,16535,docs/4.7/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html,2,['test'],['testing']
Testability,":; op_type_count[1] += 1; self.ops.append(EvoElement(op[0], _StrWrapper(op[1]),; op[1], ""string"")); elif type_ == 3:; op_type_count[2] += 1; self.ops.append(EvoElement(; op[0],; _CubicSplineWrapper(tlist, op[1], args=self.args),; op[1].copy(), ""array"")); elif type_ == 4:; op_type_count[3] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""spline"")). nops = sum(op_type_count); if all([op_t == 0 for op_t in op_type]):; self.type = ""cte""; elif op_type_count[0] == nops:; self.type = ""func""; elif op_type_count[1] == nops:; self.type = ""string""; elif op_type_count[2] == nops:; self.type = ""array""; elif op_type_count[3] == nops:; self.type = ""spline""; elif op_type_count[0]:; self.type = ""mixed_callable""; else:; self.type = ""mixed_compilable"". try:; if not self.cte:; self.cte = self.ops[0].qobj; # test is all qobj are compatible (shape, dims); for op in self.ops[1:]:; self.cte += op.qobj; self.cte *= 0.; self.dummy_cte = True; else:; cte_copy = self.cte.copy(); # test is all qobj are compatible (shape, dims); for op in self.ops:; cte_copy += op.qobj; except Exception as e:; raise TypeError(""Qobj not compatible."") from e. if not self.ops:; self.const = True; self.num_obj = (len(self.ops) if self.dummy_cte else len(self.ops) + 1); self._args_checks(); if e_ops:; for i, dargs in enumerate(self.dynamics_args):; if dargs[1] == ""expect"" and isinstance(dargs[2], int):; self.dynamics_args[i] = (dargs[0], ""expect"",; QobjEvo(e_ops[dargs[2]])); if state0 is not None:; self._dynamics_args_update(0., state0). def _td_format_check(self, Q_object):; if isinstance(Q_object, Qobj):; return 0; if isinstance(Q_object, (FunctionType, BuiltinFunctionType, partial)):; return 1; if isinstance(Q_object, list):; return [self._td_op_type(element) for element in Q_object] or -1; raise TypeError(""Incorrect Q_object specification""). def _td_op_type(self, element):; if isinstance(element, Qobj):; return 0; try:; op, td = element; except (TypeError, ValueError) as exc:; raise TypeError(""Incorrect Q_o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:15565,test,test,15565,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,4,['test'],['test']
Testability,":; op_type_count[1] += 1; self.ops.append(EvoElement(op[0], _StrWrapper(op[1]),; op[1], ""string"")); elif type_ == 3:; op_type_count[2] += 1; self.ops.append(EvoElement(; op[0],; _CubicSplineWrapper(tlist, op[1], args=self.args),; op[1].copy(), ""array"")); elif type_ == 4:; op_type_count[3] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""spline"")). nops = sum(op_type_count); if all([op_t == 0 for op_t in op_type]):; self.type = ""cte""; elif op_type_count[0] == nops:; self.type = ""func""; elif op_type_count[1] == nops:; self.type = ""string""; elif op_type_count[2] == nops:; self.type = ""array""; elif op_type_count[3] == nops:; self.type = ""spline""; elif op_type_count[0]:; self.type = ""mixed_callable""; else:; self.type = ""mixed_compilable"". try:; if not self.cte:; self.cte = self.ops[0].qobj; # test is all qobj are compatible (shape, dims); for op in self.ops[1:]:; self.cte += op.qobj; self.cte *= 0.; self.dummy_cte = True; else:; cte_copy = self.cte.copy(); # test is all qobj are compatible (shape, dims); for op in self.ops:; cte_copy += op.qobj; except Exception as e:; raise TypeError(""Qobj not compatible."") from e. if not self.ops:; self.const = True; self.num_obj = (len(self.ops) if self.dummy_cte else len(self.ops) + 1); self._args_checks(); if e_ops:; for i, dargs in enumerate(self.dynamics_args):; if dargs[1] == ""expect"" and isinstance(dargs[2], int):; self.dynamics_args[i] = (dargs[0], ""expect"",; QobjEvo(e_ops[dargs[2]])); if state0 is not None:; self._dynamics_args_update(0., state0). def _td_format_check_single(self, Q_object, tlist=None):; op_type = []. if isinstance(Q_object, Qobj):; op_type = 0; elif isinstance(Q_object, (FunctionType,; BuiltinFunctionType, partial)):; op_type = 1; elif isinstance(Q_object, list):; if (len(Q_object) == 0):; op_type = -1; for op_k in Q_object:; if isinstance(op_k, Qobj):; op_type.append(0); elif isinstance(op_k, list):; if not isinstance(op_k[0], Qobj):; raise TypeError(""Incorrect Q_object specification""); elif len(op_k) ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:15402,test,test,15402,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['test'],['test']
Testability,":; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_args['permc_spec'],; drop_tol=ss_args['drop_tol'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; fill_factor=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). P_x = lambda x: P.solve(x); M = LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)). if _scipy_check:; L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:17936,log,logger,17936,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,7,['log'],['logger']
Testability,":; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_args['permc_spec'],; drop_tol=ss_args['drop_tol'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; fill_factor=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). P_x = lambda x: P.solve(x); M = LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:20227,log,logger,20227,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,2,['log'],['logger']
Testability,"; """"""; import numpy as np; # QuTiP; from qutip import Qobj; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', prop_type='DEF',; fid_type='DEF', phase_option=None, fid_err_scale_factor=None,; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. drift : Qobj; the underlying dynamics generator of the system. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transfor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:4949,log,logging,4949,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['log'],['logging']
Testability,"; ""function, which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)). # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse. [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values. Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs. self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs. if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)). if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs,; self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; sys",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:30171,log,logging,30171,docs/4.6/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html,4,['log'],['logging']
Testability,"; A density matrix. mask : list / array; A mask that selects which subsystems should be transposed. method : str; choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:; rho_pr: :class:`qutip.qobj`; A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns:; concur : float; Concurrence. References. [1]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:; rho : qobj; Density matrix of composite object. selB : int/list; Selected components for density matrix B. base : {e,2}; Base of logarithm. sparse : {False,True}; Use sparse eigensolver. Returns:; ent_cond : float; Value of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:; rho : qobj; sensity matrix or ket/bra vector. Returns:; entropy : float; Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters:; rho : qobj; Density matrix for composite quantum systems. selA : int/list; int or list of first selected density matrix components. selB : int/list; int or list of second selected density matrix components. base : {e,2}; Base of logarithm. sparse : {False,True}; Use sparse eigensolver. Returns:; ent_mut : float; Mutual information between selected components. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Vo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:44726,log,logarithm,44726,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['log'],['logarithm']
Testability,"; Classes that define the dynamics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls = np.array(ctrls, dtype=object); except:; pass. if isinstance(c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/dynamics.html:3274,log,logging,3274,docs/4.5/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/dynamics.html,1,['log'],['logging']
Testability,"; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators.; """""". __all__ = ['steadystate', 'steady', 'build_preconditioner',; 'pseudo_inverse']. import warnings; import time; import scipy; import numpy as np; from numpy.linalg import svd; from scipy import prod; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (use_solver, splu, spilu, spsolve, eigs,; LinearOperator, gmres, lgmres, bicgstab); from qutip.qobj import Qobj, issuper, isoper; from qutip.superoperator import liouvillian, vec2mat; from qutip.sparse import sp_permute, sp_bandwidth, sp_reshape, sp_profile; from qutip.graph import reverse_cuthill_mckee, weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.utilities import _version2int; import qutip.logging. logger = qutip.logging.get_logger(); logger.setLevel('DEBUG'). # test if scipy is recent enought to get L & U factors from superLU; _scipy_check = _version2int(scipy.__version__) >= _version2int('0.14.0'). def _default_steadystate_args():; def_args = {'method': 'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'use_umfpack': False, 'weight': None,; 'use_precond': False, 'all_states': False,; 'M': None, 'x0': None, 'drop_tol': 1e-4, 'fill_factor': 100,; 'diag_pivot_thresh': None, 'maxiter': 1000, 'tol': 1e-9,; 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', 'restart': 20,; 'return_info': False, 'info': {'perm': []}}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parame",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:4324,log,logger,4324,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['log'],['logger']
Testability,"; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Generating Random Quantum States & Operators; Composite random objects. « Saving QuTiP Obj... Modifying Intern... ». Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state generators for simulations, theorem evaluation, and code testing:. Function; Description. rand_ket; Random ket-vector. rand_dm; Random density matrix. rand_herm; Random Hermitian matrix. rand_unitary; Random Unitary matrix. See the API documentation: Random Operators and States for details.; In all cases, these functions can be called with a single parameter \(N\) that indicates a \(NxN\) matrix (rand_dm, rand_herm, rand_unitary), or a \(Nx1\) vector (rand_ket), should be generated. For example:; In [2]: rand_ket(5); Out[2]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[-0.39285336+0.27024047j]; [-0.51803588+0.10328369j]; [-0.58850701-0.16960316j]; [-0.20872011+0.08251858j]; [-0.23355115+0.11654335j]]. or; In [3]: rand_herm(5); Out[3]: ; Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = True; Qobj data =; [[-0.78906375+0.j -0.49042711+0.01532022j -0.20366873+0.17308185j; -0.33542127-0.1744431j 0.00000000+0.j ]; [-0.4",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-random.html:1774,test,testing,1774,docs/3.0.1/guide/guide-random.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-random.html,1,['test'],['testing']
Testability,"; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:25459,log,logger,25459,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['log'],['logger']
Testability,"; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:20680,log,logging,20680,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,10,['log'],['logging']
Testability,"; from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. try:; import cython; use_cython = [True]; except:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """"""; def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_ + "".pyx""]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; try:; os.remove(file_); to_del.append(i); except Exception:; if not os.path.isfile(file_):; to_del.append(i). for i in to_del[::-1]:; del self.files[i]. def __del__(self):; self.clean(). coeff_files = _file_list(). class _StrWrapper:; def __init__(self, code):; self.code = ""_out = "" + code. def __call__(self, t, args={}):; env = {""t"": t}; env.update(args); exec(self.code, str_env, env); return env[""_out""]. class _CubicSplineWrapper:; # Using scipy's CubicSpline since Qutip's one; # only accept linearly dist",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:3536,log,log,3536,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,2,['log'],['log']
Testability,"; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], 'csc'); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, 'csc'); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % round(; old_band/rcm_band, 1)); logger.debug('Profile reduction factor: %f' % round(; old_pro/rcm_pro, 1)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-6, itertol=1e-5, method='solve',; use_umfpack=False, use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_umfpack=use_umfpack, use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = prod(L.dims[0][0]); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:12344,log,logger,12344,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['log'],['logger']
Testability,"; options=dict(ILU_MILU=ss_args['ILU_MILU'])). P_x = lambda x: P.solve(x); M = LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precondition(L, n, ss_args); if ss_args['M",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:20683,log,logger,20683,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,2,['log'],['logger']
Testability,"; perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve',; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if ss_args['solver'] == 'mkl':; has_mkl = 1; else:; has_mkl = 0. ss_lu_liouv_list = _steadystate_LU_liouvillian(L, ss_args, has_mkl); L, perm, perm2, rev_perm, ss_args = ss_lu_liouv_list; if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. if ss_args['solver'] == 'scipy':; ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not ss_args['solver'] == 'mkl':; # Use superLU solver; orig_nnz = L.nnz; _direct_start = time.time(); lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])); v = lu.solv",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:14667,log,logger,14667,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,4,['log'],['logger']
Testability,"; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = prod(rhoss.shape); L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); L.sort_indices(); orig_nnz = L.nnz. # start with all ones as RHS; v = np.ones(n, dtype=complex). if ss_args['use_rcm']:; if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); v = v[np.ix_(perm,)]; if settings.debug:; new_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' %; round(old_band/new_band, 2)). _power_start = time.time(); # Get LU factors; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; v = lu.solve(v); v = v / la.norm(v, np.inf); it += 1; if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'). _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v, np.inf); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:23206,log,logger,23206,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['log'],['logger']
Testability,"; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None; ; if not self.ubound is None and not self.lbound is None:; if self.ubound < self.lbound:; raise ValueError(""ubound cannot be less the lbound""). d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html:8320,log,logger,8320,docs/4.1/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html,5,['log'],['logger']
Testability,"; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters. rhoqobjsensity matrix or ket/bra vector. Returns. entropyfloatLinear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters. rhoqobjDensity matrix for composite quantum systems. selAint/listint or list of first selected density matrix components. selBint/listint or list of second selected density matrix components. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_mutfloatMutual information between selected components. entropy_relative(rho, sigma, base=2.718281828459045, sparse=False, tol=1e-12)[source]¶; Calculates the relative entropy S(r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:59799,log,logarithm,59799,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['log'],['logarithm']
Testability,"; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/entropy.html:4722,log,logarithmic,4722,docs/4.2/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/entropy.html,8,['log'],['logarithmic']
Testability,"; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iteration",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:28100,log,logger,28100,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,4,['log'],['logger']
Testability,"= 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. def _entropy_relative(rho, sigma, base=e, sparse=False):; """"""; ****NEEDS TO BE WORKED ON****. Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : qobj; First density matrix.; sigma : qobj; Second density matrix.; base : {e,2}; Base of logarithm. Returns; -------; rel_ent : float; Value of relative entropy. """"""; if rho.type != 'oper' or sigma.type != 'oper':; raise TypeError(""Inputs must be density matrices..""); # sigma terms; svals = sp_eigs(sigma.data, sigma.isherm, vecs=False, sparse=sparse); snzvals = svals[svals != 0]; if base == 2:; slogvals = log2(snzvals); elif base == e:; slogvals = log(snzvals); else:; raise ValueError(""Base must be 2 or e.""); # rho terms; rvals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); rnzvals = rvals[rvals != 0]; # calculate tr(rho*log sigma); rel_trace = float(real(sum(rnzvals * slogvals))); return -entropy_vn(rho, base, sparse) - rel_trace. [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/entropy.html:7063,log,log,7063,docs/4.2/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/entropy.html,6,['log'],['log']
Testability,"= None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None. if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False. if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j,; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k). if ecs:; ecs.wall_time_prop_compute = \; timeit.default_timer() - time_start. if ecs: time_start = timeit.default_timer(); # compute the forward propagation; R = range(n_ts); for k in R:; if dyn.oper_dtype == Qobj:; dyn._fwd_evo[k+1] = dyn._prop[k]*dyn._fwd_evo[k]; else:; dyn._fwd_evo[k+1] = dyn._prop[k].dot(dyn._fwd_evo[k]). if ecs:; ecs.wall_time_fwd_prop_compute = \; timeit.default_timer() - time_start; time_start = timeit.default_timer(); # compute the onward propagation; if dyn.fid_computer.uses_onwd_evo:; dyn._onwd_evo[n_ts-1] = dyn._prop[n_ts-1]; R = range(n_ts-2, -1, -1); for k in R:; if dyn.oper_dtype == Qobj:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1]*dyn._prop[k]; else:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1].dot(dyn._prop[k]). if dyn.fid_comp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/tslotcomp.html:9849,log,logger,9849,docs/4.4/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/tslotcomp.html,1,['log'],['logger']
Testability,"= Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = prod(rhoss.shape); L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); L.sort_indices(); orig_nnz = L.nnz. # start with all ones as RHS; v = np.ones(n, dtype=complex). if ss_args['use_rcm']:; if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); v = v[np.ix_(perm,)]; if settings.debug:; new_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' %; round(old_band/new_band, 2)). _power_start = time.time(); # Get LU factors; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; v = lu.solve(v); v = v / la.norm(v, np.inf); it += 1; if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'). _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v, np.inf); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = sp.eye(rhoss.shape[0], rhoss.shape[0], format='coo'); trow = sp_reshape(trow, (1, n)); data = v / sum(trow.dot(v)); else:; data = data / la.norm(v). data = sp.csr_matrix(vec2mat(data)); rhoss.data = 0.5 * (data + data.conj().T); rhoss.isherm = True; if ss_args['return_info']:; return rhoss, ss_args['info']; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:23602,log,logger,23602,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['log'],['logger']
Testability,"= True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]. [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs"""""". if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeError(""U",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:33385,log,logging,33385,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,6,['log'],['logging']
Testability,"= True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]; ; [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs""""""; ; if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeErro",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:28884,log,logging,28884,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,4,['log'],['logging']
Testability,"= _steadystate_LU_liouvillian(L, ss_args, has_mkl); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not has_mkl:; # Use superLU solver; orig_nnz = L.nnz; _direct_start = time.time(); lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])); v = lu.solve(b); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end - _direct_start; if (settings.debug or ss_args['return_info']) and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['lu_fill_factor'] = (L_nnz + U_nnz)/L.nnz; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz + U_nnz)/orig_nnz)). else: # Use MKL solver; if len(ss_args['info']['perm']) !=0:; in_perm = np.arange(n**2, dtype=np.int32); else:; in_perm = None; _direct_start = time.time(); v = mkl_spsolve(L, b, perm = in_perm, verbose = ss_args['verbose']); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end-_direct_start. if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = dense2D_to_fastcsr_fmode(vec2mat(v), n, n); data = 0.5 * (data + data.H); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_direct_dense(L, ss_args):; """"""; Direct solver that use numpy dense matrices. Suitable for; small system, with a few states.; """"""; if settings.debug:; logger.debug('Starting direct dense solver.'). dim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:14058,log,logger,14058,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['log'],['logger']
Testability,"= b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. if ss_args['solver'] == 'scipy':; ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not ss_args['solver'] == 'mkl':; # Use superLU solver; orig_nnz = L.nnz; _direct_start = time.time(); lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])); v = lu.solve(b); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end - _direct_start; if (settings.debug or ss_args['return_info']):; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['lu_fill_factor'] = (L_nnz + U_nnz)/L.nnz; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz + U_nnz)/orig_nnz)). else: # Use MKL solver; if len(ss_args['info']['perm']) != 0:; in_perm = np.arange(n**2, dtype=np.int32); else:; in_perm = None; _direct_start = time.time(); v = mkl_spsolve(L, b, perm=in_perm, verbose=ss_args['verbose'],; max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end-_direct_start. if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf); ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = dense2D_to_fastcsr_fmode(vec2mat(v), n, n); data = 0.5 * (data + data.H); if ss_args['return_info']:; return Qobj(data, d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:16051,log,logger,16051,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,4,['log'],['logger']
Testability,"= ket2dm(A); if B.isket or B.isbra:; B = ket2dm(B). if A.dims != B.dims:; raise TypeError('A and B do not have same dimensions.'). return np.arccos(fidelity(A, B)). [docs]def hellinger_dist(A, B, sparse=False, tol=0):; """"""; Calculates the quantum Hellinger distance between two density matrices. Formula:; hellinger_dist(A, B) = sqrt(2-2*Tr(sqrt(A)*sqrt(B))). See: D. Spehner, F. Illuminati, M. Orszag, and W. Roga, ""Geometric; measures of quantum correlations with Bures and Hellinger distances""; arXiv:1611.03449. Parameters; ----------; A : :class:`qutip.Qobj`; Density matrix or state vector.; B : :class:`qutip.Qobj`; Density matrix or state vector with same dimensions as A.; tol : float; Tolerance used by sparse eigensolver, if used. (0=Machine precision); sparse : {False, True}; Use sparse eigensolver. Returns; -------; hellinger_dist : float; Quantum Hellinger distance between A and B. Ranges from 0 to sqrt(2). Examples; --------; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(hellinger_dist(x,y), 1.3725145002591095); """"""; if A.isket or A.isbra:; sqrtmA = ket2dm(A); else:; sqrtmA = A.sqrtm(sparse=sparse, tol=tol); if B.isket or B.isbra:; sqrtmB = ket2dm(B); else:; sqrtmB = B.sqrtm(sparse=sparse, tol=tol). if sqrtmA.dims != sqrtmB.dims:; raise TypeError(""A and B do not have compatible dimensions.""). product = sqrtmA*sqrtmB; eigs = sp_eigs(product.data,; isherm=product.isherm, vecs=False, sparse=sparse, tol=tol); # np.maximum() is to avoid nan appearing sometimes due to numerical; # instabilities causing np.sum(eigs) slightly (~1e-8) larger than 1; # when hellinger_dist(A, B) is called for A=B; return np.sqrt(2.0 * np.maximum(0., (1.0 - np.real(np.sum(eigs))))). [docs]def dnorm(A, B=None, solver=""CVXOPT"", verbose=False, force_solve=False,; sparse=True):; """"""; Calculates the diamond norm of the quantum map q_oper, using; the simplified semidefinite program of [Wat13]_. The diamond norm SDP is solved by using CVXPY_. Parameters; ---------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/metrics.html:7541,test,testing,7541,docs/4.7/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html,2,['test'],['testing']
Testability,"=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). M = LinearOperator((n ** 2, n ** 2), matvec=P.solve); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except Exception:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precondition(L, n, ss_args); if ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/steadystate.html:19843,log,logger,19843,docs/4.7/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html,2,['log'],['logger']
Testability,">>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; >>> print(q * x); ------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-33-0b599f41213e> in <module>; ----> 1 print(q * x). ~/Documents/qutip_dev/qutip/qutip/qobj.py in __mul__(self, other); 553; 554 else:; --> 555 raise TypeError(""Incompatible Qobj shapes""); 556; 557 elif isinstance(other, np.ndarray):. TypeError: Incompatible Qobj shapes. In addition, the logic operators “is equal” == and “is not equal” != are also supported. Functions operating on Qobj class¶; Like attributes, the quantum object class has defined functions (methods) that operate on Qobj class instances. For a general quantum object Q:. Function; Command; Description. Check Hermicity; Q.check_herm(); Check if quantum object is Hermitian. Conjugate; Q.conj(); Conjugate of quantum object. Cosine; Q.cosm(); Cosine of quantum object. Dagger (adjoint); Q.dag(); Returns adjoint (dagger) of object. Diagonal; Q.diag(); Returns the diagonal elements. Diamond Norm; Q.dnorm(); Returns the diamond norm. Eigenenergies; Q.eigenenergies(); Eigenenergies (values) of operator. Eigenstates; Q.eigenstates(); Returns eigenvalues and eigenvectors. Eliminate States; Q.eliminate_states(inds); Returns quantum object with states in; list inds removed. Exponential; Q.expm(); Matrix exponential of operator. Extract States; Q.extract_states(inds); Qobj with states listed in inds only. Full; Q.full(); Returns full (not spars",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-basics.html:10012,log,logic,10012,docs/4.6/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html,4,['log'],['logic']
Testability,"@email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:3144,log,logging,3144,docs/4.6/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html,12,['log'],"['logger', 'logging']"
Testability,"A); else:; raise TypeError(""Cannot compute trace (not square)""); except:; # assume input is already scalar and hence assumed; # to be the prenormalised scalar value, e.g. fidelity; norm = A; return np.abs(norm) / self.dimensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:14156,log,logging,14156,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,10,['log'],['logging']
Testability,"ABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; Classes that enable the storing of historical objects created during the; pulse optimisation.; These are intented for debugging.; See the optimizer and dynamics objects for instrutcions on how to enable; data dumping.; """""". import os; import numpy as np; import copy; # QuTiP logging; import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); # QuTiP control modules; import qutip.control.io as qtrlio; from numpy.compat import asbytes. DUMP_DIR = ""~/.qtrl_dump"". def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Dump(object):; """"""; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes; ----------; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level : string; level of data dumping: SUMMARY, FULL or CUSTOM; See prop",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dump.html:2394,log,logger,2394,docs/4.1/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dump.html,8,['log'],['logger']
Testability,"AL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0. These are the periodic options. SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave. If a Dynamics object is passed in then this is used ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:2597,log,logging,2597,docs/4.6/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html,6,['log'],"['logger', 'logging']"
Testability,"AL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html:2568,log,logging,2568,docs/4.1/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html,18,['log'],"['logger', 'logging']"
Testability,"APE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html:3703,log,logging,3703,docs/4.5/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/tslotcomp.html,1,['log'],['logging']
Testability,"Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:19126,test,tests,19126,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,6,['test'],"['testing', 'tests']"
Testability,"BUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and ; not 'pulse_action' in guess_pu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:38456,log,logger,38456,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,10,['log'],['logger']
Testability,"BUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs':num_coeffs,; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type:; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and; not 'pulse_action' in guess_pulse_params",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:38089,log,logger,38089,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,2,['log'],['logger']
Testability,"Bug Fixes; Version 2.0.0 (June 01, 2012). New Features; Version 1.1.4 (May 28, 2012). Bug Fixes; Version 1.1.3 (November 21, 2011). New Functions; Bug Fixes; Version 1.1.2 (October 27, 2011). Bug Fixes; Version 1.1.1 (October 25, 2011). New Functions; Bug Fixes; Version 1.1.0 (October 04, 2011). New Functions; Bug Fixes; Version 1.0.0 (July 29, 2011). Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Change Log. Change Log¶. QuTiP 4.7.5 (2024-01-29)¶; Patch release for QuTiP 4.7. It adds support for SciPy 1.12. Bug Fixes¶. Remove use of scipy.<numpy-func> in parallel.py, incompatible with scipy==1.12 (#2305 by Evan McKinney). QuTiP 4.7.4 (2024-01-15)¶. Bug Fixes¶. Adapt to deprecation from matplotlib 3.8 (#2243, reported by Bogdan Reznychenko); Fix name of temp files for removal after use. (#2251, reported by Qile Su); Avoid integer overflow in Qobj creation. (#2252, reported by KianHwee-Lim); Ignore DeprecationWarning from pyximport (#2287); Add partial support and tests for python 3.12. (#2294). Miscellaneous¶. Rework choi_to_kraus, making it rely on an eigenstates solver that can choose eigh if the Choi matrix is Hermitian, as it is more numerically stable. (#2276, by Bogdan Reznychenko); Rework kraus_to_choi, making it faster (#2283, by Bogdan Reznychenko and Rafael Haenel). QuTiP 4.7.3 (2023-08-22)¶. Bug Fixes¶. Non-oper qobj + scalar raise an error. (#2208 reported by vikramkashyap); Fixed issue where extract_states did not preserve hermiticity.; Fixed issue where rand_herm did not set the private attribute _isherm to True. (#2214 by AGaliciaMartinez); ssesolve average states to density matrices (#2216 reported by BenjaminDAnjou). Miscellaneous¶. Exclude cython 3.0.0 from requirement (#2204); Run in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28)¶; This is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes¶. Fix setting of sso.m_ops in ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:2941,test,tests,2941,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['test'],['tests']
Testability,"CES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:2710,log,logging,2710,docs/4.5/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html,3,['log'],['logging']
Testability,"CLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/entropy.html:2330,log,log,2330,docs/4.6/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html,2,['log'],['log']
Testability,"Data, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012)¶. New Features¶. New method for generating Wigner functions based on Laguerre polynomials.; coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values.; Unittests now use nose and can be run after installation.; Added iswap and sqrt-iswap gates.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:40894,log,logarithmic,40894,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['log'],['logarithmic']
Testability,"EBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:38421,log,logger,38421,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,10,['log'],['logger']
Testability,"EBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs':num_coeffs,; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type:; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and; not 'pul",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:38054,log,logger,38054,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,2,['log'],['logger']
Testability,"Error(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. def _entropy_relative(rho, sigma, base=e, sparse=False):; """"""; ****NEEDS TO BE WORKED ON**** (after 2.0 release). Calculates the relative entropy S(rho||sigma) between two density; matrices.. Parameters; ----------; rho : qobj; First density matrix.; sigma : qobj; Second density matrix.; base : {e,2}; Base of logarithm. Returns; -------; rel_ent : float; Value of relative entropy. """"""; if rho.type != 'oper' or sigma.type != 'oper':; raise TypeError(""Inputs must be density matrices..""); # sigma terms; svals = sp_eigs(sigma.data, sigma.isherm, vecs=False, sparse=sparse); snzvals = svals[svals != 0]; if base == 2:; slogvals = log2(snzvals); elif base == e:; slogvals = log(snzvals); else:; raise ValueError(""Base must be 2 or e.""); # rho terms; rvals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); rnzvals = rvals[rvals != 0]; # calculate tr(rho*log sigma); rel_trace = float(real(sum(rnzvals * slogvals))); return -entropy_vn(rho, base, sparse) - rel_trace. [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a slected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html:7598,log,log,7598,docs/3.1.0/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html,1,['log'],['log']
Testability,"FITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/entropy.html:2732,log,logarithm,2732,docs/4.6/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html,2,['log'],['logarithm']
Testability,"GLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators.; """""". __all__ = ['fidelity', 'tracedist', 'bures_dist', 'bures_angle',; 'hellinger_dist', 'hilbert_dist', 'average_gate_fidelity',; 'process_fidelity', 'unitarity', 'dnorm']. import numpy as np; from scipy import linalg as la; import scipy.sparse as sp; from qutip.sparse import sp_eigs; from qutip.states import ket2dm; from qutip.superop_reps import to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem, dnorm_sparse_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger(). try:; import cvxpy; except ImportError:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/metrics.html:2891,log,logging,2891,docs/4.6/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html,6,['log'],"['logger', 'logging']"
Testability,"Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each ti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:19901,log,logger,19901,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,10,['log'],['logger']
Testability,"INESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:2749,log,logging,2749,docs/4.5/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html,9,['log'],"['logger', 'logging']"
Testability,"INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~qutip.control.optimresult.OptimResult`,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc.; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs':num_coeffs,; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type:; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and; not 'pul",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:47989,log,logger,47989,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,2,['log'],['logger']
Testability,"INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to ``None`` will suppress the output; of files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs': num_coeffs,; 'init_coeff_scaling': init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type:; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and; not 'pulse_action' in guess_pulse_para",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:38587,log,logger,38587,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['log'],['logger']
Testability,"INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to ``None`` will suppress the output; of files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs': num_coeffs,; 'init_coeff_scaling': init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type:; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and; not 'p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:38552,log,logger,38552,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['log'],['logger']
Testability,"IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power']. from numpy import e, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/entropy.html:2265,log,log,2265,docs/4.5/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/entropy.html,1,['log'],['log']
Testability,"ITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html:2696,log,logging,2696,docs/4.1/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html,5,['log'],['logging']
Testability,"Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Introduction. Introduction¶; Although in some cases, we want to find the stationary states of; a quantum system, often we are interested in the dynamics:; how the state of a system or an ensemble of systems evolves with time. QuTiP provides; many ways to model dynamics.; Broadly speaking, there are two categories; of dynamical models: unitary and non-unitary. In unitary evolution,; the state of the system remains normalized. In non-unitary, or; dissipative, systems, it does not.; There are two kinds of quantum systems: open systems that interact; with a larger environment and closed systems that do not.; In a closed system, the state can be described by a state vector,; although when there is entanglement a density matrix may be; needed instead. When we are modeling an open system, or an ensemble; of systems, the use of the densit",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html:1079,Log,Log,1079,docs/4.7/guide/dynamics/dynamics-intro.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html,1,['Log'],['Log']
Testability,Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; options = Options(). the properties and default values of this class can be view via the print function:; print(options). Output:; Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These pr,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:1107,Log,Log,1107,docs/4.7/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html,1,['Log'],['Log']
Testability,Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian ,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-dynamics.html:1109,Log,Log,1109,docs/4.7/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html,1,['Log'],['Log']
Testability,"L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvilli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:26476,log,logger,26476,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['log'],['logger']
Testability,"L, b, perm=in_perm, verbose=ss_args['verbose'],; max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end-_direct_start. if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf); ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = dense2D_to_fastcsr_fmode(vec2mat(v), n, n); data = 0.5 * (data + data.H); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_direct_dense(L, ss_args):; """"""; Direct solver that use numpy dense matrices. Suitable for; small system, with a few states.; """"""; if settings.debug:; logger.debug('Starting direct dense solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L = L.data.todense(); L[0, :] = np.diag(ss_args['weight']*np.ones(n)).reshape((1, n ** 2)); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_ba",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:16944,log,logger,16944,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['log'],['logger']
Testability,"Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:18773,log,logging,18773,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,3,['log'],['logging']
Testability,"Monte Carlo solver:; pip install qutip --install-option=--with-f90mc. More detailed platform-dependent installation alternatives are given below. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). Installation on MS Windows¶; We are recommending and supporting installation of Q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/installation.html:5803,test,test,5803,docs/4.0.2/installation.html,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html,1,['test'],['test']
Testability,"NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual',; 'concurrence', 'entropy_conditional', 'entangling_power']. from numpy import e, real, sort, sqrt; from scipy import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.qip.gates import swap. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html:3868,log,logarithm,3868,docs/3.1.0/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html,1,['log'],['logarithm']
Testability,"NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; Classes that enable the storing of historical objects created during the; pulse optimisation.; These are intented for debugging.; See the optimizer and dynamics objects for instrutcions on how to enable; data dumping.; """""". import os; import numpy as np; import copy; # QuTiP logging; import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); # QuTiP control modules; import qutip.control.io as qtrlio; from numpy.compat import asbytes. DUMP_DIR = ""~/.qtrl_dump"". def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Dump(object):; """"""; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes; ----------; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level : string; leve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dump.html:2357,log,logging,2357,docs/4.1/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dump.html,8,['log'],['logging']
Testability,"NSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~qutip.control.optimresult.OptimResult`,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc.; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs':num_coeffs,; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type:; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:47960,log,logging,47960,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,2,['log'],['logging']
Testability,"NSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). optim = create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=num_tslots, evo_time=evo_time, tau=tau,; amp_lbound=amp_lbound, amp_ubound=amp_ubound,; fid_err_targ=fid_err_targ, min_grad=min_grad,; max_iter=max_iter, max_wall_time=max_wall_time,; optim_alg=optim_alg, max_metric_corr=max_metric_corr,; accuracy_factor=accuracy_factor,; dyn_type=dyn_type, prop_type=prop_type,; fid_type=fid_type, phase_option=phase_option,; fid_err_scale_factor=fid_err_scale_factor,; amp_update_mode=amp_update_mode, init_pulse_type=init_pulse_type,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics; p_gen = optim.pulse_generator. if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nContr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:11031,log,logger,11031,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['log'],['logger']
Testability,"Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import numpy as np; import scipy.linalg as la; from six import string_types; # QuTiP logging; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl. [docs]class Dynamics:; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before any of the methods; can be used. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. num_tslots : integer; Number of timeslots, aka timeslices. num_ctrls : integer; Number of controls.; Note this is set when get_num_ctrls is called based on the; l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:5026,log,logging,5026,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['log'],['logging']
Testability,"ODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power']. from numpy import e, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/entropy.html:2667,log,logarithm,2667,docs/4.5/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/entropy.html,1,['log'],['logarithm']
Testability,"OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power']. from numpy import e, real, sort, sqrt; from scipy import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.qip.gates import swap; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/entropy.html:2680,log,logarithm,2680,docs/4.2/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/entropy.html,5,['log'],['logarithm']
Testability,"OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:4599,log,logging,4599,docs/4.5/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html,3,['log'],"['logger', 'logging']"
Testability,"PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains functions that implement the GRAPE algorithm for; calculating pulse sequences for quantum systems.; """""". __all__ = ['plot_grape_control_fields',; 'grape_unitary', 'cy_grape_unitary', 'grape_unitary_adaptive']. import warnings; import time; import numpy as np; from scipy.interpolate import interp1d; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.ui.progressbar import BaseProgressBar; from qutip.control.cy_grape import cy_overlap, cy_grape_inner; from qutip.qip.gates import gate_sequence_product. import qutip.logging; logger = qutip.logging.get_logger(). [docs]class GRAPEResult:; """"""; Class for representing the result of a GRAPE simulation. Attributes; ----------; u : array; GRAPE control pulse matrix. H_t : time-dependent Hamiltonian; The time-dependent Hamiltonian that realize the GRAPE pulse sequence. U_f : Qobj; The final unitary transformation that is realized by the evolution; of the system with the GRAPE generated pulse sequences.; """"""; def __init__(self, u=None, H_t=None, U_f=None):. self.u = u; self.H_t = H_t; self.U_f = U_f. [docs]def plot_grape_control_fields(times, u, labels, uniform_axes=False):; """"""; Plot a series of plots showing the GRAPE control fields given in the; given control pulse matrix u. Parameters; ----------; times : array; Time coordinate array. u : array; Control pulse matrix. labels : list; List of labels for each control pulse sequence in the control pulse; matrix. uniform_axes : bool; Whether or not to plot all pulse sequences using the same y-axis scale.; """"""; import ma",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:3880,log,logging,3880,docs/3.1.0/modules/qutip/control/grape.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html,2,['log'],"['logger', 'logging']"
Testability,"QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Generating Random Quantum States & Operators. Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state, unitary and channel generators for simulations, Monte Carlo evaluation, theorem evaluation, and code testing.; Each of these objects can be sampled from one of several different distributions including the default distributions; used by QuTiP versions prior to 3.2.0.; For example, a random Hermitian operator can be sampled by calling rand_herm function:; In [1]: rand_herm(5); Out[1]: ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[ 0.65059092+0.j 0.48575167+0.37493153j 0.66557238+0.08941232j; 0. +0.j -0.19892853-0.58575629j]; [ 0.48575167-0.37493153j 0. +0.j 0.049938 +0.01111378j; -0.15309387-0.63961294j -0.55094397-0.6883588j ]; [ 0.66557238-0.08941232j 0.049938 -0.01111378j 0.55027224+0.j; 0. +0.j 0.66793421+0.20401768j]; [ 0. +0.j -0.15309387+0.63961294j 0. +0.j; 0.52646769+0.j 0.80389708+0.60961187j]; [-0.19892853+0.58575629j -0.55094397+0.6883588j 0.66793421-0.20401768j; 0.80389708-0.60961187j 0.22957225+0.j ]]. Random Variable Type; Samplin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-random.html:1144,test,testing,1144,docs/4.5/guide/guide-random.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-random.html,1,['test'],['testing']
Testability,"R BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html:2735,log,logging,2735,docs/4.1/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html,15,['log'],"['logger', 'logging']"
Testability,"RICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators.; """""". __all__ = ['fidelity', 'tracedist', 'bures_dist', 'bures_angle',; 'hilbert_dist', 'average_gate_fidelity', 'process_fidelity',; 'unitarity', 'dnorm']. import numpy as np; from scipy import linalg as la; import scipy.sparse as sp; from qutip.sparse import sp_eigs; from qutip.states import ket2dm; from qutip.superop_reps import to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger(). try:; import cvxpy; except:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> fidelity(x,y); 0.24104350624628332. """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/metrics.html:2822,log,logging,2822,docs/4.3/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/metrics.html,3,['log'],"['logger', 'logging']"
Testability,"RN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k). def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/propcomp.html:4995,log,logger,4995,docs/4.4/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/propcomp.html,1,['log'],['logger']
Testability,"RN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html:4999,log,logger,4999,docs/4.1/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html,9,['log'],['logger']
Testability,"RND; (see PulseGen classes for details); For the CRAB the this the guess_pulse_type. init_pulse_params (dict) – Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; pulse_scaling (float) – Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter; pulse_offset (float) – Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ramping_pulse_type (string) – Type of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:169852,log,logger,169852,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['log'],['logger']
Testability,"RND; (see PulseGen classes for details); For the CRAB the this the guess_pulse_type. init_pulse_params (dict) – Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; pulse_scaling (float) – Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter; pulse_offset (float) – Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ramping_pulse_type (string) – Type of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ramping_pulse_params (dict) – Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:153254,log,logger,153254,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,2,['log'],['logger']
Testability,"Returns:ent_cond : float. Value of conditional entropy. entropy_linear(rho)¶; Linear entropy of a density matrix. Parameters:rho : qobj. sensity matrix or ket/bra vector. Returns:entropy : float. Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters:rho : qobj. Density matrix for composite quantum systems. selA : int/list. int or list of first selected density matrix components. selB : int/list. int or list of second selected density matrix components. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_mut : float. Mutual information between selected components. entropy_vn(rho, base=2.718281828459045, sparse=False)¶; Von-Neumann entropy of density matrix. Parameters:rho : qobj. Density matrix. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:entropy : float. Von-Neumann entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. Density Matrix Metrics¶; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators. fidelity(A, B)¶; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters:A : qobj. Density matrix or state vector. B : qobj. Density matrix or state vector with same dimensions as A. Returns:fid : float. Fidelity pseudo-metric between A and B. Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> fidelity(x,y); 0.24104350624628332. tracedist(A, B, sparse=False, tol=0)¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters:A : qobj. Density matrix or state vector. B : ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:27849,log,logarithm,27849,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['log'],['logarithm']
Testability,"S in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:3712,log,logging,3712,docs/4.6/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html,4,['log'],['logging']
Testability,"SE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs':num_coeffs,; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type:; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and; not 'pul",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:48891,log,logger,48891,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['log'],['logger']
Testability,"Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.brmesolve; qutip.ssesolve, qutip.photocurrent_sesolve, qutip.smesolve, and qutip.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:1385,Log,Log,1385,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,1,['Log'],['Log']
Testability,"Solvers, QuTiP includes routines for Bloch-Redfield evolution, periodic systems using the Floquet formalism, and stochastic solvers. Add to this, steady state analysis and non-Markovian techniques, and you have a wide variety of tools from which to explore your systems behavior. A wide range of time-dependent evolution simulations can be runtime compiled into C++ behind the scenes using Cython. Thus, you get the ease of use of the Python programming language, and the performance of compiled code, all for free. What can be better than that?; . Can't express your time-dependence analytically, or need to construct a function from a data set? No problem. QuTiP allows for passing interpolating functions as time-dependent arguments to the evolution solvers. Even better, these interpolating functions can be runtime compiled into C++, and support both real and complex data.; . From Bloch spheres to nonlinear colormaps for Wigner functions, QuTiP includes a host of built-in visualization routines that help bring your data to life. Our plotting utilities have been used by Fortune 500 companies, government research labs, and countless research groups around the globe. If you don't look good, we don't look good. ; . QuTiP is thoroughly tested, both by its thousands of users, and by the large collection of built in test scripts. QuTiP includes over a thousand such tests, covering nearly all of the builtin functions. These tests are run over and over again during development to make sure that the results you get from QuTiP are in fact the correct answers. No other quantum simulation software is as well tested as QuTiP.; . No software should be a black box to the user, especially in science. QuTiP is not only completely open-source, but also includes hundreds of pages of documentation, a multitude of tutorial Jupyter notebooks, and a friendly community of users who kindly donate their time to help answer questions.; . © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/features.html:2787,test,tested,2787,features.html,https://qutip.org,https://qutip.org/features.html,5,['test'],"['test', 'tested', 'tests']"
Testability,"TY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators.; """""". __all__ = ['fidelity', 'tracedist', 'bures_dist', 'bures_angle',; 'hilbert_dist', 'average_gate_fidelity', 'process_fidelity',; 'unitarity', 'dnorm']. import numpy as np; from scipy import linalg as la; from qutip.sparse import sp_eigs; from qutip.states import ket2dm; from qutip.superop_reps import to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger(). try:; import cvxpy; except:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> fidelity(x,y); 0.24104350624628332. """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/metrics.html:2795,log,logging,2795,docs/4.2/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html,9,['log'],"['logger', 'logging']"
Testability,"TiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.propcomp. Source code for qutip.control.propcomp; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/propcomp.html:1050,log,logging,1050,docs/4.7/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/propcomp.html,6,['log'],"['logger', 'logging']"
Testability,"True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters. rhoqobjsensity matrix or ket/bra vector. Returns. entropyfloatLinear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters. rhoqobjDensity matrix for composite quantum systems. selAint/listint or list of first selected density matrix components. selBint/listint or list of second selected density matrix components. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_mutfloatMutual information between selected components. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy of density matrix. Parameters. rhoqobjDensity matrix. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. entropyfloatVon-Neumann entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. Density Matrix Metrics¶; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators. fidelity(A, B)[source]¶; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. fidfloatFidelity pseudo-metric between A and B. Examples; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> fidelity(x,y); 0.24104350624628332. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. Bqobj",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:44753,log,logarithm,44753,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['log'],['logarithm']
Testability,"UBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains functions that implement the GRAPE algorithm for; calculating pulse sequences for quantum systems.; """""". __all__ = ['plot_grape_control_fields',; 'grape_unitary', 'cy_grape_unitary', 'grape_unitary_adaptive']. import warnings; import time; import numpy as np; from scipy.interpolate import interp1d; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.ui.progressbar import BaseProgressBar; from qutip.control.cy_grape import cy_overlap, cy_grape_inner; from qutip.qip.gates import gate_sequence_product. import qutip.logging; logger = qutip.logging.get_logger(). [docs]class GRAPEResult:; """"""; Class for representing the result of a GRAPE simulation. Attributes; ----------; u : array; GRAPE control pulse matrix. H_t : time-dependent Hamiltonian; The time-dependent Hamiltonian that realize the GRAPE pulse sequence. U_f : Qobj; The final unitary transformation that is realized by the evolution; of the system with the GRAPE generated pulse sequences.; """"""; def __init__(self, u=None, H_t=None, U_f=None):. self.u = u; self.H_t = H_t; self.U_f = U_f. [docs]def plot_grape_control_fields(times, u, labels, uniform_axes=False):; """"""; Plot a series of plots showing the GRAPE control fields given in the; given control pulse matrix u. Parameters; ----------; times : array; Time coordinate array. u : array; Control pulse matrix. labels : list; List of labels for each control pulse sequence in the control pulse; matrix. uniform_axes : bool; Whether or not to plot all pulse sequences using the same y-axis scale.; """"""; import matplotlib.pyplot ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:3904,log,logging,3904,docs/3.1.0/modules/qutip/control/grape.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html,1,['log'],['logging']
Testability,"U_f_list[m].data, P.data)). if alpha:; # penalty term for high power control signals u; du += -2 * alpha * u[r, j, m, best_k] * dt. if beta:; # penalty term for late control signals u; du += -2 * beta * k ** 2 * u[r, j, k] * dt. for k, eps_val in enumerate(eps_vec):; u[r + 1, j, m, k] = u[r, j, m, k] + eps_val * du.real. if u_limits:; if u[r + 1, j, m, k] < u_limits[0]:; u[r + 1, j, m, k] = u_limits[0]; elif u[r + 1, j, m, k] > u_limits[1]:; u[r + 1, j, m, k] = u_limits[1]. u[r + 1, j, -1, :] = u[r + 1, j, -2, :]. logger.debug(""Time 3: %fs"" % (time.time() - _t0)); _t0 = time.time(). for k, eps_val in enumerate(eps_vec):. def _H_idx(idx):; return H0 + sum([u[r + 1, j, idx, k] * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_idx(idx) * dt).expm() for idx in range(M-1)]. Uf[k] = gate_sequence_product(U_list); _k_overlap[k] = _fidelity_function(cy_overlap(Uf[k].data,; U.data)).real. best_k = np.argmax(_k_overlap); logger.debug(""k_overlap: "", _k_overlap, best_k). if _prev_overlap > _k_overlap[best_k]:; logger.debug(""Regression, stepping back with smaller eps.""). u[r + 1, :, :, :] = u[r, :, :, :]; eps_vec /= 2; else:. if best_k == 0:; eps_vec /= 2. elif best_k == 2:; eps_vec *= 2. _prev_overlap = _k_overlap[best_k]. overlap_log[r] = _k_overlap[best_k]. if overlap_terminate < 1.0:; if _k_overlap[best_k] > overlap_terminate:; logger.info(""Reached target fidelity, terminating.""); break. logger.debug(""Time 4: %fs"" % (time.time() - _t0)); _t0 = time.time(). if use_interp:; ip_funcs = [interp1d(times, u[_r, j, :, best_k], kind=interp_kind,; bounds_error=False, fill_value=u[R - 1, j, -1]); for j in range(J)]. H_td_func = [H0] + [[H_ops[j], lambda t, args, j=j: ip_funcs[j](t)]; for j in range(J)]; else:; H_td_func = [H0] + [[H_ops[j], u[_r, j, :, best_k]] for j in range(J)]. progress_bar.finished(). result = GRAPEResult(u=u[:_r, :, :, best_k], U_f=Uf[best_k],; H_t=H_td_func). result.eps = eps_log; result.overlap = overlap_log. return result. Back to top. © Copyright 2011 and ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:16470,log,logger,16470,docs/3.1.0/modules/qutip/control/grape.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html,1,['log'],['logger']
Testability,"Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. [docs]def entropy_relative(rho, sigma, base=e, sparse=False, tol=1e-12):; """"""; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`qutip.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`qutip.Qobj`; Second density matrix (or ket which will be converted to a density; matrix).; base : {e,2}; Base of logarithm. Defaults to e.; sparse : bool; Flag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False.; tol : float; Tolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns; -------; rel_ent : float; Value of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/entropy.html:6875,log,logarithm,6875,docs/4.6/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html,4,['log'],['logarithm']
Testability,"Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:23815,log,logger,23815,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['log'],['logger']
Testability,"['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count). elif ss_args['method'] == 'iterative-lgmres':; v, check = lgmres(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count). elif ss_args['method'] == 'iterative-bicgstab':; v, check = bicgstab(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if ss_args['info']['precond_time'] is not None:; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0])",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:20675,log,logger,20675,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['log'],['logger']
Testability,"[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Precond",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:26497,log,logger,26497,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,4,['log'],['logger']
Testability,"[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of tslotcomp.EvoCompSummarySummary items are appended if dump_summary is True; at each recomputation of the evolution. dump_ampsboolIf True control amplitudes are dumped. dump_dyn_genboolIf True the dynamics generators (Hamiltonians) are dumped. dump_propboolIf True propagators are dumped. dump_prop_gradboolIf T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:245086,log,log,245086,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['log'],['log']
Testability,"\) is the vector with quadrature operators; for the two modes.; Alternatively, if R = None, and if annihilation operators a1 and a2; for the two modes are supplied instead, the quadrature correlation matrix; is constructed from the annihilation operators before then the covariance; matrix is calculated. Parameters:a1 : qutip.qobj.Qobj. Field operator for mode 1. a2 : qutip.qobj.Qobj. Field operator for mode 2. R : array. The quadrature correlation matrix. rho : qutip.qobj.Qobj. Density matrix for which to calculate the covariance matrix. Returns:cov_mat: array. A 2-dimensional array of covariance values. logarithmic_negativity(V)[source]¶; Calculate the logarithmic negativity given the symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters:V : 2d array. The covariance matrix. Returns:N: float, the logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, rho0, tlist, e_ops, args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x105876c90>)[source]¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. Parameters:H : qutip.qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.qobj. initial densi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:41689,log,logarithmic,41689,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['log'],['logarithmic']
Testability,"\rangle\]. Parameters. basislistList of operators that defines the basis for the covariance matrix. rhoQobjDensity matrix for which to calculate the covariance matrix. symmetrizedbool {True, False}Flag indicating whether the symmetrized (default) or non-symmetrized; correlation matrix is to be calculated. Returns. corr_matndarrayA 2-dimensional array of covariance values. logarithmic_negativity(V, g=1.4142135623730951)[source]¶; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters. V2d arrayThe covariance matrix. gfloatScaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2).; The value of g is related to the value of hbar in the commutation; relation [x, y] = i * hbar via hbar=2/g ** 2 giving the default; value hbar=1. Returns. NfloatThe logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. wigner_covariance_matrix(a1=None, a2=None, R=None, rho=None, g=1.4142135623730951)[source]¶; Calculates the Wigner covariance matrix; \(V_{ij} = \frac{1}{2}(R_{ij} + R_{ji})\), given; the quadrature correlation matrix; \(R_{ij} = \langle R_{i} R_{j}\rangle -; \langle R_{i}\rangle \langle R_{j}\rangle\), where; \(R = (q_1, p_1, q_2, p_2)^T\) is the vector with quadrature operators; for the two modes.; Alternatively, if R = None, and if annihilation operators a1 and a2; for the two modes are supplied instead, the quadrature correlation matrix; is constructed from the annihilation operators before then the covariance; matrix is calculated. Parameters. a1QobjField operator for mode 1. a2QobjField operator for mode 2. RndarrayThe quadrature correlation matrix. rhoQobjDensity matrix for which to calculate the covariance matrix. gfloatScaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2).; The value of g is related to the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:68264,log,logarithmic,68264,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['log'],['logarithmic']
Testability,"]; if np.any(perm2):; b = b[np.ix_(perm2,)]. if ss_args['solver'] == 'scipy':; ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not ss_args['solver'] == 'mkl':; # Use superLU solver; orig_nnz = L.nnz; _direct_start = time.time(); lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])); v = lu.solve(b); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end - _direct_start; if (settings.debug or ss_args['return_info']) and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['lu_fill_factor'] = (L_nnz + U_nnz)/L.nnz; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz + U_nnz)/orig_nnz)). else: # Use MKL solver; if len(ss_args['info']['perm']) != 0:; in_perm = np.arange(n**2, dtype=np.int32); else:; in_perm = None; _direct_start = time.time(); v = mkl_spsolve(L, b, perm=in_perm, verbose=ss_args['verbose'],; max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end-_direct_start. if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf); ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = dense2D_to_fastcsr_fmode(vec2mat(v), n, n); data = 0.5 * (data + data.H); if ss_args['return_info']:; return Qobj(data, d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:15707,log,logger,15707,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['log'],['logger']
Testability,"]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % ; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' % ; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve', ; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol, use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if settings.has_mkl:; has_mkl = 1; else:; has_mkl = 0; ; L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args, has_mkl); if np.any(perm):; b = b[np.ix_(perm,)]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:12163,log,logger,12163,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['log'],['logger']
Testability,"]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve',; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if ss_args['solver'] == 'mkl':; has_mkl = 1; else:; has_mkl = 0. ss_lu_liouv_list = _steadystate_LU_liouvillian(L, ss_args, has_mkl); L, perm, perm2, rev_perm, ss_args = ss_lu_liouv_l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:13660,log,logger,13660,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['log'],['logger']
