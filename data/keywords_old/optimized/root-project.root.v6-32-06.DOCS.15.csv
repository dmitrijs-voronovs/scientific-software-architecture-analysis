quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Modifiability,"est of Clang, the; analyzer is implemented as a C++ library that can be used by other tools and; applications.; Download. Mac OS X. Latest build (10.8+):. Release notes; This build can be used both from the command line and from within Xcode; Installation and usage. Other Platforms; For other platforms, please follow the instructions for building the analyzer from; source code. Viewing static analyzer results in Xcode. Viewing static analyzer results in a web browser. What is Static Analysis?; The term ""static analysis"" is conflated, but here we use it to mean; a collection of algorithms and techniques used to analyze source code in order; to automatically find bugs. The idea is similar in spirit to compiler warnings; (which can be useful for finding coding errors) but to take that idea a step; further and find bugs that are traditionally found using run-time debugging; techniques such as testing.; Static analysis bug-finding tools have evolved over the last several decades; from basic syntactic checkers to those that find deep bugs by reasoning about; the semantics of code. The goal of the Clang Static Analyzer is to provide a; industrial-quality static analysis framework for analyzing C, C++, and; Objective-C programs that is freely available, extensible, and has a high quality of implementation.; Part of Clang and LLVM; As its name implies, the Clang Static Analyzer is built on top of Clang and LLVM.; Strictly speaking, the analyzer is part of Clang, as Clang consists of a set of; reusable C++ libraries for building powerful source-level tools. The static; analysis engine used by the Clang Static Analyzer is a Clang library, and has; the capability to be reused in different contexts and by different clients.; Important Points to Consider; While we believe that the static analyzer is already very useful for finding; bugs, we ask you to bear in mind a few points when using it.; Work-in-Progress; The analyzer is a continuous work-in-progress. There are many planned; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/index.html:1383,evolve,evolved,1383,interpreter/llvm-project/clang/www/analyzer/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/index.html,2,['evolve'],['evolved']
Modifiability,"est, draw } from './jsrootsys/modules/core.mjs';; let res = await httpRequest(""your_server/multi.json?number=3"", ""multi"",; ""Files/job1.root/hpx/root.json\nFiles/job1.root/hpxpy/root.json\nFiles/job1.root/hprof/root.json\n"");; for (let n = 0; n < res.length; ++n) {; console.log('Requested element of type', res[n]._typename);; // draw('drawid', res[n], 'hist');; }; ```. Here argument ""multi"" identifies, that server response should be parsed with `parseMulti()` function, which correctly interprets JSON code, produced by `multi.json` request. When sending such request to the server, one should provide list of objects names and not forget ""?number=N"" parameter in the request URL string. ## Using unix sockets. Starting from ROOT version 6.28, one can start server with unix socket. Just do:. Just call:; ```cpp; [root] new THttpServer(""socket:/tmp/root.socket""); ```; Name of socket should be unique and not match any existing files. Most easy way to access `THttpServer` running via unix socket is to configure ssh tunnel:; ```; [shell] ssh -L 7654:/tmp/root.socket localhost; ```. Once such tunnel is configured one can open following URL in web browser:; ```; [shell] xdg-open http://localhost:7654; ```. ## Websockets supports. Websockets support available starting from ROOT v6.12.; Minimal example provided in [$ROOTSYS/tutorials/http/ws.C](https://root.cern/doc/master/ws_8C.html) macro. To work with websockets, subclass of [THttpWSHandler](https://root.cern/doc/master/classTHttpWSHandler.html) should be created and registered to THttpServer:. ```cpp; #include ""THttpWSHandler.h"". class TUserHandler : public THttpWSHandler {; public:; TUserHandler(const char *name, const char *title) : THttpWSHandler(name, title) {}. // provide custom HTML page when open correspondent address; TString GetDefaultPageContent() override { return ""file:ws.htm""; }. Bool_t ProcessWS(THttpCallArg *arg) override;; };; ```. Central method is `TUserHandler::ProcessWS(THttpCallArg *arg)`, where four kinds o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:24595,config,configure,24595,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['config'],['configure']
Modifiability,"esult in a Python ``ReferenceError`` exception. `Inheritance`; -------------. The output of help shows the inheritance hierarchy, constructors, public; methods, and public data.; For example, ``Concrete`` inherits from ``Abstract`` and it has; a constructor that takes an ``int`` argument, with a default value of 42.; Consider:. .. code-block:: python. >>> from cppyy.gbl import Abstract; >>> issubclass(Concrete, Abstract); True; >>> a = Abstract(); Traceback (most recent call last):; File ""<console>"", line 1, in <module>; TypeError: cannot instantiate abstract class 'Abstract'; >>> c = Concrete(); >>> isinstance(c, Concrete); True; >>> isinstance(c, Abstract); True; >>> d = Concrete(13); >>>. Just like in C++, interface classes that define pure virtual methods, such; as ``Abstract`` does, can not be instantiated, but their concrete; implementations can.; As the output of ``help`` showed, the ``Concrete`` constructor takes; an integer argument, that by default is 42. `Cross-inheritance`; -------------------. Python classes that derive from C++ classes can override virtual methods as; long as those methods are declared on class instantiation (adding methods to; the Python class after the fact will not provide overrides on the C++ side,; only on the Python side).; Example:. .. code-block:: python. >>> from cppyy.gbl import Abstract, call_abstract_method; >>> class PyConcrete(Abstract):; ... def abstract_method(self):; ... return ""Hello, Python World!\n""; ... def concrete_method(self):; ... pass; ...; >>> pc = PyConcrete(); >>> call_abstract_method(pc); Hello, Python World!; >>>. Note that it is not necessary to provide a constructor (``__init__``), but; if you do, you *must* call the base class constructor through the ``super``; mechanism. `Multiple cross-inheritance`; ----------------------------. Python requires that any multiple inheritance (also in pure Python) has an; unambiguous method resolution order (mro), including for classes and thus; also for meta-classes.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst:4551,inherit,inheritance,4551,bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,1,['inherit'],['inheritance']
Modifiability,"et ${target}; COMMENT ""Performing ${target} for '${NEXT_CLANG_STAGE}'""; DEPENDEES configure; ALWAYS ${step_always}; EXCLUDE_FROM_MAIN ON; USES_TERMINAL 1; ). if(target MATCHES ""^stage[0-9]*""); add_custom_target(${target} DEPENDS ${NEXT_CLANG_STAGE}-${target}); endif(). ExternalProject_Add_StepTargets(${NEXT_CLANG_STAGE} ${target}); endforeach(); endif(). if (CLANG_BOLT_INSTRUMENT AND NOT LLVM_BUILD_INSTRUMENTED); set(CLANG_PATH ${LLVM_RUNTIME_OUTPUT_INTDIR}/clang); set(CLANG_INSTRUMENTED ${CLANG_PATH}-bolt.inst); set(BOLT_FDATA ${CMAKE_CURRENT_BINARY_DIR}/utils/perf-training/prof.fdata). # Instrument clang with BOLT; add_custom_target(clang-instrumented; DEPENDS ${CLANG_INSTRUMENTED}; ); add_custom_command(OUTPUT ${CLANG_INSTRUMENTED}; DEPENDS clang llvm-bolt; COMMAND llvm-bolt ${CLANG_PATH} -o ${CLANG_INSTRUMENTED}; -instrument --instrumentation-file-append-pid; --instrumentation-file=${BOLT_FDATA}; COMMENT ""Instrumenting clang binary with BOLT""; VERBATIM; ). # Optimize original (pre-bolt) Clang using the collected profile; set(CLANG_OPTIMIZED ${CMAKE_CURRENT_BINARY_DIR}/clang.bolt); add_custom_target(clang-bolt; DEPENDS ${CLANG_OPTIMIZED}; ); add_custom_command(OUTPUT ${CLANG_OPTIMIZED}; DEPENDS clang-bolt-profile; COMMAND llvm-bolt ${CLANG_PATH}; -o ${CLANG_OPTIMIZED}; -data ${BOLT_FDATA}; -reorder-blocks=ext-tsp -reorder-functions=hfsort+ -split-functions; -split-all-cold -split-eh -dyno-stats -icf=1 -use-gnu-stack; COMMAND ${CMAKE_COMMAND} -E rename ${CLANG_OPTIMIZED} $<TARGET_FILE:clang>; COMMENT ""Optimizing Clang with BOLT""; VERBATIM; ); endif(). if (LLVM_ADD_NATIVE_VISUALIZERS_TO_SOLUTION); add_subdirectory(utils/ClangVisualizers); endif(); add_subdirectory(utils/hmaptool). if(CLANG_BUILT_STANDALONE); llvm_distribution_add_targets(); process_llvm_pass_plugins(); endif(). set(CLANG_INSTALL_LIBDIR_BASENAME ""lib${CLANG_LIBDIR_SUFFIX}""). configure_file(; ${CLANG_SOURCE_DIR}/include/clang/Config/config.h.cmake; ${CLANG_BINARY_DIR}/include/clang/Config/config.h); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:32162,config,config,32162,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,2,['config'],['config']
Modifiability,"et int undef"". Instead, LLVM; produces ""ret int 0"":. int f() {; int x = 4;; int y;; if (x == 3) y = 0;; return y;; }. //===---------------------------------------------------------------------===//. The loop unroller should partially unroll loops (instead of peeling them); when code growth isn't too bad and when an unroll count allows simplification; of some code within the loop. One trivial example is:. #include <stdio.h>; int main() {; int nRet = 17;; int nLoop;; for ( nLoop = 0; nLoop < 1000; nLoop++ ) {; if ( nLoop & 1 ); nRet += 2;; else; nRet -= 1;; }; return nRet;; }. Unrolling by 2 would eliminate the '&1' in both copies, leading to a net; reduction in code size. The resultant code would then also be suitable for; exit value computation. //===---------------------------------------------------------------------===//. We miss a bunch of rotate opportunities on various targets, including ppc, x86,; etc. On X86, we miss a bunch of 'rotate by variable' cases because the rotate; matching code in dag combine doesn't look through truncates aggressively ; enough. Here are some testcases reduces from GCC PR17886:. unsigned long long f5(unsigned long long x, unsigned long long y) {; return (x << 8) | ((y >> 48) & 0xffull);; }; unsigned long long f6(unsigned long long x, unsigned long long y, int z) {; switch(z) {; case 1:; return (x << 8) | ((y >> 48) & 0xffull);; case 2:; return (x << 16) | ((y >> 40) & 0xffffull);; case 3:; return (x << 24) | ((y >> 32) & 0xffffffull);; case 4:; return (x << 32) | ((y >> 24) & 0xffffffffull);; default:; return (x << 40) | ((y >> 16) & 0xffffffffffull);; }; }. //===---------------------------------------------------------------------===//. This (and similar related idioms):. unsigned int foo(unsigned char i) {; return i | (i<<8) | (i<<16) | (i<<24);; } . compiles into:. define i32 @foo(i8 zeroext %i) nounwind readnone ssp noredzone {; entry:; %conv = zext i8 %i to i32; %shl = shl i32 %conv, 8; %shl5 = shl i32 %conv, 16; %shl9 = shl i3",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:16646,variab,variable,16646,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,2,['variab'],['variable']
Modifiability,"et or RooDataSet instances, please consider using the new `RooArgSet::uniqueId()` or `RooAbsData::uniqueId()`. ### Introducing binned likelihood fit optimization in HistFactory. In a binned likelihood fit, it is possible to skip the PDF normalization when; the unnormalized binned PDF can be interpreted directly in terms of event; yields. This is now done by default for HistFactory models, which; results in great speedups for binned fits with many channels. Some RooFit users; like ATLAS were already using this for a long time. To disable this optimization when using the `hist2workspace` executable, add the `-disable_binned_fit_optimization` command line argument.; Directly in C++, you can also set the `binnedFitOptimization` to `false` in the; HistFactory configuration as follows:; ```C++; RooStats::HistFactory::MakeModelAndMeasurementFast(measurement, {.binnedFitOptimization=false});; ```; If your compiler doesn't support aggregate initialization with designators, you; need to create and edit the configuration struct explicitely:; ```C++; RooStats::HistFactory::HistoToWorkspaceFactoryFast::Configuration hfCfg;; hfCfg.binnedFitOptimization = false;; RooStats::HistFactory::MakeModelAndMeasurementFast(measurement, hfCfg);; ```. ### Disable copy assignment for RooAbsArg and derived types. Copy assignment for RooAbsArgs was implemented in an unexpected and; inconsistent way. While one would expect that the copy assignment is copying; the object, it said in the documentation of `RooAbsArg::operator=` that it will; ""assign all boolean and string properties of the original bject. Transient; properties and client-server links are not assigned."" This contradicted with; the implementation, where the server links were actually copied too.; Furthermore, in `RooAbsRealLValue`, the assigment operator was overloaded by a; function that only assigns the value of another `RooAbsReal`. With all these inconsistencies, it was deemed safer to disable copy assignment; of RooAbsArgs from no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:20985,config,configuration,20985,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['config'],['configuration']
Modifiability,"et tessellation. The **`TGraph2D`** class has the following constructors:. - With an arrays' dimension `n` and three arrays `x`, `y`, and `z`; (can be arrays of doubles, floats, or integers):. ``` {.cpp}; TGraph2D *g = new TGraph2D(n,x,y,z);; ```. - With an array dimension only:. ``` {.cpp}; TGraph2D *g = new TGraph2D(n);; ```. - Internal arrays are filled with the method `SetPoint` at the; position ""`i`"" with the values `x`, `y`, `z`:. ``` {.cpp}; g->SetPoint(i,x,y,z);; ```. - Without parameters; the method `SetPoint` must be used to fill the; internal arrays. ``` {.cpp}; TGraph2D *g = new TGraph2D();; ```. - From a file:. ``` {.cpp}; TGraph2D *g = new TGraph2D(""graph.dat"");; ```. The arrays are read from the ASCII file ""`graph.dat`"" according to a; specified format. The format's default value is ""`%lg %lg %lg`"". Note; that in any of last three cases, the `SetPoint` method can be used to; change a data point or to add a new one. If the data point index (`i`); is greater than the size of the internal arrays, they are; automatically extended. Specific drawing options can be used to paint a **`TGraph2D`**:. - ""`TRI`"" the Delaunay triangles are drawn using filled area. A; hidden surface drawing technique is used. The surface is painted; with the current fill area color. The edges of the triangles are; painted with the current line color;. - ""`TRIW`""the Delaunay triangles are drawn as wire frame;. - ""`TRI1`"" the Delaunay triangles are painted with color levels. The; edges of the triangles are painted with the current line color;. - ""`TRI2`"" the Delaunay triangles are painted with color levels;. - ""`P`""draws a marker at each vertex;. - ""`P0`"" draws a circle at each vertex. Each circle background is; white. A **`TGraph2D`** can be also drawn with ANY options valid for 2D; histogram drawing. In this case, an intermediate 2D histogram is; filled using the Delaunay triangles technique to interpolate the data; set. **`TGraph2D`** linearly interpolate a `Z` value for any `(X,Y",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:18277,extend,extended,18277,documentation/users-guide/Graphs.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md,1,['extend'],['extended']
Modifiability,"et your system up to; execute LLVM bitcode files directly. To do this, use commands like this (the; first command may not be required if you are already using the module):. .. code-block:: console. % mount -t binfmt_misc none /proc/sys/fs/binfmt_misc; % echo ':llvm:M::BC::/path/to/lli:' > /proc/sys/fs/binfmt_misc/register; % chmod u+x hello.bc (if needed); % ./hello.bc. This allows you to execute LLVM bitcode files directly. On Debian, you can also; use this command instead of the 'echo' command above:. .. code-block:: console. % sudo update-binfmts --install llvm /path/to/lli --magic 'BC'. .. _Program Layout:; .. _general layout:. Directory Layout; ================. One useful source of information about the LLVM source base is the LLVM `doxygen; <http://www.doxygen.org/>`_ documentation available at; `<https://llvm.org/doxygen/>`_. The following is a brief introduction to code; layout:. ``llvm/cmake``; --------------; Generates system build files. ``llvm/cmake/modules``; Build configuration for llvm user defined options. Checks compiler version and; linker flags. ``llvm/cmake/platforms``; Toolchain configuration for Android NDK, iOS systems and non-Windows hosts to; target MSVC. ``llvm/examples``; -----------------. - Some simple examples showing how to use LLVM as a compiler for a custom; language - including lowering, optimization, and code generation. - Kaleidoscope Tutorial: Kaleidoscope language tutorial run through the; implementation of a nice little compiler for a non-trivial language; including a hand-written lexer, parser, AST, as well as code generation; support using LLVM- both static (ahead of time) and various approaches to; Just In Time (JIT) compilation.; `Kaleidoscope Tutorial for complete beginner; <https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html>`_. - BuildingAJIT: Examples of the `BuildingAJIT tutorial; <https://llvm.org/docs/tutorial/BuildingAJIT1.html>`_ that shows how LLVM’s; ORC JIT APIs interact with other parts of LLVM. I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:34210,config,configuration,34210,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['config'],['configuration']
Modifiability,"et(AA.getModRefInfoMask(Loc))``; this checks to see if the given; location can be modified at all. For convenience, there is also a method; ``pointsToConstantMemory(Loc)``; this is synonymous with; ``isNoModRef(AA.getModRefInfoMask(Loc))``. .. _never access memory or only read memory:. The ``doesNotAccessMemory`` and ``onlyReadsMemory`` methods; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These methods are used to provide very simple mod/ref information for function; calls. The ``doesNotAccessMemory`` method returns true for a function if the; analysis can prove that the function never reads or writes to memory, or if the; function only reads from constant memory. Functions with this property are; side-effect free and only depend on their input arguments, allowing them to be; eliminated if they form common subexpressions or be hoisted out of loops. Many; common functions behave this way (e.g., ``sin`` and ``cos``) but many others do; not (e.g., ``acos``, which modifies the ``errno`` variable). The ``onlyReadsMemory`` method returns true for a function if analysis can prove; that (at most) the function only reads from non-volatile memory. Functions with; this property are side-effect free, only depending on their input arguments and; the state of memory when they are called. This property allows calls to these; functions to be eliminated and moved around, as long as there is no store; instruction that changes the contents of memory. Note that all functions that; satisfy the ``doesNotAccessMemory`` method also satisfy ``onlyReadsMemory``. Writing a new ``AliasAnalysis`` Implementation; ==============================================. Writing a new alias analysis implementation for LLVM is quite straight-forward.; There are already several implementations that you can use for examples, and the; following information should help fill in any details. For examples, take a; look at the `various alias analysis implementations`_ included with LLVM. Different ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:8926,variab,variable,8926,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['variab'],['variable']
Modifiability,"et. Defaults to OFF. Targets; for building each unit test are generated in any case. You can build a; specific unit test using the targets defined under *unittests*, such as; ADTTests, IRTests, SupportTests, etc. (Search for ``add_llvm_unittest`` in; the subdirectories of *unittests* for a complete list of unit tests.) It is; possible to build all unit tests with the target *UnitTests*. **LLVM_BUILD_TOOLS**:BOOL; Build LLVM tools. Defaults to ON. Targets for building each tool are generated; in any case. You can build a tool separately by invoking its target. For; example, you can build *llvm-as* with a Makefile-based system by executing *make; llvm-as* at the root of your build directory. **LLVM_CCACHE_BUILD**:BOOL; If enabled and the ``ccache`` program is available, then LLVM will be; built using ``ccache`` to speed up rebuilds of LLVM and its components.; Defaults to OFF. The size and location of the cache maintained; by ``ccache`` can be adjusted via the LLVM_CCACHE_MAXSIZE and LLVM_CCACHE_DIR; options, which are passed to the CCACHE_MAXSIZE and CCACHE_DIR environment; variables, respectively. **LLVM_CREATE_XCODE_TOOLCHAIN**:BOOL; macOS Only: If enabled CMake will generate a target named; 'install-xcode-toolchain'. This target will create a directory at; $CMAKE_INSTALL_PREFIX/Toolchains containing an xctoolchain directory which can; be used to override the default system tools. **LLVM_<target>_LINKER_FLAGS**:STRING; Defines the set of linker flags that should be applied to a <target>. **LLVM_DEFAULT_TARGET_TRIPLE**:STRING; LLVM target to use for code generation when no target is explicitly specified.; It defaults to ""host"", meaning that it shall pick the architecture; of the machine where LLVM is being built. If you are building a cross-compiler,; set it to the target triple of your desired architecture. **LLVM_DOXYGEN_QCH_FILENAME**:STRING; The filename of the Qt Compressed Help file that will be generated when; ``-DLLVM_ENABLE_DOXYGEN=ON`` and; ``-DLLVM_ENABLE_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:17820,variab,variables,17820,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,et_elf_mach_gfx_name.cpp; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.h; openmp/libomptarget/plugins/amdgpu/impl/hsa_api.h; openmp/libomptarget/plugins/amdgpu/impl/impl.cpp; openmp/libomptarget/plugins/amdgpu/impl/impl_runtime.h; openmp/libomptarget/plugins/amdgpu/impl/internal.h; openmp/libomptarget/plugins/amdgpu/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/libomptarget/plugins/remote/include/Utils.h; openmp/libomptarget/plugins/remote/server/OffloadingServer.cpp; openmp/libomptarget/plugins/remote/server/Server.cpp; openmp/libomptarget/plugins/remote/server/Server.h; openmp/libomptarget/plugins/remote/src/Client.cpp; openmp/libomptarget/plugins/remote/src/Client.h; openmp/libomptarget/plugins/ve/src/rtl.cpp; openmp/libomptarget/src/api.cpp; openmp/libomptarget/src/interface.cpp; openmp/libomptarget/src/interop.cpp; openmp/libomptarget/src/omptarget.cpp; openmp/libomptarget/src/private.h; openmp/libomptarget/src/rtl.cpp; openmp/libomptarget/tools/deviceinfo/llvm-omp-device-info.cpp; openmp/runtime/doc/doxygen/libomp_interface.h; openmp/runtime/src/extractExternal.cpp; openmp/runtime/src/kmp.h; openmp/runtime/src/kmp_affinity.h; openmp/runtime/src/kmp_alloc.cpp; openmp/runtime/src/kmp_atomic.cpp; openmp/runtime/src/kmp_atomic.h; openmp/runtime/src/kmp_barrier.h; openmp/runtime/src/kmp_cancel.cpp; openmp/runtime/src/kmp_debug.cpp; openmp/runtime/src/kmp_debug.h; openmp/runtime/src/kmp_debugger.cpp; openmp/runtim,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:407969,plugin,plugins,407969,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,"etadata). This intrinsic provides information when a user source variable is set to a new; value. The first argument is the new value (wrapped as metadata). The second; argument is a `local variable <LangRef.html#dilocalvariable>`_ containing a; description of the variable. The third argument is a `complex expression; <LangRef.html#diexpression>`_. An `llvm.dbg.value` intrinsic describes the *value* of a source variable; directly, not its address. Note that the value operand of this intrinsic may; be indirect (i.e, a pointer to the source variable), provided that interpreting; the complex expression derives the direct value. ``llvm.dbg.assign``; ^^^^^^^^^^^^^^^^^^^; .. toctree::; :hidden:. AssignmentTracking. .. code-block:: llvm. void @llvm.dbg.assign(Value *Value,; DIExpression *ValueExpression,; DILocalVariable *Variable,; DIAssignID *ID,; Value *Address,; DIExpression *AddressExpression). This intrinsic marks the position in IR where a source assignment occurred. It; encodes the value of the variable. It references the store, if any, that; performs the assignment, and the destination address. The first three arguments are the same as for an ``llvm.dbg.value``. The fourth; argument is a ``DIAssignID`` used to reference a store. The fifth is the; destination of the store (wrapped as metadata), and the sixth is a `complex; expression <LangRef.html#diexpression>`_ that modifies it. The formal LLVM-IR signature is:. .. code-block:: llvm. void @llvm.dbg.assign(metadata, metadata, metadata, metadata, metadata, metadata). See :doc:`AssignmentTracking` for more info. Object lifetimes and scoping; ============================. In many languages, the local variables in functions can have their lifetimes or; scopes limited to a subset of a function. In the C family of languages, for; example, variables are only live (readable and writable) within the source; block that they are defined in. In functional languages, values are only; readable after they have been defined. Thoug",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:11267,variab,variable,11267,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"etail::RooFit::Detail::CodeSquashContext &ctx) const; {; std::string xName = ctx.getResult(x);; if (!_noRounding); xName = ""std::floor("" + xName + "")"";; ctx.addResult(this, ctx.buildCall(""RooFit::Detail::MathFuncs::poissonEvaluate"", xName, mean));; }; ```. Here we can see that the name of the variable `x` (remember that ""x"" is a; member of RooPoisson) is retrieved and stored in the `xName` variable. Next,; there's an `if` condition that does an operation on `x` (may or may not round; it to the nearest integer, depending on the condition). The important part is where the `RooPoisson::addResult()` function helps add; the result of evaluating the Poisson function to the context (`ctx`). It uses; the `RooPoisson::buildCall()` method to construct a function call to the fully; qualified name of `MathFuncs::poissonEvaluate` (which now resides in the; `MathFuncs` file), with arguments `xName` and `mean`. Essentially, the `RooPoisson::translate()` function constructs a function call; to evaluate the Poisson function using 'x' and 'mean' variables, and adds the; result to the context. Helper Functions:. - `getResult()` helps lookup the result of a child node (the string that the; child node previously saved in a variable using the `addResult()` function). - `addResult()` It may include a function call, an expression, or something; more complicated. For a specific class, it will add whatever is represented on; the right-hand side to the result of that class, which can then be propagated; in the rest of the compute graph. \note For each `translate()` function, it is important to call `addResult()` since this is what enables the squashing to happen. **translate() Example 2:** Following is a code snippet from `RooGaussian.cxx`; *after* it has AD support. ``` {.cpp}; void RooGaussian::translate(RooFit::Detail::RooFit::Detail::CodeSquashContext &ctx) const; {; ctx.addResult(this, ctx.buildCall(""RooFit::Detail::MathFuncs::gaussianEvaluate"", x, mean, sigma));; }; ```. Here we can see",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:13304,variab,variables,13304,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['variab'],['variables']
Modifiability,"ete; language that can calculate a wide variety of numeric functions. Next up; we'll add another useful expression that is familiar from non-functional; languages... 'for' Loop Expression; =====================. Now that we know how to add basic control flow constructs to the; language, we have the tools to add more powerful things. Let's add; something more aggressive, a 'for' expression:. ::. extern putchard(char);; def printstar(n); for i = 1, i < n, 1.0 in; putchard(42); # ascii 42 = '*'. # print 100 '*' characters; printstar(100);. This expression defines a new variable (""i"" in this case) which iterates; from a starting value, while the condition (""i < n"" in this case) is; true, incrementing by an optional step value (""1.0"" in this case). If; the step value is omitted, it defaults to 1.0. While the loop is true,; it executes its body expression. Because we don't have anything better; to return, we'll just define the loop as always returning 0.0. In the; future when we have mutable variables, it will get more useful. As before, let's talk about the changes that we need to Kaleidoscope to; support this. Lexer Extensions for the 'for' Loop; -----------------------------------. The lexer extensions are the same sort of thing as for if/then/else:. .. code-block:: c++. ... in enum Token ...; // control; tok_if = -6, tok_then = -7, tok_else = -8,; tok_for = -9, tok_in = -10. ... in gettok ...; if (IdentifierStr == ""def""); return tok_def;; if (IdentifierStr == ""extern""); return tok_extern;; if (IdentifierStr == ""if""); return tok_if;; if (IdentifierStr == ""then""); return tok_then;; if (IdentifierStr == ""else""); return tok_else;; if (IdentifierStr == ""for""); return tok_for;; if (IdentifierStr == ""in""); return tok_in;; return tok_identifier;. AST Extensions for the 'for' Loop; ---------------------------------. The AST node is just as simple. It basically boils down to capturing the; variable name and the constituent expressions in the node. .. code-block:: c++. /// ForEx",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:15965,variab,variables,15965,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['variab'],['variables']
Modifiability,eted move constructors; Unknown. 1832; CD4; Casting to incomplete enumeration; Unknown. 1833; NAD; friend declarations naming implicitly-declared member functions; Unknown. 1834; CD4; Constant initialization binding a reference to an xvalue; Unknown. 1835; CD6; Dependent member lookup before <; Unknown. 1836; CD5; Use of class type being defined in trailing-return-type; Unknown. 1837; CD6; Use of this in friend and local class declarations; Clang 3.3. 1838; CD4; Definition via unqualified-id and using-declaration; Unknown. 1839; CD6; Lookup of block-scope extern declarations; Unknown. 1840; drafting; Non-deleted explicit specialization of deleted function template; Not resolved. 1841; CD6; < following template injected-class-name; Unknown. 1842; open; Unevaluated operands and “carries a dependency”; Not resolved. 1843; CD4; Bit-field in conditional operator with throw operand; Unknown. 1844; open; Defining “immediate context”; Not resolved. 1845; drafting; Point of instantiation of a variable template specialization; Not resolved. 1846; CD4; Declaring explicitly-defaulted implicitly-deleted functions; Unknown. 1847; CD4; Clarifying compatibility during partial ordering; Unknown. 1848; CD4; Parenthesized constructor and destructor declarators; Unknown. 1849; CD6; Variable templates and the ODR; Unknown. 1850; CD4; Differences between definition context and point of instantiation; Unknown. 1851; CD4; decltype(auto) in new-expressions; Unknown. 1852; CD4; Wording issues regarding decltype(auto); Unknown. 1853; dup; Defining “allocated storage”; Unknown. 1854; drafting; Disallowing use of implicitly-deleted functions; Not resolved. 1855; dup; Out-of-lifetime access to nonstatic data members; Unknown. 1856; open; Indirect nested classes of class templates; Not resolved. 1857; CD5; Additional questions about bits; Unknown. 1858; CD4; Comparing pointers to union members; Unknown. 1859; CD5; UTF-16 in char16_t string literals; Unknown. 1860; C++17; What is a “direct member?,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:125313,variab,variable,125313,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['variab'],['variable']
Modifiability,"eter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters; is 5, and the number of internal parameters is 3. This is the number; which determines, for example, the size of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is that parameters are allowed to change types; during the M minimization and analysis of a $\mbox{FCN}$ function.; Several applications in M have methods available to make variable; parameters fixed and vice-versa; to impose, change, or remove limits; from variable parameters; and even to define completely new parameters; at any time during a run. In addition, some M applications (notably the; $\mbox{MINOS}$ error analysis) cause one or more variable parameters; to be temporarily fixed during the calculation. Therefore, the; correspondence between external and internal parameter lists is in; general a dynamic one, and the number of internal parameters is not; necessarily constant. For more details about parameter interaction see [api:parameters]. ### The transformation for parameters with limits ###. [intro:limits]. For variable parameters with double sided limits $a$ (lower) and $b$; (upper), M uses the following transformation:. $$\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}$$. so that the internal value $P_{\mathrm{int}}$ can take on any value,; while the external value $P_{\mathrm{ext}}$ can take on values only; between the lower limit $a$ and the upper limit $b$. Since the; transformation is necessarily non-linear, it would transform a nice; line",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:7778,variab,variable,7778,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability,"etermine that distinct different path names for the same; hard linked file actually are equal. This is an intentional tradeoff in a; bug fix, where the bug used to cause distinct files to be considered; equivalent on some file systems. This change fixed the issues; https://github.com/llvm/llvm-project/issues/61401 and; https://github.com/llvm/llvm-project/issues/22079. Changes to the X86 Backend; --------------------------. * The ``i128`` type now matches GCC and clang's ``__int128`` type. This mainly; benefits external projects such as Rust which aim to be binary compatible; with C, but also fixes code generation where LLVM already assumed that the; type matched and called into libgcc helper functions.; * Support ISA of ``USER_MSR``.; * Support ISA of ``AVX10.1-256`` and ``AVX10.1-512``.; * ``-mcpu=pantherlake`` and ``-mcpu=clearwaterforest`` are now supported.; * ``-mapxf`` is supported.; * Marking global variables with ``code_model = ""small""/""large""`` in the IR now; overrides the global code model to allow 32-bit relocations or require 64-bit; relocations to the global variable.; * The medium code model's code generation was audited to be more similar to the; small code model where possible. Changes to the OCaml bindings; -----------------------------. Changes to the Python bindings; ------------------------------. * The python bindings have been removed. Changes to the C API; --------------------. * Added ``LLVMGetTailCallKind`` and ``LLVMSetTailCallKind`` to; allow getting and setting ``tail``, ``musttail``, and ``notail``; attributes on call instructions.; * The following functions for creating constant expressions have been removed,; because the underlying constant expressions are no longer supported. Instead,; an instruction should be created using the ``LLVMBuildXYZ`` APIs, which will; constant fold the operands if possible and create an instruction otherwise:. * ``LLVMConstAnd``; * ``LLVMConstOr``; * ``LLVMConstLShr``; * ``LLVMConstAShr``; * ``LLVMConstZEx",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:9931,variab,variables,9931,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"eters like one do it in URL string:. ```html; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; ```. ## Reading local ROOT files. JSROOT can read files from local file system using HTML5 FileReader functionality.; Main limitation here - user should interactively select files for reading.; There is button __""...""__ on the main JSROOT page, which starts file selection dialog.; If valid ROOT file is selected, JSROOT will be able to normally read content of such file. ## JSROOT with THttpServer. THttpServer provides http access to objects from running ROOT application.; JSROOT is used to implement the user interface in the web browsers. The layout of the main page coming from THttpServer is very similar to normal JSROOT page.; One could browse existing items and display them. A snapshot of running; server can be seen on the [demo page](https://root.cern/js/latest/httpserver.C/). One could also specify similar URL parameters to configure the displayed items and drawing options. It is also possible to display one single item from the THttpServer server like:. <https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz>. ## Data monitoring with JSROOT. ### Monitoring with http server. The best possibility to organize the monitoring of data from a running application; is to use THttpServer. In such case the client can always access the latest; changes and request only the items currently displayed in the browser.; To enable monitoring, one should activate the appropriate checkbox or; provide __monitoring__ parameter in the URL string like:. <https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000>. The parameter value is the update interval in milliseconds. ### JSON file-based monitoring. Solid file-based monitoring (without integration of THttpServer into application) can be; implemented in JSON format. There is the [TBufferJSON](https://root.cern/doc/master",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:30212,config,configure,30212,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['config'],['configure']
Modifiability,"etrieve it in the callback:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(; varDecl(hasType(isInteger())).bind(""incrementVariable"")))))). We can add this code to the definition of ``LoopMatcher`` and make sure; that our program, outfitted with the new matcher, only prints out loops; that declare a single variable initialized to zero and have an increment; step consisting of a unary increment of some variable. Now, we just need to add a matcher to check if the condition part of the; ``for`` loop compares a variable against the size of the array. There is; only one problem - we don't know which array we're iterating over; without looking at the body of the loop! We are again restricted to; approximating the result we want with matchers, filling in the details; in the callback. So we start with:. .. code-block:: c++. hasCondition(binaryOperator(hasOperatorName(""<""))). It makes sense to ensure that the left-hand side is a reference to a; variable, and that the right-hand side has integer type. .. code-block:: c++. hasCondition(binaryOperator(; hasOperatorName(""<""),; hasLHS(declRefExpr(to(varDecl(hasType(isInteger()))))),; hasRHS(expr(hasType(isInteger()))))). Why? Because it doesn't work. Of the three loops provided in; ``test-files/simple.cpp``, zero of them have a matching condition. A; quick look at the AST dump of the first for loop, produced by the; previous iteration of loop-convert, shows us the answer:. ::. (ForStmt 0x173b240; (DeclStmt 0x173afc8; 0x173af50 ""int i =; (IntegerLiteral 0x173afa8 'int' 0)""); <<>>; (BinaryOperator 0x173b060 '_Bool' '<'; (ImplicitCastExpr 0x173b030 'int'; (DeclRefExpr 0x173afe0 'int' lvalue Var 0x173af50 'i' 'int')); (ImplicitCastExpr 0x173b048 'int'; (DeclRefExpr 0x173b008 'const int' lvalue Var 0x170fa80 'N' 'const int'))); (UnaryOperator 0x173b0b0 'int' lvalue prefix '++'; (DeclRefExpr 0x173b088 'int' lvalue Var 0x173af50 'i' 'int')); (CompoundStatement ... We already know ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:13711,variab,variable,13711,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['variab'],['variable']
Modifiability,"etry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ```. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ``` {.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ```. A navigator holds several variables describing the current navigation; state: current point position, current direction distance to next; boundary, isotropic safety, pointer to current and next nods as well as; several tracking flags related to volume boundary conditions or other; properties required for track propagation in geometry. Each geometry; query affects these variables, so the only way in testing several; navigation alternatives and remembering the active navigation state is; to use parallel navigation. The following paragraphs will describe the; usage of a single navigator. All setters/getters for navigation state; parameters as well as navigation queries provided by **`TGeoNavigator`**; are interfaced by **`TGeoManager`** and will act on the current; navigator. ### Initializing the Starting Point. The current point (`x,y,z`) known by the modeller is stored as; `Double_t fCurrentPoint[3]` by the navigator class. This array of the; three coordinates is defined in the current global reference system and; can be retrieved any time:. ``` {.cpp}; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; ```. Initializing this point can be done like:. ``` {.cpp}; gGeoManager->SetCurrentPoint(x,y,z);; // or:; gGeoManager->SetCurrentPoint(Double_t *point[3]);; ```. ### Initializing the Direction. In order to move inside geometry starting with the current point, the; modeller needs to know the current ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:103578,variab,variables,103578,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['variab'],['variables']
Modifiability,"ets which contain a single; file path to be used in processing single files. Used, for example, in; tasks generating files. The files are specified into a TMap - named; 'PROOF_FilesToProcess' - containing the list of files to be generated; per host (the key is the host name, the value the TList of TObjString; (or TFileInfo) with the files names - or a TFileCollection: the output; of TFileCollection::GetFilesPerServer() can be directly passed as files; map). Workers are first assigned files belonging to; the list with host name matching the worker name. The map is; distributed to the master via the input list.Add support for; automatic setting of pointer data members to the relevant object in the; output list. The use of fOutputList->FindObject(""name"") in; TSelector::Terminate is not needed anymore for pointer data members,; e.g. histograms.; Add the possibility to define an external list of environment; variables to be transmitted to the master and workers. This is done via; the environment variable PROOF_ENVVARS. This addition allows to change; the variables wthout changing the macro or application running; TProof::Open.; Add the possibility to save the perfomance information shown; by the dialog into a small ntuple included in the output list. The; ntuple contains 5 floats (processing time, number of active workers,; event rate, MBytes read, number of effective sessions on the cluster); and it is filled each time the number of active workers changes or at; max 100 regular intervals at least 5 secs apart; in this way the ntuple; has at most O(100 entries + number of workers). To enable the saving of; the ntuple execute the following:;         proof->SetParameter(""PROOF_SaveProgressPerf"", ""yes"");; before running the query. The ntuple is called 'PROOF_ProgressPerfNtuple'.; Add support for worker autodiscovery in PROOF using the; Avahi/Bonjour technology. The new functionality is supported on Mac; (MacOsX >= 10.4; no need of additional installs) and linux (requires; t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:2880,variab,variable,2880,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,2,['variab'],['variable']
Modifiability,"etters begin with **`Get`** and **`Set`**:; `SetLast`(), `GetFirst`(). ### Machine Independent Types. Different machines may have different lengths for the same type. The; most famous example is the `int` type. It may be 16 bits on some old; machines and 32 bits on some newer ones. To ensure the size of your; variables, use these pre defined types in ROOT:. - **`Char_t`** Signed Character 1 byte. - **`UChar_t`** Unsigned Character 1 byte. - **`Short_t`** Signed Short integer 2 bytes. - **`UShort_t`** Unsigned Short integer 2 bytes. - **`Int_t`** Signed integer 4 bytes. - **`UInt_t `**Unsigned integer 4 bytes. - **`Long64_t`** Portable signed long integer 8 bytes. - **`ULong64_t`** Portable unsigned long integer 8 bytes. - **`Float_t`** Float 4 bytes. - **`Double_t`** Float 8 bytes. - **`Double32_t`** Double 8 bytes in memory, written as a Float 4; bytes. - **`Bool_t`** Boolean (0=false, 1=true). If you do not want to save a variable on disk, you can use `int` or; `Int_t`, the result will be the same and the interpreter or the; compiler will treat them in exactly the same way. ### TObject. In ROOT, almost all classes inherit from a common base class called; **`TObject`**. This kind of architecture is also used in the Java; language. The **`TObject`** class provides default behavior and; protocol for all objects in the ROOT system. The main advantage of; this approach is that it enforces the common behavior of the derived; classes and consequently it ensures the consistency of the whole; system. See ""The Role of TObject"". **`TObject`** provides protocol, i.e. (abstract) member functions,; for:. - Object I/O (`Read()`, `Write())`. - Error handling (`Warning()`, `Error()`, `SysError()`, `Fatal())`. - Sorting (`IsSortable()`, `Compare()`, `IsEqual()`, `Hash())`. - Inspection (`Dump()`, `Inspect()`). - Printing (`Print())`. - Drawing (`Draw()`, `Paint()`, `ExecuteEvent())`. - Bit handling (`SetBit()`, `TestBit()`). - Memory allocation (operator` new and delete`, `IsOnHeap",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:30973,variab,variable,30973,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['variab'],['variable']
Modifiability,"etting the following two; CMake options to ``On``: *LLVM_BUILD_LLVM_DYLIB* and *LLVM_LINK_LLVM_DYLIB*. .. warning::; Distributions should never be built using the *BUILD_SHARED_LIBS* CMake; option. (:ref:`See the warning above for more explanation <shared_libs>`.). Relevant CMake Options; ======================. This section provides documentation of the CMake options that are intended to; help construct distributions. This is not an exhaustive list, and many; additional options are documented in the :doc:`CMake` page. Some key options; that are already documented include: *LLVM_TARGETS_TO_BUILD*, *LLVM_ENABLE_PROJECTS*,; *LLVM_ENABLE_RUNTIMES*, *LLVM_BUILD_LLVM_DYLIB*, and *LLVM_LINK_LLVM_DYLIB*. **LLVM_ENABLE_RUNTIMES**:STRING; When building a distribution that includes LLVM runtime projects (i.e. libcxx,; compiler-rt, libcxxabi, libunwind...), it is important to build those projects; with the just-built compiler. **LLVM_DISTRIBUTION_COMPONENTS**:STRING; This variable can be set to a semi-colon separated list of LLVM build system; components to install. All LLVM-based tools are components, as well as most; of the libraries and runtimes. Component names match the names of the build; system targets. **LLVM_DISTRIBUTIONS**:STRING; This variable can be set to a semi-colon separated list of distributions. See; the :ref:`Multi-distribution configurations` section above for details on this; and other CMake variables to configure multiple distributions. **LLVM_RUNTIME_DISTRIBUTION_COMPONENTS**:STRING; This variable can be set to a semi-colon separated list of runtime library; components. This is used in conjunction with *LLVM_ENABLE_RUNTIMES* to specify; components of runtime libraries that you want to include in your distribution.; Just like with *LLVM_DISTRIBUTION_COMPONENTS*, component names match the names; of the build system targets. **LLVM_DYLIB_COMPONENTS**:STRING; This variable can be set to a semi-colon separated name of LLVM library; components. LLVM library co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:11512,variab,variable,11512,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['variab'],['variable']
Modifiability,"etting up the; code, to compiling, loading, and executing it. After the basics are down, more; advanced features are discussed. .. warning::; This document deals with the legacy pass manager. LLVM uses the new pass; manager for the optimization pipeline (the codegen pipeline; still uses the legacy pass manager), which has its own way of defining; passes. For more details, see :doc:`WritingAnLLVMNewPMPass` and; :doc:`NewPassManager`. Quick Start --- Writing hello world; ===================================. Here we describe how to write the ""hello world"" of passes. The ""Hello"" pass is; designed to simply print out the name of non-external functions that exist in; the program being compiled. It does not modify the program at all, it just; inspects it. The source code and files for this pass are available in the LLVM; source tree in the ``lib/Transforms/Hello`` directory. .. _writing-an-llvm-pass-makefile:. Setting up the build environment; --------------------------------. First, configure and build LLVM. Next, you need to create a new directory; somewhere in the LLVM source base. For this example, we'll assume that you; made ``lib/Transforms/Hello``. Finally, you must set up a build script; that will compile the source code for the new pass. To do this,; copy the following into ``CMakeLists.txt``:. .. code-block:: cmake. add_llvm_library( LLVMHello MODULE; Hello.cpp. PLUGIN_TOOL; opt; ). and the following line into ``lib/Transforms/CMakeLists.txt``:. .. code-block:: cmake. add_subdirectory(Hello). (Note that there is already a directory named ``Hello`` with a sample ""Hello""; pass; you may play with it -- in which case you don't need to modify any; ``CMakeLists.txt`` files -- or, if you want to create everything from scratch,; use another name.). This build script specifies that ``Hello.cpp`` file in the current directory; is to be compiled and linked into a shared object ``$(LEVEL)/lib/LLVMHello.so`` that; can be dynamically loaded by the :program:`opt` tool via its :o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:2482,config,configure,2482,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['config'],['configure']
Modifiability,"etup in this folder, and can be found in `<builddir>/lib/`.; Loading it with `LD_PRELOAD` will bring ROOT's default sanitiser config into any non-sanitised executable, e.g. python.; 2. ROOT executables will get the config automatically, using a static version of the config library, `libROOTStaticSanitizerConfig.a`.; All ROOT executables statically link against it, so they start up without reporting lots of unfixable memory leaks (e.g. llvm). #### Small linker magic to get the config symbols into ROOT's executables; When linking a ROOT executable, the setup functions from the sanitiser config library might get ignored, because they are not used in any of our executables.; In `cmake/modules/SetUp{Linux|MacOS}.cmake`, the functions are therefore marked as ""undefined"" for the linker, so it starts copying; them into all ROOT executables.; This way, root.exe, cling, ... can start up with a sane default config. ### Use your own address/leak sanitizer configuration; The default configurations can be overridden using the environment variables `ASAN_OPTIONS` and `LSAN_OPTIONS`. Refer to the; [address sanitizer documentation](https://github.com/google/sanitizers/wiki/AddressSanitizer) or use `ASAN_OPTIONS=help=1` when starting; up a sanitised executable (e.g. `root.exe`). A template for a leak suppression file can be found in `$ROOTSYS/etc/lsan-root.supp`. ## Create your own sanitised executable; ROOT exports a library target called `ROOT::ROOTStaticSanitizerConfig` that can be used to create sanitised executables with ROOT's default; address sanitizer config. Linking against this target will add the above setup functions and also add the address sanitizer flags that; ROOT was built with. It should be sufficient to; - Link all executables against this target; - And have `-fsanitize=address` in the `CXXFLAGS`. ## Use sanitised ROOT libraries from a non-sanitised executable (e.g. `python`); When ROOT libraries are built with sanitizers, the address sanitizer runtime needs to be l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md:1684,config,configuration,1684,core/sanitizer/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md,3,"['config', 'variab']","['configuration', 'configurations', 'variables']"
Modifiability,"eturn adr[0] | (adr[1] << 8);; }; unsigned short read_16_be(const unsigned char *adr) {; return (adr[0] << 8) | adr[1];; }. //===---------------------------------------------------------------------===//. -instcombine should handle this transform:; icmp pred (sdiv X / C1 ), C2; when X, C1, and C2 are unsigned. Similarly for udiv and signed operands. . Currently InstCombine avoids this transform but will do it when the signs of; the operands and the sign of the divide match. See the FIXME in ; InstructionCombining.cpp in the visitSetCondInst method after the switch case ; for Instruction::UDiv (around line 4447) for more details. The SingleSource/Benchmarks/Shootout-C++/hash and hash2 tests have examples of; this construct. . //===---------------------------------------------------------------------===//. [LOOP OPTIMIZATION]. SingleSource/Benchmarks/Misc/dt.c shows several interesting optimization; opportunities in its double_array_divs_variable function: it needs loop; interchange, memory promotion (which LICM already does), vectorization and; variable trip count loop unrolling (since it has a constant trip count). ICC; apparently produces this very nice code with -ffast-math:. ..B1.70: # Preds ..B1.70 ..B1.69; mulpd %xmm0, %xmm1 #108.2; mulpd %xmm0, %xmm1 #108.2; mulpd %xmm0, %xmm1 #108.2; mulpd %xmm0, %xmm1 #108.2; addl $8, %edx #; cmpl $131072, %edx #108.2; jb ..B1.70 # Prob 99% #108.2. It would be better to count down to zero, but this is a lot better than what we; do. //===---------------------------------------------------------------------===//. Consider:. typedef unsigned U32;; typedef unsigned long long U64;; int test (U32 *inst, U64 *regs) {; U64 effective_addr2;; U32 temp = *inst;; int r1 = (temp >> 20) & 0xf;; int b2 = (temp >> 16) & 0xf;; effective_addr2 = temp & 0xfff;; if (b2) effective_addr2 += regs[b2];; b2 = (temp >> 12) & 0xf;; if (b2) effective_addr2 += regs[b2];; effective_addr2 &= regs[4];; if ((effective_addr2 & 3) == 0); return 1;; return 0;; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:8488,variab,variable,8488,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,2,['variab'],['variable']
Modifiability,"etween ""text"" and \#lambda were ignored. ``` {.cpp}; TLatex t; t.DrawLatex( 0.1,0.1,""text \#Lambda"" ); ```. - Implement `#backslash`.; - Implement `DrawLatexNDC`.; - Implement `#minus` and `#plus` typographically better than the; standard `""-""` and `""+""`.; - Make sure all greek and math symbols are printed correctly by `TTexDump`.; - Implement dummy operators `#mbox` and `#hbox` to improve the compatibility; between `TLatex`, `TMathText` and `TTexDump`.; - Some operators like `#minus`, `#plus`, `#mp`, `#hbar` etc ...; ignored the color defined by the operator `#color`.; - With the Cocoa backend on Mac the text string were a bit too large; compared to the TTF rendering. ### TPave. - Implement `SetX1()` etc ... for `TPave` and inherited classes to make sure the; NDC coordinates are also defined. ### TLinearGradient and TRadialGradient. - Two new classes to support color gradient: `TLinearGradient` and `TRadialGradient`.; Both classes inherit from `TColor` and can be used the same way as ROOT's; standard colors in `TAttFill` (`SetFillColor(newColorIndex)`).; Gradient fill can be created using either RGBA values directly, or from; color indices (colors from the ROOT's color table).; - TRadialGradient supports a simple radial gradient (center + radius); and an ""extended"" radial gradient (starting/ending points + two radii).; - The new gradient fill option is available either with OpenGL (""gl-in-pad""); or with a Cocoa backend (OS X only).; - Please note, at the moment, a color gradient can not be saved; in a ROOT file or a pdf/ps file. It can be saved as an image (png/jpg etc.).; - There are several demos in the tutorials/cocoa and tutorials/gl sub-directories; explaining how to use these new classes:; * grad.C; * grad2.C; * radialgradients.C. ![TRadialGradient example](ellipses.png ""TEllipse objects with a radial gradient fill""). ![TLinearGradient example](lingrad.png ""Two histograms with a linear gradient fill and transparency""). ![Gradient example](mixgrad.png ""TPie wit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md:7773,inherit,inherit,7773,graf2d/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md,1,['inherit'],['inherit']
Modifiability,"event error dterr and all its parameters, convoluted with a triple; gaussian resolution model and multiplied with a Gaussian p.d.f. in the; energy substituted mass. (In plain RooFit this would have required at; least 23 lines of code). A series of three new tutorial macros has been added to illustrate the; various features of the object factory. rf511_wsfactory_basic.C - Basic factory concepts; rf512_wsfactory_oper.C - Using operator p.d.f.s in the factory; rf513_wsfactory_tools.C - Advanced example using interfaced high level tools. A formal transaction model is used to commit composite objects into; the workspace. If an error is detected in the expression, no objects; will be committed to the workspace, thus leaving no 'partial builds'. Compact demo of several new major features. The macro below demonstrates in a couple of lines a number of major new features in RooFit 3.00: Use of. workspace factory to quickly create and store (compiled) models; workspace CINT interface to easily access contents in a typesafe way; new adaptive ND numeric integration technique to normalize arbitrary p.d.f. in fast; and reliable way; new adaptive TFoam sampling technique to efficiently generate toy MC data from strongly; peaked datasets; parallel processing in likelihood construction and use of profile likelihood operator; to represent profile likelihoods as regular RooFit functions. void demo(); {; // Construct compiled 2-D model that requires numeric integration for normalization; RooWorkspace w(""w"",1) ;; w.factory(""CEXPR::model('1/((x-a)*(x-a)+0.001)+1/((y-b)*(y-b)+0.001)',x[-1,1],y[-1,1],a[-5,5],b[-5,5])"") ;. // Generate data from model (using TFoam adaptive sampling algorithm); RooDataSet* d = w::model.generate(RooArgSet(w::x,w::y),1000) ;; w::model.fitTo(*d) ;. // Make 2D plot on (x,y); TH2* hh = w::model.createHistogram(""x,y"",40,40) ;; hh->SetLineColor(kBlue) ;. // Make Projection on x (integrate over y); RooPlot* framex = w::x.frame(Title(""Data and p.d.f. projected on X"")) ;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:22070,adapt,adaptive,22070,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['adapt'],['adaptive']
Modifiability,"ever written to disk as a pointer value. If it is a; pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL); is written. If the declaration line has a comment beginning with ""//->"", this indicates; that the pointer value will never be null, which allows a performance optimization.; Another optimization is that if two or more pointers pointing to the same object are; streamed in the same I/O operation, the object is written only once. The remaining; pointers reference the object through a unique object identifier. This saves space; and avoids the infinite loop that might otherwise arise if the directed graph of object; instance pointer references contains a cycle. If a data member is a pointer to a simple type, the Streamer presumes it is an array,; with the dimension defined in a comment of the form ""//[<length>]"", where length is; either an integer constant or a variable that is an integer data member of the class.; If a variable is used, it must be defined ahead of its use or in a base class. The above describes the function of the StreamerInfo record in decomposing a; self-identifying object if the user uses the streamer generated by ""rootcint"".; There are two reasons why a user may need to write a specialized streamer for a class.; One reason is that it may be necessary to execute some code before or after data is read; or written, for example, to initialize some non-persistent data members after the; persistent data is read. In this case, the custom streamer can use the StreamerInfo record; to decompose a self-identifying object in the exact same manner as the generated; streamer would have done. An example is given (for the Event class) in the Root User's; Guide (URL below) (Input/Output chapter, Streamers subchapter). On the other hand, if; the user needs to write a streamer for a class that ROOT cannot handle, the user may need; to explicitly code the decomposition and composition of the object to its members.; In this case, th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md:8740,variab,variable,8740,io/doc/TFile/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md,1,['variab'],['variable']
Modifiability,eviceRTL/include; - `8`; - `8`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openmp/runtime/src/thirdparty/ittnotify/legacy; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer/tests/ompt; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests; - `1`; - `1`; - `0`; - :good,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122601,plugin,plugins,122601,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['plugin'],['plugins']
Modifiability,"evious value that we replace in OldBindings. .. code-block:: c++. // Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.; Value *InitVal;; if (Init) {; InitVal = Init->codegen();; if (!InitVal); return nullptr;; } else { // If not specified, use 0.0.; InitVal = ConstantFP::get(*TheContext, APFloat(0.0));; }. AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);; Builder->CreateStore(InitVal, Alloca);. // Remember the old variable binding so that we can restore the binding when; // we unrecurse.; OldBindings.push_back(NamedValues[VarName]);. // Remember this binding.; NamedValues[VarName] = Alloca;; }. There are more comments here than code. The basic idea is that we emit; the initializer, create the alloca, then update the symbol table to; point to it. Once all the variables are installed in the symbol table,; we evaluate the body of the var/in expression:. .. code-block:: c++. // Codegen the body, now that all vars are in scope.; Value *BodyVal = Body->codegen();; if (!BodyVal); return nullptr;. Finally, before returning, we restore the previous variable bindings:. .. code-block:: c++. // Pop all our variables from scope.; for (unsigned i = 0, e = VarNames.size(); i != e; ++i); NamedValues[VarNames[i].first] = OldBindings[i];. // Return the body computation.; return BodyVal;; }. The end result of all of this is that we get properly scoped variable; definitions, and we even (trivially) allow mutation of them :). With this, we completed what we set out to do. Our nice iterative fib; example from the intro compiles and runs just fine. The mem2reg pass; optimizes all of our stack variables into SSA registers, inserting PHI; nodes where needed, and our front-end remains simple: no ""iterated; dominance frontier"" computation anywhere in sight. Full Code Listing; =================. Here is th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:28037,variab,variables,28037,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability,"ew TLatex(0.01, 0.3, ""Font styles: #^{}bf{#bf{bold}}, #^{}it{#it{italic}}, #^{}bf{#^{}it{#bf{#it{bold italic}}}}, #^{}bf{#^{}bf{#bf{#bf{unbold}}}}""))->Draw();; (new TLatex(0.01, 0.1, ""Font styles: abc#alpha#beta#gamma, #^{}it{#it{abc#alpha#beta#gamma}}, #^{}it{#^{}it{#it{#it{abc#alpha#beta#gamma}}}}""))->Draw();; }. Done by: Oleksandr Grebenyuk <ogrebenyuk@lbl.gov>.; Two new characters: #forall and #exists. TText. New method GetTextAdvance to return the text advance for string; text taking the kerning into account or not. TGaxis. In case of horizontal axis with the font size in pixel (font precision = 3); the labels were not visible.; Alpha numeric labels are not scaled anymore in case of text precision 3; (size in pixels). They are in the other precisions.; Fix a precision issue on Mac. With the following lines the last label; (10^3) did not show:; ; t1 = new TH1F(""test"",""test"", 100,1,1000);; t1.Draw();; gPad->SetLogx(1);; . TPaveStats. The stats painting assumed that the stats position was always defined with; Y2>Y1 and X2>X1. This is true when the stats is created automatically but; might not true if the stats position is given by user. This is now; protected. The stats are correctly drawn whatever the orders of X and Y; coordinates are. ; Saving canvas as a .C macro discarded white title and stat box; background. Same thing with TPaveText. TCutG. IsInside(x,y) is now inherited from TGraph. TCanvas and TPad. In case of Canvas.MoveOpaque = true in $ROOTSYS/etc/system.rootrc; the rubberband was not visible during the zooming along axis.; TPad::SaveAs now takes care of the extensions .pdf],; .pdf[, .pad( and .pdf) to avoid the PS and PDF; mixing when a multiple pages PDF files is generated. To work around this; problem it was enough to specify the option ""pdf"" in SaveAs.; c->BuildLegend() created the legend in the current pad,; not in c (as it should). ; A square TCanvas saved in batch mode in a ROOT file was not square anymore; when displayed in interactive mode. . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v528/index.html:6722,inherit,inherited,6722,graf2d/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v528/index.html,2,['inherit'],['inherited']
Modifiability,"ew algorithmic optimization in the caching of pdfs. So far - in the likelihood - two classes of; objects are identified: those that change with every event (i.e. the pdf) and those that change; only with the parameters (typically pdf normalization integrals). Pdfs are always recalculated; for every event, whereas integrals are only evaluated when needed. The exception to the first type are pdfs; that only depend on constant parameters (or no parameters) - these are identified at the beginning, and precalculated once ; to avoid recalculating an expression with the same outcome for every iteration of the likelihood calculation. For composite pdfs a further optimization has been included: for a M(x,a,b) = f*F(x,a)+(1-f)G(x,b) ; it is e.g. not needed to recalculate G(x,b) if only parameter a has changed w.r.t to the previous likelihood; calculation. This optimization is now implemented by extending the value caching originally designed; for constant terms to be usable for non-constant terms, with a check executed at the beginning of each; likelihood evaluation if selected columns need to be updated because parameters have changed. The speed gain; of this optimization depends much on the structure of the pdf: in models with many free parameters most of the; likelihood evaluations are executed when MINUIT calculates numerical likelihood derivatives which vary ; one parameter at a time and the speedup is potentially larger. In models with few free parameters the; effect will be smaller. The new per-component caching strategy is enabled by default for all pdfs that are a component of; a RooAddPdf or a RooRealSumPdf, unless that component is a RooProdPdf or a RooProduct, in that; case the components of the product are cached instead of the product itself. You can disable this; new optimization by adding Optimize(1) to the RooAbsPdf::fitTo() command line (0 = no caching,; 1 = cache constant terms only, 2 = cache also variable terms according to above mentioned strategy (DEFAUL",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html:2578,extend,extending,2578,roofit/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html,2,['extend'],['extending']
Modifiability,"ex, and VariableIndex(name) to return the index of a variable given a name.; Set a status code in Minuit2Minimizer according to the following convention:; status = minimizeStatus + 10 * minosStatus + 100 * hesseStatus.; See the Minuit2Minimizer reference documentation for the possible values of minimizeStatus , minosStatus and hesseStatus.; In MnHesse. when the inversion of the hessian matrix failed, return MnInvertFailed instead of MnHesseFailed. Mathcore Fitting classes. Fix the fitting with the integral option in multi-dimensions.; Force the gradient calculation when requested in the minimizer; classes and avoid to perform the check when using TMinuit. This was; already the case in Minuit2.; Add new class ROOT::Fit::SparseData for dealing with binned sparse data. This class automatically merges the empty region, so they can be considered, whenever possible as a larger single bin. This improves the performances when doing likelihood fits on the sparse data.; Fix the likelihood fits for variable bin histograms. Now a correct normalization is applied according to the bin volume.; Add new methods in Minimizer class :. Minimizer::SetPrecision(double eps) to change in the minimizer the precision on which the objective functions are evaluated. By default the numerical double precision is used inside the minimizers. This method should be used only if the precision in the function evaluation is worse than the double precision.; std::string Minimizer::VariableName (unsigned int index) to return a name of the minimizer variable (i.e. a fitting parameter) given the integer index. Return an empty string if the variable is not found or of the minimizer does not re-implement this method.; int Minimizer::VariableIndex(const std::string & name) to return the index of a variable given a name. Return -1 if the variable is not found or if the specific minimizer does not re-implement this function. ROOT::Fit::FitResult: fix a problem in the I/O, the function pointer is now made tempo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v526/index.html:3200,variab,variable,3200,math/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v526/index.html,2,['variab'],['variable']
Modifiability,"example we will copy an entire canvas to a new one with; `DrawClonePad`. Run the script `draw2dopt.C`. ``` {.cpp}; root[] .x tutorials/hist/draw2dopt.C; ```. This creates a canvas with 2D histograms. To make a copy of the canvas; follow the steps:. - Right-click on it to bring up the context menu. - Select `DrawClonePad`. This copies the entire canvas and all its sub-pads to a new canvas. The; copied canvas is a deep clone, and all the objects on it are copies and; independent of the original objects. For instance, change the fill on; one of the original histograms, and the cloned histogram retains its; attributes. `DrawClonePad` will copy the canvas to the active pad; the; target does not have to be a canvas. It can also be a pad on a canvas. ![Different draw options](pictures/030000D7.png). If you want to copy and paste a graphic object from one canvas or pad to; another canvas or pad, you can do so with `DrawClone` method inherited; from **`TObject`**. All graphics objects inherit the; `TObject::DrawClone` method. In this example, we create a new canvas; with one histogram from each of the canvases from the script; `draw2dopt.C`. - Start a new ROOT session and execute the script `draw2dopt.C`. - Select a canvas displayed by the script, and create a new canvas; `c1` from the File menu. - Make sure that the target canvas (`c1`) is the active one by middle; clicking on it. If you do this step right after step 2, c1 will be; active. - Select the pad with the first histogram you want to copy and paste. - Right click on it to show the context menu, and select `DrawClone`. - Leave the option blank and hit OK. Repeat these steps for one histogram on each of the canvases created by; the script, until you have one pad from each type. If you wanted to put; the same annotation on each of the sub pads in the new canvas, you could; use `DrawClone` to do so. Here we added the date to each pad. The steps; to this are:. - Create the label in on of the pads with the graphics editor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:87133,inherit,inherit,87133,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['inherit'],['inherit']
Modifiability,"example, SimpleStreamChecker should highlight; the event of opening the file when reporting a file descriptor leak. If the check tracks anything in the program state, it needs to implement the; checkDeadSymbolscallback to clean the state up.; The check should conservatively assume that the program is correct when a tracked symbol; is passed to a function that is unknown to the analyzer.; checkPointerEscape callback could help you handle that case.; Use safe and convenient APIs!. Always use CheckerContext::generateErrorNode and; CheckerContext::generateNonFatalErrorNode for emitting bug reports.; Most importantly, never emit report against CheckerContext::getPredecessor.; Prefer checkPreCall and checkPostCall to; checkPreStmt<CallExpr> and checkPostStmt<CallExpr>.; Use CallDescription to detect hardcoded API calls in the program.; Simplify C.getState()->getSVal(E, C.getLocationContext()) to C.getSVal(E). Common sources of crashes:. CallEvent::getOriginExpr is nullable - for example, it returns null for an; automatic destructor of a variable. The same applies to some values generated while the; call was modeled, eg. SymbolConjured::getStmt is nullable.; CallEvent::getDecl is nullable - for example, it returns null for a; call of symbolic function pointer.; addTransition, generateSink, generateNonFatalErrorNode,; generateErrorNode are nullable because you can transition to a node that you have already visited.; Methods of CallExpr/FunctionDecl/CallEvent that; return arguments crash when the argument is out-of-bounds. If you checked the function name,; it doesn't mean that the function has the expected number of arguments!; Which is why you should use CallDescription.; Nullability of different entities within different kinds of symbols and regions is usually; documented via assertions in their constructors.; NamedDecl::getName will fail if the name of the declaration is not a single token,; e.g. for destructors. You could use NamedDecl::getNameAsString for those cases.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:24650,variab,variable,24650,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,2,['variab'],['variable']
Modifiability,"example,; the ""add missing switch cases"" refactoring operation typically adds missing; cases to one switch at a time. However, it could be useful to have a; refactoring that works on all switches that operate on a particular enum, as; one could then automatically update all of them after adding a new enum; constant. To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a single switch. The second rule will; describe a global operation that works across translation units and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then analyze; the selection and other options passed to the refactoring action, and will pick; the most appropriate rule for the given selection and other options. Rule Types; ^^^^^^^^^^. Clang's refactoring engine supports several different refactoring rules:. - ``SourceChangeRefactoringRule`` produces source replacements that are applied; to the source files. Subclasses that choose to implement this rule have to; implement the ``createSourceReplacements`` member function. This type of; rule is typically used to implement local refactorings that transform the; source in one translation unit only. - ``FindSymbolOccurrencesRefactoringRule`` produces a ""partial"" refactoring; result: a set of occurrences that refer to a particular symbol. This type; of rule is typically used to implement an interactive renaming action that; allows users to specify which occurrences should be renamed during the; refactoring. Subclasses that choose to implement this rule have to implement; the ``findSymbolOccurrences`` member function. The following set of quick checks might help if you are unsure about the type; of rule you should use:. #. If you would like to transform the source in one translation unit and if; you don't nee",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:3674,refactor,refactoring,3674,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,2,['refactor'],['refactoring']
Modifiability,"example`` GC strategy uses to distinguish references from; non references. This is controlled via GCStrategy::isGCManagedPointer. The; ``statepoint-example`` and ``coreclr`` strategies (the only two default; strategies that support statepoints) both use addrspace(1) to determine which; pointers are references, however custom strategies don't have to follow this; convention. This pass can be used an utility function by a language frontend that doesn't; want to manually reason about liveness, base pointers, or relocation when; constructing IR. As currently implemented, RewriteStatepointsForGC must be; run after SSA construction (i.e. mem2ref). RewriteStatepointsForGC will ensure that appropriate base pointers are listed; for every relocation created. It will do so by duplicating code as needed to; propagate the base pointer associated with each pointer being relocated to; the appropriate safepoints. The implementation assumes that the following; IR constructs produce base pointers: loads from the heap, addresses of global; variables, function arguments, function return values. Constant pointers (such; as null) are also assumed to be base pointers. In practice, this constraint; can be relaxed to producing interior derived pointers provided the target; collector can find the associated allocation from an arbitrary interior; derived pointer. By default RewriteStatepointsForGC passes in ``0xABCDEF00`` as the statepoint; ID and ``0`` as the number of patchable bytes to the newly constructed; ``gc.statepoint``. These values can be configured on a per-callsite; basis using the attributes ``""statepoint-id""`` and; ``""statepoint-num-patch-bytes""``. If a call site is marked with a; ``""statepoint-id""`` function attribute and its value is a positive; integer (represented as a string), then that value is used as the ID; of the newly constructed ``gc.statepoint``. If a call site is marked; with a ``""statepoint-num-patch-bytes""`` function attribute and its; value is a positive integer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:27744,variab,variables,27744,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['variab'],['variables']
Modifiability,"exception reporting detailing; * Mapped C++ exception cleanup bug fix; * STL vector constructor passes the CPython sequence construction; * STL vector slicing passes the CPython sequence slicing tests; * Extended documentation. 2019-12-23: 1.6.0; -----------------. * Classes derived from ``std::exception`` can be used as Python exceptions; * Template handling detailing (for Eigen); * Support keyword arguments; * Added add_library_path at module level; * Extended documentation; * Fix regression bugs: #176, #179, #180, #182. 2019-11-07: 1.5.7; -----------------. * Allow implicit converions for move arguments; * Choose vector over initializer_list if part of the template argument list. 2019-11-03: 1.5.6; -----------------. * Added public C++ API for some CPyCppyy core functions (CPython only); * Support for char16_t/char16_t* and char32_t/char32_t*; * Respect ``std::hash`` in ``__hash__``; * Fix iteration over vector of shared_ptr; * Length checking on global variables of type 'signed char[N]'; * Properly support overloaded templated with non-templated ``__setitem__``; * Support for array of const char* as C-strings; * Enable type resolution of clang's builtin ``__type_pack_element``; * Fix for inner class type naming when it directly declares a variable. 2019-10-16: 1.5.5; -----------------. * Added signal -> exception support in cppyy.ll; * Support for lazily combining overloads of operator*/+-; * No longer call trivial destructors; * Support for free function unary operators; * Refactored and optimized operator==/!= usage; * Refactored converters/executors for lower memory usage; * Bug fixes in rootcling and _cppyy_generator.py. 2019-09-25: 1.5.4; -----------------. * operator+/* now respect C++-side associativity; * Fix potential crash if modules are reloaded; * Fix some portability issues on Mac/Windows of cppyy-cling. 2019-09-15: 1.5.3; -----------------. * Performance improvements; * Support for anonymous/unnamed/nested unions; * Extended documentation. 2019-09-0",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:15797,variab,variables,15797,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"expected name and returns it. Because all values in; Kaleidoscope are doubles, there is no need to pass in a type to use. With this in place, the first functionality change we want to make belongs to; variable references. In our new scheme, variables live on the stack, so; code generating a reference to them actually needs to produce a load; from the stack slot:. .. code-block:: c++. Value *VariableExprAST::codegen() {; // Look this variable up in the function.; AllocaInst *A = NamedValues[Name];; if (!A); return LogErrorV(""Unknown variable name"");. // Load the value.; return Builder->CreateLoad(A->getAllocatedType(), A, Name.c_str());; }. As you can see, this is pretty straightforward. Now we need to update; the things that define the variables to set up the alloca. We'll start; with ``ForExprAST::codegen()`` (see the `full code listing <#id1>`_ for; the unabridged code):. .. code-block:: c++. Function *TheFunction = Builder->GetInsertBlock()->getParent();. // Create an alloca for the variable in the entry block.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);. // Emit the start code first, without 'variable' in scope.; Value *StartVal = Start->codegen();; if (!StartVal); return nullptr;. // Store the value into the alloca.; Builder->CreateStore(StartVal, Alloca);; ... // Compute the end condition.; Value *EndCond = End->codegen();; if (!EndCond); return nullptr;. // Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.; Value *CurVar = Builder->CreateLoad(Alloca->getAllocatedType(), Alloca,; VarName.c_str());; Value *NextVar = Builder->CreateFAdd(CurVar, StepVal, ""nextvar"");; Builder->CreateStore(NextVar, Alloca);; ... This code is virtually identical to the code `before we allowed mutable; variables <LangImpl05.html#code-generation-for-the-for-loop>`_. The big difference is that we; no longer have to construct a PHI node, and we use load/store to access; the variable as needed. To ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:14506,variab,variable,14506,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"explicit template instantiation declarations. - The ``-fno-auto-import`` option was added for MinGW targets. The option both; affects code generation (inhibiting generating indirection via ``.refptr``; stubs for potentially auto imported symbols, generating smaller and more; efficient code) and linking (making the linker error out on such cases).; If the option only is used during code generation but not when linking,; linking may succeed but the resulting executables may expose issues at; runtime. - Clang now passes relevant LTO options to the linker (LLD) in MinGW mode. LoongArch Support; ^^^^^^^^^^^^^^^^^; - Added builtins support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; - Added builtins support for approximate calculation instructions that were; introduced in LoongArch Reference Manual V1.10.; - Made ``-mcmodel=`` compatible with LoongArch gcc that accepted ``normal``,; ``medium`` and ``extreme``.; - The ``model`` attribute was now supported for overriding the default code; model used to access global variables. The following values were supported:; ``normal``, ``medium`` and ``extreme``. *Example Code*:. .. code-block:: c. int var __attribute((model(""extreme"")));. - Default to ``-fno-direct-access-external-data`` for non-PIC.; - An ABI mismatch with gcc/g++ about empty structs/unions passing was fixed.; - ``_mcount`` was generated instead of ``mcount``. RISC-V Support; ^^^^^^^^^^^^^^; - Unaligned memory accesses can be toggled by ``-m[no-]unaligned-access`` or the; aliases ``-m[no-]strict-align``.; - CodeGen of RV32E/RV64E was supported experimentally.; - CodeGen of ilp32e/lp64e was supported experimentally. - Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:63811,variab,variables,63811,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['variab'],['variables']
Modifiability,"explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<VarDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<VarDecl>isInitCapture; Matches a variable serving as the implicit variable for a lambda init-; capture. Example matches x (matcher = varDecl(isInitCapture())); auto f = [x=3]() { return x; };. Matcher<VarDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<VarDecl>isStaticLocal; Matches a static variable with local scope. Example matches y (matcher = varDecl(isStaticLocal())); void f() {; int x;; static int y;; }; static int z;. Matcher<VarDecl>isStaticStorageClass; Matches variable/function declarations that have ""static"" storage; class specifier (""static"" keyword) written in the source. Given:; static void f() {}; static int i = 0;; extern int j;; int k;; functionDecl(isStaticStorageClass()); matches the function declaration f.; varDecl(isStaticStorageClass()); matches the variable declaration i. Matcher<VarDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:127987,variab,variables,127987,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['variab'],['variables']
Modifiability,expressions; No. 1969; CD6; Missing exclusion of ~S as an ordinary function name; Unknown. 1970; NAD; Ambiguity resolution for (T())*x; Unknown. 1971; CD4; Unclear disambiguation of destructor and operator~; Unknown. 1972; CD6; Identifier character restrictions in non-identifiers; Unknown. 1973; DRWP; Which parameter-declaration-clause in a lambda-expression?; Unknown. 1974; NAD; Redundant specification of non-type typename-specifier; Unknown. 1975; CD4; Permissible declarations for exception-specifications; Unknown. 1976; NAD; Ambiguity of namespace-aliases; Unknown. 1977; drafting; Contradictory results of failed destructor lookup; Not resolved. 1978; CD4; Redundant description of explicit constructor use; Unknown. 1979; drafting; Alias template specialization in template member definition; Not resolved. 1980; drafting; Equivalent but not functionally-equivalent redeclarations; Not resolved. 1981; CD4; Implicit contextual conversions and explicit; Unknown. 1982; NAD; Deduction extending parameter pack; Unknown. 1983; CD5; Inappropriate use of virt-specifier; Unknown. 1984; NAD; Lossless narrowing conversions; Unknown. 1985; NAD; Unknown bound array member with brace-or-equal-initializer; Unknown. 1986; drafting; odr-use and delayed initialization; Not resolved. 1987; NAD; constexpr static data members across translation units; Unknown. 1988; CD4; Ambiguity between dependent and non-dependent bases in implicit member access; Unknown. 1989; drafting; Insufficient restrictions on parameters of postfix operators; Not resolved. 1990; CD4; Ambiguity due to optional decl-specifier-seq; Unknown. 1991; CD4; Inheriting constructors vs default arguments; Clang 3.9. 1992; CD4; new (std::nothrow) int[N] can throw; Unknown. 1993; drafting; Use of template<> defining member of explicit specialization; Not resolved. 1994; dup; Confusing wording regarding multiple template<> prefixes; Duplicate of 529. 1995; CD4; exception-specifications and non-type template parameters; Unknown. ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:134656,extend,extending,134656,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['extend'],['extending']
Modifiability,"ext i32 257 to i64 ; yields i64:257; %Y = zext i1 true to i32 ; yields i32:1; %Z = zext <2 x i16> <i16 8, i16 7> to <2 x i32> ; yields <i32 8, i32 7>. %a = zext nneg i8 127 to i16 ; yields i16 127; %b = zext nneg i8 -1 to i16 ; yields i16 poison. .. _i_sext:. '``sext .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = sext <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``sext``' sign extends ``value`` to the type ``ty2``. Arguments:; """""""""""""""""""". The '``sext``' instruction takes a value to cast, and a type to cast it; to. Both types must be of :ref:`integer <t_integer>` types, or vectors of; the same number of integers. The bit size of the ``value`` must be; smaller than the bit size of the destination type, ``ty2``. Semantics:; """""""""""""""""""". The '``sext``' instruction performs a sign extension by copying the sign; bit (highest order bit) of the ``value`` until it reaches the bit size; of the type ``ty2``. When sign extending from i1, the extension always results in -1 or 0. Example:; """""""""""""""". .. code-block:: llvm. %X = sext i8 -1 to i16 ; yields i16 :65535; %Y = sext i1 true to i32 ; yields i32:-1; %Z = sext <2 x i16> <i16 8, i16 7> to <2 x i32> ; yields <i32 8, i32 7>. '``fptrunc .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fptrunc <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``fptrunc``' instruction truncates ``value`` to type ``ty2``. Arguments:; """""""""""""""""""". The '``fptrunc``' instruction takes a :ref:`floating-point <t_floating>`; value to cast and a :ref:`floating-point <t_floating>` type to cast it to.; The size of ``value`` must be larger than the size of ``ty2``. This; implies that ``fptrunc`` cannot be used to make a *no-op cast*. Semantics:; """""""""""""""""""". The '``fptrunc``' instruction casts a ``value`` from a larger; :ref:`floating-point <t_floating>` type to a smaller :ref:`floating-point; <t_floating>` type.; This instruction is assumed to execute in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:445217,extend,extending,445217,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['extend'],['extending']
Modifiability,"f RV32E/RV64E was supported experimentally.; - CodeGen of ilp32e/lp64e was supported experimentally. - Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^^. - Clang now supports CUDA SDK up to 12.3; - Added support for sm_90a. PowerPC Support; ^^^^^^^^^^^^^^^. - Added ``nmmintrin.h`` to intrinsics headers.; - Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for corresponding instruction.; - Supported ``__attribute__((target(""tune=cpu"")))``.; - Emit ``float-abi`` module flag on 64-bit ELFv2 PowerPC targets if; ``long double`` type is used in current module. AIX Support; ^^^^^^^^^^^. - Introduced the ``-maix-small-local-exec-tls`` option to produce a faster; access sequence for local-exec TLS variables where the offset from the TLS; base is encoded as an immediate operand.; This access sequence is not used for TLS variables larger than 32KB, and is; currently only supported on 64-bit mode.; - Inline assembler supports VSR register in pure digits.; - Enabled ThinLTO support. Requires AIX 7.2 TL5 SP7 or newer, or AIX 7.3 TL2; or newer. Similar to the LTO support on AIX, ThinLTO is implemented with; the libLTO.so plugin. SystemZ Support; ^^^^^^^^^^^^^^^; - Properly support 16 byte atomic int/fp types and ops. Atomic __int128 (and; long double) variables are now aligned to 16 bytes by default (like gcc 14). WebAssembly Support; ^^^^^^^^^^^^^^^^^^^. AVR Support; ^^^^^^^^^^^. DWARF Support in Clang; ----------------------. Floating Point Support in Clang; -------------------------------; - Add ``__builtin_elementwise_log`` builtin for floating point types only.; - Add ``__builtin_elementwise_log10`` builtin for floating point types only.; - Add ``__builtin_elementw",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:65346,variab,variables,65346,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['variab'],['variables']
Modifiability,"f a variable is declared in the condition of an Objective-C fast enumeration; loop, and the variable has no explicit ownership qualifier, then it is; implicitly :ref:`externally-retained <arc.misc.externally_retained>` so that; objects encountered during the enumeration are not actually retained and; released. .. admonition:: Rationale. This is an optimization made possible because fast enumeration loops promise; to keep the objects retained during enumeration, and the collection itself; cannot be synchronously modified. It can be overridden by explicitly; qualifying the variable with ``__strong``, which will make the variable; mutable again and cause the loop to retain the objects it encounters. .. _arc.misc.blocks:. Blocks; ------. The implicit ``const`` capture variables created when evaluating a block; literal expression have the same ownership semantics as the local variables; they capture. The capture is performed by reading from the captured variable; and initializing the capture variable with that value; the capture variable is; destroyed when the block literal is, i.e. at the end of the enclosing scope. The :ref:`inference <arc.ownership.inference>` rules apply equally to; ``__block`` variables, which is a shift in semantics from non-ARC, where; ``__block`` variables did not implicitly retain during capture. ``__block`` variables of retainable object owner type are moved off the stack; by initializing the heap copy with the result of moving from the stack copy. With the exception of retains done as part of initializing a ``__strong``; parameter variable or reading a ``__weak`` variable, whenever these semantics; call for retaining a value of block-pointer type, it has the effect of a; ``Block_copy``. The optimizer may remove such copies when it sees that the; result is used only as an argument to a call. When a block pointer type is converted to a non-block pointer type (such as; ``id``), ``Block_copy`` is called. This is necessary because a block allocated",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:96412,variab,variable,96412,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,3,['variab'],['variable']
Modifiability,"f allocations are known to the runtime system. ""Exterior derived pointers"" are outside the bounds of the associated object;; they may even fall within *another* allocations address range. As a result,; there is no way for a garbage collector to determine which allocation they; are associated with at runtime and compiler support is needed. The ``gc.relocate`` intrinsic supports an explicit operand for describing the; allocation associated with a derived pointer. This operand is frequently; referred to as the base operand, but does not strictly speaking have to be; a base pointer, but it does need to lie within the bounds of the associated; allocation. Some collectors may require that the operand be an actual base; pointer rather than merely an internal derived pointer. Note that during; lowering both the base and derived pointer operands are required to be live; over the associated call safepoint even if the base is otherwise unused; afterwards. If we extend our previous example to include a pointless derived pointer,; we get:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; %gep = getelementptr i8, i8 addrspace(1)* %obj, i64 20000; %token = call token (i64, i32, void ()*, i32, i32, ...)* @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 0, i32 0, void ()* @foo, i32 0, i32 0, i32 0, i32 0, i8 addrspace(1)* %obj, i8 addrspace(1)* %gep); %obj.relocated = call i8 addrspace(1)* @llvm.experimental.gc.relocate.p1i8(token %token, i32 7, i32 7); %gep.relocated = call i8 addrspace(1)* @llvm.experimental.gc.relocate.p1i8(token %token, i32 7, i32 8); %p = getelementptr i8, i8 addrspace(1)* %gep, i64 -20000; ret i8 addrspace(1)* %p; }. Note that in this example %p and %obj.relocate are the same address and we; could replace one with the other, potentially removing the derived pointer; from the live set at the safepoint entirely. .. _gc_transition_args:. GC Transitions; ^^^^^^^^^^^^^^^^^^. As a practical consideration, many g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:15282,extend,extend,15282,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['extend'],['extend']
Modifiability,"f command line options. .. option:: -o <filename>. Specify the output filename. .. option:: -S. Write output in LLVM intermediate language (instead of bitcode). .. option:: -{passname}. :program:`opt` provides the ability to run any of LLVM's optimization or; analysis passes in any order. The :option:`-help` option lists all the passes; available. The order in which the options occur on the command line are the; order in which they are executed (within pass constraints). .. option:: -strip-debug. This option causes opt to strip debug information from the module before; applying other optimizations. It is essentially the same as `-strip`; but it ensures that stripping of debug information is done first. .. option:: -verify-each. This option causes opt to add a verify pass after every pass otherwise; specified on the command line (including `-verify`). This is useful; for cases where it is suspected that a pass is creating an invalid module but; it is not clear which pass is doing it. .. option:: -stats. Print statistics. .. option:: -time-passes. Record the amount of time needed for each pass and print it to standard; error. .. option:: -debug. If this is a debug build, this option will enable debug printouts from passes; which use the ``LLVM_DEBUG()`` macro. See the `LLVM Programmer's Manual; <../ProgrammersManual.html>`_, section ``#DEBUG`` for more information. .. option:: -load=<plugin>. Load the dynamic object ``plugin``. This object should register new; optimization or analysis passes. Once loaded, the object will add new command; line options to enable various optimizations or analyses. To see the new; complete list of optimizations, use the :option:`-help` and :option:`-load`; options together. For example:. .. code-block:: sh. opt -load=plugin.so -help. .. option:: -print-passes. Print all available passes and exit. EXIT STATUS; -----------. If :program:`opt` succeeds, it will exit with 0. Otherwise, if an error; occurs, it will exit with a non-zero value.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/opt.rst:2665,plugin,plugin,2665,interpreter/llvm-project/llvm/docs/CommandGuide/opt.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/opt.rst,3,['plugin'],['plugin']
Modifiability,"f course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters; is 5, and the number of internal parameters is 3. This is the number; which determines, for example, the size of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is that parameters are allowed to change types; during the M minimization and analysis of a $\mbox{FCN}$ function.; Several applications in M have methods available to make variable; parameters fixed and vice-versa; to impose, change, or remove limits; from variable parameters; and even to define completely new parameters; at any time during a run. In addition, some M applications (notably the; $\mbox{MINOS}$ error analysis) cause one or more variable parameter",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:6803,variab,variable,6803,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability,"f events in each sub-range was not used to estimate the PDF parameters.; From now on, the likelihoods are normalized by the sum of integrals in each range. This implies that the likelihood takes into account all inter-range and intra-range information. ### Deprecation of the `RooMinuit` class. The `RooMinuit` class was the old interface between RooFit and minuit. With ROOT version 5.24, the more general `RooMinimizer` adapter was introduced, which became the default with ROOT 6.08. Before 6.26, it was possible to still use the `RooMinuit` by passing the `Minimizer(""OldMinuit"", ""minimizer"")` command argument to `RooAbsPdf::fitTo()`. This option is now removed. ### Increase of the `RooAbsArg` class version. The class version of `RooAbsArg` was incremented from 7 to 8 in this release. In some circumstances, this can cause warnings in `TStreamerInfo` for classes inheriting from `RooAbsArg` when reading; older RooFit models from a file. These warnings are harmless and can be avoided by incrementing also the class version of the inheriting class. ### Compile-time protection against creating empty `RooCmdArg`s from strings. The implicit [RooCmdArg](https://root.cern/doc/v626/classRooCmdArg.html) constructor from `const char*` was removed to avoid the accidental construction of meaningless RooCmdArgs that only have a name but no payload.; This causes new compiler errors in your code if you pass a string instead of a RooCmdArg to various RooFit functions, such as [RooAbsPdf::fitTo()](https://root.cern/doc/v626/classRooAbsPdf.html#a5f79f16f4a26a19c9e66fb5c080f59c5).; If this happens, please consult the documentation of [fitTo()](https://root.cern/doc/v626/classRooAbsPdf.html#a5f79f16f4a26a19c9e66fb5c080f59c5) to check which of the [free functions in the `RooFit` namespace](https://root.cern/doc/v626/group__CmdArgs.html) you need to use to achieve the desired configuration. **Example** of an error that is now caught at compile time: confusing the [RooAbsPdf::fitTo()]() function",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:31072,inherit,inheriting,31072,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['inherit'],['inheriting']
Modifiability,"f foo { // Value; bit isMod = 1;; bit isRef = 0;; }; def snork { // Value; bit isMod = 1;; bit isRef = 1;; }. ``let`` --- override fields in classes or records; -------------------------------------------------. A ``let`` statement collects a set of field values (sometimes called; *bindings*) and applies them to all the classes and records defined by; statements within the scope of the ``let``. .. productionlist::; Let: ""let"" `LetList` ""in"" ""{"" `Statement`* ""}""; :| ""let"" `LetList` ""in"" `Statement`; LetList: `LetItem` ("","" `LetItem`)*; LetItem: `TokIdentifier` [""<"" `RangeList` "">""] ""="" `Value`. The ``let`` statement establishes a scope, which is a sequence of statements; in braces or a single statement with no braces. The bindings in the; :token:`LetList` apply to the statements in that scope. The field names in the :token:`LetList` must name fields in classes inherited by; the classes and records defined in the statements. The field values are; applied to the classes and records *after* the records inherit all the fields from; their parent classes. So the ``let`` acts to override inherited field; values. A ``let`` cannot override the value of a template argument. Top-level ``let`` statements are often useful when a few fields need to be; overridden in several records. Here are two examples. Note that ``let``; statements can be nested. .. code-block:: text. let isTerminator = true, isReturn = true, isBarrier = true, hasCtrlDep = true in; def RET : I<0xC3, RawFrm, (outs), (ins), ""ret"", [(X86retflag 0)]>;. let isCall = true in; // All calls clobber the non-callee saved registers...; let Defs = [EAX, ECX, EDX, FP0, FP1, FP2, FP3, FP4, FP5, FP6, ST0,; MM0, MM1, MM2, MM3, MM4, MM5, MM6, MM7, XMM0, XMM1, XMM2,; XMM3, XMM4, XMM5, XMM6, XMM7, EFLAGS] in {; def CALLpcrel32 : Ii32<0xE8, RawFrm, (outs), (ins i32imm:$dst, variable_ops),; ""call\t${dst:call}"", []>;; def CALL32r : I<0xFF, MRM2r, (outs), (ins GR32:$dst, variable_ops),; ""call\t{*}$dst"", [(X86call GR32:$dst)]>;; def C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:33579,inherit,inherit,33579,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inherit']
Modifiability,"f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^^. - Clang now supports CUDA SDK up to 12.3; - Added support for sm_90a. PowerPC Support; ^^^^^^^^^^^^^^^. - Added ``nmmintrin.h`` to intrinsics headers.; - Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for corresponding instruction.; - Supported ``__attribute__((target(""tune=cpu"")))``.; - Emit ``float-abi`` module flag on 64-bit ELFv2 PowerPC targets if; ``long double`` type is used in current module. AIX Support; ^^^^^^^^^^^. - Introduced the ``-maix-small-local-exec-tls`` option to produce a faster; access sequence for local-exec TLS variables where the offset from the TLS; base is encoded as an immediate operand.; This access sequence is not used for TLS variables larger than 32KB, and is; currently only supported on 64-bit mode.; - Inline assembler supports VSR register in pure digits.; - Enabled ThinLTO support. Requires AIX 7.2 TL5 SP7 or newer, or AIX 7.3 TL2; or newer. Similar to the LTO support on AIX, ThinLTO is implemented with; the libLTO.so plugin. SystemZ Support; ^^^^^^^^^^^^^^^; - Properly support 16 byte atomic int/fp types and ops. Atomic __int128 (and; long double) variables are now aligned to 16 bytes by default (like gcc 14). WebAssembly Support; ^^^^^^^^^^^^^^^^^^^. AVR Support; ^^^^^^^^^^^. DWARF Support in Clang; ----------------------. Floating Point Support in Clang; -------------------------------; - Add ``__builtin_elementwise_log`` builtin for floating point types only.; - Add ``__builtin_elementwise_log10`` builtin for floating point types only.; - Add ``__builtin_elementwise_log2`` builtin for floating point types only.; - Add ``__builtin_elementwise_exp`` builtin for floating point types only.; - Add ``__builtin_elementwise",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:65470,variab,variables,65470,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['variab'],['variables']
Modifiability,"f its two operands.; * mul - Returns the product of its two operands.; * sub - Returns the difference of its two operands. * ``<arguments>`` is a comma separated list of expressions. For example:. .. code-block:: llvm. ; CHECK: load r[[#REG:]], [r0]; ; CHECK: load r[[#REG+1]], [r1]; ; CHECK: Loading from 0x[[#%x,ADDR:]]; ; CHECK-SAME: to 0x[[#ADDR + 7]]. The above example would match the text:. .. code-block:: gas. load r5, [r0]; load r6, [r1]; Loading from 0xa0463440 to 0xa0463447. but would not match the text:. .. code-block:: gas. load r5, [r0]; load r7, [r1]; Loading from 0xa0463440 to 0xa0463443. Due to ``7`` being unequal to ``5 + 1`` and ``a0463443`` being unequal to; ``a0463440 + 7``. A numeric variable can also be defined to the result of a numeric expression,; in which case the numeric expression constraint is checked and if verified the; variable is assigned to the value. The unified syntax for both checking a; numeric expression and capturing its value into a numeric variable is thus; ``[[#%<fmtspec>,<NUMVAR>: <constraint> <expr>]]`` with each element as; described previously. One can use this syntax to make a testcase more; self-describing by using variables instead of values:. .. code-block:: gas. ; CHECK: mov r[[#REG_OFFSET:]], 0x[[#%X,FIELD_OFFSET:12]]; ; CHECK-NEXT: load r[[#]], [r[[#REG_BASE:]], r[[#REG_OFFSET]]]. which would match:. .. code-block:: gas. mov r4, 0xC; load r6, [r5, r4]. The ``--enable-var-scope`` option has the same effect on numeric variables as; on string variables. Important note: In its current implementation, an expression cannot use a; numeric variable defined earlier in the same CHECK directive. FileCheck Pseudo Numeric Variables; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Sometimes there's a need to verify output that contains line numbers of the; match file, e.g. when testing compiler diagnostics. This introduces a certain; fragility of the match file structure, as ""``CHECK:``"" lines contain absolute; line numbers in the same file",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:32891,variab,variable,32891,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variable']
Modifiability,"f scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7048,variab,variables,7048,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,4,['variab'],['variables']
Modifiability,"f specifying user credentials on a per-file; basis or for all S3 files via environment variables.; - honor the ""NOPROXY"" option when specified in the constructor.; - exploit the capability of the S3 file server to provide partial; content responses to multi-range HTTP requests. Here are some examples of usages from the end user perspective:. ``` {.cpp}; TFile* f = TFile::Open(""s3://s3.amazonaws.com/mybucket/path/to/my/file"", ""AUTH=<accessKey>:<secretKey> NOPROXY""); TFile* f = TFile::Open(""s3://s3.amazonaws.com/mybucket/path/to/my/file"") // Uses environmental variables for retrieving credentials; ```. Limitations:. - we cannot efficiently detect that a S3 server is able to respond to; multi-range HTTP GET requests. Some servers, such as Amazon's,; respond to such kind of requests with the whole file contents. Other; servers, such as Huawei's, respond with the exact partial content; requested. Therefore, I added the possibility of configuring the; behavior via the ROOT configuration file: the identity of the; servers known to correctly support multi-range requests is; configurable. If the server is known to support this feature, ROOT; will send multi-range requests, otherwise it will issue multiple; single-range GET requests, which is also the default behavior.; - currently the virtual host syntax:; ""s3://mybucket.s3.amazonaws.com/path/to/my/file"" is not supported; but can be added if this is considered useful. The TAS3File class will be removed and should not have been used; directly by users anyway as it was only accessed via the plugin manager; in TFile::Open(). ### New HTTP Server package. A new HTTP Server package has been introduced. The idea behind such server is to provide direct access to the data from a running ROOT application. Any object can be streamed when requested and delivered to the browser. ##### Starting HTTP server. To start http server, at any time create instance; of the **`THttpServer`** class like:. ``` {.cpp}; serv = new THttpServer(""http:808",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v600/index.md:1863,config,configuring,1863,net/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v600/index.md,3,['config'],"['configurable', 'configuration', 'configuring']"
Modifiability,"f the Block; literal expression evaluation. The compiler is not required to capture a variable if it can prove; that no references to the variable will actually be evaluated.; Programmers can force a variable to be captured by referencing it in a; statement at the beginning of the Block, like so:. .. code-block:: c. (void) foo;. This matters when capturing the variable has side-effects, as it can; in Objective-C or C++. The lifetime of variables declared in a Block is that of a function;; each activation frame contains a new copy of variables declared within; the local scope of the Block. Such variable declarations should be; allowed anywhere [testme] rather than only when C99 parsing is; requested, including for statements. [testme]. Block literal expressions may occur within Block literal expressions; (nest) and all variables captured by any nested blocks are implicitly; also captured in the scopes of their enclosing Blocks. A Block literal expression may be used as the initialization value for; Block variables at global or local static scope. The Invoke Operator; ===================. Blocks are :block-term:`invoked` using function call syntax with a; list of expression parameters of types corresponding to the; declaration and returning a result type also according to the; declaration. Given:. .. code-block:: c. int (^x)(char);; void (^z)(void);; int (^(*y))(char) = &x;. the following are all legal Block invocations:. .. code-block:: c. x('a');; (*y)('a');; (true ? x : *y)('a'). The Copy and Release Operations; ===============================. The compiler and runtime provide :block-term:`copy` and; :block-term:`release` operations for Block references that create and,; in matched use, release allocated storage for referenced Blocks. The copy operation ``Block_copy()`` is styled as a function that takes; an arbitrary Block reference and returns a Block reference of the same; type. The release operation, ``Block_release()``, is styled as a; function that takes an ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:5737,variab,variables,5737,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['variab'],['variables']
Modifiability,"f the current C++ interpreter in the ROOT project - CINT. The backward-compatibility with CINT is major priority during the development.; ; How to use it; You can start typing not only C++ top level declaratons but statements, too. ; **** Welcome to the cling prototype! ****; * Type C code and press enter to run it *; * Type .q, exit or ctrl+D to quit *; *****************************************; [cling]$. Statements and expressions could take more than one input line. The interactive prompt changes from ""[cling]$"" to ""[cling]$ ?"".; ; [cling]$ #include ""math.h""; [cling]$ #include ""stdio.h""; [cling]$ for (unsigned i = 0; i < 5; ++i) {; [cling]$ ? printf(""%f\n"", sin(i));; [cling]$ ? }; 0.000000; 0.841471; 0.909297; 0.141120; -0.756802; Grammar; Cling is able to parse everything that clang can. Current clang status can be found here. At the moment, there are use cases only for C++ that's why cling is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward to having more use-cases and extend our tool in that direction.; Cling has internal commands, which can change its behavior at runtime. Those commands usually start with dot (.):; .I <path> - Adds an include path;; .x <filename> - #include-s the filename; and calls function called filename(); ; .L <libname> - Loads libname or #include-s the libname if libname is file;; .@ - Cancels the multiline input;; .printAST - (DEBUG ONLY) Turns on the printing of the compiler's abstract syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:2029,extend,extend,2029,interpreter/cling/www/old/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html,2,['extend'],['extend']
Modifiability,"f the current supported ONNX operator is the following:; - Gemm; - Conv (in 1D,2D and 3D); - RNN, GRU, LSTM; - Relu, Selu, Sigmoid, Softmax, Tanh, LeakyRelu; - BatchNormalization; - MaxPool, AveragePool, GlobalAverage; - ConvTranspose; - Gather; - Expand, Reduce; - Neg, Exp, Sqrt, Reciprocal; - Add, Sum, Mul, Div; - Reshape, Flatten, Transpose; - Squeeze, Unsqueeze, Slice; - Concat, Reduce; - Identity; - Shape. In addition a Custom (user defined) operator is supported. An example of using a Custom operator is the program `tmva/pymva/test/EmitCustomModel.cxx`. The ONNX parser supports also the fusing of the operators MatMul + Add in a Gemm operator and fusing Conv + Add and ConvTranspose + Add. #### SOFIE Keras Parser. The Keras parser supports now model with input batch size not defined (e.g `bathsize=-1`), and by default the model is generated with `batchsize=1`.; The Keras parser supports now in addition to the Dense layer the Conv2D layer, several activation functions (Relu, Selu, Sigmoid, Softmax, Tanh, LeakyRelu) and these other layers: BatchNormalization, Reshape, Convatenate, Add, Subtract, Multiply.; Models with Dropout layers are supported in case the Dropout is used only during training and not inference. For model having operators not yet supported in the Keras parser it is then reccomended to convert the Keras model to `ONNX` using the python `tf2onnx` tool. #### SOFIE PyTorch Parser. If using PyTorch it is recommended to save the model directly in `ONNX` format instad of the native `.pt` format by using the `torch.onnx.export` function of PyTorch. The support for parsing directly `.pt` files is limited to the Gemm, Conv, Relu, Selu, Sigmoid and Transpose operators. #### SOFIE RDataFrame Integration. The SOFIE inference is now integrated with RDataFrame, where a model can be evaluated on the columns of an input `TTree` with `RDataFrame` using the adapter functor class `SofieFunctor`.; Examples of using SOFIE with `RDataFrame` are the new tutorials (in th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:28470,layers,layers,28470,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['layers'],['layers']
Modifiability,"f the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of any configuration macro has changed, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the ``NDEBUG`` macro setting:. .. parsed-literal::. module MyLogger {; umbrella header ""MyLogger.h""; config_macros [exhaustive] NDEBUG; }. Conflict declarations; ~~~~~~~~~~~~~~~~~~~~~; A *conflict-declaration* describes a case where the presence of two different modules in the same translation unit is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:47412,config,configuration,47412,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['config'],['configuration']
Modifiability,"f the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your expression.; * To test template instantiation, take those tests you wrote to make sure; that you were type checking with type-dependent expressions and dependent; types (from step #2) and instantiate those templates with various types,; some of which type-check and some that don't, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option as a way to; validate diagnostic behavior. This option will use special comments within the; test file to verify that expected diagnostics appear in the correct source; locations. If all of the expected diagnostics match the actual output of Clang,; then the invocation will return normally. If there are discrepancies between; the expected and actual output, Clang will emit detailed information about; which expected diagnostics were not seen or which unexpected diagnostics were; seen, etc. A complete example is:. .. code-block: ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:154129,extend,extend,154129,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['extend'],['extend']
Modifiability,"f the; variables are not used. This includes ``const`` imports as well as ``__block``; variables. Objective C Extensions to ``Blocks``; ====================================. Importing Objects; -----------------. Objects should be treated as ``__attribute__((NSObject))`` variables; all; ``copy_helper``, ``dispose_helper``, ``byref_keep``, and ``byref_dispose``; helper functions should use ``_Block_object_assign`` and; ``_Block_object_dispose``. There should be no code generated that uses; ``*-retain`` or ``*-release`` methods. ``Blocks`` as Objects; ---------------------. The compiler will treat ``Blocks`` as objects when synthesizing property setters; and getters, will characterize them as objects when generating garbage; collection strong and weak layout information in the same manner as objects, and; will issue strong and weak write-barrier assignments in the same manner as; objects. ``__weak __block`` Support; --------------------------. Objective-C (and Objective-C++) support the ``__weak`` attribute on ``__block``; variables. Under normal circumstances the compiler uses the Objective-C runtime; helper support functions ``objc_assign_weak`` and ``objc_read_weak``. Both; should continue to be used for all reads and writes of ``__weak __block``; variables:. .. code-block:: c. objc_read_weak(&block->byref_i->forwarding->i). The ``__weak`` variable is stored in a ``_block_byref_foo`` structure and the; ``Block`` has copy and dispose helpers for this structure that call:. .. code-block:: c. _Block_object_assign(&dest->_block_byref_i, src-> _block_byref_i, BLOCK_FIELD_IS_WEAK | BLOCK_FIELD_IS_BYREF);. and:. .. code-block:: c. _Block_object_dispose(src->_block_byref_i, BLOCK_FIELD_IS_WEAK | BLOCK_FIELD_IS_BYREF);. In turn, the ``block_byref`` copy support helpers distinguish between whether; the ``__block`` variable is a ``Block`` or not and should either call:. .. code-block:: c. _Block_object_assign(&dest->_block_byref_i, src->_block_byref_i, BLOCK_FIELD_IS_WEAK | BL",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:19512,variab,variables,19512,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability,"f:. ``` {.cpp}; TGTextButton *exit = new TGTextButton(hframe,""&Exit"",; ""gApplication->Terminate()"");; ```. You will have the following the two lines:. ``` {.cpp}; TGTextButton *exit = new TGTextButton(hframe,""&Exit"");; exit->SetCommand(""gApplication->Terminate()"");; ```. The method `IsEnabled()` - returns `kTRUE` if the widget has flag; `kWidgetIsEnabled` and it accepts user events. This method is very; important for creating a good user interface because it allows you to; disable or enable a widget depending on the situation of your; application. As a standard all disabled widgets are displayed ""grayed; out"". `HasFocus()` - returns `kTRUE` if the widget has the input focus; (i.e. flag `kWidgetHasFocus` is set). Remember that only one item in a; complex widget as a dialog can have the value of `HasFocus()` sets as; true. `WantFocus()` - returns `kTRUE` if the flag `kWidgetWantFocus` is; set. ### TGWindow. **`TGWindow`** is a ROOT GUI window base class. It inherits from; **`TGObject`** and **`TGFrame`** derives from it. The application does; not use it directly. It creates and registers a new window within the; system. This window has common characteristics: existing parent,; location, size in height and width (it has a default minimum size 1, 1; under which it cannot shrink), border with particular view, state,; specific attributes. If there are no specified arguments their values; will be taken from the parent. It receives events from the window system; and can paint a representation of itself on the screen. ![](pictures/02000205.jpg). ### Frames. Most of the frame classes are mainly created for arranging widgets in a; window. The class **`TGFrame`** is a subclass of **`TGWindow`**; providing additional window characteristics and overriding some methods; of **`TGWindow`**. It is a base class for the simple widgets as buttons,; labels, etc. Its only purpose is to draw a frame around widgets that do; not have a frame of their own. The main groups of **`TGFrame`** mem",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:23654,inherit,inherits,23654,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['inherit'],['inherits']
Modifiability,"f:`DISubprogram`. .. code-block:: text. !0 = !DILocation(line: 2900, column: 42, scope: !1, inlinedAt: !2). .. _DILocalVariable:. DILocalVariable; """""""""""""""""""""""""""""". ``DILocalVariable`` nodes represent local variables in the source language. If; the ``arg:`` field is set to non-zero, then this variable is a subprogram; parameter, and it will be included in the ``retainedNodes:`` field of its; :ref:`DISubprogram`. .. code-block:: text. !0 = !DILocalVariable(name: ""this"", arg: 1, scope: !3, file: !2, line: 7,; type: !3, flags: DIFlagArtificial); !1 = !DILocalVariable(name: ""x"", arg: 2, scope: !4, file: !2, line: 7,; type: !3); !2 = !DILocalVariable(name: ""y"", scope: !5, file: !2, line: 7, type: !3). .. _DIExpression:. DIExpression; """""""""""""""""""""""". ``DIExpression`` nodes represent expressions that are inspired by the DWARF; expression language. They are used in :ref:`debug intrinsics<dbg_intrinsics>`; (such as ``llvm.dbg.declare`` and ``llvm.dbg.value``) to describe how the; referenced LLVM variable relates to the source language variable. Debug; intrinsics are interpreted left-to-right: start by pushing the value/address; operand of the intrinsic onto a stack, then repeatedly push and evaluate; opcodes from the DIExpression until the final variable description is produced. The current supported opcode vocabulary is limited:. - ``DW_OP_deref`` dereferences the top of the expression stack.; - ``DW_OP_plus`` pops the last two entries from the expression stack, adds; them together and appends the result to the expression stack.; - ``DW_OP_minus`` pops the last two entries from the expression stack, subtracts; the last entry from the second last entry and appends the result to the; expression stack.; - ``DW_OP_plus_uconst, 93`` adds ``93`` to the working expression.; - ``DW_OP_LLVM_fragment, 16, 8`` specifies the offset and size (``16`` and ``8``; here, respectively) of the variable fragment from the working expression. Note; that contrary to DW_OP_bit_piece, the offset is desc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:261151,variab,variable,261151,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['variab'],['variable']
Modifiability,"fListBox->Resize(150, 80);; parent->AddFrame(fListBox,new TGLayoutHints(kLHintsTop|kLHintsLeft,; 5, 5, 5, 5));; ```. We create the list box widget passing the parent window pointer and; giving an ID number. Next we add entries with specified string and ID to; the list box. Before adding the list box to its parent widget, it should; be resized via `Resize(width, height)` method. The list box width and; height are in pixels. The default entry layout hints are; `kLHintsExpandX | kLHintsTop`. If you want to add entries using; different ones, call the method:. ``` {.cpp}; TGListBox::AddEntry(TGLBEntry *lbe, TGLayoutHints *lhints);; ```. It adds the specified **`TGLBEntry`** and **`TGLayoutHints`** to the; list box. There are several methods providing a flexible entry; manipulation: you can insert, add or remove list box items dynamically.; The list box entry IDs are used in these methods and also in event; processing routines. In our example the integer variables `fFirstEntry`; and `fLastEntry` contain the information about the first and last entry; IDs. You can add or remove a list box entry using them in the following; way:. ``` {.cpp}; // adding an entry; fLastEntry++;; sprintf(tmp, ""Entry %i"", fLastEntry);; fListBox->AddEntry(tmp, fLastEntry);; fListBox->MapSubwindows();; fListBox->Layout();; . . .; // removing an entry; if (fFirstEntry < fLastEntry) {; fListBox->RemoveEntry(fFirstEntry);; fListBox->Layout();; fFirstEntry++;; }; ```. A single-selection list box is used for selecting only one item in a; list. A multiple-selection list box permits selection of more than one item.; The selected choices should be visible - you have several choices to do; this:. - to mark selected choices with a check mark or highlight them. - to provide a summary list box to the right of the list box,; containing the selected choices. - to provide a display-only text control indicating the number of; selected choices (its position should be justified upper-right above; the list box). - i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:81341,variab,variables,81341,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['variab'],['variables']
Modifiability,"f``, ``CFArrayRef``,; etc. When used from C, however, these are still really objects and are the; second case where that requires copy and dispose helper functions to be; generated. The copy helper functions generated by the compiler should use the; ``_Block_object_assign`` runtime helper function and in the dispose helper the; ``_Block_object_dispose`` runtime helper function should be called. For example, ``Block`` foo in the following:. .. code-block:: c. struct Opaque *__attribute__((NSObject)) objectPointer = ...;; ...; void (^foo)(void) = ^{ CFPrint(objectPointer); };. would have the following helper functions generated:. .. code-block:: c. void __block_copy_foo(struct __block_literal_5 *dst, struct __block_literal_5 *src) {; _Block_object_assign(&dst->objectPointer, src-> objectPointer, BLOCK_FIELD_IS_OBJECT);; }. void __block_dispose_foo(struct __block_literal_5 *src) {; _Block_object_dispose(src->objectPointer, BLOCK_FIELD_IS_OBJECT);; }. Imported ``__block`` marked variables; -------------------------------------. Layout of ``__block`` marked variables; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The compiler must embed variables that are marked ``__block`` in a specialized; structure of the form:. .. code-block:: c. struct _block_byref_foo {; void *isa;; struct Block_byref *forwarding;; int flags; //refcount;; int size;; typeof(marked_variable) marked_variable;; };. Variables of certain types require helper functions for when ``Block_copy()``; and ``Block_release()`` are performed upon a referencing ``Block``. At the ""C""; level only variables that are of type ``Block`` or ones that have; ``__attribute__((NSObject))`` marked require helper functions. In Objective-C; objects require helper functions and in C++ stack based objects require helper; functions. Variables that require helper functions use the form:. .. code-block:: c. struct _block_byref_foo {; void *isa;; struct _block_byref_foo *forwarding;; int flags; //refcount;; int size;; // helper functions ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:11366,variab,variables,11366,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability,"fect of any preceding dbg.values for (any; overlapping fragments of) the specified variable.; * The dbg.value's position in the IR defines where in the instruction stream; the variable's value changes.; * Operands can be constants, indicating the variable is assigned a; constant value. Care must be taken to update ``llvm.dbg.value`` intrinsics when optimization; passes alter or move instructions and blocks -- the developer could observe such; changes reflected in the value of variables when debugging the program. For any; execution of the optimized program, the set of variable values presented to the; developer by the debugger should not show a state that would never have existed; in the execution of the unoptimized program, given the same input. Doing so; risks misleading the developer by reporting a state that does not exist,; damaging their understanding of the optimized program and undermining their; trust in the debugger. Sometimes perfectly preserving variable locations is not possible, often when a; redundant calculation is optimized out. In such cases, a ``llvm.dbg.value``; with operand ``poison`` should be used, to terminate earlier variable locations; and let the debugger present ``optimized out`` to the developer. Withholding; these potentially stale variable values from the developer diminishes the; amount of available debug information, but increases the reliability of the; remaining information. To illustrate some potential issues, consider the following example:. .. code-block:: llvm. define i32 @foo(i32 %bar, i1 %cond) {; entry:; call @llvm.dbg.value(metadata i32 0, metadata !1, metadata !2); br i1 %cond, label %truebr, label %falsebr; truebr:; %tval = add i32 %bar, 1; call @llvm.dbg.value(metadata i32 %tval, metadata !1, metadata !2); %g1 = call i32 @gazonk(); br label %exit; falsebr:; %fval = add i32 %bar, 2; call @llvm.dbg.value(metadata i32 %fval, metadata !1, metadata !2); %g2 = call i32 @gazonk(); br label %exit; exit:; %merge = phi [ %tval, %tr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:19389,variab,variable,19389,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"fer to the tree (or chain) containing the data by using the; string '`This`'. You can also call any **`TTree`** methods. Next example; will display the name of the first '`user info`' object:. `tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");`. 46. **`tree->Draw(""mybr.mystring"");`**. **`TString`** and `std::string` object are plotted directly. The example; 45 draws the same results - i.e. an histogram whose labels are the; string value of '`mystring`':. `tree->Draw(""mybr.mystring.c_str()"");`. or. `tree->Draw(""mybr.mytstring.Data()"");`. 47. **`tree->Draw(""myTimeStamp"");`**. You can plot plot objects of any class which has either `AsDouble` or; `AsString` (`AsDouble` has priority). For such a class (for example; **`TTimeStamp`**), the line 46 will plot the same as:. `tree->Draw(""myTimeStamp.AsDouble"");`. `AsString` can be returning either a `char*`, or a **`TString`** or an; `std::string`. ### Multiple variables visualisation. This section presents the visualization technique available in ROOT; to represent multiple variables (>4) data sets. #### Spider (Radar) Plots. Spider plots (sometimes called “web-plots” or “radar plots”) are used; to compare series of data points (events). They use the human ability; to spot un-symmetry. ![Example of spider plot.](pictures/spider1.png). Variables are represented on individual axes displayed along a circle.; For each variable the minimum value sits on the circle’s center, and; the maximum on the circle’s radius. Spider plots are not suitable for; an accurate graph reading since, by their nature, it can be difficult; to read out very detailed values, but they give quickly a global view; of an event in order to compare it with the others. In ROOT the spider; plot facility is accessed from the tree viewer GUI. The variables to; be visualized are selected in the tree viewer and can be scanned using; the spider plot button. ![The tree viewer Graphical User Interface and the Spider Plot Editor.](pictures/spider2.png). The spider pl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:94093,variab,variables,94093,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"ference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:19142,plugin,plugins,19142,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['plugin'],['plugins']
Modifiability,"ferences to ``__bidi_indexable``, all array accesses are; bounds checked in ``-fbounds-safety``, just as ``__bidi_indexable`` pointers; are. Maintaining correctness of bounds annotations; ---------------------------------------------. ``-fbounds-safety`` maintains correctness of bounds annotations by performing; additional checks when a pointer object and/or its related value containing the; bounds information is updated. For example, ``__single`` expresses an invariant that the pointer must either; point to a single valid object or be a null pointer. To maintain this invariant,; the compiler inserts checks when initializing a ``__single`` pointer, as shown; in the following example:. .. code-block:: c. void foo(void *__sized_by(size) vp, size_t size) {; // Inserted check:; // if ((int*)upper_bound(vp) - (int*)vp < sizeof(int) && !!vp) trap();; int *__single ip = (int *)vp;; }. Additionally, an explicit bounds annotation such as ``int *__counted_by(count); buf`` defines a relationship between two variables, ``buf`` and ``count``:; namely, that ``buf`` has ``count`` number of elements available. This; relationship must hold even after any of these related variables are updated. To; this end, the model requires that assignments to ``buf`` and ``count`` must be; side by side, with no side effects between them. This prevents ``buf`` and; ``count`` from temporarily falling out of sync due to updates happening at a; distance. The example below shows a function ``alloc_buf`` that initializes a struct that; members that use the ``__counted_by`` annotation. The compiler allows these; assignments because ``sbuf->buf`` and ``sbuf->count`` are updated side by side; without any side effects in between the assignments. Furthermore, the compiler inserts additional run-time checks to ensure the new; ``buf`` has at least as many elements as the new ``count`` indicates as shown in; the transformed pseudo code of function ``alloc_buf()`` in the example below. .. code-block:: c. typedef",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:35976,variab,variables,35976,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['variab'],['variables']
Modifiability,"ffect of negating part of the ``ffp-model`` that; has been selected, then the compiler will issue a diagnostic warning; that the override has occurred. .. option:: -ffp-exception-behavior=<value>. Specify the floating-point exception behavior. Valid values are: ``ignore``, ``maytrap``, and ``strict``.; The default value is ``ignore``. Details:. * ``ignore`` The compiler assumes that the exception status flags will not be read and that floating point exceptions will be masked.; * ``maytrap`` The compiler avoids transformations that may raise exceptions that would not have been raised by the original code. Constant folding performed by the compiler is exempt from this option.; * ``strict`` The compiler ensures that all transformations strictly preserve the floating point exception semantics of the original code. .. option:: -ffp-eval-method=<value>. Specify the floating-point evaluation method for intermediate results within; a single expression of the code. Valid values are: ``source``, ``double``, and ``extended``.; For 64-bit targets, the default value is ``source``. For 32-bit x86 targets; however, in the case of NETBSD 6.99.26 and under, the default value is; ``double``; in the case of NETBSD greater than 6.99.26, with NoSSE, the; default value is ``extended``, with SSE the default value is ``source``.; Details:. * ``source`` The compiler uses the floating-point type declared in the source program as the evaluation method.; * ``double`` The compiler uses ``double`` as the floating-point evaluation method for all float expressions of type that is narrower than ``double``.; * ``extended`` The compiler uses ``long double`` as the floating-point evaluation method for all float expressions of type that is narrower than ``long double``. .. option:: -f[no-]protect-parens. This option pertains to floating-point types, complex types with; floating-point components, and vectors of these types. Some arithmetic; expression transformations that are mathematically correct and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:64276,extend,extended,64276,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['extend'],['extended']
Modifiability,"fferent file formats may limit; this to a subset of the local symbols. For example, file and section symbols in; ELF objects will not be discarded. Additionally, remove all debug sections. .. option:: --enable-deterministic-archives, -D. Enable deterministic mode when stripping archives, i.e. use 0 for archive member; header UIDs, GIDs and timestamp fields. On by default. .. option:: --help, -h. Print a summary of command line options. .. option:: --no-strip-all. Disable :option:`--strip-all`. .. option:: -o <file>. Write output to <file>. Multiple input files cannot be used in combination; with -o. .. option:: --only-keep-debug. Produce a debug file as the output that only preserves contents of sections; useful for debugging purposes. For ELF objects, this removes the contents of `SHF_ALLOC` sections that are not; `SHT_NOTE` by making them `SHT_NOBITS` and shrinking the program headers where; possible. .. option:: --regex. If specified, symbol and section names specified by other switches are treated; as extended POSIX regular expression patterns. .. option:: --remove-section <section>, -R. Remove the specified section from the output. Can be specified multiple times; to remove multiple sections simultaneously. .. option:: --strip-all-gnu. Remove all symbols, debug sections and relocations from the output. This option; is equivalent to GNU :program:`strip`'s ``--strip-all`` switch. .. option:: --strip-all, -s. For ELF objects, remove from the output all symbols and non-alloc sections not; within segments, except for .gnu.warning, .ARM.attribute sections and the; section name table. For COFF objects, remove all symbols, debug sections, and relocations from the; output. .. option:: --strip-debug, -d, -g, -S. Remove all debug sections from the output. .. option:: --strip-symbol <symbol>, -N. Remove all symbols named ``<symbol>`` from the output. Can be specified; multiple times to remove multiple symbols. .. option:: --strip-unneeded. Remove from the output all local o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-strip.rst:2154,extend,extended,2154,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-strip.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-strip.rst,1,['extend'],['extended']
Modifiability,"fferent; program location ranges. But if supporting for some then should be for; all. It seems odd this attribute is not the same as; ``DW_AT_data_member_location`` in having an initial stack with the; location description of the object since the expression has to need it. A.6 Other Debugging Information; -------------------------------. .. note::. This section provides changes to existing debugger information entry; attributes. These would be incorporated into the corresponding DWARF Version 5; chapter 6 sections. A.6.1 Accelerated Access; ~~~~~~~~~~~~~~~~~~~~~~~~. .. _amdgpu-dwarf-lookup-by-name:. A.6.1.1 Lookup By Name; ++++++++++++++++++++++. A.6.1.1.1 Contents of the Name Index; ####################################. .. note::. The following provides changes to DWARF Version 5 section 6.1.1.1. The rule for debugger information entries included in the name index in the; optional ``.debug_names`` section is extended to also include named; ``DW_TAG_variable`` debugging information entries with a ``DW_AT_location``; attribute that includes a ``DW_OP_LLVM_form_aspace_address`` operation. The name index must contain an entry for each debugging information entry that; defines a named subprogram, label, variable, type, or namespace, subject to the; following rules:. * ``DW_TAG_variable`` debugging information entries with a ``DW_AT_location``; attribute that includes a ``DW_OP_addr``, ``DW_OP_LLVM_form_aspace_address``,; or ``DW_OP_form_tls_address`` operation are included; otherwise, they are; excluded. A.6.1.1.4 Data Representation of the Name Index; ###############################################. .. _amdgpu-dwarf-name-index-section-header:. A.6.1.1.4.1 Section Header; ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. note::. The following provides an addition to DWARF Version 5 section 6.1.1.4.1 item; 14 ``augmentation_string``. A null-terminated UTF-8 vendor specific augmentation string, which provides; additional information about the contents of this index. If provided, the; recomme",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:186116,extend,extended,186116,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['extend'],['extended']
Modifiability,"ffloading entry is an entry; to a target region it can have one of the following :ref:`entry flags; <table-offload_entry_flags>`. .. table:: Target Region Entry Flags; :name: table-offload_entry_flags. +----------------------------------+-------+-----------------------------------------+; | Name | Value | Description |; +==================================+=======+=========================================+; | OMPTargetRegionEntryTargetRegion | 0x00 | Mark the entry as generic target region |; +----------------------------------+-------+-----------------------------------------+; | OMPTargetRegionEntryCtor | 0x02 | Mark the entry as a global constructor |; +----------------------------------+-------+-----------------------------------------+; | OMPTargetRegionEntryDtor | 0x04 | Mark the entry as a global destructor |; +----------------------------------+-------+-----------------------------------------+. If the offloading entry is a global variable, indicated by a non-zero size, it; will instead have one of the following :ref:`global; <table-offload_global_flags>` flags. .. table:: Target Region Global; :name: table-offload_global_flags. +-----------------------------+-------+---------------------------------------------------------------+; | Name | Value | Description |; +=============================+=======+===============================================================+; | OMPTargetGlobalVarEntryTo | 0x00 | Mark the entry as a 'to' attribute (w.r.t. the to clause) |; +-----------------------------+-------+---------------------------------------------------------------+; | OMPTargetGlobalVarEntryLink | 0x01 | Mark the entry as a 'link' attribute (w.r.t. the link clause) |; +-----------------------------+-------+---------------------------------------------------------------+. The target offload entries are used by the runtime to access the device kernels; and globals that will be provided by the final device image. Each offloading; entry is set to use the ``omp_off",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:5866,variab,variable,5866,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst,1,['variab'],['variable']
Modifiability,"ffset equal to V scaled by 8 (the byte size). .. note::. If it is wanted to allow any integral type value to be implicitly converted to; a memory location description in the target architecture default address; space:. If a stack entry is required to be a location description, but is a value V; with an integral type, then it is implicitly converted to a location; description L with a one memory location description SL. If the type size of; V is less than the generic type size, then the value V is zero extended to; the size of the generic type. The least significant generic type size bits; are treated as an unsigned value to be used as an address A. SL specifies; memory location storage corresponding to the target architecture default; address space with a bit offset equal to A scaled by 8 (the byte size). The implicit conversion could also be defined as target architecture specific.; For example, GDB checks if V is an integral type. If it is not it gives an; error. Otherwise, GDB zero-extends V to 64 bits. If the GDB target defines a; hook function, then it is called. The target specific hook function can modify; the 64-bit value, possibly sign extending based on the original value type.; Finally, GDB treats the 64-bit value V as a memory location address. If a stack entry is required to be a location description, but it is an implicit; pointer value IPV with the target architecture default address space, then it is; implicitly converted to a location description with one single location; description specified by IPV. See; :ref:`amdgpu-dwarf-implicit-location-description-operations`. .. note::. Is this rule required for DWARF Version 5 backwards compatibility? If not, it; can be eliminated, and the producer can use; ``DW_OP_LLVM_form_aspace_address``. If a stack entry is required to be a value, but it is a location description L; with one memory location description SL in the target architecture default; address space with a bit offset B that is a multiple of 8, the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:107617,extend,extends,107617,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['extend'],['extends']
Modifiability,fiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or more member fields or functions. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:61875,config,configuration,61875,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"fies the natural alignment of the stack in bits. Alignment; promotion of stack variables is limited to the natural stack; alignment to avoid dynamic stack realignment. The stack alignment; must be a multiple of 8-bits. If omitted, the natural stack; alignment defaults to ""unspecified"", which does not prevent any; alignment promotions.; ``P<address space>``; Specifies the address space that corresponds to program memory.; Harvard architectures can use this to specify what space LLVM; should place things such as functions into. If omitted, the; program memory space defaults to the default address space of 0,; which corresponds to a Von Neumann architecture that has code; and data in the same space.; ``G<address space>``; Specifies the address space to be used by default when creating global; variables. If omitted, the globals address space defaults to the default; address space 0.; Note: variable declarations without an address space are always created in; address space 0, this property only affects the default value to be used; when creating globals without additional contextual information (e.g. in; LLVM passes). .. _alloca_addrspace:. ``A<address space>``; Specifies the address space of objects created by '``alloca``'.; Defaults to the default address space of 0.; ``p[n]:<size>:<abi>[:<pref>][:<idx>]``; This specifies the *size* of a pointer and its ``<abi>`` and; ``<pref>``\erred alignments for address space ``n``. ``<pref>`` is optional; and defaults to ``<abi>``. The fourth parameter ``<idx>`` is the size of the; index that used for address calculation, which must be less than or equal; to the pointer size. If not; specified, the default index size is equal to the pointer size. All sizes; are in bits. The address space, ``n``, is optional, and if not specified,; denotes the default address space 0. The value of ``n`` must be; in the range [1,2^24).; ``i<size>:<abi>[:<pref>]``; This specifies the alignment for an integer type of a given bit; ``<size>``. The value ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:132677,variab,variable,132677,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"figuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted variables are pass arguments to filters. # Filter function; # void cleanse_first_arg(int* arg); #; # Result example:; # int x; // x is tainted; # cleanse_first_arg(&x); // x is not tainted after the call; - Name: cleanse_first_arg; Args: [0]. Propagations:; # Source functions; # The omission of SrcArgs key indicates unconditional taint propagation,; # which is conceptually what a source does. # Source function; # size_t fread(void *ptr, size_t size, size_t nmemb, FILE * stream); #; # Result example:; # FILE* f = fopen(""file.txt"");; # char buf[1024];; # size_t read = fread(buf, sizeof(buf[0]), sizeof(buf)/sizeof(bu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:1880,config,configuration,1880,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,1,['config'],['configuration']
Modifiability,"file content, for file types; not supported you will get a generic window showing some basic file info. The idea of QL is that file content can be shown without the heavy application; startup process. Generating a QL view of a ROOT file depends on the size of the; file, but generally it is a quick operation. Get the binary for the ROOTQL plugin from:. ftp://root.cern.ch/root/ROOTQL.tgz. To install the plugin, after untarring the above file, just drag the bundle; ROOTQL.qlgenerator to /Library/QuickLook (global, i.e. for all users on a; system) or to ~/Library/QuickLook (local, this user only) directory.; You may need to create that folder if it doesn't already exist. To build from source, get it from svn using:. svn co http://root.cern.ch/svn/root/trunk/misc/rootql rootql. Open the ROOTQL project in Xcode and click on ""Build"" (make sure the Active; Build Configuration is set the ""Release""). Copy the resulting; plugin from build/Release to the desired QuickLook directory. SpotLight plugin for MacOS X. This is a Spotlight plugin that allows ROOT files to be indexed by SL.; Once indexed SL can find ROOT files based on the names and titles of the; objects in the files. Spotlight is available on MacOS X since version 10.4 (Tiger). To use SL; select the SL icon on the top right of the menubar and type in a search text. Get the binary for the ROOTSL plugin from:. ftp://root.cern.ch/root/ROOTSL.tgz. To install the plugin, after untarring the above file, just drag the bundle; ROOTSL.mdimporter to /Library/Spotlight (global, i.e. for all users on a; system) or to ~/Library/Spotlight (local, this user only) directory.; You may need to create that folder if it doesn't already exist. To build from source, get it from svn using:. svn co http://root.cern.ch/svn/root/trunk/misc/rootsl rootsl. Open the ROOTSL project in Xcode and click on ""Build"" (make sure the Active; Build Configuration is set the ""Release""). Copy the resulting; plugin from build/Release to the desired QuickLook d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/doc/v524/index.html:1321,plugin,plugin,1321,misc/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/doc/v524/index.html,2,['plugin'],['plugin']
Modifiability,"file(dlfcn.h CLANG_HAVE_DLFCN_H); if( CLANG_HAVE_DLFCN_H ); include(CheckLibraryExists); include(CheckSymbolExists); check_library_exists(dl dlopen """" HAVE_LIBDL); if( HAVE_LIBDL ); list(APPEND CMAKE_REQUIRED_LIBRARIES dl); endif(); list(APPEND CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE); check_symbol_exists(dladdr dlfcn.h CLANG_HAVE_DLADDR); list(REMOVE_ITEM CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE); if( HAVE_LIBDL ); list(REMOVE_ITEM CMAKE_REQUIRED_LIBRARIES dl); endif(); endif(). set(CLANG_RESOURCE_DIR """" CACHE STRING; ""Relative directory from the Clang binary to its resource files.""). set(C_INCLUDE_DIRS """" CACHE STRING; ""Colon separated list of directories clang will search for headers.""). set(GCC_INSTALL_PREFIX """" CACHE PATH ""Directory where gcc is installed."" ); set(DEFAULT_SYSROOT """" CACHE STRING; ""Default <path> to all compiler invocations for --sysroot=<path>."" ); if(GCC_INSTALL_PREFIX); message(WARNING ""GCC_INSTALL_PREFIX is deprecated and will be removed. Use ""; ""configuration files (https://clang.llvm.org/docs/UsersManual.html#configuration-files)""; ""to specify the default --gcc-install-dir= or --gcc-triple=. --gcc-toolchain= is discouraged. ""; ""See https://github.com/llvm/llvm-project/pull/77537 for detail.""); endif(). set(ENABLE_LINKER_BUILD_ID OFF CACHE BOOL ""pass --build-id to ld""). set(ENABLE_X86_RELAX_RELOCATIONS ON CACHE BOOL; ""enable x86 relax relocations by default""). set(PPC_LINUX_DEFAULT_IEEELONGDOUBLE OFF CACHE BOOL; ""Enable IEEE binary128 as default long double format on PowerPC Linux.""). set(CLANG_SPAWN_CC1 OFF CACHE BOOL; ""Whether clang should use a new process for the CC1 invocation""). option(CLANG_DEFAULT_PIE_ON_LINUX ""Default to -fPIE and -pie on linux-gnu"" ON). set(CLANG_DEFAULT_LINKER """" CACHE STRING; ""Default linker to use (linker name or absolute path, empty for platform default)""). set(CLANG_DEFAULT_CXX_STDLIB """" CACHE STRING; ""Default C++ stdlib to use (\""libstdc++\"" or \""libc++\"", empty for platform default""); if (NOT(CLANG_DEFAULT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:6937,config,configuration,6937,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['config'],['configuration']
Modifiability,"file. MultiTargetRegression No False − Do regression with multiple targets. Nmin No 100 − Number of events in cell required to split cell. MaxDepth No 0 − Maximum depth of cell tree (0=unlimited). FillFoamWithOrigWeights No False − Fill foam with original or boost weights. UseYesNoCell No False − Return -1 or 1 for bkg or signal like events. DTLogic No None None, GiniIndex, MisClassificationError, CrossEntropy, GiniIndexWithLaplace, SdivSqrtSplusB Use decision tree algorithm to split cells. Kernel No None None, Gauss, LinNeighbors Kernel type used. TargetSelection No Mean Mean, Mpv Target selection method. Configuration options for MVA method :. Configuration options reference for MVA method: TMlpANN. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). NCycles No 200 − Number of training cycles. HiddenLayers No N,N-1 − Specification of hidden layer architecture (N stands for number of variables; any integers may also be used). ValidationFraction No 0.5 − Fraction of events in training tree used for cross validation. LearningMethod No Stochastic Stochastic, Batch, SteepestDescent, RibierePolak, FletcherReeves, BFGS Learning method. Configuration options for setup an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:28129,variab,variable,28129,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,2,['variab'],['variable']
Modifiability,"file; ``<buildbot-worker-root-directory>/worker/twistd.log``. If your settings; are correct you will see a refused connection. This is good and expected,; as the credentials have not been established on both ends. Now stop the; worker and proceed to the next steps. #. Fill the buildbot-worker description and admin name/e-mail. Here is an; example of the buildbot-worker description::. Windows 7 x64; Core i7 (2.66GHz), 16GB of RAM. g++.exe (TDM-1 mingw32) 4.4.0; GNU Binutils 2.19.1; cmake version 2.8.4; Microsoft(R) 32-bit C/C++ Optimizing Compiler Version 16.00.40219.01 for 80x86. See `here <http://docs.buildbot.net/current/manual/installation/worker.html>`_; for which files to edit. #. Send a patch which adds your build worker and your builder to; `zorg <https://github.com/llvm/llvm-zorg>`_. Use the typical LLVM; `workflow <https://llvm.org/docs/Contributing.html#how-to-submit-a-patch>`_. * workers are added to ``buildbot/osuosl/master/config/workers.py``; * builders are added to ``buildbot/osuosl/master/config/builders.py``. Please make sure your builder name and its builddir are unique through the; file. All new builders should default to using the ""'collapseRequests': False""; configuration. This causes the builder to build each commit individually; and not merge build requests. To maximize quality of feedback to developers,; we *strongly prefer* builders to be configured not to collapse requests.; This flag should be removed only after all reasonable efforts have been; exhausted to improve build times such that the builder can keep up with; commit flow. It is possible to allow email addresses to unconditionally receive; notifications on build failure; for this you'll need to add an; ``InformativeMailNotifier`` to ``buildbot/osuosl/master/config/status.py``.; This is particularly useful for the staging buildmaster which is silent; otherwise. #. Send the buildbot-worker access name and the access password directly to; `Galina Kistanova <mailto:gkistanova@gmail.com>`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:5404,config,config,5404,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['config'],['config']
Modifiability,files.; Large benchmarks and whole applications go here. - `MicroBenchmarks/`. Programs using the [google-benchmark](https://github.com/google/benchmark); library. The programs define functions that are run multiple times until the; measurement results are statistically significant. - `External/`. Contains descriptions and test data for code that cannot be directly; distributed with the test-suite. The most prominent members of this; directory are the SPEC CPU benchmark suites.; See [External Suites](#external-suites). - `Bitcode/`. These tests are mostly written in LLVM bitcode. - `CTMark/`. Contains symbolic links to other benchmarks forming a representative sample; for compilation performance measurements. ### Benchmarks. Every program can work as a correctness test. Some programs are unsuitable for; performance measurements. Setting the `TEST_SUITE_BENCHMARKING_ONLY` CMake; option to `ON` will disable them. Configuration; -------------. The test-suite has configuration options to customize building and running the; benchmarks. CMake can print a list of them:. ```bash; % cd test-suite-build; # Print basic options:; % cmake -LH; # Print all options:; % cmake -LAH; ```. ### Common Configuration Options. - `CMAKE_C_FLAGS`. Specify extra flags to be passed to C compiler invocations. The flags are; also passed to the C++ compiler and linker invocations. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html). - `CMAKE_C_COMPILER`. Select the C compiler executable to be used. Note that the C++ compiler is; inferred automatically i.e. when specifying `path/to/clang` CMake will; automatically use `path/to/clang++` as the C++ compiler. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html). - `CMAKE_Fortran_COMPILER`. Select the Fortran compiler executable to be used. Not set by default and not; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:3765,config,configuration,3765,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['config'],['configuration']
Modifiability,"filing tests are very limited, and generating the profile takes a; significant amount of time, but it can result in a significant improvement in; the performance of the generated binaries. In addition to PGO profiling we also have limited support in-tree for generating; linker order files. These files provide the linker with a suggested ordering for; functions in the final binary layout. This can measurably speed up clang by; physically grouping functions that are called temporally close to each other.; The current tooling is only available on Darwin systems with ``dtrace(1)``. It; is worth noting that dtrace is non-deterministic, and so the order file; generation using dtrace is also non-deterministic. Options for Reducing Size; =========================. .. warning::; Any steps taken to reduce the binary size will come at a cost of runtime; performance in the generated binaries. The simplest and least significant way to reduce binary size is to set the; *CMAKE_BUILD_TYPE* variable to ``MinSizeRel``, which will set the compiler; optimization level to ``-Os`` which optimizes for binary size. This will have; both the least benefit to size and the least impact on performance. The most impactful way to reduce binary size is to dynamically link LLVM into; all the tools. This reduces code size by decreasing duplication of common code; between the LLVM-based tools. This can be done by setting the following two; CMake options to ``On``: *LLVM_BUILD_LLVM_DYLIB* and *LLVM_LINK_LLVM_DYLIB*. .. warning::; Distributions should never be built using the *BUILD_SHARED_LIBS* CMake; option. (:ref:`See the warning above for more explanation <shared_libs>`.). Relevant CMake Options; ======================. This section provides documentation of the CMake options that are intended to; help construct distributions. This is not an exhaustive list, and many; additional options are documented in the :doc:`CMake` page. Some key options; that are already documented include: *LLVM_TARGETS_TO_B",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:10122,variab,variable,10122,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['variab'],['variable']
Modifiability,"final device image. Each offloading; entry is set to use the ``omp_offloading_entries`` section. When the final; application is created the linker will provide the; ``__start_omp_offloading_entries`` and ``__stop_omp_offloading_entries`` symbols; which are used to create the :ref:`final image <Device Binary Wrapping>`. This information is used by the device compilation stage to determine which; symbols need to be exported from the device. We use the ``omp_offload.info``; metadata node to pass this information device compilation stage. Accessing Entries on the Device; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Accessing the entries in the device is done using the address field in the; :ref:`offload entry<table-tgt_offload_entry_structure>`. The runtime will set; the address to the pointer associated with the device image during runtime; initialization. This is used to call the corresponding kernel function when; entering a ``#pragma omp target`` region. For variables, the runtime maintains a; table mapping host pointers to device pointers. Global variables inside a; ``#pragma omp target declare`` directive are first initialized to the host's; address. Once the device address is initialized we insert it into the table to; map the host address to the device address. Debugging Information; ^^^^^^^^^^^^^^^^^^^^^. We generate structures to hold debugging information that is passed to; ``libomptarget``. This allows the front-end to generate information the runtime; library uses for more informative error messages. This is done using the; standard :ref:`identifier structure <table-ident_t_structure>` used in; ``libomp`` and ``libomptarget``. This is used to pass information and source; locations to the runtime. .. table:: ident_t Structure; :name: table-ident_t_structure. +---------+------------+-----------------------------------------------------------------------------+; | Type | Identifier | Description |; +=========+============+==================================================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:7805,variab,variables,7805,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst,1,['variab'],['variables']
Modifiability,"final stage, ROOT might be able to integrate the Name.pcm with the; shared library itself.; * Improved correctness in number of cases -- in a few cases ROOT is more; correct. In particular, when resolving global variables and function; declarations which are not part of the ROOT PCH.; * Enhanced symbol resolution mechanisms, bloom filters -- standard ROOT relies; on information in ROOTMAP files to react when the llvm JIT issues an; unresolved symbol callback. C++ Modules-aware ROOT relies on a behavior much; closer to the standard linker behavior. In particular, we start searching on; the LD_LIBRARY_PATH descending to the system libraries. The algorithm is very; efficient because it uses bloom filters[[5]]. This in turn allows ROOT symbol; to be extended to system libraries. ### Module Registration Approaches. The C++ modules system supports /*preloading*/ of all modules at startup time.; The current implementation of loading of C++ modules in clang has an overhead; and is between 40-60 MB depending on the ROOT configuration while there might; be 2x slowdown depending on the workflow. These issues are very likely to be; addressed by the LLVM community in midterm. Preloading of all C++ modules is semantically the closest to C++ behavior.; However, in order to achieve performance ROOT loads them on demand using; a global module index file. It has sufficient information to map a looked up; identifier to the module which contains the corresponding definition. Switching; back to preloading of all C++ modules is done by setting the `ROOT_USE_GMI`; environment variable to false.; ; ### Supported Platforms. We support all platforms with glibc++ versions: 5.2 onward. We support OSX from XCode 10 onward. ## Changes required by the users; * Self-contained header files -- every header file should be able to compile; on its own. For instance, `cat header.h header.h | gcc -fsyntax-only -xc++ -`.; This command concatenates `header.h` twice before compiling it to make sure; it has p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:13940,config,configuration,13940,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['config'],['configuration']
Modifiability,"fined behavior.; Source: C++03 27.4.3.2p3; C++11 27.5.4.2p3. #include <fstream>. class my_streambuf : public std::streambuf {; void f() {; seekpos(-1); // warn; }; };. #include <fstream>. void test() {; std::filebuf fb;; std::istream in(&fb);; std::filebuf::off_type pos(-1);; in.seekg(pos); // warn; }. different. Name, DescriptionExampleProgress. different.SuccessiveAssign; (C); Successive assign to a variable. int test() {; int i;; i=1;; i=2; // warn; return i;; }. different.NullDerefStmtOrder; (C); Dereferencing of the null pointer might take place. Checking the pointer for; null should be performed first.; Note: possibly an enhancement to ; core.NullDereference. struct S {; int x;; };. struct S* f();. void test() {; struct S *p1 = f();; int x1 = p1->x; // warn; if (p1) {};. struct S *p2 = f();; int x2 = p2->x; // ok; }. different.NullDerefCondOrder; (C); Dereferencing of the null pointer might take place. Checking the pointer for; null should be performed first.; Note: possibly an enhancement to ; core.NullDereference. struct S {int i;};. struct S* f();. void test() {; struct S *p = f();; if (p->i && p) {}; // warn; }. different.MultipleAccessors; (C++); Identical accessor bodies. Possibly a misprint. class A {; int i;; int j;; public:; int getI() { return i; }; int getJ() { return i; } // warn; };. class A {; int i;; int j;; public:; void setI(int& ii) { i = ii; }; void setJ(int& jj) { i = jj; } // warn; };. different.AccessorsForPublic; (C++); Accessors exist for a public class field. Should this field really be; public?. class A {; public:; int i; // warn; int getI() { return i; }; void setI(int& ii) { i = ii; }; };. different.LibFuncResultUnised; (C, C++); Calling a function ignoring its return value is of no use (create the list of; known system/library/API functions falling into this category). #include <vector>. void test() {; std::vector<int> v;; v.empty(); // warn; }. different.WrongVarForStmt; (C, C++); Wrong variable is possibly used in the loop/cond-e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:20323,enhance,enhancement,20323,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,2,['enhance'],['enhancement']
Modifiability,"first tree as a friend; t3->AddFriend(""t3f"",""tree3f.root"");; // Draw pz which is in the first tree and use pt; // in the condition. pt is in the friend tree.; t3->Draw(""pz"",""pt>3"");; }. // This is executed when typing .x tree3.C; void tree3() {; tree3w();; tree3r();; }; ```. ## Example 4: A Tree with an Event Class. This example is a simplified version of `$ROOTSYS/test/MainEvent.cxx`; and where Event objects are saved in a tree. The full definition of; `Event` is in `$ROOTSYS/test`/`Event.h`. To execute this macro, you will; need the library `$ROOTSYS/test/libEvent.so`. If it does not exist you; can build the test directory applications by following the instruction; in the `$ROOTSYS/test/README` file. In this example we will show. - the difference in splitting or not splitting a branch; - how to read selected branches of the tree,; - how to print a selected entry. ### The Event Class. `Event` is a descendent of **`TObject`**. As such it inherits the data; members of **`TObject`** and its methods such as `Dump()` and; `Inspect() `and` Write()`. In addition, because it inherits from; **`TObject`** it can be a member of a collection. To summarize, the; advantages of inheriting from a **`TObject`** are:. - Inherit the `Write`, `Inspect`, and `Dump` methods; - Enables a class to be a member of a ROOT collection; - Enables RTTI. Below is the list of the `Event` data members. It contains a character; array, several integers, a floating-point number, and an `EventHeader`; object. The `EventHeader` class is described in the following paragraph.; `Event` also has two pointers, one to a **`TClonesArray`** of tracks and; one to a histogram. The string ""`->`"" in the comment field of the; members `*fTracks` and `*fH` instructs the automatic `Streamer` to; assume that the objects `*fTracks` and `*fH` are never null pointers and; that `fTracks->Streamer` can be used instead of the more time consuming; form `R__b << fTracks`. ``` {.cpp}; class Event : public TObject {; private:; ch",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:58630,inherit,inherits,58630,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['inherit'],['inherits']
Modifiability,"floating point type, if one is supported on the target. Other types may be supported in the future. Matrix Type Attribute; ---------------------. Matrix types can be declared by adding the ``matrix_type`` attribute to the; declaration of a *typedef* (or a C++ alias declaration). The underlying type; of the *typedef* must be a valid matrix element type. The; attribute takes two arguments, both of which must be integer constant; expressions that evaluate to a value greater than zero. The first specifies the; number of rows, and the second specifies the number of columns. The underlying; type of the *typedef* becomes a matrix type with the given dimensions and an; element type of the former underlying type. If a declaration of a *typedef-name* has a ``matrix_type`` attribute, then all; declaration of that *typedef-name* shall have a matrix_type attribute with the; same element type, number of rows, and number of columns. Standard Conversions; --------------------. The standard conversions are extended as follows. Note that these conversions; are intentionally not listed as satisfying the constraints for assignment,; which is to say, they are only permitted as explicit casts, not as implicit; conversions. A value of matrix type can be converted to another matrix type if the number of; rows and columns are the same and the value's elements can be converted to the; element type of the result type. The result is a matrix where each element is; the converted corresponding element. A value of any real type (as in C23 6.2.5p14) can be converted to a matrix type; if it can be converted to the element type of the matrix. The result is a; matrix where all elements are the converted original value. If the number of rows or columns differ between the original and resulting; type, the program is ill-formed. Arithmetic Conversions; ----------------------. The usual arithmetic conversions are extended as follows. Insert at the start:. * If both operands are of matrix type, no arithme",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:2237,extend,extended,2237,interpreter/llvm-project/clang/docs/MatrixTypes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst,1,['extend'],['extended']
Modifiability,"floating-point operation must treat any input denormal value as; zero. In some situations, if an instruction does not respect this; mode, the input may need to be converted to 0 as if by; ``@llvm.canonicalize`` during lowering for correctness. ``""denormal-fp-math-f32""``; Same as ``""denormal-fp-math""``, but only controls the behavior of; the 32-bit float type (or vectors of 32-bit floats). If both are; are present, this overrides ``""denormal-fp-math""``. Not all targets; support separately setting the denormal mode per type, and no; attempt is made to diagnose unsupported uses. Currently this; attribute is respected by the AMDGPU and NVPTX backends. ``""thunk""``; This attribute indicates that the function will delegate to some other; function with a tail call. The prototype of a thunk should not be used for; optimization purposes. The caller is expected to cast the thunk prototype to; match the thunk target prototype. ``""tls-load-hoist""``; This attribute indicates that the function will try to reduce redundant; tls address calculation by hoisting tls variable. ``uwtable[(sync|async)]``; This attribute indicates that the ABI being targeted requires that; an unwind table entry be produced for this function even if we can; show that no exceptions passes by it. This is normally the case for; the ELF x86-64 abi, but it can be disabled for some compilation; units. The optional parameter describes what kind of unwind tables; to generate: ``sync`` for normal unwind tables, ``async`` for asynchronous; (instruction precise) unwind tables. Without the parameter, the attribute; ``uwtable`` is equivalent to ``uwtable(async)``.; ``nocf_check``; This attribute indicates that no control-flow check will be performed on; the attributed entity. It disables -fcf-protection=<> for a specific; entity to fine grain the HW control flow protection mechanism. The flag; is target independent and currently appertains to a function or function; pointer.; ``shadowcallstack``; This attribute indicate",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:108607,variab,variable,108607,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,floating-point.h; flang/include/flang/Decimal/decimal.h; flang/include/flang/Evaluate/call.h; flang/include/flang/Evaluate/characteristics.h; flang/include/flang/Evaluate/check-expression.h; flang/include/flang/Evaluate/common.h; flang/include/flang/Evaluate/complex.h; flang/include/flang/Evaluate/constant.h; flang/include/flang/Evaluate/expression.h; flang/include/flang/Evaluate/fold-designator.h; flang/include/flang/Evaluate/fold.h; flang/include/flang/Evaluate/formatting.h; flang/include/flang/Evaluate/initial-image.h; flang/include/flang/Evaluate/integer.h; flang/include/flang/Evaluate/intrinsics-library.h; flang/include/flang/Evaluate/intrinsics.h; flang/include/flang/Evaluate/logical.h; flang/include/flang/Evaluate/real.h; flang/include/flang/Evaluate/rounding-bits.h; flang/include/flang/Evaluate/shape.h; flang/include/flang/Evaluate/static-data.h; flang/include/flang/Evaluate/tools.h; flang/include/flang/Evaluate/traverse.h; flang/include/flang/Evaluate/type.h; flang/include/flang/Evaluate/variable.h; flang/include/flang/Frontend/CompilerInstance.h; flang/include/flang/Frontend/FrontendAction.h; flang/include/flang/Frontend/FrontendActions.h; flang/include/flang/Frontend/FrontendOptions.h; flang/include/flang/Frontend/FrontendPluginRegistry.h; flang/include/flang/Frontend/PreprocessorOptions.h; flang/include/flang/Frontend/TargetOptions.h; flang/include/flang/Frontend/TextDiagnostic.h; flang/include/flang/Frontend/TextDiagnosticBuffer.h; flang/include/flang/Frontend/TextDiagnosticPrinter.h; flang/include/flang/FrontendTool/Utils.h; flang/include/flang/Lower/AbstractConverter.h; flang/include/flang/Lower/Allocatable.h; flang/include/flang/Lower/BoxAnalyzer.h; flang/include/flang/Lower/Bridge.h; flang/include/flang/Lower/CallInterface.h; flang/include/flang/Lower/Coarray.h; flang/include/flang/Lower/ComponentPath.h; flang/include/flang/Lower/ConvertExpr.h; flang/include/flang/Lower/ConvertType.h; flang/include/flang/Lower/ConvertVariable.h; flang/include/flang/L,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:110392,variab,variable,110392,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['variab'],['variable']
Modifiability,"fo Debug, Verbose, Info VerboseLevel (Debug/Verbose/Info). Configuration options for the PDF class :. Configuration options reference for class: PDF. Option Array Default value Predefined values Description. NSmooth No 0 − Number of smoothing iterations for the input histograms. MinNSmooth No -1 − Min number of smoothing iterations, for bins with most data. MaxNSmooth No -1 − Max number of smoothing iterations, for bins with least data. NAvEvtPerBin No 50 − Average number of events per PDF bin. Nbins No 0 − Defined number of bins for the histogram from which the PDF is created. CheckHist No False − Whether or not to check the source histogram of the PDF. PDFInterpol No Spline2 Spline0, Spline1, Spline2, Spline3, Spline5, KDE Interpolation method for reference histograms (e.g. Spline2 or KDE). KDEtype No Gauss Gauss KDE kernel type (1=Gauss). KDEiter No Nonadaptive Nonadaptive, Adaptive Number of iterations (1=non-adaptive, 2=adaptive). KDEFineFactor No 1 − Fine tuning factor for Adaptive KDE: Factor to multyply the width of the kernel. KDEborder No None None, Renorm, Mirror Border effects treatment (1=no treatment , 2=kernel renormalization, 3=sample mirroring). Configuration options for Factory running :. Configuration options reference for class: Factory. Option Array Default value Predefined values Description. V No False − Verbose flag. Color No True − Flag for coloured screen output (default: True, if in batch mode: False). Transformations No − List of transformations to test; formatting example: Transformations=I;D;P;U;G,D, for identity, decorrelation, PCA, Uniform and Gaussianisation followed by decorrelation transformations. Silent No False − Batch mode: boolean silent flag inhibiting any output from TMVA after the creation of the factory class object (default: False). DrawProgressBar No True − Draw progress bar to display training, testing and evaluation schedule (default: True). AnalysisType No Auto Classification, Regression, Multiclass, Auto Set the anal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:34367,Adapt,Adaptive,34367,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['Adapt'],['Adaptive']
Modifiability,"foo.c; clang-11: output=/tmp/foo-855a8e.o, total=68.000 ms, user=60.000 ms, mem=86920 Kb; ld: output=a.out, total=8.000 ms, user=4.000 ms, mem=52320 Kb. The report file specified in the option is locked for write, so this option; can be used to collect statistics in parallel builds. The report file is not; cleared, new data is appended to it, thus making possible to accumulate build; statistics. You can also use environment variables to control the process statistics reporting.; Setting ``CC_PRINT_PROC_STAT`` to ``1`` enables the feature, the report goes to; stdout in human readable format.; Setting ``CC_PRINT_PROC_STAT_FILE`` to a fully qualified file path makes it report; process statistics to the given file in the CSV format. Specifying a relative; path will likely lead to multiple files with the same name created in different; directories, since the path is relative to a changing working directory. These environment variables are handy when you need to request the statistics; report without changing your build scripts or alter the existing set of compiler; options. Note that ``-fproc-stat-report`` take precedence over ``CC_PRINT_PROC_STAT``; and ``CC_PRINT_PROC_STAT_FILE``. .. code-block:: console. $ export CC_PRINT_PROC_STAT=1; $ export CC_PRINT_PROC_STAT_FILE=~/project-build-proc-stat.csv; $ make. Other Options; -------------; Clang options that don't fit neatly into other categories. .. option:: -fgnuc-version=. This flag controls the value of ``__GNUC__`` and related macros. This flag; does not enable or disable any GCC extensions implemented in Clang. Setting; the version to zero causes Clang to leave ``__GNUC__`` and other; GNU-namespaced macros, such as ``__GXX_WEAK__``, undefined. .. option:: -MV. When emitting a dependency file, use formatting conventions appropriate; for NMake or Jom. Ignored unless another option causes Clang to emit a; dependency file. When Clang emits a dependency file (e.g., you supplied the -M option); most filenames can be writte",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:28300,variab,variables,28300,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variables']
Modifiability,"for MVA method: Likelihood. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). TransformOutput No False − Transform likelihood output by inverse sigmoid function. Configuration options for MVA method :. Configuration options reference for MVA method: MLP. Option Array Default value Predefined values Description. NCycles No 500 − Number of training cycles. HiddenLayers No N,N-1 − Specification of hidden layer architecture. NeuronType No sigmoid − Neuron activation function type. RandomSeed No 1 − Random seed for initial synapse weights (0 means unique seed for each run; default value '1'). EstimatorType No MSE MSE, CE, linear, sigmoid, tanh, radial MSE (Mean Square Estimator) for Gaussian Likelihood or CE(Cross-Entropy) for Bernoulli Likelihood. NeuronInputType No sum sum, sqsum, abssum Neuron input function type. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Ga",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:20783,Config,Configuration,20783,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['Config'],['Configuration']
Modifiability,"for THttpServer with webgui. If THttpServer created for use with webgui widgets (RBrowser, RCanvas, REve), it only will; provide access to the widgets via websocket connection - any other kind of requests like root.json; or exe.json will be refused completely. Combined with connection tokens and https protocol,; this makes usage of webgui components in public networks more secure. ### Enabled WLCG Bearer Tokens support in RDavix. Bearer tokens are part of WLCG capability-based infrastructure with capability-based scheme which uses an infrastructure that describes what the bearer is allowed to do as opposed to who that bearer is. Token discovery procedure are developed according WLCG Bearer Token Discovery specification document (https://github.com/WLCG-AuthZ-WG/bearer-token-discovery/blob/master/specification.md). Short overview:. 1. If the `BEARER_TOKEN` environment variable is set, then the value is taken to be the token contents.; 2. If the `BEARER_TOKEN_FILE` environment variable is set, then its value is interpreted as a filename. The contents of the specified file are taken to be the token contents.; 3. If the `XDG_RUNTIME_DIR` environment variable is set, then take the token from the contents of `$XDG_RUNTIME_DIR/bt_u$ID`(this additional location is intended to provide improved security for shared login environments as `$XDG_RUNTIME_DIR` is defined to be user-specific as opposed to a system-wide directory.).; 4. Otherwise, take the token from `/tmp/bt_u$ID`. ## GUI Libraries. ### RBrowser improvements. - central factory methods to handle browsing, editing and drawing of different classes; - simple possibility to extend RBrowser on user-defined classes; - support of web-based geometry viewer; - better support of TTree drawing; - server-side handling of code editor and image viewer widgets; - rbrowser content is fully recovered when web-browser is reloaded; - load of widgets code only when really required (shorter startup time for RBrowser). ## Montecarlo Librar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:26275,variab,variable,26275,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['variab'],['variable']
Modifiability,"for a higher level source language constructs for building a compiler?; --------------------------------------------------------------------------------------------; Currently, there isn't much. LLVM supports an intermediate representation; which is useful for code representation but will not support the high level; (abstract syntax tree) representation needed by most compilers. There are no; facilities for lexical nor semantic analysis. I don't understand the ``GetElementPtr`` instruction. Help!; -----------------------------------------------------------; See `The Often Misunderstood GEP Instruction <GetElementPtr.html>`_. Using the C and C++ Front Ends; ==============================. Can I compile C or C++ code to platform-independent LLVM bitcode?; -----------------------------------------------------------------; No. C and C++ are inherently platform-dependent languages. The most obvious; example of this is the preprocessor. A very common way that C code is made; portable is by using the preprocessor to include platform-specific code. In; practice, information about other platforms is lost after preprocessing, so; the result is inherently dependent on the platform that the preprocessing was; targeting. Another example is ``sizeof``. It's common for ``sizeof(long)`` to vary; between platforms. In most C front-ends, ``sizeof`` is expanded to a; constant immediately, thus hard-wiring a platform-specific detail. Also, since many platforms define their ABIs in terms of C, and since LLVM is; lower-level than C, front-ends currently must emit platform-specific IR in; order to have the result conform to the platform ABI. Questions about code generated by the demo page; ===============================================. What is this ``llvm.global_ctors`` and ``_GLOBAL__I_a...`` stuff that happens when I ``#include <iostream>``?; -------------------------------------------------------------------------------------------------------------; If you ``#include`` the ``<iostre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst:5908,portab,portable,5908,interpreter/llvm-project/llvm/docs/FAQ.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst,1,['portab'],['portable']
Modifiability,"for all entries; Int_t nentries = (Int_t)t2->GetEntries();; for (Int_t i=0;i<nentries;i++) {; b_destep->GetEntry(i);; // fill the histogram with the destep entry; hdestep->Fill(destep);; }. // we do not close the file; we want to keep the generated histograms;; // we fill a 3-d scatter plot with the particle step coordinates; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,800);; c1->SetFillColor(42);; c1->Divide(1,2);. c1->cd(1);; hdestep->SetFillColor(45);; hdestep->Fit(""gaus"");. c1->cd(2);; gPad->SetFillColor(37); // continued...; t2->SetMarkerColor(kRed);; t2->Draw(""vect[0]:vect[1]:vect[2]"");; if (gROOT->IsBatch()) return;. // invoke the x3d viewer; gPad->GetViewer3D(""x3d"");; }; ```. ## Example 3: Adding Friends to Trees. In this example, we will show how to extend a tree with a branch from; another tree with the Friends feature. ### Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example, if one; variable in the tree was computed with a certain algorithm, you may want; to try another algorithm and compare the results. One solution is to add; a new branch, fill it, and save the tree. The code below adds a simple; branch to an existing tree. Note that the `kOverwrite` option in the; `Write` method overwrites the existing tree. If it is not specified, two; copies of the tree headers are saved. ``` {.cpp}; void tree3AddBranch() {; TFile f(""tree3.root"",""update"");; Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3-> Branch(""new_v"",&new_v,""new_v/F"");; //read the number of entries in the t3; Int_t nentries = (Int_t)t3->GetEntries();; for (Int_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0,1);; newBranch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the tree; }; ```. Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk lo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:51095,variab,variable,51095,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"for any function that has complex argument-based behaviors or optional; arguments. CMake's official documentation for the module is in the; ``cmake-modules`` manpage, and is also available at the; `cmake-modules online documentation; <https://cmake.org/cmake/help/v3.4/module/CMakeParseArguments.html>`_. .. note::; As of CMake 3.5 the cmake_parse_arguments command has become a native command; and the CMakeParseArguments module is empty and only left around for; compatibility. Functions Vs Macros; -------------------. Functions and Macros look very similar in how they are used, but there is one; fundamental difference between the two. Functions have their own scope, and; macros don't. This means variables set in macros will bleed out into the calling; scope. That makes macros suitable for defining very small bits of functionality; only. The other difference between CMake functions and macros is how arguments are; passed. Arguments to macros are not set as variables, instead dereferences to; the parameters are resolved across the macro before executing it. This can; result in some unexpected behavior if using unreferenced variables. For example:. .. code-block:: cmake. macro(print_list my_list); foreach(var IN LISTS my_list); message(""${var}""); endforeach(); endmacro(). set(my_list a b c d); set(my_list_of_numbers 1 2 3 4); print_list(my_list_of_numbers); # prints:; # a; # b; # c; # d. Generally speaking this issue is uncommon because it requires using; non-dereferenced variables with names that overlap in the parent scope, but it; is important to be aware of because it can lead to subtle bugs. LLVM Project Wrappers; =====================. LLVM projects provide lots of wrappers around critical CMake built-in commands.; We use these wrappers to provide consistent behaviors across LLVM components; and to reduce code duplication. We generally (but not always) follow the convention that commands prefaced with; ``llvm_`` are intended to be used only as building blocks for ot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:12434,variab,variables,12434,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['variab'],['variables']
Modifiability,"for debugging; or program visualization purposes. Transform passes can use (or invalidate); the analysis passes. Transform passes all mutate the program in some way.; Utility passes provides some utility but don't otherwise fit categorization.; For example passes to extract functions to bitcode or write a module to bitcode; are neither analysis nor transform passes. The table of contents above; provides a quick summary of each pass and links to the more complete pass; description later in the document. Analysis Passes; ===============. This section describes the LLVM Analysis Passes. ``aa-eval``: Exhaustive Alias Analysis Precision Evaluator; ----------------------------------------------------------. This is a simple N^2 alias analysis accuracy evaluator. Basically, for each; function in the program, it simply queries to see how the alias analysis; implementation answers alias queries between each pair of pointers in the; function. This is inspired and adapted from code by: Naveen Neelakantam, Francesco; Spadini, and Wojciech Stryjewski. ``basic-aa``: Basic Alias Analysis (stateless AA impl); ------------------------------------------------------. A basic alias analysis pass that implements identities (two different globals; cannot alias, etc), but does no stateful analysis. ``basiccg``: Basic CallGraph Construction; -----------------------------------------. Yet to be written. .. _passes-da:. ``da``: Dependence Analysis; ---------------------------. Dependence analysis framework, which is used to detect dependences in memory; accesses. ``domfrontier``: Dominance Frontier Construction; ------------------------------------------------. This pass is a simple dominator construction algorithm for finding forward; dominator frontiers. ``domtree``: Dominator Tree Construction; ----------------------------------------. This pass is a simple dominator construction algorithm for finding forward; dominators. ``dot-callgraph``: Print Call Graph to ""dot"" file; ----------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:1510,adapt,adapted,1510,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['adapt'],['adapted']
Modifiability,"for the loop is set up, we switch to emitting; code for the loop body. To begin with, we move the insertion point and; create the PHI node for the loop induction variable. Since we already; know the incoming value for the starting value, we add it to the Phi; node. Note that the Phi will eventually get a second value for the; backedge, but we can't set it up yet (because it doesn't exist!). .. code-block:: c++. // Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.; Value *OldVal = NamedValues[VarName];; NamedValues[VarName] = Variable;. // Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.; if (!Body->codegen()); return nullptr;. Now the code starts to get more interesting. Our 'for' loop introduces a; new variable to the symbol table. This means that our symbol table can; now contain either function arguments or loop variables. To handle this,; before we codegen the body of the loop, we add the loop variable as the; current value for its name. Note that it is possible that there is a; variable of the same name in the outer scope. It would be easy to make; this an error (emit an error and return null if there is already an; entry for VarName) but we choose to allow shadowing of variables. In; order to handle this correctly, we remember the Value that we are; potentially shadowing in ``OldVal`` (which will be null if there is no; shadowed variable). Once the loop variable is set into the symbol table, the code; recursively codegen's the body. This allows the body to use the loop; variable: any references to it will naturally find it in the symbol; table. .. code-block:: c++. // Emit the step value.; Value *StepVal = nullptr;; if (Step) {; StepVal = Step->codegen();; if (!StepVal); return nullptr;; } else {; // If not specified, use 1.0.; StepVal = ConstantFP::get(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:23032,variab,variables,23032,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['variab'],['variables']
Modifiability,"fore you should add an offset of one or two compile jobs ; to be sure its not terminated in your memory restricted environment. On ELF; platforms also consider ``LLVM_USE_SPLIT_DWARF`` in Debug build. **LLVM_PROFDATA_FILE**:PATH; Path to a profdata file to pass into clang's -fprofile-instr-use flag. This; can only be specified if you're building with clang. **LLVM_REVERSE_ITERATION**:BOOL; If enabled, all supported unordered llvm containers would be iterated in; reverse order. This is useful for uncovering non-determinism caused by; iteration of unordered containers. **LLVM_STATIC_LINK_CXX_STDLIB**:BOOL; Statically link to the C++ standard library if possible. This uses the flag; ""-static-libstdc++"", but a Clang host compiler will statically link to libc++; if used in conjunction with the **LLVM_ENABLE_LIBCXX** flag. Defaults to OFF. **LLVM_TABLEGEN**:STRING; Full path to a native TableGen executable (usually named ``llvm-tblgen``). This is; intended for cross-compiling: if the user sets this variable, no native; TableGen will be created. **LLVM_TARGET_ARCH**:STRING; LLVM target to use for native code generation. This is required for JIT; generation. It defaults to ""host"", meaning that it shall pick the architecture; of the machine where LLVM is being built. If you are cross-compiling, set it; to the target architecture name. **LLVM_TARGETS_TO_BUILD**:STRING; Semicolon-separated list of targets to build, or *all* for building all; targets. Case-sensitive. Defaults to *all*. Example:; ``-DLLVM_TARGETS_TO_BUILD=""X86;PowerPC""``.; The full list, as of March 2023, is:; ``AArch64;AMDGPU;ARM;AVR;BPF;Hexagon;Lanai;LoongArch;Mips;MSP430;NVPTX;PowerPC;RISCV;Sparc;SystemZ;VE;WebAssembly;X86;XCore``. **LLVM_TEMPORARILY_ALLOW_OLD_TOOLCHAIN**:BOOL; If enabled, the compiler version check will only warn when using a toolchain; which is about to be deprecated, instead of emitting an error. **LLVM_UBSAN_FLAGS**:STRING; Defines the set of compile flags used to enable UBSan. Only used ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:34101,variab,variable,34101,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variable']
Modifiability,"foreBinaryOperators>`; The way to wrap binary operators. Possible values:. * ``BOS_None`` (in configuration: ``None``); Break after operators. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa >; ccccccccccccccccccccccccccccccccccccccccc;. * ``BOS_NonAssignment`` (in configuration: ``NonAssignment``); Break before operators that aren't assignments. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; > ccccccccccccccccccccccccccccccccccccccccc;. * ``BOS_All`` (in configuration: ``All``); Break before operators. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable; = someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; > ccccccccccccccccccccccccccccccccccccccccc;. .. _BreakBeforeBraces:. **BreakBeforeBraces** (``BraceBreakingStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <BreakBeforeBraces>`; The brace breaking style to use. Possible values:. * ``BS_Attach`` (in configuration: ``Attach``); Always attach braces to surrounding context. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i) {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b) {; if (b) {; baz(2);; } else {; baz",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:47122,config,configuration,47122,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"format 15` :ref:`¶ <RequiresClausePosition>`; The position of the ``requires`` clause. Possible values:. * ``RCPS_OwnLine`` (in configuration: ``OwnLine``); Always put the ``requires`` clause on its own line. .. code-block:: c++. template <typename T>; requires C<T>; struct Foo {... template <typename T>; requires C<T>; void bar(T t) {... template <typename T>; void baz(T t); requires C<T>; {... * ``RCPS_WithPreceding`` (in configuration: ``WithPreceding``); Try to put the clause together with the preceding part of a declaration.; For class templates: stick to the template declaration.; For function templates: stick to the template declaration.; For function declaration followed by a requires clause: stick to the; parameter list. .. code-block:: c++. template <typename T> requires C<T>; struct Foo {... template <typename T> requires C<T>; void bar(T t) {... template <typename T>; void baz(T t) requires C<T>; {... * ``RCPS_WithFollowing`` (in configuration: ``WithFollowing``); Try to put the ``requires`` clause together with the class or function; declaration. .. code-block:: c++. template <typename T>; requires C<T> struct Foo {... template <typename T>; requires C<T> void bar(T t) {... template <typename T>; void baz(T t); requires C<T> {... * ``RCPS_SingleLine`` (in configuration: ``SingleLine``); Try to put everything in the same line if possible. Otherwise normal; line breaking rules take over. .. code-block:: c++. // Fitting:; template <typename T> requires C<T> struct Foo {... template <typename T> requires C<T> void bar(T t) {... template <typename T> void bar(T t) requires C<T> {... // Not fitting, one possible example:; template <typename LongName>; requires C<LongName>; struct Foo {... template <typename LongName>; requires C<LongName>; void bar(LongName ln) {. template <typename LongName>; void bar(LongName ln); requires C<LongName> {. .. _RequiresExpressionIndentation:. **RequiresExpressionIndentation** (``RequiresExpressionIndentationKind``) :versionbadg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:105215,config,configuration,105215,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"format 3.7` :ref:`¶ <BinPackParameters>`; If ``false``, a function declaration's or function definition's; parameters will either all be on the same line or will have one line each. .. code-block:: c++. true:; void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. false:; void f(int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. .. _BitFieldColonSpacing:. **BitFieldColonSpacing** (``BitFieldColonSpacingStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BitFieldColonSpacing>`; The BitFieldColonSpacingStyle to use for bitfields. Possible values:. * ``BFCS_Both`` (in configuration: ``Both``); Add one space on each side of the ``:``. .. code-block:: c++. unsigned bf : 2;. * ``BFCS_None`` (in configuration: ``None``); Add no space around the ``:`` (except when needed for; ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf:2;. * ``BFCS_Before`` (in configuration: ``Before``); Add space before the ``:`` only. .. code-block:: c++. unsigned bf :2;. * ``BFCS_After`` (in configuration: ``After``); Add space after the ``:`` only (space may be added before if; needed for ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf: 2;. .. _BraceWrapping:. **BraceWrapping** (``BraceWrappingFlags``) :versionbadge:`clang-format 3.8` :ref:`¶ <BraceWrapping>`; Control of individual brace wrapping cases. If ``BreakBeforeBraces`` is set to ``BS_Custom``, use this to specify how; each individual brace case should be handled. Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; BreakBeforeBraces: Custom; BraceWrapping:; AfterEnum: true; AfterStruct: false; SplitEmptyFunction: false. Nested configuration flags:. Precise control over the wrapping of braces. .. code-block:: c++. # Should be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:37995,config,configuration,37995,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"formation about; their status (generally only for failures). See the :ref:`output-options`; section for more information. .. _lit-infrastructure:. LIT INFRASTRUCTURE; ------------------. This section describes the :program:`lit` testing architecture for users interested in; creating a new :program:`lit` testing implementation, or extending an existing one. :program:`lit` proper is primarily an infrastructure for discovering and running; arbitrary tests, and to expose a single convenient interface to these; tests. :program:`lit` itself doesn't know how to run tests, rather this logic is; defined by *test suites*. TEST SUITES; ~~~~~~~~~~~. As described in :ref:`test-discovery`, tests are always located inside a *test; suite*. Test suites serve to define the format of the tests they contain, the; logic for finding those tests, and any additional information to run the tests. :program:`lit` identifies test suites as directories containing ``lit.cfg`` or; ``lit.site.cfg`` files (see also :option:`--config-prefix`). Test suites are; initially discovered by recursively searching up the directory hierarchy for; all the input files passed on the command line. You can use; :option:`--show-suites` to display the discovered test suites at startup. Once a test suite is discovered, its config file is loaded. Config files; themselves are Python modules which will be executed. When the config file is; executed, two important global variables are predefined:. **lit_config**. The global **lit** configuration object (a *LitConfig* instance), which defines; the builtin test formats, global configuration parameters, and other helper; routines for implementing test configurations. **config**. This is the config object (a *TestingConfig* instance) for the test suite,; which the config file is expected to populate. The following variables are also; available on the *config* object, some of which must be set by the config and; others are optional or predefined:. **name** *[required]* The nam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:14535,config,config-prefix,14535,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['config'],['config-prefix']
Modifiability,"formation for the variable ``Z``. .. code-block:: text. !18 = distinct !DILexicalBlock(scope: !4, file: !1, line: 4, column: 5); !19 = !DILocation(line: 5, column: 11, scope: !18). Here ``!19`` indicates that ``Z`` is declared at line number 5 and column; number 11 inside of lexical scope ``!18``. The lexical scope itself resides; inside of subprogram ``!4`` described above. The scope information attached with each instruction provides a straightforward; way to find instructions covered by a scope. Object lifetime in optimized code; =================================. In the example above, every variable assignment uniquely corresponds to a; memory store to the variable's position on the stack. However in heavily; optimized code LLVM promotes most variables into SSA values, which can; eventually be placed in physical registers or memory locations. To track SSA; values through compilation, when objects are promoted to SSA values an; ``llvm.dbg.value`` intrinsic is created for each assignment, recording the; variable's new location. Compared with the ``llvm.dbg.declare`` intrinsic:. * A dbg.value terminates the effect of any preceding dbg.values for (any; overlapping fragments of) the specified variable.; * The dbg.value's position in the IR defines where in the instruction stream; the variable's value changes.; * Operands can be constants, indicating the variable is assigned a; constant value. Care must be taken to update ``llvm.dbg.value`` intrinsics when optimization; passes alter or move instructions and blocks -- the developer could observe such; changes reflected in the value of variables when debugging the program. For any; execution of the optimized program, the set of variable values presented to the; developer by the debugger should not show a state that would never have existed; in the execution of the unoptimized program, given the same input. Doing so; risks misleading the developer by reporting a state that does not exist,; damaging their understanding of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:18310,variab,variable,18310,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"found during code generation; (for example, use of an undeclared parameter):. .. code-block:: c++. static std::unique_ptr<LLVMContext> TheContext;; static std::unique_ptr<IRBuilder<>> Builder(TheContext);; static std::unique_ptr<Module> TheModule;; static std::map<std::string, Value *> NamedValues;. Value *LogErrorV(const char *Str) {; LogError(Str);; return nullptr;; }. The static variables will be used during code generation. ``TheContext``; is an opaque object that owns a lot of core LLVM data structures, such as; the type and constant value tables. We don't need to understand it in; detail, we just need a single instance to pass into APIs that require it. The ``Builder`` object is a helper object that makes it easy to generate; LLVM instructions. Instances of the; `IRBuilder <https://llvm.org/doxygen/IRBuilder_8h_source.html>`_; class template keep track of the current place to insert instructions; and has methods to create new instructions. ``TheModule`` is an LLVM construct that contains functions and global; variables. In many ways, it is the top-level structure that the LLVM IR; uses to contain code. It will own the memory for all of the IR that we; generate, which is why the codegen() method returns a raw Value\*,; rather than a unique_ptr<Value>. The ``NamedValues`` map keeps track of which values are defined in the; current scope and what their LLVM representation is. (In other words, it; is a symbol table for the code). In this form of Kaleidoscope, the only; things that can be referenced are function parameters. As such, function; parameters will be in this map when generating code for their function; body. With these basics in place, we can start talking about how to generate; code for each expression. Note that this assumes that the ``Builder``; has been set up to generate code *into* something. For now, we'll assume; that this has already been done, and we'll just use it to emit code. Expression Code Generation; ==========================. Generating",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:3810,variab,variables,3810,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['variab'],['variables']
Modifiability,"free to contact us on `the Discourse forums (Clang Frontend category); <https://discourse.llvm.org/c/clang/6>`_ or file `a GitHub issue; <https://github.com/llvm/llvm-project/issues/new>`_. .. _opencl_experimental_cxxlibs:. C++ libraries for OpenCL; ------------------------. There is ongoing work to support C++ standard libraries from `LLVM's libcxx; <https://libcxx.llvm.org/>`_ in OpenCL kernel code using C++ for OpenCL mode. It is currently possible to include `type_traits` from C++17 in the kernel; sources when the following clang extensions are enabled; ``__cl_clang_function_pointers`` and ``__cl_clang_variadic_functions``,; see :doc:`LanguageExtensions` for more details. The use of non-conformant; features enabled by the extensions does not expose non-conformant behavior; beyond the compilation i.e. does not get generated in IR or binary.; The extension only appear in metaprogramming; mechanism to identify or verify the properties of types. This allows to provide; the full C++ functionality without a loss of portability. To avoid unsafe use; of the extensions it is recommended that the extensions are disabled directly; after the header include. **Example of Use**:. The example of kernel code with `type_traits` is illustrated here. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_function_pointers : enable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : enable; #include <type_traits>; #pragma OPENCL EXTENSION __cl_clang_function_pointers : disable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : disable. using sint_type = std::make_signed<unsigned int>::type;. __kernel void foo() {; static_assert(!std::is_same<sint_type, unsigned int>::value);; }. The possible clang invocation to compile the example is as follows:. .. code-block:: console. $ clang -I<path to libcxx checkout or installation>/include test.clcpp. Note that `type_traits` is a header only library and therefore no extra; linking step against the standard libraries is require",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:23595,portab,portability,23595,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst,1,['portab'],['portability']
Modifiability,"from HybridCalculator to; HybridCalculatorOriginal; Note also that with the new class no HybridResult is; returned but directly the base class HypoTestResult which; has been improved for this release.; The plot class, HybridPlot is not returned, but; the user can create an HypoTestPlot object from the; HypoTestResult.; The classes HybridResult and HybridPlot work only; with the HybridCalculatorOriginal and remain for maintaining; a backward compatibility. ; Given a ModelConfig, the tool will attempt to form the posterior pdf ; for the nuisance parameters based on the prior and the constraint terms ; in the pdf. However, this is not yet implemented. In order to keep; logical consistency with other tools, the distribution being used; to smear the nuisance parameters should NOT be considered the prior in ; the model config. Instead, one should use HybridCalculator's; ForcePriorNuisanceNull and ForcePriorNuisanceAlt. HybridCalculatorOriginal. Apply a fix for test statistic = 3 (profile likelihood); Apply a fix for using non-extended pdf. TestStatSampler and TestStatistics. Cleanup of the interfaces.; TestStatistics now have a method PValueIsRightTail to specify the sign conventions for the test statistic. This is used when making plots and calculating p-values.; make clear that TestStatistic::Evaluate should take data and values of the parameters that define the null.; Add method TestStatSampler::SetParametersForTestStat that ; allows for greater control of parameters used for generating toy data; and parameters used for evaluating the test statistic.; ProfileLikelihoodTestStatUsing the raw profile likelihood while reviewing the old algorithm used to provide robustness in situations with local minima.; New test statistic classes:; ; SimpleLikelihoodRatioTestStat : log L_1 / L_0; RatioOfProfiledLikelihoodsTestStat: log L(mu_1, hat(nu_1))/L(mu_0,hat(nu_0)); MaxLikelihoodEstimateTestStat: the MLE of a specified parameter. ToyMCSampler. New version of ToyMCSampler which can ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html:6405,extend,extended,6405,roofit/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html,2,['extend'],['extended']
Modifiability,"from the context menu and that method; has options, the user will be asked for numerical values or strings to; fill in the option. For example, `TAxis::SetTitle` will prompt you for a; string to use for the axis title. ![Context menus of different objects in a canvas](pictures/030000A0.png). #### Structure of the Context Menus. The curious reader will have noticed that each entry in the context menu; corresponds to a method of the class. Look for example to the menu named; `TAxis::xaxis`. `xaxis` is the name of the object and **`TAxis`** the; name of its class. If we look at the list of **`TAxis`** methods, for; example in <https://root.cern/doc/master/classTAxis.html>, we see the; methods `SetTimeDisplay()` and` UnZoom()`, which appear also in the; context menu. There are several divisions in the context menu, separated by lines. The; top division is a list of the class methods; the second division is a; list of the parent class methods. The subsequent divisions are the; methods other parent classes in case of multiple inheritance. For; example, see the `TPaveText::title context; menu.` A **`TPaveText`** inherits from **`TAttLine`**, which has the; method `SetLineAttributes()`. #### Adding Context Menus for a Class. For a method to appear in the context menu of the object it has to be; marked by `// *MENU*` in the header file. Below is the line from; `TAttLine.h` that adds the `SetLineAttribute` method to the context; menu. ``` {.cpp}; virtual void SetLineAttributes(); // *MENU*; ```. Nothing else is needed, since Cling knows the classes and their methods.; It takes advantage of that to create the context menu on the fly when; the object is clicking on. If you click on an axis, ROOT will ask the; interpreter what are the methods of the **`TAxis`** and which ones are; set for being displayed in a context menu. Now, how does the interpreter know this? Remember, when you build a; class that you want to use in the ROOT environment, you use `rootcling`; that builds the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:5762,inherit,inheritance,5762,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['inherit'],['inheritance']
Modifiability,"from those superclasses. ``Init``; --------. The ``Init`` class is used to represent TableGen values. The name derives; from *initialization value*. This class should not be confused with the; ``RecordVal`` class, which represents record fields, both their names and; values. The ``Init`` class is the base class for a series of subclasses, one; for each of the available value types. The primary data member of ``Init``; is an enumerated type that represents the specific type of the value. The ``Init`` class provides a few useful functions. * A function to get the type enumerator. * A boolean virtual function to determine whether a value is completely; specified; that is, has no uninitialized subvalues. * Virtual functions to get the value as a string. * Virtual functions to cast the value to other types, implement the bit; range feature of TableGen, and implement the list slice feature. * A virtual function to get a particular bit of the value. The subclasses that inherit directly from ``Init`` are; ``UnsetInit`` and ``TypedInit``. An ``Init`` instance can be printed to an output stream with the ``<<``; operator. .. warning::; It is not specified whether two separate initialization values with; the same underlying type and value (e.g., two strings with the value; ""Hello"") are represented by two ``Init``\ s or share the same ``Init``. ``UnsetInit``; ~~~~~~~~~~~~~. This class, a subclass of ``Init``, represents the unset (uninitialized); value. The static function ``get()`` can be used to obtain the singleton; ``Init`` of this type. ``TypedInit``; ~~~~~~~~~~~~~. This class, a subclass of ``Init``, acts as the parent class of the classes; that represent specific value types (except for the unset value). These; classes include ``BitInit``, ``BitsInit``, ``DagInit``, ``DefInit``,; ``IntInit``, ``ListInit``, and ``StringInit``. (There are additional derived; types used by the TableGen parser.). This class includes a data member that specifies the ``RecTy`` type of the; value",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst:9699,inherit,inherit,9699,interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,1,['inherit'],['inherit']
Modifiability,"fter collapsing a loop nest via the; collapse clause by replacing the expensive remainder operation with; multiplications and additions. - When using the collapse clause on a loop nest the default behavior; is to automatically extend the representation of the loop counter to; 64 bits for the cases where the sizes of the collapsed loops are not; known at compile time. To prevent this conservative choice and use; at most 32 bits, compile your program with the; `-fopenmp-optimistic-collapse`. GPU devices support; ===================. Data-sharing modes; ------------------. Clang supports two data-sharing models for Cuda devices: `Generic` and `Cuda`; modes. The default mode is `Generic`. `Cuda` mode can give an additional; performance and can be activated using the `-fopenmp-cuda-mode` flag. In; `Generic` mode all local variables that can be shared in the parallel regions; are stored in the global memory. In `Cuda` mode local variables are not shared; between the threads and it is user responsibility to share the required data; between the threads in the parallel regions. Often, the optimizer is able to; reduce the cost of `Generic` mode to the level of `Cuda` mode, but the flag,; as well as other assumption flags, can be used for tuning. Features not supported or with limited support for Cuda devices; ---------------------------------------------------------------. - Cancellation constructs are not supported. - Doacross loop nest is not supported. - User-defined reductions are supported only for trivial types. - Nested parallelism: inner parallel regions are executed sequentially. - Debug information for OpenMP target regions is supported, but sometimes it may; be required to manually specify the address class of the inspected variables.; In some cases the local variables are actually allocated in the global memory,; but the debug info may be not aware of it. .. _OpenMP implementation details:. OpenMP 5.0 Implementation Details; =================================. The ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:1885,variab,variables,1885,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['variab'],['variables']
Modifiability,"ftware and method performance; validation has been implemented.; . Methods. BDT Automatic parameter optimisation for building the; tree architecture: The optimisation procedure uses the; performance of the trained classifier on the ""test sample"" for; finding the set of optimal parameters. Two different methods to; traverse the parameter space are available (scanning, genetic; algorithm). Currently parameter optimization is implemented only; for these three parameters that influence the tree architectur:; the maximum depth of a tree, MaxDepth, the minimum; number of events in each node, NodeMinEvents, and; the number of tress, NTrees. Optimization can; is invoked by calling; factory->OptimizeAllMethods(); prior to the call; factory->TrainAllMethods();. Automated and configurable parameter optimization is soon to; be enabled for all methods (for those parameters where; optimization is applicable).; . BDT node splitting: While Decision Trees; typically have only univariate splits, in TMVA one can now; also opt for multivariate splits that use a ""Fisher; Discriminant"" (option: UseFisherCuts), built from all; observables that show correlations larger than some threshold; (MinLinCorrForFisher). The training will then test at each; split a cut on this fisher discriminant in addition to all; univariate cuts on the variables (or only on those variables; that have not been used in the Fisher discriminant, option; UseExcusiveVars). No obvious improvement betwen very simple; decision trees after boosting has been observed so far, but; only a limited number of studies has been performed concerning; potiential benenfit of these simple multivariate splits.; . Bug fixes. A problem in the BDTG has been fixed, leading to a much; improved regression performance.; A problem in the TMVA::Reader has been fixed.; With the new test framework and the coverity checks of ROOT; a number of bugs were discovered and fixed. They mainly concerned; memory leaks, and did not affect the performance. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v528/index.html:2809,variab,variables,2809,tmva/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v528/index.html,4,['variab'],['variables']
Modifiability,"ful to implement named register global variables that need; to always be mapped to a specific register, as is common practice on; bare-metal programs including OS kernels. The compiler doesn't check for register availability or use of the used; register in surrounding code, including inline assembly. Because of that,; allocatable registers are not supported. Warning: So far it only works with the stack pointer on selected; architectures (ARM, AArch64, PowerPC and x86_64). Significant amount of; work is needed to support other registers and even more so, allocatable; registers. .. _int_stacksave:. '``llvm.stacksave``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.stacksave.p0(); declare ptr addrspace(5) @llvm.stacksave.p5(). Overview:; """""""""""""""""". The '``llvm.stacksave``' intrinsic is used to remember the current state; of the function stack, for use with; :ref:`llvm.stackrestore <int_stackrestore>`. This is useful for; implementing language features like scoped automatic variable sized; arrays in C99. Semantics:; """""""""""""""""""". This intrinsic returns an opaque pointer value that can be passed to; :ref:`llvm.stackrestore <int_stackrestore>`. When an; ``llvm.stackrestore`` intrinsic is executed with a value saved from; ``llvm.stacksave``, it effectively restores the state of the stack to; the state it was in when the ``llvm.stacksave`` intrinsic executed. In; practice, this pops any :ref:`alloca <i_alloca>` blocks from the stack; that were allocated after the ``llvm.stacksave`` was executed. The; address space should typically be the; :ref:`alloca address space <alloca_addrspace>`. .. _int_stackrestore:. '``llvm.stackrestore``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.stackrestore.p0(ptr %ptr); declare void @llvm.stackrestore.p5(ptr addrspace(5) %ptr). Overview:; """""""""""""""""". The '``llvm.stackrestore``' intrinsic is used to restore the state of; the function stack to the state it was in when ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:519887,variab,variable,519887,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"function -> module; MPM.addPass(createModuleToFunctionPassAdaptor(createFunctionToLoopPassAdaptor(LoopFooPass())));; // function -> module; MPM.addPass(createModuleToFunctionPassAdaptor(FunctionFooPass()));. // loop -> function -> cgscc -> module; MPM.addPass(createModuleToPostOrderCGSCCPassAdaptor(createCGSCCToFunctionPassAdaptor(createFunctionToLoopPassAdaptor(LoopFooPass()))));; // function -> cgscc -> module; MPM.addPass(createModuleToPostOrderCGSCCPassAdaptor(createCGSCCToFunctionPassAdaptor(FunctionFooPass())));. A pass manager of a specific IR unit is also a pass of that kind. For; example, a ``FunctionPassManager`` is a function pass, meaning it can be; added to a ``ModulePassManager``:. .. code-block:: c++. ModulePassManager MPM;. FunctionPassManager FPM;; // InstSimplifyPass is a function pass; FPM.addPass(InstSimplifyPass());. MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));. Generally you want to group CGSCC/function/loop passes together in a pass; manager, as opposed to adding adaptors for each pass to the containing upper; level pass manager. For example,. .. code-block:: c++. ModulePassManager MPM;; MPM.addPass(createModuleToFunctionPassAdaptor(FunctionPass1()));; MPM.addPass(createModuleToFunctionPassAdaptor(FunctionPass2()));; MPM.run();. will run ``FunctionPass1`` on each function in a module, then run; ``FunctionPass2`` on each function in the module. In contrast,. .. code-block:: c++. ModulePassManager MPM;. FunctionPassManager FPM;; FPM.addPass(FunctionPass1());; FPM.addPass(FunctionPass2());. MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));. will run ``FunctionPass1`` and ``FunctionPass2`` on the first function in a; module, then run both passes on the second function in the module, and so on.; This is better for cache locality around LLVM data structures. This similarly; applies for the other IR types, and in some cases can even affect the quality; of optimization. For example, running all loop passes on a loop may",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:3865,adapt,adaptors,3865,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['adapt'],['adaptors']
Modifiability,"function attributes often have default values or the test works just; as well with default values. Typical candidates for this are: `alignment:`,; `exposesReturnsTwice`, `legalized`, `regBankSelected`, `selected`.; The whole `frameInfo` section is often unnecessary if there is no special; frame usage in the function. `tracksRegLiveness` on the other hand is often; necessary for some passes that care about block livein lists. - The (global) `liveins:` list is typically only interesting for early; instruction selection passes and can be removed when testing later passes.; The per-block `liveins:` on the other hand are necessary if; `tracksRegLiveness` is true. - Branch probability data in block `successors:` lists can be dropped if the; test doesn't depend on it. Example:; `successors: %bb.1(0x40000000), %bb.2(0x40000000)` can be replaced with; `successors: %bb.1, %bb.2`. - MIR code contains a whole IR module. This is necessary because there are; no equivalents in MIR for global variables, references to external functions,; function attributes, metadata, debug info. Instead some MIR data references; the IR constructs. You can often remove them if the test doesn't depend on; them. - Alias Analysis is performed on IR values. These are referenced by memory; operands in MIR. Example: `:: (load 8 from %ir.foobar, !alias.scope !9)`.; If the test doesn't depend on (good) alias analysis the references can be; dropped: `:: (load 8)`. - MIR blocks can reference IR blocks for debug printing, profile information; or debug locations. Example: `bb.42.myblock` in MIR references the IR block; `myblock`. It is usually possible to drop the `.myblock` reference and simply; use `bb.42`. - If there are no memory operands or blocks referencing the IR then the; IR function can be replaced by a parameterless dummy function like; `define @func() { ret void }`. - It is possible to drop the whole IR section of the MIR file if it only; contains dummy functions (see above). The .mir loader will cr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:4196,variab,variables,4196,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['variab'],['variables']
Modifiability,"function=[name]. Instruct code generator to emit a function call to the specified; function name for ``__builtin_trap()``. LLVM code generator translates ``__builtin_trap()`` to a trap; instruction if it is supported by the target ISA. Otherwise, the; builtin is translated into a call to ``abort``. If this option is; set, then the code generator will always lower the builtin to a call; to the specified function regardless of whether the target ISA has a; trap instruction. This option is useful for environments (e.g.; deeply embedded) where a trap cannot be properly handled, or when; some custom behavior is desired. .. option:: -ftls-model=[model]. Select which TLS model to use. Valid values are: ``global-dynamic``, ``local-dynamic``,; ``initial-exec`` and ``local-exec``. The default value is; ``global-dynamic``. The compiler may use a different model if the; selected model is not supported by the target, or if a more; efficient model can be used. The TLS model can be overridden per; variable using the ``tls_model`` attribute. .. option:: -femulated-tls. Select emulated TLS model, which overrides all -ftls-model choices. In emulated TLS mode, all access to TLS variables are converted to; calls to __emutls_get_address in the runtime library. .. option:: -mhwdiv=[values]. Select the ARM modes (arm or thumb) that support hardware division; instructions. Valid values are: ``arm``, ``thumb`` and ``arm,thumb``.; This option is used to indicate which mode (arm or thumb) supports; hardware division instructions. This only applies to the ARM; architecture. .. option:: -m[no-]crc. Enable or disable CRC instructions. This option is used to indicate whether CRC instructions are to; be generated. This only applies to the ARM architecture. CRC instructions are enabled by default on ARMv8. .. option:: -mgeneral-regs-only. Generate code which only uses the general purpose registers. This option restricts the generated code to use general registers; only. This only applies to the AArc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:83767,variab,variable,83767,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variable']
Modifiability,"functions and the dictionary. These; functions and the dictionary contain the knowledge of the used classes.; To do this, `rootcling` parses all the header files. ROOT has defined; some special syntax to inform Cling of certain things, this is done in; the comments so that the code still compiles with a C++ compiler. For example, you have a class with a `Draw()` method, which will display; itself. You would like a context menu to appear when on clicks on the; image of an object of this class. The recipe is the following:. - The class has to contain the `ClassDef/ClassImp` macros. - For each method you want to appear in the context menu, put a; comment after the declaration containing `*MENU*` or `*TOGGLE*`; depending on the behavior you expect. One usually uses Set methods; (setters). The `*TOGGLE*` comment is used to toggle a `boolean` data; field. In that case, it is safe to call the data field `fMyBool`; where `MyBool` is the name of the setter `SetMyBool`. Replace; `MyBool` with your own `boolean` variable. - You can specify arguments and the data members in which to store the; arguments. For example:. ``` {.cpp}; class MyClass : public TObject {; private:; int fV1; // first variable; double fV2; // second variable; public:; int GetV1() {return fV1;}; double GetV2() {return fV2;}; void SetV1(int x1) { fV1 = x1;} // *MENU*; void SetV2(double d2) { fV2 = d2;} // *MENU*; void SetBoth(int x1, double d2) {fV1 = x1; fV2 = d2;}. ClassDef (MyClass,1); }; ```. To specify arguments:. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fV1}; ```. This statement is in the comment field, after the \*MENU\*. If there is; more than one argument, these arguments are separated by commas, where; fX1 and fY2 are data fields in the same class. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fX1,y2=>fY2}; ```. If the arguments statement is present, the option dialog displayed when; selecting `SetXXX field` will show the values of variables. We indic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:7758,variab,variable,7758,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['variab'],['variable']
Modifiability,"functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5473,variab,variable,5473,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,2,['variab'],['variable']
Modifiability,"fuzzer is good for stressing the surface layers of a; program, and is good at testing things like lexers, parsers, or binary; protocols. Some of the in-tree fuzzers that use this type of mutator are `clang-fuzzer`_,; `clang-format-fuzzer`_, `llvm-as-fuzzer`_, `llvm-dwarfdump-fuzzer`_,; `llvm-mc-assemble-fuzzer`_, and `llvm-mc-disassemble-fuzzer`_. .. _fuzzing-llvm-protobuf:. Structured Fuzzing using ``libprotobuf-mutator``; ------------------------------------------------. We can use libprotobuf-mutator_ in order to perform structured fuzzing and; stress deeper layers of programs. This works by defining a protobuf class that; translates arbitrary data into structurally interesting input. Specifically, we; use this to work with a subset of the C++ language and perform mutations that; produce valid C++ programs in order to exercise parts of clang that are more; interesting than parser error handling. To build this kind of fuzzer you need `protobuf`_ and its dependencies; installed, and you need to specify some extra flags when configuring the build; with :doc:`CMake <CMake>`. For example, `clang-proto-fuzzer`_ can be enabled by; adding ``-DCLANG_ENABLE_PROTO_FUZZER=ON`` to the flags described in; :ref:`building-fuzzers`. The only in-tree fuzzer that uses ``libprotobuf-mutator`` today is; `clang-proto-fuzzer`_. .. _libprotobuf-mutator: https://github.com/google/libprotobuf-mutator; .. _protobuf: https://github.com/google/protobuf. .. _fuzzing-llvm-ir:. Structured Fuzzing of LLVM IR; -----------------------------. We also use a more direct form of structured fuzzing for fuzzers that take; :doc:`LLVM IR <LangRef>` as input. This is achieved through the ``FuzzMutate``; library, which was `discussed at EuroLLVM 2017`_. The ``FuzzMutate`` library is used to structurally fuzz backends in; `llvm-isel-fuzzer`_. .. _discussed at EuroLLVM 2017: https://www.youtube.com/watch?v=UBbQ_s6hNgg. Building and Running; ====================. .. _building-fuzzers:. Configuring LLVM to Build",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst:7021,config,configuring,7021,interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,1,['config'],['configuring']
Modifiability,"fy must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DATA_SOURCE_DIR=<path to llvm-test-suite> \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DEPS=runtimes. The BOOTSTRAP\_ prefixes tells CMake to pass the variables on to the instrumented; stage two build. And the CLANG_PGO_TRAINING_DEPS option let's you specify; additional build targets to build before building the external project. The; LLVM Test Suite requires compiler-rt to build, so we need to add the; `runtimes` target as a dependency. After configuration, building the stage2-instrumented-generate-profdata target; will automatically build the stage1 compiler, build the instrumented compiler; with the stage1 compiler, and then run the instrumented compiler against the; perf training data:. .. code-block:: console. $ ninja stage2-instrumented-generate-profdata. If you let that run for a few hours or so, it will place a profdata file in your; build directory. This takes a really long time because it builds clang twice,; and you *must* have compiler-rt in your build tree. This process uses any source files under the perf-training directory as training; data as long as the source files are marked up with LIT-style RUN lines. After it finishes you can use :code:`find . -name clang.profdata` to find it, but it; should be at a path something like:. .. code-block:: console. <build dir>/tools/clang/stage2-instrumented-bins/utils/perf-training/clang.profdata. You can feed that file into the LLVM_PROFDATA_FILE option when you build your; optimized compiler. It may be necessary to build additional targets before running perf training, such as; builtins an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:7306,config,configuration,7306,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['config'],['configuration']
Modifiability,"g and testing LLVM/Clang on ARM. :doc:`HowToBuildWithPGO`; Notes on building LLVM/Clang with PGO. :doc:`HowToCrossCompileLLVM`; Notes on cross-building and testing LLVM/Clang. `How to build the C, C++, ObjC, and ObjC++ front end`__; Instructions for building the clang front-end from source. .. __: https://clang.llvm.org/get_started.html. :doc:`CoverageMappingFormat`; This describes the format and encoding used for LLVM’s code coverage mapping. :doc:`CFIVerify`; A description of the verification tool for Control Flow Integrity. LLVM Builds and Distributions; -----------------------------. :doc:`BuildingADistribution`; A best-practices guide for using LLVM's CMake build system to package and; distribute LLVM-based tools. :doc:`CMake`; An addendum to the main Getting Started guide for those using the `CMake; build system <http://www.cmake.org>`_. :doc:`Docker`; A reference for using Dockerfiles provided with LLVM. :doc:`Support Library <SupportLibrary>`; This document describes the LLVM Support Library (``lib/Support``) and; how to keep LLVM source code portable. :doc:`AdvancedBuilds`; This document describes more advanced build configurations. Optimizations; -------------. :doc:`WritingAnLLVMPass`; Information on how to write LLVM transformations and analyses. :doc:`WritingAnLLVMNewPMPass`; Information on how to write LLVM transformations under the new pass; manager. :doc:`Passes`; A list of optimizations and analyses implemented in LLVM. :doc:`StackSafetyAnalysis`; This document describes the design of the stack safety analysis of local; variables. :doc:`MergeFunctions`; Describes functions merging optimization. :doc:`AliasAnalysis`; Information on how to write a new alias analysis implementation or how to; use existing analyses. :doc:`MemorySSA`; Information about the MemorySSA utility in LLVM, as well as how to use it. :doc:`LoopTerminology`; A document describing Loops and associated terms as used in LLVM. :doc:`CycleTerminology`; A document describing cycles as a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst:2507,portab,portable,2507,interpreter/llvm-project/llvm/docs/UserGuides.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst,1,['portab'],['portable']
Modifiability,"g as the `CMakeCache.txt` file is not removed. Remember that after building a tarball or a binary package you should remove the copied files using:. ```bash; make purge; ```. Otherwise git shows the file as untracked, unless you explicitly remove their tracking yourself with a .gitignore file. ## Building a tarball. Minuit2 standalone also has support for CPack to make installers for different platforms. To build a source package:. ```bash; make package_source; ```. This will create a source file in several formats that you can distribute. Reminder: You **must** have used `-Dminuit2_standalone=ON` when you configured CMake, or many of the files will be missing. ## Building a binary. To build a binary package (add other generators with `-G`):; ```bash; make; make package; ```. ## Maintenance. If new files are needed by Minuit2 due to additions to [ROOT], they should be added to the source files lists in `src/Math/CMakeLists.txt` and `src/Minuit2/CMakeLists.txt` (depending on if it's a new Math or Minuit2 requirement). For testing, the main `test/CMakeLists.txt` is used by ROOT, and the `test/*/CMakeLists.txt` files are used by the standalone build. ## How it works. Extracting from the ROOT sources is made possible through a few careful design features:. * A CMake variable `minuit2_inroot` lets the build system know we are inside ROOT (it looks for `../../build/version_info`); * All files that are not part of the minuit2 directory are passed into `copy_standalone`, and that handles selecting the correct location; * `copy_standalone` copies the files into the minuit2 source directory if `minuit2_standalone` is `ON`. After this happens, all the standard CMake machinery can produce the source distribution. And, CMake correctly builds and installs in either mode, since all source and header files are explicitly listed. [ROOT]: https://root.cern; [minuitdoc]: https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html#minuit2-package; [CMake]: https://cmake.org; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/DEVELOP.md:2112,variab,variable,2112,math/minuit2/DEVELOP.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/DEVELOP.md,1,['variab'],['variable']
Modifiability,"g because the initializer expression is; evaluated at the call site but doesn't syntactically belong to the; caller's AST; instead it belongs to the ParmVarDecl for the default; parameter. This can lead to situations when the same expression has to; carry different values simultaneously -; when multiple instances of the same function are evaluated as part of the; same full-expression without specifying the default arguments.; Even simply calling the function twice (not necessarily within the; same full-expression) may lead to program points agglutinating because; it's the same expression. There are some nasty test cases already; in temporaries.cpp (struct DefaultParam and so on). I recommend adding a; new LocationContext kind specifically to deal with this problem. It'll; also help you figure out the construction context when you evaluate the; construct-expression (though you might still need to do some additional; CFG work to get construction contexts right).; . Enhance the modeling of the standard library.; The analyzer needs a better understanding of STL in order to be more; useful on C++ codebases.; While full library modeling is not an easy task,; large gains can be achieved by supporting only a few cases:; e.g. calling .length() on an empty; std::string always yields zero.; (Difficulty: Medium). Enhance CFG to model exception-handling.; Currently exceptions are treated as ""black holes"", and exception-handling; control structures are poorly modeled in order to be conservative.; This could be improved for both C++ and Objective-C exceptions.; (Difficulty: Hard). Core Analyzer Infrastructure; ; Handle unions.; Currently in the analyzer the value of a union is always regarded as; an unknown.; This problem was; previously discussed; on the mailing list, but no solution was implemented.; (Difficulty: Medium) . Floating-point support.; Currently, the analyzer treats all floating-point values as unknown.; This project would involve adding a new SVal kind; for constant",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html:5651,Enhance,Enhance,5651,interpreter/llvm-project/clang/www/analyzer/open_projects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html,1,['Enhance'],['Enhance']
Modifiability,"g can be said about the value of ``foo[i]``,; because ``foo[0]`` may have overwritten it! *Binding to a region R with a; concrete offset invalidates any symbolic offset bindings whose concrete offset; region is a super-region **or** sub-region of R.* All we know about ``foo[i]``; is that it is somewhere within ``foo``, so changing *anything* within ``foo``; might change ``foo[i]``, and changing *all* of ``foo`` (or its base region) will; *definitely* change ``foo[i]``. This logic could be improved by using the current constraints on ``i``, at the; cost of speed. The latter case could also be improved by matching region kinds,; i.e. changing ``foo[0].a`` is unlikely to affect ``foo[i].b``, no matter what; ``i`` is. For more detail, read through ``RegionStoreManager::removeSubRegionBindings`` in; RegionStore.cpp. ObjCIvarRegions; ---------------. Objective-C instance variables require a bit of special handling. Like struct; fields, they are not base regions, and when their parent object region is; invalidated, all the instance variables must be invalidated as well. However,; they have no concrete compile-time offsets (in the modern, ""non-fragile""; runtime), and so cannot easily be represented as an offset from the start of; the object in the analyzer. Moreover, this means that invalidating a single; instance variable should *not* invalidate the rest of the object, since unlike; struct fields or array elements there is no way to perform pointer arithmetic; to access another instance variable. Consequently, although the base region of an ObjCIvarRegion is the entire; object, RegionStore offsets are computed from the start of the instance; variable. Thus it is not valid to assume that all bindings with non-symbolic; offsets start from the base region!. Region Invalidation; -------------------. Unlike binding invalidation, region invalidation occurs when the entire; contents of a region may have changed---say, because it has been passed to a; function the analyzer can mode",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:2844,variab,variables,2844,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,1,['variab'],['variables']
Modifiability,"g from the old instruction number /; operand pair to new instruction number / operand pair. Consider if we replace; a three-address add instruction with a two-address add:. ```text; %2:gr32 = ADD32rr %0, %1, debug-instr-number 1; ```. becomes. ```text; %2:gr32 = ADD32rr %0(tied-def 0), %1, debug-instr-number 2; ```. With a substitution from ""instruction number 1 operand 0"" to ""instruction number; 2 operand 0"" recorded in the `MachineFunction`. In `LiveDebugValues`,; `DBG_INSTR_REF`s will be mapped through the substitution table to find the most; recent instruction number / operand number of the value it refers to. Use `MachineFunction::substituteDebugValuesForInst` to automatically produce; substitutions between an old and new instruction. It assumes that any operand; that is a def in the old instruction is a def in the new instruction at the; same operand position. This works most of the time, for example in the example; above. If operand numbers do not line up between the old and new instruction, use; `MachineInstr::getDebugInstrNum` to acquire the instruction number for the new; instruction, and `MachineFunction::makeDebugValueSubstitution` to record the; mapping between register definitions in the old and new instructions. If some; values computed by the old instruction are no longer computed by the new; instruction, record no substitution -- `LiveDebugValues` will safely drop the; now unavailable variable value. Should your target clone instructions, much the same as the `TailDuplicator`; optimisation pass, do not attempt to preserve the instruction numbers or; record any substitutions. `MachineFunction::CloneMachineInstr` should drop the; instruction number of any cloned instruction, to avoid duplicate numbers; appearing to `LiveDebugValues`. Dealing with duplicated instructions is a; natural extension to instruction referencing that's currently unimplemented. [LiveDebugValues]: project:SourceLevelDebugging.rst#LiveDebugValues expansion of variable locations; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md:8722,variab,variable,8722,interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,2,['variab'],['variable']
Modifiability,"g histograms for each boosted classifier. Boost_DetailedMonitoring No False − Produce histograms for detailed boost-wise monitoring. Boost_Type No AdaBoost AdaBoost, Bagging, HighEdgeGauss, HighEdgeCoPara Boosting type for the classifiers. Boost_BaggedSampleFraction No 0.6 − Relative size of bagged event sample to original size of the data sample (used whenever bagging is used). Boost_MethodWeightType No ByError ByError, Average, ByROC, ByOverlap, LastMethod How to set the final weight of the boosted classifiers. Boost_RecalculateMVACut No True − Recalculate the classifier MVA Signallike cut at every boost iteration. Boost_AdaBoostBeta No 1 − The ADA boost parameter that sets the effect of every boost step on the events' weights. Boost_Transform No step step, linear, log, gauss Type of transform applied to every boosted method linear, log, step. Boost_RandomSeed No 0 − Seed for random number generator used for bagging. Configuration options for MVA method :. Configuration options reference for MVA method: RuleFit. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). GDTau No -1 − Gradient-directed (GD) path: default fit cut-off. GDTauPrec No 0.01 − GD path: precision",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:17640,Config,Configuration,17640,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['Config'],['Configuration']
Modifiability,"g name;; }. void GetCustomer(Customer *c) {; c->account_id = ...;; if (...) {; c->name = ...;; } else {; c->name = ...;; }; }; ```. We would like to refactor this code into:. ```c++; Customer GetCustomer() {; Customer c;; c.account_id = ...;; if (...) {; c.name = ...;; } else {; c.name = ...;; }; return c;; }; ```. However, in the function below the parameter `c` is not an output parameter; because its field `name` is not overwritten on every path through the function. ```c++; void GetCustomer(Customer *c) {; c->account_id = ...;; if (...) {; c->name = ...;; }; }; ```. The code also cannot read the value of the parameter before overwriting it:. ```c++; void GetCustomer(Customer *c) {; use(c->account_id);; c->name = ...;; c->account_id = ...;; }; ```. Functions that escape the pointer also block the refactoring:. ```c++; Customer* kGlobalCustomer;. void GetCustomer(Customer *c) {; c->name = ...;; c->account_id = ...;; kGlobalCustomer = c;; }; ```. To identify a candidate function for refactoring, we need to do the following:. * Find a function with a non-const pointer or reference parameter. * Find the definition of that function. * Prove that the function completely overwrites the pointee on all paths; before returning. * Prove that the function reads the pointee only after overwriting it. * Prove that the function does not persist the pointer in a data structure; that is live after the function returns. There are also requirements that all usage sites of the candidate function must; satisfy, for example, that function arguments do not alias, that users are not; taking the address of the function, and so on. Let's consider verifying usage; site conditions to be a separate static analysis problem. ### Lattice design. To analyze the function body we can use a lattice which consists of normal; states and failure states. A normal state describes program points where we are; sure that no behaviors that block the refactoring have occurred. Normal states; keep track of all",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:16140,refactor,refactoring,16140,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['refactor'],['refactoring']
Modifiability,"g of code editor and image viewer widgets; - rbrowser content is fully recovered when web-browser is reloaded; - load of widgets code only when really required (shorter startup time for RBrowser). ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ### Major JSROOT update to version 6. - update all used libraries `d3.js`, `three.js`, `MathJax.js`, openui5; - change to Promise based interface for all async methods, remove call-back arguments; - change scripts names, core scripts name now `JSRoot.core.js`; - unify function/methods naming conventions, many changes in method names; - provide central code loader via `JSROOT.require`, supporting 4 different loading engines; - many nice features and many bug fixes; see JSROOT v6 release notes. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. - a new cmake variable, `CMAKE_INSTALL_PYTHONDIR`, has been added: it allows customization of the installation directory of ROOT's python modules; - the developer build option `asserts` is introduced to enable/disable asserts via the `NDEBUG` C/CXX flag. Asserts are always enabled for `CMAKE_BUILD_TYPE=Debug` and `dev=ON`. The previous behavior of the builds set via the `CMAKE_BUILD_TYPE` variable has not changed.; - `CMAKE_CXX_STANDARD`, i.e. the C++ standard ROOT is built with, now defaults to the compiler default (or C++11 if the compiler default is older than that) rather than always defaulting to C++11. In turn this means that v6.24 is the first ROOT release for which ROOT's pre-compiled binaries are not compiled with C++11 but with the default standard in use by the default system compiler. On Ubuntu 20.04, for example, the v6.24 pre-compiled binaries are now compiled with C++14 rather than C++11 as it happened for previous ROOT versions. Also see [ROOT-10692](https://sft.its.cern.ch/jira/browse/ROOT-10692). The following builtins have been updated:. - VecCore 0.7.0. ## PyROOT. - Deprecate `TTree.AsMatri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:27957,variab,variable,27957,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['variab'],['variable']
Modifiability,"g standard input or a file that doesn't have the; extension corresponding to its language, ``-assume-filename=`` option can be; used to override the file name :program:`clang-format` uses to detect the; language. An example of a configuration file for multiple languages:. .. code-block:: yaml. ---; # We'll use defaults from the LLVM style, but with 4 columns indentation.; BasedOnStyle: LLVM; IndentWidth: 4; ---; Language: Cpp; # Force pointers to the type for C++.; DerivePointerAlignment: false; PointerAlignment: Left; ---; Language: JavaScript; # Use 100 columns for JS.; ColumnLimit: 100; ---; Language: Proto; # Don't format .proto files.; DisableFormat: true; ---; Language: CSharp; # Use 100 columns for C#.; ColumnLimit: 100; ... An easy way to get a valid ``.clang-format`` file containing all configuration; options of a certain predefined style is:. .. code-block:: console. clang-format -style=llvm -dump-config > .clang-format. When specifying configuration in the ``-style=`` option, the same configuration; is applied for all input files. The format of the configuration is:. .. code-block:: console. -style='{key1: value1, key2: value2, ...}'. Disabling Formatting on a Piece of Code; =======================================. Clang-format understands also special comments that switch formatting in a; delimited range. The code between a comment ``// clang-format off`` or; ``/* clang-format off */`` up to a comment ``// clang-format on`` or; ``/* clang-format on */`` will not be formatted. The comments themselves will be; formatted (aligned) normally. Also, a colon (``:``) and additional text may; follow ``// clang-format off`` or ``// clang-format on`` to explain why; clang-format is turned off or back on. .. code-block:: c++. int formatted_code;; // clang-format off; void unformatted_code ;; // clang-format on; void formatted_code_again;. Configuring Style in Code; =========================. When using ``clang::format::reformat(...)`` functions, the format is specifi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:3523,config,configuration,3523,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,2,['config'],['configuration']
Modifiability,"g the analysis; state. The analyzer engine talks to them via a visitor interface.; For example, the PreVisitCallExpr() method is called by ExprEngine; to tell the Checker that we are about to analyze a CallExpr, and the; checker is asked to check for any preconditions that might not be; satisfied. The checker can do nothing, or it can generate a new; ProgramState and ExplodedNode which contains updated checker state. If it; finds a bug, it can tell the BugReporter object about the bug,; providing it an ExplodedNode which is the last node in the path that; triggered the problem. = Notes about C++ =. Since now constructors are seen before the variable that is constructed; in the CFG, we create a temporary object as the destination region that; is constructed into. See ExprEngine::VisitCXXConstructExpr(). In ExprEngine::processCallExit(), we always bind the object region to the; evaluated CXXConstructExpr. Then in VisitDeclStmt(), we compute the; corresponding lazy compound value if the variable is not a reference, and; bind the variable region to the lazy compound value. If the variable; is a reference, just use the object region as the initializer value. Before entering a C++ method (or ctor/dtor), the 'this' region is bound; to the object region. In ctors, we synthesize 'this' region with; CXXRecordDecl*, which means we do not use type qualifiers. In methods, we; synthesize 'this' region with CXXMethodDecl*, which has getThisType(); taking type qualifiers into account. It does not matter we use qualified; 'this' region in one method and unqualified 'this' region in another; method, because we only need to ensure the 'this' region is consistent; when we synthesize it and create it directly from CXXThisExpr in a single; method call. = Working on the Analyzer =. If you are interested in bringing up support for C++ expressions, the; best place to look is the visitation logic in ExprEngine, which; handles the simulation of individual expressions. There are plenty of; exam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt:4174,variab,variable,4174,interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,2,['variab'],['variable']
Modifiability,"g the critical section. A **`semaphore`** is a synchronization mechanism that starts out; initialized to some positive value. A thread may ask to wait on a; semaphore in which case the thread blocks until the value of the; semaphore is positive. At that time the semaphore count is decremented; and the thread continues. When a thread releases semaphore, the; semaphore count is incremented. Counting semaphores are useful for; coordinating access to a limited pool of some resource. **`Readers/Writer Lock`** - a multiple-reader, single-writer lock is one; that allows simultaneous read access by many threads while restricting; write access to only one thread at a time. When any thread holds the; lock for reading, other threads can also acquire the lock reading. If; one thread holds the lock for writing, or is waiting to acquire the lock; for writing, other threads must wait to acquire the lock for either; reading or writing. Use a **`condition variable`** in conjunction with a mutex lock to; automatically block threads until a particular condition is true. **`Multithread Safe Levels`** - a possible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this; definition, requires the user of the library only to be familiar; with the semantic content of the objects in use. Locking access to; objects that are being shared due to extra-semantic details of; implementation (for example, copy-on-write) should remain the; responsibility of the library. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:23230,variab,variable,23230,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['variab'],['variable']
Modifiability,"g the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file_advanced.C; ```. The `Branch()` function requires a pointer to a variable and a; definition of the variable type. The following table lists some of the possible; values.; Please note that ROOT is not checking the input and mistakes are likely; to result in serious problems. This holds especially if values are read; as another type than they have been written, e.g. when storing a; variable as float and reading it as double. List of variable types that can be used to define the type of a branch in ROOT:. type size C++ identifier; ------------------ -------- --------------- ------------; signed integer 32 bit int I; 64 bit long L; unsigned integer 32 bit unsigned int i; 64 bit unsigned long l; floating point 32 bit float F; 64 bit double D; boolean - bool O. ### Processing N-tuples Spanning over Several Files ###. Usually n-tuples or trees span over many files and it would be difficult; to add them manually. ROOT thus kindly provides a helper class in the; form of `TChain`. Its usage is shown in the following macro which is; very similar to the previous example. The constructor of a `TChain`; takes the name of the `TTree` (or `TNuple`) as an argument. The files; are added with the function `Add(fileName)`, where one can also use; wild-cards as shown in the example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_with_chain.C; ```. ### *For the advanced user:* Processing trees with a selector script ###. Another very general and powerful way of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:5376,variab,variable,5376,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['variab'],['variable']
Modifiability,"g to select a directory to INSTALL to; once compiling is complete, although installation is not mandatory for; using LLVM. Another important option is ``LLVM_TARGETS_TO_BUILD``,; which controls the LLVM target architectures that are included on the; build.; * CMake generates project files for all build types. To select a specific; build type, use the Configuration manager from the VS IDE or the; ``/property:Configuration`` command line option when using MSBuild.; * By default, the Visual Studio project files generated by CMake use the; 32-bit toolset. If you are developing on a 64-bit version of Windows and; want to use the 64-bit toolset, pass the ``-Thost=x64`` flag when; generating the Visual Studio solution. This requires CMake 3.8.0 or later. 13. Start Visual Studio and select configuration:. In the directory you created the project files will have an ``llvm.sln``; file, just double-click on that to open Visual Studio. The default Visual; Studio configuration is **Debug** which is slow and generates a huge amount; of debug information on disk. For now, we recommend selecting **Release**; configuration for the LLVM project which will build the fastest or; **RelWithDebInfo** which is also several time larger than Release.; Another technique is to build all of LLVM in Release mode and change; compiler flags, disabling optimization and enabling debug information, only; for specific libraries or source files you actually need to debug. 14. Test LLVM in Visual Studio:. You can run LLVM tests by merely building the project ""check-all"". The test; results will be shown in the VS output window. Once the build succeeds, you; have verified a working LLVM development environment!. You should not see any unexpected failures, but will see many unsupported; tests and expected failures:. ::. 114>Testing Time: 1124.66s; 114> Skipped : 39; 114> Unsupported : 21649; 114> Passed : 51615; 114> Expectedly Failed: 93; ========== Build: 114 succeeded, 0 failed, 321 up-to-date, 0 skipped",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst:6932,config,configuration,6932,interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,1,['config'],['configuration']
Modifiability,"g to the caller""; Unknown. 2792; DR; Clean up specification of noexcept operator; Unknown. 2793; DR; Block-scope declaration conflicting with parameter name; Unknown. 2794; open; Uniqueness of lambdas in alias templates; Not resolved. 2795; DR; Overlapping empty subobjects with different cv-qualification; Unknown. 2796; DR; Function pointer conversions for relational operators; Unknown. 2797; open; Meaning of ""corresponds"" for rewritten operator candidates; Not resolved. 2798; DR; Manifestly constant evaluation of the static_assert message; Clang 17. 2799; drafting; Inheriting default constructors; Not resolved. 2800; review; Instantiating constexpr variables for potential constant evaluation; Not resolved. 2801; DR; Reference binding with reference-related types; Unknown. 2802; open; Constrained auto and redeclaration with non-abbreviated syntax; Not resolved. 2803; tentatively ready; Overload resolution for reference binding of similar types; Unknown. 2804; open; Lookup for determining rewrite targets; Not resolved. 2805; open; Underspecified selection of deallocation function; Not resolved. 2806; DR; Make a type-requirement a type-only context; Unknown. 2807; DR; Destructors declared consteval; Unknown. 2808; review; Explicit specialization of defaulted special member function; Not resolved. 2809; tentatively ready; An implicit definition does not redeclare a function; Unknown. 2810; tentatively ready; Requiring the absence of diagnostics for templates; Unknown. 2811; tentatively ready; Clarify ""use"" of main; Unknown. 2812; open; Allocation with explicit alignment; Not resolved. 2813; review; Class member access with prvalues; Not resolved. 2814; review; Alignment requirement of incomplete class type; Not resolved. 2815; open; Overload resolution for references/pointers to noexcept functions; Not resolved. 2816; review; Unclear phrasing ""may assume ... eventually""; Not resolved. 2817; open; sizeof(abstract class) is underspecified; Not resolved. 2818; review; Use",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:194566,rewrite,rewrite,194566,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['rewrite'],['rewrite']
Modifiability,"g transparent volumes; For different geometries different methods can be applied. In any case, all opaque volumes rendered first. ## Reading ROOT files from other servers. In principle, one could open any ROOT file placed in the web, providing the full URL to it like:. - <https://jsroot.gsi.de/latest/?file=https://root.cern/js/files/hsimple.root&item=hpx>. But one should be aware of [Same-origin policy](https://en.wikipedia.org/wiki/Same-origin_policy),; when the browser blocks requests to files from domains other than current web page.; To enable CORS on Apache web server, hosting ROOT files, one should add following lines to `.htaccess` file:. <IfModule mod_headers.c>; <FilesMatch ""\.root"">; Header set Access-Control-Allow-Origin ""*""; Header set Access-Control-Allow-Headers ""range""; Header set Access-Control-Expose-Headers ""content-range,content-length,accept-ranges""; Header set Access-Control-Allow-Methods ""GET""; </FilesMatch>; </IfModule>. More details about configuring of CORS headers can be found [here](https://developer.mozilla.org/en/http_access_control). Alternative - enable CORS requests in the browser. It can be easily done with [CORS Everywhere plugin](https://addons.mozilla.org/de/firefox/addon/cors-everywhere/) for the Firefox browser or [Allow CORS plugin](https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi?hl=en) for the Chrome browser. Next solution - install JSROOT on the server hosting ROOT files. In such configuration JSROOT does not issue CORS requests, therefore server and browsers can be used with their default settings. A simplified variant of such solution - copy only the top index.htm file from JSROOT package and specify the full path to `modules/gui.mjs` script like:. ```javascript; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; ```. In the main `<div>` element one can specify many custom parameters like one do it in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:28213,config,configuring,28213,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['config'],['configuring']
Modifiability,"g will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31301,config,config,31301,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['config']
Modifiability,"g with CTU specific extra arguments:. .. code-block:: bash. $ pwd; /path/to/your/project; $ clang++ --analyze \; -Xclang -analyzer-config -Xclang experimental-enable-naive-ctu-analysis=true \; -Xclang -analyzer-config -Xclang ctu-dir=. \; -Xclang -analyzer-config -Xclang ctu-invocation-list=invocations.yaml \; -Xclang -analyzer-output=plist-multi-file \; main.cpp; main.cpp:5:12: warning: Division by zero; return 3 / foo();; ~~^~~~~~~; 1 warning generated.; $ # The plist file with the result is generated.; $ ls -F; compile_commands.json externalDefMap.txt foo.cpp main.cpp main.plist; $. This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use; `CodeChecker` or `scan-build-py`. Automated CTU Analysis with CodeChecker; #######################################; The `CodeChecker <https://github.com/Ericsson/codechecker>`_ project fully supports automated CTU analysis with Clang.; Once we have set up the `PATH` environment variable and we activated the python `venv` then it is all it takes:. .. code-block:: bash. $ CodeChecker analyze --ctu --ctu-ast-loading-mode on-demand compile_commands.json -o reports; $ ls -F; compile_commands.json foo.cpp main.cpp reports/; $ tree reports; reports; ├── compile_cmd.json; ├── compiler_info.json; ├── foo.cpp_53f6fbf7ab7ec9931301524b551959e2.plist; ├── main.cpp_23db3d8df52ff0812e6e5a03071c8337.plist; ├── metadata.json; └── unique_compile_commands.json. 0 directories, 6 files; $. The `plist` files contain the results of the analysis, which may be viewed with the regular analysis tools.; E.g. one may use `CodeChecker parse` to view the results in command line:. .. code-block:: bash. $ CodeChecker parse reports; [HIGH] /home/egbomrt/ctu_mini_raw_project/main.cpp:5:12: Division by zero [core.DivideZero]; return 3 / foo();; ^. Found 1 defect(s) in main.cpp. ----==== Summary ====----; -----------------------; Filename | Report count; -----------------------; main.cpp | 1; --------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:10241,variab,variable,10241,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,1,['variab'],['variable']
Modifiability,"g"" which block; control came from. The Phi operation takes on the value corresponding to; the input control block. In this case, if control comes in from the; ""then"" block, it gets the value of ""calltmp"". If control comes from the; ""else"" block, it gets the value of ""calltmp1"". At this point, you are probably starting to think ""Oh no! This means my; simple and elegant front-end will have to start generating SSA form in; order to use LLVM!"". Fortunately, this is not the case, and we strongly; advise *not* implementing an SSA construction algorithm in your; front-end unless there is an amazingly good reason to do so. In; practice, there are two sorts of values that float around in code; written for your average imperative programming language that might need; Phi nodes:. #. Code that involves user variables: ``x = 1; x = x + 1;``; #. Values that are implicit in the structure of your AST, such as the; Phi node in this case. In `Chapter 7 <LangImpl07.html>`_ of this tutorial (""mutable variables""),; we'll talk about #1 in depth. For now, just believe me that you don't; need SSA construction to handle this case. For #2, you have the choice; of using the techniques that we will describe for #1, or you can insert; Phi nodes directly, if convenient. In this case, it is really; easy to generate the Phi node, so we choose to do it directly. Okay, enough of the motivation and overview, let's generate code!. Code Generation for If/Then/Else; --------------------------------. In order to generate code for this, we implement the ``codegen`` method; for ``IfExprAST``:. .. code-block:: c++. Value *IfExprAST::codegen() {; Value *CondV = Cond->codegen();; if (!CondV); return nullptr;. // Convert condition to a bool by comparing non-equal to 0.0.; CondV = Builder->CreateFCmpONE(; CondV, ConstantFP::get(*TheContext, APFloat(0.0)), ""ifcond"");. This code is straightforward and similar to what we saw before. We emit; the expression for the condition, then compare that value to zero to get;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:8695,variab,variables,8695,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['variab'],['variables']
Modifiability,"g*`` *to be used instead of*; ``DW_OP_breg* 0``\ *.*. .. note::. This rule could be removed and require the producer to create the required; location description directly using ``DW_OP_call_frame_cfa``,; ``DW_OP_breg*``, or ``DW_OP_LLVM_aspace_bregx``. This would also then; allow a target to implement the call frames within a large register. Otherwise, the DWARF is ill-formed if SL is not a memory location; description in any of the target architecture specific address spaces. The resulting L is the *frame base* for the subprogram or entry point. *Typically, E will use the* ``DW_OP_call_frame_cfa`` *operation or be a; stack pointer register plus or minus some offset.*. *The frame base for a subprogram is typically an address relative to the; first unit of storage allocated for the subprogram's stack frame. The*; ``DW_AT_frame_base`` *attribute can be used in several ways:*. 1. *In subprograms that need location lists to locate local variables, the*; ``DW_AT_frame_base`` *can hold the needed location list, while all; variables' location descriptions can be simpler ones involving the frame; base.*. 2. *It can be used in resolving ""up-level"" addressing within; nested routines. (See also* ``DW_AT_static_link``\ *, below)*. *Some languages support nested subroutines. In such languages, it is; possible to reference the local variables of an outer subroutine from within; an inner subroutine. The* ``DW_AT_static_link`` *and* ``DW_AT_frame_base``; *attributes allow debuggers to support this same kind of referencing.*. 3. If a ``DW_TAG_subprogram`` or ``DW_TAG_entry_point`` debugger information; entry is lexically nested, it may have a ``DW_AT_static_link`` attribute,; whose value is a DWARF expression E. The result of the attribute is obtained by evaluating E with a context that; has a result kind of a location description, an unspecified object, the; compilation unit that contains E, an empty initial stack, and other context; elements corresponding to the source language th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:158909,variab,variables,158909,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,2,['variab'],['variables']
Modifiability,"g-format 5` :ref:`¶ <BreakConstructorInitializers>`; The break constructor initializers style to use. Possible values:. * ``BCIS_BeforeColon`` (in configuration: ``BeforeColon``); Break constructor initializers before the colon and after the commas. .. code-block:: c++. Constructor(); : initializer1(),; initializer2(). * ``BCIS_BeforeComma`` (in configuration: ``BeforeComma``); Break constructor initializers before the colon and commas, and align; the commas with the colon. .. code-block:: c++. Constructor(); : initializer1(); , initializer2(). * ``BCIS_AfterColon`` (in configuration: ``AfterColon``); Break constructor initializers after the colon and commas. .. code-block:: c++. Constructor() :; initializer1(),; initializer2(). .. _BreakInheritanceList:. **BreakInheritanceList** (``BreakInheritanceListStyle``) :versionbadge:`clang-format 7` :ref:`¶ <BreakInheritanceList>`; The inheritance list style to use. Possible values:. * ``BILS_BeforeColon`` (in configuration: ``BeforeColon``); Break inheritance list before the colon and after the commas. .. code-block:: c++. class Foo; : Base1,; Base2; {};. * ``BILS_BeforeComma`` (in configuration: ``BeforeComma``); Break inheritance list before the colon and commas, and align; the commas with the colon. .. code-block:: c++. class Foo; : Base1; , Base2; {};. * ``BILS_AfterColon`` (in configuration: ``AfterColon``); Break inheritance list after the colon and commas. .. code-block:: c++. class Foo :; Base1,; Base2; {};. * ``BILS_AfterComma`` (in configuration: ``AfterComma``); Break inheritance list only after the commas. .. code-block:: c++. class Foo : Base1,; Base2; {};. .. _BreakStringLiterals:. **BreakStringLiterals** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <BreakStringLiterals>`; Allow breaking string literals when formatting. In C, C++, and Objective-C:. .. code-block:: c++. true:; const char* x = ""veryVeryVeryVeryVeryVe""; ""ryVeryVeryVeryVeryVery""; ""VeryLongString"";. false:; const char* x =; ""veryVeryVery",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:55169,config,configuration,55169,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,2,"['config', 'inherit']","['configuration', 'inheritance']"
Modifiability,"g-llvm/build/; ninja loop-convert; vim ~/test-files/simple-loops.cc; bin/loop-convert ~/test-files/simple-loops.cc. Step 3.5: More Complicated Matchers; ===================================. Our simple matcher is capable of discovering for loops, but we would; still need to filter out many more ourselves. We can do a good portion; of the remaining work with some cleverly chosen matchers, but first we; need to decide exactly which properties we want to allow. How can we characterize for loops over arrays which would be eligible; for translation to range-based syntax? Range based loops over arrays of; size ``N`` that:. - start at index ``0``; - iterate consecutively; - end at index ``N-1``. We already check for (1), so all we need to add is a check to the loop's; condition to ensure that the loop's index variable is compared against; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same variable declared in the; init portion. Unfortunately, such a matcher is impossible to write. Matchers contain; no logic for comparing two arbitrary AST nodes and determining whether; or not they are equal, so the best we can do is matching more than we; would like to allow, and punting extra comparisons to the callback. In any case, we can start building this sub-matcher. We can require that; the increment step be a unary increment like this:. .. code-block:: c++. hasIncrement(unaryOperator(hasOperatorName(""++""))). Specifying what is incremented introduces another quirk of Clang's AST:; Usages of variables are represented as ``DeclRefExpr``'s (""declaration; reference expressions"") because they are expressions which refer to; variable declarations. To find a ``unaryOperator`` that refers to a; specific declaration, we can simply add a second condition to it:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr())",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:11397,variab,variable,11397,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['variab'],['variable']
Modifiability,"g. Let us go through it in detail:. Lines *7-18* define the necessary functions in `C++` code, split into; three separate functions, as suggested by the problem considered. The; full interference pattern is given by the product of a function; depending on the ratio of the width and distance of the slits, and a; second one depending on the number of slits. More important for us here; is the definition of the interface of these functions to make them; usable for the ROOT class `TF1`: the first argument is the pointer to; *x*, the second one points to the array of parameters. The main program starts at line 21 with the definition of a function; `slits()` of type `void`. After asking for user input, a ROOT function; is defined using the C-type function given in the beginning. We can now; use all methods of the `TF1` class to control the behaviour of our; function -- nice, isn't it ?. If you like, you can easily extend the example to also plot the; interference pattern of a single slit, using function `double single`,; or of a grid with narrow slits, function `double nslit0`, in `TF1`; instances. Here, we used a macro, some sort of lightweight program, that the; interpreter distributed with ROOT, Cling, is able to execute. This is a; rather extraordinary situation, since `C++` is not natively an interpreted; language! There is much more to say: chapter is indeed dedicated to; macros. ## Controlling ROOT ##. One more remark at this point: as every command you type into ROOT is; usually interpreted by Cling, an ""escape character"" is needed to pass; commands to ROOT directly. This character is the dot at the beginning of; a line:. ``` {.cpp}; root [1] .<command>; ```. This is a selection of the most common commands. - **quit root**, simply type `.q` or `.quit` or `.exit`. - obtain the full **list of commands**, use `.?` or `.help`. - **access the shell** of the operating system, type `.!<OS_command>`;; try, e.g. `.!ls` or `.!pwd`. - **execute a macro**, enter `.x <file_name",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:7063,extend,extend,7063,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['extend'],['extend']
Modifiability,"g. To be specific, it is preferred to write the code like; this:. .. code-block:: c++. assert(V.size() > 42 && ""Vector smaller than it should be"");. bool NewToSet = Myset.insert(Value); (void)NewToSet;; assert(NewToSet && ""The value shouldn't be in the set yet"");. Do Not Use ``using namespace std``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In LLVM, we prefer to explicitly prefix all identifiers from the standard; namespace with an ""``std::``"" prefix, rather than rely on ""``using namespace; std;``"". In header files, adding a ``'using namespace XXX'`` directive pollutes the; namespace of any source file that ``#include``\s the header, creating; maintenance issues. In implementation files (e.g. ``.cpp`` files), the rule is more of a stylistic; rule, but is still important. Basically, using explicit namespace prefixes; makes the code **clearer**, because it is immediately obvious what facilities; are being used and where they are coming from. And **more portable**, because; namespace clashes cannot occur between LLVM code and other namespaces. The; portability rule is important because different standard library implementations; expose different symbols (potentially ones they shouldn't), and future revisions; to the C++ standard will add more symbols to the ``std`` namespace. As such, we; never use ``'using namespace std;'`` in LLVM. The exception to the general rule (i.e. it's not an exception for the ``std``; namespace) is for implementation files. For example, all of the code in the; LLVM project implements code that lives in the 'llvm' namespace. As such, it is; ok, and actually clearer, for the ``.cpp`` files to have a ``'using namespace; llvm;'`` directive at the top, after the ``#include``\s. This reduces; indentation in the body of the file for source editors that indent based on; braces, and keeps the conceptual context cleaner. The general form of this rule; is that any ``.cpp`` file that implements code in any namespace may use that; namespace (and its parents'),",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:49452,portab,portable,49452,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['portab'],['portable']
Modifiability,"g., member functions with ``&`` or ``&&``; applied to ``*this``) is enabled. C++11 range-based ``for`` loop; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_range_for)`` or ``__has_extension(cxx_range_for)`` to; determine if support for the range-based for loop is enabled. C++11 raw string literals; ^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_raw_string_literals)`` to determine if support for raw; string literals (e.g., ``R""x(foo\bar)x""``) is enabled. C++11 rvalue references; ^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_rvalue_references)`` or; ``__has_extension(cxx_rvalue_references)`` to determine if support for rvalue; references is enabled. C++11 ``static_assert()``; ^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_static_assert)`` or; ``__has_extension(cxx_static_assert)`` to determine if support for compile-time; assertions using ``static_assert`` is enabled. C++11 ``thread_local``; ^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_thread_local)`` to determine if support for; ``thread_local`` variables is enabled. C++11 type inference; ^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_auto_type)`` or ``__has_extension(cxx_auto_type)`` to; determine C++11 type inference is supported using the ``auto`` specifier. If; this is disabled, ``auto`` will instead be a storage class specifier, as in C; or C++98. C++11 strongly typed enumerations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_strong_enums)`` or; ``__has_extension(cxx_strong_enums)`` to determine if support for strongly; typed, scoped enumerations is enabled. C++11 trailing return type; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_trailing_return)`` or; ``__has_extension(cxx_trailing_return)`` to determine if support for the; alternate function declaration syntax with trailing return type is enabled. C++11 Unicode string literals; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_unicode_literals)`` to determine if support for Unicode; string literals is enabled. C+",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:46581,variab,variables,46581,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['variab'],['variables']
Modifiability,"g.C for details; RooDataHist - Add new named argument constructor that can collate multiple ROOT THn histgrams into a n+1 dimensional RooDataHist; RooDataSet - Add new named argument constructor that can collate multiple input RooDataSets into a n+1 dimensional RooDataSet.Add createHistogram() method for simplified plotting; RooFitResult - Add new method correlationHist() that returns a labeled TH2 with the contents of the fit correlation matrix; RooFFTConvPdf - Automatically put sampling windows of 'resolution model' p.d.f. centered around zero, even if fit range of convolution observable does not bracket zero. Improve internal efficiency; RooAbsData - Add ability to plot efficiency distribution with correct binomial errors given a RooRealVar and a RooCategory category observable encoding distribution and accept/reject state respectively. See rf701_efficiencyfit.C for details ; RooAbsPdf - Included extended ML term by default in fit if p.d.f is extendable. You can still use Extended() to override default behavior. Do not run MINOS by default anymore if no fit options are provided.; RooProfileLL - Add option to always start minimization from global minimimum (takes more time, but improves reproducibility). Can now profile multi-core paralellized likelihoods as well.; RooRealSumPdf - Enable plotting of component p.d.f.s using same scheme as RooAddPdf, i.e. just use the Components() specified in plotOn().; RooExpensiveObjectCache - New cache manager for sharing and storing of expensive components cached by operator p.d.f.s ; RooMCStudy - Add Silence() argument to constructor to request minimal verbosity during running; RooMinuit - Improve contour() method to return RooPlots rather than drawing TGraphs straight on a canvas; RooWorkspace - Add private expensive object cache to workspace; RooBinningCategory - New real-to-category function that maps values of input RooRealVar to categories with labels that correspond to bins of input RooRealVar. See rf405_realtocatfuncs.C ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:8310,Extend,Extended,8310,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['Extend'],['Extended']
Modifiability,g.cpp; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.h; clang-tools-extra/clangd/index/remote/monitor/Monitor.cpp; clang-tools-extra/clangd/index/remote/server/Server.cpp; clang-tools-extra/clangd/index/remote/unimplemented/UnimplementedClient.cpp; clang-tools-extra/clangd/indexer/IndexerMain.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.h; clang-tools-extra/clangd/refactor/Rename.h; clang-tools-extra/clangd/refactor/Tweak.cpp; clang-tools-extra/clangd/refactor/Tweak.h; clang-tools-extra/clangd/refactor/tweaks/AddUsing.cpp; clang-tools-extra/clangd/refactor/tweaks/AnnotateHighlightings.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineInline.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineOutline.cpp; clang-tools-extra/clangd/refactor/tweaks/DumpAST.cpp; clang-tools-extra/clangd/refactor/tweaks/ExpandMacro.cpp; clang-tools-extra/clangd/refactor/tweaks/ExtractFunction.cpp; clang-tools-extra/clangd/refactor/tweaks/ObjCLocalizeStringLiteral.cpp; clang-tools-extra/clangd/refactor/tweaks/RemoveUsingNamespace.cpp; clang-tools-extra/clangd/refactor/tweaks/SwapIfBranches.cpp; clang-tools-extra/clangd/support/Cancellation.cpp; clang-tools-extra/clangd/support/Cancellation.h; clang-tools-extra/clangd/support/Context.cpp; clang-tools-extra/clangd/support/Context.h; clang-tools-extra/clangd/support/FileCache.cpp; clang-tools-extra/clangd/support/FileCache.h; clang-tools-extra/clangd/support/Function.h; clang-tools-extra/clangd/support/Logger.cpp; clang-tools-extra/clangd/support/Markup.cpp; clang-tools-extra/clangd/support/Markup.h; clang-tools-extra/clangd/support/MemoryTree.cpp; clang-tools-extra/clangd/support/MemoryTree.h; clang-tools-extra/clangd/support/Path.cpp; clang-tools-extra/clangd/support/Path.h; clang-tools-extra/clangd/support/Shutdown.cpp; clang-tools-extra/clangd/support/Shutdown.h; clang-tools-extra/clangd/support/ThreadCrashReporter.cpp; clang-tools-extra/clangd/support/Thread,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:80679,refactor,refactor,80679,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,g/Syntax/Pseudo/LRGraph.cpp; clang/lib/Tooling/Syntax/Pseudo/LRTable.cpp; clang/lib/Tooling/Syntax/Pseudo/LRTableBuild.cpp; clang/lib/Tooling/Syntax/Pseudo/Preprocess.cpp; clang/lib/Tooling/Syntax/Pseudo/Token.cpp; clang/lib/Tooling/Transformer/Parsing.cpp; clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp; clang/lib/Tooling/Transformer/Stencil.cpp; clang/lib/Tooling/Transformer/Transformer.cpp; clang/tools/amdgpu-arch/AMDGPUArch.cpp; clang/tools/apinotes-test/APINotesTest.cpp; clang/tools/clang-format/ClangFormat.cpp; clang/tools/clang-fuzzer/ClangFuzzer.cpp; clang/tools/clang-fuzzer/DummyClangFuzzer.cpp; clang/tools/clang-fuzzer/ExampleClangLLVMProtoFuzzer.cpp; clang/tools/clang-fuzzer/ExampleClangLoopProtoFuzzer.cpp; clang/tools/clang-fuzzer/handle-llvm/handle_llvm.h; clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp; clang/tools/clang-linker-wrapper/OffloadWrapper.cpp; clang/tools/clang-pseudo/ClangPseudo.cpp; clang/tools/clang-refactor/ClangRefactor.cpp; clang/tools/clang-refactor/TestSupport.cpp; clang/tools/clang-refactor/TestSupport.h; clang/tools/clang-refactor/ToolRefactoringResultConsumer.h; clang/tools/clang-rename/ClangRename.cpp; clang/tools/clang-repl/ClangRepl.cpp; clang/tools/clang-scan-deps/ClangScanDeps.cpp; clang/tools/clang-shlib/clang-shlib.cpp; clang/tools/driver/cc1gen_reproducer_main.cpp; clang/tools/libclang/CIndex.cpp; clang/tools/libclang/CIndexUSRs.cpp; clang/tools/libclang/CursorVisitor.h; clang/tools/libclang/CXCursor.cpp; clang/tools/libclang/CXCursor.h; clang/tools/scan-build-py/tests/functional/src/include/clean-one.h; clang/unittests/Analysis/CFGBuildResult.h; clang/unittests/Analysis/MacroExpansionContextTest.cpp; clang/unittests/Analysis/FlowSensitive/DataflowAnalysisContextTest.cpp; clang/unittests/Analysis/FlowSensitive/DataflowEnvironmentTest.cpp; clang/unittests/Analysis/FlowSensitive/MapLatticeTest.cpp; clang/unittests/Analysis/FlowSensitive/MatchSwitchTest.cpp; clang/unittests/Analysis/FlowSensitive/MultiVarConstan,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:28029,refactor,refactor,28029,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,g/lib/Semantics/check-purity.cpp; flang/lib/Semantics/check-purity.h; flang/lib/Semantics/check-return.cpp; flang/lib/Semantics/check-return.h; flang/lib/Semantics/check-select-rank.cpp; flang/lib/Semantics/check-select-rank.h; flang/lib/Semantics/check-select-type.cpp; flang/lib/Semantics/check-select-type.h; flang/lib/Semantics/check-stop.cpp; flang/lib/Semantics/check-stop.h; flang/lib/Semantics/compute-offsets.cpp; flang/lib/Semantics/compute-offsets.h; flang/lib/Semantics/data-to-inits.cpp; flang/lib/Semantics/mod-file.h; flang/lib/Semantics/pointer-assignment.cpp; flang/lib/Semantics/pointer-assignment.h; flang/lib/Semantics/program-tree.cpp; flang/lib/Semantics/program-tree.h; flang/lib/Semantics/resolve-directives.cpp; flang/lib/Semantics/resolve-directives.h; flang/lib/Semantics/resolve-labels.cpp; flang/lib/Semantics/resolve-labels.h; flang/lib/Semantics/resolve-names-utils.cpp; flang/lib/Semantics/resolve-names-utils.h; flang/lib/Semantics/resolve-names.h; flang/lib/Semantics/rewrite-parse-tree.cpp; flang/lib/Semantics/rewrite-parse-tree.h; flang/lib/Semantics/runtime-type-info.cpp; flang/lib/Semantics/scope.cpp; flang/lib/Semantics/semantics.cpp; flang/lib/Semantics/tools.cpp; flang/lib/Semantics/unparse-with-symbols.cpp; flang/module/omp_lib.h; flang/runtime/allocatable.cpp; flang/runtime/assign.cpp; flang/runtime/buffer.cpp; flang/runtime/buffer.h; flang/runtime/character.cpp; flang/runtime/command.cpp; flang/runtime/complex-reduction.h; flang/runtime/connection.cpp; flang/runtime/connection.h; flang/runtime/copy.cpp; flang/runtime/copy.h; flang/runtime/derived-api.cpp; flang/runtime/derived.h; flang/runtime/descriptor-io.cpp; flang/runtime/descriptor-io.h; flang/runtime/descriptor.cpp; flang/runtime/dot-product.cpp; flang/runtime/edit-input.cpp; flang/runtime/edit-input.h; flang/runtime/edit-output.cpp; flang/runtime/edit-output.h; flang/runtime/environment.cpp; flang/runtime/environment.h; flang/runtime/extensions.cpp; flang/runtime/extrema.cpp; flan,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:123879,rewrite,rewrite-parse-tree,123879,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['rewrite'],['rewrite-parse-tree']
Modifiability,"g/posts/2020-11-30-interactive-cpp-with-cling/>`_; - *Vassil Vassilev* 2020 The LLVM Project Blog; - This blog page briefly discusses the concept of interactive C++ by presenting Cling’s main features, such as wrapper functions, entity redefinition, error recovery. ; * - `Using the Cling C++ Interpreter on the Bela Platform <https://gist.github.com/jarmitage/6e411ae8746c04d6ecbee1cbc1ebdcd4>`_; - Jack Armitage 2019; - Cling has been installed on a BeagleBoard to bring live coding to the Bela interactive audio platform.; * - `Implementation of GlobalModuleIndex in ROOT and Cling <https://indico.cern.ch/event/840376/contributions/3525646/attachments/1895398/3127159/GSoC_Presentation__GMI.pdf>`_; - *Arpitha Raghunandan* 2012 Google Summer of Code GSoC; - GlobalModuleIndex can be used for improving ROOT’s and Cling’s performance ; * - `Example project using cling as library <https://github.com/root-project/cling/tree/master/tools/demo>`_; - *Axel Naumann* 2016 GitHub; - This video showcases how to use Cling as a library, and shows how to set up a simple CMake configuration that uses Cling.; * - `Cling C++ interpreter testdrive <https://www.youtube.com/watch?v=1IGTHusaJ18>`_; - *Mika* 2015 Youtube; - In this tutorial, a developer tries Cling for the first time by uploading a few simple C++ user-cases onto Cling, involving also the loading of external files; * - `Building an Order Book in C++ <https://www.youtube.com/watch?v=fxN4xEZvrxI>`_; - *Dimitri Nesteruk* 2015 Youtube; - This demo shows how to build a simple order book using C++, CLion, Google Test and, of course, Cling. ; * - `Cling C++ interpreter testdrive <https://www.youtube.com/watch?v=1IGTHusaJ18>`_; - Dimitri Nesteruk 2015 Youtube; - This tutorial describes Cling’s general features. You will learn how to start Cling on Ubuntu, how to write a simple expression (N=5, N++) and how to define a Class for calculating body mass index. ; * - `Cling Interactive OpenGL Demo <https://www.youtube.com/watch?v=eoIuqLNvzFs>",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst:4594,config,configuration,4594,interpreter/cling/docs/chapters/references.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst,1,['config'],['configuration']
Modifiability,g; - `5`; - `5`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Inclusions; - `3`; - `3`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Refactoring; - `15`; - `12`; - `3`; - :part:`80%`; * - clang/include/clang/Tooling/Refactoring/Extract; - `2`; - `2`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Refactoring/Rename; - `6`; - `5`; - `1`; - :part:`83%`; * - clang/include/clang/Tooling/Syntax; - `5`; - `5`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Syntax/Pseudo; - `5`; - `5`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Transformer; - `8`; - `6`; - `2`; - :part:`75%`; * - clang/include/clang-c; - `10`; - `3`; - `7`; - :part:`30%`; * - clang/INPUTS; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/lib/Analysis; - `28`; - `3`; - `25`; - :part:`10%`; * - clang/lib/Analysis/FlowSensitive; - `7`; - `7`; - `0`; - :good:`100%`; * - clang/lib/Analysis/plugins/CheckerDependencyHandling; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/lib/Analysis/plugins/CheckerOptionHandling; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/Analysis/plugins/SampleAnalyzer; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/lib/APINotes; - `3`; - `3`; - `0`; - :good:`100%`; * - clang/lib/ARCMigrate; - `22`; - `0`; - `22`; - :none:`0%`; * - clang/lib/AST; - `81`; - `2`; - `79`; - :part:`2%`; * - clang/lib/AST/Interp; - `44`; - `18`; - `26`; - :part:`40%`; * - clang/lib/ASTMatchers; - `3`; - `1`; - `2`; - :part:`33%`; * - clang/lib/ASTMatchers/Dynamic; - `6`; - `1`; - `5`; - :part:`16%`; * - clang/lib/Basic; - `39`; - `13`; - `26`; - :part:`33%`; * - clang/lib/Basic/Targets; - `50`; - `25`; - `25`; - :part:`50%`; * - clang/lib/CodeGen; - `87`; - `9`; - `78`; - :part:`10%`; * - clang/lib/CrossTU; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/DirectoryWatcher; - `2`; - `2`; - `0`; - :good:`100%`; * - clang/lib/DirectoryWatcher/default; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/DirectoryWatcher/linux; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/l,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:6792,plugin,plugins,6792,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['plugin'],['plugins']
Modifiability,"g; ``/usr/bin/ld.gold -plugin``. If it complains ""missing argument"" then; you have plugin support. If not, and you get an error such as ""unknown option"",; then you will either need to build gold or install a version with plugin; support. * Download, configure and build gold with plugin support:. .. code-block:: bash. $ git clone --depth 1 git://sourceware.org/git/binutils-gdb.git binutils; $ mkdir build; $ cd build; $ ../binutils/configure --enable-gold --enable-plugins --disable-werror; $ make all-gold. That should leave you with ``build/gold/ld-new`` which supports; the ``-plugin`` option. Running ``make`` will additionally build; ``build/binutils/ar`` and ``nm-new`` binaries supporting plugins. Once you're ready to switch to using gold, backup your existing; ``/usr/bin/ld`` then replace it with ``ld-new``. Alternatively, install; in ``/usr/bin/ld.gold`` and use ``-fuse-ld=gold`` as described earlier. Optionally, add ``--enable-gold=default`` to the above configure invocation; to automatically install the newly built gold as the default linker with; ``make install``. * Build the LLVMgold plugin. Run CMake with; ``-DLLVM_BINUTILS_INCDIR=/path/to/binutils/include``. The correct include; path will contain the file ``plugin-api.h``. Usage; =====. You should produce bitcode files from ``clang`` with the option; ``-flto``. This flag will also cause ``clang`` to look for the gold plugin in; the ``lib`` directory under its prefix and pass the ``-plugin`` option to; ``ld``. It will not look for an alternate linker without ``-fuse-ld=gold``,; which is why you otherwise need gold to be the installed system linker in; your path. ``ar`` and ``nm`` also accept the ``-plugin`` option and it's possible to; to install ``LLVMgold.so`` to ``/usr/lib/bfd-plugins`` for a seamless setup.; If you built your own gold, be sure to install the ``ar`` and ``nm-new`` you; built to ``/usr/bin``. Example of link time optimization; ---------------------------------. The following example shows a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:2780,config,configure,2780,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['config'],['configure']
Modifiability,"g; `llvm.dbg.assign` intrinsics after the resultant PHIs generated during; promotion. `mem2reg` already has to do this (with `llvm.dbg.value`) for; `llvm.dbg.declare`s. Where a store has no linked intrinsic, the store is; assumed to represent an assignment for variables stored at the destination; address. #### Debug intrinsic updates. **Moving** a debug intrinsic: avoid moving `llvm.dbg.assign` intrinsics where; possible, as they represent a source-level assignment, whose position in the; program should not be affected by optimization passes. **Deleting** a debug intrinsic: Nothing new to do. Just like for conventional; debug intrinsics, unless it is unreachable, it’s almost always incorrect to; delete a `llvm.dbg.assign` intrinsic. ### Lowering `llvm.dbg.assign` to MIR. To begin with only SelectionDAG ISel will be supported. `llvm.dbg.assign`; intrinsics are lowered to MIR `DBG_INSTR_REF` instructions. Before this happens; we need to decide where it is appropriate to use memory locations and where we; must use a non-memory location (or no location) for each variable. In order to; make those decisions we run a standard fixed-point dataflow analysis that makes; the choice at each instruction, iteratively joining the results for each block. ### TODO list. As this is an experimental work in progress so there are some items we still need; to tackle:. * As mentioned in test llvm/test/DebugInfo/assignment-tracking/X86/diamond-3.ll,; the analysis should treat escaping calls like untagged stores. * The system expects locals to be backed by a local alloca. This isn't always; the case - sometimes a pointer to storage is passed into a function; (e.g. sret, byval). We need to be able to handle those cases. See; llvm/test/DebugInfo/Generic/assignment-tracking/track-assignments.ll and; clang/test/CodeGen/assignment-tracking/assignment-tracking.cpp for examples. * `trackAssignments` doesn't yet work for variables that have their; `llvm.dbg.declare` location modified by a `DIExpres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:9187,variab,variable,9187,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,1,['variab'],['variable']
Modifiability,"gConstraint<""$dst.reg = $ea_res"">, NoEncode<""$ea_res"">;. def : Pat<(pre_store GPRC:$rS, ptr_rc:$ptrreg, iaddroff:$ptroff),; (STWU GPRC:$rS, iaddroff:$ptroff, ptr_rc:$ptrreg)>;. Here, the pair of ``ptroff`` and ``ptrreg`` operands is matched onto the; complex operand ``dst`` of class ``memri`` in the ``STWU`` instruction. * While the system does automate a lot, it still allows you to write custom C++; code to match special cases if there is something that is hard to; express. While it has many strengths, the system currently has some limitations,; primarily because it is a work in progress and is not yet finished:. * Overall, there is no way to define or match SelectionDAG nodes that define; multiple values (e.g. ``SMUL_LOHI``, ``LOAD``, ``CALL``, etc). This is the; biggest reason that you currently still *have to* write custom C++ code; for your instruction selector. * There is no great way to support matching complex addressing modes yet. In; the future, we will extend pattern fragments to allow them to define multiple; values (e.g. the four operands of the `X86 addressing mode`_, which are; currently matched with custom C++ code). In addition, we'll extend fragments; so that a fragment can match multiple different patterns. * We don't automatically infer flags like ``isStore``/``isLoad`` yet. * We don't automatically generate the set of supported registers and operations; for the `Legalizer`_ yet. * We don't have a way of tying in custom legalized nodes yet. Despite these limitations, the instruction selector generator is still quite; useful for most of the binary and logical operations in typical instruction; sets. If you run into any problems or can't figure out how to do something,; please let Chris know!. .. _Scheduling and Formation:; .. _SelectionDAG Scheduling and Formation:. SelectionDAG Scheduling and Formation Phase; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The scheduling phase takes the DAG of target instructions from the selection; phase and assign",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:52623,extend,extend,52623,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['extend'],['extend']
Modifiability,"gance, because; only supporting one type means that you never have to specify types.; Different languages have different ways of handling this. The easiest; way is to require the user to specify types for every variable; definition, and record the type of the variable in the symbol table; along with its Value\*.; - **arrays, structs, vectors, etc** - Once you add types, you can start; extending the type system in all sorts of interesting ways. Simple; arrays are very easy and are quite useful for many different; applications. Adding them is mostly an exercise in learning how the; LLVM `getelementptr <../../LangRef.html#getelementptr-instruction>`_ instruction; works: it is so nifty/unconventional, it `has its own; FAQ <../../GetElementPtr.html>`_!; - **standard runtime** - Our current language allows the user to access; arbitrary external functions, and we use it for things like ""printd""; and ""putchard"". As you extend the language to add higher-level; constructs, often these constructs make the most sense if they are; lowered to calls into a language-supplied runtime. For example, if; you add hash tables to the language, it would probably make sense to; add the routines to a runtime, instead of inlining them all the way.; - **memory management** - Currently we can only access the stack in; Kaleidoscope. It would also be useful to be able to allocate heap; memory, either with calls to the standard libc malloc/free interface; or with a garbage collector. If you would like to use garbage; collection, note that LLVM fully supports `Accurate Garbage; Collection <../../GarbageCollection.html>`_ including algorithms that; move objects and need to scan/update the stack.; - **exception handling support** - LLVM supports generation of `zero; cost exceptions <../../ExceptionHandling.html>`_ which interoperate with; code compiled in other languages. You could also generate code by; implicitly making every function return an error value and checking; it. You could also make expli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:2898,extend,extend,2898,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['extend'],['extend']
Modifiability,gd/index/dex/Iterator.h; clang-tools-extra/clangd/index/dex/PostingList.cpp; clang-tools-extra/clangd/index/dex/PostingList.h; clang-tools-extra/clangd/index/dex/Token.h; clang-tools-extra/clangd/index/dex/Trigram.cpp; clang-tools-extra/clangd/index/dex/Trigram.h; clang-tools-extra/clangd/index/dex/dexp/Dexp.cpp; clang-tools-extra/clangd/index/remote/Client.cpp; clang-tools-extra/clangd/index/remote/Client.h; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.cpp; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.h; clang-tools-extra/clangd/index/remote/monitor/Monitor.cpp; clang-tools-extra/clangd/index/remote/server/Server.cpp; clang-tools-extra/clangd/index/remote/unimplemented/UnimplementedClient.cpp; clang-tools-extra/clangd/indexer/IndexerMain.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.h; clang-tools-extra/clangd/refactor/Rename.h; clang-tools-extra/clangd/refactor/Tweak.cpp; clang-tools-extra/clangd/refactor/Tweak.h; clang-tools-extra/clangd/refactor/tweaks/AddUsing.cpp; clang-tools-extra/clangd/refactor/tweaks/AnnotateHighlightings.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineInline.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineOutline.cpp; clang-tools-extra/clangd/refactor/tweaks/DumpAST.cpp; clang-tools-extra/clangd/refactor/tweaks/ExpandMacro.cpp; clang-tools-extra/clangd/refactor/tweaks/ExtractFunction.cpp; clang-tools-extra/clangd/refactor/tweaks/ObjCLocalizeStringLiteral.cpp; clang-tools-extra/clangd/refactor/tweaks/RemoveUsingNamespace.cpp; clang-tools-extra/clangd/refactor/tweaks/SwapIfBranches.cpp; clang-tools-extra/clangd/support/Cancellation.cpp; clang-tools-extra/clangd/support/Cancellation.h; clang-tools-extra/clangd/support/Context.cpp; clang-tools-extra/clangd/support/Context.h; clang-tools-extra/clangd/support/FileCache.cpp; clang-tools-extra/clangd/support/FileCache.h; clang-tools-extra/clangd/support/Function.h; clang-tools-extra/clangd/suppo,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:80220,refactor,refactor,80220,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,"ge patterns and a number of special cases. In; the case of Verilog, it doesn't affect a comment right after the opening; parenthesis in the port or parameter list in a module header, because it; is probably for the port on the following line instead of the parenthesis; it follows. .. code-block:: c++. SpacesBeforeTrailingComments: 3; void f() {; if (true) { // foo1; f(); // bar; } // foo; }. .. _SpacesInAngles:. **SpacesInAngles** (``SpacesInAnglesStyle``) :versionbadge:`clang-format 3.4` :ref:`¶ <SpacesInAngles>`; The SpacesInAnglesStyle to use for template argument lists. Possible values:. * ``SIAS_Never`` (in configuration: ``Never``); Remove spaces after ``<`` and before ``>``. .. code-block:: c++. static_cast<int>(arg);; std::function<void(int)> fct;. * ``SIAS_Always`` (in configuration: ``Always``); Add spaces after ``<`` and before ``>``. .. code-block:: c++. static_cast< int >(arg);; std::function< void(int) > fct;. * ``SIAS_Leave`` (in configuration: ``Leave``); Keep a single space after ``<`` and before ``>`` if any spaces were; present. Option ``Standard: Cpp03`` takes precedence. .. _SpacesInCStyleCastParentheses:. **SpacesInCStyleCastParentheses** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInCStyleCastParentheses>`; If ``true``, spaces may be inserted into C style casts.; This option is **deprecated**. See ``InCStyleCasts`` of; ``SpacesInParensOptions``. .. _SpacesInConditionalStatement:. **SpacesInConditionalStatement** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <SpacesInConditionalStatement>`; If ``true``, spaces will be inserted around if/for/switch/while; conditions.; This option is **deprecated**. See ``InConditionalStatements`` of; ``SpacesInParensOptions``. .. _SpacesInContainerLiterals:. **SpacesInContainerLiterals** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInContainerLiterals>`; If ``true``, spaces are inserted inside container literals (e.g. ObjC and; Javascript array and dict literals). For J",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:123658,config,configuration,123658,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ge, but we can't set it up yet (because it doesn't exist!). .. code-block:: c++. // Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.; Value *OldVal = NamedValues[VarName];; NamedValues[VarName] = Variable;. // Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.; if (!Body->codegen()); return nullptr;. Now the code starts to get more interesting. Our 'for' loop introduces a; new variable to the symbol table. This means that our symbol table can; now contain either function arguments or loop variables. To handle this,; before we codegen the body of the loop, we add the loop variable as the; current value for its name. Note that it is possible that there is a; variable of the same name in the outer scope. It would be easy to make; this an error (emit an error and return null if there is already an; entry for VarName) but we choose to allow shadowing of variables. In; order to handle this correctly, we remember the Value that we are; potentially shadowing in ``OldVal`` (which will be null if there is no; shadowed variable). Once the loop variable is set into the symbol table, the code; recursively codegen's the body. This allows the body to use the loop; variable: any references to it will naturally find it in the symbol; table. .. code-block:: c++. // Emit the step value.; Value *StepVal = nullptr;; if (Step) {; StepVal = Step->codegen();; if (!StepVal); return nullptr;; } else {; // If not specified, use 1.0.; StepVal = ConstantFP::get(*TheContext, APFloat(1.0));; }. Value *NextVar = Builder->CreateFAdd(Variable, StepVal, ""nextvar"");. Now that the body is emitted, we compute the next value of the iteration; variable by adding the step value, or 1.0 if it isn't present.; '``NextVar``' will be the value of the loop variable on the next; iteration of the loop. .. cod",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:23399,variab,variables,23399,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['variab'],['variables']
Modifiability,"ge, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockBegin>`; A regular expression matching macros that start a block. .. code-block:: c++. # With:; MacroBlockBegin: ""^NS_MAP_BEGIN|\; NS_TABLE_HEAD$""; MacroBlockEnd: ""^\; NS_MAP_END|\; NS_TABLE_.*_END$"". NS_MAP_BEGIN; foo();; NS_MAP_EN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:84172,config,configuration,84172,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ge. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). VolumeRangeMode No Adaptive Unscaled, MinMax, RMS, Adaptive, kNN Method to determine volume size. KernelEstimator No Box Box, Sphere, Teepee, Gauss, Sinc3, Sinc5, Sinc7, Sinc9, Sinc11, Lanczos2, Lanczos3, Lanczos5, Lanczos8, Trim Kernel estimation function. DeltaFrac No 3 − nEventsMin/Max for minmax and rms volume range. NEventsMin No 100 − nEventsMin for adaptive volume range. NEventsMax No 200 − nEventsMax for adaptive volume range. MaxVIterations No 150 − MaxVIterations for adaptive volume range. InitialScale No 0.99 − InitialScale for adaptive volume range. GaussSigma No 0.1 − Width (wrt volume size) of Gaussian kernel estimator. NormTree No False − Normalize binary search tree. Configuration options for MVA method :. Configuration options reference for MVA method: FDA. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). Formula No (0) − The discrimination formula. ParRanges No () − Parameter ranges. FitMethod No MINUIT MC,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:5099,Config,Configuration,5099,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['Config'],['Configuration']
Modifiability,"generated. The copy helper functions generated by the compiler should use the; ``_Block_object_assign`` runtime helper function and in the dispose helper the; ``_Block_object_dispose`` runtime helper function should be called. For example, ``Block`` foo in the following:. .. code-block:: c. struct Opaque *__attribute__((NSObject)) objectPointer = ...;; ...; void (^foo)(void) = ^{ CFPrint(objectPointer); };. would have the following helper functions generated:. .. code-block:: c. void __block_copy_foo(struct __block_literal_5 *dst, struct __block_literal_5 *src) {; _Block_object_assign(&dst->objectPointer, src-> objectPointer, BLOCK_FIELD_IS_OBJECT);; }. void __block_dispose_foo(struct __block_literal_5 *src) {; _Block_object_dispose(src->objectPointer, BLOCK_FIELD_IS_OBJECT);; }. Imported ``__block`` marked variables; -------------------------------------. Layout of ``__block`` marked variables; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The compiler must embed variables that are marked ``__block`` in a specialized; structure of the form:. .. code-block:: c. struct _block_byref_foo {; void *isa;; struct Block_byref *forwarding;; int flags; //refcount;; int size;; typeof(marked_variable) marked_variable;; };. Variables of certain types require helper functions for when ``Block_copy()``; and ``Block_release()`` are performed upon a referencing ``Block``. At the ""C""; level only variables that are of type ``Block`` or ones that have; ``__attribute__((NSObject))`` marked require helper functions. In Objective-C; objects require helper functions and in C++ stack based objects require helper; functions. Variables that require helper functions use the form:. .. code-block:: c. struct _block_byref_foo {; void *isa;; struct _block_byref_foo *forwarding;; int flags; //refcount;; int size;; // helper functions called via Block_copy() and Block_release(); void (*byref_keep)(void *dst, void *src);; void (*byref_dispose)(void *);; typeof(marked_variable) marked_variable;; };. The str",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:11520,variab,variables,11520,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability,"generator names at the end of the help text. Generators' names are case-sensitive, and may contain spaces. For this reason,; you should enter them exactly as they are listed in the ``cmake --help``; output, in quotes. For example, to generate project files specifically for; Visual Studio 12, you can execute:. .. code-block:: console. $ cmake -G ""Visual Studio 12"" path/to/llvm/source/root. For a given development platform there can be more than one adequate; generator. If you use Visual Studio, ""NMake Makefiles"" is a generator you can use; for building with NMake. By default, CMake chooses the most specific generator; supported by your development environment. If you want an alternative generator,; you must tell this to CMake with the ``-G`` option. .. todo::. Explain variables and cache. Move explanation here from #options section. .. _Options and variables:. Options and variables; =====================. Variables customize how the build will be generated. Options are boolean; variables, with possible values ON/OFF. Options and variables are defined on the; CMake command line like this:. .. code-block:: console. $ cmake -DVARIABLE=value path/to/llvm/source. You can set a variable after the initial CMake invocation to change its; value. You can also undefine a variable:. .. code-block:: console. $ cmake -UVARIABLE path/to/llvm/source. Variables are stored in the CMake cache. This is a file named ``CMakeCache.txt``; stored at the root of your build directory that is generated by ``cmake``.; Editing it yourself is not recommended. Variables are listed in the CMake cache and later in this document with; the variable name and type separated by a colon. You can also specify the; variable and type on the CMake command line:. .. code-block:: console. $ cmake -DVARIABLE:TYPE=value path/to/llvm/source. Frequently-used CMake variables; -------------------------------. Here are some of the CMake variables that are used often, along with a; brief explanation. For full documentati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:5695,variab,variables,5695,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,"generator; supported by your development environment. If you want an alternative generator,; you must tell this to CMake with the ``-G`` option. .. todo::. Explain variables and cache. Move explanation here from #options section. .. _Options and variables:. Options and variables; =====================. Variables customize how the build will be generated. Options are boolean; variables, with possible values ON/OFF. Options and variables are defined on the; CMake command line like this:. .. code-block:: console. $ cmake -DVARIABLE=value path/to/llvm/source. You can set a variable after the initial CMake invocation to change its; value. You can also undefine a variable:. .. code-block:: console. $ cmake -UVARIABLE path/to/llvm/source. Variables are stored in the CMake cache. This is a file named ``CMakeCache.txt``; stored at the root of your build directory that is generated by ``cmake``.; Editing it yourself is not recommended. Variables are listed in the CMake cache and later in this document with; the variable name and type separated by a colon. You can also specify the; variable and type on the CMake command line:. .. code-block:: console. $ cmake -DVARIABLE:TYPE=value path/to/llvm/source. Frequently-used CMake variables; -------------------------------. Here are some of the CMake variables that are used often, along with a; brief explanation. For full documentation, consult the CMake manual,; or execute ``cmake --help-variable VARIABLE_NAME``. See `Frequently; Used LLVM-related Variables`_ below for information about commonly; used variables that control features of LLVM and enabled subprojects. .. _cmake_build_type:. **CMAKE_BUILD_TYPE**:STRING; This configures the optimization level for ``make`` or ``ninja`` builds. Possible values:. =========================== ============= ========== ========== ==========================; Build Type Optimizations Debug Info Assertions Best suited for; =========================== ============= ========== ========== ============",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:6334,variab,variable,6334,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variable']
Modifiability,"geometry vectors and points, while the 4D space-time is used for; physics vectors representing relativistic particles. These 3D and 4D; vectors are different from vectors of the linear algebra package, which; describe generic N-dimensional vectors. Similar functionality is; currently provided by the CLHEP <Vector> and <Geometry> packages and the; ROOT Physics vector classes (See ""Physics Vectors""). It also re-uses; concepts and ideas from the CMS; [Common Vector package](Common Vector package). In contrast to CLHEP or; the ROOT physics libraries, `GenVector` provides class templates for; modeling the vectors. The user can control how the vector is internally; represented. This is expressed by a choice of coordinate system, which; is supplied as a template parameter when the vector is constructed.; Furthermore, each coordinate system is itself a template, so that the; user can specify the underlying scalar type. The `GenVector` classes do not inherit from **`TObject`**, therefore; cannot be used as in the case of the physics vector classes in ROOT; collections. In addition, to optimize performances, no virtual destructors are; provided. In the following paragraphs, the main characteristics of; `GenVector` are described. A more detailed description of all the; `GenVector` classes is available also at; <http://seal.cern.ch/documents/mathlib/GenVector.pdf>. ### Main Characteristics. #### Optimal Runtime Performances. We try to minimize any overhead in the run-time performance. We have; deliberately avoided the use of any virtual function and even virtual; destructors in the classes. In addition, as much as possible functions; are defined as inline. For this reason, we have chosen to use template; classes to implement the `GenVector` concepts instead of abstract or; base classes and virtual functions. It is then recommended to avoid; using the `GenVector` classes polymorphically and developing classes; inheriting from them. #### Points and Vector Concept. Mathematically ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:68439,inherit,inherit,68439,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['inherit'],['inherit']
Modifiability,"get entry 0, and print the number of tracks (594).; Then we get entry 1 and print the number of tracks (597). ``` {.cpp}; root[] m.GetEntry(0); (int)57503; root[] m.fNtrack(); (Int_t)594; root[] m.GetEntry(1); (int)48045; root[] m.fNtrack(); (Int_t)597; ```. Now we can call the `Loop` method, which will build and display the two; histograms. ``` {.cpp}; root[] m.Loop(); ```. You should now see a canvas that looks like this. ![](pictures/03000106.png). To conclude the discussion on `MakeClass` let us lists the steps that; got us here. - Call `TTree::MakeClass`, which automatically creates a class to loop; over the tree. - Modify the `MyClass::Loop()` method in `MyClass.C` to fit your task. - Load and instantiate `MyClass`, and run `MyClass::Loop()`. ## Using TTree::MakeSelector; \index{tree!MakeSelector}. With a **`TTree`** we can make a selector and use it to process a; limited set of entries. This is especially important in a parallel; processing configuration where the analysis is distributed over several; processors and we can specify which entries to send to each processor.; The `TTree::Process` method is used to specify the selector and the; entries. Before we can use **`TTree::Process`** we need to make a; selector. We can call the `TTree::MakeSelector` method. It creates; two files similar to `TTree::MakeClass`. In the resulting files is a class that is a descendent of; **`TSelector`** and implements the following methods:. - `TSelector::Begin()` `-` this method is called every time a loop; over the tree starts. This is a convenient place to create your; histograms. - `TSelector::Notify()` `-` it is called at the first entry of a new; tree in a chain. - `TSelector::Process()` `-` it is called to process an event. It is; the user's responsibility to read the corresponding entry in memory; (may be just a partial read). Once the entry is in memory one can; apply a selection and if the event is selected histograms can be; filled. Processing stops when this functi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:131223,config,configuration,131223,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['config'],['configuration']
Modifiability,"get(test-depends; DEPENDS ${LLVM_ALL_LIT_DEPENDS} ${LLVM_ALL_ADDITIONAL_TEST_DEPENDS}); set_target_properties(test-depends PROPERTIES FOLDER ""Tests""); add_dependencies(check-all test-depends); endif(). if (LLVM_INCLUDE_DOCS); add_subdirectory(docs); endif(). add_subdirectory(cmake/modules). # Do this last so that all lit targets have already been created.; if (LLVM_INCLUDE_UTILS); add_subdirectory(utils/llvm-lit); endif(). if (NOT LLVM_INSTALL_TOOLCHAIN_ONLY); install(DIRECTORY include/llvm include/llvm-c; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT llvm-headers; FILES_MATCHING; PATTERN ""*.def""; PATTERN ""*.h""; PATTERN ""*.td""; PATTERN ""*.inc""; PATTERN ""LICENSE.TXT""; ). install(DIRECTORY ${LLVM_INCLUDE_DIR}/llvm ${LLVM_INCLUDE_DIR}/llvm-c; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT llvm-headers; FILES_MATCHING; PATTERN ""*.def""; PATTERN ""*.h""; PATTERN ""*.gen""; PATTERN ""*.inc""; # Exclude include/llvm/CMakeFiles/intrinsics_gen.dir, matched by ""*.def""; PATTERN ""CMakeFiles"" EXCLUDE; PATTERN ""config.h"" EXCLUDE; ). if (LLVM_INSTALL_MODULEMAPS); install(DIRECTORY include; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT llvm-headers; FILES_MATCHING; PATTERN ""module.modulemap""; ); install(FILES include/module.install.modulemap; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT llvm-headers; RENAME ""module.extern.modulemap""; ); endif(LLVM_INSTALL_MODULEMAPS). # Installing the headers needs to depend on generating any public; # tablegen'd headers.; add_custom_target(llvm-headers DEPENDS intrinsics_gen omp_gen); set_target_properties(llvm-headers PROPERTIES FOLDER ""Misc""). if (NOT LLVM_ENABLE_IDE); add_llvm_install_targets(install-llvm-headers; DEPENDS llvm-headers; COMPONENT llvm-headers); endif(). # Custom target to install all libraries.; add_custom_target(llvm-libraries); set_target_properties(llvm-libraries PROPERTIES FOLDER ""Misc""). if (NOT LLVM_ENABLE_IDE); add_llvm_install_targets(install-llvm-libraries; DEPENDS llvm-libraries; COMPONENT llvm-lib",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:52143,config,config,52143,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['config'],['config']
Modifiability,"get_property(LLVM_LIT_CONFIG_FILES GLOBAL PROPERTY LLVM_LIT_CONFIG_FILES); list(LENGTH LLVM_LIT_CONFIG_FILES file_len); math(EXPR file_last ""${file_len} - 1""). get_llvm_lit_path(LIT_BASE_DIR LIT_FILE_NAME). set(LLVM_SOURCE_DIR ${LLVM_MAIN_SRC_DIR}). # LLVM_LIT_CONFIG_FILES contains interleaved main config (in the source tree); # and site config (in the build tree) pairs. Make them relative to; # llvm-lit and then convert them to map_config() calls.; if(""${CMAKE_CFG_INTDIR}"" STREQUAL "".""); make_paths_relative(; LLVM_LIT_CONFIG_FILES ""${LIT_BASE_DIR}"" ""${LLVM_LIT_CONFIG_FILES}""); make_paths_relative(; LLVM_SOURCE_DIR ""${LIT_BASE_DIR}"" ""${LLVM_SOURCE_DIR}""); endif(). set(LLVM_LIT_CONFIG_MAP ""${LLVM_LIT_PATH_FUNCTION}\n""); if (${file_last} GREATER -1); foreach(i RANGE 0 ${file_last} 2); list(GET LLVM_LIT_CONFIG_FILES ${i} main_config); math(EXPR i1 ""${i} + 1""); list(GET LLVM_LIT_CONFIG_FILES ${i1} site_out); set(map ""map_config(path(r'${main_config}'), path(r'${site_out}'))""); set(LLVM_LIT_CONFIG_MAP ""${LLVM_LIT_CONFIG_MAP}\n${map}""); endforeach(); endif(). if(NOT ""${CMAKE_CFG_INTDIR}"" STREQUAL "".""); foreach(BUILD_MODE ${CMAKE_CONFIGURATION_TYPES}); string(REPLACE ${CMAKE_CFG_INTDIR} ${BUILD_MODE} bi ${LIT_BASE_DIR}); set(bi ""${bi}/${LIT_FILE_NAME}""); configure_file(; llvm-lit.in; ${bi}; ); endforeach(); else(); set(BUILD_MODE .); configure_file(; llvm-lit.in; ${LIT_BASE_DIR}/${LIT_FILE_NAME}; ); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/llvm-lit/CMakeLists.txt:300,config,config,300,interpreter/llvm-project/llvm/utils/llvm-lit/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/llvm-lit/CMakeLists.txt,4,['config'],['config']
Modifiability,"gets (nD).; ; Not all transformation of input variables are available; (only ""Norm"" so far). Regression requires specific evaluation tools:. ; During the training we provide a ranking of input; variables, using various criteria: correlations, transposed; correlation, correlation ratio, and ""mutual information"" between; input variables and regression target. (Correlation ratio and; mutual information implmentations provided by Moritz Backes,; Geneva U); ; After the training, the trained MVA methods are ranked wrt.; the deviations between regression target and estimate.; ; Macros plot various deviation and correlation quantities.; A new GUI (macros/TMVARegGui.C) collects these macros.; . Improvements of / new features for MVA methods . Linear Discriminant:; Re-implementation of ""Fisher"" method as general linear discriminant (""LD""),; which is also regression capable (so far: single-target only). PDEFoam:; PDE-Foam is a variation of the PDE-RS method using a self-adapting binning; method to divide the multi-dimensional variable space into a finite number; of hyper-rectangles (cells). The binning algorithm adjusts the size and; position of a predefined number of cells such that the variance of the; signal and background densities inside the cells reaches a minimum. BDT:; Introduced gradient boosting and stochastic gradient boosting for ; classification with BDT (as desribed by Friedman 1999). See ""BDTG"" ; example in TMVAClassification.C/cxx. A new option allows to restrict the maximum tree depth. This may be used to; avoid overtraining and often gives better performance than pruning. (The; pruning mechanism needs to be revisited). MLP:; Introduced recognition of convergence via general ConvergenceTest-class for; interrupting computations when convergence is reached. This feature has is; used now in MethodMLP. Improved treatment of event-weights in BFGS training. Implemented random and importance sampling of events in DataSet. Implemented; the usage of this feature for MLP",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v524/index.html:2435,adapt,adapting,2435,tmva/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v524/index.html,4,"['adapt', 'variab']","['adapting', 'variable']"
Modifiability,"gging<format_common_intrinsics>`; documentation. Varying variable locations; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Variables that are not always on the stack or change location are specified; with the ``DBG_VALUE`` meta machine instruction. It is synonymous with the; ``llvm.dbg.value`` IR intrinsic, and is written:. .. code-block:: text. DBG_VALUE $rax, $noreg, !123, !DIExpression(), debug-location !456. The operands to which respectively:. 1. Identifies a machine location such as a register, immediate, or frame index,. 2. Is either $noreg, or immediate value zero if an extra level of indirection is to be added to the first operand,. 3. Identifies a ``DILocalVariable`` metadata node,. 4. Specifies an expression qualifying the variable location, either inline or as a metadata node reference,. While the source location identifies the ``DILocation`` for the scope of the; variable. The second operand (``IsIndirect``) is deprecated and to be deleted.; All additional qualifiers for the variable location should be made through the; expression metadata. .. _instruction-referencing-locations:. Instruction referencing locations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This experimental feature aims to separate the specification of variable; *values* from the program point where a variable takes on that value. Changes; in variable value occur in the same manner as ``DBG_VALUE`` meta instructions; but using ``DBG_INSTR_REF``. Variable values are identified by a pair of; instruction number and operand number. Consider the example below:. .. code-block:: text. $rbp = MOV64ri 0, debug-instr-number 1, debug-location !12; DBG_INSTR_REF !123, !DIExpression(DW_OP_LLVM_arg, 0), dbg-instr-ref(1, 0), debug-location !456. Instruction numbers are directly attached to machine instructions with an; optional ``debug-instr-number`` attachment, before the optional; ``debug-location`` attachment. The value defined in ``$rbp`` in the code; above would be identified by the pair ``<1, 0>``. The 3rd operand of the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:26350,variab,variable,26350,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['variab'],['variable']
Modifiability,"gh ARC destroys instance variables automatically, there are still; legitimate reasons to write a ``dealloc`` method, such as freeing; non-retainable resources. Failing to call ``[super dealloc]`` in such a; method is nearly always a bug. Sometimes, the object is simply trying to; prevent itself from being destroyed, but ``dealloc`` is really far too late; for the object to be raising such objections. Somewhat more legitimately, an; object may have been pool-allocated and should not be deallocated with; ``free``; for now, this can only be supported with a ``dealloc``; implementation outside of ARC. Such an implementation must be very careful; to do all the other work that ``NSObject``'s ``dealloc`` would, which is; outside the scope of this document to describe. The instance variables for an ARC-compiled class will be destroyed at some; point after control enters the ``dealloc`` method for the root class of the; class. The ordering of the destruction of instance variables is unspecified,; both within a single class and between subclasses and superclasses. .. admonition:: Rationale. The traditional, non-ARC pattern for destroying instance variables is to; destroy them immediately before calling ``[super dealloc]``. Unfortunately,; message sends from the superclass are quite capable of reaching methods in; the subclass, and those methods may well read or write to those instance; variables. Making such message sends from dealloc is generally discouraged,; since the subclass may well rely on other invariants that were broken during; ``dealloc``, but it's not so inescapably dangerous that we felt comfortable; calling it undefined behavior. Therefore we chose to delay destroying the; instance variables to a point at which message sends are clearly disallowed:; the point at which the root class's deallocation routines take over. In most code, the difference is not observable. It can, however, be observed; if an instance variable holds a strong reference to an object whose; d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:88926,variab,variables,88926,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variables']
Modifiability,"gin(), a.end(), [](int x, int y) { return x < y; });. * ``SLS_All`` (in configuration: ``All``); Merge all lambdas fitting on a single line. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) { return a; };. .. _AllowShortLoopsOnASingleLine:. **AllowShortLoopsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <AllowShortLoopsOnASingleLine>`; If ``true``, ``while (true) continue;`` can be put on a single; line. .. _AlwaysBreakAfterDefinitionReturnType:. **AlwaysBreakAfterDefinitionReturnType** (``DefinitionReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlwaysBreakAfterDefinitionReturnType>`; The function definition return type breaking style to use. This; option is **deprecated** and is retained for backwards compatibility. Possible values:. * ``DRTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. * ``DRTBS_All`` (in configuration: ``All``); Always break after the return type. * ``DRTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. _AlwaysBreakAfterReturnType:. **AlwaysBreakAfterReturnType** (``ReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlwaysBreakAfterReturnType>`; The function declaration return type breaking style to use. Possible values:. * ``RTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int f() { return 1; }. * ``RTBS_All`` (in configuration: ``All``); Always break after the return type. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. code-block:: c++. class A {; int f() { return 0; };; };; int; f();;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:32690,config,configuration,32690,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ginal size of the data sample (used whenever bagging is used). Boost_MethodWeightType No ByError ByError, Average, ByROC, ByOverlap, LastMethod How to set the final weight of the boosted classifiers. Boost_RecalculateMVACut No True − Recalculate the classifier MVA Signallike cut at every boost iteration. Boost_AdaBoostBeta No 1 − The ADA boost parameter that sets the effect of every boost step on the events' weights. Boost_Transform No step step, linear, log, gauss Type of transform applied to every boosted method linear, log, step. Boost_RandomSeed No 0 − Seed for random number generator used for bagging. Configuration options for MVA method :. Configuration options reference for MVA method: RuleFit. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). GDTau No -1 − Gradient-directed (GD) path: default fit cut-off. GDTauPrec No 0.01 − GD path: precision of tau. GDStep No 0.01 − GD path: step size. GDNSteps No 10000 − GD path: number of steps. GDErrScale No 1.1 − Stop scan when error > scale*errmin. LinQuantile No 0.025 − Quantile of linear terms (removes outliers). GDPathEveFrac No 0.5 − Fraction of events used for the path search. GDValidEveFrac No 0.5 − Fraction ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:17975,variab,variable,17975,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,2,['variab'],['variable']
Modifiability,"gister a variable is located in during regalloc, but at; single positions (block entry points) rather than ranges of instructions. An example, before regalloc:. ```text; bb.2:; %2 = PHI %1, %bb.0, %2, %bb.1, debug-instr-number 1; ```. After:. ```text; bb.2:; DBG_PHI $rax, 1; ```. # `LiveDebugValues`. After optimisations and code layout complete, information about variable; values must be translated into variable locations, i.e. registers and stack; slots. This is performed in the [`LiveDebugValues` pass][LiveDebugValues], where; the debug instructions and machine code are separated out into two independent; functions:; * One that assigns values to variable names,; * One that assigns values to machine registers and stack slots. LLVM's existing SSA tools are used to place `PHI`s for each function, between; variable values and the values contained in machine locations, with value; propagation eliminating any unnecessary `PHI`s. The two can then be joined up; to map variables to values, then values to locations, for each instruction in; the function. Key to this process is being able to identify the movement of values between; registers and stack locations, so that the location of values can be preserved; for the full time that they are resident in the machine. # Required target support and transition guide. Instruction referencing will work on any target, but likely with poor coverage.; Supporting instruction referencing well requires:; * Target hooks to be implemented to allow `LiveDebugValues` to follow values; through the machine,; * Target-specific optimisations to be instrumented, to preserve instruction; numbers. ## Target hooks. `TargetInstrInfo::isCopyInstrImpl` must be implemented to recognise any; instructions that are copy-like -- `LiveDebugValues` uses this to identify when; values move between registers. `TargetInstrInfo::isLoadFromStackSlotPostFE` and; `TargetInstrInfo::isStoreToStackSlotPostFE` are needed to identify spill and; restore instructions. Each",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md:4938,variab,variables,4938,interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,1,['variab'],['variables']
Modifiability,"gister allocation, the; VirtRegRewriter pass re-inserts DBG_VALUE instructions in their original; positions, translating virtual register references into their physical; machine locations. To avoid encoding incorrect variable locations, in this; pass any DBG_VALUE of a virtual register that is not live, is replaced by; the undefined location. The LiveDebugVariables may insert redundant DBG_VALUEs; because of virtual register rewriting. These will be subsequently removed by; the RemoveRedundantDebugValues pass. LiveDebugValues expansion of variable locations; -----------------------------------------------. After all optimizations have run and shortly before emission, the; LiveDebugValues pass runs to achieve two aims:. * To propagate the location of variables through copies and register spills,; * For every block, to record every valid variable location in that block. After this pass the DBG_VALUE instruction changes meaning: rather than; corresponding to a source-level assignment where the variable may change value,; it asserts the location of a variable in a block, and loses effect outside the; block. Propagating variable locations through copies and spills is; straightforwards: determining the variable location in every basic block; requires the consideration of control flow. Consider the following IR, which; presents several difficulties:. .. code-block:: text. define dso_local i32 @foo(i1 %cond, i32 %input) !dbg !12 {; entry:; br i1 %cond, label %truebr, label %falsebr. bb1:; %value = phi i32 [ %value1, %truebr ], [ %value2, %falsebr ]; br label %exit, !dbg !26. truebr:; call void @llvm.dbg.value(metadata i32 %input, metadata !30, metadata !DIExpression()), !dbg !24; call void @llvm.dbg.value(metadata i32 1, metadata !23, metadata !DIExpression()), !dbg !24; %value1 = add i32 %input, 1; br label %bb1. falsebr:; call void @llvm.dbg.value(metadata i32 %input, metadata !30, metadata !DIExpression()), !dbg !24; call void @llvm.dbg.value(metadata i32 2, metadata !23",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:36926,variab,variable,36926,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,2,['variab'],['variable']
Modifiability,"github.com/mozilla/dxr>`_; ""DXR is a source code cross-reference tool that uses static analysis; data collected by instrumented compilers."". `<https://github.com/eschulte/clang-mutate>`_; ""This tool performs a number of operations on C-language source files."". `<https://github.com/gmarpons/Crisp>`_; ""A coding rule validation add-on for LLVM/clang. Crisp rules are written; in Prolog. A high-level declarative DSL to easily write new rules is under; development. It will be called CRISP, an acronym for *Coding Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memory allocations to misusage of API, including fix-its for automatic; refactoring."". `<https://gerrit.libreo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:2875,plugin,plugin,2875,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,1,['plugin'],['plugin']
Modifiability,"given in Attr.td. This definition is used to automatically generate; functionality used for the implementation of the attribute, such as a class; derived from ``clang::Attr``, information for the parser to use, automated; semantic checking for some attributes, etc. ``include/clang/Basic/Attr.td``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; The first step to adding a new attribute to Clang is to add its definition to; `include/clang/Basic/Attr.td; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/Attr.td>`_.; This tablegen definition must derive from the ``Attr`` (tablegen, not; semantic) type, or one of its derivatives. Most attributes will derive from the; ``InheritableAttr`` type, which specifies that the attribute can be inherited by; later redeclarations of the ``Decl`` it is associated with.; ``InheritableParamAttr`` is similar to ``InheritableAttr``, except that the; attribute is written on a parameter instead of a declaration. If the attribute; applies to statements, it should inherit from ``StmtAttr``. If the attribute is; intended to apply to a type instead of a declaration, such an attribute should; derive from ``TypeAttr``, and will generally not be given an AST representation.; (Note that this document does not cover the creation of type attributes.) An; attribute that inherits from ``IgnoredAttr`` is parsed, but will generate an; ignored attribute diagnostic when used, which may be useful when an attribute is; supported by another vendor but not supported by clang. The definition will specify several key pieces of information, such as the; semantic name of the attribute, the spellings the attribute supports, the; arguments the attribute expects, and more. Most members of the ``Attr`` tablegen; type do not require definitions in the derived definition as the default; suffice. However, every attribute must specify at least a spelling list, a; subject list, and a documentation list. Spellings; ~~~~~~~~~; All attributes are required to specify",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:128126,inherit,inherit,128126,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['inherit'],['inherit']
Modifiability,"given tag in an NSIS; installer (.exe); --dmg-tag DMG_TAG Package the snapshot of a given tag in a DMG package; (.dmg); --with-llvm-url WITH_LLVM_URL; Specify an alternate URL of LLVM repo; --with-clang-url WITH_CLANG_URL; Specify an alternate URL of Clang repo; --with-cling-url WITH_CLING_URL; Specify an alternate URL of Cling repo; --no-test Do not run test suite of Cling; --create-dev-env CREATE_DEV_ENV; Set up a release/debug environment; --with-workdir WITH_WORKDIR; Specify an alternate working directory for CPT; --make-proper MAKE_PROPER; Internal option to support calls from build system. ```; If you want CPT to build a package by detecting your platform automatically,; use the value 'pkg'.; ```sh; ./cpt.py --current-dev=pkg; ```; or; ```sh; ./cpt.py --last-stable=pkg; ```; ### Overriding Default Variables; There are a select number of variables which can be set to make CPT work; differently. This eliminates the need to manually edit the script.; You can overrride variables by using the following syntax:; ```$ ./cpt.py --with-cling-url=""http://github.com/ani07nov/cling"" --current-dev=tar```. List of variables in CPT which can be overridden:; - **CLING_GIT_URL**; * Specify the URL of the Git repository of Cling to be used by CPT; * **Default value:** ""http://root.cern.ch/git/cling.git""; * **Usage:** ```./cpt.py --with-cling-url=""http://github.com/ani07nov/cling"" --last-stable=deb```. - **CLANG_GIT_URL**; * Specify the URL of the Git repository of Clang to be used by CPT; * **Default value:** ""http://root.cern.ch/git/clang.git""; * **Usage:** ```./cpt.py --with-clang-url=""http://github.com/ani07nov/clang"" --last-stable=tar```. - **LLVM_GIT_URL**; * Specify the URL of the Git repository of LLVM to be used by CPT; * **Default value:** ""http://root.cern.ch/git/llvm.git""; * **Usage:** ```./cpt.py --with-llvm-url=""http://github.com/ani07nov/llvm"" --current-dev=tar```. - **workdir**; * Specify the working directory of CPT. All sources will be cloned, built; and instal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md:8408,variab,variables,8408,interpreter/cling/tools/packaging/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md,1,['variab'],['variables']
Modifiability,"gnal, which `b` will receive, i.e. `b->SetValue(79)` is invoked. It is executed immediately, just like a normal function call. `b` will in turn emit the same signal, which nobody receives, since no slot has been connected to it, so it disappears into hyperspace. This example illustrates that objects can work together without knowing about each other, as long as there is someone around to set up a connection between them. ## Features of the ROOT implementation. * The ROOT implementation **does not require the** *moc* preprocessor and the `signal:` and `slot:` keywords in the class declaration. Signals and slots are normal class methods. * The class which corresponds to **Qt's** **QObject** is [TQObject](https://root.cern/doc/master/classTQObject.html). It reproduces the general features of the QObject class and has the `Connect()`, `Disconnect()` and `Emit()` methods. The [TQObject](https://root.cern/doc/master/classTQObject.html) class does not derive from any class which makes it possible to have multiple inheritance from [TObject](https://root.cern/doc/master/classTQObject.html) derived classes and [TQObject](https://root.cern/doc/master/classTQObject.html). * By placing the [`RQ_OBJECT()`](https://root.cern/doc/master/RQ__OBJECT_8h.html) macro inside a class body you can use signals and slots with classes not inheriting from [TQObject](https://root.cern/doc/master/classTQObject.html), like interpreted classes which can not derive from compiled classes. This makes it possible to apply the **Object Communication Mechanism** between compiled and interpreted classes in an interactive ROOT session. * The ROOT implementation allows to make connections to any object known to the ROOT C++ interpreter. The following line makes a connection between signal `Pressed()` from `button` and method/slot `Draw()` from object `hist` of class (compiled or interpreted) `TH1`. ``` {.cpp}; Connect(button, ""Pressed()"", ""TH1"", hist, ""Draw()"");; ```. To connect to a stand-alone function (",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md:4051,inherit,inheritance,4051,documentation/users-guide/SignalSlot.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md,1,['inherit'],['inheritance']
Modifiability,"gnatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockBegin>`; A regular expression matching macros that start a block. .. code-block:: c++. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:84009,config,configuration,84009,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"gned for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from the; heavy lifting Clang already does to detect features. Low maintenance; ---------------. Multilib is a relatively small feature in the scheme of things so supporting it; should accordingly take little time. Where possible this should be achieved by; implementing it in terms of existing features in the LLVM codebase. Minimal additional API surface; ------------------------------. The greater the API surface, the greater the difficulty of keeping it stable.; Where possible the additional API surface should be kept small by defining it; in relation to existing APIs. An example of this is keeping a simple; relationship between flag names and command line options where possible.; Since the command line options are part of a stable API they are unlikely; to change, and therefore the flag names get the same stability. Low compile-time overhead; -------------------------. If the process of selecting multilib directories must be done on every; invocation of the Clang driver then it must have",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:12405,config,configuration,12405,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['config'],['configuration']
Modifiability,"gnment information provided by the frontend for a non-integral pointer; (typically using attributes or metadata) must be valid for every possible ; representation of the pointer. .. _globalvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be initialized. Global variables in other translation units can also be declared, in which; case they don't have an initializer. Global variables can optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:31033,variab,variable,31033,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['variab'],['variable']
Modifiability,"gnment; 2. Many improvements in TPaletteAxis drawing - draw label, avoid too large ticks.; 3. Fix error with col drawing - bin with maximum value got wrong color; 4. Test for existing jquery.js, jquery-ui.js and d3.js libraries, reuse when provided; 5. Fix several I/O problems; now one could read files, produced in Geant4; 6. Implement 'e2' drawing option for TH1 class,; use by default 'e' option when TH1 has non-empty fSumw2; 7. Reuse statistic from histogram itself, when no axis selection done; 8. Support log/lin z scale for color drawing; 9. Implement interactive z-scale selection on TPaletteAxis; 10. Allow to redraw item with other draw options (before one should clear drawings); 11. Several improvements in THttpServer user interface - repair hierarchy reload,; hide unsupported context menu entries, status line update. ## Changes in 3.4; 1. Support usage of minimized versions of .js and .css files.; Minimized scripts used by default on web servers.; 2. Implement JSROOT.extend instead of jQuery.extend, reduce; usage of jquery.js in core JSROOT classes; 3. Implement main graphics without jquery at all,; such mode used in `nobrowser` mode.; 4. Provide optional latex drawing with MathJax SVG.; TMathText always drawn with MathJax,; other classes require `mathjax` option in URL; 5. Improve drawing of different text classes, correctly handle; their alignment and scaling, special handling for IE; 6. Fix error with time axes - time offset was not correctly interpreted. ## Changes in 3.3; 1. Use d3.time.scale for display of time scales; 2. Within JSRootCore.js script URL one could specify JSROOT; functionality to be loaded: '2d', '3d', 'io', 'load', 'onload'.; Old method with JSROOT.AssertPrerequisites will also work.; 3. With THttpServer JSROOT now provides simple control functionality.; One could publish commands and execute them from the browser; 4. One could open several ROOT files simultaneously; 5. Add 'simple' layout - drawing uses full space on the right side; 6. A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:66420,extend,extend,66420,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['extend'],['extend']
Modifiability,"gold.so`` to ``/usr/lib/bfd-plugins`` for a seamless setup.; If you built your own gold, be sure to install the ``ar`` and ``nm-new`` you; built to ``/usr/bin``. Example of link time optimization; ---------------------------------. The following example shows a worked example of the gold plugin mixing LLVM; bitcode and native code. .. code-block:: c. --- a.c ---; #include <stdio.h>. extern void foo1(void);; extern void foo4(void);. void foo2(void) {; printf(""Foo2\n"");; }. void foo3(void) {; foo4();; }. int main(void) {; foo1();; }. --- b.c ---; #include <stdio.h>. extern void foo2(void);. void foo1(void) {; foo2();; }. void foo4(void) {; printf(""Foo4"");; }. .. code-block:: bash. --- command lines ---; $ clang -flto a.c -c -o a.o # <-- a.o is LLVM bitcode file; $ ar q a.a a.o # <-- a.a is an archive with LLVM bitcode; $ clang b.c -c -o b.o # <-- b.o is native object file; $ clang -flto a.a b.o -o main # <-- link with LLVMgold plugin. Gold informs the plugin that foo3 is never referenced outside the IR,; leading LLVM to delete that function. However, unlike in the :ref:`libLTO; example <libLTO-example>` gold does not currently eliminate foo4. Quickstart for using LTO with autotooled projects; =================================================. Once your system ``ld``, ``ar``, and ``nm`` all support LLVM bitcode,; everything is in place for an easy to use LTO build of autotooled projects:. * Follow the instructions :ref:`on how to build LLVMgold.so; <lto-how-to-build>`. * Install the newly built binutils to ``$PREFIX``. * Copy ``Release/lib/LLVMgold.so`` to ``$PREFIX/lib/bfd-plugins/``. * Set environment variables (``$PREFIX`` is where you installed clang and; binutils):. .. code-block:: bash. export CC=""$PREFIX/bin/clang -flto""; export CXX=""$PREFIX/bin/clang++ -flto""; export AR=""$PREFIX/bin/ar""; export NM=""$PREFIX/bin/nm""; export RANLIB=/bin/true #ranlib is not needed, and doesn't support .bc files in .a. * Or you can just set your path:. .. code-block:: bash. export PA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:4511,plugin,plugin,4511,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['plugin'],['plugin']
Modifiability,"gory.html#ae63ae78231765d184b7a839c74746a49). In the past, you had to create the correct C++ class in Python, but now you can usually pass a Python dictionary instead. For example, a RooCategory can be created like this:; ```Python; sample = ROOT.RooCategory(""sample"", ""sample"", {""Sample1"": 1, ""Sample2"": 2, ""Sample3"": 3}); ```. #### RooWorkspace accessors. In Python, you can now get objects stored in a [RooWorkspace](https://root.cern/doc/v626/classRooWorkspace.html) with the item retrieval operator, and the return value is also always downcasted to the correct type. That means in Python you don't have to use [RooWorkspace::var()](https://root.cern/doc/v626/classRooWorkspace.html#acf5f9126ee264c234721a4ed1f9bf837) to access variables or [RooWorkspace::pdf()](https://root.cern/doc/v626/classRooWorkspace.html#afa7384cece424a1a94a644bb05549eee) to access pdfs, but you can always get any object using square brackets. For example:; ```Python; # w is a RooWorkspace instance that contains the variables `x`, `y`, and `z` for which we want to generate toy data:; model.generate({w[""x""], w[""y""], w[""z""]}, 1000); ```. ### New PyROOT functions for interoperability with NumPy and Pandas. New member functions of RooFit classes were introduced exclusively to PyROOT for better interoperability between RooFit and Numpy and Pandas:. - `RooDataSet.from_numpy`: Import a RooDataSet from a dictionary of numpy arrays (static method); - `RooDataSet.to_numpy`: Export a RooDataSet to a dictionary of numpy arrays; - `RooDataSet.from_pandas`: Import a RooDataSet from a Pandas dataframe (static method); - `RooDataSet.to_pandas`: Export a RooDataSet to a Pandas dataframe; - `RooDataHist.from_numpy`: Import a RooDataHist from numpy arrays with histogram counts and bin edges (static method); - `RooDataHist.to_numpy`: Export a RooDataHist to numpy arrays with histogram counts and bin edges; - `RooRealVar.bins`: Get bin boundaries for a `RooRealVar` as a NumPy array. For more details, consult the tutor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:22486,variab,variables,22486,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['variab'],['variables']
Modifiability,grals.cxx; testTStatistic.cxx; fit/SparseDataComparer.cxx; fit/SparseFit3.cxx; fit/SparseFit4.cxx; fit/testBinnedFitExecPolicy.cxx; fit/testFit.cxx; fit/testGraphFit.cxx; fit/testLogLExecPolicy.cxx; fit/testMinim.cxx). if(mathmore); list(APPEND Libraries MathMore); endif(). if(r); add_definitions(-DROOT_HAS_R); list(APPEND Libraries RInterface); endif(). #---Build and add all the defined test in the list---------------; foreach(file ${TestSource}); get_filename_component(testname ${file} NAME_WE); ROOT_EXECUTABLE(${testname} ${file} LIBRARIES ${Libraries}); ROOT_ADD_TEST(mathcore-${testname} COMMAND ${testname} LABELS ${${testname}_LABELS}); endforeach(). ROOT_STANDARD_LIBRARY_PACKAGE(TrackMathCoreUnitDict; NO_INSTALL_HEADERS; NO_SOURCES; HEADERS ${CMAKE_CURRENT_SOURCE_DIR}/stress/TrackMathCore.h; LINKDEF stress/TrackMathCoreLinkDef.h; DEPENDENCIES Core MathCore RIO GenVector Smatrix). if(MSVC AND NOT CMAKE_GENERATOR MATCHES Ninja); add_custom_command(TARGET TrackMathCoreUnitDict POST_BUILD; COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_BINARY_DIR}/$<CONFIG>/libTrackMathCoreUnitDict.dll; ${CMAKE_CURRENT_BINARY_DIR}/libTrackMathCoreUnitDict.dll); endif(). ROOT_ADD_GTEST(stressMathCoreUnit stress/testSMatrix.cxx stress/testGenVector.cxx; stress/testStat.cxx stress/testSVector.cxx stress/testVector.cxx stress/testVector34.cxx; stress/TestHelper.cxx; LIBRARIES Core MathCore Hist RIO Tree GenVector). ROOT_ADD_GTEST(GradientUnit testGradient.cxx LIBRARIES Core MathCore Hist ). ROOT_ADD_GTEST(GradientFittingUnit testGradientFitting.cxx LIBRARIES Core MathCore Hist). ROOT_ADD_GTEST(MulmodUnitOpt mulmod_opt.cxx); ROOT_ADD_GTEST(MulmodUnitNoInt128 mulmod_noint128.cxx); ROOT_ADD_GTEST(RanluxLCGUnit ranlux_lcg.cxx). ROOT_ADD_GTEST(RanluxppEngineTests RanluxppEngine.cxx; LIBRARIES Core MathCore). if(veccore AND vc); ROOT_ADD_GTEST(VectorizedTMathUnit testVectorizedTMath.cxx; LIBRARIES Core MathCore); endif(). ROOT_ADD_GTEST(testRootFinder testRootFinder.cxx LIBRARIES ${Librari,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/CMakeLists.txt:1842,CONFIG,CONFIG,1842,math/mathcore/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/CMakeLists.txt,1,['CONFIG'],['CONFIG']
Modifiability,"gram state (scanning; reachable symbols and regions) that cannot work without checker support. We can probably add a new callback ""checkReachableSymbols"" to solve this. This; is in fact also related to the dead symbols problem (we're scanning for live; symbols in the store and in the checkers separately, but we need to do so; simultaneously with a single worklist). Hmm, in fact this sounds like a good; idea; we can replace checkLiveSymbols with checkReachableSymbols. Or we could just have ghost member variables, and no checker support required at; all. For ghost member variables, the relation with their parent region (which; would be their superregion) is actually useful, the mutability of their contents; is expressed naturally, and the store automagically sees reachable symbols, live; symbols, escapes, invalidations, whatever. > In my view this differs from ghost variables in that (1) this storage does; > actually exist (it is just a library implementation detail where that storage; > lives) and (2) it is perfectly valid for a pointer into that storage to be; > returned and for another part of the program to read or write from that; > storage. (Well, in this case just read since it is allowed to be read-only; > memory). > What I'm not OK with is modeling abstract analysis state (for example, the; > count of a NSMutableArray or the typestate of a file handle) as a value stored; > in some ginned up region in the store.This takes an easy problem that the; > analyzer does well at (modeling typestate) and turns it into a hard one that; > the analyzer is bad at (reasoning about the contents of the heap). Yeah, i tend to agree on that. For simple typestates, this is probably an; overkill, so let's definitely put aside the idea of ""ghost symbolic regions""; that i had earlier. But, to summarize a bit, in our current case, however, the typestate we're; looking for is the contents of the heap. And when we try to model such; typestates (complex in this specific manner, i.e. hea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:13972,variab,variables,13972,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['variab'],['variables']
Modifiability,"gram to adjust; the scale of the function. In case of extended p.d.f.s, the adjustment is made with the expected; number of events, rather than the observed number of events. Tutorial macro rf602_chi2fit.C has been updated to use this new interface. Chi-squared fits to X-Y datasets now possible; In addition to the ability to perform chi-squared fits to histograms it is now also possible; to perform chi-squared fits to unbinned datasets containing a series of X and Y values; with associated errors on Y and optionally on X. These 'X-Y' chi-squared fits are interfaced through newly added method; RooAbsReal::chi2FitTo(const RooDataSet&,...). By default the event weight is; interpreted as the 'Y' value, but an YVar() argument can designate any other; dataset column as Y value. If X errors are defined, one can choose to integrate the fitted; function over the range of the X errors, rather than taking the central value by adding; an Integrate(true) argument to chi2FitTo(); Two new arguments, StoreError(const RooArgSet&) and StoreAsymError(const RooArgSet&); have been added to the RooDataSet constructor to simplify the process of storing the errors; of X and Y variables along with their values in a dataset. The newly added tutorial macro rf609_xychi2fit.C illustrates the use of all this; new functionality. Uniform interface for creation of (profile likelihoods) and chi-squared from p.d.f.s; It is now recommended to use the method RooAbsPdf::createNLL(RooAbsData&,...) to; create a likelihood from a p.d.f and a dataset rather than constructing a RooNLLVar; object directly. This is because part of the likelihood construction functionality such a using; multiple Range()s, or the inclusion for constraint terms are only available through; createNLL(). To promote the consistency of this interface, a similar method RooAbsReal::createChi2(); has been added to construct chi-squared functions of a dataset and a function or p.d.f. Along the same lines, it is recommended to use RooAbsRe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:9074,variab,variables,9074,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['variab'],['variables']
Modifiability,grams are unsuitable for; performance measurements. Setting the `TEST_SUITE_BENCHMARKING_ONLY` CMake; option to `ON` will disable them. Configuration; -------------. The test-suite has configuration options to customize building and running the; benchmarks. CMake can print a list of them:. ```bash; % cd test-suite-build; # Print basic options:; % cmake -LH; # Print all options:; % cmake -LAH; ```. ### Common Configuration Options. - `CMAKE_C_FLAGS`. Specify extra flags to be passed to C compiler invocations. The flags are; also passed to the C++ compiler and linker invocations. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html). - `CMAKE_C_COMPILER`. Select the C compiler executable to be used. Note that the C++ compiler is; inferred automatically i.e. when specifying `path/to/clang` CMake will; automatically use `path/to/clang++` as the C++ compiler. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html). - `CMAKE_Fortran_COMPILER`. Select the Fortran compiler executable to be used. Not set by default and not; required unless running the Fortran Test Suite. - `CMAKE_BUILD_TYPE`. Select a build type like `OPTIMIZE` or `DEBUG` selecting a set of predefined; compiler flags. These flags are applied regardless of the `CMAKE_C_FLAGS`; option and may be changed by modifying `CMAKE_C_FLAGS_OPTIMIZE` etc. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html](https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html). - `TEST_SUITE_FORTRAN`. Activate that Fortran tests. This is a work in progress. More information can be; found in the [Flang documentation](https://flang.llvm.org/docs/FortranLLVMTestSuite.html). - `TEST_SUITE_RUN_UNDER`. Prefix test invocations with the given tool. This is typically used to run; cross-compiled tests within a simulator tool. - `TEST_SU,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:4577,variab,variable,4577,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['variab'],['variable']
Modifiability,"gration; ==================. :program:`clang-format` cannot be used as a text filter with BBEdit, but works; well via a script. The AppleScript to do this integration can be found at; `clang/tools/clang-format/clang-format-bbedit.applescript`; place a copy in; `~/Library/Application Support/BBEdit/Scripts`, and edit the path within it to; point to your local copy of :program:`clang-format`. With this integration you can select the script from the Script menu and; :program:`clang-format` will format the selection. Note that you can rename the; menu item by renaming the script, and can assign the menu item a keyboard; shortcut in the BBEdit preferences, under Menus & Shortcuts. CLion Integration; =================. :program:`clang-format` is integrated into `CLion <https://www.jetbrains; .com/clion/>`_ as an alternative code formatter. CLion turns it on; automatically when there is a ``.clang-format`` file under the project root.; Code style rules are applied as you type, including indentation,; auto-completion, code generation, and refactorings. :program:`clang-format` can also be enabled without a ``.clang-format`` file.; In this case, CLion prompts you to create one based on the current IDE settings; or the default LLVM style. Visual Studio Integration; =========================. Download the latest Visual Studio extension from the `alpha build site; <https://llvm.org/builds/>`_. The default key-binding is Ctrl-R,Ctrl-F. Visual Studio Code Integration; ==============================. Get the latest Visual Studio Code extension from the `Visual Studio Marketplace <https://marketplace.visualstudio.com/items?itemName=xaver.clang-format>`_. The default key-binding is Alt-Shift-F. Git integration; ===============. The script `clang/tools/clang-format/git-clang-format` can be used to; format just the lines touched in git commits:. .. code-block:: console. % git clang-format -h; usage: git clang-format [OPTIONS] [<commit>] [<commit>|--staged] [--] [<file>...]. If zero or o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:9512,refactor,refactorings,9512,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['refactor'],['refactorings']
Modifiability,gregate initialization with parenthesized string literal; Unknown. 1498; dup; Lifetime of temporaries in range-based for; Unknown. 1499; drafting; Missing case for deleted move assignment operator; Not resolved. 1500; CD6; Name lookup of dependent conversion function; Unknown. 1501; NAD; Nested braces in list-initialization; Unknown. 1502; CD3; Value initialization of unions with member initializers; Unknown. 1503; CD3; Exceptions during copy to exception object; Unknown. 1504; CD3; Pointer arithmetic after derived-base conversion; Unknown. 1505; dup; Direct binding of reference to temporary in list-initialization; Unknown. 1506; CD3; Value category of initializer_list object; Unknown. 1507; CD3; Value initialization with trivial inaccessible default constructor; Unknown. 1508; C++14; Template initializer-list constructors; Unknown. 1509; C++14; Definition of “non-template function”; Unknown. 1510; CD3; cv-qualified references via decltype; Unknown. 1511; CD3; const volatile variables and the one-definition rule; Unknown. 1512; CD3; Pointer comparison vs qualification conversions; Clang 4. 1513; drafting; initializer_list deduction failure; Not resolved. 1514; C++14; Ambiguity between enumeration definition and zero-length bit-field; Clang 11. 1515; CD3; Modulo 2n arithmetic for implicitly-unsigned types; Unknown. 1516; CD3; Definition of “virtual function call”; Unknown. 1517; drafting; Unclear/missing description of behavior during construction/destruction; Not resolved. 1518; CD4; Explicit default constructors and copy-list-initialization; Clang 4. 1519; NAD; Conflicting default and variadic constructors; Unknown. 1520; NAD; Alias template specialization vs pack expansion; Unknown. 1521; drafting; T{expr} with reference types; Not resolved. 1522; CD3; Access checking for initializer_list array initialization; Unknown. 1523; CD5; Point of declaration in range-based for; Unknown. 1524; drafting; Incompletely-defined class template base; Not resolved. 1525; NAD; Arr,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:101617,variab,variables,101617,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['variab'],['variables']
Modifiability,"gression; performance. Presently, the Category method works for; classification only, but regression will follow soon. Please; contact us if urgently needed. An example scripts and data files illustrating how the new; Category method is configured and used. Please check the macros; test/TMVAClassificationCategory.C and; test/TMVAClassificationCategoryApplication.C or the; corresponding executables.; Regression functionality for gradient boosted trees using a Huber loss function. Comments. On Input Data: . New TMVA event vector building. The code for splitting the input; data into training and test samples for all classes and the; mixing of those samples to one training and one test sample has; been rewritten completely. The new code is more performant and; has a clearer structure. This fixes several bugs which have been; reported by the TMVA users. On Minimization: . Variables, targets and spectators are now checked if they are; constant. (The execution of TMVA is stopped for variables and; targets, a warning is given for spectators.). On Regression:; ; The analysis type is no longer defined by calling a dedicated; TestAllMethods-member-function of the Factory, but with the; option ""AnalysisType"" in the Factory. The default value is; ""Auto"" where TMVA tries to determine the most suitable analysis; type from the targets and classes the user has defined. Other; values are ""regression"", ""classification"" and ""multiclass"" for; the forthcoming multiclass classification.; Missing regression evaluation plots for training sample were; added. On Cut method:. Removed obsolete option ""FVerySmart"" from Cuts method. On MLP method:; ; Display of convergence information in the progress bar for MLP during training. Creation of animated gifs for MLP convergence monitoring (please; contact authors if you want to do this). On Datasets: . Checks are performed if events are unvoluntarily cut by using a; non-filled array entry (e.g. ""arr[4]"" is used, when the array; has not always at least",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html:1791,variab,variables,1791,tmva/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html,2,['variab'],['variables']
Modifiability,"gs: ""``-f``"" to force writing binary output to a; terminal, ""``--quiet``"" to enable quiet mode, and ""``-q``"" for backwards; compatibility with some of our users. We can support these by declaring options; of boolean type like this:. .. code-block:: c++. cl::opt<bool> Force (""f"", cl::desc(""Enable binary output on terminals""));; cl::opt<bool> Quiet (""quiet"", cl::desc(""Don't print informational messages""));; cl::opt<bool> Quiet2(""q"", cl::desc(""Don't print informational messages""), cl::Hidden);. This does what you would expect: it declares three boolean variables; (""``Force``"", ""``Quiet``"", and ""``Quiet2``"") to recognize these options. Note; that the ""``-q``"" option is specified with the ""`cl::Hidden`_"" flag. This; modifier prevents it from being shown by the standard ""``-help``"" output (note; that it is still shown in the ""``-help-hidden``"" output). The CommandLine library uses a `different parser`_ for different data types.; For example, in the string case, the argument passed to the option is copied; literally into the content of the string variable... we obviously cannot do that; in the boolean case, however, so we must use a smarter parser. In the case of; the boolean parser, it allows no options (in which case it assigns the value of; true to the variable), or it allows the values ""``true``"" or ""``false``"" to be; specified, allowing any of the following inputs:. ::. compiler -f # No value, 'Force' == true; compiler -f=true # Value specified, 'Force' == true; compiler -f=TRUE # Value specified, 'Force' == true; compiler -f=FALSE # Value specified, 'Force' == false. ... you get the idea. The `bool parser`_ just turns the string values into; boolean values, and rejects things like '``compiler -f=foo``'. Similarly, the; `float`_, `double`_, and `int`_ parsers work like you would expect, using the; '``strtol``' and '``strtod``' C library calls to parse the string value into the; specified data type. With the declarations above, ""``compiler -help``"" emits this:. ::. USA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:9991,variab,variable,9991,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variable']
Modifiability,"gs: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are verified. It is the; responsibility of the programmer to ensure that this verification was indeed; correct. Please note that `csa_mark_sanitized` function is only declared and; used during Clang Static Analysis and skipped in (production) builds. Further examples of injection vulnerabilities this checker can find. .. code-block:: c. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:69496,variab,variable,69496,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['variab'],['variable']
Modifiability,"guage mode and issues a diagnostic if not.; * ``existsInTarget``, which checks if the attribute is permitted for the given; target. To see a working example of an attribute plugin, see `the Attribute.cpp example; <https://github.com/llvm/llvm-project/blob/main/clang/examples/Attribute/Attribute.cpp>`_. Putting it all together; =======================. Let's look at an example plugin that prints top-level function names. This; example is checked into the clang repository; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:4722,plugin,plugin,4722,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,2,['plugin'],['plugin']
Modifiability,"guration. All the local environment files are loaded at the time of the; client's startup following a certain order. - `common.before`. - `local.before`. - `local.conf`. - `$VafConf_LocalPodLocation/PoD_env.sh`. - `common.after`. - `local.after`. The `common.*` files are sourced both for the local and the remote; environment. This might be convenient to avoid repeating the same; configuration in different places. Each file is looked for first in the system-wide directory and then in; the user's directory. If a configuration file does not exist, it is; silently skipped. The `$VafConf_LocalPodLocation/PoD_env.sh` environment script, provided; with each PROOF on Demand installation, *must exist*: without this file,; the VAF client won't start. ### List of VAF-specific variables. There are some special variables that need to be set in one of the above; configuration files. `$VafConf_LocalPodLocation`; : Full path to the PoD installation on the client. > The `$VafConf_LocalPodLocation` variable must be set before the; > `PoD_env.sh` script gets sourced, so set it either in; > `common.before`, `local.before` or `local.conf`. Since PoD is; > usually system-wide installed, its location is normally; > system-wide set in either the `local.conf` file by the system; > administrator. `$VafConf_RemotePodLocation`; : Full path to the PoD installation on the VAF master node. *Note: this variable should be set in the configuration files for; the local environment despite it refers to a software present on the; remote nodes.*. `$VafConf_PodRms` *(optional)*; : Name of the Resource Management System used for submitting PoD jobs.; Run `pod-submit -l` to see the possible values. If not set, defaults to `condor`. `$VafConf_PodQueue` *(optional)*; : Queue name where to submit PoD jobs. If no queue has been given, the default one configured on your RMS; will be used. ### Remote environment configuration. All the PoD commands sent to the VAF master will live in the environment; loaded via us",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:3527,variab,variable,3527,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['variab'],['variable']
Modifiability,"guration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cache; scripts to provide more complex options. By default, only a few CMake options will be passed between stages.; The list, called _BOOTSTRAP_DEFAULT_PASSTHROUGH, is defined in clang/CMakeLists.txt.; To force the passing of the variables between stages, use the -DCLANG_BOOTSTRAP_PASSTHROUGH; CMake option, each variable separated by a "";"". As example:. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DCLANG_BOOTSTRAP_PASSTHROUGH=""CMAKE_INSTALL_PREFIX;CMAKE_VERBOSE_MAKEFILE"" \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. CMake options starting by ``BOOTSTRAP_`` will be passed only to the stage2 build.; This gives the opportunity to use Clang specific build flags.; For example, the following CMake call will enabled '-fno-addrsig' only during; the stage2 build for C and C++. .. code-block:: console. $ cmake [..] ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:1925,config,configurations,1925,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['config'],['configurations']
Modifiability,"gy, but with the tag storage (shadow); provided by the hardware. A quick overview of MTE hardware capabilities:. * Every 16 aligned bytes of memory can be assigned a 4-bit Allocation Tag.; * Every pointer can have a 4-bit Address Tag that is in its most significant byte.; * Most memory access instructions generate an exception if Address Tag != Allocation Tag.; * Special instructions are provided for fast tag manipulation. Stack instrumentation; =====================. Stack-based memory errors are detected by updating Allocation Tag for; each local variable to a random value at the start of its lifetime,; and resetting it to the stack pointer Address Tag at the end of; it. Unallocated stack space is expected to match the Address Tag of; SP; this allows to skip tagging of any variable when memory safety can; be statically proven. Allocating a truly random tag for each stack variable in a large; function may incur significant code size overhead, because it means; that each variable's address is an independent, non-rematerializable; value; thus a function with N local variables will have extra N live; values to keep through most of its life time. For this reason MemTagSanitizer generates at most one random tag per; function, called a ""base tag"". Other stack variables, if there are; any, are assigned tags at a fixed offset from the base. Please refer to `this document; <https://github.com/google/sanitizers/wiki/Stack-instrumentation-with-ARM-Memory-Tagging-Extension-(MTE)>`_; for more details about stack instrumentation. Heap tagging; ============. **Note:** this part is not implemented as of Oct 2019. MemTagSanitizer will use :doc:`ScudoHardenedAllocator`; with additional code to update memory tags when. * New memory is obtained from the system.; * An allocation is freed. There is no need to change Allocation Tags for the bulk of the; allocated memory in malloc(), as long as a pointer with the matching; Address Tag is returned. More information; ================. * `LLV",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst:2258,variab,variable,2258,interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst,3,['variab'],"['variable', 'variables']"
Modifiability,"h 256 threads due to reduced lock contention. ## I/O Libraries. - Exclusive use of the global lock is reduced or migrated to finer grained read and write locks in a few hotspots that occur during file opening/closing or task initialization in RDataFrame. This can lead to O(100x) improvements for some typical RDataFrame scenarios with 256 threads due to massively reduced lock contention. ## TTree Libraries. - `TTree` now supports the inclusion of leaves of types `long` and `unsigned long` (and therefore also `std::size_t` on most systems) also for branches in ""leaflist mode"". The corresponding leaflist letters are 'G' and 'g'.; - when looping over a `TTree` with a friend with a larger number of entries, `TTreeReader` now ends the event loop when the entries in the _main_ `TTree` are exhausted, consistently with other interfaces. See [#6518](https://github.com/root-project/root/issues/6518) for more details.; - `TTreeProcessorMT::SetMaxTasksPerFilePerWorker` is now deprecated in favor of the more flexible and newly introduced `TTreeProcessorMT::SetTasksPerWorkerHint`. See the relevant entries in our reference guide for more information.; - The name of the sub-branches of a split collection no longer have 2 consecutive dots if the top level branche name has a trailing dot. The name of the collection's index leaf also no longer include the dot. For example for ""t."" the names where ""t._"" and ""t..fValue"" and are now ""t_"" and ""t.fValue"". . ## RDataFrame. ### New features. - Introduce `ROOT::RDF::RunGraphs`, which allows to compute the results of multiple `RDataFrame`s (or better, multiple independent computation graphs) concurrently while sharing the same thread pool. The computation may be more efficient than running the `RDataFrame`s sequentially if an analysis consists of several computation graphs that individually do not fully utilize the available resources. See e.g. [this tutorial](https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html) for an example usage.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:5241,flexible,flexible,5241,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['flexible'],['flexible']
Modifiability,"h as TH1::Fit.; ; The fit data are decoupled from the fitter class and described by the dedicated fit data classes like the ROOT::Fit::BinData for bin data containing coordinate values of any dimensions, bin content values and optionally errors in coordinate and bin content, and ROOT::Fit::UnBinData classes for any dimension un-bin data.; The fitter class, ROOT::Fit::Fitter, provides the functionality for fitting those data with any model function implementing the parametric function interface, ROOT::Math::IParamMultiFunction. Fit methods such as least square, bin and un-bin likelihood are supported. The fit solution is then found by using the ROOT::Math::Minimizer interface class and the results are stored in the ROOT::Fit::FitResult class. Fit parameter can be configured individually using the ROOT::Fit::FitParameterSettings class.; ; Various implementation of the minimizer interface can be used automatically using the ROOT plug-in manager mechanism, including the linear fitter for a fast and direct solution, in case of a linear least square model, or by using Minuit, Minuit2 or GSL minimization methods provided by the MathMore library. Functions for filling the new ROOT::Fit::BinData classes with all the histogram and graph types have been added in the histogram library (libHist) and graph library:; ; ROOT::Fit::FillData( BinData & , const TH1 *, TF1 * ) for histograms (in libHist); ROOT::Fit::FillData( BinData & , const TGraph2D *, TF1 * ) for 2D graphs (in libHist); ROOT::Fit::FillData( BinData & , const TGraph *, TF1 * ) for all 1D graphs (in libGraf); ROOT::Fit::FillData( BinData & , const TMultiGraph *, TF1 * ) for multi-graphs (in libGraf); . MathCore Numerical Algorithms. Classes implementing numerical methods which can be used by all the other ROOT library have been added in MathCore. These originate mainly from methods present previously in the implementation of the TF1 class. Now they can be used also outside this class. In addition, in order to have a c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:5221,plug-in,plug-in,5221,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['plug-in'],['plug-in']
Modifiability,"h as ``'\0'`` or ``NULL``, but it will match against macros that; expand to 0. The matcher will also not match against calls to the; overloaded operator ``'+'``, as there is a separate ``operatorCallExpr``; matcher to handle overloaded operators. There are AST matchers to match all the different nodes of the AST,; narrowing matchers to only match AST nodes fulfilling specific criteria,; and traversal matchers to get from one kind of AST node to another. For; a complete list of AST matchers, take a look at the `AST Matcher; References <LibASTMatchersReference.html>`_. All matcher that are nouns describe entities in the AST and can be; bound, so that they can be referred to whenever a match is found. To do; so, simply call the method ``bind`` on these matchers, e.g.:. .. code-block:: c++. variable(hasType(isInteger())).bind(""intvar""). Step 2: Using AST matchers; ==========================. Okay, on to using matchers for real. Let's start by defining a matcher; which will capture all ``for`` statements that define a new variable; initialized to zero. Let's start with matching all ``for`` loops:. .. code-block:: c++. forStmt(). Next, we want to specify that a single variable is declared in the first; portion of the loop, so we can extend the matcher to. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl())))). Finally, we can add the condition that the variable is initialized to; zero. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))). It is fairly easy to read and understand the matcher definition (""match; loops whose init portion declares a single variable which is initialized; to the integer literal 0""), but deciding that every piece is necessary; is more difficult. Note that this matcher will not match loops whose; variables are initialized to ``'\0'``, ``0.0``, ``NULL``, or any form of; zero besides the integer 0. The last step is giving the matcher a name and binding the ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:7573,variab,variable,7573,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['variab'],['variable']
Modifiability,"h basic block is a node in the graph, and each node contains the instructions; in the block. Similarly, there also exists ``Function::viewCFGOnly()`` (does; not include the instructions), the ``MachineFunction::viewCFG()`` and; ``MachineFunction::viewCFGOnly()``, and the ``SelectionDAG::viewGraph()``; methods. Within GDB, for example, you can usually use something like ``call; DAG.viewGraph()`` to pop up a window. Alternatively, you can sprinkle calls to; these functions in your code in places you want to debug. Getting this to work requires a small amount of setup. On Unix systems; with X11, install the `graphviz <http://www.graphviz.org>`_ toolkit, and make; sure 'dot' and 'gv' are in your path. If you are running on macOS, download; and install the macOS `Graphviz program; <http://www.pixelglow.com/graphviz/>`_ and add; ``/Applications/Graphviz.app/Contents/MacOS/`` (or wherever you install it) to; your path. The programs need not be present when configuring, building or; running LLVM and can simply be installed when needed during an active debug; session. ``SelectionDAG`` has been extended to make it easier to locate *interesting*; nodes in large complex graphs. From gdb, if you ``call DAG.setGraphColor(node,; ""color"")``, then the next ``call DAG.viewGraph()`` would highlight the node in; the specified color (choices of colors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ==============",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:53797,config,configuring,53797,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['config'],['configuring']
Modifiability,"h function pointers,; object pointers, and pointer offsets, into the intermediate representation; (IR) as generated by Numba.; A future version may integrate Cling-generated IR directly into Numba IR (or; vice versa), e.g. if the C++ code is exposed from (precompiled) headers.; This would allow inlining of C++ code into Numba traces, for further; expected speedups. Why Numba?; ----------. The advertised premise of Numba is that it ""makes Python code fast.""; However, there is a much more compelling reason: Numba allows developers to; stay in their chosen ecosystem, be it Python or C++, in mixed environments,; without paying for their choice in lost performance.; For example, a Python developer using Numba does not need to rewrite a kernel; into C++ just to run performantly in a C++ framework.; Similarly, a C++ developer can use Numba to compile and create function; pointers to Python code for easy, performant, access.; This becomes even more compelling if the deployment target is a GPU, which; would otherwise certainly require a rewrite of the Python code.; Add that Numba, as a JIT-compiler, is fully run-time just like ``cppyy``,; and the use case for integration is clear.; (Numba does not currently provide support for C++.). Usage; -------. ``cppyy`` does not use Numba extension hooks to minimize accidental; dependencies.; Instead, it requires that the extensions are loaded explicitly by any code; that uses it::. import cppyy.numba_ext. After that, Numba is able to trace ``cppyy`` bound code when applying the; usual ``numba.njit`` decorator. Numba type declarations are done lazily, with the ``numba_ext`` module only; initially registering hooks on proxy base classes, to keep overheads in; Numba's type-resolution to a minimum.; On use in a JITed trace, each C++ type or function call is refined to the; actual, concrete types and type-specific overloads, with templates; instantiated as-needed.; Where possible, lowering is kept generic to reduce the number of callbacks; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst:2033,rewrite,rewrite,2033,bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,1,['rewrite'],['rewrite']
Modifiability,"h names or identical; branch names. By default collections have a name equal to the; corresponding class name, e.g. the default name of **`TList`** is; ""`TList`"". ## Examples for Writing and Reading Trees. The following sections are examples of writing and reading trees; increasing in complexity from a simple tree with a few variables to a; tree containing folders and complex Event objects. Each example has a; named script in the `$ROOTSYS/tutorials/tree` directory. They are called; tree1.C to tree4.C. The examples are:. - `tree1.C`: a tree with several simple (integers and floating point); variables. - `tree2.C`: a tree built from a C structure (`struct`). This example; uses the `Geant3` C wrapper as an example of a FORTRAN common block; ported to C with a C structure. - `tree3.C:` in this example, we will show how to extend a tree with a; branch from another tree with the Friends feature. These trees have; branches with variable length arrays. Each entry has a variable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:33916,variab,variable,33916,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,2,['variab'],"['variable', 'variables']"
Modifiability,"h operand; specifies how many of the following variable operands are considered; function call arguments. The remaining variable number of operands are; the ``live values`` for which locations will be recorded in the stack; map. Semantics:; """""""""""""""""""". The patch point intrinsic generates a stack map. It also emits a; function call to the address specified by ``<target>`` if the address; is not a constant null. The function call and its arguments are; lowered according to the calling convention specified at the; intrinsic's callsite. Variants of the intrinsic with non-void return; type also return a value according to calling convention. On PowerPC, note that ``<target>`` must be the ABI function pointer for the; intended target of the indirect call. Specifically, when compiling for the; ELF V1 ABI, ``<target>`` is the function-descriptor address normally used as; the C/C++ function-pointer representation. Requesting zero patch point arguments is valid. In this case, all; variable operands are handled just like; ``llvm.experimental.stackmap.*``. The difference is that space will; still be reserved for patching, a call will be emitted, and a return; value is allowed. The location of the arguments are not normally recorded in the stack; map because they are already fixed by the calling convention. The; remaining ``live values`` will have their location recorded, which; could be a register, stack location, or constant. A special calling; convention has been introduced for use with stack maps, anyregcc,; which forces the arguments to be loaded into registers but allows; those register to be dynamically allocated. These argument registers; will have their register locations recorded in the stack map in; addition to the remaining ``live values``. The patch point also emits nops to cover at least ``<numBytes>`` of; instruction encoding space. Hence, the client must ensure that; ``<numBytes>`` is enough to encode a call to the target address on the; supported targets. If the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:9056,variab,variable,9056,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['variab'],['variable']
Modifiability,"h this nonsense for my; front-end? Wouldn't it be better if I just did SSA construction; directly, avoiding use of the mem2reg optimization pass? In short, we; strongly recommend that you use this technique for building SSA form,; unless there is an extremely good reason not to. Using this technique; is:. - Proven and well tested: clang uses this technique; for local mutable variables. As such, the most common clients of LLVM; are using this to handle a bulk of their variables. You can be sure; that bugs are found fast and fixed early.; - Extremely Fast: mem2reg has a number of special cases that make it; fast in common cases as well as fully general. For example, it has; fast-paths for variables that are only used in a single block,; variables that only have one assignment point, good heuristics to; avoid insertion of unneeded phi nodes, etc.; - Needed for debug info generation: `Debug information in; LLVM <../../SourceLevelDebugging.html>`_ relies on having the address of; the variable exposed so that debug info can be attached to it. This; technique dovetails very naturally with this style of debug info. If nothing else, this makes it much easier to get your front-end up and; running, and is very simple to implement. Let's extend Kaleidoscope with; mutable variables now!. Mutable Variables in Kaleidoscope; =================================. Now that we know the sort of problem we want to tackle, let's see what; this looks like in the context of our little Kaleidoscope language.; We're going to add two features:. #. The ability to mutate variables with the '=' operator.; #. The ability to define new variables. While the first item is really what this is about, we only have; variables for incoming arguments as well as for induction variables, and; redefining those only goes so far :). Also, the ability to define new; variables is a useful thing regardless of whether you will be mutating; them. Here's a motivating example that shows how we could use these:. ::. # Def",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:9895,variab,variable,9895,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"h two deviations. LLVM uses a PC relative; (PIC) or static addressing for accessing global values, so no TOC (r2) is; used. Second, r31 is used as a frame pointer to allow dynamic growth of a stack; frame. LLVM takes advantage of having no TOC to provide space to save the frame; pointer in the PowerPC linkage area of the caller frame. Other details of; PowerPC ABI can be found at `PowerPC ABI; <http://developer.apple.com/documentation/DeveloperTools/Conceptual/LowLevelABI/Articles/32bitPowerPC.html>`_\; . Note: This link describes the 32 bit ABI. The 64 bit ABI is similar except; space for GPRs are 8 bytes wide (not 4) and r13 is reserved for system use. Frame Layout; ^^^^^^^^^^^^. The size of a PowerPC frame is usually fixed for the duration of a function's; invocation. Since the frame is fixed size, all references into the frame can be; accessed via fixed offsets from the stack pointer. The exception to this is; when dynamic alloca or variable sized arrays are present, then a base pointer; (r31) is used as a proxy for the stack pointer and stack pointer is free to grow; or shrink. A base pointer is also used if llvm-gcc is not passed the; -fomit-frame-pointer flag. The stack pointer is always aligned to 16 bytes, so; that space allocated for altivec vectors will be properly aligned. An invocation frame is laid out as follows (low memory at top):. :raw-html:`<table border=""1"" cellspacing=""0"">`; :raw-html:`<tr>`; :raw-html:`<td>Linkage<br><br></td>`; :raw-html:`</tr>`; :raw-html:`<tr>`; :raw-html:`<td>Parameter area<br><br></td>`; :raw-html:`</tr>`; :raw-html:`<tr>`; :raw-html:`<td>Dynamic area<br><br></td>`; :raw-html:`</tr>`; :raw-html:`<tr>`; :raw-html:`<td>Locals area<br><br></td>`; :raw-html:`</tr>`; :raw-html:`<tr>`; :raw-html:`<td>Saved registers area<br><br></td>`; :raw-html:`</tr>`; :raw-html:`<tr style=""border-style: none hidden none hidden;"">`; :raw-html:`<td><br></td>`; :raw-html:`</tr>`; :raw-html:`<tr>`; :raw-html:`<td>Previous Frame<br><br></td>`; :ra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:95450,variab,variable,95450,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['variab'],['variable']
Modifiability,"h) is no longer necessary; when using ExpandCreateFast. New Thread Pool class. A first version of TThreadPool class has been introduced.; This class implements a Thread Pool pattern.; So far it supports only one type of queue - FIFO. Thread library. Reduces risk of internal dead lock by using a private internal lock to protect the internals of TThread, rather than using TThread::Lock. New header TThreadSlots.h to centralize and formalize the use of the TThread local memory slots amongst the ROOT packages. Global Variables. The global values gPad, gVirtualX, gInterpreter, gDirectory and gFile; are now all accessed via a static function of their respective class. The; access is made transparent via a CPP macro.; The access is now also made transparent from the CINT and python prompt.; gPad, gVirtualX and gInterpreter are now accessible even when their value; is zero and they now properly support tab completion.; See the important note in the I/O section on gDirectory and gFile which; are now thread local. Meta. The new interface TDictionary::GetDictionary(const char*) offers a; single entry point to query the type based on its name, conveniently combining; TDataType and TClass queries. It does name normalization (removing std etc). Add the ability to explicitly forbid (or allow) the splitting of a class; (TClass::SetSplit) so that user can inforce the use of a custom streamer in all possible split cases. Resolve several issues with the creation of StreamerInfo for abstract classes. When looking for the value corresponding to an enum type, skip global that are not enums. (This improves the speed of TFile::Open by 60%). TStyle. The Modern style has now a transparent background for the histogram title. Misc. In the root executable, auto-detect command line arguments that are local root files even if their name does not end with "".root"". If home directory is not correctly set in pw file or user is not known, use the HOME shell variable to find the desired home directory. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html:4332,variab,variable,4332,core/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html,2,['variab'],['variable']
Modifiability,"h.; kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch.; kMatch (0) : perfect match.; kMatchConversion (1) : match with (I/O) conversion.; kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection.; kMakeClass (3) : MakeClass mode so we can not check.; kVoidPtr (4) : void* passed so no check was made.; kNoCheck (5) : Underlying TBranch not yet available so no check was made. Insure that the TTreeCloner (fast merging) is able to also copy 'uninitialized' TStreamerInfo describing abstract classes.; Repair several use case of splitting collection of pointers (especially when their split level is 1).; Several run-time performance improvements.; In TTree::Fill use fZipBytes instead of fTotBytes for deciding when to flush or autosave.; Properly handle TTree aliases containing array indices.; Fix the default sorting order of baskets when the TTree is an older in-memory TTree.; Enhance the sort order to use the 'entry number' when the seek position are equal.; Consequently the default sort order for an older in-memory TTree is now; essentially kSortBasketsByEntry rather than kSortBasketsByBranch (old 'correct' sort; order) or 'random' (the 'broken' sort order prior to this release). IMPORTANT enhancement in TTree::Fill:; Slides from a recent seminar describing the main features of ROOT IO and Trees and the recent; improvements described below are available at; http://root.cern/files/brun_lcgapp09.pptx ; or; http://root.cern/files/brun_lcgapp09.pdf .; The baskets are flushed and the Tree header saved at regular intervals (See AutoFlush and OptimizeBaskets); When the amount of data written so far (fTotBytes) is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region.; When the first call to flush the baskets happens, we also take this opportunity to optim",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v526/index.html:2830,Enhance,Enhance,2830,tree/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v526/index.html,1,['Enhance'],['Enhance']
Modifiability,"h/phpBB3/viewtopic.php?f=3&t=16937&p=72314#p72314). ### TPaletteAxis. - The histogram Z axis title is now painted along the palette axis. ### TAxis. - The Axis has a new public bit `TAxis::kCanExtend`, which control the axis extensions (for example in case of time axis) and used to; replace the old bit `TH1::kCanRebin` (see below).; Note that this bit is automatically set when the axis has labels associated to each bin. In this case the axis becomes alphanumeric and; there is no more relation to the observed quantities. Note that when an axis is alphanumeric the mean and the rms of the histograms are not anymore; coputed and they are set to zero. ### TH1. - The bit `TH1::kCanRebin` used to extend the histogram axes is now deprecated. The bit exists still in ROOT 6.0 but it has no effect.; One should use now the new function `TH1::SetCanExtend(..)` passing the axis (using the appropriate enumeration), which needs to be extended.; In addition to extend each axis individually, the function can be used also to enable/disable extension for all axes.; For example `TH1::SetCanExtend(TH1::kXaxis)` will make extendable only the X axis; `TH1::SetCanExtend(TH1::kAllAxes)` will; make extendable all the axes (this is the same functionality of the previous function `SetBit(TH1::kCanRebin)` and; `TH1::SetCanExtend(TH1::kNoAxis)` will remove the extendable functionality to all the axes (equivalent to the old `ResetBit(TH1::kCanRebin)`).; The functionality of `TestBit(TH1::kCanRebin)` is now replaced by `TH1::CanExtendAllAxis()`. - An histogram filled with weights different than one has now automatically the sum of the weight squared stored inside, without the need to call anymore; `TH1::Sumw2()`. As a consequences an histogram filled with weights will always draw the errors by default. If one desire to continue having the histogram drawn; without the errors, one should use the `hist` option: `h.Draw(""hist"")`.; If, for memory reason, one does not want to remove the internal array sto",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md:7376,extend,extend,7376,hist/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md,1,['extend'],['extend']
Modifiability,"h/to/clang/bin/../lib/LLVMgold.so: could not load plugin library: /path/to/clang/bin/../lib/LLVMgold.so: cannot open shared object file: No such file or directory. Then either gold was not configured with plugins enabled, or clang; was not built with ``-DLLVM_BINUTILS_INCDIR`` set properly. See; the instructions for the; `LLVM gold plugin <https://llvm.org/docs/GoldPlugin.html#how-to-build-it>`_. Controlling Backend Parallelism; -------------------------------; .. _parallelism:. By default, the ThinLTO link step will launch as many; threads in parallel as there are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:4176,plugin,plugin-opt,4176,interpreter/llvm-project/clang/docs/ThinLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst,1,['plugin'],['plugin-opt']
Modifiability,h; TMVA/ResultsRegression.h; TMVA/ROCCalc.h; TMVA/ROCCurve.h; TMVA/RootFinder.h; TMVA/RuleCut.h; TMVA/RuleEnsemble.h; TMVA/RuleFitAPI.h; TMVA/RuleFit.h; TMVA/RuleFitParams.h; TMVA/Rule.h; TMVA/SdivSqrtSplusB.h; TMVA/SeparationBase.h; TMVA/SimulatedAnnealingFitter.h; TMVA/SimulatedAnnealing.h; TMVA/SVEvent.h; TMVA/SVKernelFunction.h; TMVA/SVKernelMatrix.h; TMVA/SVWorkingSet.h; TMVA/TActivationChooser.h; TMVA/TActivation.h; TMVA/TActivationIdentity.h; TMVA/TActivationRadial.h; TMVA/TActivationReLU.h; TMVA/TActivationSigmoid.h; TMVA/TActivationTanh.h; TMVA/Timer.h; TMVA/TNeuron.h; TMVA/TNeuronInputAbs.h; TMVA/TNeuronInputChooser.h; TMVA/TNeuronInput.h; TMVA/TNeuronInputSqSum.h; TMVA/TNeuronInputSum.h; TMVA/Tools.h; TMVA/TrainingHistory.h; TMVA/TransformationHandler.h; TMVA/TSpline1.h; TMVA/TSpline2.h; TMVA/TSynapse.h; TMVA/Types.h; TMVA/VariableDecorrTransform.h; TMVA/VariableGaussTransform.h; TMVA/VariableIdentityTransform.h; TMVA/VariableImportance.h; TMVA/VariableInfo.h; TMVA/VariableNormalizeTransform.h; TMVA/VariablePCATransform.h; TMVA/VariableRearrangeTransform.h; TMVA/VariableTransformBase.h; TMVA/VariableTransform.h; TMVA/VarTransformHandler.h; TMVA/Version.h; TMVA/Volume.h; # TMVA/DNN/Adadelta.h; # TMVA/DNN/Adagrad.h; # TMVA/DNN/Adam.h; # TMVA/DNN/BatchNormLayer.h; # TMVA/DNN/DataLoader.h; # TMVA/DNN/DeepNet.h; # TMVA/DNN/DenseLayer.h; # TMVA/DNN/DLMinimizers.h; # TMVA/DNN/Functions.h; # TMVA/DNN/GeneralLayer.h; # TMVA/DNN/ReshapeLayer.h; # TMVA/DNN/RMSProp.h; # TMVA/DNN/SGD.h; # TMVA/DNN/TensorDataLoader.h; # TMVA/DNN/CNN/ContextHandles.h; # TMVA/DNN/CNN/ConvLayer.h; # TMVA/DNN/CNN/MaxPoolLayer.h; # TMVA/DNN/RNN/RNNLayer.h; # TMVA/DNN/Architectures/Reference.h; # TMVA/DNN/Architectures/Reference/DataLoader.h; # TMVA/DNN/Architectures/Reference/TensorDataLoader.h; # TMVA/DNN/Architectures/Cpu.h; # TMVA/DNN/Architectures/Cpu/CpuBuffer.h; # TMVA/DNN/Architectures/Cpu/CpuMatrix.h; # TMVA/DNN/Architectures/Cpu/CpuTensor.h; ${TMVA_EXTRA_HEADERS}; SOURCES; src/BDTEv,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/CMakeLists.txt:4170,Variab,VariableNormalizeTransform,4170,tmva/tmva/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/CMakeLists.txt,1,['Variab'],['VariableNormalizeTransform']
Modifiability,h; clang-tools-extra/clangd/index/remote/monitor/Monitor.cpp; clang-tools-extra/clangd/index/remote/server/Server.cpp; clang-tools-extra/clangd/index/remote/unimplemented/UnimplementedClient.cpp; clang-tools-extra/clangd/indexer/IndexerMain.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.h; clang-tools-extra/clangd/refactor/Rename.h; clang-tools-extra/clangd/refactor/Tweak.cpp; clang-tools-extra/clangd/refactor/Tweak.h; clang-tools-extra/clangd/refactor/tweaks/AddUsing.cpp; clang-tools-extra/clangd/refactor/tweaks/AnnotateHighlightings.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineInline.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineOutline.cpp; clang-tools-extra/clangd/refactor/tweaks/DumpAST.cpp; clang-tools-extra/clangd/refactor/tweaks/ExpandMacro.cpp; clang-tools-extra/clangd/refactor/tweaks/ExtractFunction.cpp; clang-tools-extra/clangd/refactor/tweaks/ObjCLocalizeStringLiteral.cpp; clang-tools-extra/clangd/refactor/tweaks/RemoveUsingNamespace.cpp; clang-tools-extra/clangd/refactor/tweaks/SwapIfBranches.cpp; clang-tools-extra/clangd/support/Cancellation.cpp; clang-tools-extra/clangd/support/Cancellation.h; clang-tools-extra/clangd/support/Context.cpp; clang-tools-extra/clangd/support/Context.h; clang-tools-extra/clangd/support/FileCache.cpp; clang-tools-extra/clangd/support/FileCache.h; clang-tools-extra/clangd/support/Function.h; clang-tools-extra/clangd/support/Logger.cpp; clang-tools-extra/clangd/support/Markup.cpp; clang-tools-extra/clangd/support/Markup.h; clang-tools-extra/clangd/support/MemoryTree.cpp; clang-tools-extra/clangd/support/MemoryTree.h; clang-tools-extra/clangd/support/Path.cpp; clang-tools-extra/clangd/support/Path.h; clang-tools-extra/clangd/support/Shutdown.cpp; clang-tools-extra/clangd/support/Shutdown.h; clang-tools-extra/clangd/support/ThreadCrashReporter.cpp; clang-tools-extra/clangd/support/ThreadCrashReporter.h; clang-tools-extra/clangd/support/Threading.cpp; clang,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:80751,refactor,refactor,80751,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,"h; the dictionaries are to be created. In addition, it allows to specify; properties of classes or data members, without the need to add comments in; the source code. This is of primary importance when dictionaries must be; created for classes residing in code which cannot be modified.; For a complete description of the structure of the *selection XML files*; and the way in which attributes can be set, refer to the `genreflex --help`; command. It is important to observe that *selection XML files* can be used in presence; of `rootcling` invocations instead of `LinkDef` files. ### The `ROOT::Meta::Selection` namespace. Not only `LinkDef` and `selection` files allow to select the classes for which; the dictionaries must be created: a third method is available. This is; represented by the `ROOT::Meta::Selection` namespace. The idea behind this; technique is that all the classes which are located in this special namespace; are automatically selected for dictionary generation. All the properties and; annotations allowed by `LinkDef` and `selection XML` files are possible.; For a detailed documentation of the features of the `ROOT::Meta::Selection`; namespace, refer to its online documentation. ## Adding a Class with ACLiC. \index{adding a class!ACLiC}; **Step 1:** Define your class. ``` {.cpp}; #include ""TObject.h"". // define the ABC class and make it inherit from TObject so that; // we can write ABC to a ROOT file; class ABC : public TObject {. public:; Float_t a, b, c, p;; ABC() : a(0), b(0), c(0), p(0){};. // Define the class for the dictionary; ClassDef (ABC,1); };. // Call the ClassImp macro to give the ABC class RTTI and; // full I/O capabilities. #if !defined(__CLING__); ClassImp(ABC);; #endif; ```. **Step 2:** Load the ABC class in the script. ``` {.cpp}; // Check if ABC is already loaded; if (!TClass::GetDict(""ABC"")) {; gROOT->ProcessLine("".L ABCClass.C++"");; }. // Use the Class; ABC *v = new ABC;; v->p = (sqrt((v->a * v->a)+ (v->b * v->b)+(v->c * v->c)));; ```; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:36028,inherit,inherit,36028,documentation/users-guide/AddingaClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md,1,['inherit'],['inherit']
Modifiability,"h; up the control flow for it. This code remembers the end block (for the; phi node), then creates the block for the loop exit (""afterloop""). Based; on the value of the exit condition, it creates a conditional branch that; chooses between executing the loop again and exiting the loop. Any; future code is emitted in the ""afterloop"" block, so it sets the; insertion position to it. .. code-block:: c++. // Add a new entry to the PHI node for the backedge.; Variable->addIncoming(NextVar, LoopEndBB);. // Restore the unshadowed variable.; if (OldVal); NamedValues[VarName] = OldVal;; else; NamedValues.erase(VarName);. // for expr always returns 0.0.; return Constant::getNullValue(Type::getDoubleTy(*TheContext));; }. The final code handles various cleanups: now that we have the ""NextVar""; value, we can add the incoming value to the loop PHI node. After that,; we remove the loop variable from the symbol table, so that it isn't in; scope after the for loop. Finally, code generation of the for loop; always returns 0.0, so that is what we return from; ``ForExprAST::codegen()``. With this, we conclude the ""adding control flow to Kaleidoscope"" chapter; of the tutorial. In this chapter we added two control flow constructs,; and used them to motivate a couple of aspects of the LLVM IR that are; important for front-end implementors to know. In the next chapter of our; saga, we will get a bit crazier and add `user-defined; operators <LangImpl06.html>`_ to our poor innocent language. Full Code Listing; =================. Here is the complete code listing for our running example, enhanced with; the if/then/else and for expressions. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../../examples/Kaleidoscope/Chapter5/toy.cpp; :language: c++. `Next: Extending the language: user-defined operators <LangImpl06.html>`_. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:26823,enhance,enhanced,26823,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,2,"['config', 'enhance']","['config', 'enhanced']"
Modifiability,"h``, but break before functions. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Custom`` (in configuration: ``Custom``); Configure each individual brace in ``BraceWrapping``. .. _BreakBeforeConceptDeclarations:. **BreakBeforeConceptDeclarations** (``BreakBeforeConceptDeclarationsStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BreakBeforeConceptDeclarations>`; The concept declaration style to use. Possible values:. * ``BBCDS_Never`` (in configuration: ``Never``); Keep the template declaration line together with ``concept``. .. code-block:: c++. template <typename T> concept C = ...;. * ``BBCDS_Allowed`` (in configuration: ``Allowed``); Breaking between template declaration and ``concept`` is allowed. The; actual behavior depends on the content and line breaking rules and; penalties. * ``BBCDS_Always`` (in configuration: ``Always``); Always break before ``concept``, putting it in the line after the; template declaration. .. code-block:: c++. template <typename T>; concept C = ...;. .. _BreakBeforeInlineASMColon:. **BreakBeforeInlineASMColon** (``BreakBeforeInlineASMColonStyle``) :versionbadge:`clang-format 16` :ref:`¶ <BreakBeforeInlineASMColon>`; The inline ASM colon style to use. Possible values:. * ``BBIAS_Never`` (in configuration: ``Never``); No break before inline ASM colon. .. code-block:: c++. asm volatile(""string"", : : val);. * ``BBIAS_OnlyMultiline`` (in configuration: ``OnlyMultiline``); Break before inline ASM colon if the line length is longer than column; limit. .. code-block:: c++. asm volatile(""string"", : : val);; asm(""cmoveq %1, %2, %[result]""; : [result] ""=r""(result); : ""r""(test), ""r""(new), ""[result]""(old)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:52414,config,configuration,52414,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ha.core.PointerSub; (C); Check for pointer subtractions on two pointers pointing to different memory; chunks. void test() {; int x, y;; int d = &y - &x; // warn; }. alpha.core.SizeofPtr; (C); Warn about unintended use of sizeof() on pointer; expressions. struct s {};. int test(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. alpha.core.StackAddressAsyncEscape; (C); Check that addresses to stack memory do not escape the function that involves; dispatch_after or dispatch_async. This checker is; a part of core.StackAddressEscape, but is; temporarily disabled until some; false positives are fixed. dispatch_block_t test_block_inside_block_async_leak() {; int x = 123;; void (^inner)(void) = ^void(void) {; int y = x;; ++y;; };; void (^outer)(void) = ^void(void) {; int z = x;; ++z;; inner();; };; return outer; // warn: address of stack-allocated block is captured by a; // returned block; }. alpha.core.TestAfterDivZero; (C, C++, ObjC); Check for division by variable that is later compared against 0.; Either the comparison is useless or there is division by zero. void test(int x) {; var = 77 / x;; if (x == 0) { } // warn; }. C++ Alpha Checkers. Name, DescriptionExample. alpha.cplusplus.ArrayDelete; (C++); Reports destructions of arrays of polymorphic objects that are destructed as; their base class. Base *create() {; Base *x = new Derived[10]; // note: Casting from 'Derived' to 'Base' here; return x;; }. void sink(Base *x) {; delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' undefined; }. alpha.cplusplus.DeleteWithNonVirtualDtor; (C++); Reports destructions of polymorphic objects with a non-virtual destructor in; their base class. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void sink(NonVirtual *x) {; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. alpha.cplusplus.Inval",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:4113,variab,variable,4113,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,2,['variab'],['variable']
Modifiability,"hanges.; set(SYSTEM_LIBS ${SYSTEM_LIBS} ""${l}""); else(); # Otherwise assume it's a library name we need to link with.; if(IS_ABSOLUTE ${l}); set(SYSTEM_LIBS ${SYSTEM_LIBS} ""${l}""); else(); set(SYSTEM_LIBS ${SYSTEM_LIBS} ""-l${l}""); endif(); endif(); endif(); endforeach(). string(REPLACE "";"" "" "" SYSTEM_LIBS ""${SYSTEM_LIBS}""). # Fetch target specific compile options, e.g. RTTI option; get_property(COMPILE_FLAGS TARGET llvm-config PROPERTY COMPILE_FLAGS). # NOTE: We don't want to start extracting any random C/CXX flags that the; # user may add that could affect the ABI. We only want to extract flags; # that have been added by the LLVM build system.; string(REGEX MATCH ""-stdlib=[^ ]+"" LLVM_CXX_STDLIB_FLAG ${CMAKE_CXX_FLAGS}); string(REGEX MATCH ""-std=[^ ]+"" LLVM_C_STD_FLAG ${CMAKE_C_FLAGS}). # Use configure_file to create BuildVariables.inc.; set(LLVM_SRC_ROOT ${LLVM_MAIN_SRC_DIR}); set(LLVM_OBJ_ROOT ${LLVM_BINARY_DIR}); set(LLVM_CPPFLAGS ""${LLVM_DEFINITIONS}""); set(LLVM_CFLAGS ""${LLVM_C_STD_FLAG} ${LLVM_DEFINITIONS}""); # The language standard potentially affects the ABI/API of LLVM, so we want; # to make sure it is reported by llvm-config.; set(LLVM_CXXFLAGS ""${CMAKE_CXX${CMAKE_CXX_STANDARD}_STANDARD_COMPILE_OPTION} ${LLVM_CXX_STDLIB_FLAG} ${COMPILE_FLAGS} ${LLVM_DEFINITIONS}""); set(LLVM_BUILD_SYSTEM cmake); set(LLVM_HAS_RTTI ${LLVM_CONFIG_HAS_RTTI}); set(LLVM_DYLIB_VERSION ""${LLVM_VERSION_MAJOR}${LLVM_VERSION_SUFFIX}""). # Use the C++ link flags, since they should be a superset of C link flags.; set(LLVM_LDFLAGS ""${CMAKE_CXX_LINK_FLAGS}""); set(LLVM_BUILDMODE ${CMAKE_BUILD_TYPE}); set(LLVM_SYSTEM_LIBS ${SYSTEM_LIBS}); string(REPLACE "";"" "" "" LLVM_TARGETS_BUILT ""${LLVM_TARGETS_TO_BUILD}""); llvm_canonicalize_cmake_booleans(; LLVM_BUILD_LLVM_DYLIB; LLVM_LINK_LLVM_DYLIB; LLVM_HAS_RTTI; BUILD_SHARED_LIBS); llvm_expand_pseudo_components(LLVM_DYLIB_COMPONENTS_expanded ""${LLVM_DYLIB_COMPONENTS}""); configure_file(${BUILDVARIABLES_SRCPATH} ${BUILDVARIABLES_OBJPATH} @ONLY). # Set bui",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/CMakeLists.txt:2308,config,config,2308,interpreter/llvm-project/llvm/tools/llvm-config/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/CMakeLists.txt,2,['config'],['config']
Modifiability,"has no; effect beyond ``standard``. The ``_Float16`` type is an interchange floating type specified in; ISO/IEC TS 18661-3:2015 (""Floating-point extensions for C""). It will; be supported on more targets as they define ABIs for it. The ``__bf16`` type is a non-standard extension, but it generally follows; the rules for arithmetic interchange floating types from ISO/IEC TS; 18661-3:2015. In previous versions of Clang, it was a storage-only type; that forbade arithmetic operations. It will be supported on more targets; as they define ABIs for it. The ``__fp16`` type was originally an ARM extension and is specified; by the `ARM C Language Extensions <https://github.com/ARM-software/acle/releases>`_.; Clang uses the ``binary16`` format from IEEE 754-2008 for ``__fp16``,; not the ARM alternative format. Operators that expect arithmetic operands; immediately promote ``__fp16`` operands to ``float``. It is recommended that portable code use ``_Float16`` instead of ``__fp16``,; as it has been defined by the C standards committee and has behavior that is; more familiar to most programmers. Because ``__fp16`` operands are always immediately promoted to ``float``, the; common real type of ``__fp16`` and ``_Float16`` for the purposes of the usual; arithmetic conversions is ``float``. A literal can be given ``_Float16`` type using the suffix ``f16``. For example,; ``3.14f16``. Because default argument promotion only applies to the standard floating-point; types, ``_Float16`` values are not promoted to ``double`` when passed as variadic; or untyped arguments. As a consequence, some caution must be taken when using; certain library facilities with ``_Float16``; for example, there is no ``printf`` format; specifier for ``_Float16``, and (unlike ``float``) it will not be implicitly promoted to; ``double`` when passed to ``printf``, so the programmer must explicitly cast it to; ``double`` before using it with an ``%f`` or similar specifier. Messages on ``deprecated`` and ``unavailable`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:34631,portab,portable,34631,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['portab'],['portable']
Modifiability,"has three integers called; `ntrack`, `nseg`, and `nvtex`. ``` {.cpp}; ""ntrack/I:nseg:nvtex""; ```. There is one more rule: when no type is given for the very first leaf,; it becomes a `float` (F). This leaf list has three floats called `temp`,; `mass`, and `px`. ``` {.cpp}; ""temp:mass:px""; ```. The symbols used for the type are:. - `C`: a character string terminated by the 0 character; - `B`: an 8 bit signed integer; - `b`: an 8 bit unsigned integer; - `S`: a 16 bit signed integer; - `s`: a 16 bit unsigned integer; - `I`: a 32 bit signed integer; - `i`: a 32 bit unsigned integer; - `L`: a 64 bit signed integer; - `l`: a 64 bit unsigned integer; - `G`: a long signed integer, stored as 64 bit; - `g`: a long unsigned integer, stored as 64 bit; - `F`: a 32 bit floating point; - `D`: a 64 bit floating point; - `O`: [the letter 'o', not a zero] a boolean (Bool\_t). The type is used for a byte count to decide how much space to allocate.; The variable written is simply the block of bytes starting at the; starting address given in the second parameter. It may or may not match; the leaf list depending on whether or not the programmer is being; careful when choosing the leaf address, name, and type. By default, a variable will be copied with the number of bytes specified; in the type descriptor symbol. However, if the type consists of two; characters, the number specifies the number of bytes to be used when; copying the variable to the output buffer. The line below describes; `ntrack` to be written as a 16-bit integer (rather than a 32-bit; integer). ``` {.cpp}; ""ntrack/I2""; ```. With this Branch method, you can also add a leaf that holds an entire; array of variables. To add an array of floats use the `f[n]` notation; when describing the leaf. ``` {.cpp}; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; ```. You can also add an array of variable length:. ``` {.cpp}; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:21762,variab,variable,21762,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"hasLHS(integerLiteral(equals(0)))). Shockingly, it will match against addition expressions whose left hand; side is exactly the literal 0. It will not match against other forms of; 0, such as ``'\0'`` or ``NULL``, but it will match against macros that; expand to 0. The matcher will also not match against calls to the; overloaded operator ``'+'``, as there is a separate ``operatorCallExpr``; matcher to handle overloaded operators. There are AST matchers to match all the different nodes of the AST,; narrowing matchers to only match AST nodes fulfilling specific criteria,; and traversal matchers to get from one kind of AST node to another. For; a complete list of AST matchers, take a look at the `AST Matcher; References <LibASTMatchersReference.html>`_. All matcher that are nouns describe entities in the AST and can be; bound, so that they can be referred to whenever a match is found. To do; so, simply call the method ``bind`` on these matchers, e.g.:. .. code-block:: c++. variable(hasType(isInteger())).bind(""intvar""). Step 2: Using AST matchers; ==========================. Okay, on to using matchers for real. Let's start by defining a matcher; which will capture all ``for`` statements that define a new variable; initialized to zero. Let's start with matching all ``for`` loops:. .. code-block:: c++. forStmt(). Next, we want to specify that a single variable is declared in the first; portion of the loop, so we can extend the matcher to. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl())))). Finally, we can add the condition that the variable is initialized to; zero. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))). It is fairly easy to read and understand the matcher definition (""match; loops whose init portion declares a single variable which is initialized; to the integer literal 0""), but deciding that every piece is necessary; is more difficult. Note that this matcher will",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:7338,variab,variable,7338,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['variab'],['variable']
Modifiability,"hat allow injecting passes into; certain parts of the pipeline. For example,. .. code-block:: c++. PassBuilder PB;; PB.registerPipelineStartEPCallback([&](ModulePassManager &MPM,; PassBuilder::OptimizationLevel Level) {; MPM.addPass(FooPass());; };. will add ``FooPass`` near the very beginning of the pipeline for pass; managers created by that ``PassBuilder``. See the documentation for; ``PassBuilder`` for the various places that passes can be added. If a ``PassBuilder`` has a corresponding ``TargetMachine`` for a backend, it; will call ``TargetMachine::registerPassBuilderCallbacks()`` to allow the; backend to inject passes into the pipeline. Clang's ``BackendUtil.cpp`` shows examples of a frontend adding (mostly; sanitizer) passes to various parts of the pipeline.; ``AMDGPUTargetMachine::registerPassBuilderCallbacks()`` is an example of a; backend adding passes to various parts of the pipeline. Pass plugins can also add passes into default pipelines. Different tools have; different ways of loading dynamic pass plugins. For example, ``opt; -load-pass-plugin=path/to/plugin.so`` loads a pass plugin into ``opt``. For; information on writing a pass plugin, see :doc:`WritingAnLLVMNewPMPass`. Using Analyses; ==============. LLVM provides many analyses that passes can use, such as a dominator tree.; Calculating these can be expensive, so the new pass manager has; infrastructure to cache analyses and reuse them when possible. When a pass runs on some IR, it also receives an analysis manager which it can; query for analyses. Querying for an analysis will cause the manager to check if; it has already computed the result for the requested IR. If it already has and; the result is still valid, it will return that. Otherwise it will construct a; new result by calling the analysis's ``run()`` method, cache it, and return it.; You can also ask the analysis manager to only return an analysis if it's; already cached. The analysis manager only provides analysis results for the same IR",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:6588,plugin,plugins,6588,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['plugin'],['plugins']
Modifiability,"hat ignores the type of ``s``. That is, it will modify *any* method call; where the method is named ""size"":. .. code-block:: c++. llvm::StringRef s = ""str"";; makeRule(; cxxMemberCallExpr(; on(expr().bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. We express the pattern with the given AST matcher, which binds the method call's; target to ``s`` [#f1]_. For the edit, we again use ``changeTo``, but this; time we construct the term from multiple parts, which we compose with ``cat``. The; second part of our term is ``node(s)``, which selects the source code; corresponding to the AST node ``s`` that was bound when a match was found in the; AST for our rule's pattern. ``node(s)`` constructs a ``RangeSelector``, which, when; used in ``cat``, indicates that the selected source should be inserted in the; output at that point. Now, we probably don't want to rewrite *all* invocations of ""size"" methods, just; those on ``std::string``\ s. We can achieve this change simply by refining our; matcher. The rest of the rule remains unchanged:. .. code-block:: c++. llvm::StringRef s = ""str"";; makeRule(; cxxMemberCallExpr(; on(expr(hasType(namedDecl(hasName(""std::string"")))); 	 .bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. Example: rewriting method calls; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In this example, we delete an ""intermediary"" method call in a string of; invocations. This scenario can arise, for example, if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:6816,rewrite,rewrite,6816,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['rewrite'],['rewrite']
Modifiability,"hat it is functional makes it ""too easy"" to generate LLVM IR for it. In; particular, a functional language makes it very easy to build LLVM IR; directly in `SSA; form <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_.; Since LLVM requires that the input code be in SSA form, this is a very; nice property and it is often unclear to newcomers how to generate code; for an imperative language with mutable variables. The short (and happy) summary of this chapter is that there is no need; for your front-end to build SSA form: LLVM provides highly tuned and; well tested support for this, though the way it works is a bit; unexpected for some. Why is this a hard problem?; ===========================. To understand why mutable variables cause complexities in SSA; construction, consider this extremely simple C example:. .. code-block:: c. int G, H;; int test(_Bool Condition) {; int X;; if (Condition); X = G;; else; X = H;; return X;; }. In this case, we have the variable ""X"", whose value depends on the path; executed in the program. Because there are two different possible values; for X before the return instruction, a PHI node is inserted to merge the; two values. The LLVM IR that we want for this example looks like this:. .. code-block:: llvm. @G = weak global i32 0 ; type of @G is i32*; @H = weak global i32 0 ; type of @H is i32*. define i32 @test(i1 %Condition) {; entry:; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; br label %cond_next. cond_next:; %X.2 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]; ret i32 %X.2; }. In this example, the loads from the G and H global variables are; explicit in the LLVM IR, and they live in the then/else branches of the; if statement (cond\_true/cond\_false). In order to merge the incoming; values, the X.2 phi node in the cond\_next block selects the right value; to use based on where control flow is coming from: if",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:1725,variab,variable,1725,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"hat make use of this; information. Attaching section information to an external declaration is an; assertion that its definition is located in the specified section. If the; definition is located in a different section, the behavior is undefined. LLVM allows an explicit code model to be specified for globals. If the; target supports it, it will emit globals in the code model specified,; overriding the code model used to compile the translation unit.; The allowed values are ""tiny"", ""small"", ""kernel"", ""medium"", ""large"".; This may be extended in the future to specify global data layout that; doesn't cleanly fit into a specific code model. By default, global initializers are optimized by assuming that global; variables defined within the module are not modified from their; initial values before the start of the global initializer. This is; true even for variables potentially accessible from outside the; module, including those with external linkage or appearing in; ``@llvm.used`` or dllexported variables. This assumption may be suppressed; by marking the variable with ``externally_initialized``. An explicit alignment may be specified for a global, which must be a; power of 2. If not present, or if the alignment is set to zero, the; alignment of the global is set by the target to whatever it feels; convenient. If an explicit alignment is specified, the global is forced; to have exactly that alignment. Targets and optimizers are not allowed; to over-align the global if the global has an assigned section. In this; case, the extra alignment could be observable: for example, code could; assume that the globals are densely packed in their section and try to; iterate over them as an array, alignment padding would break this; iteration. For TLS variables, the module flag ``MaxTLSAlign``, if present,; limits the alignment to the given value. Optimizers are not allowed to; impose a stronger alignment on these variables. The maximum alignment; is ``1 << 32``. For global variable d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:34281,variab,variables,34281,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"hat only appear when the; experimental target is enabled, caused by changes unrelated to the target, are; the responsibility of the community behind the target to fix. The basic rules for a back-end to be upstreamed in **experimental** mode are:. * Every target must have a :ref:`code owner<code owners>`. The `CODE_OWNERS.TXT`; file has to be updated as part of the first merge. The code owner makes sure; that changes to the target get reviewed and steers the overall effort. * There must be an active community behind the target. This community; will help maintain the target by providing buildbots, fixing; bugs, answering the LLVM community's questions and making sure the new; target doesn't break any of the other targets, or generic code. This; behavior is expected to continue throughout the lifetime of the; target's code. * The code must be free of contentious issues, for example, large; changes in how the IR behaves or should be formed by the front-ends,; unless agreed by the majority of the community via refactoring of the; (:doc:`IR standard<LangRef>`) **before** the merge of the new target changes,; following the :ref:`IR backwards compatibility`. * The code conforms to all of the policies laid out in this developer policy; document, including license, patent, and coding standards. * The target should have either reasonable documentation on how it; works (ISA, ABI, etc.) or a publicly available simulator/hardware; (either free or cheap enough) - preferably both. This allows; developers to validate assumptions, understand constraints and review code; that can affect the target. In addition, the rules for a back-end to be promoted to **official** are:. * The target must have addressed every other minimum requirement and; have been stable in tree for at least 3 months. This cool down; period is to make sure that the back-end and the target community can; endure continuous upstream development for the foreseeable future. * The target's code must have been completely ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:40579,refactor,refactoring,40579,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['refactor'],['refactoring']
Modifiability,"hat operands which are constants also use; the relative encoding, while operands like basic block labels; do not use the relative encoding. Forward references will result in a negative value.; This can be inefficient, as operands are normally encoded; as unsigned VBRs. However, forward references are rare, except in the; case of phi instructions. For phi instructions, operands are encoded as; `Signed VBRs`_ to deal with forward references. In version 2, the meaning of module records ``FUNCTION``, ``GLOBALVAR``,; ``ALIAS``, ``IFUNC`` and ``COMDAT`` change such that the first two operands; specify an offset and size of a string in a string table (see `STRTAB_BLOCK; Contents`_), the function name is removed from the ``FNENTRY`` record in the; value symbol table, and the top-level ``VALUE_SYMTAB_BLOCK`` may only contain; ``FNENTRY`` records. MODULE_CODE_TRIPLE Record; ^^^^^^^^^^^^^^^^^^^^^^^^^. ``[TRIPLE, ...string...]``. The ``TRIPLE`` record (code 2) contains a variable number of values representing; the bytes of the ``target triple`` specification string. MODULE_CODE_DATALAYOUT Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[DATALAYOUT, ...string...]``. The ``DATALAYOUT`` record (code 3) contains a variable number of values; representing the bytes of the ``target datalayout`` specification string. MODULE_CODE_ASM Record; ^^^^^^^^^^^^^^^^^^^^^^. ``[ASM, ...string...]``. The ``ASM`` record (code 4) contains a variable number of values representing; the bytes of ``module asm`` strings, with individual assembly blocks separated; by newline (ASCII 10) characters. .. _MODULE_CODE_SECTIONNAME:. MODULE_CODE_SECTIONNAME Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[SECTIONNAME, ...string...]``. The ``SECTIONNAME`` record (code 5) contains a variable number of values; representing the bytes of a single section name string. There should be one; ``SECTIONNAME`` record for each section name referenced (e.g., in global; variable or function ``section`` attributes) within the module. These r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:25436,variab,variable,25436,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability,"hat the builtins can be linked; into a binary and execute the tests correctly but it will not catch if the; builtins use instructions that are supported on Armv7-A but not Armv6-M,; Armv7-M and Armv7E-M. To get the cmake compile test to pass you will need to pass the libraries; needed to successfully link the cmake test via ``CMAKE_CFLAGS``. It is; strongly recommended that you use version 3.6 or above of cmake so you can use; ``CMAKE_TRY_COMPILE_TARGET=STATIC_LIBRARY`` to skip the link step. * ``-DCMAKE_TRY_COMPILE_TARGET_TYPE=STATIC_LIBRARY``; * ``-DCOMPILER_RT_OS_DIR=""baremetal""``; * ``-DCOMPILER_RT_BUILD_BUILTINS=ON``; * ``-DCOMPILER_RT_BUILD_SANITIZERS=OFF``; * ``-DCOMPILER_RT_BUILD_XRAY=OFF``; * ``-DCOMPILER_RT_BUILD_LIBFUZZER=OFF``; * ``-DCOMPILER_RT_BUILD_PROFILE=OFF``; * ``-DCMAKE_C_COMPILER=${host_install_dir}/bin/clang``; * ``-DCMAKE_C_COMPILER_TARGET=""your *-none-eabi target""``; * ``-DCMAKE_ASM_COMPILER_TARGET=""your *-none-eabi target""``; * ``-DCMAKE_AR=/path/to/llvm-ar``; * ``-DCMAKE_NM=/path/to/llvm-nm``; * ``-DCMAKE_RANLIB=/path/to/llvm-ranlib``; * ``-DCOMPILER_RT_BAREMETAL_BUILD=ON``; * ``-DCOMPILER_RT_DEFAULT_TARGET_ONLY=ON``; * ``-DLLVM_CONFIG_PATH=/path/to/llvm-config``; * ``-DCMAKE_C_FLAGS=""build-c-flags""``; * ``-DCMAKE_ASM_FLAGS=""build-c-flags""``; * ``-DCOMPILER_RT_EMULATOR=""qemu-arm -L /path/to/armv7-A/sysroot""``; * ``-DCOMPILER_RT_INCLUDE_TESTS=ON``; * ``-DCOMPILER_RT_TEST_COMPILER=""/path/to/clang""``; * ``-DCOMPILER_RT_TEST_COMPILER_CFLAGS=""test-c-flags""``. The Armv6-M builtins will use the soft-float ABI. When compiling the tests for; Armv7-A we must include ``""-mthumb -mfloat-abi=soft -mfpu=none""`` in the; test-c-flags. We must use an Armv7-A soft-float abi sysroot for ``qemu-arm``. Depending on the linker used for the test cases you may encounter BuildAttribute; mismatches between the M-profile objects from compiler-rt and the A-profile; objects from the test. The lld linker does not check the profile; BuildAttribute so it can be used to lin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst:11522,config,config,11522,interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,1,['config'],['config']
Modifiability,"have `Query` which lists all the queries we defined. ```python; print(full_json[""anonymous_0""][""!superclasses""]); ```. ['Query']. On each def there is also a `!superclasses` that gives you the same information. Meaning you could use `!instanceof` to get a list of keys to lookup, or you could walk all keys and check `!superclasses`. ```python; print(full_json[""anonymous_0""][""Fields""]); ```. {'args': [], 'kind': 'dag', 'operator': {'def': 'all', 'kind': 'def', 'printable': 'all'}, 'printable': '(all)'}. From a def object you can find its attributes. Here we have the fields we want the query to show, which is all of them. # The Backend. The core of a backend is looping over all defs of a certain class and outputting some text based on their properties. Here we're going to loop over all defs of type `Query` and emit SQL queries for them. ```python; def find_all_queries(j):; queries = []; for key in j:; # ! means it is some metadata, not a def.; if not key.startswith(""!""):; value = full_json[key]; # If we inherit from Query.; if ""Query"" in value[""!superclasses""]:; queries.append(value); return queries. queries = find_all_queries(full_json); ; print([q[""!name""] for q in queries]); ```. ['anonymous_0', 'anonymous_1', 'anonymous_2', 'anonymous_3', 'anonymous_4']. Why are the names `anonymous_...`? When we defined them we did `def :` and missed out the name. This is allowed and `llvm-tblgen` just came up with a name for us. For this purpose the names are irrelevant. Now we have the relevant classes we need to ""emit"" them. Meaning produce something from them, in this case a SQL query. ```python; def emit_operator(operator):; return {; 'gt': ' > ',; 'ge': ' >= ',; 'lt': ' < ',; 'le': ' <= ',; 'ne': ' <> ',; 'eq': ' = ',; 'or': ' OR ',; 'and': ' AND '; }[operator]. print(emit_operator('and')); ```. AND . The maps our TableGen constants to the equivalent SQL logical operation. ```python; def emit_fields(args):; # Return a comma separated list of arg names.; return "", "".join([arg[",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/sql_query_backend.md:11157,inherit,inherit,11157,interpreter/llvm-project/llvm/utils/TableGen/jupyter/sql_query_backend.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/sql_query_backend.md,1,['inherit'],['inherit']
Modifiability,"having the same value in two; threads refer to the same data. Also, if any thread changes one of the; shared system resources, all threads within the process are affected.; For example, if a thread closes a file, the file is closed for all; threads. ### The Initial Thread. When a process is created, one thread is automatically created. This; thread is called the initial thread or the main thread. The initial; thread executes the main routine in multi-threaded programs. Note: At the end of this chapter is a glossary of thread specific terms. ## Implementation of Threads in ROOT. The **`TThread`** class has been developed to provide a platform; independent interface to threads for ROOT. ### Installation. For the time being, it is still necessary to compile a threaded version; of ROOT to enable some very special treatments of the canvas operations.; We hope that this will become the default later. To compile ROOT, just do (for example on a debian Linux):. ```; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; ```. This configures and builds ROOT using `/usr/lib/libpthread.so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The platform dependent; implementation is in the **`TThreadImp`** class and its descendant; classes (e.g. **`TPosixThread`** ). **`TMutex`** class implements `mutex` locks. A mutex is a mutually; exclusive lock. The platform dependent implementation is in the; **`TMutexImp`** class and its descendant classes (e.g.; **`TPosixMutex`**). **`TCondition`** class implements a condition variable. Use a condition; variable to signal threads. The platform dependent implementation is in; the **`TConditionImp`** and **`TPosixCondition`** classes . **`TSemaphore`** class implem",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:3128,config,configure,3128,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['config'],['configure']
Modifiability,"he Basics; ^^^^^^^^^^^. #. Make sure that your Modules contain both a data layout specification and; target triple. Without these pieces, non of the target specific optimization; will be enabled. This can have a major effect on the generated code quality. #. For each function or global emitted, use the most private linkage type; possible (private, internal or linkonce_odr preferably). Doing so will; make LLVM's inter-procedural optimizations much more effective. #. Avoid high in-degree basic blocks (e.g. basic blocks with dozens or hundreds; of predecessors). Among other issues, the register allocator is known to; perform badly with confronted with such structures. The only exception to; this guidance is that a unified return block with high in-degree is fine. Use of allocas; ^^^^^^^^^^^^^^. An alloca instruction can be used to represent a function scoped stack slot,; but can also represent dynamic frame expansion. When representing function; scoped variables or locations, placing alloca instructions at the beginning of; the entry block should be preferred. In particular, place them before any; call instructions. Call instructions might get inlined and replaced with; multiple basic blocks. The end result is that a following alloca instruction; would no longer be in the entry basic block afterward. The SROA (Scalar Replacement Of Aggregates) and Mem2Reg passes only attempt; to eliminate alloca instructions that are in the entry basic block. Given; SSA is the canonical form expected by much of the optimizer; if allocas can; not be eliminated by Mem2Reg or SROA, the optimizer is likely to be less; effective than it could be. Avoid loads and stores of large aggregate type; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. LLVM currently does not optimize well loads and stores of large :ref:`aggregate; types <t_aggregate>` (i.e. structs and arrays). As an alternative, consider; loading individual fields from memory. Aggregates that are smaller than the largest (performan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst:2305,variab,variables,2305,interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,1,['variab'],['variables']
Modifiability,"he C++Now! 2012 talk; describing this technique in more detail.; #. `Sean Parent's Papers and Presentations; <http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations>`_; - A GitHub project full of links to slides, video, and sometimes code. When deciding between creating a type hierarchy (with either tagged or virtual; dispatch) and using templates or concepts-based polymorphism, consider whether; there is some refinement of an abstract base class which is a semantically; meaningful type on an interface boundary. If anything more refined than the; root abstract interface is meaningless to talk about as a partial extension of; the semantic model, then your use case likely fits better with polymorphism and; you should avoid using virtual dispatch. However, there may be some exigent; circumstances that require one technique or the other to be used. If you do need to introduce a type hierarchy, we prefer to use explicitly; closed type hierarchies with manual tagged dispatch and/or RTTI rather than the; open inheritance model and virtual dispatch that is more common in C++ code.; This is because LLVM rarely encourages library consumers to extend its core; types, and leverages the closed and tag-dispatched nature of its hierarchies to; generate significantly more efficient code. We have also found that a large; amount of our usage of type hierarchies fits better with tag-based pattern; matching rather than dynamic dispatch across a common interface. Within LLVM we; have built custom helpers to facilitate this design. See this document's; section on :ref:`isa and dyn_cast <isa>` and our :doc:`detailed document; <HowToSetUpLLVMStyleRTTI>` which describes how you can implement this; pattern for use with the LLVM helpers. .. _abi_breaking_checks:. ABI Breaking Checks; -------------------. Checks and asserts that alter the LLVM C++ ABI are predicated on the; preprocessor symbol `LLVM_ENABLE_ABI_BREAKING_CHECKS` -- LLVM; libraries built with `LLVM_ENAB",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:132444,inherit,inheritance,132444,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['inherit'],['inheritance']
Modifiability,"he LLVM IR. Stack memory allocated with the alloca; instruction is fully general: you can pass the address of the stack slot; to functions, you can store it in other variables, etc. In our example; above, we could rewrite the example to use the alloca technique to avoid; using a PHI node:. .. code-block:: llvm. @G = weak global i32 0 ; type of @G is i32*; @H = weak global i32 0 ; type of @H is i32*. define i32 @test(i1 %Condition) {; entry:; %X = alloca i32 ; type of %X is i32*.; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; store i32 %X.0, i32* %X ; Update X; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; store i32 %X.1, i32* %X ; Update X; br label %cond_next. cond_next:; %X.2 = load i32, i32* %X ; Read X; ret i32 %X.2; }. With this, we have discovered a way to handle arbitrary mutable; variables without the need to create Phi nodes at all:. #. Each mutable variable becomes a stack allocation.; #. Each read of the variable becomes a load from the stack.; #. Each update of the variable becomes a store to the stack.; #. Taking the address of a variable just uses the stack address; directly. While this solution has solved our immediate problem, it introduced; another one: we have now apparently introduced a lot of stack traffic; for very simple and common operations, a major performance problem.; Fortunately for us, the LLVM optimizer has a highly-tuned optimization; pass named ""mem2reg"" that handles this case, promoting allocas like this; into SSA registers, inserting Phi nodes as appropriate. If you run this; example through the pass, for example, you'll get:. .. code-block:: bash. $ llvm-as < example.ll | opt -passes=mem2reg | llvm-dis; @G = weak global i32 0; @H = weak global i32 0. define i32 @test(i1 %Condition) {; entry:; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; br label %cond_next. cond_next",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:6274,variab,variable,6274,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"he PTX kernel functions are callable by host-side code. .. _address_spaces:. Address Spaces; --------------. The NVPTX back-end uses the following address space mapping:. ============= ======================; Address Space Memory Space; ============= ======================; 0 Generic; 1 Global; 2 Internal Use; 3 Shared; 4 Constant; 5 Local; ============= ======================. Every global variable and pointer type is assigned to one of these address; spaces, with 0 being the default address space. Intrinsics are provided which; can be used to convert pointers between the generic and non-generic address; spaces. As an example, the following IR will define an array ``@g`` that resides in; global device memory. .. code-block:: llvm. @g = internal addrspace(1) global [4 x i32] [ i32 0, i32 1, i32 2, i32 3 ]. LLVM IR functions can read and write to this array, and host-side code can; copy data to it by name with the CUDA Driver API. Note that since address space 0 is the generic space, it is illegal to have; global variables in address space 0. Address space 0 is the default address; space in LLVM, so the ``addrspace(N)`` annotation is *required* for global; variables. Triples; -------. The NVPTX target uses the module triple to select between 32/64-bit code; generation and the driver-compiler interface to use. The triple architecture; can be one of ``nvptx`` (32-bit PTX) or ``nvptx64`` (64-bit PTX). The; operating system should be one of ``cuda`` or ``nvcl``, which determines the; interface used by the generated code to communicate with the driver. Most; users will want to use ``cuda`` as the operating system, which makes the; generated PTX compatible with the CUDA Driver API. Example: 32-bit PTX for CUDA Driver API: ``nvptx-nvidia-cuda``. Example: 64-bit PTX for CUDA Driver API: ``nvptx64-nvidia-cuda``. .. _nvptx_intrinsics:. NVPTX Intrinsics; ================. Address Space Conversion; ------------------------. '``llvm.nvvm.ptr.*.to.gen``' Intrinsics; ^^^^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:2947,variab,variables,2947,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['variab'],['variables']
Modifiability,"he RooFit collection constructors. #### Allow for use of Python collections instead of C++ STL containers. Some RooFit functions take STL map-like types such as `std::map` as parameters, for example the [RooCategory constructor](https://root.cern/doc/v626/classRooCategory.html#ae63ae78231765d184b7a839c74746a49). In the past, you had to create the correct C++ class in Python, but now you can usually pass a Python dictionary instead. For example, a RooCategory can be created like this:; ```Python; sample = ROOT.RooCategory(""sample"", ""sample"", {""Sample1"": 1, ""Sample2"": 2, ""Sample3"": 3}); ```. #### RooWorkspace accessors. In Python, you can now get objects stored in a [RooWorkspace](https://root.cern/doc/v626/classRooWorkspace.html) with the item retrieval operator, and the return value is also always downcasted to the correct type. That means in Python you don't have to use [RooWorkspace::var()](https://root.cern/doc/v626/classRooWorkspace.html#acf5f9126ee264c234721a4ed1f9bf837) to access variables or [RooWorkspace::pdf()](https://root.cern/doc/v626/classRooWorkspace.html#afa7384cece424a1a94a644bb05549eee) to access pdfs, but you can always get any object using square brackets. For example:; ```Python; # w is a RooWorkspace instance that contains the variables `x`, `y`, and `z` for which we want to generate toy data:; model.generate({w[""x""], w[""y""], w[""z""]}, 1000); ```. ### New PyROOT functions for interoperability with NumPy and Pandas. New member functions of RooFit classes were introduced exclusively to PyROOT for better interoperability between RooFit and Numpy and Pandas:. - `RooDataSet.from_numpy`: Import a RooDataSet from a dictionary of numpy arrays (static method); - `RooDataSet.to_numpy`: Export a RooDataSet to a dictionary of numpy arrays; - `RooDataSet.from_pandas`: Import a RooDataSet from a Pandas dataframe (static method); - `RooDataSet.to_pandas`: Export a RooDataSet to a Pandas dataframe; - `RooDataHist.from_numpy`: Import a RooDataHist from numpy arra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:22219,variab,variables,22219,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['variab'],['variables']
Modifiability,"he SPIR-V support section <spir-v>`. - SPIR is available as a generic target to allow portable bitcode to be produced; that can be used across GPU toolchains. The implementation follows `the SPIR; specification <https://www.khronos.org/spir>`_. There are two flavors; available for 32 and 64 bits. .. code-block:: console. $ clang --target=spir test.cl -emit-llvm -c; $ clang --target=spir64 test.cl -emit-llvm -c. Clang will generate SPIR v1.2 compatible IR for OpenCL versions up to 2.0 and; SPIR v2.0 for OpenCL v2.0 or C++ for OpenCL. - x86 is used by some implementations that are x86 compatible and currently; remains for backwards compatibility (with older implementations prior to; SPIR target support). For ""non-SPMD"" targets which cannot spawn multiple; work-items on the fly using hardware, which covers practically all non-GPU; devices such as CPUs and DSPs, additional processing is needed for the kernels; to support multiple work-item execution. For this, a 3rd party toolchain,; such as for example `POCL <http://portablecl.org/>`_, can be used. This target does not support multiple memory segments and, therefore, the fake; address space map can be added using the :ref:`-ffake-address-space-map; <opencl_fake_address_space_map>` flag. All known OpenCL extensions and features are set to supported in the generic targets,; however :option:`-cl-ext` flag can be used to toggle individual extensions and; features. .. _opencl_header:. OpenCL Header; -------------. By default Clang will include standard headers and therefore most of OpenCL; builtin functions and types are available during compilation. The; default declarations of non-native compiler types and functions can be disabled; by using flag :option:`-cl-no-stdinc`. The following example demonstrates that OpenCL kernel sources with various; standard builtin functions can be compiled without the need for an explicit; includes or compiler flags. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:146478,portab,portablecl,146478,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['portab'],['portablecl']
Modifiability,"he ``__weak`` and; ``__unsafe_unretained`` qualifiers (and the ``weak`` and; ``unsafe_unretained`` property attributes) are just as laid out; in the :doc:`ARC specification <AutomaticReferenceCounting>`.; In particular, note that some classes do not support forming weak; references to their instances, and note that special care must be; taken when storing weak references in memory where initialization; and deinitialization are outside the responsibility of the compiler; (such as in ``malloc``-ed memory). Loading from a ``__weak`` variable always implicitly retains the; loaded value. In non-ARC modes, this retain is normally balanced; by an implicit autorelease. This autorelease can be suppressed; by performing the load in the receiver position of a ``-retain``; message send (e.g. ``[weakReference retain]``); note that this performs; only a single retain (the retain done when primitively loading from; the weak reference). For the most part, ``__unsafe_unretained`` in non-ARC modes is just the; default behavior of variables and therefore is not needed. However,; it does have an effect on the semantics of block captures: normally,; copying a block which captures an Objective-C object or block pointer; causes the captured pointer to be retained or copied, respectively,; but that behavior is suppressed when the captured variable is qualified; with ``__unsafe_unretained``. Note that the ``__weak`` qualifier formerly meant the GC qualifier in; all non-ARC modes and was silently ignored outside of GC modes. It now; means the ARC-style qualifier in all non-GC modes and is no longer; allowed if not enabled by either ``-fobjc-arc`` or ``-fobjc-weak``.; It is expected that ``-fobjc-weak`` will eventually be enabled by default; in all non-GC Objective-C modes. .. _objc-fixed-enum:. Enumerations with a fixed underlying type; -----------------------------------------. Clang provides support for C++11 enumerations with a fixed underlying type; within Objective-C. For example, one c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:73013,variab,variables,73013,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['variab'],['variables']
Modifiability,"he ``bits`` value and a; function to get that size. The ``get()`` function takes the length of the sequence, *n*, and returns the; ``BitsRecTy`` type corresponding to ``bits<``\ *n*\ ``>``. ``ListRecTy``; ~~~~~~~~~~~~~. This class includes a data member that specifies the type of the list's; elements and a function to get that type. The ``get()`` function takes the ``RecTy`` *type* of the list members and; returns the ``ListRecTy`` type corresponding to ``list<``\ *type*\ ``>``. ``RecordRecTy``; ~~~~~~~~~~~~~~~. This class includes data members that contain the list of parent classes of; this record. It also provides a function to obtain the array of classes and; two functions to get the iterator ``begin()`` and ``end()`` values. The; class defines a type for the return values of the latter two functions. .. code-block:: text. using const_record_iterator = Record * const *;. The ``get()`` function takes an ``ArrayRef`` of pointers to the ``Record``; instances of the *direct* superclasses of the record and returns the ``RecordRecTy``; corresponding to the record inheriting from those superclasses. ``Init``; --------. The ``Init`` class is used to represent TableGen values. The name derives; from *initialization value*. This class should not be confused with the; ``RecordVal`` class, which represents record fields, both their names and; values. The ``Init`` class is the base class for a series of subclasses, one; for each of the available value types. The primary data member of ``Init``; is an enumerated type that represents the specific type of the value. The ``Init`` class provides a few useful functions. * A function to get the type enumerator. * A boolean virtual function to determine whether a value is completely; specified; that is, has no uninitialized subvalues. * Virtual functions to get the value as a string. * Virtual functions to cast the value to other types, implement the bit; range feature of TableGen, and implement the list slice feature. * A virtual f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst:8711,inherit,inheriting,8711,interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,1,['inherit'],['inheriting']
Modifiability,"he bits with the most significance have the lowest address; location.; ``e``; Specifies that the target lays out data in little-endian form. That; is, the bits with the least significance have the lowest address; location.; ``S<size>``; Specifies the natural alignment of the stack in bits. Alignment; promotion of stack variables is limited to the natural stack; alignment to avoid dynamic stack realignment. The stack alignment; must be a multiple of 8-bits. If omitted, the natural stack; alignment defaults to ""unspecified"", which does not prevent any; alignment promotions.; ``P<address space>``; Specifies the address space that corresponds to program memory.; Harvard architectures can use this to specify what space LLVM; should place things such as functions into. If omitted, the; program memory space defaults to the default address space of 0,; which corresponds to a Von Neumann architecture that has code; and data in the same space.; ``G<address space>``; Specifies the address space to be used by default when creating global; variables. If omitted, the globals address space defaults to the default; address space 0.; Note: variable declarations without an address space are always created in; address space 0, this property only affects the default value to be used; when creating globals without additional contextual information (e.g. in; LLVM passes). .. _alloca_addrspace:. ``A<address space>``; Specifies the address space of objects created by '``alloca``'.; Defaults to the default address space of 0.; ``p[n]:<size>:<abi>[:<pref>][:<idx>]``; This specifies the *size* of a pointer and its ``<abi>`` and; ``<pref>``\erred alignments for address space ``n``. ``<pref>`` is optional; and defaults to ``<abi>``. The fourth parameter ``<idx>`` is the size of the; index that used for address calculation, which must be less than or equal; to the pointer size. If not; specified, the default index size is equal to the pointer size. All sizes; are in bits. The address space, ``n`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:132579,variab,variables,132579,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"he code is being compiled for. The supported GPU; architectures can be found in the `AMDGPU Processor Table <https://llvm.org/docs/AMDGPUUsage.html#processors>`_.; Alternatively, you can use the ``amdgpu-arch`` tool that comes with Clang to list the GPU architecture on your system:. .. code-block:: shell. amdgpu-arch. You can use ``--offload-arch=native`` to automatically detect the GPU architectures on your system:. .. code-block:: shell. clang++ --offload-arch=native -xhip sample.cpp -o sample. Path Setting for Dependencies; =============================. Compiling a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4069,variab,variable,4069,interpreter/llvm-project/clang/docs/HIPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst,1,['variab'],['variable']
Modifiability,"he context so that it can be accessed; and used in the generated code. This variable is made available globally; (using `addToGlobalScope()`). If a weight sum is needed, then it creates a loop, and `weightSumName` is; accumulated with the weight variable. Otherwise, if there are multiple; simultaneous PDFs, then it adds a term to the result that scales with the; logarithm of the count of simultaneous PDFs. The rest of the function body; (including the loop scope with NLL computation) has omitted from this example; to keep it brief. Helper functions:. - `makeValidVarName()` helps get a valid name from the name of the respective; RooFit class. It then helps save it to the variable that represents the result; of this class (the squashed code/ C++ function that will be created). - `addToGlobalScope()` helps declare and initialize the results variable, so; that it can be available globally (throughout the function body). For local; variables, the `addToCodeBody()` function can be used to keep the variables in; the respective scope (for example, within a loop). - `beginLoop()` helps build the start and the end of a For loop for your; class. Simply place this function in the scope and place the contents of the; `For` loop below this statement. The code squashing task will automatically; build a loop around the statements that follow it. There's no need to worry; about the index of these loops, because they get propagated. For example, if; you want to iterate over a vector of RooFit objects using a loop, you don't; have to think about indexing them properly because the `beginLoop()` function; takes care of that. Simply call this function, place your function call in a; scope and after the scope ends, the loop will also end. - `addToCodeBody()` helps add things to the body of the C++ function that; you're creating. It takes whatever string is computed in its arguments and; adds it to the overall function string (which will later be just-in-time; compiled). The `addToCodeBody",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:17515,variab,variables,17515,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,2,['variab'],['variables']
Modifiability,"he data layout; conventions used by the C and C++ front-ends. Debug information descriptors are `specialized metadata nodes; <LangRef.html#specialized-metadata>`_, first-class subclasses of ``Metadata``. .. _format_common_intrinsics:. Debugger intrinsic functions; ----------------------------. LLVM uses several intrinsic functions (name prefixed with ""``llvm.dbg``"") to; track source local variables through optimization and code generation. ``llvm.dbg.declare``; ^^^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. void @llvm.dbg.declare(metadata, metadata, metadata). This intrinsic provides information about a local element (e.g., variable).; The first argument is metadata holding the address of variable, typically a; static alloca in the function entry block. The second argument is a; `local variable <LangRef.html#dilocalvariable>`_ containing a description of; the variable. The third argument is a `complex expression; <LangRef.html#diexpression>`_. An `llvm.dbg.declare` intrinsic describes the; *address* of a source variable. .. code-block:: text. %i.addr = alloca i32, align 4; call void @llvm.dbg.declare(metadata i32* %i.addr, metadata !1,; metadata !DIExpression()), !dbg !2; !1 = !DILocalVariable(name: ""i"", ...) ; int i; !2 = !DILocation(...); ...; %buffer = alloca [256 x i8], align 8; ; The address of i is buffer+64.; call void @llvm.dbg.declare(metadata [256 x i8]* %buffer, metadata !3,; metadata !DIExpression(DW_OP_plus, 64)), !dbg !4; !3 = !DILocalVariable(name: ""i"", ...) ; int i; !4 = !DILocation(...). A frontend should generate exactly one call to ``llvm.dbg.declare`` at the point; of declaration of a source variable. Optimization passes that fully promote the; variable from memory to SSA values will replace this call with possibly multiple; calls to `llvm.dbg.value`. Passes that delete stores are effectively partial; promotion, and they will insert a mix of calls to ``llvm.dbg.value`` to track; the source variable value when it is available. After optimization, ther",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:8974,variab,variable,8974,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"he delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162591,variab,variable,162591,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['variab'],['variable']
Modifiability,"he destination size, '``llvm.vp.trunc``' cannot be a *no-op cast*. It will; always truncate bits. The conversion is performed on lane positions below the; explicit vector length and where the vector mask is true. Masked-off lanes are; ``poison``. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call <4 x i16> @llvm.vp.trunc.v4i16.v4i32(<4 x i32> %a, <4 x i1> %mask, i32 %evl); ;; For all lanes below %evl, %r is lane-wise equivalent to %also.r. %t = trunc <4 x i32> %a to <4 x i16>; %also.r = select <4 x i1> %mask, <4 x i16> %t, <4 x i16> poison. .. _int_vp_zext:. '``llvm.vp.zext.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <16 x i32> @llvm.vp.zext.v16i32.v16i16 (<16 x i16> <op>, <16 x i1> <mask>, i32 <vector_length>); declare <vscale x 4 x i32> @llvm.vp.zext.nxv4i32.nxv4i16 (<vscale x 4 x i16> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". The '``llvm.vp.zext``' intrinsic zero extends its first operand to the return; type. The operation has a mask and an explicit vector length parameter. Arguments:; """""""""""""""""""". The '``llvm.vp.zext``' intrinsic takes a value to cast as its first operand.; The return type is the type to cast the value to. Both types must be vectors of; :ref:`integer <t_integer>` type. The bit size of the value must be smaller than; the bit size of the return type. The second operand is the vector mask. The; return type, the value to cast, and the vector mask have the same number of; elements. The third operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.zext``' intrinsic fill the high order bits of the value with zero; bits until it reaches the size of the return type. When zero extending from i1,; the result will always be either 0 or 1. The conversion is performed on lane; positions below the explicit vector length and where the vector mask is true.; Masked-off lanes are ``poison``. Examples:; """""""""""""""""". .. cod",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:797990,extend,extends,797990,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['extend'],['extends']
Modifiability,"he files to ``X`` seconds (or minutes, hours; respectively). When a file hasn't been accessed for ``prune_after`` seconds,; it is removed from the cache. A value of 0 disables the expiration-based; pruning. The default is 1 week. - ``prune_interval=Xs``, ``prune_interval=Xm``, ``prune_interval=Xh``:; Sets the pruning interval to ``X`` seconds (or minutes, hours; respectively). This is intended to be used to avoid scanning the directory; too often. It does not impact the decision of which files to prune. A; value of 0 forces the scan to occur. The default is every 20 minutes. Clang Bootstrap; ---------------. To `bootstrap clang/LLVM <https://llvm.org/docs/AdvancedBuilds.html#bootstrap-builds>`_; with ThinLTO, follow these steps:. 1. The host compiler_ must be a version of clang that supports ThinLTO.; #. The host linker_ must support ThinLTO (and in the case of gold, must be; `configured with plugins enabled <https://llvm.org/docs/GoldPlugin.html>`_).; #. Use the following additional `CMake variables; <https://llvm.org/docs/CMake.html#options-and-variables>`_; when configuring the bootstrap compiler build:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang++``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib``; * ``-DCMAKE_AR=/path/to/host/llvm-ar``. Or, on Windows:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_LINKER=/path/to/host/lld-link.exe``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib.exe``; * ``-DCMAKE_AR=/path/to/host/llvm-ar.exe``. #. To use additional linker arguments for controlling the backend; parallelism_ or enabling incremental_ builds of the bootstrap compiler,; after configuring the build, modify the resulting CMakeCache.txt file in the; build directory. Specify any additional linker options after; ``CMAKE_EXE_LINKER_FLAGS:STRING=``. Note the configure may fail if; linker plugin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:7988,variab,variables,7988,interpreter/llvm-project/clang/docs/ThinLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst,1,['variab'],['variables']
Modifiability,"he first check line matches a regex ``%[a-z]+`` and captures it into the; string variable ``REGISTER``. The second line verifies that whatever is in; ``REGISTER`` occurs later in the file after an ""``andw``"". :program:`FileCheck`; string substitution blocks are always contained in ``[[ ]]`` pairs, and string; variable names can be formed with the regex ``[a-zA-Z_][a-zA-Z0-9_]*``. If a; colon follows the name, then it is a definition of the variable; otherwise, it; is a substitution. :program:`FileCheck` variables can be defined multiple times, and substitutions; always get the latest value. Variables can also be substituted later on the; same line they were defined on. For example:. .. code-block:: llvm. ; CHECK: op [[REG:r[0-9]+]], [[REG]]. Can be useful if you want the operands of ``op`` to be the same register,; and don't care exactly which register it is. If ``--enable-var-scope`` is in effect, variables with names that; start with ``$`` are considered to be global. All others variables are; local. All local variables get undefined at the beginning of each; CHECK-LABEL block. Global variables are not affected by CHECK-LABEL.; This makes it easier to ensure that individual tests are not affected; by variables set in preceding tests. FileCheck Numeric Substitution Blocks; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. :program:`FileCheck` also supports numeric substitution blocks that allow; defining numeric variables and checking for numeric values that satisfy a; numeric expression constraint based on those variables via a numeric; substitution. This allows ``CHECK:`` directives to verify a numeric relation; between two numbers, such as the need for consecutive registers to be used. The syntax to capture a numeric value is; ``[[#%<fmtspec>,<NUMVAR>:]]`` where:. * ``%<fmtspec>,`` is an optional format specifier to indicate what number; format to match and the minimum number of digits to expect. * ``<NUMVAR>:`` is an optional definition of variable ``<NUMVAR>`` from the; c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:27597,variab,variables,27597,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variables']
Modifiability,"he flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:10895,config,configuration,10895,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['config'],['configuration']
Modifiability,"he generated; // histograms we open a browser and the TreeViewer; if (gROOT->IsBatch()) return;; new TBrowser ();; t1->StartViewer();. //In the browser, click on ""ROOT Files"", then on ""tree1.root""; //You can click on the histogram icons in the right panel to draw; //them in the TreeViewer, follow the instructions in the Help.; }; ```. ## Example 2: A Tree with a C Structure. The executable script for this example is; `$ROOTSYS/tutorials/tree/tree2.C. `In this example we show:. - how to build branches from a C structure; - how to make a branch with a fixed length array; - how to make a branch with a variable length array; - how to read selective branches; - how to fill a histogram from a branch; - how to use `TTree::Draw` to show a 3D plot. A C structure (`struct`) is used to build a ROOT tree. In general we; discourage the use of C structures`,` we recommend using a class; instead. However, we do support them for legacy applications written in; C or FORTRAN. The example `struct` holds simple variables and arrays. It; maps to a Geant3 common block `/gctrak/. `This is the definition of the; common block/structure:. ``` {.cpp}; const Int_t MAXMEC = 30;; // PARAMETER (MAXMEC=30); // COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7); // + ,NMEC,LMEC(MAXMEC); // + ,NAMEC(MAXMEC),NSTEP; // + ,PID,DESTEP,DESTEL,SAFETY,SLENG; // + ,STEP,SNEXT,SFIELD,TOFG,GEKRAT,UPWGHT. typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; ```. When using Geant3, the common block is filled by Geant3 routines at each; step and only the `TTree::Fill` method needs to be called. In this; example we emulate the Geant3 step routine with the `helixStep`; function. We also emulate the filling of the particle values. The ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:43471,variab,variables,43471,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"he histogram. Use `TTree::GetListOfFriends` to retrieve the list of friends from a; tree. When the tree is written to file (`TTree::Write`), the friends list is; saved with it. Moreover, when the tree is retrieved, the trees on the; friends list are also retrieved and the friendship restored. When a tree; is deleted, the elements of the friend list are also deleted. It is; possible to declare a friend tree that has the same internal structure; (same branches and leaves) as the original tree, and compare the same; values by specifying the tree. ``` {.cpp}; tree.Draw(""var:ft1.var:ft2.var"");; ```. The example code is in `$ROOTSYS/tutorials/tree/tree3.C`. Here is the; script:. ``` {.cpp}; void tree3w() {; // Example of a Tree where branches are variable length arrays; // A second Tree is created and filled in parallel.; // Run this script with .x tree3.C; // In the function treer, the first Tree is open.; // The second Tree is declared friend of the first tree.; // TTree::Draw is called with variables from both Trees.; const Int_t kMaxTrack = 500;; Int_t ntrack;; Int_t stat[kMaxTrack];; Int_t sign[kMaxTrack];; Float_t px[kMaxTrack];; Float_t py[kMaxTrack];; Float_t pz[kMaxTrack];; Float_t pt[kMaxTrack];; Float_t zv[kMaxTrack];; Float_t chi2[kMaxTrack];; Double_t sumstat;. // create the first root file with a tree; TFile f(""tree3.root"",""recreate"");; TTree *t3 = new TTree(""t3"",""Reconst ntuple"");; t3->Branch(""ntrack"",&ntrack,""ntrack/I"");; t3->Branch(""stat"",stat,""stat[ntrack]/I"");; t3->Branch(""sign"",sign,""sign[ntrack]/I"");; t3->Branch(""px"",px,""px[ntrack]/F"");; t3->Branch(""py"",py,""py[ntrack]/F"");; t3->Branch(""pz"",pz,""pz[ntrack]/F"");; t3->Branch(""zv"",zv,""zv[ntrack]/F"");; t3->Branch(""chi2"",chi2,""chi2[ntrack]/F"");. // create the second root file with a different tree; TFile fr(""tree3f.root"",""recreate"");; TTree *t3f = new TTree(""t3f"",""a friend Tree"");; t3f->Branch(""ntrack"",&ntrack,""ntrack/I"");; t3f->Branch(""sumstat"",&sumstat,""sumstat/D"");; t3f->Branch(""pt"",pt,""pt[ntrack]/F"");. /",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:55952,variab,variables,55952,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"he list of friends of `tree`. The number of entries; in the friend must be equal or greater to the number of entries of the; original tree. If the friend tree has fewer entries, a warning is given; and the missing entries are not included in the histogram. Use `TTree::GetListOfFriends` to retrieve the list of friends from a; tree. When the tree is written to file (`TTree::Write`), the friends list is; saved with it. Moreover, when the tree is retrieved, the trees on the; friends list are also retrieved and the friendship restored. When a tree; is deleted, the elements of the friend list are also deleted. It is; possible to declare a friend tree that has the same internal structure; (same branches and leaves) as the original tree, and compare the same; values by specifying the tree. ``` {.cpp}; tree.Draw(""var:ft1.var:ft2.var"");; ```. The example code is in `$ROOTSYS/tutorials/tree/tree3.C`. Here is the; script:. ``` {.cpp}; void tree3w() {; // Example of a Tree where branches are variable length arrays; // A second Tree is created and filled in parallel.; // Run this script with .x tree3.C; // In the function treer, the first Tree is open.; // The second Tree is declared friend of the first tree.; // TTree::Draw is called with variables from both Trees.; const Int_t kMaxTrack = 500;; Int_t ntrack;; Int_t stat[kMaxTrack];; Int_t sign[kMaxTrack];; Float_t px[kMaxTrack];; Float_t py[kMaxTrack];; Float_t pz[kMaxTrack];; Float_t pt[kMaxTrack];; Float_t zv[kMaxTrack];; Float_t chi2[kMaxTrack];; Double_t sumstat;. // create the first root file with a tree; TFile f(""tree3.root"",""recreate"");; TTree *t3 = new TTree(""t3"",""Reconst ntuple"");; t3->Branch(""ntrack"",&ntrack,""ntrack/I"");; t3->Branch(""stat"",stat,""stat[ntrack]/I"");; t3->Branch(""sign"",sign,""sign[ntrack]/I"");; t3->Branch(""px"",px,""px[ntrack]/F"");; t3->Branch(""py"",py,""py[ntrack]/F"");; t3->Branch(""pz"",pz,""pz[ntrack]/F"");; t3->Branch(""zv"",zv,""zv[ntrack]/F"");; t3->Branch(""chi2"",chi2,""chi2[ntrack]/F"");. // create the second roo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:55700,variab,variable,55700,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"he method; `TBranch::Fill()`. In this case you do not need to call `TTree::Fill()`; method. The entries can be set by `TTree::SetEntries(Double_t n)`.; Calling this method makes sense only if the number of existing entries; is null. ### Viewing the Tree. ![The tree1.root file and its tree in the browser and a leaf histogram](pictures/030000FC.png). In the right panel of the ROOT object browse are the branches: `ev`,; `px`, `py`, `pz`, and `random`. Note that these are shown as leaves; because they are ""end"" branches with only one leaf. To histogram a leaf,; we can simply double click on it in the browser. This is how the tree; `t1` looks in the Tree Viewer. Here we can add a cut and add other; operations for histogramming the leaves. See ""The Tree Viewer"". For; example, we can plot a two dimensional histogram. ![The tree viewer](pictures/030000FE.png). ### Reading the Tree. The `tree1r` function shows how to read the tree and access each entry; and each leaf. We first define the variables to hold the read values. ``` {.cpp}; Float_t px, py, pz;; ```. Then we tell the tree to populate these variables when reading an entry.; We do this with the method `TTree::SetBranchAddress`. The first; parameter is the branch name, and the second is the address of the; variable where the branch data is to be placed. In this example, the; branch name is `px`. This name was given when the tree was written (see; `tree1w`). The second parameter is the address of the variable `px`. ``` {.cpp}; t1->SetBranchAddress(""px"",&px);; ```. #### GetEntry. Once the branches have been given the address, a specific entry can be; read into the variables with the method `TTree::GetEntry(n)`. It; reads all the branches for entry (n) and populates the given address; accordingly. By default, `GetEntry()` reuses the space allocated by the; previous object for each branch. You can force the previous object to be; automatically deleted if you call `mybranch.SetAutoDelete(kTRUE)`; (default is `kFALSE`). Consi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:38065,variab,variables,38065,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"he module,; or zero if it is not. * *initid*: If non-zero, the value index of the initializer for this variable,; plus 1. .. _linkage type:. * *linkage*: An encoding of the linkage type for this variable:. * ``external``: code 0; * ``weak``: code 1; * ``appending``: code 2; * ``internal``: code 3; * ``linkonce``: code 4; * ``dllimport``: code 5; * ``dllexport``: code 6; * ``extern_weak``: code 7; * ``common``: code 8; * ``private``: code 9; * ``weak_odr``: code 10; * ``linkonce_odr``: code 11; * ``available_externally``: code 12; * deprecated : code 13; * deprecated : code 14. * alignment*: The logarithm base 2 of the variable's requested alignment, plus 1. * *section*: If non-zero, the 1-based section index in the table of; `MODULE_CODE_SECTIONNAME`_ entries. .. _visibility:. * *visibility*: If present, an encoding of the visibility of this variable:. * ``default``: code 0; * ``hidden``: code 1; * ``protected``: code 2. .. _bcthreadlocal:. * *threadlocal*: If present, an encoding of the thread local storage mode of the; variable:. * ``not thread local``: code 0; * ``thread local; default TLS model``: code 1; * ``localdynamic``: code 2; * ``initialexec``: code 3; * ``localexec``: code 4. .. _bcunnamedaddr:. * *unnamed_addr*: If present, an encoding of the ``unnamed_addr`` attribute of this; variable:. * not ``unnamed_addr``: code 0; * ``unnamed_addr``: code 1; * ``local_unnamed_addr``: code 2. .. _bcdllstorageclass:. * *dllstorageclass*: If present, an encoding of the DLL storage class of this variable:. * ``default``: code 0; * ``dllimport``: code 1; * ``dllexport``: code 2. * *comdat*: An encoding of the COMDAT of this function. * *attributes*: If nonzero, the 1-based index into the table of AttributeLists. .. _bcpreemptionspecifier:. * *preemptionspecifier*: If present, an encoding of the runtime preemption specifier of this variable:. * ``dso_preemptable``: code 0; * ``dso_local``: code 1. .. _FUNCTION:. MODULE_CODE_FUNCTION Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:28640,variab,variable,28640,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability,"he object:. ```c++; void UniqueOwnership3() {; std::unique_ptr<int> pi = std::make_unique<int>();; if (...) {; Borrow(pi);; } else {; int *pi_non_owning = pi.get();; vector<unique_ptr<int>> v = {std::move(pi)};; print(*pi_non_owning);; use(v);; }; }; ```. If the original code didn't call `delete` at the very end of the function, then; our refactoring may change the point at which we run the destructor and release; memory. Specifically, if there is some user code after `delete`, then extending; the lifetime of the object until the end of the function may hold locks for; longer than necessary, introduce memory overhead etc. One solution is to always replace `delete` with a call to `reset()`, and then; perform another analysis that removes unnecessary `reset()` calls. ```c++; void AddedMemoryOverhead() {; HugeObject *ho = new HugeObject();; use(ho);; delete ho; // Release the large amount of memory quickly.; LongRunningFunction();; }; ```. This analysis will refuse to refactor code that mixes borrowed pointer values; and unique ownership. In the following code, `GetPtr()` returns a borrowed; pointer, which is assigned to `pi`. Then, `pi` is used to hold a uniquely-owned; pointer. We don't distinguish between these two assignments, and we want each; assignment to be paired with a corresponding sink; otherwise, we transition the; pointer to a `Conflicting` state, like in this example. ```c++; void ConflictingOwnership() {; int *pi; // pi is Compatible; pi = GetPtr(); // pi is Defined; Borrow(pi); // pi is Defined. pi = new int; // pi is Conflicting; Borrow(pi);; delete pi;; // pi is Conflicting; }; ```. We could still handle this case by finding a maximal range in the code where; `pi` could be in the Compatible state, and only refactoring that part. ```c++; void ConflictingOwnership() {; int *pi;; pi = GetPtr();; Borrow(pi);. std::unique_ptr<int> pi_unique = std::make_unique<int>();; Borrow(pi_unique.get());; }; ```. ## Example: finding redundant branch conditions. In the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:24839,refactor,refactor,24839,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['refactor'],['refactor']
Modifiability,"he ownership has been transferred. ```c++; void UniqueOwnership3() {; int *pi = new int; // pi is Defined; if (...) {; Borrow(pi);; delete pi; // pi is Compatible; } else {; vector<unique_ptr<int>> v = {std::unique_ptr(pi)}; // pi is Compatible; print(*pi);; use(v);; }; // pi is Compatible; }; ```. We can refactor this code to use `unique_ptr`, however we would have to; introduce a non-owning pointer variable, since we can't use the moved-from; `unique_ptr` to access the object:. ```c++; void UniqueOwnership3() {; std::unique_ptr<int> pi = std::make_unique<int>();; if (...) {; Borrow(pi);; } else {; int *pi_non_owning = pi.get();; vector<unique_ptr<int>> v = {std::move(pi)};; print(*pi_non_owning);; use(v);; }; }; ```. If the original code didn't call `delete` at the very end of the function, then; our refactoring may change the point at which we run the destructor and release; memory. Specifically, if there is some user code after `delete`, then extending; the lifetime of the object until the end of the function may hold locks for; longer than necessary, introduce memory overhead etc. One solution is to always replace `delete` with a call to `reset()`, and then; perform another analysis that removes unnecessary `reset()` calls. ```c++; void AddedMemoryOverhead() {; HugeObject *ho = new HugeObject();; use(ho);; delete ho; // Release the large amount of memory quickly.; LongRunningFunction();; }; ```. This analysis will refuse to refactor code that mixes borrowed pointer values; and unique ownership. In the following code, `GetPtr()` returns a borrowed; pointer, which is assigned to `pi`. Then, `pi` is used to hold a uniquely-owned; pointer. We don't distinguish between these two assignments, and we want each; assignment to be paired with a corresponding sink; otherwise, we transition the; pointer to a `Conflicting` state, like in this example. ```c++; void ConflictingOwnership() {; int *pi; // pi is Compatible; pi = GetPtr(); // pi is Defined; Borrow(pi); // pi is D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:24347,extend,extending,24347,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['extend'],['extending']
Modifiability,"he point number `ipoint`.; - When a 2D histogram was drawn with error bars and has a function in its list; it was impossible to rotate it interactively. This problem was reported; [here](https://root-forum.cern.ch/t/2d-histogram-fit-draws-to-wrong-scale/26369).; - As more and more people are using `TGraph2D` for random cloud of points, the default; drawing option implying Delaunay triangulation was not appropriate. The default; drawing option is now change to `P0`.; - It is now possible to set the value of `MaxDigits` on individual axis as; requested [here](https://sft.its.cern.ch/jira/browse/ROOT-35).; For example, to accept 6 digits number like 900000 on the X axis of the; histogram `h` call:; ```{.cpp}; h->GetXaxis()->SetMaxDigits(6);; ```; - Auto-coloring for TF1 (drawing options PFC, PLC and PMC) is implemented. ## 3D Graphics Libraries; - When a LEGO plot was drawn with Theta=90, the X and Y axis were misplaced. ## Geometry Libraries; - Added system of units and physical constants matching the CLHEP port to Geant4, adapted to ROOT by Marko Petric.; - Computing radiation length and nuclear interaction length for mixtures as in Geant4 to have; numeric matching of average properties.; - Added support for reading region definition and production cuts for e+, e-, gamma, p; from GDML files; - Added support for reading/writing parts of the geometry tree to GDML (Markus Frank). ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## Parallelism; - Fix issue which prevented nested TBB task execution without race conditions, e.g. in TDataFrame; - Fix race condition in TTreeProcessorMT due to TBB nested task execution; - The TTaskGroup class has been added to the ROOT::Experimental namespace. It allows to submit to the runtime; item of work which are dealt with in parallel;; - The Async template function has been added the ROOT::Experimental namespace. The template function is analogous; to *std::async* but without the possibility of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:22954,adapt,adapted,22954,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['adapt'],['adapted']
Modifiability,"he problem:. #. ``opt ""-passes=lto<O3>"" a.out.0.2.internalize.bc``; #. ``llc a.out.0.5.precodegen.bc``. If one of these do crash, you should be able to reduce; this with :program:`llvm-reduce`; command line (use the bc file corresponding to the command above that failed):. .. code-block:: bash. llvm-reduce --test reduce.sh a.out.0.2.internalize.bc. Example of reduce.sh script. .. code-block:: bash. $ cat reduce.sh; #!/bin/bash -e. path/to/not --crash path/to/opt ""-passes=lto<O3>"" $1 -o temp.bc 2> err.log; grep -q ""It->second == &Insn"" err.log. Here we have grepped the failed assert message. Please run this, then file a bug with the instructions and reduced .bc file; that llvm-reduce emits. .. _miscompiling:. Miscompilations; ===============. If clang successfully produces an executable, but that executable doesn't run; right, this is either a bug in the code or a bug in the compiler. The first; thing to check is to make sure it is not using undefined behavior (e.g.; reading a variable before it is defined). In particular, check to see if the; program is clean under various `sanitizers; <https://github.com/google/sanitizers>`_ (e.g. ``clang; -fsanitize=undefined,address``) and `valgrind <http://valgrind.org/>`_. Many; ""LLVM bugs"" that we have chased down ended up being bugs in the program being; compiled, not LLVM. Once you determine that the program itself is not buggy, you should choose; which code generator you wish to compile the program with (e.g. LLC or the JIT); and optionally a series of LLVM passes to run. For example:. .. code-block:: bash. bugpoint -run-llc [... optzn passes ...] file-to-test.bc --args -- [program arguments]. bugpoint will try to narrow down your list of passes to the one pass that; causes an error, and simplify the bitcode file as much as it can to assist; you. It will print a message letting you know how to reproduce the; resulting error. The :doc:`OptBisect <OptBisect>` page shows an alternative method for finding; incorrect optimization",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst:8216,variab,variable,8216,interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,1,['variab'],['variable']
Modifiability,"he proper parameters, you get an actual class, which can then be; used to create object instances. An example usage:. ``` {.cpp}; >>> from ROOT import std; >>> v = std.vector(int)(); >>> for i in range(0,10):; ... v.push_back(i); ...; >>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; ```. The parameters to the template instantiation can either be an actual; type or value (as is used here, ""int""), or a string representation of; the parameters (e.g. ""'double'""), or a mixture of both (e.g. ""'TCanvas,; 0'"" or ""'double', 0"" ). The ""std::vector\<int\>"" class is one of the; classes builtin by default into the Cling extension dlls. You will get a; non-functional class (instances of which can still be passed around to; C++) if the corresponding dictionary doesn't exist. #### Access to ROOT Globals. Most globals and global functions can be imported directly from the; ROOT.py module, but some common ones (most notably **`gMinuit`**,; although that variable now exists at startup from release 5.08 onward); do not exist yet at program startup, as they exist in modules that are; loaded later (e.g. through the auto-loading mechanism). An example; session should make this clear:. ``` {.cpp}; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; ```. It is also possible to create globals interactively, either by executing; a Cling macro, or by a call to `gROOT.ProcessLine()`. These globals are; made available in the same way: either use them directly after",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:12958,variab,variable,12958,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['variab'],['variable']
Modifiability,"he rest of the rule remains unchanged:. .. code-block:: c++. llvm::StringRef s = ""str"";; makeRule(; cxxMemberCallExpr(; on(expr(hasType(namedDecl(hasName(""std::string"")))); 	 .bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. Example: rewriting method calls; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In this example, we delete an ""intermediary"" method call in a string of; invocations. This scenario can arise, for example, if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(""``child`` accessor is being removed; call "",; 		member(m), "" directly on parent""));. This rule isn't quite what we want: it will rewrite ``my_object.child().foo()`` to; ``my_object.foo()``, but it will also rewrite ``my_ptr->child().foo()`` to; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:7970,rewrite,rewrite,7970,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['rewrite'],['rewrite']
Modifiability,"he right default attribute. Promotion expression; ====================. A new expression will be introduced to represent the conversion from a pointer; with an external bounds annotation, such as ``__counted_by``, to; ``__bidi_indexable``. This type of conversion cannot be handled by normal; CastExprs because it requires an extra subexpression(s) to provide the bounds; information necessary to create a wide pointer. Bounds check expression; =======================. Bounds checks are part of semantics defined in the ``-fbounds-safety`` language; model. Hence, exposing the bounds checks and other semantic actions in the AST; is desirable. A new expression for bounds checks has been added to the AST. The; bounds check expression has a ``BoundsCheckKind`` to indicate the kind of checks; and has the additional sub-expressions that are necessary to perform the check; according to the kind. Paired assignment check; =======================. ``-fbounds-safety`` enforces that variables or fields related with the same; external bounds annotation (e.g., ``buf`` and ``count`` related with; ``__counted_by`` in the example below) must be updated side by side within the; same basic block and without side effect in between. .. code-block:: c. typedef struct {; int *__counted_by(count) buf; size_t count;; } sized_buf_t;. void alloc_buf(sized_buf_t *sbuf, sized_t nelems) {; sbuf->buf = (int *)malloc(sizeof(int) * nelems);; sbuf->count = nelems;; }. To implement this rule, the compiler requires a linear representation of; statements to understand the ordering and the adjacency between the two or more; assignments. The Clang CFG is used to implement this analysis as Clang CFG; provides a linear view of statements within each ``CFGBlock`` (Clang; ``CFGBlock`` represents a single basic block in a source-level CFG). Bounds check optimizations; ==========================. In ``-fbounds-safety``, the Clang frontend emits run-time checks for every; memory dereference if the type system or ana",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:5114,variab,variables,5114,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['variab'],['variables']
Modifiability,"he root of the output file is a JSON object (i.e. dictionary),; containing the following fixed keys:. * ``!tablegen_json_version``: a numeric version field that will; increase if an incompatible change is ever made to the structure of; this data. The format described here corresponds to version 1. * ``!instanceof``: a dictionary whose keys are the class names defined; in the TableGen input. For each key, the corresponding value is an; array of strings giving the names of ``def`` records that derive; from that class. So ``root[""!instanceof""][""Instruction""]``, for; example, would list the names of all the records deriving from the; class ``Instruction``. For each ``def`` record, the root object also has a key for the record; name. The corresponding value is a subsidiary object containing the; following fixed keys:. * ``!superclasses``: an array of strings giving the names of all the; classes that this record derives from. * ``!fields``: an array of strings giving the names of all the variables; in this record that were defined with the ``field`` keyword. * ``!name``: a string giving the name of the record. This is always; identical to the key in the JSON root object corresponding to this; record's dictionary. (If the record is anonymous, the name is; arbitrary.). * ``!anonymous``: a boolean indicating whether the record's name was; specified by the TableGen input (if it is ``false``), or invented by; TableGen itself (if ``true``). For each variable defined in a record, the ``def`` object for that; record also has a key for the variable name. The corresponding value; is a translation into JSON of the variable's value, using the; conventions described below. Some TableGen data types are translated directly into the; corresponding JSON type:. * A completely undefined value (e.g. for a variable declared without; initializer in some superclass of this record, and never initialized; by the record itself or any other superclass) is emitted as the JSON; ``null`` value. * ``int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst:16167,variab,variables,16167,interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,1,['variab'],['variables']
Modifiability,"he same array,; etc.). Query for this feature with ``__has_builtin(__builtin_assume_separate_storage)``. ``__builtin_offsetof``; ----------------------. ``__builtin_offsetof`` is used to implement the ``offsetof`` macro, which; calculates the offset (in bytes) to a given member of the given type. **Syntax**:. .. code-block:: c++. __builtin_offsetof(type-name, member-designator). **Example of Use**:. .. code-block:: c++. struct S {; char c;; int i;; struct T {; float f[2];; } t;; };. const int offset_to_i = __builtin_offsetof(struct S, i);; const int ext1 = __builtin_offsetof(struct U { int i; }, i); // C extension; const int offset_to_subobject = __builtin_offsetof(struct S, t.f[1]);. **Description**:. This builtin is usable in an integer constant expression which returns a value; of type ``size_t``. The value returned is the offset in bytes to the subobject; designated by the member-designator from the beginning of an object of type; ``type-name``. Clang extends the required standard functionality in the; following way:. * In C language modes, the first argument may be the definition of a new type.; Any type declared this way is scoped to the nearest scope containing the call; to the builtin. Query for this feature with ``__has_builtin(__builtin_offsetof)``. ``__builtin_call_with_static_chain``; ------------------------------------. ``__builtin_call_with_static_chain`` is used to perform a static call while; setting updating the static chain register. **Syntax**:. .. code-block:: c++. T __builtin_call_with_static_chain(T expr, void* ptr). **Example of Use**:. .. code-block:: c++. auto v = __builtin_call_with_static_chain(foo(3), foo);. **Description**:. This builtin returns ``expr`` after checking that ``expr`` is a non-member; static call expression. The call to that expression is made while using ``ptr``; as a function pointer stored in a dedicated register to implement *static chain*; calling convention, as used by some language to implement closures or nested; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:101661,extend,extends,101661,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['extend'],['extends']
Modifiability,"he test suite, you need to use the following steps:. #. Check out the ``test-suite`` module with:. .. code-block:: bash. % git clone https://github.com/llvm/llvm-test-suite.git test-suite. #. FIXME: these directions are outdated and won't work. Figure out; what the correct thing to do is, and write it down here. #. Configure and build ``llvm``. #. Configure and build ``llvm-gcc``. #. Install ``llvm-gcc`` somewhere. #. *Re-configure* ``llvm`` from the top level of each build tree (LLVM; object directory tree) in which you want to run the test suite, just; as you do before building LLVM. During the *re-configuration*, you must either: (1) have ``llvm-gcc``; you just built in your path, or (2) specify the directory where your; just-built ``llvm-gcc`` is installed using; ``--with-llvmgccdir=$LLVM_GCC_DIR``. You must also tell the configure machinery that the test suite is; available so it can be configured for your build tree:. .. code-block:: bash. % cd $LLVM_OBJ_ROOT ; $LLVM_SRC_ROOT/configure [--with-llvmgccdir=$LLVM_GCC_DIR]. [Remember that ``$LLVM_GCC_DIR`` is the directory where you; *installed* llvm-gcc, not its src or obj directory.]. #. You can now run the test suite from your build tree as follows:. .. code-block:: bash. % cd $LLVM_OBJ_ROOT/projects/test-suite; % make. Note that the second and third steps only need to be done once. After; you have the suite checked out and configured, you don't need to do it; again (unless the test code or configure script changes). Configuring External Tests; ==========================. In order to run the External tests in the ``test-suite`` module, you; must specify *--with-externals*. This must be done during the; *re-configuration* step (see above), and the ``llvm`` re-configuration; must recognize the previously-built ``llvm-gcc``. If any of these is; missing or neglected, the External tests won't work. * *--with-externals*. * *--with-externals=<directory>*. This tells LLVM where to find any external tests. They are expe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:1369,config,configure,1369,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,1,['config'],['configure']
Modifiability,"he toolchain from step 1. to build libc++, libc++abi, and libunwind. It is also possible to cross-compile from Linux. One method of building the libraries in step 2. is to build them ""stand-alone"".; A stand-alone build doesn't involve the rest of the LLVM tree. The steps are:. * ``cd build-dir``; * ``cmake -DLLVM_PATH=<path to llvm checkout e.g. /llvm-project/> -DCMAKE_INSTALL_PREFIX=<install path> <other options> <path to project e.g. /llvm-project/libcxxabi>``; * ``<make program e.g. ninja>``; * ``<make program> install``. More information on standalone builds can be found in the build documentation for; the respective libraries. The next section discuss the salient options and modifications; required for building and installing the libraries using standalone builds. This assumes; that we are building libunwind and ibc++ as DLLs and statically linking libc++abi into; libc++. Other build configurations are possible, but they are not discussed here. Common CMake configuration options:; -----------------------------------. * ``-D_LIBCPP_ABI_FORCE_ITANIUM'``. Tell the libc++ headers that the Itanium C++ ABI is being used. * ``-DCMAKE_C_FLAGS=""-lmsvcrt -llegacy_stdio_definitions -D_NO_CRT_STDIO_INLINE""``. Supply CRT definitions including stdio definitions that have been removed from the MS VS CRT.; We don't want the stdio functions declared inline as they will cause multiple definition; errors when the same symbols are pulled in from legacy_stdio_definitions.ib. * ``-DCMAKE_INSTALL_PREFIX=<install path>``. Where to install the library and headers. Building libunwind:; -------------------. * ``-DLIBUNWIND_ENABLE_SHARED=ON``; * ``-DLIBUNWIND_ENABLE_STATIC=OFF``. libunwind can be built as a DLL. It is not dependent on other projects. * ``-DLIBUNWIND_USE_COMPILER_RT=OFF``. We use the MS runtime. The CMake files will need to be edited to prevent them adding GNU specific libraries to the link line. Building libc++abi:; -------------------. * ``-DLIBCXXABI_ENABLE_SHARED=OFF``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst:4086,config,configuration,4086,interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst,1,['config'],['configuration']
Modifiability,"he value; of ``idx`` exceeds the runtime length of the vector, the result is a; :ref:`poison value <poisonvalues>`. Example:; """""""""""""""". .. code-block:: text. <result> = extractelement <4 x i32> %vec, i32 0 ; yields i32. .. _i_insertelement:. '``insertelement``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = insertelement <n x <ty>> <val>, <ty> <elt>, <ty2> <idx> ; yields <n x <ty>>; <result> = insertelement <vscale x n x <ty>> <val>, <ty> <elt>, <ty2> <idx> ; yields <vscale x n x <ty>>. Overview:; """""""""""""""""". The '``insertelement``' instruction inserts a scalar element into a; vector at a specified index. Arguments:; """""""""""""""""""". The first operand of an '``insertelement``' instruction is a value of; :ref:`vector <t_vector>` type. The second operand is a scalar value whose; type must equal the element type of the first operand. The third operand; is an index indicating the position at which to insert the value. The; index may be a variable of any integer type, and will be treated as an; unsigned integer. Semantics:; """""""""""""""""""". The result is a vector of the same type as ``val``. Its element values; are those of ``val`` except at position ``idx``, where it gets the value; ``elt``. If ``idx`` exceeds the length of ``val`` for a fixed-length vector,; the result is a :ref:`poison value <poisonvalues>`. For a scalable vector,; if the value of ``idx`` exceeds the runtime length of the vector, the result; is a :ref:`poison value <poisonvalues>`. Example:; """""""""""""""". .. code-block:: text. <result> = insertelement <4 x i32> %vec, i32 1, i32 0 ; yields <4 x i32>. .. _i_shufflevector:. '``shufflevector``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = shufflevector <n x <ty>> <v1>, <n x <ty>> <v2>, <m x i32> <mask> ; yields <m x <ty>>; <result> = shufflevector <vscale x n x <ty>> <v1>, <vscale x n x <ty>> v2, <vscale x m x i32> <mask> ; yields <vscale x m x <ty>>. Overview:; """""""""""""""""". The '``shufflevector``' instructi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:402842,variab,variable,402842,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"he variable `y` is between `fYmin` and `fYmax`. If a; minimum or maximum value is set for the Y scale before filling, then; all values below `ylow` or above `yup` will be discarded. Setting the; minimum or maximum value for the Y scale before filling has the same; effect as calling the special **`TProfile`** constructor above where; `ylow` and `yup` are specified. ### Build Options. The last parameter is the build option. If a bin has N data points all; with the same value Y, which is the case when dealing with integers,; the spread in Y for that bin is zero, and the uncertainty assigned is; also zero, and the bin is ignored in making subsequent fits. If; `SQRT(Y)` was the correct error in the case above, then; `SQRT(Y)/SQRT(N)` would be the correct error here. In fact, any bin; with non-zero number of entries N but with zero spread; (`spread = s[j]`) should have an uncertainty `SQRT(Y)/SQRT(N)`. Now,; is `SQRT(Y)/SQRT(N)` really the correct uncertainty ? That it is only; in the case where the Y variable is some sort of counting statistics,; following a Poisson distribution. This is the default case. However, Y; can be any variable from an original `NTUPLE`, and does not; necessarily follow a Poisson distribution. The computation of errors; is based on Y = values of data points; N = number of data points. - `' '` - the default is blank, the errors are:. - `spread/SQRT(N)` for a non-zero spread. - `SQRT(Y)/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. - ‘ `s` ' - errors are:. - `spread` for a non-zero spread. - `SQRT(Y)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `i` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `1/SQRT(12*N)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `G` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `sigma/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. The option ' `i` ' is used for integer Y value",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:64174,variab,variable,64174,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['variab'],['variable']
Modifiability,"he variables are parsed, we then parse the body and create the; AST node:. .. code-block:: c++. // At this point, we have to have 'in'.; if (CurTok != tok_in); return LogError(""expected 'in' keyword after 'var'"");; getNextToken(); // eat 'in'. auto Body = ParseExpression();; if (!Body); return nullptr;. return std::make_unique<VarExprAST>(std::move(VarNames),; std::move(Body));; }. Now that we can parse and represent the code, we need to support; emission of LLVM IR for it. This code starts out with:. .. code-block:: c++. Value *VarExprAST::codegen() {; std::vector<AllocaInst *> OldBindings;. Function *TheFunction = Builder->GetInsertBlock()->getParent();. // Register all variables and emit their initializer.; for (unsigned i = 0, e = VarNames.size(); i != e; ++i) {; const std::string &VarName = VarNames[i].first;; ExprAST *Init = VarNames[i].second.get();. Basically it loops over all the variables, installing them one at a; time. For each variable we put into the symbol table, we remember the; previous value that we replace in OldBindings. .. code-block:: c++. // Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.; Value *InitVal;; if (Init) {; InitVal = Init->codegen();; if (!InitVal); return nullptr;; } else { // If not specified, use 0.0.; InitVal = ConstantFP::get(*TheContext, APFloat(0.0));; }. AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);; Builder->CreateStore(InitVal, Alloca);. // Remember the old variable binding so that we can restore the binding when; // we unrecurse.; OldBindings.push_back(NamedValues[VarName]);. // Remember this binding.; NamedValues[VarName] = Alloca;; }. There are more comments here than code. The basic idea is that we emit; the initializer, create the alloca, then update the symbol table to; point to it. Once all the variables are installed in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:27018,variab,variable,27018,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"he; `CoreCLR <https://github.com/dotnet/coreclr>`__ runtime. Support for this GC strategy is a work in progress. This strategy will; differ from; :ref:`statepoint-example GC<statepoint_example_gc>` strategy in; certain aspects like:. * Base-pointers of interior pointers are not explicitly; tracked and reported. * A different format is used for encoding stack maps. * Safe-point polls are only needed before loop-back edges; and before tail-calls (not needed at function-entry). Custom GC Strategies; ====================. If none of the built in GC strategy descriptions met your needs above, you will; need to define a custom GCStrategy and possibly, a custom LLVM pass to perform; lowering. Your best example of where to start defining a custom GCStrategy; would be to look at one of the built in strategies. You may be able to structure this additional code as a loadable plugin library.; Loadable plugins are sufficient if all you need is to enable a different; combination of built in functionality, but if you need to provide a custom; lowering pass, you will need to build a patched version of LLVM. If you think; you need a patched build, please ask for advice on llvm-dev. There may be an; easy way we can extend the support to make it work for your use case without; requiring a custom build. Collector Requirements; ----------------------. You should be able to leverage any existing collector library that includes the following elements:. #. A memory allocator which exposes an allocation function your compiled; code can call. #. A binary format for the stack map. A stack map describes the location; of references at a safepoint and is used by precise collectors to identify; references within a stack frame on the machine stack. Note that collectors; which conservatively scan the stack don't require such a structure. #. A stack crawler to discover functions on the call stack, and enumerate the; references listed in the stack map for each call site. #. A mechanism for identifyin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:21934,plugin,plugins,21934,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['plugin'],['plugins']
Modifiability,"he; individual instructions. TableGen allows an arbitrary hierarchy of classes,; so that the abstract classes for two concepts can share a third superclass that; abstracts common ""sub-concepts"" from the two original concepts. In order to make classes more useful, a concrete record (or another class); can request a class as a parent class and pass *template arguments* to it.; These template arguments can be used in the fields of the parent class to; initialize them in a custom manner. That is, record or class ``A`` can; request parent class ``S`` with one set of template arguments, while record or class; ``B`` can request ``S`` with a different set of arguments. Without template; arguments, many more classes would be required, one for each combination of; the template arguments. Both classes and concrete records can include fields that are uninitialized.; The uninitialized ""value"" is represented by a question mark (``?``). Classes; often have uninitialized fields that are expected to be filled in when those; classes are inherited by concrete records. Even so, some fields of concrete; records may remain uninitialized. TableGen provides *multiclasses* to collect a group of record definitions in; one place. A multiclass is a sort of macro that can be ""invoked"" to define; multiple concrete records all at once. A multiclass can inherit from other; multiclasses, which means that the multiclass inherits all the definitions; from its parent multiclasses. `Appendix C: Sample Record`_ illustrates a complex record in the Intel X86; target and the simple way in which it is defined. Source Files; ============. TableGen source files are plain ASCII text files. The files can contain; statements, comments, and blank lines (see `Lexical Analysis`_). The standard file; extension for TableGen files is ``.td``. TableGen files can grow quite large, so there is an include mechanism that; allows one file to include the content of another file (see `Include; Files`_). This allows large file",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:5132,inherit,inherited,5132,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inherited']
Modifiability,"heJIT = std::make_unique<KaleidoscopeJIT>();. // Run the main ""interpreter loop"" now.; MainLoop();. return 0;; }. We also need to setup the data layout for the JIT:. .. code-block:: c++. void InitializeModuleAndPassManager(void) {; // Open a new context and module.; TheContext = std::make_unique<LLVMContext>();; TheModule = std::make_unique<Module>(""my cool jit"", TheContext);; TheModule->setDataLayout(TheJIT->getDataLayout());. // Create a new builder for the module.; Builder = std::make_unique<IRBuilder<>>(*TheContext);. // Create a new pass manager attached to it.; TheFPM = std::make_unique<legacy::FunctionPassManager>(TheModule.get());; ... The KaleidoscopeJIT class is a simple JIT built specifically for these; tutorials, available inside the LLVM source code; at `llvm-src/examples/Kaleidoscope/include/KaleidoscopeJIT.h; <https://github.com/llvm/llvm-project/blob/main/llvm/examples/Kaleidoscope/include/KaleidoscopeJIT.h>`_.; In later chapters we will look at how it works and extend it with; new features, but for now we will take it as given. Its API is very simple:; ``addModule`` adds an LLVM IR module to the JIT, making its functions; available for execution (with its memory managed by a ``ResourceTracker``); and; ``lookup`` allows us to look up pointers to the compiled code. We can take this simple API and change our code that parses top-level expressions to; look like this:. .. code-block:: c++. static ExitOnError ExitOnErr;; ...; static void HandleTopLevelExpression() {; // Evaluate a top-level expression into an anonymous function.; if (auto FnAST = ParseTopLevelExpr()) {; if (FnAST->codegen()) {; // Create a ResourceTracker to track JIT'd memory allocated to our; // anonymous expression -- that way we can free it after executing.; auto RT = TheJIT->getMainJITDylib().createResourceTracker();. auto TSM = ThreadSafeModule(std::move(TheModule), std::move(TheContext));; ExitOnErr(TheJIT->addModule(std::move(TSM), RT));; InitializeModuleAndPassManager();. // Sear",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:12151,extend,extend,12151,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['extend'],['extend']
Modifiability,help/latest/variable/CMAKE_LANG_FLAGS.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html). - `CMAKE_C_COMPILER`. Select the C compiler executable to be used. Note that the C++ compiler is; inferred automatically i.e. when specifying `path/to/clang` CMake will; automatically use `path/to/clang++` as the C++ compiler. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html). - `CMAKE_Fortran_COMPILER`. Select the Fortran compiler executable to be used. Not set by default and not; required unless running the Fortran Test Suite. - `CMAKE_BUILD_TYPE`. Select a build type like `OPTIMIZE` or `DEBUG` selecting a set of predefined; compiler flags. These flags are applied regardless of the `CMAKE_C_FLAGS`; option and may be changed by modifying `CMAKE_C_FLAGS_OPTIMIZE` etc. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html](https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html). - `TEST_SUITE_FORTRAN`. Activate that Fortran tests. This is a work in progress. More information can be; found in the [Flang documentation](https://flang.llvm.org/docs/FortranLLVMTestSuite.html). - `TEST_SUITE_RUN_UNDER`. Prefix test invocations with the given tool. This is typically used to run; cross-compiled tests within a simulator tool. - `TEST_SUITE_BENCHMARKING_ONLY`. Disable tests that are unsuitable for performance measurements. The disabled; tests either run for a very short time or are dominated by I/O performance; making them unsuitable as compiler performance tests. - `TEST_SUITE_SUBDIRS`. Semicolon-separated list of directories to include. This can be used to only; build parts of the test-suite or to include external suites. This option; does not work reliably with deeper subdirectories as it skips intermediate; `CMakeLists.txt` files which may be required. - `TEST_SUITE_COLLECT_STATS`. Collect internal LLVM statistics. Appends `-save-stats,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:5193,variab,variable,5193,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['variab'],['variable']
Modifiability,"hen be passed to a TableGen backend. TableGen allows you to define Classes and Defs (which are instances of classes) but it doesn't encode what to do with that structure. That's what the backend does. The backend converts this structure into something useful, for example C++ code. These backends are included in the `llvm-tblgen` binary and you can choose which one to run using a command line option. If you don't choose a backend you get a dump of the structure, and that is what this notebook will be showing. This tutorial will focus on the language itself only. The only thing you need to know now is that in addition to `llvm-tblgen` you will see other `*-tblgen` like `clang-tblgen`. The difference between them is the backends they include. The default output from `llvm-tblgen` looks like this:. ```tablegen; %config cellreset on. // Empty source file; ```. ------------- Classes -----------------; ------------- Defs -----------------. **Note:** `%config` is not a TableGen command but a ""magic"" command to the Jupyter kernel for this notebook. By default new cells include the content of previously run cells, but for this notebook we mostly want each to be isolated. On occasion we will use the `%noreset` magic to override this. No source means no classes and no defs. Let's add a class. ## Classes. ```tablegen; class C {}; ```. ------------- Classes -----------------; class C {; }; ------------- Defs -----------------. Followed by a def (definition). ```tablegen; %noreset. def X: C;; ```. ------------- Classes -----------------; class C {; }; ------------- Defs -----------------; def X {	// C; }. `def` creates an instance of a class. Typically, the main loop of a TableGen backend will look for all defs that are instances of a certain class. For example if I am generating register information I would look for all defs that are instances of `RegisterInfo` in the example below. ```tablegen; class RegisterInfo {}; def X0: RegisterInfo {}; def X1: RegisterInfo {}; ```. --------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md:1697,config,config,1697,interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,1,['config'],['config']
Modifiability,"hen emitting a; diagnostic. For example, when this is enabled, Clang will print; something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. .. option:: -f[no-]color-diagnostics. This option, which defaults to on when a color-capable terminal is; detected, controls whether or not Clang prints diagnostics in color. When this option is enabled, Clang will use colors to highlight; specific parts of the diagnostic, e.g.,. .. nasty hack to not lose our dignity. .. raw:: html. <pre>; <b><span style=""color:black"">test.c:28:8: <span style=""color:magenta"">warning</span>: extra tokens at end of #endif directive [-Wextra-tokens]</span></b>; #endif bad; <span style=""color:green"">^</span>; <span style=""color:green"">//</span>; </pre>. When this is disabled, Clang will just print:. ::. test.c:2:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. If the ``NO_COLOR`` environment variable is defined and not empty; (regardless of value), color diagnostics are disabled. If ``NO_COLOR`` is; defined and ``-fcolor-diagnostics`` is passed on the command line, Clang; will honor the command line argument. .. option:: -fansi-escape-codes. Controls whether ANSI escape codes are used instead of the Windows Console; API to output colored diagnostics. This option is only used on Windows and; defaults to off. .. option:: -fdiagnostics-format=clang/msvc/vi. Changes diagnostic output format to better match IDEs and command line tools. This option controls the output format of the filename, line number,; and column printed in diagnostic messages. The options, and their; affect on formatting a simple conversion diagnostic, follow:. **clang** (default); ::. t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int'. **msvc**; ::. t.c(3,11) : warning: conversion specifies type 'char *' but the argument has type 'int'. **vi**; ::. t.c +3:11: warning: conversion specifies type 'char ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:7915,variab,variable,7915,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variable']
Modifiability,"hen exiting the function. ``` {.cpp}; void foo() {; TFile *f = new TFile(""AFile.root"",""RECREATE"");; }; ```. ### Retrieving Objects from Disk. If you have a ROOT session running, please quit and start fresh. We saw that multiple versions of an object with the same name could be; in a ROOT file. In our example, we saved a modified histogram `hpx` to; the file, which resulted in two `hpx's` uniquely identified by the cycle; number: `hpx;1` and `hpx;2`. The question is how we can retrieve the; right version of `hpx`. When opening the file and using `hpx`, Cling; retrieves the one with the highest cycle number. To read the `hpx;1`; into memory, rather than the `hpx:2` we would get by default, we have to; explicitly get it and assign it to a variable. ``` {.cpp}; root[] TFile *f1 = new TFile(""hsimple.root""); root[] TH1F *hpx1; f1->GetObject(""hpx;1"",hpx); root[] hpx1->Draw(); ```. ### Subdirectories and Navigation. The **`TDirectory`** class lets you organize its contents into; subdirectories, and **`TFile`** being a descendent of **`TDirectory`**; inherits this ability. Here is an example of a ROOT file with multiple; subdirectories as seen in the ROOT browser. To add a subdirectory to a; file use `TDirectory::mkdir`. The example below opens the file for; writing and creates a subdirectory called ""Wed011003"". Listing the; contents of the file shows the new directory in the file and the; **`TDirectory`** object in memory. ``` {.cpp}; root[] TFile *f = new TFile(""AFile.root"",""RECREATE""); root[] f->mkdir(""Wed011003""); (class TDirectory*)0x1072b5c8; ```. ``` {.cpp}; root[] f->ls(); TFile** AFile.root; TFile* AFile.root; TDirectory* Wed011003 Wed011003; KEY: TDirectory Wed011003;1 Wed011003; ```. We can change the current directory by navigating into the subdirectory,; and after changing directory; we can see that ***`gDirectory`*** is now; ""`Wed011003`"". ``` {.cpp}; root[] f->cd(""Wed011003""); root[] gDirectory->pwd(); AFile.root:/Wed011003; ```. In addition to ***`gDirectory`*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:37270,inherit,inherits,37270,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['inherit'],['inherits']
Modifiability,"hen use the command; `gROOT->SetStyle(""MyStyleName"");` to make this new style definition the; default one. As an example, have a look in the file `rootlogon.C` coming; with this tutorial. Another relevant file is `rootlogoff.C` that it; called when the session is finished. ### ROOT command history ###. Every command typed at the ROOT prompt is stored in a file `.root_hist`; in your home directory. ROOT uses this file to allow for navigation in; the command history with the up-arrow and down-arrow keys. It is also; convenient to extract successful ROOT commands with the help of a text; editor for use in your own macros. ### ROOT Global Pointers ###. All global pointers in ROOT begin with a small ""g"". Some of them were; already implicitly introduced (for example in the section; [Configure ROOT at start-up](#configure-root-at-start-up)).; The most important among them are presented in the following:. - **[gROOT](https://root.cern.ch/doc/master/classTROOT.html)**: the `gROOT`; variable is the entry point to the ROOT system. Technically it is an; instance of the `TROOT` class. Using the `gROOT` pointer one has; access to basically every object created in a ROOT based program.; The `TROOT` object is essentially a container of several lists; pointing to the main `ROOT` objects. - **[gStyle](https://root.cern.ch/doc/master/classTStyle.html)**: By default; ROOT creates a default style that can be accessed via the `gStyle`; pointer. This class includes functions to set some of the following; object attributes. - Canvas; - Pad; - Histogram axis; - Lines; - Fill areas; - Text; - Markers; - Functions; - Histogram Statistics and Titles; - etc ... - **[gSystem](https://root.cern.ch/doc/master/classTSystem.html)**: An; instance of a base class defining a generic interface to the; underlying Operating System, in our case `TUnixSystem`. - **[gInterpreter](http://root.cern.ch/htmldoc/html/TInterpreter.html)**: The; entry point for the ROOT interpreter. Technically an abstraction level;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:20220,variab,variable,20220,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['variab'],['variable']
Modifiability,"her = binaryOperator(isAssignmentOperator())); if (a == b); a += b;. Example 2: matches s1 = s2; (matcher = cxxOperatorCallExpr(isAssignmentOperator())); struct S { S& operator=(const S&); };; void x() { S s1, s2; s1 = s2; }. Matcher<BinaryOperator>isComparisonOperator; Matches comparison operators. Example 1: matches a == b (matcher = binaryOperator(isComparisonOperator())); if (a == b); a += b;. Example 2: matches s1 < s2; (matcher = cxxOperatorCallExpr(isComparisonOperator())); struct S { bool operator<(const S& other); };; void x(S s1, S s2) { bool b1 = s1 < s2; }. Matcher<CXXBaseSpecifier>isPrivate; Matches private C++ declarations and C++ base specifers that specify private; inheritance. Examples:; class C {; public: int a;; protected: int b;; private: int c; // fieldDecl(isPrivate()) matches 'c'; };. struct Base {};; struct Derived1 : private Base {}; // matches 'Base'; class Derived2 : Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isProtected; Matches protected C++ declarations and C++ base specifers that specify; protected inheritance. Examples:; class C {; public: int a;; protected: int b; // fieldDecl(isProtected()) matches 'b'; private: int c;; };. class Base {};; class Derived : protected Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isPublic; Matches public C++ declarations and C++ base specifers that specify public; inheritance. Examples:; class C {; public: int a; // fieldDecl(isPublic()) matches 'a'; protected: int b;; private: int c;; };. class Base {};; class Derived1 : public Base {}; // matches 'Base'; struct Derived2 : Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isVirtual; Matches declarations of virtual methods and C++ base specifers that specify; virtual inheritance. Example:; class A {; public:; virtual void x(); // matches x; };. Example:; class Base {};; class DirectlyDerived : virtual Base {}; // matches Base; class IndirectlyDerived : DirectlyDerived, Base {}; // matches Base. Usable as: Matcher<CXXMethodDecl>, Matc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:57039,inherit,inheritance,57039,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['inherit'],['inheritance']
Modifiability,"her expression AST node; definitions that we'll use in the basic form of the Kaleidoscope; language:. .. code-block:: c++. /// VariableExprAST - Expression class for referencing a variable, like ""a"".; class VariableExprAST : public ExprAST {; std::string Name;. public:; VariableExprAST(const std::string &Name) : Name(Name) {}; };. /// BinaryExprAST - Expression class for a binary operator.; class BinaryExprAST : public ExprAST {; char Op;; std::unique_ptr<ExprAST> LHS, RHS;. public:; BinaryExprAST(char Op, std::unique_ptr<ExprAST> LHS,; std::unique_ptr<ExprAST> RHS); : Op(Op), LHS(std::move(LHS)), RHS(std::move(RHS)) {}; };. /// CallExprAST - Expression class for function calls.; class CallExprAST : public ExprAST {; std::string Callee;; std::vector<std::unique_ptr<ExprAST>> Args;. public:; CallExprAST(const std::string &Callee,; std::vector<std::unique_ptr<ExprAST>> Args); : Callee(Callee), Args(std::move(Args)) {}; };. This is all (intentionally) rather straight-forward: variables capture; the variable name, binary operators capture their opcode (e.g. '+'), and; calls capture a function name as well as a list of any argument; expressions. One thing that is nice about our AST is that it captures; the language features without talking about the syntax of the language.; Note that there is no discussion about precedence of binary operators,; lexical structure, etc. For our basic language, these are all of the expression nodes we'll; define. Because it doesn't have conditional control flow, it isn't; Turing-complete; we'll fix that in a later installment. The two things; we need next are a way to talk about the interface to a function, and a; way to talk about functions themselves:. .. code-block:: c++. /// PrototypeAST - This class represents the ""prototype"" for a function,; /// which captures its name, and its argument names (thus implicitly the number; /// of arguments the function takes).; class PrototypeAST {; std::string Name;; std::vector<std::string> Args;. publ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:3321,variab,variables,3321,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"her. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). Method No Fisher Fisher, Mahalanobis Discrimination method. Configuration options for MVA method :. Configuration options reference for MVA method: PDERS. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). VolumeRangeMode No Adaptive Unscaled, MinMax, RMS, Adaptive, kNN Method to determine volume size. Kerne",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:3443,Config,Configuration,3443,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['Config'],['Configuration']
Modifiability,"her; does the same job as `scan-build` does. So, you can expect the same output; from this line as simple `scan-build` would do:. $ intercept-build <your build command> && analyze-build. The major difference is how and when the analyzer is run. The `scan-build`; tool has three distinct model to run the analyzer:. 1. Use compiler wrappers to make actions.; The compiler wrappers does run the real compiler and the analyzer.; This is the default behaviour, can be enforced with `--override-compiler`; flag. 2. Use special library to intercept compiler calls during the build process.; The analyzer run against each modules after the build finished.; Use `--intercept-first` flag to get this model. 3. Use compiler wrappers to intercept compiler calls during the build process.; The analyzer run against each modules after the build finished.; Use `--intercept-first` and `--override-compiler` flags together to get; this model. The 1. and 3. are using compiler wrappers, which works only if the build; process respects the `CC` and `CXX` environment variables. (Some build; process can override these variable as command line parameter only. This case; you need to pass the compiler wrappers manually. eg.: `intercept-build; --override-compiler make CC=intercept-cc CXX=intercept-c++ all` where the; original build command would have been `make all` only.). The 1. runs the analyzer right after the real compilation. So, if the build; process removes removes intermediate modules (generated sources) the analyzer; output still kept. The 2. and 3. generate the compilation database first, and filters out those; modules which are not exists. So, it's suitable for incremental analysis during; the development. The 2. mode is available only on FreeBSD and Linux. Where library preload; is available from the dynamic loader. Not supported on OS X (unless System; Integrity Protection feature is turned off). `intercept-build` command uses only the 2. and 3. mode to generate the; compilation database. `a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/README.md:3022,variab,variables,3022,interpreter/llvm-project/clang/tools/scan-build-py/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/README.md,1,['variab'],['variables']
Modifiability,"her<UnresolvedUsingValueDecl>...; Matches unresolved using value declarations. Given; template<typename X>; class C : private X {; using X::x;; };; unresolvedUsingValueDecl(); matches using X::x ; Matcher<Decl>usingDeclMatcher<UsingDecl>...; Matches using declarations. Given; namespace X { int x; }; using X::x;; usingDecl(); matches using X::x ; Matcher<Decl>usingDirectiveDeclMatcher<UsingDirectiveDecl>...; Matches using namespace declarations. Given; namespace X { int x; }; using namespace X;; usingDirectiveDecl(); matches using namespace X ; Matcher<Decl>usingEnumDeclMatcher<UsingEnumDecl>...; Matches using-enum declarations. Given; namespace X { enum x {...}; }; using enum X::x;; usingEnumDecl(); matches using enum X::x ; Matcher<Decl>valueDeclMatcher<ValueDecl>...; Matches any value declaration. Example matches A, B, C and F; enum X { A, B, C };; void F();. Matcher<Decl>varDeclMatcher<VarDecl>...; Matches variable declarations. Note: this does not match declarations of member variables, which are; ""field"" declarations in Clang parlance. Example matches a; int a;. Matcher<LambdaCapture>lambdaCaptureMatcher<LambdaCapture>...; Matches lambda captures. Given; int main() {; int x;; auto f = [x](){};; auto g = [x = 1](){};; }; In the matcher `lambdaExpr(hasAnyCapture(lambdaCapture()))`,; `lambdaCapture()` matches `x` and `x=1`. Matcher<NestedNameSpecifierLoc>nestedNameSpecifierLocMatcher<NestedNameSpecifierLoc>...; Same as nestedNameSpecifier but matches NestedNameSpecifierLoc. Matcher<NestedNameSpecifier>nestedNameSpecifierMatcher<NestedNameSpecifier>...; Matches nested name specifiers. Given; namespace ns {; struct A { static void f(); };; void A::f() {}; void g() { A::f(); }; }; ns::A a;; nestedNameSpecifier(); matches ""ns::"" and both ""A::"". Matcher<OMPClause>ompDefaultClauseMatcher<OMPDefaultClause>...; Matches OpenMP ``default`` clause. Given. #pragma omp parallel default(none); #pragma omp parallel default(shared); #pragma omp parallel default(private); #pragma o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:20002,variab,variables,20002,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['variab'],['variables']
Modifiability,"here are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:4732,plugin,plugin-opt,4732,interpreter/llvm-project/clang/docs/ThinLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst,1,['plugin'],['plugin-opt']
Modifiability,"hes (e.g. x86), this; intrinsic is a nop. On platforms with non-coherent instruction and data; cache (e.g. ARM, MIPS), the intrinsic is lowered either to appropriate; instructions or a system call, if cache flushing requires special; privileges. The default behavior is to emit a call to ``__clear_cache`` from the run; time library. This intrinsic does *not* empty the instruction pipeline. Modifications; of the current function are outside the scope of the intrinsic. '``llvm.instrprof.increment``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.increment(ptr <name>, i64 <hash>,; i32 <num-counters>, i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.increment``' intrinsic can be emitted by a; frontend for use with instrumentation based profiling. These will be; lowered by the ``-instrprof`` pass to generate execution counts of a; program at runtime. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source, and; the third is the number of counters associated with ``name``. It is an; error if ``hash`` or ``num-counters`` differ between two instances of; ``instrprof.increment`` that refer to the same name. The last argument refers to which of the counters for ``name`` should; be incremented. It should be a value between 0 and ``num-counters``. Semantics:; """""""""""""""""""". This intrinsic represents an increment of a profiling counter. It will; cause the ``-instrprof`` pass to generate the appropriate data; structures and the code to increment the appropriate value, in a; format that can be written out by a compiler runtime and consumed via; the ``llvm-profdata`` tool. '``llvm.instrprof.increment.step``' Intrinsic; ^^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:527306,variab,variable,527306,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"hese coordinates are in NDC. This means; that they are independent of the user coordinates system, in particular; if you have already drawn for example a histogram in the mother pad. The; only thing left is to draw the pad:. ``` {.cpp}; root[] spad1->Draw(); ```. If you want more sub-pads, you have to repeat this procedure as many; times as necessary. #### Dividing a Canvas into Sub-Pads. The manual way of dividing a pad into sub-pads is sometimes very; tedious. There is a way to automatically generate horizontal and; vertical sub-pads inside a given pad. ``` {.cpp}; root[] pad1->Divide(3,2); ```. ![Dividing a pad into 6 sub-pads](pictures/030000A5.png). ![Dividing a pad into 6 sub-pads](pictures/020000A6.jpg). If `pad1` is a pad then, it will divide the pad into 3 columns of 2; sub-pads. The generated sub-pads get names `pad1_i` where the index; `i=1` to `nxm` (in our case `pad1_1`, `pad1_2`...`pad1_6)`. The names; `pad1_1 `etc... correspond to new variables in Cling, so you may use them; as soon as the executed method was `pad->Divide()`. However, in a; compiled program, one has to access these objects. Remember that a pad; contains other objects and that these objects may themselves be pads. So; we can use the `GetPrimitive()` method:. ``` {.cpp}; TPad* pad1_1 = (TPad*)(pad1->GetPrimitive(""pad1_1"")); ```. One question remains. In case one does an automatic divide, how one can; set the default margins between pads? This is done by adding two; parameters to `Divide()`, which are the margins in `x` and `y`:. ``` {.cpp}; root[] pad1->Divide(3,2,0.1,0.1); ```. The margins are here set to 10% of the parent pad width. ### Updating the Pad. For performance reasons, a pad is not updated with every change. For; example, changing the coordinates of the pad does not automatically; redraw it. Instead, the pad has a ""bit-modified"" that triggers a redraw.; This bit is automatically set by:. - Touching the pad with the mouse - for example resizing it with the; mouse. - Finishing ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:25484,variab,variables,25484,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['variab'],['variables']
Modifiability,"hesis"" {; rankdir=""LR"";; graph [fontname=""Verdana"", fontsize=""12""];; node [fontname=""Verdana"", fontsize=""12""];; edge [fontname=""Sans"", fontsize=""9""];. start [label="" Create an Object \n 'Last Value' \n of type 'Value' "", shape=""note"", fontcolor=white, fillcolor=""#3333ff"", style=filled];; assign [label="" Assign the result \n to the 'LastValue' \n (based on respective \n Memory Allocation \n scenario) "", shape=""box""]; print [label="" Pretty Print \n the Value Object "", shape=""Msquare"", fillcolor=""yellow"", style=filled];; start -> assign;; assign -> print;. subgraph SynthesizeExpression {; synth [label="" SynthesizeExpr() "", shape=""note"", fontcolor=white, fillcolor=""#3333ff"", style=filled];; mem [label="" New Memory \n Allocation? "", shape=""diamond""];; withaloc [label="" SetValueWithAlloc() "", shape=""box""];; noaloc [label="" SetValueNoAlloc() "", shape=""box""];; right [label="" 1. RValue Structure \n (a temporary value)"", shape=""box""];; left2 [label="" 2. LValue Structure \n (a variable with \n an address)"", shape=""box""];; left3 [label="" 3. Built-In Type \n (int, float, etc.)"", shape=""box""];; output [label="" move to 'Assign' step "", shape=""box""];. synth -> mem;; mem -> withaloc [label=""Yes""];; mem -> noaloc [label=""No""];; withaloc -> right;; noaloc -> left2;; noaloc -> left3;; right -> output;; left2 -> output;; left3 -> output;; }; output -> assign; }. Where is the captured result stored?; ------------------------------------. ``LastValue`` holds the last result of the value printing. It is a class member; because it can be accessed even after subsequent inputs. **Note:** If no value printing happens, then it is in an invalid state. Improving Efficiency and User Experience; ----------------------------------------. The Value object is essentially used to create a mapping between an expression; 'type' and the allocated 'memory'. Built-in types (bool, char, int,; float, double, etc.) are copyable. Their memory allocation size is known; and the Value object can introduce a small-b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:8025,variab,variable,8025,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['variab'],['variable']
Modifiability,"hich is not yet complete.; The FeldmanCousins class is a separate concrete implementation of the; IntervalCalculator interface. �It uses the NeymanConstruction internally,; and�enforces�specific choices of the test statistic and ordering; principle to realize the Unified intervals described by Feldman and; Cousins in their paper�Phys.Rev.D57:3873-3889,1998. In an extension to the technique discussed in Feldman and Cousins paper,; the FeldmanCousins class also performs a ""profile construction"" if their are nuisance parameters.; In this case, the parameters of interest are scanned in a regular grid. For each point in the grid; the calculator finds the best fit value of the nuisance parameters (given the data). The construction; is then only performed in this subspace of the parameters. As a result, the number of points in the; construction only scales in the number of parameters of interest, not in the number of nuisance parameters. Markov Chain Monte Carlo Interval; A flexible framework for Markov Chain Monte Carlo was added in this; release. The MCMCCalculator is a concrete implementation of the; IntervalCalculator interface. To use it one needs to specify the ProposalFunction.; There is a base class for ProposalFunctions and one concrete implementation: UniformProposal.; Support for other proposal functions will be added in the next release.; The MCMCCalculator scans the space of the parameters of interest and nuisance parameters and; produces a Bayesian posterior. In this version, the prior must be added to the model initially,; otherwise a flat prior is assumed. The MCMCCalculator returns an MCMCInterval, which produces; the smallest interval by taking a contour of the posterior. This first version only supports; 1,2, and 3 dimensional intervals, but will be generalized in the next release. In addition to the MCMC implementation in RooStats, one can export their model and dataset into a workspace,; and then use the Bayesian Analysis Toolkit (BAT) for the MCMC. The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:29486,flexible,flexible,29486,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['flexible'],['flexible']
Modifiability,"hich the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When Clang emits a diagnostic, it includes rich information in the; output, and gives you fine-grain control over which information is; printed. Clang has the ab",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:35250,config,configuration,35250,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['configuration']
Modifiability,"hidden in a script so that `git llvmpush` would perform all; these steps, fail only if such a dependent change exists, and show immediately; the change that prevented the push. An immediate repeat of the command would; (almost) certainly result in a successful push.; Note that today with SVN or git-svn, this step is not possible since the; ""rebase"" implicitly happens while committing (unless a conflict occurs). Checkout/Clone Multiple Projects, with Commit Access; ----------------------------------------------------. Let's look how to assemble llvm+clang+libcxx at a given revision. Currently; ^^^^^^^^^. ::. svn co https://llvm.org/svn/llvm-project/llvm/trunk llvm -r $REVISION; cd llvm/tools; svn co https://llvm.org/svn/llvm-project/clang/trunk clang -r $REVISION; cd ../projects; svn co https://llvm.org/svn/llvm-project/libcxx/trunk libcxx -r $REVISION. Or using git-svn::. git clone https://llvm.org/git/llvm.git; cd llvm/; git svn init https://llvm.org/svn/llvm-project/llvm/trunk --username=<username>; git config svn-remote.svn.fetch :refs/remotes/origin/main; git svn rebase -l; git checkout `git svn find-rev -B r258109`; cd tools; git clone https://llvm.org/git/clang.git; cd clang/; git svn init https://llvm.org/svn/llvm-project/clang/trunk --username=<username>; git config svn-remote.svn.fetch :refs/remotes/origin/main; git svn rebase -l; git checkout `git svn find-rev -B r258109`; cd ../../projects/; git clone https://llvm.org/git/libcxx.git; cd libcxx; git svn init https://llvm.org/svn/llvm-project/libcxx/trunk --username=<username>; git config svn-remote.svn.fetch :refs/remotes/origin/main; git svn rebase -l; git checkout `git svn find-rev -B r258109`. Note that the list would be longer with more sub-projects. .. _workflow-monocheckout-multicommit:. Monorepo Variant; ^^^^^^^^^^^^^^^^. The repository contains natively the source for every sub-projects at the right; revision, which makes this straightforward::. git clone https://github.com/llvm/llvm-project.git; cd",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:15800,config,config,15800,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['config'],['config']
Modifiability,"hing delimiter takes; precedence over a matching enclosing function name for determining the; language of the raw string contents. If a canonical delimiter is specified, occurrences of other delimiters for; the same language will be updated to the canonical if possible. There should be at most one specification per language and each delimiter; and enclosing function should not occur in multiple specifications. To configure this in the .clang-format file, use:. .. code-block:: yaml. RawStringFormats:; - Language: TextProto; Delimiters:; - 'pb'; - 'proto'; EnclosingFunctions:; - 'PARSE_TEXT_PROTO'; BasedOnStyle: google; - Language: Cpp; Delimiters:; - 'cc'; - 'cpp'; BasedOnStyle: llvm; CanonicalDelimiter: 'cc'. .. _ReferenceAlignment:. **ReferenceAlignment** (``ReferenceAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <ReferenceAlignment>`; Reference alignment style (overrides ``PointerAlignment`` for; references). Possible values:. * ``RAS_Pointer`` (in configuration: ``Pointer``); Align reference like ``PointerAlignment``. * ``RAS_Left`` (in configuration: ``Left``); Align reference to the left. .. code-block:: c++. int& a;. * ``RAS_Right`` (in configuration: ``Right``); Align reference to the right. .. code-block:: c++. int &a;. * ``RAS_Middle`` (in configuration: ``Middle``); Align reference in the middle. .. code-block:: c++. int & a;. .. _ReflowComments:. **ReflowComments** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <ReflowComments>`; If ``true``, clang-format will attempt to re-flow comments. That is it; will touch a comment and *reflow* long comments into new lines, trying to; obey the ``ColumnLimit``. .. code-block:: c++. false:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information; /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */. true:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of; // information; /* second veryVeryVeryVeryVeryVe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:99948,config,configuration,99948,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to define selections interactively. A selection is a set of ranges combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with logical AND. A selection is; displayed on top of the complete data set using its own color. Only the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been defined. Each cluster is now clearly visible; and the zone with crossing clusters is now understandable whereas,; without any",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:100077,variab,variables,100077,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,3,['variab'],['variables']
Modifiability,"hip, as well as the usual behavior of; copy semantics on the setter.; * ``retain`` implies ``__strong`` ownership.; * ``strong`` implies ``__strong`` ownership.; * ``unsafe_unretained`` implies ``__unsafe_unretained`` ownership.; * ``weak`` implies ``__weak`` ownership. With the exception of ``weak``, these modifiers are available in non-ARC; modes. A property's specified ownership is preserved in its metadata, but otherwise; the meaning is purely conventional unless the property is synthesized. If a; property is synthesized, then the :arc-term:`associated instance variable` is; the instance variable which is named, possibly implicitly, by the; ``@synthesize`` declaration. If the associated instance variable already; exists, then its ownership qualification must equal the ownership of the; property; otherwise, the instance variable is created with that ownership; qualification. A property of retainable object pointer type which is synthesized without a; source of ownership has the ownership of its associated instance variable, if it; already exists; otherwise, :when-revised:`[beginning Apple 3.1, LLVM 3.1]`; :revision:`its ownership is implicitly` ``strong``. Prior to this revision, it; was ill-formed to synthesize such a property. .. admonition:: Rationale. Using ``strong`` by default is safe and consistent with the generic ARC rule; about :ref:`inferring ownership <arc.ownership.inference.variables>`. It is,; unfortunately, inconsistent with the non-ARC rule which states that such; properties are implicitly ``assign``. However, that rule is clearly; untenable in ARC, since it leads to default-unsafe code. The main merit to; banning the properties is to avoid confusion with non-ARC practice, which did; not ultimately strike us as sufficient to justify requiring extra syntax and; (more importantly) forcing novices to understand ownership rules just to; declare a property when the default is so reasonable. Changing the rule away; from non-ARC practice was acceptable b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:35795,variab,variable,35795,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variable']
Modifiability,"his can be done in; Cling by inserting the bash-like style line:. .. code:: bash; ; #!/usr/bin/cling; ; 3. **Rapid Application Development (RAD):**. Cling can be used successfully for Rapid Application Development allowing for; prototyping and proofs of concept taking advantage of dynamicity and feedback; during the implementation process. 4. **Runtime-Generated Code**. Sometime it's convenient to create code as a reaction to input; (user/network/configuration). Runtime-generated code can interface with C++; libraries. 5. **Embedding Cling:**. The functionality of an application can be enriched by embedding Cling. To embed; Cling, the main program has to be provided. One of the things this main program; has to do is initialize the Cling interpreter. There are optional calls to pass; command line arguments to Cling. Afterwards, you can call the interpreter from; any anywhere within the application. For compilation and linkage the application needs the path to the Clang and LLVM; libraries and the invocation is order dependent since the linker cannot do; backward searches. .. code:: bash. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclangEdit -lclangLex -lclangDriver -lclangCodeGen ; -lclangBasic -lclangAST ; `llvm-config ; --libs bitwriter mcjit orcjit native option ; ipo profiledata instrumentation objcarcopts` ; -lz -pthread -ldl -ltinfo ; -o embedcling; . Embedding Cling requires the creation of the interpreter. Optionally compiler; arguments and the resource directory of LLVM can be passed. An example is the; following:. .. code:: bash. #include ""cling/Interpreter/Interpreter.h"". int main(int argc, char** argv) {; const char* LLVMRESDIR = ""/usr/local/""; //path to llvm resource directory; cling::Interpreter interp(argc, argv, LLVMRESDIR);. interp.declare(""int p=0;"");; }; ; A more complete example could be found in `<tools/demo/cling-demo.cpp>`_.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/why_interpreting.rst:1778,config,config,1778,interpreter/cling/docs/chapters/why_interpreting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/why_interpreting.rst,1,['config'],['config']
Modifiability,"his track; Float_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion. // method definitions ...; ClassDef(Track,1) //A track segment; };; ```. ### Writing the Tree. We create a simple tree with two branches both holding `Event` objects.; One is split and the other is not. We also create a pointer to an; `Event` object (`event`). ``` {.cpp}; void tree4w() {; // check to see if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; // create a ROOT Tree; TTree t4(""t4"",""A Tree with Events"");; // create a pointer to an Event object; Event *event = new Event();; // create two branches, split one; t4.Branch(""event_branch"", ""Event"", &event,16000,2);; t4.Branch(""event_not_split"", ""Event"", &event,16000,0);. // a local variable for the event type; char etype[20];. // fill the tree; for (Int_t ev = 0; ev <100; ev++) {; Float_t sigmat, sigmas;; gRandom->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(etype);; event->SetHeader(ev, 200, 960312, random);; event->SetNseg(Int_t(10*ntrack+20*sigmas));; event->SetNvertex(Int_t(1+20*gRandom->Rndm()));; event->SetFlag(UInt_t(random+0.5));; event->SetTemperature(random+20.);; for(UChar_t m = 0; m < 10; m++) {; event->SetMeasure(m, Int_t(gRandom->Gaus(m,m+1)));; }; // continued...; // fill the matrix; for(UChar_t i0 = 0; i0 < 4; i0++) {; for(UChar_t i1 = 0; i1 < 4; i1++) {; event->SetMatrix(i0,i1,gRandom->Gaus(i0*i1,1));; }; }; // create and fill the Track objects; for (Int_t t = 0; t < ntrack; t++) event->AddTrack(random);; t4.Fill(); // Fill the tree; event->Clear(); // Clear before reloading event; }; f.Write(); // Write the file header; t4.Print(); // Print the tree conten",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:62816,variab,variable,62816,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"histograms only the; X-axis is relevant, while for two-dimensional histograms the X-axis; and Y-axis are relevant. See the class **` TAxis`** for a description; of all the access methods. The bin edges are always stored internally; in double precision. You can examine the actual edges / limits of the histogram bins by; accessing the axis parameters, like in the example below:. ``` {.cpp}; const Int_t XBINS = 5; const Int_t YBINS = 5;; Double_t xEdges[XBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; Double_t yEdges[YBINS + 1] = {-1.0, -0.4, -0.2, 0.5, 0.7, 1.0};. TH2* h = new TH2D(""h2"", ""h2"", XBINS, xEdges, YBINS, yEdges);; TAxis* xAxis = h->GetXaxis(); TAxis* yAxis = h->GetYaxis();. cout << ""Third bin on Y-dimension: "" << endl; // corresponds to; // [-0.2, 0.5]; cout << ""\tLower edge: "" << yAxis->GetBinLowEdge(3) << endl;; cout << ""\tCenter: "" << yAxis->GetBinCenter(3) << endl;; cout << ""\tUpper edge: "" << yAxis->GetBinUpEdge(3) << endl;; ```. ## Bin Numbering. All histogram types support fixed or variable bin sizes. 2-D; histograms may have fixed size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw, or; access histograms are identical in both cases. ### Convention. For all histogram types: `nbins` , `xlow` , `xup`. Bin\# 0 contains the underflow. Bin\# 1 contains the first bin with low-edge ( `xlow` INCLUDED). The second to last bin (bin\# `nbins`) contains the upper-edge; (`xup` EXCLUDED). The Last bin (bin\# `nbins+1)` contains the overflow. In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram `h` with `binx`, `biny`, `binz`,; the function returns a global/linear bin number. ``` {.cpp}; Int_t bin = h->GetBin(binx, biny, binz);; ```. This global bin is useful to access the bin information independently; of the dimension. ### Re-binning; \index{histogram!rebin}. At any time, a histogram can be re-binned via the **`TH1`**`::Rebin()`; method. It returns a new histogr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:6147,variab,variable,6147,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['variab'],['variable']
Modifiability,"hives</td></tr>; <tr><td>llvm-devmeeting</td><td>Community/US Developer Meeting</td></tr>; <tr><td>llvm-foundation</td><td>Community/LLVM Foundation</td></tr>; <tr><td>Mlir-commits</td><td>no migration at the moment</td></tr>; <tr><td>Openmp-commits</td><td>no migration at the moment</td></tr>; <tr><td>Openmp-dev</td><td>Runtimes/OpenMP</td></tr>; <tr><td>Parallel_libs-commits</td><td>no migration at the moment</td></tr>; <tr><td>Parallel_libs-dev</td><td>Runtimes/C++</td></tr>; <tr><td>Release-testers</td><td>Project Infrastructure/Release Testers</td></tr>; <tr><td>Test-list</td><td>Obsolete</td></tr>; <tr><td>vmkit-commits</td><td>Obsolete</td></tr>; <tr><td>WiCT</td><td>Community/Women in Compilers and Tools</td></tr>; <tr><td>www-scripts</td><td>Obsolete</td></tr> ; </table>. ## FAQ. ### I don't want to use a web UI. You can do most of the communication with your email client (see section on; Setting up email interactions above). You only need to set up your account once; and then configure which categories you want to subscribe to. ### How do I send a private message?. On the mailing list you have the opportunity to reply only to the sender of; the email, not to the entire list. That is not supported when replying via; email on Discourse. However you can send someone a private message via the; Web UI: Click on the user's name above a post and then on `Message`. Also Discourse does not expose users' email addresses , so your private; replies have to go through their platform (unless you happen to know the; email address of the user.). ### How can my script/tool send automatic messages?**. In case you want to [create a new; post/topic](https://docs.discourse.org/#tag/Posts/paths/~1posts.json/post); automatically from a script or tool, you can use the; [Discourse API](https://docs.discourse.org/). ### Who are the admins for Discourse?. See https://llvm.discourse.group/about. ### What is the reason for the migration?. See; [this email](https://lists.llvm.org/piperm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md:10159,config,configure,10159,interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md,1,['config'],['configure']
Modifiability,"hod :. Configuration options reference for MVA method: HMatrix. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). Configuration options for MVA method :. Configuration options reference for MVA method: Fisher. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). Method No Fisher Fisher, Mahalanobis Discrimination method. Configuration options for MVA method :. Co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:2418,Config,Configuration,2418,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['Config'],['Configuration']
Modifiability,"hod finds the first occurrence of the regular expression in the; `string` and returns its position. ## Conventions. In this paragraph, we will explain some of the conventions used in; ROOT source and examples. ### Coding Conventions. From the first days of ROOT development, it was decided to use a set; of coding conventions. This allows a consistency throughout the source; code. Learning these will help you identify what type of information; you are dealing with and enable you to understand the code better and; quicker. Of course, you can use whatever convention you want but if; you are going to submit some code for inclusion into the ROOT sources,; you will need to use these. These are the coding conventions:. - Classes begin with **`T`**: **`TLine`**, **`TTree`**. - Non-class types end with **`_t`**: `Int_t`. - Data members begin with **`f`**: `fTree`. - Member functions begin with a capital: `Loop()`. - Constants begin with **`k`**: `kInitialSize`, `kRed `. - Global variables begin with **`g`**: ***`gEnv`***. - Static data members begin with **`fg`**: `fgTokenClient `. - Enumeration types begin with **`E`**: `EColorLevel`. - Locals and parameters begin with a lower case: `nbytes`. - Getters and setters begin with **`Get`** and **`Set`**:; `SetLast`(), `GetFirst`(). ### Machine Independent Types. Different machines may have different lengths for the same type. The; most famous example is the `int` type. It may be 16 bits on some old; machines and 32 bits on some newer ones. To ensure the size of your; variables, use these pre defined types in ROOT:. - **`Char_t`** Signed Character 1 byte. - **`UChar_t`** Unsigned Character 1 byte. - **`Short_t`** Signed Short integer 2 bytes. - **`UShort_t`** Unsigned Short integer 2 bytes. - **`Int_t`** Signed integer 4 bytes. - **`UInt_t `**Unsigned integer 4 bytes. - **`Long64_t`** Portable signed long integer 8 bytes. - **`ULong64_t`** Portable unsigned long integer 8 bytes. - **`Float_t`** Float 4 bytes. - **`Double_t`** Float",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:29801,variab,variables,29801,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['variab'],['variables']
Modifiability,"hod is called when displaying the event status in a canvas. To; show the event status window, select the `Options` menu and the; `EventStatus` item. This method returns a string of information about; the object at position (x, y). Every time the cursor moves, the object; under the cursor executes the `GetObjectInfo` method. The string is then; shown in the status bar. There is a default implementation in; **`TObject`**, but it is typically overridden for classes that can; report peculiarities for different cursor positions (for example the bin; contents in a TH1). ### IsFolder. By default an object inheriting from **`TObject`** is not brows-able,; because **`TObject::IsFolder()`** returns `kFALSE`. To make a class; browse-able, the `IsFolder` method needs to be overridden to return; `kTRUE`. In general, this method returns `kTRUE` if the object contains; browse-able objects (like containers or lists of other objects). ### Bit Masks and Unique ID. A **`TObject`** descendent inherits two data members: `fBits` and; `fUniqueID`. `fBits `is 32-bit data member used with a bit mask to get; object information. Bits 0 - 13 are reserved as global bits, bits 14 -; 23 can be used in different class hierarchies. ``` {.cpp}; enum EObjBits {; kCanDelete = BIT(0), // if can be deleted; kMustCleanup = BIT(3), // if destructor must call RecursiveRemove(); kObjInCanvas = BIT(3), // for backward compatibility only; kIsReferenced = BIT(4), // if referenced by TRef or TRefArray; kHasUUID = BIT(5), // if has a TUUID, fUniqueID=UUIDNumber; kCannotPick = BIT(6), // if cannot be picked in a pad; kNoContextMenu = BIT(8), // if does not want a context menu; kInvalidObject = BIT(13) // object ctor succeeded but the object should not be used; };; ```. For example, the bits `kMustCleanup` and `kCanDelete` are used in; **`TObject`**. See ""The kCanDelete Bit"" and ""The kMustCleanup Bit"". They; can be set by any object and should not be reused. Make sure not; to overlap them in any given hierarchy. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:5418,inherit,inherits,5418,documentation/users-guide/AddingaClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md,1,['inherit'],['inherits']
Modifiability,"hod. ``` {.cpp}; h->SetDirectory(newDir);; ```. If the parameter is 0, the histogram is no longer associated with a; directory. ``` {.cpp}; h->SetDirectory(0);; ```. Once a histogram is removed from the directory, it will no longer be; deleted when the directory is closed. It is now your responsibility to; delete this histogram object once you are finished with it. To change; the default that automatically adds the histogram to the current; directory, you can call the static function:. ``` {.cpp}; TH1::AddDirectory(kFALSE);; ```. In this case, you will need to do all the bookkeeping for all the; created histograms. ### Saving Objects to Disk. In addition to histograms and trees, you can save any object in a ROOT; file. For example to save a canvas to the ROOT file you can use either; **`TObject::Write()` or `TDirectory`**`::WriteTObject()`. The example:. ``` {.cpp}; root[] c1->Write(); ```. This is equivalent to:. ``` {.cpp}; root[] f->WriteTObject(c1); ```. For objects that do not inherit from **`TObject`** use:. ``` {.cpp}; root[] f->WriteObject(ptr,""nameofobject""); ```. ***`Another example:`***. ``` {.cpp}; root[] TFile *f = new TFile(""hsimple.root"",""UPDATE""); root[] hpx->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] c1->Write(); root[] f->ls(); TFile** hsimple.root; TFile* hsimple.root; OBJ: TH1F hpx This is the px distribution : 0; KEY: TH1F hpx;2 This is the px distribution; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;2 Profile of pz versus px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; KEY: TCanvas c1;1 c1; ```. ### Saving Collections to Disk. All collection classes inherit from **`TCollection`** and hence inherit; the **`TCollection::Write()` method. When you call; `TCollection`**`::Write()` each object in the container is written; individually into its own key in the file. To write all objects into one; key you can specify the name of the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:33587,inherit,inherit,33587,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['inherit'],['inherit']
Modifiability,"hods. This release contains the following changes:. The ROOT::Math::IParamFunction, ROOT::Math::IParamMultiFunction interfaces (used mainly for fitting) require now a pointer to the parameters (type const double *), when evaluating the function. The derived classes must implement now the const; method DoEvalPar (and not DoEval as before). In addition the method; operator()(const double * x, const double * p) is now const. This change makes the caching of parameter not hidden and the interface is now; thread-safe. ; A similar change in the ROOT::Math::IParamGradFunction, ROOT::Math::IParamMultiGradFunction interfaces, where the parameter values are now required for calculating the partial derivatives with respect to the parameters.; This changes the signature of the pure abstract method, DoParameterDerivative(const double *x, const double * p, , which takes also a pointer (type const double *) to the parameters.; In addition, these classes do not inherit anymore from the function gradient interface (ROOT::Math::IGradFunction and ROOT::Math::IMultiGradFunction). They define only the parameter gradient which is needed for fitting and not the coordinate gradient. A derived class, like ROOT::Math::Polynomial, implementing both functionality (coordinate and parameter gradient) inherits then from both interfaces.; . More detailed description of the current MathCore release can be found at this location. MathMore; This new release contains:. Modify and rename the class ROOT::Math::RootFinder to ROOT::Math::GSLRootFinder to distinguish from the main interface class which has been put in the Mathcore library and it can create the GSLRootFinder using the plug-in manager. Furthermore, the class ROOT::Math::GSLRootFinder is not anymore a template class on the algorithm. They type of root-finder algorithm can now be selected via an enumeration; Fixed a bug in the ROOT::Math::GSLNLSMultiFi class.; Changes also in the class for the new enumeration names (all names start with k, lik",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:9820,inherit,inherit,9820,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['inherit'],['inherit']
Modifiability,"hortEnumsOnASingleLine>`; Allow short enums on a single line. .. code-block:: c++. true:; enum { A, B } myEnum;. false:; enum {; A,; B; } myEnum;. .. _AllowShortFunctionsOnASingleLine:. **AllowShortFunctionsOnASingleLine** (``ShortFunctionStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortFunctionsOnASingleLine>`; Dependent on the value, ``int f() { return 0; }`` can be put on a; single line. Possible values:. * ``SFS_None`` (in configuration: ``None``); Never merge functions into a single line. * ``SFS_InlineOnly`` (in configuration: ``InlineOnly``); Only merge functions defined inside a class. Same as ""inline"",; except it does not implies ""empty"": i.e. top level empty functions; are not merged either. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {; }. * ``SFS_Empty`` (in configuration: ``Empty``); Only merge empty functions. .. code-block:: c++. void f() {}; void f2() {; bar2();; }. * ``SFS_Inline`` (in configuration: ``Inline``); Only merge functions defined inside a class. Implies ""empty"". .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {}. * ``SFS_All`` (in configuration: ``All``); Merge all functions fitting on a single line. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() { bar(); }. .. _AllowShortIfStatementsOnASingleLine:. **AllowShortIfStatementsOnASingleLine** (``ShortIfStyle``) :versionbadge:`clang-format 3.3` :ref:`¶ <AllowShortIfStatementsOnASingleLine>`; Dependent on the value, ``if (a) return;`` can be put on a single line. Possible values:. * ``SIS_Never`` (in configuration: ``Never``); Never put short ifs on the same line. .. code-block:: c++. if (a); return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_WithoutElse`` (in configuration: ``WithoutElse``); Put short ifs on the same line only if there is no else statement. .. code-block:: c++. if (a) return;. if (b); return;; else; return;. if (c); retu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:29435,config,configuration,29435,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"hould be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true:; switch (foo) { vs. switch (foo) {; case 1: { case 1:; bar(); {; break; bar();; } break;; default: { }; plop(); default:; } {; } plop();; }; }. * ``bool AfterClass`` Wrap class definitions. .. code-block:: c++. true:; class foo; {};. false:; class foo {};. * ``BraceWrappingAfterControlStatementStyle AfterControlStatement``; Wrap control statements (``if``/``for``/``while``/``switch``/..). Possible values:. * ``BWACS_Never`` (in configuration: ``Never``); Never wrap braces after a control statement. .. code-block:: c++. if (foo()) {; } else {; }; for (int i = 0; i < 10; ++i) {; }. * ``BWACS_MultiLine`` (in configuration: ``MultiLine``); Only wrap braces after a multi-line control statement. .. code-block:: c++. if (foo && bar &&; baz); {; quux();; }; while (foo || bar) {; }. * ``BWACS_Always`` (in configuration: ``Always``); Always wrap braces after a control statement. .. code-block:: c++. if (foo()); {; } else; {}; for (int i = 0; i < 10; ++i); {}. * ``bool AfterEnum`` Wrap enum definitions. .. code-block:: c++. true:; enum X : int; {; B; };. false:; enum X : int { B };. * ``bool AfterFunction`` Wrap function definitions. .. code-block:: c++. true:; void foo(); {; bar();; bar2();; }. false:; void foo() {; bar();; bar2();; }. * ``bool AfterNamespace`` Wrap namespace definitions. .. code-block:: c++. true:; namespace; {; int foo();; int bar();; }. false:; namespace {; int foo();; int bar();; }. * ``bool AfterObjCDeclaration`` Wrap ObjC definitions (interfaces, implementations...). .. note::. @autoreleasepool and @synchronized blocks are wrapped; according to ``AfterControlStatement`` flag. * ``bool AfterStruct`` Wrap struct definitions. .. code-block:: c++. true:; struct foo; {; int x;; };. false:; struct foo {; int x;; };. * ``bool AfterUnion`` Wrap union definitions. .. code-block:: c++. true:; union ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:39824,config,configuration,39824,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"hout; constraining it to a specific triple. **FileCheck-specific substitutions:**. ``%ProtectFileCheckOutput``; This should precede a ``FileCheck`` call if and only if the call's textual; output affects test results. It's usually easy to tell: just look for; redirection or piping of the ``FileCheck`` call's stdout or stderr. .. _Test-specific substitutions:. **Test-specific substitutions:**. Additional substitutions can be defined as follows:. - Lit configuration files (e.g., ``lit.cfg`` or ``lit.local.cfg``) can define; substitutions for all tests in a test directory. They do so by extending the; substitution list, ``config.substitutions``. Each item in the list is a tuple; consisting of a pattern and its replacement, which lit applies using python's; ``re.sub`` function.; - To define substitutions within a single test file, lit supports the; ``DEFINE:`` and ``REDEFINE:`` directives, described in detail below. So that; they have no effect on other test files, these directives modify a copy of the; substitution list that is produced by lit configuration files. For example, the following directives can be inserted into a test file to define; ``%{cflags}`` and ``%{fcflags}`` substitutions with empty initial values, which; serve as the parameters of another newly defined ``%{check}`` substitution:. .. code-block:: llvm. ; DEFINE: %{cflags} =; ; DEFINE: %{fcflags} =. ; DEFINE: %{check} = \; ; DEFINE: %clang_cc1 -verify -fopenmp -fopenmp-version=51 %{cflags} \; ; DEFINE: -emit-llvm -o - %s | \; ; DEFINE: FileCheck %{fcflags} %s. Alternatively, the above substitutions can be defined in a lit configuration; file to be shared with other test files. Either way, the test file can then; specify directives like the following to redefine the parameter substitutions as; desired before each use of ``%{check}`` in a ``RUN:`` line:. .. code-block:: llvm. ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0 -fopenmp-simd; ; REDEFINE: %{fcflags} = -check-prefix=SIMD; ; RUN: %{che",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:29242,config,configuration,29242,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['config'],['configuration']
Modifiability,"how you can declare and manipulate a stack; variable in the LLVM IR. Stack memory allocated with the alloca; instruction is fully general: you can pass the address of the stack slot; to functions, you can store it in other variables, etc. In our example; above, we could rewrite the example to use the alloca technique to avoid; using a PHI node:. .. code-block:: llvm. @G = weak global i32 0 ; type of @G is i32*; @H = weak global i32 0 ; type of @H is i32*. define i32 @test(i1 %Condition) {; entry:; %X = alloca i32 ; type of %X is i32*.; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; store i32 %X.0, i32* %X ; Update X; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; store i32 %X.1, i32* %X ; Update X; br label %cond_next. cond_next:; %X.2 = load i32, i32* %X ; Read X; ret i32 %X.2; }. With this, we have discovered a way to handle arbitrary mutable; variables without the need to create Phi nodes at all:. #. Each mutable variable becomes a stack allocation.; #. Each read of the variable becomes a load from the stack.; #. Each update of the variable becomes a store to the stack.; #. Taking the address of a variable just uses the stack address; directly. While this solution has solved our immediate problem, it introduced; another one: we have now apparently introduced a lot of stack traffic; for very simple and common operations, a major performance problem.; Fortunately for us, the LLVM optimizer has a highly-tuned optimization; pass named ""mem2reg"" that handles this case, promoting allocas like this; into SSA registers, inserting Phi nodes as appropriate. If you run this; example through the pass, for example, you'll get:. .. code-block:: bash. $ llvm-as < example.ll | opt -passes=mem2reg | llvm-dis; @G = weak global i32 0; @H = weak global i32 0. define i32 @test(i1 %Condition) {; entry:; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; br label %cond_next. cond_false:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:6216,variab,variable,6216,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"how_bug.cgi?id=9663. http://www.inf.u-szeged.hu/gcc-arm/; http://citeseer.ist.psu.edu/debus04linktime.html. //===---------------------------------------------------------------------===//. gcc generates smaller code for this function at -O2 or -Os:. void foo(signed char* p) {; if (*p == 3); bar();; else if (*p == 4); baz();; else if (*p == 5); quux();; }. llvm decides it's a good idea to turn the repeated if...else into a; binary tree, as if it were a switch; the resulting code requires -1; compare-and-branches when *p<=2 or *p==5, the same number if *p==4; or *p>6, and +1 if *p==3. So it should be a speed win; (on balance). However, the revised code is larger, with 4 conditional; branches instead of 3. More seriously, there is a byte->word extend before; each comparison, where there should be only one, and the condition codes; are not remembered when the same two values are compared twice. //===---------------------------------------------------------------------===//. More LSR enhancements possible:. 1. Teach LSR about pre- and post- indexed ops to allow iv increment be merged; in a load / store.; 2. Allow iv reuse even when a type conversion is required. For example, i8; and i32 load / store addressing modes are identical. //===---------------------------------------------------------------------===//. This:. int foo(int a, int b, int c, int d) {; long long acc = (long long)a * (long long)b;; acc += (long long)c * (long long)d;; return (int)(acc >> 32);; }. Should compile to use SMLAL (Signed Multiply Accumulate Long) which multiplies; two signed 32-bit values to produce a 64-bit value, and accumulates this with; a 64-bit value. We currently get this with both v4 and v6:. _foo:; smull r1, r0, r1, r0; smull r3, r2, r3, r2; adds r3, r3, r1; adc r0, r2, r0; bx lr. //===---------------------------------------------------------------------===//. This:; #include <algorithm>; std::pair<unsigned, bool> full_add(unsigned a, unsigned b); { return std::make_pair(a + b, a + b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt:12416,enhance,enhancements,12416,interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,2,['enhance'],['enhancements']
Modifiability,"hr``, ``strchrnul``, ``strcasecmp``, ``strcmp``,; ``strcspn``, ``strncasecmp``, ``strncmp``, ``strndup``,; ``strndupa``, ``strpbrk``, ``strrchr``, ``strsep``, ``strspn``,; ``strstr``, ``strtol``, ``strtoll``, ``strtoul``, ``strtoull``, ``tolower``,; ``toupper``, ``ttyname``, ``ttyname_r``, ``wctomb``, ``wcwidth``. Default sinks:; ``printf``, ``setproctitle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <htt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:73011,config,config,73011,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,2,"['config', 'extend']","['config', 'extend']"
Modifiability,"hree new tutorial macros has been added to illustrate the; various features of the object factory. rf511_wsfactory_basic.C - Basic factory concepts; rf512_wsfactory_oper.C - Using operator p.d.f.s in the factory; rf513_wsfactory_tools.C - Advanced example using interfaced high level tools. A formal transaction model is used to commit composite objects into; the workspace. If an error is detected in the expression, no objects; will be committed to the workspace, thus leaving no 'partial builds'. Compact demo of several new major features. The macro below demonstrates in a couple of lines a number of major new features in RooFit 3.00: Use of. workspace factory to quickly create and store (compiled) models; workspace CINT interface to easily access contents in a typesafe way; new adaptive ND numeric integration technique to normalize arbitrary p.d.f. in fast; and reliable way; new adaptive TFoam sampling technique to efficiently generate toy MC data from strongly; peaked datasets; parallel processing in likelihood construction and use of profile likelihood operator; to represent profile likelihoods as regular RooFit functions. void demo(); {; // Construct compiled 2-D model that requires numeric integration for normalization; RooWorkspace w(""w"",1) ;; w.factory(""CEXPR::model('1/((x-a)*(x-a)+0.001)+1/((y-b)*(y-b)+0.001)',x[-1,1],y[-1,1],a[-5,5],b[-5,5])"") ;. // Generate data from model (using TFoam adaptive sampling algorithm); RooDataSet* d = w::model.generate(RooArgSet(w::x,w::y),1000) ;; w::model.fitTo(*d) ;. // Make 2D plot on (x,y); TH2* hh = w::model.createHistogram(""x,y"",40,40) ;; hh->SetLineColor(kBlue) ;. // Make Projection on x (integrate over y); RooPlot* framex = w::x.frame(Title(""Data and p.d.f. projected on X"")) ;; d->plotOn(framex) ;; w::model.plotOn(framex) ;. // Construct likelihood, profile likelihood in a, and draw the latter; RooAbsReal* nll = w::model.createNLL(*d,NumCPU(2)) ;; RooAbsReal* pll = nll->createProfile(w::a) ;; RooPlot* framea = w::a.fram",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:22173,adapt,adaptive,22173,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['adapt'],['adaptive']
Modifiability,"hrough launder.invariant.group to get value of %ptr. ...; declare void @foo(ptr); declare ptr @getPointer(ptr); declare ptr @llvm.launder.invariant.group.p0(ptr). !0 = !{}. The invariant.group metadata must be dropped when replacing one pointer by; another based on aliasing information. This is because invariant.group is tied; to the SSA value of the pointer operand. .. code-block:: llvm. %v = load i8, ptr %x, !invariant.group !0; ; if %x mustalias %y then we can replace the above instruction with; %v = load i8, ptr %y. Note that this is an experimental feature, which means that its semantics might; change in the future. '``type``' Metadata; ^^^^^^^^^^^^^^^^^^^. See :doc:`TypeMetadata`. '``associated``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^. The ``associated`` metadata may be attached to a global variable definition with; a single argument that references a global object (optionally through an alias). This metadata lowers to the ELF section flag ``SHF_LINK_ORDER`` which prevents; discarding of the global variable in linker GC unless the referenced object is; also discarded. The linker support for this feature is spotty. For best; compatibility, globals carrying this metadata should:. - Be in ``@llvm.compiler.used``.; - If the referenced global variable is in a comdat, be in the same comdat. ``!associated`` can not express many-to-one relationship. A global variable with; the metadata should generally not be referenced by a function: the function may; be inlined into other functions, leading to more references to the metadata.; Ideally we would want to keep metadata alive as long as any inline location is; alive, but this many-to-one relationship is not representable. Moreover, if the; metadata is retained while the function is discarded, the linker will report an; error of a relocation referencing a discarded section. The metadata is often used with an explicit section consisting of valid C; identifiers so that the runtime can find the metadata section with; linker-de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:318210,variab,variable,318210,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"i-c-e's, and a lot of real world code depends on; this unfortunate accident of history (including, e.g., the glibc system; headers). GCC accepts anything its ""fold"" optimizer is capable of reducing to; an integer constant, which means that the definition of what it accepts changes; as its optimizer does. One example is that GCC accepts things like ""``case; X-X:``"" even when ``X`` is a variable, because it can fold this to 0. Another issue are how constants interact with the extensions we support, such; as ``__builtin_constant_p``, ``__builtin_inf``, ``__extension__`` and many; others. C99 obviously does not specify the semantics of any of these; extensions, and the definition of i-c-e does not include them. However, these; extensions are often used in real code, and we have to have a way to reason; about them. Finally, this is not just a problem for semantic analysis. The code generator; and other clients have to be able to fold constants (e.g., to initialize global; variables) and have to handle a superset of what C99 allows. Further, these; clients can benefit from extended information. For example, we know that; ""``foo() || 1``"" always evaluates to ``true``, but we can't replace the; expression with ``true`` because it has side effects. Implementation Approach; ^^^^^^^^^^^^^^^^^^^^^^^. After trying several different approaches, we've finally converged on a design; (Note, at the time of this writing, not all of this has been implemented,; consider this a design goal!). Our basic approach is to define a single; recursive evaluation method (``Expr::Evaluate``), which is implemented; in ``AST/ExprConstant.cpp``. Given an expression with ""scalar"" type (integer,; fp, complex, or pointer) this method returns the following information:. * Whether the expression is an integer constant expression, a general constant; that was folded but has no side effects, a general constant that was folded; but that does have side effects, or an uncomputable/unfoldable value.; * If the e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:120551,variab,variables,120551,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['variab'],['variables']
Modifiability,"i-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cache; scripts to provide more complex options. By default, only a few CMake options will be passed between stages.; The list, called _BOOTSTRAP_DEFAULT_PASSTHROUGH, is defined in clang/CMakeLists.txt.; To force the passing of the variables between stages, use the -DCLANG_BOOTSTRAP_PASSTHROUGH; CMake option, each variable separated by a "";"". As example:. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DCLANG_BOOTSTRAP_PASSTHROUGH=""CMAKE_INSTALL_PREFIX;CMAKE_VERBOSE_MAKEFILE"" \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. CMake options starting by ``BOOTSTRAP_`` will be passed only to the stage2 build.; This gives the opportunity to use Clang specific build flags.; For example, the following CMake call will enabled '-fno-addrsig' only during; the stage2 build for C and C++. .. code-block:: console. $ cmake [..] -DBOOTSTRAP_CMAKE_CXX_FLAGS='-fno-addrsig' -DBOOTSTRAP_CMAKE_C_FLAGS='-fno-addrsig' [..]. The clang build system refers to builds as stages. A stage1 build is a standard; build using the compiler installed on the host, and a stage2 build is built; using the stage1 compiler. This nomenclature holds up to more stages too. In; general a stage*n* build is built using",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:2229,variab,variables,2229,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"iable Class; <https://llvm.org/doxygen/classllvm_1_1GlobalVariable.html>`_. Superclasses: GlobalValue_, Constant_, User_, Value_. Global variables are represented with the (surprise surprise) ``GlobalVariable``; class. Like functions, ``GlobalVariable``\ s are also subclasses of; GlobalValue_, and as such are always referenced by their address (global values; must live in memory, so their ""name"" refers to their constant address). See; GlobalValue_ for more on this. Global variables may have an initial value; (which must be a Constant_), and if they have an initializer, they may be marked; as ""constant"" themselves (indicating that their contents never change at; runtime). .. _m_GlobalVariable:. Important Public Members of the ``GlobalVariable`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``GlobalVariable(const Type *Ty, bool isConstant, LinkageTypes &Linkage,; Constant *Initializer = 0, const std::string &Name = """", Module* Parent = 0)``. Create a new global variable of the specified type. If ``isConstant`` is true; then the global variable will be marked as unchanging for the program. The; Linkage parameter specifies the type of linkage (internal, external, weak,; linkonce, appending) for the variable. If the linkage is InternalLinkage,; WeakAnyLinkage, WeakODRLinkage, LinkOnceAnyLinkage or LinkOnceODRLinkage, then; the resultant global variable will have internal linkage. AppendingLinkage; concatenates together all instances (in different translation units) of the; variable into a single variable but is only applicable to arrays. See the; `LLVM Language Reference <LangRef.html#modulestructure>`_ for further details; on linkage types. Optionally an initializer, a name, and the module to put; the variable into may be specified for the global variable as well. * ``bool isConstant() const``. Returns true if this is a global variable that is known not to be modified at; runtime. * ``bool hasInitializer()``. Returns true if this ``GlobalVariable`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:159526,variab,variable,159526,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['variab'],['variable']
Modifiability,"iable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of course not a serious problem as; long as it recovers and leaves such a region. #### An Underdetermined Problem. If the matrix is not positive-definite even at the minimum, this may; mean that the solution is not well defined, for example that there are; more unknowns than there are data points, or that the parameterization; of the fit contains a linear dependence. If this is the case, then; `Minuit` (or any other program) cannot solve your problem uniquely.; The error matrix will necessarily be largely meaningless, so the user; must remove the under determinedness by reformulating the; parameterization. `Minuit` cannot do this itself. #### Numerical Inaccuracies. It is possible that the apparent lack of positive-definiteness is due; to excessive round off errors in numerical calculations (in the user; function), or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or; if the parameters are badly scaled (not all of the same order of; magnitude), and correlations are large. In any case, whether the; non-positive-definiteness is real or only numerical is largely; irrelevant, since in both cases the error matrix will be unreliable; and the minimum sus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:63201,parameteriz,parameterization,63201,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['parameteriz'],['parameterization']
Modifiability,"iable: no known conversion from '<builtin fn type>' to 'int' for 2nd argument; 5 | void* operator new(__SIZE_TYPE__, int);; | ^. After:. .. code-block:: text. error: builtin functions must be directly called; 13 | new (__builtin_memset) S {};; | ^. - Clang now diagnoses import before module declarations but not in global; module fragment.; (`#67627 <https://github.com/llvm/llvm-project/issues/67627>`_). - Clang now diagnoses include headers with angle in module purviews, which is; not usually intended.; (`#68615 <https://github.com/llvm/llvm-project/issues/68615>`_). - Clang now won't mention invisible namespace when diagnose invisible declarations; inside namespace. The original diagnostic message is confusing.; (`#73893 <https://github.com/llvm/llvm-project/issues/73893>`_). Improvements to Clang's time-trace; ----------------------------------; - Two time-trace scope variables are added. A time trace scope variable of; ``ParseDeclarationOrFunctionDefinition`` with the function's source location; is added to record the time spent parsing the function's declaration or; definition. Another time trace scope variable of ``ParseFunctionDefinition``; is also added to record the name of the defined function. Bug Fixes in This Version; -------------------------; - Fixed an issue where a class template specialization whose declaration is; instantiated in one module and whose definition is instantiated in another; module may end up with members associated with the wrong declaration of the; class, which can result in miscompiles in some cases.; - Fix crash on use of a variadic overloaded operator.; (`#42535 <https://github.com/llvm/llvm-project/issues/42535>`_); - Fix a hang on valid C code passing a function type as an argument to; ``typeof`` to form a function declaration.; (`#64713 <https://github.com/llvm/llvm-project/issues/64713>`_); - Clang now reports missing-field-initializers warning for missing designated; initializers in C++.; (`#56628 <https://github.com/llvm/llv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:32643,variab,variable,32643,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['variab'],['variable']
Modifiability,"iables; ---------------------------. Here are some of the CMake variables that are rarely used, along with a brief; explanation and LLVM-related notes. For full documentation, consult the CMake; manual, or execute ``cmake --help-variable VARIABLE_NAME``. **CMAKE_CXX_STANDARD**:STRING; Sets the C++ standard to conform to when building LLVM. Possible values are; 17 and 20. LLVM Requires C++ 17 or higher. This defaults to 17. **CMAKE_INSTALL_BINDIR**:PATH; The path to install executables, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""bin"". **CMAKE_INSTALL_INCLUDEDIR**:PATH; The path to install header files, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""include"". **CMAKE_INSTALL_DOCDIR**:PATH; The path to install documentation, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""share/doc"". **CMAKE_INSTALL_MANDIR**:PATH; The path to install manpage files, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""share/man"". .. _LLVM-related variables:. LLVM-related variables; -----------------------. These variables provide fine control over the build of LLVM and; enabled sub-projects. Nearly all of these variable names begin with; ``LLVM_``. **BUILD_SHARED_LIBS**:BOOL; Flag indicating if each LLVM component (e.g. Support) is built as a shared; library (ON) or as a static library (OFF). Its default value is OFF. On; Windows, shared libraries may be used when building with MinGW, including; mingw-w64, but not when building with the Microsoft toolchain. .. note:: BUILD_SHARED_LIBS is only recommended for use by LLVM developers.; If you want to build LLVM as a shared library, you should use the; ``LLVM_BUILD_LLVM_DYLIB`` option. **LLVM_ABI_BREAKING_CHECKS**:STRING; Used to decide if LLVM should be built with ABI breaking checks or; not. Allowed values are `WITH_ASSERTS` (default), `FORCE_ON` and; `FORCE_OFF`. `WITH_ASSERTS` turns on ABI breaking checks in an; assertion enabled build. `FORCE_ON` (`FORCE_OFF`) turns them on; (off) irrespective of whether normal ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:11317,variab,variables,11317,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,ialization.cpp; clang-tools-extra/clangd/index/dex/Iterator.cpp; clang-tools-extra/clangd/index/dex/Iterator.h; clang-tools-extra/clangd/index/dex/PostingList.cpp; clang-tools-extra/clangd/index/dex/PostingList.h; clang-tools-extra/clangd/index/dex/Token.h; clang-tools-extra/clangd/index/dex/Trigram.cpp; clang-tools-extra/clangd/index/dex/Trigram.h; clang-tools-extra/clangd/index/dex/dexp/Dexp.cpp; clang-tools-extra/clangd/index/remote/Client.cpp; clang-tools-extra/clangd/index/remote/Client.h; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.cpp; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.h; clang-tools-extra/clangd/index/remote/monitor/Monitor.cpp; clang-tools-extra/clangd/index/remote/server/Server.cpp; clang-tools-extra/clangd/index/remote/unimplemented/UnimplementedClient.cpp; clang-tools-extra/clangd/indexer/IndexerMain.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.h; clang-tools-extra/clangd/refactor/Rename.h; clang-tools-extra/clangd/refactor/Tweak.cpp; clang-tools-extra/clangd/refactor/Tweak.h; clang-tools-extra/clangd/refactor/tweaks/AddUsing.cpp; clang-tools-extra/clangd/refactor/tweaks/AnnotateHighlightings.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineInline.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineOutline.cpp; clang-tools-extra/clangd/refactor/tweaks/DumpAST.cpp; clang-tools-extra/clangd/refactor/tweaks/ExpandMacro.cpp; clang-tools-extra/clangd/refactor/tweaks/ExtractFunction.cpp; clang-tools-extra/clangd/refactor/tweaks/ObjCLocalizeStringLiteral.cpp; clang-tools-extra/clangd/refactor/tweaks/RemoveUsingNamespace.cpp; clang-tools-extra/clangd/refactor/tweaks/SwapIfBranches.cpp; clang-tools-extra/clangd/support/Cancellation.cpp; clang-tools-extra/clangd/support/Cancellation.h; clang-tools-extra/clangd/support/Context.cpp; clang-tools-extra/clangd/support/Context.h; clang-tools-extra/clangd/support/FileCache.cpp; clang-tools-extra/clangd/support/,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:80131,refactor,refactor,80131,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,"ianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). nkNN No 20 − Number of k-nearest neighbors. BalanceDepth No 6 − Binary tree balance depth. ScaleFrac No 0.8 − Fraction of events used to compute variable width. SigmaFact No 1 − Scale factor for sigma in Gaussian kernel. Kernel No Gaus − Use polynomial (=Poln) or Gaussian (=Gaus) kernel. Trim No False − Use equal number of signal and background events. UseKernel No False − Use polynomial kernel weight. UseWeight No True − Use weight to count kNN events. UseLDA No False − Use local linear discriminant - experimental feature. Configuration options for MVA method :. Configuration options reference for MVA method: BDT. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). NTrees No 800 − Number of trees in the forest. MaxDepth N",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:10907,Config,Configuration,10907,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['Config'],['Configuration']
Modifiability,"iases`_, and `lists`_ of options. .. _aliases:. Argument Aliases; ----------------. So far, the example works well, except for the fact that we need to check the; quiet condition like this now:. .. code-block:: c++. ...; if (!Quiet && !Quiet2) printInformationalMessage(...);; ... ... which is a real pain! Instead of defining two values for the same; condition, we can use the ""`cl::alias`_"" class to make the ""``-q``"" option an; **alias** for the ""``-quiet``"" option, instead of providing a value itself:. .. code-block:: c++. cl::opt<bool> Force (""f"", cl::desc(""Overwrite output files""));; cl::opt<bool> Quiet (""quiet"", cl::desc(""Don't print informational messages""));; cl::alias QuietA(""q"", cl::desc(""Alias for -quiet""), cl::aliasopt(Quiet));. The third line (which is the only one we modified from above) defines a ""``-q``""; alias that updates the ""``Quiet``"" variable (as specified by the `cl::aliasopt`_; modifier) whenever it is specified. Because aliases do not hold state, the only; thing the program has to query is the ``Quiet`` variable now. Another nice; feature of aliases is that they automatically hide themselves from the ``-help``; output (although, again, they are still visible in the ``-help-hidden output``). Now the application code can simply use:. .. code-block:: c++. ...; if (!Quiet) printInformationalMessage(...);; ... ... which is much nicer! The ""`cl::alias`_"" can be used to specify an; alternative name for any variable type, and has many uses. .. _unnamed alternatives using the generic parser:. Selecting an alternative from a set of possibilities; ----------------------------------------------------. So far we have seen how the CommandLine library handles builtin types like; ``std::string``, ``bool`` and ``int``, but how does it handle things it doesn't; know about, like enums or '``int*``'s?. The answer is that it uses a table-driven generic parser (unless you specify; your own parser, as described in the `Extension Guide`_). This parser maps; literal str",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:12753,variab,variable,12753,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variable']
Modifiability,"iation tool [Clad] have been shown to be far more efficient [^2]. \htmlonly; <div class=""pyrootbox"">; \endhtmlonly. Main Advantage of using AD with RooFit: efficient and more precise; derivatives. It computes derivatives with high precision, avoiding the errors; that may arise from approximating derivatives using finite differences. \htmlonly; </div>; \endhtmlonly. ### AD Support essentially requires Code Generation. As we'll discuss in upcoming sections, *AD support* can be added using *C++; Code generation*.; These two terms may be used interchangeably in this document, since the term; *Code Generation* better helps visualize the transformation that is enabling; AD support. ## Current Status of Code Generation in RooFit. RooFit is an extensive toolkit.; The initiative to add AD support/ Code Generation has been started, but has; not yet achieved full coverage for the models defined/maintained in RooFit. ## How Clad enables AD support using Source Code Transformation. [Clad] is a C++ plugin for Clang. It implements a technique called Source Code; Transformation to enable AD support. Source Code Transformation takes the source code (that needs to be; differentiated) as the input and generates an output code that represents the; derivative of the input. This output code can be used instead of the input; code for more efficient compilation. For more technical details, please see the following paper:. > [Automatic Differentiation of Binned Likelihoods with RooFit and Clad](https://arxiv.org/abs/2304.02650). ## Overview on RooFit implementation details to access source code transformation AD. In RooFit jargon, what is meant by a ""RooFit class"" is a class inheriting from; RooAbsArg that represents a mathematical function, a PDF, or any other; transformation of inputs that are also represented by RooAbsArg objects.; Almost all final classes deriving from RooAbsArg have RooAbsReal as an; intermediate base class, which is the base class for all RooAbsArg that; represent rea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:2304,plugin,plugin,2304,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['plugin'],['plugin']
Modifiability,"ibraries out; there in many different languages, none of them fit well with what I needed. By; looking at the features and problems of other libraries, I designed the; CommandLine library to have the following features:. #. Speed: The CommandLine library is very quick and uses little resources. The; parsing time of the library is directly proportional to the number of; arguments parsed, not the number of options recognized. Additionally,; command line argument values are captured transparently into user defined; global variables, which can be accessed like any other variable (and with the; same performance). #. Type Safe: As a user of CommandLine, you don't have to worry about; remembering the type of arguments that you want (is it an int? a string? a; bool? an enum?) and keep casting it around. Not only does this help prevent; error prone constructs, it also leads to dramatically cleaner source code. #. No subclasses required: To use CommandLine, you instantiate variables that; correspond to the arguments that you would like to capture, you don't; subclass a parser. This means that you don't have to write **any**; boilerplate code. #. Globally accessible: Libraries can specify command line arguments that are; automatically enabled in any tool that links to the library. This is; possible because the application doesn't have to keep a list of arguments to; pass to the parser. This also makes supporting `dynamically loaded options`_; trivial. #. Cleaner: CommandLine supports enum and other types directly, meaning that; there is less error and more security built into the library. You don't have; to worry about whether your integral command line argument accidentally got; assigned a value that is not valid for your enum type. #. Powerful: The CommandLine library supports many different types of arguments,; from simple `boolean flags`_ to `scalars arguments`_ (`strings`_,; `integers`_, `enums`_, `doubles`_), to `lists of arguments`_. This is; possible because CommandLin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:1562,variab,variables,1562,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variables']
Modifiability,"ibrary (ON) or as a static library (OFF). Its default value is OFF. On; Windows, shared libraries may be used when building with MinGW, including; mingw-w64, but not when building with the Microsoft toolchain. .. note:: BUILD_SHARED_LIBS is only recommended for use by LLVM developers.; If you want to build LLVM as a shared library, you should use the; ``LLVM_BUILD_LLVM_DYLIB`` option. **LLVM_ABI_BREAKING_CHECKS**:STRING; Used to decide if LLVM should be built with ABI breaking checks or; not. Allowed values are `WITH_ASSERTS` (default), `FORCE_ON` and; `FORCE_OFF`. `WITH_ASSERTS` turns on ABI breaking checks in an; assertion enabled build. `FORCE_ON` (`FORCE_OFF`) turns them on; (off) irrespective of whether normal (`NDEBUG`-based) assertions are; enabled or not. A version of LLVM built with ABI breaking checks; is not ABI compatible with a version built without it. **LLVM_ADDITIONAL_BUILD_TYPES**:LIST; Adding a semicolon separated list of additional build types to this flag; allows for them to be specified as values in CMAKE_BUILD_TYPE without; encountering a fatal error during the configuration process. **LLVM_UNREACHABLE_OPTIMIZE**:BOOL; This flag controls the behavior of `llvm_unreachable()` in release build; (when assertions are disabled in general). When ON (default) then; `llvm_unreachable()` is considered ""undefined behavior"" and optimized as; such. When OFF it is instead replaced with a guaranteed ""trap"". **LLVM_APPEND_VC_REV**:BOOL; Embed version control revision info (Git revision id).; The version info is provided by the ``LLVM_REVISION`` macro in; ``llvm/include/llvm/Support/VCSRevision.h``. Developers using git who don't; need revision info can disable this option to avoid re-linking most binaries; after a branch switch. Defaults to ON. **LLVM_FORCE_VC_REVISION**:STRING; Force a specific Git revision id rather than calling to git to determine it.; This is useful in environments where git is not available or non-functional; but the VC revision is availa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:12703,config,configuration,12703,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['config'],['configuration']
Modifiability,"ibrary (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:17494,config,config,17494,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['config'],['config']
Modifiability,"ibute by adding an ``Attr`` to the; ``Decl``. It returns either ``AttributeApplied``, to indicate that the; attribute was successfully applied, or ``AttributeNotApplied`` if it wasn't. The members of ``ParsedAttrInfo`` that may need to be defined, depending on the; attribute, are:. * ``NumArgs`` and ``OptArgs``, which set the number of required and optional; arguments to the attribute.; * ``diagAppertainsToDecl``, which checks if the attribute has been used on the; right kind of declaration and issues a diagnostic if not.; * ``diagLangOpts``, which checks if the attribute is permitted for the current; language mode and issues a diagnostic if not.; * ``existsInTarget``, which checks if the attribute is permitted for the given; target. To see a working example of an attribute plugin, see `the Attribute.cpp example; <https://github.com/llvm/llvm-project/blob/main/clang/examples/Attribute/Attribute.cpp>`_. Putting it all together; =======================. Let's look at an example plugin that prints top-level function names. This; example is checked into the clang repository; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:4131,plugin,plugin,4131,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,1,['plugin'],['plugin']
Modifiability,"ibute is absent, then the amdgpu-no-implicitarg-ptr is also removed. ""amdgpu-no-default-queue"" Similar to amdgpu-no-implicitarg-ptr, except specific to the implicit; kernel argument that holds the default queue pointer. If this; attribute is absent, then the amdgpu-no-implicitarg-ptr is also removed. ""amdgpu-no-completion-action"" Similar to amdgpu-no-implicitarg-ptr, except specific to the implicit; kernel argument that holds the completion action pointer. If this; attribute is absent, then the amdgpu-no-implicitarg-ptr is also removed. ""amdgpu-lds-size""=""min[,max]"" Min is the minimum number of bytes that will be allocated in the Local; Data Store at address zero. Variables are allocated within this frame; using absolute symbol metadata, primarily by the AMDGPULowerModuleLDS; pass. Optional max is the maximum number of bytes that will be allocated.; Note that min==max indicates that no further variables can be added to; the frame. This is an internal detail of how LDS variables are lowered,; language front ends should not set this attribute. ======================================= ==========================================================. Calling Conventions; -------------------. The AMDGPU backend supports the following calling conventions:. .. table:: AMDGPU Calling Conventions; :name: amdgpu-cc. =============================== ==========================================================; Calling Convention Description; =============================== ==========================================================; ``ccc`` The C calling convention. Used by default.; See :ref:`amdgpu-amdhsa-function-call-convention-non-kernel-functions`; for more details. ``fastcc`` The fast calling convention. Mostly the same as the ``ccc``. ``coldcc`` The cold calling convention. Mostly the same as the ``ccc``. ``amdgpu_cs`` Used for Mesa/AMDPAL compute shaders.; ..TODO::; Describe. ``amdgpu_cs_chain`` Similar to ``amdgpu_cs``, with differences described below. Functions with this calli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:51785,variab,variables,51785,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['variab'],['variables']
Modifiability,"ibution; -----------------. The LoopDistribution pass tries to separate vectorizable parts of a loop; from the non-vectorizable part (which otherwise would make the entire; loop non-vectorizable). Conceptually, it transforms a loop such as. .. code-block:: c. for (int i = 1; i < n; i+=1) { // original loop; A[i] = i;; B[i] = 2 + B[i];; C[i] = 3 + C[i - 1];; }. into the following code:. .. code-block:: c. if (rtc) {; for (int i = 1; i < n; i+=1) // coincident loop; A[i] = i;; for (int i = 1; i < n; i+=1) // coincident loop; B[i] = 2 + B[i];; for (int i = 1; i < n; i+=1) // sequential loop; C[i] = 3 + C[i - 1];; } else {; for (int i = 1; i < n; i+=1) { // fallback loop; A[i] = i;; B[i] = 2 + B[i];; C[i] = 3 + C[i - 1];; }; }. where ``rtc`` is a generated runtime check. ``llvm.loop.distribute.followup_coincident`` sets the loop attributes of; all loops without loop-carried dependencies (i.e. vectorizable loops).; There might be more than one such loops. If not defined, the loops will; inherit the original loop's attributes. ``llvm.loop.distribute.followup_sequential`` sets the loop attributes of the; loop with potentially unsafe dependencies. There should be at most one; such loop. If not defined, the loop will inherit the original loop's; attributes. ``llvm.loop.distribute.followup_fallback`` defines the loop attributes; for the fallback loop, which is a copy of the original loop for when; loop versioning is required. If undefined, the fallback loop inherits; all attributes from the original loop. Attributes defined in ``llvm.loop.distribute.followup_all`` are added to; all of the aforementioned output loops. It is recommended to add ``llvm.loop.disable_nonforced`` to; ``llvm.loop.distribute.followup_fallback``. This avoids that the; fallback version (which is likely never executed) is further optimized; which would increase the code size. Versioning LICM; ---------------. The pass hoists code out of loops that are only loop-invariant when; dynamic conditions apply. F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:11872,inherit,inherit,11872,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['inherit'],['inherit']
Modifiability,"ic Libraries; =========================. All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have multiple; copies of your libraries and (possibly) headers. Some Linux distributions have support for Multilib, which handle that; for you in an easier way, but if you're not careful and, for instance,; forget to specify ``-ccc-gcc-name armv7l-linux-gnueabihf-gcc`` (which; uses hard-float), Clang will pick the ``armv7l-linux-gnueabi-ld``; (which uses soft-float) and linker errors will happen. The same is true if you're compiling for different environments, like; ``gnueabi`` and ``androideabi``, and might even link and run, but produce; run-time errors, which ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:8537,config,configuration,8537,interpreter/llvm-project/clang/docs/CrossCompilation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst,1,['config'],['configuration']
Modifiability,"ic TMyClass {; public:; void Print() const;; };; void TChild::Print() const // child print metod; {; cout << ""This is TChild::Print()"" << endl;; TMyClass::Print();; }; ```. To execute `script4.C` do:. ``` {.cpp}; root[] .L script4.C; root[] TMyClass *a = new TChild; root[] a->Print(); This is TChild::Print(); fX = -1, fY = -1; root[] a->SetX(10); root[] a->SetY(12); root[] a->Print(); This is TChild::Print(); fX = 10, fY = 12; root[] .class TMyClass; =====================================================; class TMyClass; size=0x8 FILE:script4.C LINE:3; List of base class-----------------------------------; List of member variable------------------------------; Defined in TMyClass; 0x0 private: float fX; 0x4 private: float fY; List of member function------------------------------; Defined in TMyClass; filename line:size busy function type and name; script4.C 16:5 0 public: class TMyClass TMyClass(void);; script4.C 22:4 0 public: void Print(void);; script4.C 12:1 0 public: void SetX(float x);; script4.C 13:1 0 public: void SetY(float y);; root[] .q; ```. As you can see, an interpreted class behaves just like a compiled; class.; See ""Adding a Class"" for ways how to add a class with a shared library; and with ACLiC. ## Inspecting Objects. An object of a class inheriting from `TObject` can be inspected,; with the `Inspect()` method. The `TObject::Inspect` method creates a; window listing the current values of the objects members. For example,; the next picture is of `TFile`. ``` {.cpp}; root[] TFile f(""staff.root""); root[] f.Inspect(); ```. You can see the pointers are in red and can be clicked on to follow; the pointer to the object. If you clicked on `fList`, the list of; objects in memory and there were none, no new canvas would be shown.; On top of the page are the navigation buttons to see the previous and; next screen. ![ROOT object inspector of TFile](pictures/03000092.png). ![The object inspector of `fKeys`, the list of keys in the memory](pictures/03000093.png); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:26229,inherit,inheriting,26229,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['inherit'],['inheriting']
Modifiability,"ic"" model is used. The models correspond to the ELF TLS models; see `ELF Handling For; Thread-Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for; more information on under which circumstances the different models may; be used. The target may choose a different TLS model if the specified; model is not supported, or if a better choice of model can be made. A model can also be specified in an alias, but then it only governs how; the alias is accessed. It will not have any effect in the aliasee. For platforms without linker support of ELF TLS model, the -femulated-tls; flag can be used to generate GCC compatible emulated TLS code. .. _runtime_preemption_model:. Runtime Preemption Specifiers; -----------------------------. Global variables, functions and aliases may have an optional runtime preemption; specifier. If a preemption specifier isn't given explicitly, then a; symbol is assumed to be ``dso_preemptable``. ``dso_preemptable``; Indicates that the function or variable may be replaced by a symbol from; outside the linkage unit at runtime. ``dso_local``; The compiler may assume that a function or variable marked as ``dso_local``; will resolve to a symbol within the same linkage unit. Direct access will; be generated even if the definition is not within this compilation unit. .. _namedtypes:. Structure Types; ---------------. LLVM IR allows you to specify both ""identified"" and ""literal"" :ref:`structure; types <t_struct>`. Literal types are uniqued structurally, but identified types; are never uniqued. An :ref:`opaque structural type <t_opaque>` can also be used; to forward declare a type that is not yet available. An example of an identified structure specification is:. .. code-block:: llvm. %mytype = type { %mytype*, i32 }. Prior to the LLVM 3.0 release, identified types were structurally uniqued. Only; literal types are uniqued in recent versions of LLVM. .. _nointptrtype:. Non-Integral Pointer Type; -------------------------. Note: non-integral pointer ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:27155,variab,variable,27155,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"ic, and defines a DW_AT_address_class attribute. With the removal of; DW_AT_segment in DWARF 6, it is unclear how the address class is intended to; be used as the term is not used elsewhere. Should these be replaced by this; proposal's more complete address space? Or are they intended to represent; source language memory spaces such as in OpenCL?. .. _amdgpu-dwarf-memory-spaces:. A.2.14 Memory Spaces; ~~~~~~~~~~~~~~~~~~~~. .. note::. This is a new section after DWARF Version 5 section 2.12 Segmented Addresses. DWARF memory spaces are used for source languages that have the concept of; memory spaces. They are used in the ``DW_AT_LLVM_memory_space`` attribute for; pointer type, reference type, variable, formal parameter, and constant debugger; information entries. Each DWARF memory space is conceptually a separate source language memory space; with its own lifetime and aliasing rules. DWARF memory spaces are used to; specify the source language memory spaces that pointer type and reference type; values refer, and to specify the source language memory space in which variables; are allocated. Although DWARF memory space identifiers are source language specific,; ``DW_MSPACE_LLVM_none`` is a common memory space supported by all source; languages, and defined as the source language default memory space. The set of currently defined DWARF memory spaces, together with source language; mappings, is given in :ref:`amdgpu-dwarf-source-language-memory-spaces-table`. Vendor defined source language memory spaces may be defined using codes in the; range ``DW_MSPACE_LLVM_lo_user`` to ``DW_MSPACE_LLVM_hi_user``. .. table:: Source language memory spaces; :name: amdgpu-dwarf-source-language-memory-spaces-table. =========================== ============ ============== ============== ==============; Memory Space Name Meaning C/C++ OpenCL CUDA/HIP; =========================== ============ ============== ============== ==============; ``DW_MSPACE_LLVM_none`` generic *default* generic *defa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:150940,variab,variables,150940,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variables']
Modifiability,"ical bugs; present before that version were hindering the normal execution of the tool. Consequently, the minimum Python version; needed to include distributed RDataFrame in the ROOT build is Python 3.8. More information in the relative; [github issue](https://github.com/root-project/root/issues/11515).; - `Stats` and `StdDev` operations are now available in distributed mode.; - `GetColumnNames` operation is now available in distributed mode. ## Histogram Libraries. - New class `TGraph2DAsymmErrors` to create TGraph2D with asymmetric errors.; ![TGraph2DAsymmErrors](TGraph2DAsymmErrors.png). ## Math Libraries. ### Fitter class. Some improvements and small fixes to the internal object memory management have been applied to the `ROOT::Fit::Fitter` class.; - When setting an external FCN (objective function) to the Fitter, the function object is not cloned anymore.; - A memory leak has been fixed, when using the `GSLMultiFit` class.; - A bug has been resolved in setting fixed variables when using the linear fitter (via the `TLinearMinimizer` class). Support for providing the second derivatives (Hessian matrix) from the model function is added to the `Fitter` class and the corresponding function interfaces. The functionality it is then propagated in the implementation of the `FitMethod` classes and it is also added to the `Minimizer` classes for providing a user computed Hessian of the objective functions to the minimizers. Only Minuit2 (see below) has the capabilities of using this external Hessian. The `GradFunctor` class has been improved by providing a new constructor taking an `std::function` implementing the full gradient calculations instead of the single partial derivative. The specialized methods for least-square/likelihood functions such as Fumili, Fumili2 and GSLMultiFit have been improved in case of binned likelihood fits, where a better approximation is used than before. This makes these method work better (conerging with less number of function calls) for the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:15235,variab,variables,15235,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['variab'],['variables']
Modifiability,"ically numbered. #. This is a second list element. #. Use indentation to create nested lists. ...as well as unordered lists:. * Stuff. + Deeper stuff. * More stuff. Code Blocks; ===========. You can make blocks of code like this:. .. code-block:: c++. int main() {; return 0;; }. For a shell session, use a ``console`` code block (some existing docs use; ``bash``):. .. code-block:: console. $ echo ""Goodbye cruel world!""; $ rm -rf /. If you need to show LLVM IR use the ``llvm`` code block. .. code-block:: llvm. define i32 @test1() {; entry:; ret i32 0; }. Some other common code blocks you might need are ``c``, ``objc``, ``make``,; and ``cmake``. If you need something beyond that, you can look at the `full; list`_ of supported code blocks. .. _`full list`: http://pygments.org/docs/lexers/. However, don't waste time fiddling with syntax highlighting when you could; be adding meaningful content. When in doubt, show preformatted text; without any syntax highlighting like this:. ::. .; +:.; ..:: ::; .++:+:: ::+:.:.; .:+ :; ::.::..:: .+.; ..:+ :: :; ......+:. ..; :++. .. :; .+:::+:: :; .. . .+ ::; +.: .::+.; ...+. .: .; .++:..; ... Generating the documentation; ============================. You can generate the HTML documentation from the sources locally if you want to; see what they would look like. In addition to the normal; `build tools <GettingStarted.html>`_; you need to install `Sphinx`_ and the necessary extensions; using the following command inside the ``llvm-project`` checkout:. .. code-block:: console. pip install --user -r ./llvm/docs/requirements.txt. Then run cmake to build the documentation inside the ``llvm-project`` checkout:. .. code-block:: console. mkdir build; cd build; cmake -DLLVM_ENABLE_SPHINX=On ../llvm; cmake --build . --target docs-llvm-html. In case you already have the Cmake build set up and want to reuse that,; just set the CMake variable ``LLVM_ENABLE_SPHINX=On``. After that you find the generated documentation in ``build/docs/html``; folder.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SphinxQuickstartTemplate.rst:6144,variab,variable,6144,interpreter/llvm-project/llvm/docs/SphinxQuickstartTemplate.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SphinxQuickstartTemplate.rst,1,['variab'],['variable']
Modifiability,"icantly change the ordering of the program, and occurs in a number of; different passes. Some variable locations are not transformed during CodeGen. Stack locations; specified by ``llvm.dbg.declare`` are valid and unchanging for the entire; duration of the function, and are recorded in a simple MachineFunction table.; Location changes in the prologue and epilogue of a function are also ignored:; frame setup and destruction may take several instructions, require a; disproportionate amount of debugging information in the output binary to; describe, and should be stepped over by debuggers anyway. Variable locations in Instruction Selection and MIR; ---------------------------------------------------. Instruction selection creates a MIR function from an IR function, and just as; it transforms ``intermediate`` instructions into machine instructions, so must; ``intermediate`` variable locations become machine variable locations.; Within IR, variable locations are always identified by a Value, but in MIR; there can be different types of variable locations. In addition, some IR; locations become unavailable, for example if the operation of multiple IR; instructions are combined into one machine instruction (such as; multiply-and-accumulate) then intermediate Values are lost. To track variable; locations through instruction selection, they are first separated into; locations that do not depend on code generation (constants, stack locations,; allocated virtual registers) and those that do. For those that do, debug; metadata is attached to SDNodes in SelectionDAGs. After instruction selection; has occurred and a MIR function is created, if the SDNode associated with debug; metadata is allocated a virtual register, that virtual register is used as the; variable location. If the SDNode is folded into a machine instruction or; otherwise transformed into a non-register, the variable location becomes; unavailable. Locations that are unavailable are treated as if they have been optim",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:25834,variab,variable,25834,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,2,['variab'],['variable']
Modifiability,"ich are not saved in the TQueryResult object. These are meant for big; objects whic can create a big overload when distributed via the; standard input list (which should mostly be used for job control; parameters).  To add an input-data object just use; TProof::AddInputData(TObject *); if the input-data objects are in a; file you can use TProof::SetInputDataFile(const char *file); the final; set of input-data objects is assembled from the objects added via; AddInputData and those found in the file defined bySetInputDataFile.  . Improvements:. More; complete set of tests in test/stressProof . To run with PROOF-Lite pass; the argument 'lite' as master URL, e.g. './stressProof lite'.Possibility; to control on the client via rc variable the location of the sandbox,; package directory, cache and dataset directory (the latters two only; for PROOF-Lite); the variable names are 'Proof.Sandbox', ; 'Proof.PackageDir', 'Proof.CacheDir' and 'Proof.DataSetDir'. The default location of the sandbox has been changed from ""~/proof"" to ""~/.proof"" to avoid interferences with possible users' working areas.XrdProofd plug-in. Overall refactorization for easier; maintainance and improved solidity; Improved format of printout messages: all information; messages contain now the tag 'xpd-I' and all error messages the; tag 'xpd-E', so that they can easily be grepped out from the; log file.; . Log sending. Implement selective sending of logs from workers to master to avoid duplicating; too many text lines on the master log. Logs are now sent only after Exec, Print; requests and in case an error (level >= kError) occured. Of course, the full; logs can always be retrieved via TProofMgr::GetSessionLogs; . Log retrieval:. for 'grep' operations, use the system 'grep' command; via 'popen'; instead of a handmade filtering; this implies that the full grep; functionality is now available; set the default number of displayed lines to 100; instead of 10. Improve diagnostic in case of worker death: client",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html:4350,sandbox,sandbox,4350,proof/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html,2,['sandbox'],['sandbox']
Modifiability,"ich; itself indents the code - unless IndentCaseBlocks is enabled). .. code-block:: c++. false: true:; switch (fool) { vs. switch (fool) {; case 1: case 1:; bar(); bar();; break; break;; default: default:; plop(); plop();; } }. .. _IndentExternBlock:. **IndentExternBlock** (``IndentExternBlockStyle``) :versionbadge:`clang-format 11` :ref:`¶ <IndentExternBlock>`; IndentExternBlockStyle is the type of indenting of extern blocks. Possible values:. * ``IEBS_AfterExternBlock`` (in configuration: ``AfterExternBlock``); Backwards compatible with AfterExternBlock's indenting. .. code-block:: c++. IndentExternBlock: AfterExternBlock; BraceWrapping.AfterExternBlock: true; extern ""C""; {; void foo();; }. .. code-block:: c++. IndentExternBlock: AfterExternBlock; BraceWrapping.AfterExternBlock: false; extern ""C"" {; void foo();; }. * ``IEBS_NoIndent`` (in configuration: ``NoIndent``); Does not indent extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. * ``IEBS_Indent`` (in configuration: ``Indent``); Indents extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. .. _IndentGotoLabels:. **IndentGotoLabels** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <IndentGotoLabels>`; Indent goto labels. When ``false``, goto labels are flushed left. .. code-block:: c++. true: false:; int f() { vs. int f() {; if (foo()) { if (foo()) {; label1: label1:; bar(); bar();; } }; label2: label2:; return 1; return 1;; } }. .. _IndentPPDirectives:. **IndentPPDirectives** (``PPDirectiveIndentStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IndentPPDirectives>`; The preprocessor directive indenting style to use. Possible values:. * ``PPDIS_None`` (in configuration: ``None``); Does not indent any directives. .. code-block:: c++. #if FOO; #if BAR; #include <foo>; #endif; #endif. * ``PPDIS_AfterHash`` (in configuration: ``AfterHash``); Indents directives after the hash. .. code-block:: c++. #if FOO; # if BAR; # include <foo>; # endif; #endif. * ``PPDIS_BeforeHash`` (in configura",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:72499,config,configuration,72499,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"icit; location descriptions created by the ``DW_OP_implicit_pointer`` and; ``DW_OP_LLVM_aspace_implicit_pointer`` operations. 4. ``DW_OP_form_tls_address``. ``DW_OP_form_tls_address`` pops one stack entry that must be an integral; type value and treats it as a thread-local storage address TA. It pushes a location description L with one memory location description SL; on the stack. SL is the target architecture specific memory location; description that corresponds to the thread-local storage address TA. The meaning of the thread-local storage address TA is defined by the; run-time environment. If the run-time environment supports multiple; thread-local storage blocks for a single thread, then the block; corresponding to the executable or shared library containing this DWARF; expression is used. *Some implementations of C, C++, Fortran, and other languages, support a; thread-local storage class. Variables with this storage class have distinct; values and addresses in distinct threads, much as automatic variables have; distinct values and addresses in each subprogram invocation. Typically,; there is a single block of storage containing all thread-local variables; declared in the main executable, and a separate block for the variables; declared in each shared library. Each thread-local variable can then be; accessed in its block using an identifier. This identifier is typically a; byte offset into the block and pushed onto the DWARF stack by one of the*; ``DW_OP_const*`` *operations prior to the* ``DW_OP_form_tls_address``; *operation. Computing the address of the appropriate block can be complex; (in some cases, the compiler emits a function call to do it), and difficult; to describe using ordinary DWARF location descriptions. Instead of forcing; complex thread-local storage calculations into the DWARF expressions, the*; ``DW_OP_form_tls_address`` *allows the consumer to perform the computation; based on the target architecture specific run-time environment.*. 5. ``DW",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:112953,variab,variables,112953,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variables']
Modifiability,"ics with the desired semantics. If you have opted in to custom; lowering of a particular intrinsic your pass **must** eliminate all; instances of the corresponding intrinsic in functions which opt in to; your GC. The best example of such a pass is the ShadowStackGC and it's; ShadowStackGCLowering pass. There is currently no way to register such a custom lowering pass; without building a custom copy of LLVM. .. _safe-points:. Generating safe points; -----------------------. LLVM provides support for associating stackmaps with the return address of; a call. Any loop or return safepoints required by a given collector design; can be modeled via calls to runtime routines, or potentially patchable call; sequences. Using gcroot, all call instructions are inferred to be possible; safepoints and will thus have an associated stackmap. .. _assembly:. Emitting assembly code: ``GCMetadataPrinter``; ---------------------------------------------. LLVM allows a plugin to print arbitrary assembly code before and after the rest; of a module's assembly code. At the end of the module, the GC can compile the; LLVM stack map into assembly code. (At the beginning, this information is not; yet computed.). Since AsmWriter and CodeGen are separate components of LLVM, a separate abstract; base class and registry is provided for printing assembly code, the; ``GCMetadaPrinter`` and ``GCMetadataPrinterRegistry``. The AsmWriter will look; for such a subclass if the ``GCStrategy`` sets ``UsesMetadata``:. .. code-block:: c++. MyGC::MyGC() {; UsesMetadata = true;; }. This separation allows JIT-only clients to be smaller. Note that LLVM does not currently have analogous APIs to support code generation; in the JIT, nor using the object writers. .. code-block:: c++. // lib/MyGC/MyGCPrinter.cpp - Example LLVM GC printer. #include ""llvm/CodeGen/GCMetadataPrinter.h""; #include ""llvm/Support/Compiler.h"". using namespace llvm;. namespace {; class LLVM_LIBRARY_VISIBILITY MyGCPrinter : public GCMetadataPrinter",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:35209,plugin,plugin,35209,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['plugin'],['plugin']
Modifiability,"ictions on use of alignas; Unknown. 2206; C++17; Composite type of object and function pointers; Unknown. 2207; CD5; Alignment of allocation function return value; Unknown. 2208; NAD; static_assert-declaration does not declare a member; Unknown. 2209; NAD; Destruction of constructed array elements; Unknown. 2210; NAD; Principal/target constructor confusion; Unknown. 2211; C++17; Hiding by lambda captures and parameters; Clang 8. 2212; CD5; Typedef changing linkage after use; Unknown. 2213; CD6; Forward declaration of partial specializations; Yes. 2214; C++17; Missing requirement on representation of integer values; Unknown. 2215; C++17; Redundant description of language linkage in function call; Unknown. 2216; NAD; Exception specifications in unevaluated contexts; Unknown. 2217; NAD; constexpr constructors for non-literal types; Unknown. 2218; C++17; Ambiguity and namespace aliases; Unknown. 2219; drafting; Dynamically-unreachable handlers; Not resolved. 2220; C++17; Hiding index variable in range-based for; Unknown. 2221; CD6; Copying volatile objects; Unknown. 2222; drafting; Additional contexts where instantiation is not required; Not resolved. 2223; drafting; Multiple alignas specifiers; Not resolved. 2224; C++17; Member subobjects and base-class casts; Unknown. 2225; NAD; reinterpret_cast to same floating-point type; Unknown. 2226; CD5; Xvalues vs lvalues in conditional expressions; Unknown. 2227; CD5; Destructor access and default member initializers; Unknown. 2228; open; Ambiguity resolution for cast to function type; Not resolved. 2229; CD5; Volatile unnamed bit-fields; Clang 7. 2230; NAD; Linkage of extern ""C"" function in unnamed namespace; Unknown. 2231; NAD; Class member access to static data member template; Unknown. 2232; open; thread_local anonymous unions; Not resolved. 2233; CD5; Function parameter packs following default arguments; Clang 11. 2234; CD5; Missing rules for simple-template-id as class-name; Unknown. 2235; CD5; Partial ordering and non-d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:151282,variab,variable,151282,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['variab'],['variable']
Modifiability,"id f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasLocalStorage; Matches a variable declaration that has function scope and is a; non-static local variable. Example matches x (matcher = varDecl(hasLocalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasStaticStorageDuration; Matches a variable declaration that has static storage duration.; It includes the variable declared at namespace scope and those declared; with ""static"" and ""extern"" storage class specifiers. void f() {; int x;; static int y;; thread_local int z;; }; int a;; static int b;; extern int c;; varDecl(hasStaticStorageDuration()); matches the function declaration y, a, b and c. Matcher<VarDecl>hasThreadStorageDuration; Matches a variable declaration that has thread storage duration. Example matches z, but not x, z, or a.; (matcher = varDecl(hasThreadStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<VarDecl>isConstinit; Matches constinit variable declarations. Given:; constinit int foo = 42;; constinit const char* bar = ""bar"";; int baz = 42;; [[clang::require_constant_initialization]] int xyz = 42;; varDecl(isConstinit()); matches the declaration of `foo` and `bar`, but not `baz` and `xyz`. Matcher<VarDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:125537,variab,variable,125537,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['variab'],['variable']
Modifiability,"id foo();; void bar(); void bar();; } // namespace a }; namespace shortNamespace { namespace shortNamespace {; void baz(); void baz();; } }. .. _ForEachMacros:. **ForEachMacros** (``List of Strings``) :versionbadge:`clang-format 3.7` :ref:`¶ <ForEachMacros>`; A vector of macros that should be interpreted as foreach loops; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. FOREACH(<variable-declaration>, ...); <loop-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. ForEachMacros: ['RANGES_FOR', 'FOREACH']. For example: BOOST_FOREACH. .. _IfMacros:. **IfMacros** (``List of Strings``) :versionbadge:`clang-format 13` :ref:`¶ <IfMacros>`; A vector of macros that should be interpreted as conditionals; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. IF(...); <conditional-body>; else IF(...); <conditional-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. IfMacros: ['IF']. For example: `KJ_IF_MAYBE; <https://github.com/capnproto/capnproto/blob/master/kjdoc/tour.md#maybes>`_. .. _IncludeBlocks:. **IncludeBlocks** (``IncludeBlocksStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IncludeBlocks>`; Dependent on the value, multiple ``#include`` blocks can be sorted; as one and divided based on category. Possible values:. * ``IBS_Preserve`` (in configuration: ``Preserve``); Sort each ``#include`` block separately. .. code-block:: c++. #include ""b.h"" into #include ""b.h"". #include <lib/main.h> #include ""a.h""; #include ""a.h"" #include <lib/main.h>. * ``IBS_Merge`` (in configuration: ``Merge``); Merge multiple ``#include`` blocks together and sort as one. .. code-block:: c++. #include ""b.h"" into #include ""a.h""; #include ""b.h""; #include <lib/main.h> #include <lib/main.h>; #include ""a.h"". * ``IBS_Regroup`` (in configuration: ``Regroup``); Merge multiple ``#include`` blocks together and sort as one.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:64908,config,configuration,64908,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,2,['config'],"['configuration', 'configured']"
Modifiability,"id) {; int x[8] __attribute__((aligned(128)));; memset (x, 0, sizeof (x));; bar (x);; }. //===----------------------------------------------------------------------===//. Altivec: Codegen'ing MUL with vector FMADD should add -0.0, not 0.0:; http://gcc.gnu.org/bugzilla/show_bug.cgi?id=8763. When -ffast-math is on, we can use 0.0. //===----------------------------------------------------------------------===//. Consider this:; v4f32 Vector;; v4f32 Vector2 = { Vector.X, Vector.X, Vector.X, Vector.X };. Since we know that ""Vector"" is 16-byte aligned and we know the element offset ; of "".X"", we should change the load into a lve*x instruction, instead of doing; a load/store/lve*x sequence. //===----------------------------------------------------------------------===//. Implement passing vectors by value into calls and receiving them as arguments. //===----------------------------------------------------------------------===//. GCC apparently tries to codegen { C1, C2, Variable, C3 } as a constant pool load; of C1/C2/C3, then a load and vperm of Variable. //===----------------------------------------------------------------------===//. We need a way to teach tblgen that some operands of an intrinsic are required to; be constants. The verifier should enforce this constraint. //===----------------------------------------------------------------------===//. We currently codegen SCALAR_TO_VECTOR as a store of the scalar to a 16-byte; aligned stack slot, followed by a load/vperm. We should probably just store it; to a scalar stack slot, then use lvsl/vperm to load it. If the value is already; in memory this is a big win. //===----------------------------------------------------------------------===//. extract_vector_elt of an arbitrary constant vector can be done with the ; following instructions:. vTemp = vec_splat(v0,2); // 2 is the element the src is in.; vec_ste(&destloc,0,vTemp);. We can do an arbitrary non-constant value by using lvsr/perm/ste. //===---------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt:1486,Variab,Variable,1486,interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt,2,['Variab'],['Variable']
Modifiability,"id);. void foo1(void) {; foo2();; }. void foo4(void) {; printf(""Foo4"");; }. .. code-block:: bash. --- command lines ---; $ clang -flto a.c -c -o a.o # <-- a.o is LLVM bitcode file; $ ar q a.a a.o # <-- a.a is an archive with LLVM bitcode; $ clang b.c -c -o b.o # <-- b.o is native object file; $ clang -flto a.a b.o -o main # <-- link with LLVMgold plugin. Gold informs the plugin that foo3 is never referenced outside the IR,; leading LLVM to delete that function. However, unlike in the :ref:`libLTO; example <libLTO-example>` gold does not currently eliminate foo4. Quickstart for using LTO with autotooled projects; =================================================. Once your system ``ld``, ``ar``, and ``nm`` all support LLVM bitcode,; everything is in place for an easy to use LTO build of autotooled projects:. * Follow the instructions :ref:`on how to build LLVMgold.so; <lto-how-to-build>`. * Install the newly built binutils to ``$PREFIX``. * Copy ``Release/lib/LLVMgold.so`` to ``$PREFIX/lib/bfd-plugins/``. * Set environment variables (``$PREFIX`` is where you installed clang and; binutils):. .. code-block:: bash. export CC=""$PREFIX/bin/clang -flto""; export CXX=""$PREFIX/bin/clang++ -flto""; export AR=""$PREFIX/bin/ar""; export NM=""$PREFIX/bin/nm""; export RANLIB=/bin/true #ranlib is not needed, and doesn't support .bc files in .a. * Or you can just set your path:. .. code-block:: bash. export PATH=""$PREFIX/bin:$PATH""; export CC=""clang -flto""; export CXX=""clang++ -flto""; export RANLIB=/bin/true; * Configure and build the project as usual:. .. code-block:: bash. % ./configure && make && make check. The environment variable settings may work for non-autotooled projects too,; but you may need to set the ``LD`` environment variable as well. Licensing; =========. Gold is licensed under the GPLv3. LLVMgold uses the interface file; ``plugin-api.h`` from gold which means that the resulting ``LLVMgold.so``; binary is also GPLv3. This can still be used to link non-GPLv3 programs; just",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:5145,plugin,plugins,5145,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['plugin'],['plugins']
Modifiability,"ided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a telephone. If you are interested in doing physics, a good HEP framework will save; you much work. Next is a list of the more commonly used components of; ROOT: Command Line Interpreter, Histograms and Fitting, Writing a; Graphical User Interface, 2D Graphics, Input/Output , Collection; Classes, Script Processor. There are also less commonly used components, as: 3D Graphics,; Parallel Processing (PROOF), Run Time Type Identification (RTTI),; Socket and Network Communication, Threads. #### Advantages of Frameworks. The benefits of frameworks can be summarized as follows:. - Less code to write - the programmer should be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent and modular code - the code reuse provides; consistency and common capabilities between programs, no matter; who writes them. Frameworks make it easier to break programs into; smaller pieces. - More focus on areas of expertise - users can concentrate on their; particular problem domain. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:7431,inherit,inherited,7431,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['inherit'],['inherited']
Modifiability,"ident = !{!8}. ;; Define the global variable itself; !0 = distinct !DIGlobalVariable(name: ""MyGlobal"", scope: !1, file: !2, line: 1, type: !5, isLocal: false, isDefinition: true, align: 64). ;; Define the compile unit.; !1 = distinct !DICompileUnit(language: DW_LANG_C99, file: !2,; producer: ""clang version 4.0.0"",; isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug,; enums: !3, globals: !4). ;;; ;; Define the file; ;;; !2 = !DIFile(filename: ""/dev/stdin"",; directory: ""/Users/dexonsmith/data/llvm/debug-info""). ;; An empty array.; !3 = !{}. ;; The Array of Global Variables; !4 = !{!0}. ;;; ;; Define the type; ;;; !5 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed). ;; Dwarf version to output.; !6 = !{i32 2, !""Dwarf Version"", i32 4}. ;; Debug info schema version.; !7 = !{i32 2, !""Debug Info Version"", i32 3}. ;; Compiler identification; !8 = !{!""clang version 4.0.0""}. The align value in DIGlobalVariable description specifies variable alignment in; case it was forced by C11 _Alignas(), C++11 alignas() keywords or compiler; attribute __attribute__((aligned ())). In other case (when this field is missing); alignment is considered default. This is used when producing DWARF output; for DW_AT_alignment value. C/C++ function information; --------------------------. Given a function declared as follows:. .. code-block:: c. int main(int argc, char *argv[]) {; return 0;; }. a C/C++ front-end would generate the following descriptors:. .. code-block:: text. ;;; ;; Define the anchor for subprograms.; ;;; !4 = !DISubprogram(name: ""main"", scope: !1, file: !1, line: 1, type: !5,; isLocal: false, isDefinition: true, scopeLine: 1,; flags: DIFlagPrototyped, isOptimized: false,; retainedNodes: !2). ;;; ;; Define the subprogram itself.; ;;; define i32 @main(i32 %argc, i8** %argv) !dbg !4 {; ...; }. C++ specific debug information; ==============================. C++ special member functions information; ----------------------------------------. DWARF v5 introduces a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:43952,variab,variable,43952,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"identifies a DILocation metadata node. These metadata attributes correspond to the operands of a ``llvm.dbg.declare``; IR intrinsic, see the :ref:`source level debugging<format_common_intrinsics>`; documentation. Varying variable locations; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Variables that are not always on the stack or change location are specified; with the ``DBG_VALUE`` meta machine instruction. It is synonymous with the; ``llvm.dbg.value`` IR intrinsic, and is written:. .. code-block:: text. DBG_VALUE $rax, $noreg, !123, !DIExpression(), debug-location !456. The operands to which respectively:. 1. Identifies a machine location such as a register, immediate, or frame index,. 2. Is either $noreg, or immediate value zero if an extra level of indirection is to be added to the first operand,. 3. Identifies a ``DILocalVariable`` metadata node,. 4. Specifies an expression qualifying the variable location, either inline or as a metadata node reference,. While the source location identifies the ``DILocation`` for the scope of the; variable. The second operand (``IsIndirect``) is deprecated and to be deleted.; All additional qualifiers for the variable location should be made through the; expression metadata. .. _instruction-referencing-locations:. Instruction referencing locations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This experimental feature aims to separate the specification of variable; *values* from the program point where a variable takes on that value. Changes; in variable value occur in the same manner as ``DBG_VALUE`` meta instructions; but using ``DBG_INSTR_REF``. Variable values are identified by a pair of; instruction number and operand number. Consider the example below:. .. code-block:: text. $rbp = MOV64ri 0, debug-instr-number 1, debug-location !12; DBG_INSTR_REF !123, !DIExpression(DW_OP_LLVM_arg, 0), dbg-instr-ref(1, 0), debug-location !456. Instruction numbers are directly attached to machine instructions with an; optional ``debug-instr-number`` attachment, bef",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:26236,variab,variable,26236,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['variab'],['variable']
Modifiability,"ider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6686,variab,variable,6686,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,2,['variab'],['variable']
Modifiability,"idth. <kind> defaults to ``integer`` if unspecified. .. option:: -fblocks. Enable the ""Blocks"" language feature. .. option:: -fobjc-abi-version=version. Select the Objective-C ABI version to use. Available versions are 1 (legacy; ""fragile"" ABI), 2 (non-fragile ABI 1), and 3 (non-fragile ABI 2). .. option:: -fobjc-nonfragile-abi-version=<version>. Select the Objective-C non-fragile ABI version to use by default. This will; only be used as the Objective-C ABI when the non-fragile ABI is enabled; (either via :option:`-fobjc-nonfragile-abi`, or because it is the platform; default). .. option:: -fobjc-nonfragile-abi, -fno-objc-nonfragile-abi. Enable use of the Objective-C non-fragile ABI. On platforms for which this is; the default ABI, it can be disabled with :option:`-fno-objc-nonfragile-abi`. Target Selection Options; ~~~~~~~~~~~~~~~~~~~~~~~~. Clang fully supports cross compilation as an inherent part of its design.; Depending on how your version of Clang is configured, it may have support for a; number of cross compilers, or may only support a native target. .. option:: -arch <architecture>. Specify the architecture to build for (Mac OS X specific). .. option:: -target <architecture>. Specify the architecture to build for (all platforms). .. option:: -mmacosx-version-min=<version>. When building for macOS, specify the minimum version supported by your; application. .. option:: -miphoneos-version-min. When building for iPhone OS, specify the minimum version supported by your; application. .. option:: --print-supported-cpus. Print out a list of supported processors for the given target (specified; through ``--target=<architecture>`` or :option:`-arch` ``<architecture>``). If no; target is specified, the system default target will be used. .. option:: -mcpu=?, -mtune=?. Acts as an alias for :option:`--print-supported-cpus`. .. option:: -mcpu=help, -mtune=help. Acts as an alias for :option:`--print-supported-cpus`. .. option:: -march=<cpu>. Specify that Clang should gene",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:9086,config,configured,9086,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,1,['config'],['configured']
Modifiability,"ied offset. .. option:: --arch-name=<string>. Specify the target architecture when disassembling. Use :option:`--version`; for a list of available targets. .. option:: --build-id=<string>. Look up the object using the given build ID, specified as a hexadecimal; string. The found object is handled as if it were an input filename. .. option:: -C, --demangle. Demangle symbol names in the output. .. option:: --debug-file-directory <path>. Provide a path to a directory with a `.build-id` subdirectory to search for; debug information for stripped binaries. Multiple instances of this argument; are searched in the order given. .. option:: --debuginfod, --no-debuginfod. Whether or not to try debuginfod lookups for debug binaries. Unless specified,; debuginfod is only enabled if libcurl was compiled in (``LLVM_ENABLE_CURL``); and at least one server URL was provided by the environment variable; ``DEBUGINFOD_URLS``. .. option:: --debug-vars=<format>. Print the locations (in registers or memory) of source-level variables; alongside disassembly. ``format`` may be ``unicode`` or ``ascii``, defaulting; to ``unicode`` if omitted. .. option:: --debug-vars-indent=<width>. Distance to indent the source-level variable display, relative to the start; of the disassembly. Defaults to 52 characters. .. option:: -j, --section=<section1[,section2,...]>. Perform commands on the specified sections only. For Mach-O use; `segment,section` to specify the section name. .. option:: -l, --line-numbers. When disassembling, display source line numbers. Implies; :option:`--disassemble`. .. option:: -M, --disassembler-options=<opt1[,opt2,...]>. Pass target-specific disassembler options. Available options:. * ``reg-names-std``: ARM only (default). Print in ARM 's instruction set documentation, with r13/r14/r15 replaced by sp/lr/pc.; * ``reg-names-raw``: ARM only. Use r followed by the register number.; * ``no-aliases``: AArch64 and RISC-V only. Print raw instruction mnemonic instead of pseudo instruction ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-objdump.rst:4174,variab,variables,4174,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-objdump.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-objdump.rst,1,['variab'],['variables']
Modifiability,"ied on the browser objects - can be `name`,; `type`, `size`, `date`:. ``` {.cpp}; Browser.SortBy: name; ```. Number of items in a group view:. ``` {.cpp}; Browser.GroupView: 10000; ```. Show or not hidden items:. ``` {.cpp}; Browser.ShowHidden: no; ```. Create a thumbnail view after executing the macro (default is `yes`). ``` {.cpp}; Browser.AutoThumbnail: yes; ```. ### TRint Specific Settings. Rint (interactive ROOT executable) specific alias, logon and logoff; macros. ``` {.cpp}; Rint.Load: rootalias.C; Rint.Logon: rootlogon.C; Rint.Logoff: rootlogoff.C; ```. Record ROOT session commands in a given history file (default is; `$(HOME)/.root_hist`). If set to ""`-`"", it turn off the command; recording. ``` {.cpp}; Rint.History: $(HOME)/.root_hist; ```. Next two lines set the history file size handling. Once `HistSize` is; reached, the last `HistSave` entries are removed. If `HistSize` is set; to 0, it turns off command recording. Both values can be overridden by; environment variable `ROOT_HIST=size[:save]`, where the ""`:save`"" part; is optional. ``` {.cpp}; Rint.HistSize: 500; Rint.HistSave: 400; ```. ### ACLiC Specific Settings. `ACLiC.Linkdef` specifies the suffix that will be added to the script; name to try to locate a custom linkdef file when generating the; dictionary. ``` {.cpp}; ACLiC.Linkdef: _linkdef; ```. The top directory for storing the libraries produced by ACLiC is set by:. ``` {.cpp}; ACLiC.BuildDir: /where/I/would/like/my/compiled/scripts; ```. The additional include directives for ACLiC compilations are set by:. ``` {.cpp}; ACLiC.IncludePaths: -I/where/the/includes/are; ```. ### PROOF Related Variables. PROOF debug options. ``` {.cpp}; Proof.DebugLevel: 0; Proof.DebugMask:-1; ```. PROOF GDB hooks allows a debugger to be attached early in the startup; phase of `proofserv: `0 - don't wait; 1 - master proofserv enters wait; loop; 2 - slave proofserv enters wait loop; 3 - any proofserv enters; wait loop. ``` {.cpp}; Proof.GdbHook: 0; ```. On the master t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:12660,variab,variable,12660,documentation/users-guide/InstallandBuild.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md,1,['variab'],['variable']
Modifiability,"ield,Column,Cluster,...}Descriptor; The descriptor classes provide read-only access to the on-disk meta-data of an RNTuple.; The meta-data include the schema (fields and columns), information about clusters and the page locations.; The descriptor classes are closely related to the format specification. For normal read and write tasks, access to the descriptor is not necessary.; One notable exception is bulk reading, where the descriptor can be used to determine entry boundaries of clusters.; The descriptors are used internally, e.g. to build an RNTupleModel from the on-disk information.; The descriptors are also useful for inspection purposes. The descriptor classes contain a copy of the meta-data; they are not linked to an open page source.; A descriptor can be used after its originating page source has been deleted. ### RField<T>; The RField<T> classes are central in RNTuple:; they link the in-memory representation of data types to their on-disk representation.; All field classes inherit from `RFieldBase`. Every type with RNTuple I/O supported has a corresponding RField<T> template specialization.; Complex types are composed of fields and sub fields.; E.g., a `struct` is represented by a parent field for the `struct` itself and a subfield for every member of the `struct`.; Fields of complex types have type-erased versions in addition to the templated ones (e.g., `RVectorField`, `RClassField`).; In this way, fields can be constructed even if the type information is only available at runtime.; To this end, `RFieldBase::Create()` creates an `RField` object from a type string. On the ""in-memory"" side, fields can construct and destroy objects of their wrapped type; (cf. `CreateValue()`, `CreateObject()`, `GetDeleter()` methods).; Existing objects in memory can be bound to fields (cf. `BindValue()` method). On the ""on-disk"" side, fields know about the possible column representations of their wrapped type.; Upon connecting a field to a page source or page sink,; fields c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:7844,inherit,inherit,7844,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['inherit'],['inherit']
Modifiability,"iends in PROOF.Package; management: add support for arguments in the SETUP function: it is; possible now to pass a string or a list of objects. The; TProof::EnablePackage interface has been extended to support this.Optimize; the validation step in the case not all the entries are required. The; validation step is stopped as soon as the requested number of events is; reached. If the parameter ""PROOF_ValidateByFile"" is set to 1, the; number of files is exactly what needed; otherwise the number of files; may exceed the number of files needed by (Number_Of_Workers - 1) .; New directive 'xpd.datadir' to better control the user data directories and their permission settings. In TPacketizerUnit, add the possibility to exactly share the number of cycles between the workers.; See the parameter PROOF_PacketizerFixedNum.Implement; a timer to terminate idle sessions. The timeout value is controlled by; the variable ProofServ.IdleTimeout (value in seconds). This variable; can be set for all sessions in the xproofd config file via the 'xpd.putrc' directive.; Add the possibility to control the use of sub-mergers with; the ROOTrc variable Proof.SubMergers. It has the same meaning of the; parameter 'PROOF_UseMergers'. The capabilities of the latter have been; extended: now -1 means disable the use of submergers (before  negative values were ignored and there was no way for the user to disable the use of submergers). . Packetizer optimizations: improved worked distribution when; the number of files left to be processed is smaller than the number of; workers and at least one file has a number of events significantly; larger than the average; better apply the upper/lower limits on the; expected packet processing time.; Add the possibility to single-out disk partitions in the; packetizer; this works adding the beginning of a path in the name; defining a new TFileNode (e.g. 'host://disk1' instead of 'host' only as; it was so far). These feature can be enabled by defining the rootrc; vari",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:6619,variab,variable,6619,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,4,"['config', 'variab']","['config', 'variable']"
Modifiability,"ients; Integration with IDEs; Use the LLVM 'BSD' License. Internal Design and Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++,; and Objective C++; Conformance with C/C++/ObjC and their; variants. End-User Features. Fast compiles and Low Memory Use. A major focus of our work on clang is to make it fast, light and scalable.; The library-based architecture of clang makes it straight-forward to time and; profile the cost of each layer of the stack, and the driver has a number of; options for performance analysis. Many detailed benchmarks can be found online.; Compile time performance is important, but when using clang as an API, often; memory use is even more so: the less memory the code takes the more code you can; fit into memory at a time (useful for whole program analysis tools, for; example).; In addition to being efficient when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong in the program,; highlighting related information so that it is easy to understand at a glance,; and making the wording as clear as possible.; Here is one simple example that illustrates the quality of Clang diagnostic:. $ clang -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:1439,adapt,adapt,1439,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,2,['adapt'],['adapt']
Modifiability,"ier). A text/uri-list is a standard file listing format; for drag and drop that specifies a list of files (each file per line).; Each line ends with a carriage return and newline` rn`. File names have; to be valid, url-encoded URI's as shown below:. `file://localhost/usr/bin/opera` or; `file://localhost/c:/programs/myfile.txt`. `file://server/data/software.xml` or; `http://root.cern.ch/root/images/ftpstats.gif`. The atoms and the drag and drop manager (**`TGDNDManager`**), are; created at the main application creation time (class TGMainFrame). Setting a Drag Source - first, create and fill data:. ``` {.cpp}; TH1F *h = new TH1F(""h"",""h"",1000,-3,3);; h->FillRandom(""gaus"",50000);; TDNDdata data;; TBufferFile *buf = new TBufferFile(TBuffer::kWrite);; buf->WriteObject(h);; data.fData = buf->Buffer();; data.fDataLength = buf->Length();; data.fDataType = gVirtualX->InternAtom(""application/root"");; ```. Then, set a GUI widget as DND Source, and associate the data. Source; widget can be any class inheriting from **`TGFrame`**. ``` {.cpp}; SourceWidget=new TGIcon(this,gClient->GetPicture(""f1_s.xpm""),32,32);; SourceWidget->SetDNDSource(kTRUE);; SourceWidget->SetDNDdata(&data);; ```. Setting A Drop Target - set the widget as DND Target, and set the DND; types it must be aware of: as `SourceWidget`, `TargetWidget` can be any; class inheriting from **`TGFrame`**. ``` {.cpp}; TargetWidget = new TRootEmbeddedCanvas(""Target"", this, 700, 400);; TargetWidget->SetDNDTarget(kTRUE);; gVirtualX->SetDNDAware(TargetWidget->GetId(),; gDNDManager->GetTypeList());; ```. `gDNDManager->GetTypeList()` returns the list of types recognized by; ROOT. Note that the Widget may receive drag and drop messages with drop-data; it does not understand, and thus it should only accept drops of the; proper type. ### Handling Drag and Drop Events. Once a widget has been set as DND Target, it has to handle Drag and Drop; events. `Atom_t HandleDNDenter(Atom_t *typelist)` - this method is used to; handle a drag oper",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:110086,inherit,inheriting,110086,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['inherit'],['inheriting']
Modifiability,"iers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or more member fields or functions. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ExperimentalAutoDetectBinPacking>`; If ``true``, clang-format detects whether function calls and; definitions are formatted with one parameter per line. Each call can be bin-packed, one-per-line or inconclusive. If it is; inconclusive, e.g. completely on one line, but a decision needs to be; made",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:62214,config,configuration,62214,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ies ; and depends on ROOT, is is advised to compile first ROOT without VecGeom support, ; then compile VecGeom against this ROOT version, then re-configure ROOT to enable ; VecGeom and Vc support, using the flags -Dvc=ON -Dvecgeom=on; ; This has been implemented by Mihaela Gheata <Mihaela.Gheata@cern.ch>. ## Database Libraries. * Fix `TPgSQLStatement::SetBinary` to actually handle binary data (previous limited to ascii). ## Networking Libraries. * When seeing too many requested ranges, Apache 2.4 now simply sends the whole file; (MaxRanges configuration parameter). TWebFile can handle this case now, but this can; trigger multiple transmissions of the full file. TWebFile warns when Apache reacts by; sending the full file. ## GUI Libraries. * A new `Browser.ExpandDirectories` option (the default is `yes`) has been added, allowing to prevent expanding the parent directory tree in the ROOT Browser (for example on nfs). ## Language Bindings. ### PyROOT. * Added a new configuration option to disable processing of the rootlogon[.py|C] macro in addition; ro the -n option in the command arguments. To disable processing the rootlogon do the following; before any other command that will trigger initialization:; ```; >>> import ROOT; >>> ROOT.PyConfig.DisableRootLogon = True; >>> ...; ```. ### Notebook integration. * Refactoring of the Jupyter integration layer into the new package JupyROOT.; * Added ROOT [Jupyter Kernel for ROOT](https://root.cern.ch/root-has-its-jupyter-kernel); * Magics are now invoked with standard syntax ""%%"", for example ""%%cpp"".; * The methods ""toCpp"" and ""toPython"" have been removed.; * Factorise output capturing and execution in an accelerator library and use ctypes to invoke functions.; * When the ROOT kernel is used, the output is consumed progressively; * Capture unlimited output also when using an IPython Kernel (fixes [ROOT-7960]). ## JavaScript ROOT. - New geometry (TGeo) classes support:; - browsing through volumes hieararchy; - changing visibil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:25246,config,configuration,25246,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['config'],['configuration']
Modifiability,"ies; of large commits. The principle advantage of this approach is that it minimises the cost of; inconsistency [BradburyTransition]_ [RobinsonTransition]_. It goes against a policy of avoiding large-scale reformatting of existing code; [GreeneDistinguish]_. It has been suggested that LLD would be a good starter project for the renaming; [Ueyama]_. Keeping git blame usable; ************************. ``git blame`` (or ``git annotate``) permits quickly identifying the commit that; changed a given line in a file. After renaming variables, many lines will show; as being changed by that one commit, requiring a further invocation of ``git; blame`` to identify prior, more interesting commits [GreeneGitBlame]_; [RicciAcronyms]_. **Mitigation**: `git-hyper-blame; <https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/git-hyper-blame.html>`_; can ignore or ""look through"" a given set of commits.; A ``.git-blame-ignore-revs`` file identifying the variable renaming commits; could be added to the LLVM git repository root directory.; It is being `investigated; <https://public-inbox.org/git/20190324235020.49706-1-michael@platin.gs/>`_; whether similar functionality could be added to ``git blame`` itself. Minimising cost of downstream merges; ************************************. There are many forks of LLVM with downstream changes. Merging a large-scale; renaming change could be difficult for the fork maintainers. **Mitigation**: A large-scale renaming would be automated. A fork maintainer can; merge from the commit immediately before the renaming, then apply the renaming; script to their own branch. They can then merge again from the renaming commit,; resolving all conflicts by choosing their own version. This could be tested on; the [SVE]_ fork. Provisional Plan; ================. This is a provisional plan for the `Big bang`_ approach. It has not been agreed. #. Investigate improving ``git blame``. The extent to which it can be made to; ""look throu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:9599,variab,variable,9599,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['variab'],['variable']
Modifiability,"iew and ELF targets with recent versions of Clang, GCC and MSVC; (-O0 -g). .. code-block:: c++. // definitions.h; #ifdef _MSC_VER; #define forceinline __forceinline; #elif defined(__clang__); #if __has_attribute(__always_inline__); #define forceinline inline __attribute__((__always_inline__)); #else; #define forceinline inline; #endif; #elif defined(__GNUC__); #define forceinline inline __attribute__((__always_inline__)); #else; #define forceinline inline; #error; #endif. As the test is dependent on inline compiler options, the above header; file defines *forceinline*. .. code-block:: c++. #include ""definitions.h"". .. code-block:: c++. 1 #include ""definitions.h""; 2 forceinline int InlineFunction(int Param) {; 3 int Var_1 = Param;; 4 {; 5 int Var_2 = Param + Var_1;; 6 Var_1 = Var_2;; 7 }; 8 return Var_1;; 9 }; 10; 11 int test(int Param_1, int Param_2) {; 12 int A = Param_1;; 13 A += InlineFunction(Param_2);; 14 return A;; 15 }. The above test is used to illustrate a variable issue found in the Clang; compiler:; `PR43860 (Bugs LLVM) <https://bugs.llvm.org/show_bug.cgi?id=43860>`_ /; `PR43205 (GitHub) <https://github.com/llvm/llvm-project/issues/43205>`_. These are the logical views that :program:`llvm-debuginfo-analyzer`; generates for 3 different compilers (MSVC, Clang and GCC), emitting; different debug information formats (CodeView, DWARF) on different; platforms. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level,format,producer; --output-sort=name; --print=symbols; pr-43860-codeview-clang.o; pr-43860-codeview-msvc.o; pr-43860-dwarf-clang.o; pr-43860-dwarf-gcc.o. CODEVIEW - Clang (Windows); ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: none. Logical View:; [000] {File} 'pr-43860-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [002] {Producer} 'clang version 14.0.0'; [002] 2 {Function} inlined 'InlineFunction' -> 'int'; [003] {Parameter} '' -> 'int'; [002] {Function} extern not_inlined 'test' -> 'int'; [003] {Variable} 'A' -> 'int'; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:49589,variab,variable,49589,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['variab'],['variable']
Modifiability,"iews.llvm.org/D95776 |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Feature optionality | Generic address space | :good:`done` | https://reviews.llvm.org/D95778 and https://reviews.llvm.org/D103401 |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Feature optionality | Builtin function overloads with generic address space | :good:`done` | https://reviews.llvm.org/D105526, https://reviews.llvm.org/D107769 |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Feature optionality | Program scope variables in global memory | :good:`done` | https://reviews.llvm.org/D103191 |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Feature optionality | 3D image writes including builtin functions | :good:`done` | https://reviews.llvm.org/D106260 (frontend) |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Feature optionality | read_write images including builtin functions | :good:`done` | https://reviews.llvm.org/D104915 (frontend) and https://reviews.llvm.o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:17586,variab,variables,17586,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst,1,['variab'],['variables']
Modifiability,"if any dbg.value has its operand optimized out and cannot be; recovered, then a kill dbg.value is necessary to terminate earlier variable; locations. Additional kill dbg.values may be necessary when the debugger can; observe re-ordering of assignments. How variable location metadata is transformed during CodeGen; ============================================================. LLVM preserves debug information throughout mid-level and backend passes,; ultimately producing a mapping between source-level information and; instruction ranges. This; is relatively straightforwards for line number information, as mapping; instructions to line numbers is a simple association. For variable locations; however the story is more complex. As each ``llvm.dbg.value`` intrinsic; represents a source-level assignment of a value to a source variable, the; variable location intrinsics effectively embed a small imperative program; within the LLVM IR. By the end of CodeGen, this becomes a mapping from each; variable to their machine locations over ranges of instructions.; From IR to object emission, the major transformations which affect variable; location fidelity are:. 1. Instruction Selection; 2. Register allocation; 3. Block layout. each of which are discussed below. In addition, instruction scheduling can; significantly change the ordering of the program, and occurs in a number of; different passes. Some variable locations are not transformed during CodeGen. Stack locations; specified by ``llvm.dbg.declare`` are valid and unchanging for the entire; duration of the function, and are recorded in a simple MachineFunction table.; Location changes in the prologue and epilogue of a function are also ignored:; frame setup and destruction may take several instructions, require a; disproportionate amount of debugging information in the output binary to; describe, and should be stepped over by debuggers anyway. Variable locations in Instruction Selection and MIR; ---------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:24569,variab,variable,24569,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"if it can be decomposed. For example, classes, structures, and; arrays are composite types. Simple types are also called primitive; types, basic types, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves up the; inheritance tree until it reaches an ancestor without a parent. To; serialize the object data members it calls their `Streamer`. They in; turn move up their own inheritance tree and so forth. The simple data; members are written to the buffer directly. Eventually the buffer; contains all simple data members of all the classes that make up this; particular object. Data members that are references (as; `MyClass &fObj;`) are never saved, it is always the responsibility of; the object's constructor to set them properly. ### Automatically Generated Streamers. A `Streamer `usually calls other `Streamers`: the `Streamer `of its; parents and data members. This architecture depends on all classes; having `Streamers`, because eventually they will be called. To ensure; that a class has a `Streamer`, `rootcling` automatically creates one in; the `ClassDef` macro that is defined in `$ROOTSYS/include/Rtypes.h`.; `ClassDef` defines several methods for any class, and one of them is the; `Streamer`. The automatically generated `Streamer `is complete and can; be used as long as no customization is needed. The `Event` class is defined in `$ROOTSYS/test/Event.h`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:43161,inherit,inheritance,43161,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['inherit'],['inheritance']
Modifiability,"if it did, it could not eliminate the sext. 4) the code; generator has historically assumed that the result is extended to i32, which is; a problem on PIC16 (and is also probably wrong on alpha and other 64-bit; targets). //===----------------------------------------------------------------------===//; // The proposal; //===----------------------------------------------------------------------===//. I suggest that we have the front-end fully lower out the ABI issues here to; LLVM IR. This makes it 100% explicit what is going on and means that there is; no cause for confusion. For example, the cases above should compile into:. define i32 @z() nounwind {; entry:; %0 = tail call i32 (...)* @y() nounwind; 	%1 = trunc i32 %0 to i16; %2 = sext i16 %1 to i32; ret i32 %2; }; define i32 @b() nounwind {; entry:; 	%0 = tail call i32 (...)* @a() nounwind; 	%retval12 = trunc i32 %0 to i16; 	%tmp = sext i16 %retval12 to i32; 	ret i32 %tmp; }. In this model, no functions will return an i1/i8/i16 (and on a x86-64 target; that extends results to i64, no i32). This solves the ambiguity issue, allows us ; to fully describe all possible ABIs, and now allows the optimizers to reason; about and eliminate these extensions. The one thing that is missing is the ability for the front-end and optimizer to; specify/infer the guarantees provided by the ABI to allow other optimizations.; For example, in the y/z case, since y is known to return a sign extended value,; the trunc/sext in z should be eliminable. This can be done by introducing new sext/zext attributes which mean ""I know; that the result of the function is sign extended at least N bits. Given this,; and given that it is stuck on the y function, the mid-level optimizer could; easily eliminate the extensions etc with existing functionality. The major disadvantage of doing this sort of thing is that it makes the ABI; lowering stuff even more explicit in the front-end, and that we would like to; eventually move to having the code generat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt:3741,extend,extends,3741,interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt,1,['extend'],['extends']
Modifiability,"if it is supported by the target ISA. Otherwise, the; builtin is translated into a call to ``abort``. If this option is; set, then the code generator will always lower the builtin to a call; to the specified function regardless of whether the target ISA has a; trap instruction. This option is useful for environments (e.g.; deeply embedded) where a trap cannot be properly handled, or when; some custom behavior is desired. .. option:: -ftls-model=[model]. Select which TLS model to use. Valid values are: ``global-dynamic``, ``local-dynamic``,; ``initial-exec`` and ``local-exec``. The default value is; ``global-dynamic``. The compiler may use a different model if the; selected model is not supported by the target, or if a more; efficient model can be used. The TLS model can be overridden per; variable using the ``tls_model`` attribute. .. option:: -femulated-tls. Select emulated TLS model, which overrides all -ftls-model choices. In emulated TLS mode, all access to TLS variables are converted to; calls to __emutls_get_address in the runtime library. .. option:: -mhwdiv=[values]. Select the ARM modes (arm or thumb) that support hardware division; instructions. Valid values are: ``arm``, ``thumb`` and ``arm,thumb``.; This option is used to indicate which mode (arm or thumb) supports; hardware division instructions. This only applies to the ARM; architecture. .. option:: -m[no-]crc. Enable or disable CRC instructions. This option is used to indicate whether CRC instructions are to; be generated. This only applies to the ARM architecture. CRC instructions are enabled by default on ARMv8. .. option:: -mgeneral-regs-only. Generate code which only uses the general purpose registers. This option restricts the generated code to use general registers; only. This only applies to the AArch64 architecture. .. option:: -mcompact-branches=[values]. Control the usage of compact branches for MIPSR6. Valid values are: ``never``, ``optimal`` and ``always``.; The default value is ``optimal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:83947,variab,variables,83947,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variables']
Modifiability,"if they were disjoint partitions of the; memory (that is, if you have one variable, as above, it represents the entire; memory, and if you have multiple variables, each one represents some; disjoint portion of the memory). First, because alias analysis results conflict with each other, and; each result may be what an analysis wants (IE; TBAA may say no-alias, and something else may say must-alias), it is; not possible to partition the memory the way every optimization wants.; Second, some alias analysis results are not transitive (IE A noalias B,; and B noalias C, does not mean A noalias C), so it is not possible to; come up with a precise partitioning in all cases without variables to; represent every pair of possible aliases. Thus, partitioning; precisely may require introducing at least N^2 new virtual variables,; phi nodes, etc. Each of these variables may be clobbered at multiple def sites. To give an example, if you were to split up struct fields into; individual variables, all aliasing operations that may-def multiple struct; fields, will may-def more than one of them. This is pretty common (calls,; copies, field stores, etc). Experience with SSA forms for memory in other compilers has shown that; it is simply not possible to do this precisely, and in fact, doing it; precisely is not worth it, because now all the optimizations have to; walk tons and tons of virtual variables and phi nodes. So we partition. At the point at which you partition, again,; experience has shown us there is no point in partitioning to more than; one variable. It simply generates more IR, and optimizations still; have to query something to disambiguate further anyway. As a result, LLVM partitions to one variable. Precision in practice; ^^^^^^^^^^^^^^^^^^^^^. In practice, there are implementation details in LLVM that also affect the; results' precision provided by ``MemorySSA``. For example, AliasAnalysis has various; caps, or restrictions on looking through phis which can affect what ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:17715,variab,variables,17715,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['variab'],['variables']
Modifiability,"if( NOT LLVM_BUILD_TOOLS ); set(EXCLUDE_FROM_ALL ON); endif(). # If we don't need RTTI or EH, there's no reason to export anything; # from this plugin.; if( NOT LLVM_REQUIRES_RTTI ); if( NOT LLVM_REQUIRES_EH ); set(LLVM_EXPORTED_SYMBOL_FILE ${CMAKE_CURRENT_SOURCE_DIR}/bugpoint.exports); endif(); endif(). if(WIN32 OR CYGWIN OR ZOS); set(LLVM_LINK_COMPONENTS Core Support); endif(). add_llvm_library( BugpointPasses MODULE BUILDTREE_ONLY; TestPasses.cpp. DEPENDS; intrinsics_gen; bugpoint; ); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/CMakeLists.txt:144,plugin,plugin,144,interpreter/llvm-project/llvm/tools/bugpoint-passes/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/CMakeLists.txt,2,['plugin'],['plugin']
Modifiability,"if(LLVM_BYE_LINK_INTO_TOOLS); message(WARNING ""Setting LLVM_BYE_LINK_INTO_TOOLS=ON only makes sense for testing purpose""); endif(). # The plugin expects to not link against the Support and Core libraries,; # but expects them to exist in the process loading the plugin. This doesn't; # work with DLLs on Windows (where a shared library can't have undefined; # references), so just skip this example on Windows.; if (NOT WIN32 AND NOT CYGWIN); add_llvm_pass_plugin(Bye; Bye.cpp; DEPENDS; intrinsics_gen; BUILDTREE_ONLY; ). install(TARGETS ${name} RUNTIME DESTINATION ""${LLVM_EXAMPLES_INSTALL_DIR}""); set_target_properties(${name} PROPERTIES FOLDER ""Examples""); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Bye/CMakeLists.txt:138,plugin,plugin,138,interpreter/llvm-project/llvm/examples/Bye/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Bye/CMakeLists.txt,2,['plugin'],['plugin']
Modifiability,"if(LLVM_EXAMPLEIRTRANSFORMS_LINK_INTO_TOOLS); message(WARNING ""Setting LLVM_EXAMPLEIRTRANSFORMS_LINK_INTO_TOOLS=ON only makes sense for testing purpose""); endif(). # The plugin expects to not link against the Support and Core libraries,; # but expects them to exist in the process loading the plugin. This doesn't; # work with DLLs on Windows (where a shared library can't have undefined; # references), so just skip this example on Windows.; if (NOT WIN32 AND NOT CYGWIN); add_llvm_pass_plugin(ExampleIRTransforms; SimplifyCFG.cpp; DEPENDS; intrinsics_gen; BUILDTREE_ONLY; ). install(TARGETS ${name} RUNTIME DESTINATION ""${LLVM_EXAMPLES_INSTALL_DIR}""); set_target_properties(${name} PROPERTIES FOLDER ""Examples""); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/CMakeLists.txt:170,plugin,plugin,170,interpreter/llvm-project/llvm/examples/IRTransforms/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/CMakeLists.txt,2,['plugin'],['plugin']
Modifiability,"if(NOT asan OR MSVC); return(); endif(). # Make a shared library that holds the ROOT default config for address sanitizer.; # This is can be used with LD_PRELOAD; add_library(ROOTSanitizerConfig SHARED SanitizerSetup.cxx). # Make a static library that holds the ROOT default config for address sanitizer.; # We link this into all executables in ROOT, so they automatically start up with good defaults.; set(library ROOTStaticSanitizerConfig); add_library(${library} STATIC SanitizerSetup.cxx); set_property(TARGET ${library} PROPERTY POSITION_INDEPENDENT_CODE ON). # This pulls in the sanitizer link flags when linking against the config library; target_link_libraries(${library} INTERFACE ${ASAN_EXTRA_EXE_LINKER_FLAGS}). # Make it visible to the outside to sanitize e.g. roottest executables; set_property(GLOBAL APPEND PROPERTY ROOT_EXPORTED_TARGETS ${library}); add_library(ROOT::${library} ALIAS ${library}). # Now sanitize executables that are not created with ROOT_EXECUTABLE():; foreach(target llvm-min-tblgen llvm-tblgen clang-tblgen); target_link_libraries(${target} PRIVATE ${library}); endforeach(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/CMakeLists.txt:93,config,config,93,core/sanitizer/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/CMakeLists.txt,3,['config'],['config']
Modifiability,"ifficult to support on-the-fly redefinition; of the event weight variable in the new data store scheme. To declare a data set weighed,; use the WeightVar() modifier of the constructor instead,e.g.:. RooDataSet wdata(""wdata"",""wdata"",RooArgSet(x,y,wgt),WeightVar(wgt)) ;. The RooHist class that represents data as a histogram in a RooPlot has been modified; so that it can show approximate Poisson errors for non-integer data. These approximate; errors are calculated from interpolation of the error bars of the nearest integers. NB: A weighted dataset; plotted with RooAbsData::plotOn() will be default show sum-of-weights-squared errors. Only; when Poisson error are forced through a DataError(RooAbsData::Poisson) argument these; approximate Poisson error bars are shown. Miscellaneous improvements other. The RooFit messagee service class RooMsgService has been augmented with a stack that; can store its configurate state information. A call to saveState() will save the; present configuration, which can be restored through a subsequent call to restoreState().; In addition to the method RooAbsArg::printCompactTree() which is mostly intende for; debugging, a new method RooAbsArg::printComponentTree() has been added that prints; the tree structure of a pdf in a more user-friendly content oriented way. The printing ; of the leaf nodes (the variables) is omitted in this method to keep the output compact. RooStats. This release contains significant bug fixes and it is strongly; recommended to update to this version if using older ones. . Major Changes in LimitCalculator and HypoTestCalculator classes: usage of ModelConfig class. The RooStats calculator interfaces have been changed to use the ModelConfig class.; All the setter methods with the parameter lists, pdf instances and name have been removed from the interfaces.; The SetWorkspace(RooWorkspace & ) has also been removed, while a SetModel(const ModelConfig &); function is introduced. Users are supposed to pass all the model info",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:10853,config,configuration,10853,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,2,['config'],['configuration']
Modifiability,"ific; complaint is that people perceive LLVM as being incapable of performing; high-level language-specific optimization: LLVM ""loses too much; information"". Here are a few observations about this:. First, you're right that LLVM does lose information. For example, as of; this writing, there is no way to distinguish in the LLVM IR whether an; SSA-value came from a C ""int"" or a C ""long"" on an ILP32 machine (other; than debug info). Both get compiled down to an 'i32' value and the; information about what it came from is lost. The more general issue; here, is that the LLVM type system uses ""structural equivalence"" instead; of ""name equivalence"". Another place this surprises people is if you; have two types in a high-level language that have the same structure; (e.g. two different structs that have a single int field): these types; will compile down into a single LLVM type and it will be impossible to; tell what it came from. Second, while LLVM does lose information, LLVM is not a fixed target: we; continue to enhance and improve it in many different ways. In addition; to adding new features (LLVM did not always support exceptions or debug; info), we also extend the IR to capture important information for; optimization (e.g. whether an argument is sign or zero extended,; information about pointers aliasing, etc). Many of the enhancements are; user-driven: people want LLVM to include some specific feature, so they; go ahead and extend it. Third, it is *possible and easy* to add language-specific optimizations,; and you have a number of choices in how to do it. As one trivial; example, it is easy to add language-specific optimization passes that; ""know"" things about code compiled for a language. In the case of the C; family, there is an optimization pass that ""knows"" about the standard C; library functions. If you call ""exit(0)"" in main(), it knows that it is; safe to optimize that into ""return 0;"" because C specifies what the; 'exit' function does. In addition to simple li",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:9856,enhance,enhance,9856,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['enhance'],['enhance']
Modifiability,"ification string. MODULE_CODE_ASM Record; ^^^^^^^^^^^^^^^^^^^^^^. ``[ASM, ...string...]``. The ``ASM`` record (code 4) contains a variable number of values representing; the bytes of ``module asm`` strings, with individual assembly blocks separated; by newline (ASCII 10) characters. .. _MODULE_CODE_SECTIONNAME:. MODULE_CODE_SECTIONNAME Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[SECTIONNAME, ...string...]``. The ``SECTIONNAME`` record (code 5) contains a variable number of values; representing the bytes of a single section name string. There should be one; ``SECTIONNAME`` record for each section name referenced (e.g., in global; variable or function ``section`` attributes) within the module. These records; can be referenced by the 1-based index in the *section* fields of ``GLOBALVAR``; or ``FUNCTION`` records. MODULE_CODE_DEPLIB Record; ^^^^^^^^^^^^^^^^^^^^^^^^^. ``[DEPLIB, ...string...]``. The ``DEPLIB`` record (code 6) contains a variable number of values representing; the bytes of a single dependent library name string, one of the libraries; mentioned in a ``deplibs`` declaration. There should be one ``DEPLIB`` record; for each library name referenced. MODULE_CODE_GLOBALVAR Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[GLOBALVAR, strtab offset, strtab size, pointer type, isconst, initid, linkage, alignment, section, visibility, threadlocal, unnamed_addr, externally_initialized, dllstorageclass, comdat, attributes, preemptionspecifier]``. The ``GLOBALVAR`` record (code 7) marks the declaration or definition of a; global variable. The operand fields are:. * *strtab offset*, *strtab size*: Specifies the name of the global variable.; See `STRTAB_BLOCK Contents`_. * *pointer type*: The type index of the pointer type used to point to this; global variable. * *isconst*: Non-zero if the variable is treated as constant within the module,; or zero if it is not. * *initid*: If non-zero, the value index of the initializer for this variable,; plus 1. .. _linkage type:. * *linkage*: ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:26701,variab,variable,26701,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability,ification.h; TMVA/Results.h; TMVA/ResultsMulticlass.h; TMVA/ResultsRegression.h; TMVA/ROCCalc.h; TMVA/ROCCurve.h; TMVA/RootFinder.h; TMVA/RuleCut.h; TMVA/RuleEnsemble.h; TMVA/RuleFitAPI.h; TMVA/RuleFit.h; TMVA/RuleFitParams.h; TMVA/Rule.h; TMVA/SdivSqrtSplusB.h; TMVA/SeparationBase.h; TMVA/SimulatedAnnealingFitter.h; TMVA/SimulatedAnnealing.h; TMVA/SVEvent.h; TMVA/SVKernelFunction.h; TMVA/SVKernelMatrix.h; TMVA/SVWorkingSet.h; TMVA/TActivationChooser.h; TMVA/TActivation.h; TMVA/TActivationIdentity.h; TMVA/TActivationRadial.h; TMVA/TActivationReLU.h; TMVA/TActivationSigmoid.h; TMVA/TActivationTanh.h; TMVA/Timer.h; TMVA/TNeuron.h; TMVA/TNeuronInputAbs.h; TMVA/TNeuronInputChooser.h; TMVA/TNeuronInput.h; TMVA/TNeuronInputSqSum.h; TMVA/TNeuronInputSum.h; TMVA/Tools.h; TMVA/TrainingHistory.h; TMVA/TransformationHandler.h; TMVA/TSpline1.h; TMVA/TSpline2.h; TMVA/TSynapse.h; TMVA/Types.h; TMVA/VariableDecorrTransform.h; TMVA/VariableGaussTransform.h; TMVA/VariableIdentityTransform.h; TMVA/VariableImportance.h; TMVA/VariableInfo.h; TMVA/VariableNormalizeTransform.h; TMVA/VariablePCATransform.h; TMVA/VariableRearrangeTransform.h; TMVA/VariableTransformBase.h; TMVA/VariableTransform.h; TMVA/VarTransformHandler.h; TMVA/Version.h; TMVA/Volume.h; # TMVA/DNN/Adadelta.h; # TMVA/DNN/Adagrad.h; # TMVA/DNN/Adam.h; # TMVA/DNN/BatchNormLayer.h; # TMVA/DNN/DataLoader.h; # TMVA/DNN/DeepNet.h; # TMVA/DNN/DenseLayer.h; # TMVA/DNN/DLMinimizers.h; # TMVA/DNN/Functions.h; # TMVA/DNN/GeneralLayer.h; # TMVA/DNN/ReshapeLayer.h; # TMVA/DNN/RMSProp.h; # TMVA/DNN/SGD.h; # TMVA/DNN/TensorDataLoader.h; # TMVA/DNN/CNN/ContextHandles.h; # TMVA/DNN/CNN/ConvLayer.h; # TMVA/DNN/CNN/MaxPoolLayer.h; # TMVA/DNN/RNN/RNNLayer.h; # TMVA/DNN/Architectures/Reference.h; # TMVA/DNN/Architectures/Reference/DataLoader.h; # TMVA/DNN/Architectures/Reference/TensorDataLoader.h; # TMVA/DNN/Architectures/Cpu.h; # TMVA/DNN/Architectures/Cpu/CpuBuffer.h; # TMVA/DNN/Architectures/Cpu/CpuMatrix.h; # TMVA/DNN/Architectures/Cpu/Cp,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/CMakeLists.txt:4122,Variab,VariableImportance,4122,tmva/tmva/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/CMakeLists.txt,1,['Variab'],['VariableImportance']
Modifiability,"ified; ``<N>`` has precedence. The default is 5. .. option:: --dump-input-filter <value>. In the dump requested by ``--dump-input``, print only input lines of kind; ``<value>`` plus any context specified by ``--dump-input-context``. When; there are multiple occurrences of this option, the ``<value>`` that appears; earliest in the list below has precedence. The default is ``error`` when; ``--dump-input=fail``, and it's ``all`` when ``--dump-input=always``. * ``all`` - All input lines; * ``annotation-full`` - Input lines with annotations; * ``annotation`` - Input lines with starting points of annotations; * ``error`` - Input lines with starting points of error annotations. .. option:: --enable-var-scope. Enables scope for regex variables. Variables with names that start with ``$`` are considered global and; remain set throughout the file. All other variables get undefined after each encountered ``CHECK-LABEL``. .. option:: -D<VAR=VALUE>. Sets a filecheck pattern variable ``VAR`` with value ``VALUE`` that can be; used in ``CHECK:`` lines. .. option:: -D#<FMT>,<NUMVAR>=<NUMERIC EXPRESSION>. Sets a filecheck numeric variable ``NUMVAR`` of matching format ``FMT`` to; the result of evaluating ``<NUMERIC EXPRESSION>`` that can be used in; ``CHECK:`` lines. See section; ``FileCheck Numeric Variables and Expressions`` for details on supported; numeric expressions. .. option:: -version. Show the version number of this program. .. option:: -v. Print good directive pattern matches. However, if ``-dump-input=fail`` or; ``-dump-input=always``, add those matches as input annotations instead. .. option:: -vv. Print information helpful in diagnosing internal FileCheck issues, such as; discarded overlapping ``CHECK-DAG:`` matches, implicit EOF pattern matches,; and ``CHECK-NOT:`` patterns that do not have matches. Implies ``-v``.; However, if ``-dump-input=fail`` or ``-dump-input=always``, just add that; information as input annotations instead. .. option:: --allow-deprecated-dag-over",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:6157,variab,variable,6157,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variable']
Modifiability,"ifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). NCycles No 200 − Number of training cycles. HiddenLayers No N,N-1 − Specification of hidden layer architecture (N stands for number of variables; any integers may also be used). ValidationFraction No 0.5 − Fraction of events in training tree used for cross validation. LearningMethod No Stochastic Stochastic, Batch, SteepestDescent, RibierePolak, FletcherReeves, BFGS Learning method. Configuration options for setup and tuning of specific fitter :. Configuration options reference for fitting method: Simulated Annealing (SA). Option Array Default value Predefined values Description. MaxCalls No 100000 − Maximum number of minimisation calls. InitialTemp No 1e+06 − Initial temperature. MinTemp No 1e-06 − Mimimum temperature. Eps No 1e-10 − Epsilon. TempScale No 1 − Temperature scale. AdaptiveSpeed No 1 − Adaptive speed. TempAdaptiveStep No 0.009875 − Step made in each generation temperature adaptive. UseDefaultScale No False − Use default temperature scale for temperature minimisation algorithm. UseDefaultTemp No False − Use default initial temperature. KernelTemp No IncAdaptive IncAdaptive, DecAdaptive, Sqrt, Log, Sin, Homo, Geo Temperature minimisation algorithm. Configuration options for setup and tuning of specific fitter :. Configuration options reference for fitting method: Monte Carlo sampling (MC). Option Array Default value Predefined values Description. SampleSize No 100000 − Number of Monte Carlo events in toy sample. Sigma No -1 − If > 0: new points are generated according to Gauss around best value and with Sigma in units of interval length. Seed No 100 − Seed for the random generator (0 takes random seeds). Configuration options for setup and tuning of specific fitter :. Configuration options reference for fitting method: TMinuit (MT). Option Array Default value Predef",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:29510,Adapt,AdaptiveSpeed,29510,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,2,['Adapt'],"['Adaptive', 'AdaptiveSpeed']"
Modifiability,"ig ipa option has five different modes: none, basic-inlining,; inlining, dynamic, and dynamic-bifurcate. Under -analyzer-config ipa=dynamic,; all dynamic calls are inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if they are non-virtual or; can be safely devirtualized. Bifurcation; ^^^^^^^^^^^. ExprEngine::BifurcateCall implements the ``-analyzer-config ipa=dynamic-bifurcate``; mode. When a call is made on an object with imprecise dynamic type information; (RuntimeDefinition::mayHaveOtherDefinitions() evaluates to TRUE), ExprEngine; bifurcates the path and marks the object's region (retrieved from the; RuntimeDefinition object) with a path-sensitive ""mode"" in the ProgramState. Currently, there are 2 modes:. * ``DynamicDispatchModeInlined`` - Models the case where the dynamic type information; of the receiver (MemoryRegion) is assumed to be perfectly constrained so; that a given definition of a method is expected to be the code actually; called. When this mode is set, ExprEngine uses the Decl from; RuntimeDefinition to inline any dynamically dispatched call sent to this; receiver because the function definition is considered to be fully resolved. * ``DynamicD",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:12748,config,config,12748,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['config'],['config']
Modifiability,"ightforward: we emit the RHS of the assignment, create a store, and; return the computed value. Returning a value allows for chained; assignments like ""X = (Y = Z)"". Now that we have an assignment operator, we can mutate loop variables; and arguments. For example, we can now run code like this:. ::. # Function to print a double.; extern printd(x);. # Define ':' for sequencing: as a low-precedence operator that ignores operands; # and just returns the RHS.; def binary : 1 (x y) y;. def test(x); printd(x) :; x = 4 :; printd(x);. test(123);. When run, this example prints ""123"" and then ""4"", showing that we did; actually mutate the value! Okay, we have now officially implemented our; goal: getting this to work requires SSA construction in the general; case. However, to be really useful, we want the ability to define our; own local variables, let's add this next!. User-defined Local Variables; ============================. Adding var/in is just like any other extension we made to; Kaleidoscope: we extend the lexer, the parser, the AST and the code; generator. The first step for adding our new 'var/in' construct is to; extend the lexer. As before, this is pretty trivial, the code looks like; this:. .. code-block:: c++. enum Token {; ...; // var definition; tok_var = -13; ...; }; ...; static int gettok() {; ...; if (IdentifierStr == ""in""); return tok_in;; if (IdentifierStr == ""binary""); return tok_binary;; if (IdentifierStr == ""unary""); return tok_unary;; if (IdentifierStr == ""var""); return tok_var;; return tok_identifier;; ... The next step is to define the AST node that we will construct. For; var/in, it looks like this:. .. code-block:: c++. /// VarExprAST - Expression class for var/in; class VarExprAST : public ExprAST {; std::vector<std::pair<std::string, std::unique_ptr<ExprAST>>> VarNames;; std::unique_ptr<ExprAST> Body;. public:; VarExprAST(std::vector<std::pair<std::string, std::unique_ptr<ExprAST>>> VarNames,; std::unique_ptr<ExprAST> Body); : VarNames(std::move(V",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:22991,extend,extend,22991,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['extend'],['extend']
Modifiability,"iginal spectrum, are presented in the Figure 4.8. ![Original spectrum before unfolding](figures/image100.png). ![Contents of the responses in the original spectrum](figures/image102.png). Another example where we have used the unfolding method is the; decomposition of continuum of gamma-ray spectra. Using simulation and; interpolation techniques, we have synthesized the response matrix (size; `3400x3400` channels) of Gammasphere spectrometer (Figure 4.9). Its details are; presented in Figure 4.10. The original spectrum of Co^56 before and after; continuum decomposition are presented in Figures 4.11, 4.12, respectively. ![Response matrix (size 3400x3400 channels) of Gammasphere spectrometer](figures/image104.png). ![Detail of Figure 4.9](figures/image106.png). ![Original spectrum of Co56 before continuum decomposition](figures/image108.png). ![Original spectrum of Co56 after continuum decomposition](figures/image110.png). ## 2-DIMENSIONAL SPECTRA. We have extended the method of Gold deconvolution also for; 2-dimensional data. Again, the goal of the deconvolution methods is to; improve the resolution in the spectrum and to decompose multiplets. The method of optimized 2-dimensional deconvolution is described in details in [8]. Mathematical formulation of 2-dimensional convolution system is as; follows:. $$ y(i_1,i_2) = \sum_{k_1=0}^{N_1-1}\sum_{k_2=0}^{N_2-1}h(i_1-k_1,i_2-k_2)x(k_1,k_2), i_1=0,1,2,...,N_1-1, i_2=0,1,2,...,N_2-1 $$. Assuming we know the output; spectrum `y` and the response spectrum `h`, the task is to calculate the matrix `x`. The basic function has the form of. ``` {.cpp}; char *Deconvolution2(float **source,; const float **resp,; int sizex,; int sizey,; int niter);; ```. This function calculates deconvolution from the source spectrum according to; the response spectrum. The result is placed in the matrix pointed by the source; pointer. Function parameters:. - **`source`**: pointer to the matrix of the source spectrum; - **`resp`**: pointer to the ma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:32603,extend,extended,32603,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['extend'],['extended']
Modifiability,"ignPacket. ; Memory controlAdd; the possibility to display the memory footprint on workers and master as a; function of the entry processed (workers) or of the merging step; (master). A new button has been added to the PROOF dialog box to; retrieve and display the memory usage. On the workers about 100; measurements are recorded by default; this number can be changed with 'proof->SetParameter(""PROOF_MemLogFreq"", memlogfreq)';Add; the possibility to set upper limits on the virtual memory used by; processes; the session gets firts a warning when it reaches 80% of; the limit, and then processing is stopped whenit exceeds 95% of the; limit, sending back the results. Also, the memory footprint is notified; when the session is terminated. The limit in MBs is set by the; environment variable ""ROOTPROOFASSOFT"". An hard limit can be set via the; env ""ROOTPROOFASHARD"" (also in MBs): the process is automatically; killed by the system if it reaches this limit. Envs variables for the; PROOF processes can be set using the directive 'xpd.putenv' in the; xrootd config file.Input dataIntroduce the; concept of 'input data': these are objects that are distributed in; optimal way to the workers, which are available via the input list, but; which are not saved in the TQueryResult object. These are meant for big; objects whic can create a big overload when distributed via the; standard input list (which should mostly be used for job control; parameters).  To add an input-data object just use; TProof::AddInputData(TObject *); if the input-data objects are in a; file you can use TProof::SetInputDataFile(const char *file); the final; set of input-data objects is assembled from the objects added via; AddInputData and those found in the file defined bySetInputDataFile.  . Improvements:. More; complete set of tests in test/stressProof . To run with PROOF-Lite pass; the argument 'lite' as master URL, e.g. './stressProof lite'.Possibility; to control on the client via rc variable the location of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html:3085,variab,variables,3085,proof/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html,2,['variab'],['variables']
Modifiability,"igned to eliminate unreachable internal globals from the; program. It uses an aggressive algorithm, searching out globals that are known; to be alive. After it finds all of the globals which are needed, it deletes; whatever is left over. This allows it to delete recursive chunks of the; program which are unreachable. ``globalopt``: Global Variable Optimizer; ----------------------------------------. This pass transforms simple global variables that never have their address; taken. If obviously true, it marks read/write globals as constant, deletes; variables only stored to, etc. ``gvn``: Global Value Numbering; -------------------------------. This pass performs global value numbering to eliminate fully and partially; redundant instructions. It also performs redundant load elimination. .. _passes-indvars:. ``indvars``: Canonicalize Induction Variables; ---------------------------------------------. This transformation analyzes and transforms the induction variables (and; computations derived from them) into simpler forms suitable for subsequent; analysis and transformation. This transformation makes the following changes to each loop with an; identifiable induction variable:. * All loops are transformed to have a *single* canonical induction variable; which starts at zero and steps by one.; * The canonical induction variable is guaranteed to be the first PHI node in; the loop header block.; * Any pointer arithmetic recurrences are raised to use array subscripts. If the trip count of a loop is computable, this pass also makes the following; changes:. * The exit condition for the loop is canonicalized to compare the induction; value against the exit value. This turns loops like:. .. code-block:: c++. for (i = 7; i*i < 1000; ++i). into. .. code-block:: c++. for (i = 0; i != 25; ++i). * Any use outside of the loop of an expression derived from the indvar is; changed to compute the derived value outside of the loop, eliminating the; dependence on the exit value of the ind",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:17689,variab,variables,17689,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['variab'],['variables']
Modifiability,"ignificantly increase a performance, especially when; several clients are connected. ### Better security for THttpServer with webgui. If THttpServer created for use with webgui widgets (RBrowser, RCanvas, REve), it only will; provide access to the widgets via websocket connection - any other kind of requests like root.json; or exe.json will be refused completely. Combined with connection tokens and https protocol,; this makes usage of webgui components in public networks more secure. ### Enabled WLCG Bearer Tokens support in RDavix. Bearer tokens are part of WLCG capability-based infrastructure with capability-based scheme which uses an infrastructure that describes what the bearer is allowed to do as opposed to who that bearer is. Token discovery procedure are developed according WLCG Bearer Token Discovery specification document (https://github.com/WLCG-AuthZ-WG/bearer-token-discovery/blob/master/specification.md). Short overview:. 1. If the `BEARER_TOKEN` environment variable is set, then the value is taken to be the token contents.; 2. If the `BEARER_TOKEN_FILE` environment variable is set, then its value is interpreted as a filename. The contents of the specified file are taken to be the token contents.; 3. If the `XDG_RUNTIME_DIR` environment variable is set, then take the token from the contents of `$XDG_RUNTIME_DIR/bt_u$ID`(this additional location is intended to provide improved security for shared login environments as `$XDG_RUNTIME_DIR` is defined to be user-specific as opposed to a system-wide directory.).; 4. Otherwise, take the token from `/tmp/bt_u$ID`. ## GUI Libraries. ### RBrowser improvements. - central factory methods to handle browsing, editing and drawing of different classes; - simple possibility to extend RBrowser on user-defined classes; - support of web-based geometry viewer; - better support of TTree drawing; - server-side handling of code editor and image viewer widgets; - rbrowser content is fully recovered when web-browser is reloaded; -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:26165,variab,variable,26165,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['variab'],['variable']
Modifiability,"igrate-downstream-fork.py`` are in the; Python script and are expanded on below to a more general recipe::. # Make a repository which will become your final local mirror of the; # monorepo.; mkdir my-monorepo; git -C my-monorepo init. # Add a remote to the monorepo.; git -C my-monorepo remote add upstream/monorepo https://github.com/llvm/llvm-project.git. # Add remotes for each git mirror you use, from upstream as well as; # your local mirror. All projects are listed here but you need only; # import those for which you have local branches.; my_projects=( clang; clang-tools-extra; compiler-rt; debuginfo-tests; libcxx; libcxxabi; libunwind; lld; lldb; llvm; openmp; polly ); for p in ${my_projects[@]}; do; git -C my-monorepo remote add upstream/split/${p} https://github.com/llvm-mirror/${p}.git; git -C my-monorepo remote add local/split/${p} https://my.local.mirror.org/${p}.git; done. # Pull in all the commits.; git -C my-monorepo fetch --all. # Run migrate-downstream-fork to rewrite local branches on top of; # the upstream monorepo.; (; cd my-monorepo; migrate-downstream-fork.py \; refs/remotes/local \; refs/tags \; --new-repo-prefix=refs/remotes/upstream/monorepo \; --old-repo-prefix=refs/remotes/upstream/split \; --source-kind=split \; --revmap-out=monorepo-map.txt; ). # Octopus-merge the resulting local split histories to unify them. # Assumes local work on local split mirrors is on main (and; # upstream is presumably represented by some other branch like; # upstream/main).; my_local_branch=""main"". git -C my-monorepo branch --no-track local/octopus/main \; $(git -C my-monorepo merge-base refs/remotes/upstream/monorepo/main \; refs/remotes/local/split/llvm/${my_local_branch}); git -C my-monorepo checkout local/octopus/${my_local_branch}. subproject_branches=(); for p in ${my_projects[@]}; do; subproject_branch=${p}/local/monorepo/${my_local_branch}; git -C my-monorepo branch ${subproject_branch} \; refs/remotes/local/split/${p}/${my_local_branch}; if [[ ""${p}"" != ""l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:21453,rewrite,rewrite,21453,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['rewrite'],['rewrite']
Modifiability,"igurability of GL event-handler to allow inversion of; controls from scene-centric to viewer-centric. The following rootrc; variables control the behaviour:. OpenGL.EventHandler.ViewerCentricControls: 1; OpenGL.EventHandler.ArrowKeyFactor: -1.0; OpenGL.EventHandler.MouseDragFactor: -1.0; OpenGL.EventHandler.MouseWheelFactor: -1.0. Add camera auto-rotation support. Controls are available from the; ""Extras"" tab of TGLViewer GUI editor. Implemented in class; TGLAutoRotator, can be sub-classed and attached to a viewer via; TGLViewer::SetAutoRotator() method.; Added new overlay element class TGLCameraGuide that shows the; orientation of major axes. To use, call this on a TGLViewer object:. gl_viewer->AddOverlayElement(new TGLCameraGuide(0.9, 0.1, 0.08));. Fix an issue with GL-clip object not being properly updated after; a scene update.; Hide / show menu-bar with a time-out (default 400ms). This can be; adjusted by calling static method:; TGLSAViewer::SetMenuHidingTimeout(200);; To disable menu hiding for Eve viewers, where it is enabled by; default, set the following rootrc variable:; Eve.Viewer.HideMenus: off. EVE; Major changes. Implement central infractructure to allow eve-elements to support; internal multiple selection and highlightning of their sub-parts. Use this in TEveDigitSet and its sub-classes TEveQuadSet and; TEveBoxSet. TEveSecondarySelectable: New secondary base-class for elements; supporting internal multiple selection / highlight.; TEveViewer - Add functions to handle additional mouse-over signals; from TGLViewer.; TEveElement - Add 3 new functions:; virtual TString GetHighlightTooltip();; virtual void UnSelected();; virtual void UnHighlighted();. TEveDigitSet, TEveQuadSet, TEveBoxSet. Sub-class TEveDigitSet from TEveSecondarySelectable.; Implement functions needed for internal selection.; Add common base-class TEveDigitSetGL for quad and box-set GL rendering.; Move anti-flickering controls from TEveQuadSet to TEveDigitSet and; implement it also in TEve",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v528/index.html:2587,variab,variable,2587,graf3d/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v528/index.html,2,['variab'],['variable']
Modifiability,"iguration options reference for MVA method: Fisher. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). Method No Fisher Fisher, Mahalanobis Discrimination method. Configuration options for MVA method :. Configuration options reference for MVA method: PDERS. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). VolumeRangeMode No Adaptive Unscaled, MinMax, RMS, Adap",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:3403,Config,Configuration,3403,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['Config'],['Configuration']
Modifiability,"igure we present; the background, which was added to the synthetic spectrum. One can; observe good coincidence with the estimated background. The method of; the estimation of Compton edge is described in details in [3]. ![Synthetic spectrum with Compton edges](figures/image012.png). The generalized form of the algorithm is implemented in the following function. ``` {.cpp}; char *Background1General(float *spectrum,; int size,; int number_of_iterations,; int direction,; int filter_order,; bool compton);; ```. The meaning of the parameters is as follows:. - **`spectrum`**: pointer to the vector of the source spectrum; - **`size`**: length of spectrum vector; - **`number_of_iterations`**: maximal width of clipping window; - **`direction`**: direction of change of clipping window. Possible values:; - `BACK1_INCREASING_WINDOW`; - `BACK1_DECREASING_WINDOW`; - **`filter_order`**: order of clipping filter. Possible values:; - `BACK1_ORDER2`; - `BACK1_ORDER4`; - `BACK1_ORDER6`; - `BACK1_ORDER8`; - **`compton`**: logical variable whether the estimation of Compton edge will be included. Possible values:; - `BACK1_EXCLUDE_COMPTON`; - `BACK1_INCLUDE_COMPTON`. ## 2-DIMENSIONAL SPECTRA. This basic background estimation function allows to separate useless; spectrum information (2D-continuous background and coincidences of peaks; with background in both dimensions) from peaks. It calculates background; spectrum from the source spectrum. The result is placed in the array; pointed by spectrum pointer. On successful completion it returns 0. On; error it returns a pointer to the string describing error. ``` {.cpp}; char *Background2(float **spectrum,; int sizex,; int sizey,; int number_of_iterations);; ```. Function parameters:. - **`spectrum`**: pointer to the array of the source spectrum; - **`sizex`**: x length of spectrum; - **`sizey`**: y length of spectrum; - **`number_of_iterations`**: width of the clipping window. In Figure 1.6 we present an example of a 2-dimensional spectrum bef",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:4200,variab,variable,4200,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['variab'],['variable']
Modifiability,"igured things:. - a HTCondor cluster capable of running PROOF on Demand. - certificate authentication. - your experiment's software (if available on CernVM-FS). Obtain the CernVM image and contextualization; ---------------------------------------------. ### Download the CernVM bare image. The Virtual Analysis Facility currently works with *CernVM Batch 2.7.1; 64-bit*. This means that you need to have this CernVM image available; either on your local hard disk (in case of a desktop deployment) or in; your cloud's image repository. > For convenience we provide the direct link for the working versions:; >; > - [CernVM 2.7.1 batch 64-bit for; > **KVM**](https://cernvm.cern.ch/releases/19/cernvm-batch-node-2.7.1-2-3-x86_64.hdd.gz); >; > - [CernVM 2.7.1 batch 64-bit for; > **Xen**](https://cernvm.cern.ch/releases/19/cernvm-batch-node-2.7.1-2-3-x86_64.ext3.gz); >; > Images are gzipped. In most cases you'll need to gunzip them before; > registering to your image repository. ### Create VM configuration profiles. CernVM images are base images supporting boot-time customization via; configuration profiles called ""contexts"". Context creation can be; performed through the [CernVM Online](https://cernvm-online.cern.ch/); website. The site is immediately accessible if you have a CERN account. Go to your [CernVM Online; Dashboard](https://cernvm-online.cern.ch/dashboard), click on the; **Create new context...** dropdown and select **Virtual Analysis Facility; node**. There's only a few parameters to configure. Context name; : A name for your context (such as *VAF Master for ATLAS*). Any name; will work. Role; : Use this to configure either a *master* or a *slave*. VAF master (only available when configuring a slave); : IP address or FQDN of the Virtual Analysis Facility master. Auth method; : Choose between *ALICE LDAP* (useful only for ALICE users) or *Pool; accounts* (good for authenticating all the other Grid users). Num. pool accounts (only available when using pool accounts a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md:1631,config,configuration,1631,proof/doc/confman/DeployVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md,1,['config'],['configuration']
Modifiability,"ihood calculation: `LikelihoodWrapper` and `LikelihoodGradientWrapper`.; These are used by the `RooAbsMinimizerFcn` implementation `MinuitFcnGrad` which expects them to, respectively, provide likelihood and likelihood gradient values for use by `Minuit2` in fitting the pdf to the dataset. The `Wrapper`s can be implemented for different kinds of algorithms, or with different kinds of optimization ""back-ends"" in mind.; One implementation of each is ready for use in `RooFit` currently:. 1. `LikelihoodSerial` is more or less simply a rewrite of the existing serial calculation of a `RooNLLVar`.; 2. `LikelihoodGradientJob` calculates the partial derivatives or the gradient in parallel on multiple CPUs/cores, based on `RooFit::MultiProcess`, which is a fork-based multi-processing task execution framework with dynamic load balancing. Other possible implementations could use the GPU or external tools like TensorFlow. The coupling of all these classes to `RooMinimizer` is made via the `MinuitFcnGrad` class, which owns the `Wrappers` that calculate the likelihood components. Note: a second `LikelihoodWrapper` class called `LikelihoodJob` is also available.; This class emulates the existing `NumCPU(>1)` functionality of the `RooAbsTestStatistic` tree, which is implemented based on `RooRealMPFE`.; This class is not yet thoroughly tested and should not be considered production ready. ### Usage example: `MultiProcess` enabled parallel gradient calculator. The main selling point of using `RooFit::TestStatistics` from a performance point of view is the implementation of the `RooFit::MultiProcess` based `LikelihoodGradientJob` calculator class.; To use it, one should create a `RooMinimizer` using the new constructor that takes a `RooAbsL`-based likelihood instead of a `RooAbsReal`. Taking any of the above created `likelihood` objects (as long as they are in a `std::shared_ptr`), we can create a `RooMinimizer` with parallel gradient calculation using:; ``` {.cpp}; std::shared_ptr<RooAb",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md:7522,coupling,coupling,7522,roofit/doc/developers/test_statistics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md,1,['coupling'],['coupling']
Modifiability,ilable for use in tailoring; rf303_conditional.C - Use of tailored p.d.f as conditional p.d.fs.s; rf304_uncorrprod.C - Simple uncorrelated multi-dimensional p.d.f.s; rf305_condcorrprod.C - Multi-dimensional p.d.f.s with conditional p.d.fs in product; rf306_condpereventerrors.C - Complete example with use of conditional p.d.f. with per-event errors; rf307_fullpereventerrors.C -Complete example with use of full p.d.f. with per-event errors; rf308_normintegration2d.C - Examples on normalization of p.d.f.s in more than one dimension; rf309_ndimplot.C - Making 2 and 3 dimensional plots of p.d.f.s and datasets; rf310_sliceplot.C -Projecting p.d.f and data slices in discrete observables; rf311_rangeplot.C -Projecting p.d.f and data ranges in continuous observables; rf312_multirangefit.C - Performing fits in multiple (disjoint) ranges in one or more dimensions; rf313_paramranges.C - Working with parameterized ranges to define non-rectangular regions; rf314_paramfitrange.C - Working with parameterized ranges in a fit.; rf315_projectpdf.C - Marginizalization of multi-dimensional p.d.f.s through integration; rf316_llratioplot.C - Using the likelihood ratio technique to construct a signal enhanced 1-D projection of a multi-dimensional p.d.f.; ; DATA AND CATEGORIES. rf401_importttreethx.C -Overview of advanced option for importing data from ROOT TTree and THx histograms; rf402_datahandling.C - Tools for manipulation of (un)binned datasets; rf403_weightedevts.C - Using weights in unbinned datasets; rf404_categories.C - Working with RooCategory objects to describe discrete variables; rf405_realtocatfuncs.C - Demonstration of real-->discrete mapping functions; rf406_cattocatfuncs.C - Demonstration of discrete-->discrete (invertable) functions; rf407_latextables.C - Latex printing of lists and sets of RooArgSets; ; ORGANIZATION AND SIMULTANEOUS FITS. rf501_simultaneouspdf.C - Using simultaneous p.d.f.s to describe simultaneous fits to multiple datasets; rf502_wspacewrite.C - Creating,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:3285,parameteriz,parameterized,3285,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,2,['parameteriz'],['parameterized']
Modifiability,"ild the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as; ``getActionType`` to run plugins while still benefitting from; ``-clear-ast-before-backend``. Plugins must make sure not to modify the AST,; otherwise they should run after the main action. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:6983,plugin,plugin,6983,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,6,['plugin'],"['plugin', 'plugins']"
Modifiability,"ild"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:6413,config,configuration,6413,interpreter/llvm-project/clang/www/hacking.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html,2,['config'],['configuration']
Modifiability,"ild; $ ../binutils/configure --enable-gold --enable-plugins --disable-werror; $ make all-gold. That should leave you with ``build/gold/ld-new`` which supports; the ``-plugin`` option. Running ``make`` will additionally build; ``build/binutils/ar`` and ``nm-new`` binaries supporting plugins. Once you're ready to switch to using gold, backup your existing; ``/usr/bin/ld`` then replace it with ``ld-new``. Alternatively, install; in ``/usr/bin/ld.gold`` and use ``-fuse-ld=gold`` as described earlier. Optionally, add ``--enable-gold=default`` to the above configure invocation; to automatically install the newly built gold as the default linker with; ``make install``. * Build the LLVMgold plugin. Run CMake with; ``-DLLVM_BINUTILS_INCDIR=/path/to/binutils/include``. The correct include; path will contain the file ``plugin-api.h``. Usage; =====. You should produce bitcode files from ``clang`` with the option; ``-flto``. This flag will also cause ``clang`` to look for the gold plugin in; the ``lib`` directory under its prefix and pass the ``-plugin`` option to; ``ld``. It will not look for an alternate linker without ``-fuse-ld=gold``,; which is why you otherwise need gold to be the installed system linker in; your path. ``ar`` and ``nm`` also accept the ``-plugin`` option and it's possible to; to install ``LLVMgold.so`` to ``/usr/lib/bfd-plugins`` for a seamless setup.; If you built your own gold, be sure to install the ``ar`` and ``nm-new`` you; built to ``/usr/bin``. Example of link time optimization; ---------------------------------. The following example shows a worked example of the gold plugin mixing LLVM; bitcode and native code. .. code-block:: c. --- a.c ---; #include <stdio.h>. extern void foo1(void);; extern void foo4(void);. void foo2(void) {; printf(""Foo2\n"");; }. void foo3(void) {; foo4();; }. int main(void) {; foo1();; }. --- b.c ---; #include <stdio.h>. extern void foo2(void);. void foo1(void) {; foo2();; }. void foo4(void) {; printf(""Foo4"");; }. .. code-blo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:3206,plugin,plugin,3206,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,2,['plugin'],['plugin']
Modifiability,"ild; * [[#12718](https://github.com/root-project/root/issues/12718)] - A crash when trying to initialise a vector from a >1D numpy array in PyROOT; * [[#12685](https://github.com/root-project/root/issues/12685)] - `TEnum::GetEnum` does NOT process typedefs; * [[#12644](https://github.com/root-project/root/issues/12644)] - Can't find cxxabi.h and build module 'ROOT_Foundation_Stage1_NoRTTI' when building from source on Macos; * [[#12631](https://github.com/root-project/root/issues/12631)] - Unable to build master with external XROOTD; * [[#12621](https://github.com/root-project/root/issues/12621)] - [I/O][RDF] Usage of xrootd from multi-thread event loops runs into severe bottlenecks; * [[#12592](https://github.com/root-project/root/issues/12592)] - [doc] TProfile bin error documentation is not correct; * [[#12591](https://github.com/root-project/root/issues/12591)] - Allow partial enablement of modules; * [[#12527](https://github.com/root-project/root/issues/12527)] - MacOS build fails if configured without cocoa; * [[#12492](https://github.com/root-project/root/issues/12492)] - The problem with building ROOT v6-26-10 in debug mode on ubuntu 20.04; * [[#12230](https://github.com/root-project/root/issues/12230)] - Wrong conversion from Numpy Array to `std.vector` when using the wrong type; * [[#12091](https://github.com/root-project/root/issues/12091)] - TSpline SaveAs not using equidistant and loss of precision; * [[#11924](https://github.com/root-project/root/issues/11924)] - PyROOT: wrong overload resolution for C++ functions from python ; * [[#11901](https://github.com/root-project/root/issues/11901)] - Binary distribution for Ubutu 22.04 is broken (on WSL2); * [[#11750](https://github.com/root-project/root/issues/11750)] - FindXROOTD adds libraries to link against irrespective of xrootd version used; * [[#11746](https://github.com/root-project/root/issues/11746)] - TH2::Fill(const char *namex, const char *namey, Double_t w) doesn't update fTsumwxy; * [[#11743](ht",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:41512,config,configured,41512,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['config'],['configured']
Modifiability,"ilder->CreateLoad(Alloca->getAllocatedType(), Alloca,; VarName.c_str());; Value *NextVar = Builder->CreateFAdd(CurVar, StepVal, ""nextvar"");; Builder->CreateStore(NextVar, Alloca);; ... This code is virtually identical to the code `before we allowed mutable; variables <LangImpl05.html#code-generation-for-the-for-loop>`_. The big difference is that we; no longer have to construct a PHI node, and we use load/store to access; the variable as needed. To support mutable argument variables, we need to also make allocas for; them. The code for this is also pretty simple:. .. code-block:: c++. Function *FunctionAST::codegen() {; ...; Builder->SetInsertPoint(BB);. // Record the function arguments in the NamedValues map.; NamedValues.clear();; for (auto &Arg : TheFunction->args()) {; // Create an alloca for this variable.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());. // Store the initial value into the alloca.; Builder->CreateStore(&Arg, Alloca);. // Add arguments to variable symbol table.; NamedValues[std::string(Arg.getName())] = Alloca;; }. if (Value *RetVal = Body->codegen()) {; ... For each argument, we make an alloca, store the input value to the; function into the alloca, and register the alloca as the memory location; for the argument. This method gets invoked by ``FunctionAST::codegen()``; right after it sets up the entry block for the function. The final missing piece is adding the mem2reg pass, which allows us to; get good codegen once again:. .. code-block:: c++. // Promote allocas to registers.; TheFPM->add(createPromoteMemoryToRegisterPass());; // Do simple ""peephole"" optimizations and bit-twiddling optzns.; TheFPM->add(createInstructionCombiningPass());; // Reassociate expressions.; TheFPM->add(createReassociatePass());; ... It is interesting to see what the code looks like before and after the; mem2reg optimization runs. For example, this is the before/after code; for our recursive fib function. Before the optimization:. .. code-bloc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:16053,variab,variable,16053,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"ile and link. E.g. .. code-block:: console. % clang -flto=thin -O2 file1.c file2.c -c; % clang -flto=thin -O2 file1.o file2.o -o a.out. When using lld-link, the -flto option need only be added to the compile step:. .. code-block:: console. % clang-cl -flto=thin -O2 -c file1.c file2.c; % lld-link /out:a.exe file1.obj file2.obj. As mentioned earlier, by default the linkers will launch the ThinLTO backend; threads in parallel, passing the resulting native object files back to the; linker for the final native link. As such, the usage model is the same as; non-LTO. With gold, if you see an error during the link of the form:. .. code-block:: console. /usr/bin/ld: error: /path/to/clang/bin/../lib/LLVMgold.so: could not load plugin library: /path/to/clang/bin/../lib/LLVMgold.so: cannot open shared object file: No such file or directory. Then either gold was not configured with plugins enabled, or clang; was not built with ``-DLLVM_BINUTILS_INCDIR`` set properly. See; the instructions for the; `LLVM gold plugin <https://llvm.org/docs/GoldPlugin.html#how-to-build-it>`_. Controlling Backend Parallelism; -------------------------------; .. _parallelism:. By default, the ThinLTO link step will launch as many; threads in parallel as there are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-thr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:3532,plugin,plugin,3532,interpreter/llvm-project/clang/docs/ThinLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst,1,['plugin'],['plugin']
Modifiability,"ile store i32 -1, i32* inttoptr (i32 1342341148 to i32*), align 4,; !tbaa; !0. is compiled and optimized to:. movw r0, #32796; mov.w r1, #-1; movt r0, #20480; str r1, [r0]; movw r0, #32796 @ <= this MOVW is not needed, value is there already; movt r0, #20482; str r1, [r0]. //===---------------------------------------------------------------------===//. Improve codegen for select's:; if (x != 0) x = 1; if (x == 1) x = 1. ARM codegen used to look like this:; mov r1, r0; cmp r1, #1; mov r0, #0; moveq r0, #1. The naive lowering select between two different values. It should recognize the; test is equality test so it's more a conditional move rather than a select:; cmp r0, #1; movne r0, #0. Currently this is a ARM specific dag combine. We probably should make it into a; target-neutral one. //===---------------------------------------------------------------------===//. Optimize unnecessary checks for zero with __builtin_clz/ctz. Those builtins; are specified to be undefined at zero, so portable code must check for zero; and handle it as a special case. That is unnecessary on ARM where those; operations are implemented in a way that is well-defined for zero. For; example:. int f(int x) { return x ? __builtin_clz(x) : sizeof(int)*8; }. should just be implemented with a CLZ instruction. Since there are other; targets, e.g., PPC, that share this behavior, it would be best to implement; this in a target-independent way: we should probably fold that (when using; ""undefined at zero"" semantics) to set the ""defined at zero"" bit and have; the code generator expand out the right code. //===---------------------------------------------------------------------===//. Clean up the test/MC/ARM files to have more robust register choices. R0 should not be used as a register operand in the assembler tests as it's then; not possible to distinguish between a correct encoding and a missing operand; encoding, as zero is the default value for the binary encoder.; e.g.,; add r0, r0 // bad; add r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt:20811,portab,portable,20811,interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,2,['portab'],['portable']
Modifiability,ile.; ``PointerAlignment`` is then used only as fallback. .. _DisableFormat:. **DisableFormat** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DisableFormat>`; Disables formatting completely. .. _EmptyLineAfterAccessModifier:. **EmptyLineAfterAccessModifier** (``EmptyLineAfterAccessModifierStyle``) :versionbadge:`clang-format 13` :ref:`¶ <EmptyLineAfterAccessModifier>`; Defines when to put an empty line after access modifiers.; ``EmptyLineBeforeAccessModifier`` configuration handles the number of; empty lines between two access modifiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:61320,config,configuration,61320,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ile: !1, line: 3, type: !12); !16 = !DILocation(line: 3, column: 9, scope: !4); !17 = !DILocalVariable(name: ""Z"", scope: !18, file: !1, line: 5, type: !12); !18 = distinct !DILexicalBlock(scope: !4, file: !1, line: 4, column: 5); !19 = !DILocation(line: 5, column: 11, scope: !18); !20 = !DILocation(line: 6, column: 11, scope: !18); !21 = !DILocation(line: 6, column: 9, scope: !18); !22 = !DILocation(line: 8, column: 9, scope: !4); !23 = !DILocation(line: 8, column: 7, scope: !4); !24 = !DILocation(line: 9, column: 3, scope: !4). This example illustrates a few important details about LLVM debugging; information. In particular, it shows how the ``llvm.dbg.declare`` intrinsic and; location information, which are attached to an instruction, are applied; together to allow a debugger to analyze the relationship between statements,; variable definitions, and the code used to implement the function. .. code-block:: llvm. call void @llvm.dbg.declare(metadata i32* %X, metadata !11, metadata !13), !dbg !14; ; [debug line = 2:7] [debug variable = X]. The first intrinsic ``%llvm.dbg.declare`` encodes debugging information for the; variable ``X``. The metadata ``!dbg !14`` attached to the intrinsic provides; scope information for the variable ``X``. .. code-block:: text. !14 = !DILocation(line: 2, column: 9, scope: !4); !4 = distinct !DISubprogram(name: ""foo"", scope: !1, file: !1, line: 1, type: !5,; isLocal: false, isDefinition: true, scopeLine: 1,; isOptimized: false, retainedNodes: !2). Here ``!14`` is metadata providing `location information; <LangRef.html#dilocation>`_. In this example, scope is encoded by ``!4``, a; `subprogram descriptor <LangRef.html#disubprogram>`_. This way the location; information attached to the intrinsics indicates that the variable ``X`` is; declared at line number 2 at a function level scope in function ``foo``. Now lets take another example. .. code-block:: llvm. call void @llvm.dbg.declare(metadata i32* %Z, metadata !17, metadata !13), !dbg !19; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:16122,variab,variable,16122,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"iler backend, you need to create and modify a few; files. The absolute minimum is discussed here. But to actually use the LLVM; target-independent code generator, you must perform the steps described in the; :doc:`LLVM Target-Independent Code Generator <CodeGenerator>` document. First, you should create a subdirectory under ``lib/Target`` to hold all the; files related to your target. If your target is called ""Dummy"", create the; directory ``lib/Target/Dummy``. In this new directory, create a ``CMakeLists.txt``. It is easiest to copy a; ``CMakeLists.txt`` of another target and modify it. It should at least contain; the ``LLVM_TARGET_DEFINITIONS`` variable. The library can be named ``LLVMDummy``; (for example, see the MIPS target). Alternatively, you can split the library; into ``LLVMDummyCodeGen`` and ``LLVMDummyAsmPrinter``, the latter of which; should be implemented in a subdirectory below ``lib/Target/Dummy`` (for example,; see the PowerPC target). Note that these two naming schemes are hardcoded into ``llvm-config``. Using; any other naming scheme will confuse ``llvm-config`` and produce a lot of; (seemingly unrelated) linker errors when linking ``llc``. To make your target actually do something, you need to implement a subclass of; ``TargetMachine``. This implementation should typically be in the file; ``lib/Target/DummyTargetMachine.cpp``, but any file in the ``lib/Target``; directory will be built and should work. To use LLVM's target independent code; generator, you should do what all current machine backends do: create a; subclass of ``LLVMTargetMachine``. (To create a target from scratch, create a; subclass of ``TargetMachine``.). To get LLVM to actually build and link your target, you need to run ``cmake``; with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=Dummy``. This will build your; target without needing to add it to the list of all the targets. Once your target is stable, you can add it to the ``LLVM_ALL_TARGETS`` variable; located in the main ``CMakeLists",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:6947,config,config,6947,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['config'],['config']
Modifiability,"iler. **LLVM_DISTRIBUTION_COMPONENTS**:STRING; This variable can be set to a semi-colon separated list of LLVM build system; components to install. All LLVM-based tools are components, as well as most; of the libraries and runtimes. Component names match the names of the build; system targets. **LLVM_DISTRIBUTIONS**:STRING; This variable can be set to a semi-colon separated list of distributions. See; the :ref:`Multi-distribution configurations` section above for details on this; and other CMake variables to configure multiple distributions. **LLVM_RUNTIME_DISTRIBUTION_COMPONENTS**:STRING; This variable can be set to a semi-colon separated list of runtime library; components. This is used in conjunction with *LLVM_ENABLE_RUNTIMES* to specify; components of runtime libraries that you want to include in your distribution.; Just like with *LLVM_DISTRIBUTION_COMPONENTS*, component names match the names; of the build system targets. **LLVM_DYLIB_COMPONENTS**:STRING; This variable can be set to a semi-colon separated name of LLVM library; components. LLVM library components are either library names with the LLVM; prefix removed (i.e. Support, Demangle...), LLVM target names, or special; purpose component names. The special purpose component names are:. #. ``all`` - All LLVM available component libraries; #. ``Native`` - The LLVM target for the Native system; #. ``AllTargetsAsmParsers`` - All the included target ASM parsers libraries; #. ``AllTargetsDescs`` - All the included target descriptions libraries; #. ``AllTargetsDisassemblers`` - All the included target dissassemblers libraries; #. ``AllTargetsInfos`` - All the included target info libraries. **LLVM_INSTALL_TOOLCHAIN_ONLY**:BOOL; This option defaults to ``Off``: when set to ``On`` it removes many of the; LLVM development and testing tools as well as component libraries from the; default ``install`` target. Including the development tools is not recommended; for distributions as many of the LLVM tools are only inten",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:12441,variab,variable,12441,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['variab'],['variable']
Modifiability,"ility in LLVM, as well as how to use it. :doc:`LoopTerminology`; A document describing Loops and associated terms as used in LLVM. :doc:`CycleTerminology`; A document describing cycles as a generalization of loops. :doc:`Vectorizers`; This document describes the current status of vectorization in LLVM. :doc:`LinkTimeOptimization`; This document describes the interface between LLVM intermodular optimizer; and the linker and its design. :doc:`GoldPlugin`; How to build your programs with link-time optimization on Linux. :doc:`Remarks`; A reference on the implementation of remarks in LLVM. :doc:`Source Level Debugging with LLVM <SourceLevelDebugging>`; This document describes the design and philosophy behind the LLVM; source-level debugger. :doc:`How to Update Debug Info <HowToUpdateDebugInfo>`; This document specifies how to correctly update debug info in various kinds; of code transformations. :doc:`InstrRefDebugInfo`; This document explains how LLVM uses value tracking, or instruction; referencing, to determine variable locations for debug info in the final; stages of compilation. :doc:`RemoveDIsDebugInfo`; This is a migration guide describing how to move from debug info using; intrinsics such as dbg.value to using the non-instruction DPValue object. :doc:`InstrProfileFormat`; This document explains two binary formats of instrumentation-based profiles. Code Generation; ---------------. :doc:`WritingAnLLVMBackend`; Information on how to write LLVM backends for machine targets. :doc:`CodeGenerator`; The design and implementation of the LLVM code generator. Useful if you are; working on retargetting LLVM to a new architecture, designing a new codegen; pass, or enhancing existing components. :doc:`TableGen <TableGen/index>`; Describes the TableGen tool, which is used heavily by the LLVM code; generator. ==========; GlobalISel; ==========. :doc:`MIRPatterns <GlobalISel/MIRPatterns>`; Describes the design of MIR Patterns and how to use them. ===; JIT; ===. :doc:`MCJITDesig",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst:4277,variab,variable,4277,interpreter/llvm-project/llvm/docs/UserGuides.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst,1,['variab'],['variable']
Modifiability,"ill issue strong and weak write-barrier assignments in the same manner as; objects. ``__weak __block`` Support; --------------------------. Objective-C (and Objective-C++) support the ``__weak`` attribute on ``__block``; variables. Under normal circumstances the compiler uses the Objective-C runtime; helper support functions ``objc_assign_weak`` and ``objc_read_weak``. Both; should continue to be used for all reads and writes of ``__weak __block``; variables:. .. code-block:: c. objc_read_weak(&block->byref_i->forwarding->i). The ``__weak`` variable is stored in a ``_block_byref_foo`` structure and the; ``Block`` has copy and dispose helpers for this structure that call:. .. code-block:: c. _Block_object_assign(&dest->_block_byref_i, src-> _block_byref_i, BLOCK_FIELD_IS_WEAK | BLOCK_FIELD_IS_BYREF);. and:. .. code-block:: c. _Block_object_dispose(src->_block_byref_i, BLOCK_FIELD_IS_WEAK | BLOCK_FIELD_IS_BYREF);. In turn, the ``block_byref`` copy support helpers distinguish between whether; the ``__block`` variable is a ``Block`` or not and should either call:. .. code-block:: c. _Block_object_assign(&dest->_block_byref_i, src->_block_byref_i, BLOCK_FIELD_IS_WEAK | BLOCK_FIELD_IS_OBJECT | BLOCK_BYREF_CALLER);. for something declared as an object or:. .. code-block:: c. _Block_object_assign(&dest->_block_byref_i, src->_block_byref_i, BLOCK_FIELD_IS_WEAK | BLOCK_FIELD_IS_BLOCK | BLOCK_BYREF_CALLER);. for something declared as a ``Block``. A full example follows:. .. code-block:: c. __block __weak id obj = <initialization expression>;; functioncall(^{ [obj somemessage]; });. would translate to:. .. code-block:: c. struct _block_byref_obj {; void *isa; // uninitialized; struct _block_byref_obj *forwarding;; int flags; //refcount;; int size;; void (*byref_keep)(struct _block_byref_i *dst, struct _block_byref_i *src);; void (*byref_dispose)(struct _block_byref_i *);; id captured_obj;; };. void _block_byref_obj_keep(struct _block_byref_voidBlock *dst, struct _block_byref_voi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:20312,variab,variable,20312,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variable']
Modifiability,ime of temporaries in init-captures; Unknown. 1928; NAD; Triviality of deleted special member functions; Unknown. 1929; CD4; template keyword following namespace nested-name-specifier; Unknown. 1930; CD4; init-declarator-list vs member-declarator-list; Unknown. 1931; CD5; Default-constructible and copy-assignable closure types; Unknown. 1932; CD4; Bit-field results of conditional operators; Unknown. 1933; NAD; Implementation limit for initializer-list elements; Unknown. 1934; NAD; Relaxing exception-specification compatibility requirements; Unknown. 1935; CD5; Reuse of placement arguments in deallocation; Unknown. 1936; CD6; Dependent qualified-ids; Unknown. 1937; CD5; Incomplete specification of function pointer from lambda; Unknown. 1938; CD5; Should hosted/freestanding be implementation-defined?; Unknown. 1939; open; Argument conversions to nondeduced parameter types revisited; Not resolved. 1940; CD4; static_assert in anonymous unions; Clang 3.5. 1941; CD4; SFINAE and inherited constructor default arguments; Clang 3.9. 1942; CD4; Incorrect reference to trailing-return-type; Unknown. 1943; CD5; Unspecified meaning of “bit”; Unknown. 1944; open; New C incompatibilities; Not resolved. 1945; open; Friend declarations naming members of class templates in non-templates; Not resolved. 1946; CD4; exception-specifications vs pointer dereference; Unknown. 1947; NAD; Digit separators following non-octal prefix; Clang 3.5. 1948; NAD; exception-specification of replacement global new; Clang 3.5. 1949; CD4; “sequenced after” instead of “sequenced before”; Unknown. 1950; NAD; Restructuring description of ranks of conversion sequences; Unknown. 1951; CD4; Cv-qualification and literal types; Unknown. 1952; CD4; Constant expressions and library undefined behavior; Unknown. 1953; open; Data races and common initial sequence; Not resolved. 1954; tentatively ready; typeid null dereference check in subexpressions; Unknown. 1955; CD4; #elif with invalid controlling expression; Unknown,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:131817,inherit,inherited,131817,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['inherit'],['inherited']
Modifiability,"ime of temporaries; N/A. 444; NAD; Overriding and the generated copy assignment operator; Yes. 445; NAD; Wording issue on friend declarations; Clang 3.2. 446; CD1; Does an lvalue-to-rvalue conversion on the ""?"" operator produce a temporary?; Clang 2.8. 447; CD1; Is offsetof type-dependent?; Yes. 448; C++11; Set of template functions in call with dependent explicit argument; Clang 2.8. 449; NAD; Consistency in use of hyphen with names of ""non"" entities; N/A. 450; CD1; Binding a reference to const to a cv-qualified array rvalue; Yes. 451; CD1; Expressions with invalid results and ill-formedness; Yes. 452; CD1; Wording nit on description of this; Yes. 453; tentatively ready; References may only bind to “valid” objects; Unknown. 454; CD1; When is a definition of a static data member required?; Unknown. 455; NAD; Partial ordering and non-deduced arguments; Unknown. 456; NAD; Is initialized const int or const bool variable a null pointer constant?; Yes. 457; CD1; Wording nit on use of const variables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditionally-supported; N/A. 462; CD3; Lifetime of temporaries bound to comma expressions; Unknown. 463; CD1; reinterpret_cast<T*>(0); N/A. 464; CD1; Wording nit on lifetime of temporaries to which references are bound; N/A. 465; NAD; May constructors of global objects call exit()?; N/A. 466; CD1; cv-qualifiers on pseudo-destructor type; No. 467; NAD; Jump past initialization of local static variable; Yes. 468; CD1; Allow ::template outside of templates; Yes (C++11 onwards). 469; NAD; Const template specializations and reference arguments; No. 470; CD1; Instantiation of members of an explicitly-instantiated class template; Yes. 471; NAD; Conflicting inherited access specifications; Clang 2.8. 472; drafting; Casting across p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:31277,variab,variables,31277,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['variab'],['variables']
Modifiability,"imizations which could decrease *or increase*; precision. Differences in Templates; ------------------------. HLSL uses templates to define builtin types and methods, but disallowed; user-defined templates until HLSL 2021. HLSL also allows omitting empty template; parameter lists when all template parameters are defaulted. This is an ambiguous; syntax in C++, but Clang detects the case and issues a diagnostic. This makes; supporting the case in Clang minimally invasive. Vector Extensions; -----------------. HLSL uses the OpenCL vector extensions, and also provides C++-style constructors; for vectors that are not supported by Clang. Standard Library; ----------------. HLSL does not support the C or C++ standard libraries. Like OpenCL, HLSL; describes its own library of built in types, complex data types, and functions. Unsupported C & C++ Features; ----------------------------. HLSL does not support all features of C and C++. In implementing HLSL in Clang; use of some C and C++ features will produce diagnostics under HLSL, and others; will be supported as language extensions. In general, any C or C++ feature that; can be supported by the DXIL and SPIR-V code generation targets could be treated; as a clang HLSL extension. Features that cannot be lowered to DXIL or SPIR-V,; must be diagnosed as errors. HLSL does not support the following C features:. * Pointers; * References; * ``goto`` or labels; * Variable Length Arrays; * ``_Complex`` and ``_Imaginary``; * C Threads or Atomics (or Obj-C blocks); * ``union`` types `(in progress for HLSL 202x) <https://github.com/microsoft/DirectXShaderCompiler/pull/4132>`_; * Most features C11 and later. HLSL does not support the following C++ features:. * RTTI; * Exceptions; * Multiple inheritance; * Access specifiers; * Anonymous or inline namespaces; * ``new`` & ``delete`` operators in all of their forms (array, placement, etc); * Constructors and destructors; * Any use of the ``virtual`` keyword; * Most features C++11 and later; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:10371,inherit,inheritance,10371,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,1,['inherit'],['inheritance']
Modifiability,"imple `scan-build` would do:. $ intercept-build <your build command> && analyze-build. The major difference is how and when the analyzer is run. The `scan-build`; tool has three distinct model to run the analyzer:. 1. Use compiler wrappers to make actions.; The compiler wrappers does run the real compiler and the analyzer.; This is the default behaviour, can be enforced with `--override-compiler`; flag. 2. Use special library to intercept compiler calls during the build process.; The analyzer run against each modules after the build finished.; Use `--intercept-first` flag to get this model. 3. Use compiler wrappers to intercept compiler calls during the build process.; The analyzer run against each modules after the build finished.; Use `--intercept-first` and `--override-compiler` flags together to get; this model. The 1. and 3. are using compiler wrappers, which works only if the build; process respects the `CC` and `CXX` environment variables. (Some build; process can override these variable as command line parameter only. This case; you need to pass the compiler wrappers manually. eg.: `intercept-build; --override-compiler make CC=intercept-cc CXX=intercept-c++ all` where the; original build command would have been `make all` only.). The 1. runs the analyzer right after the real compilation. So, if the build; process removes removes intermediate modules (generated sources) the analyzer; output still kept. The 2. and 3. generate the compilation database first, and filters out those; modules which are not exists. So, it's suitable for incremental analysis during; the development. The 2. mode is available only on FreeBSD and Linux. Where library preload; is available from the dynamic loader. Not supported on OS X (unless System; Integrity Protection feature is turned off). `intercept-build` command uses only the 2. and 3. mode to generate the; compilation database. `analyze-build` does only run the analyzer against the; captured compiler calls. Known problems; -----",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/README.md:3073,variab,variable,3073,interpreter/llvm-project/clang/tools/scan-build-py/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/README.md,1,['variab'],['variable']
Modifiability,"implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matches Objective-C instance variable declarations. Example matches _enabled; @implementation Foo {; BOOL _enabled;; }; @end. Matcher<Decl>objcMethodDeclMatcher<ObjCMethodDecl>...; Matches Objective-C method declarations. Example matches both declaration and definition of -[Foo method]; @interface Foo; - (void)method;; @end. @implementation Foo; - (void)method {}; @end. Matcher<Decl>objcPropertyDeclMatcher<ObjCPropertyDecl>...; Matches Objective-C property declarations. Example matches enabled; @interface Foo; @property BOOL enabled;; @end. Matcher<Decl>objcProtocolDeclMatcher<ObjCProtocolDecl>...; Matches Objective-C protocol declarations. Example matches FooDelegate; @protocol FooDelegate; @end. Matcher<Decl>parmVarDeclMatcher<ParmVarDecl>...; Matches parameter variable declarations. Given; void f(int x);; parmVarDecl(); matches int x. Matcher<Decl>recordDeclMatcher<RecordDecl>...; Matches class, struct, and union declarations. Example matches X, Z, U, and S; class X;; template<class T> class Z {};; struct S {};; union U {};. Matcher<Decl>staticAssertDeclMatcher<StaticAssertDecl>...; Matches a C++ static_assert declaration. Example:; staticAssertDecl(); matches; static_assert(sizeof(S) == sizeof(int)); in; struct S {; int x;; };; static_assert(sizeof(S) == sizeof(int));. Matcher<Decl>tagDeclMatcher<TagDecl>...; Matches tag declarations. Example matches X, Z, U, S, E; class X;; template<class T> class Z {};; struct S {};; union U {};; enum E {; A, B, C; };. Matcher<Decl>templateTemplateParmDeclMatcher<TemplateTemplateParmDecl>...; Matches template template parameter declarations. Given; template <template <typename> class Z, int N> struct C {};; templateTypeParmDecl(); matches 'Z', but not 'N'. Matcher<Decl>templateTypeParmDeclMatcher<TemplateT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:16447,variab,variable,16447,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['variab'],['variable']
Modifiability,"improved. Now it supports sending RDataFrame tasks to a [Dask](https://dask.org/) scheduler. Through Dask, RDataFrame can be also scaled to a cluster of machines managed through a batch system like HTCondor or Slurm. Here is an example:. ```python; import ROOT; from dask.distributed import Client; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame. # In a Python script the Dask client needs to be initalized in a context; # Jupyter notebooks / Python session don't need this; if __name__ == ""__main__"":; client = Client(""SCHEDULER_ADDRESS""); df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); # Proceed as usual; df.Define(""x"",""someoperation"").Histo1D(""x""); ```. Other notable additions and improvements include:. - Enable triggering multiple distributed computation graphs through `RunGraphs`. This also allows sending both Spark and Dask jobs at the same time through a single function call.; - Greatly reduce distributed tasks processing overhead in TTree-based analyses by refactoring the translation from task metadata to RDataFrame object on the workers.; - Refactor triggering of the computation graph in the distributed tasks, so that it now runs with the Python GIL released. This allows interoperability with frameworks like Dask that run different Python threads along the main processing one.; - Set minimum Python version to use this tool to 3.7. This allows using more modern Python functionality in distributed RDataFrame code and is in line with the Python support provided by Spark and Dask.; - Add support for the following operations:; - `DefinePerSample`; - `HistoND`; - `Redefine`; - Make sure a user-provided `npartitions` parameter to a distributed RDataFrame constructor always takes precedence over the value computed by default.; - Improve support for friend trees in distributed executions, now any kind of friendship layout between the main tree and the friend tree(s) is expected to work.; - Add support for TChain data sources with no tree name an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:11327,refactor,refactoring,11327,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['refactor'],['refactoring']
Modifiability,imumState.h; MinosError.h; Minuit2Minimizer.h; MinuitParameter.h; MnApplication.h; MnConfig.h; MnContours.h; MnCovarianceSqueeze.h; MnCross.h; MnEigen.h; MnFcn.h; MnFumiliMinimize.h; MnFunctionCross.h; MnGlobalCorrelationCoeff.h; MnHesse.h; MnLineSearch.h; MnMachinePrecision.h; MnMatrix.h; MnMatrixfwd.h; MnMigrad.h; MnMinimize.h; MnMinos.h; MnParabola.h; MnParabolaFactory.h; MnParabolaPoint.h; MnParameterScan.h; MnPlot.h; MnPosDef.h; MnPrint.h; MnScan.h; MnSeedGenerator.h; MnSimplex.h; MnStrategy.h; MnTiny.h; MnTraceObject.h; MnUserCovariance.h; MnUserFcn.h; MnUserParameterState.h; MnUserParameters.h; MnUserTransformation.h; MnVectorTransform.h; ModularFunctionMinimizer.h; NegativeG2LineSearch.h; Numerical2PGradientCalculator.h; ParametricFunction.h; ScanBuilder.h; ScanMinimizer.h; SimplexBuilder.h; SimplexMinimizer.h; SimplexParameters.h; SimplexSeedGenerator.h; SinParameterTransformation.h; SqrtLowParameterTransformation.h; SqrtUpParameterTransformation.h; StackAllocator.h; VariableMetricBuilder.h; VariableMetricEDMEstimator.h; VariableMetricMinimizer.h; VectorOuterProduct.h; ). set(MINUIT2_SOURCES; AnalyticalGradientCalculator.cxx; BFGSErrorUpdator.cxx; CombinedMinimumBuilder.cxx; DavidonErrorUpdator.cxx; ExternalInternalGradientCalculator.cxx; FumiliBuilder.cxx; FumiliErrorUpdator.cxx; FumiliGradientCalculator.cxx; FumiliMinimizer.cxx; FumiliStandardChi2FCN.cxx; FumiliStandardMaximumLikelihoodFCN.cxx; HessianGradientCalculator.cxx; InitialGradientCalculator.cxx; LaEigenValues.cxx; LaInnerProduct.cxx; LaInverse.cxx; LaOuterProduct.cxx; LaSumOfElements.cxx; LaVtMVSimilarity.cxx; MPIProcess.cxx; MinimumBuilder.cxx; Minuit2Minimizer.cxx; MnApplication.cxx; MnContours.cxx; MnCovarianceSqueeze.cxx; MnEigen.cxx; MnFcn.cxx; MnFumiliMinimize.cxx; MnFunctionCross.cxx; MnGlobalCorrelationCoeff.cxx; MnHesse.cxx; MnLineSearch.cxx; MnMachinePrecision.cxx; MnMinos.cxx; MnParabolaFactory.cxx; MnParameterScan.cxx; MnPlot.cxx; MnPosDef.cxx; MnPrint.cxx; MnPrintImpl.cxx; MnScan.cxx,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/CMakeLists.txt:2129,Variab,VariableMetricBuilder,2129,math/minuit2/src/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/CMakeLists.txt,1,['Variab'],['VariableMetricBuilder']
Modifiability,"in JITLink, and for others it is provided in cooperation with the; (prototype) ORC runtime. JITLink aims to support the following features, some of which are still under; development:. 1. Cross-process and cross-architecture linking of single relocatable objects; into a target *executor* process. 2. Support for all object format features. 3. Open linker data structures (``LinkGraph``) and pass system. JITLink and ObjectLinkingLayer; ==============================. ``ObjectLinkingLayer`` is ORCs wrapper for JITLink. It is an ORC layer that; allows objects to be added to a ``JITDylib``, or emitted from some higher level; program representation. When an object is emitted, ``ObjectLinkingLayer`` uses; JITLink to construct a ``LinkGraph`` (see :ref:`constructing_linkgraphs`) and; calls JITLink's ``link`` function to link the graph into the executor process. The ``ObjectLinkingLayer`` class provides a plugin API,; ``ObjectLinkingLayer::Plugin``, which users can subclass in order to inspect and; modify ``LinkGraph`` instances at link time, and react to important JIT events; (such as an object being emitted into target memory). This enables many features; and optimizations that were not possible under MCJIT or RuntimeDyld. ObjectLinkingLayer Plugins; --------------------------. The ``ObjectLinkingLayer::Plugin`` class provides the following methods:. * ``modifyPassConfig`` is called each time a LinkGraph is about to be linked. It; can be overridden to install JITLink *Passes* to run during the link process. .. code-block:: c++. void modifyPassConfig(MaterializationResponsibility &MR,; const Triple &TT,; jitlink::PassConfiguration &Config). * ``notifyLoaded`` is called before the link begins, and can be overridden to; set up any initial state for the given ``MaterializationResponsibility`` if; needed. .. code-block:: c++. void notifyLoaded(MaterializationResponsibility &MR). * ``notifyEmitted`` is called after the link is complete and code has been; emitted to the executor pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:2303,plugin,plugin,2303,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['plugin'],['plugin']
Modifiability,"in ROOT we will use the tree produced by the following; “pseudo C++” code:. ``` {.cpp}; void parallel_example() {; TNtuple *nt = new TNtuple(""nt"",""Demo ntuple"",""x:y:z:u:v:w:a:b:c"");; for (Int_t i=0; i<3000; i++) {; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x, s1y, s1z, s2x, s2y, s2z, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, s3y, rnd );; nt->Fill( s2x-1, s2y-1, s2z, s1x+.5, s1y+.5, s1z+.5, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x+1, s1y+1, s1z+1, s3x-2, s3y-2, s3z-2, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, s3x, rnd, s3z );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; }; ```. The data set generated has:. - 9 variables: x, y, z, u, v, w, a, b, c.; - 3000*8 = 24000 events.; - 3 sets of random points distributed on spheres: s1, s2, s3; - Random values (noise): rnd; - The variables a,b,c are almost completely random. The variables a; and c are correlated via the 1st and 3rd coordinates of the 3rd “sphere” s3. The command used to produce the Parallel Coordinates plot is:. ``` {.cpp}; nt->Draw(""x:a:y:b:z:u:c:v:w"","""",""PARA"");; ```. ![Cluttered output produced when all the tree events are plotted.](pictures/para3.png). If the 24000 events are plotted as solid lines and no special techniques; are used to clarify the picture, the result is the previous picture; which is very cluttered and useless. To improve the readability of the; Parallel Coordinates output and to explore interactively the data set,; many techniques are available. We have implemented a few in ROOT. First; of all, in order to show better where the clusters on the various axes; are, a 1D histogram is associated to each axis. These histograms; (one per axis) are filled according to the number of lines passing; through the bins. ![The histogram’s axis can be represented with colors or as bar charts.](pictures/para4.png). These histograms can be represented which colors (get from a pal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:97861,variab,variables,97861,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"in TPaletteAxis drawing - draw label, avoid too large ticks.; 3. Fix error with col drawing - bin with maximum value got wrong color; 4. Test for existing jquery.js, jquery-ui.js and d3.js libraries, reuse when provided; 5. Fix several I/O problems; now one could read files, produced in Geant4; 6. Implement 'e2' drawing option for TH1 class,; use by default 'e' option when TH1 has non-empty fSumw2; 7. Reuse statistic from histogram itself, when no axis selection done; 8. Support log/lin z scale for color drawing; 9. Implement interactive z-scale selection on TPaletteAxis; 10. Allow to redraw item with other draw options (before one should clear drawings); 11. Several improvements in THttpServer user interface - repair hierarchy reload,; hide unsupported context menu entries, status line update. ## Changes in 3.4; 1. Support usage of minimized versions of .js and .css files.; Minimized scripts used by default on web servers.; 2. Implement JSROOT.extend instead of jQuery.extend, reduce; usage of jquery.js in core JSROOT classes; 3. Implement main graphics without jquery at all,; such mode used in `nobrowser` mode.; 4. Provide optional latex drawing with MathJax SVG.; TMathText always drawn with MathJax,; other classes require `mathjax` option in URL; 5. Improve drawing of different text classes, correctly handle; their alignment and scaling, special handling for IE; 6. Fix error with time axes - time offset was not correctly interpreted. ## Changes in 3.3; 1. Use d3.time.scale for display of time scales; 2. Within JSRootCore.js script URL one could specify JSROOT; functionality to be loaded: '2d', '3d', 'io', 'load', 'onload'.; Old method with JSROOT.AssertPrerequisites will also work.; 3. With THttpServer JSROOT now provides simple control functionality.; One could publish commands and execute them from the browser; 4. One could open several ROOT files simultaneously; 5. Add 'simple' layout - drawing uses full space on the right side; 6. Allow to open ROOT files in o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:66445,extend,extend,66445,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['extend'],['extend']
Modifiability,"in a single class and between subclasses and superclasses. .. admonition:: Rationale. The traditional, non-ARC pattern for destroying instance variables is to; destroy them immediately before calling ``[super dealloc]``. Unfortunately,; message sends from the superclass are quite capable of reaching methods in; the subclass, and those methods may well read or write to those instance; variables. Making such message sends from dealloc is generally discouraged,; since the subclass may well rely on other invariants that were broken during; ``dealloc``, but it's not so inescapably dangerous that we felt comfortable; calling it undefined behavior. Therefore we chose to delay destroying the; instance variables to a point at which message sends are clearly disallowed:; the point at which the root class's deallocation routines take over. In most code, the difference is not observable. It can, however, be observed; if an instance variable holds a strong reference to an object whose; deallocation will trigger a side-effect which must be carefully ordered with; respect to the destruction of the super class. Such code violates the design; principle that semantically important behavior should be explicit. A simple; fix is to clear the instance variable manually during ``dealloc``; a more; holistic solution is to move semantically important side-effects out of; ``dealloc`` and into a separate teardown phase which can rely on working with; well-formed objects. .. _arc.misc.autoreleasepool:. ``@autoreleasepool``; --------------------. To simplify the use of autorelease pools, and to bring them under the control; of the compiler, a new kind of statement is available in Objective-C. It is; written ``@autoreleasepool`` followed by a *compound-statement*, i.e. by a new; scope delimited by curly braces. Upon entry to this block, the current state; of the autorelease pool is captured. When the block is exited normally,; whether by fallthrough or directed control flow (such as ``return`` o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:89896,variab,variable,89896,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variable']
Modifiability,"in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockBegin>`; A regular expression matching macros that start a block. .. code-block:: c++. # With:; MacroBlockBegin: ""^NS_MAP_BEGIN|\; NS_TABLE_HEAD$""; MacroBlockEnd: ""^\; NS_MAP_END|\; NS_TABLE_.*_END$"". NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. # Without:; NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. .. _MacroBlockEnd:. **MacroBlockEnd** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockEnd>`; A regular expression matching macros that end a block. .. _Macros:. **Macros** (``List of Strings``) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:84531,config,configuration,84531,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"in configuration: ``Middle``); Align pointer in the middle. .. code-block:: c++. int * a;. .. _QualifierAlignment:. **QualifierAlignment** (``QualifierAlignmentStyle``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierAlignment>`; Different ways to arrange specifiers and qualifiers (e.g. const/volatile). .. warning::. Setting ``QualifierAlignment`` to something other than ``Leave``, COULD; lead to incorrect code formatting due to incorrect decisions made due to; clang-formats lack of complete semantic information.; As such extra care should be taken to review code changes made by the use; of this option. Possible values:. * ``QAS_Leave`` (in configuration: ``Leave``); Don't change specifiers/qualifiers to either Left or Right alignment; (default). .. code-block:: c++. int const a;; const int *a;. * ``QAS_Left`` (in configuration: ``Left``); Change specifiers/qualifiers to be left-aligned. .. code-block:: c++. const int a;; const int *a;. * ``QAS_Right`` (in configuration: ``Right``); Change specifiers/qualifiers to be right-aligned. .. code-block:: c++. int const a;; int const *a;. * ``QAS_Custom`` (in configuration: ``Custom``); Change specifiers/qualifiers to be aligned based on ``QualifierOrder``.; With:. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const']. .. code-block:: c++. int const a;; int const *a;. .. _QualifierOrder:. **QualifierOrder** (``List of Strings``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierOrder>`; The order in which the qualifiers appear.; Order is an array that can contain any of the following:. * const; * inline; * static; * friend; * constexpr; * volatile; * restrict; * type. .. note::. it MUST contain 'type'. Items to the left of 'type' will be placed to the left of the type and; aligned in the order supplied. Items to the right of 'type' will be; placed to the right of the type and aligned in the order supplied. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const', 'volatile' ]. .. _Ra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:97321,config,configuration,97321,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"in fitting. See rf606_nllerrorhandling.C for details; RooDataHist - Add new named argument constructor that can collate multiple ROOT THn histgrams into a n+1 dimensional RooDataHist; RooDataSet - Add new named argument constructor that can collate multiple input RooDataSets into a n+1 dimensional RooDataSet.Add createHistogram() method for simplified plotting; RooFitResult - Add new method correlationHist() that returns a labeled TH2 with the contents of the fit correlation matrix; RooFFTConvPdf - Automatically put sampling windows of 'resolution model' p.d.f. centered around zero, even if fit range of convolution observable does not bracket zero. Improve internal efficiency; RooAbsData - Add ability to plot efficiency distribution with correct binomial errors given a RooRealVar and a RooCategory category observable encoding distribution and accept/reject state respectively. See rf701_efficiencyfit.C for details ; RooAbsPdf - Included extended ML term by default in fit if p.d.f is extendable. You can still use Extended() to override default behavior. Do not run MINOS by default anymore if no fit options are provided.; RooProfileLL - Add option to always start minimization from global minimimum (takes more time, but improves reproducibility). Can now profile multi-core paralellized likelihoods as well.; RooRealSumPdf - Enable plotting of component p.d.f.s using same scheme as RooAddPdf, i.e. just use the Components() specified in plotOn().; RooExpensiveObjectCache - New cache manager for sharing and storing of expensive components cached by operator p.d.f.s ; RooMCStudy - Add Silence() argument to constructor to request minimal verbosity during running; RooMinuit - Improve contour() method to return RooPlots rather than drawing TGraphs straight on a canvas; RooWorkspace - Add private expensive object cache to workspace; RooBinningCategory - New real-to-category function that maps values of input RooRealVar to categories with labels that correspond to bins of input R",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:8280,extend,extendable,8280,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,2,['extend'],['extendable']
Modifiability,"in real aspect.; - New graphics style ""BELLE2"" from Martin Ritter. ## 3D Graphics Libraries. ## Geometry Libraries. ### Geometry drawing in web browser. When ROOT compiled with -Droot7=ON flag, one can enable geometry drawing in web browser.; Just apply --web option when starting root like: `root --web tutorials/geom/rootgeom.C`; Not all features of TGeoPainter are supported - only plain drawing of selected TGeoVolume. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. By default, ROOT now falls back to the built-in version of xrootd if it can't find it in the system.; This means that passing `-Dbuiltin_xrootd=ON` is not necessary anymore to build ROOT with xrootd support.; Note that built-in xrootd requires a working network connection. ### Experimental address sanitizer build configuration; Added a build flag `asan` that switches on address sanitizer. It's experimental, so expect problems. For example, when building with gcc,; manipulations in global variables in llvm will abort the build. Such checks can be disabled using environment variables. Check the address; sanitizer documentation or the link below for details. In clang, which allows to blacklist functions, the build will continue. See [core/sanitizer](https://github.com/root-project/root/tree/master/core/sanitizer) for information. ### Optimization of ROOT header files. Many (but intentionally not all) unused includes were removed from ROOT header files. For instance, `#include ""TObjString.h""` and; `#include ""ThreadLocalStorage.h""` were removed from `TClass.h`. Or `#include ""TDatime.h""` was removed from; `TDirectory.h` header file . Or `#include ""TDatime.h""` was removed from `TFile.h`.; This change may cause errors during compilation of ROOT-based code. To fix it, provide missing the includes; where they are really ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:7657,config,configuration,7657,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['config'],['configuration']
Modifiability,"in this case is scaled by the histogram bin width. ### TFormula. * Fix several bugs in the new TFormula class.; * Add as new pre-defined functions: `crystalball`, `breitwigner` and `cheb0,cheb1,...cheb10` for the Chebyshev polynomials. . ## Math Libraries. ### Random numbers. * Move from MathMore to MathCore the class `ROOT::Math::Random`. Make it a new interface class for random number generation. Add interfaces for standard; ROOT random engines, GSL random engines and random engines provided by the C++ standard library (`std::random`).; * Add a new randomengine, `MIXMAX` based on matrix-recursive random number generator from Kostas and George Savvidy. See this [paper](http://dx.doi.org/10.1016/j.cpc.2015.06.003). ## R Interface. Apply several improvements in the interface to R, allowing to use R functions within ROOT.; See more at the [ROOT-R User Guide](http://oproject.org/tiki-index.php?page=ROOT%20R%20Users%20Guide). . ## TMVA. Add new TMVA plug-in based on R and Python (using Scikit-Learn) ; * See the [RMVA Web page](http://oproject.org/tiki-index.php?page=RMVA) for a detailed description of the new TMVA method based on R; * See the [PyMVA Web page](http://oproject.org/tiki-index.php?page=PyMVA) for detailed description of the machine learning methods added in TMVA and based on the Python Scikit-Learn package. ## RooFit Libraries; . ## 2D Graphics Libraries. ### THistPainter. Improve the algorithm to compute the lower limit of an axis in log scale when its; real lower limit is 0. The problem was reported in ROOT-7414. Using the `COL` option with histograms having some negative bins; the empty bins; (containing 0) are drawn. In some cases one wants to not draw empty bins; (containing 0) of histograms having a negative minimum. The option `1`, used with; the option `COL`, allows to do that. Implement the Log option for `CANDLE` plots as requested; [here](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=20225&p=87006#p87006). ### TTeXDump. From Dmitry Kalinkin (via",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:14082,plug-in,plug-in,14082,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['plug-in'],['plug-in']
Modifiability,"in this process.; Such volumes having shape parameters known only when used have to be; positioned only with **`TGeoManager::Node()` method (see ‘Creating and; Positioning Volumes').**. Other case when shape parameterizations are quite useful is scaling; geometry structures. Imagine that we would like to enlarge/shrink a; detector structure on one or more axes. This happens quite often in real; life and is handled by ""fitting mother"" parameters. This is accomplished; by defining shapes with one or more invalid (negative) parameters. For; instance, defining a box having `dx=10.`, `dy=10.`, and `dz=-1` will not; generate an error but will be interpreted in a different way: A special; volume **`TGeoVolumeMulti`** will be created. Whenever positioned inside; a mother volume, this will create a normal **`TGeoVolume`** object; having as shape a box with `dz` fitting the corresponding `dz `of the; mother shape. Generally, this type of parameterization is used when; positioning volumes in containers having a matching shape, but it works; also for most reasonable combinations. ## Geometry Creation. A given geometry can be built in various ways, but one has to follow; some mandatory steps. Even if we might use some terms that will be; explained later, here are few general rules:. - Volumes need media and shapes in order to be created.; - Both containers and contained volumes must be created before linking; them together, and the relative transformation matrix must be; provided.; - Any volume have to be positioned somewhere otherwise it will not be; considered as part of the geometry.; - Visibility or tracking properties of volumes can be provided both at; build time or after geometry is closed, but global visualization; settings (see section: ""The Drawing Package"") should not be provided; at build time, otherwise the drawing package will be loaded. There is also a list of specific rules:. - Positioned volumes should not extrude their container or intersect; with others within ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:56569,parameteriz,parameterization,56569,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['parameteriz'],['parameterization']
Modifiability,"in two ways:; 1. `LD_PRELOAD`: A micro library `libROOTSanitizerConfig.<dylib|so>` is created with the setup in this folder, and can be found in `<builddir>/lib/`.; Loading it with `LD_PRELOAD` will bring ROOT's default sanitiser config into any non-sanitised executable, e.g. python.; 2. ROOT executables will get the config automatically, using a static version of the config library, `libROOTStaticSanitizerConfig.a`.; All ROOT executables statically link against it, so they start up without reporting lots of unfixable memory leaks (e.g. llvm). #### Small linker magic to get the config symbols into ROOT's executables; When linking a ROOT executable, the setup functions from the sanitiser config library might get ignored, because they are not used in any of our executables.; In `cmake/modules/SetUp{Linux|MacOS}.cmake`, the functions are therefore marked as ""undefined"" for the linker, so it starts copying; them into all ROOT executables.; This way, root.exe, cling, ... can start up with a sane default config. ### Use your own address/leak sanitizer configuration; The default configurations can be overridden using the environment variables `ASAN_OPTIONS` and `LSAN_OPTIONS`. Refer to the; [address sanitizer documentation](https://github.com/google/sanitizers/wiki/AddressSanitizer) or use `ASAN_OPTIONS=help=1` when starting; up a sanitised executable (e.g. `root.exe`). A template for a leak suppression file can be found in `$ROOTSYS/etc/lsan-root.supp`. ## Create your own sanitised executable; ROOT exports a library target called `ROOT::ROOTStaticSanitizerConfig` that can be used to create sanitised executables with ROOT's default; address sanitizer config. Linking against this target will add the above setup functions and also add the address sanitizer flags that; ROOT was built with. It should be sufficient to; - Link all executables against this target; - And have `-fsanitize=address` in the `CXXFLAGS`. ## Use sanitised ROOT libraries from a non-sanitised executable (e.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md:1636,config,config,1636,core/sanitizer/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md,1,['config'],['config']
Modifiability,"in)LTO pipelines, module cloning led to some cases of; miscompilation, and we have moved away from trying to keep bitcode; generation and optimization completely disjoint. Bit-for-bit compatibility is not (and never was) a guarantee, and we reserve; the right to change this at any time. Explicitly, users should not rely on; the produced bitcode or object code to match their non-LTO counterparts; precisely. They will exhibit similar performance characteristics, but may; not be bit-for-bit the same. Internally, the ``.llvm.lto`` section is created by running the; ``EmbedBitcodePass`` after the ``ThinLTOPreLinkDefaultPipeline``. This pass is; responsible for emitting the ``.llvm.lto`` section. Afterwards, the; ``ThinLTODefaultPipeline`` runs and the compiler can emit the fat object file. Limitations; ===========. Linkers; -------. Currently, using LTO with LLVM fat lto objects is supported by LLD and by the; GNU linkers via :doc:`GoldPlugin`. This may change in the future, but; extending support to other linkers isn't planned for now. .. NOTE; For standard linking the fat object files should be usable by any; linker capable of using ELF objects, since the ``.llvm.lto`` section is; marked ``SHF_EXCLUDE``. Supported File Formats; ----------------------. The current implementation only supports ELF files. At time of writing, it is; unclear if it will be useful to support other object file formats like ``COFF``; or ``Mach-O``. Usage; =====. Clang users can specify ``-ffat-lto-objects`` with ``-flto`` or ``-flto=thin``.; Without the ``-flto`` option, ``-ffat-lto-objects`` has no effect. Compile an object file using FatLTO:. .. code-block:: console. $ clang -flto -ffat-lto-objects example.c -c -o example.o. Link using the object code from the fat object without LTO. This turns; ``-ffat-lto-objects`` into a no-op, when ``-fno-lto`` is specified:. .. code-block:: console. $ clang -fno-lto -ffat-lto-objects -fuse-ld=lld example.o. Alternatively, you can omit any references to L",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FatLTO.rst:2471,extend,extending,2471,interpreter/llvm-project/llvm/docs/FatLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FatLTO.rst,1,['extend'],['extending']
Modifiability,"in/sh``). To run ``/bin/sh``, first you specify options; to the shell itself (like ``-x`` which turns on trace output), then you specify; the name of the script to run, then you specify arguments to the script. These; arguments to the script are parsed by the Bourne shell command line option; processor, but are not interpreted as options to the shell itself. Using the; CommandLine library, we would specify this as:. .. code-block:: c++. cl::opt<string> Script(cl::Positional, cl::desc(""<input script>""), cl::init(""-""));; cl::list<string> Argv(cl::ConsumeAfter, cl::desc(""<program arguments>...""));; cl::opt<bool> Trace(""x"", cl::desc(""Enable trace output""));. which automatically provides the help output:. ::. USAGE: spiffysh [options] <input script> <program arguments>... OPTIONS:; -help - display available options (-help-hidden for more); -x - Enable trace output. At runtime, if we run our new shell replacement as ```spiffysh -x test.sh -a -x; -y bar``', the ``Trace`` variable will be set to true, the ``Script`` variable; will be set to ""``test.sh``"", and the ``Argv`` list will contain ``[""-a"", ""-x"",; ""-y"", ""bar""]``, because they were specified after the last positional argument; (which is the script name). There are several limitations to when ``cl::ConsumeAfter`` options can be; specified. For example, only one ``cl::ConsumeAfter`` can be specified per; program, there must be at least one `positional argument`_ specified, there must; not be any `cl::list`_ positional arguments, and the ``cl::ConsumeAfter`` option; should be a `cl::list`_ option. .. _can be changed:; .. _Internal vs External Storage:. Internal vs External Storage; ----------------------------. By default, all command line options automatically hold the value that they; parse from the command line. This is very convenient in the common case,; especially when combined with the ability to define command line options in the; files that use them. This is called the internal storage model. Sometimes, however,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:32325,variab,variable,32325,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,2,['variab'],['variable']
Modifiability,"in; ``argmem: write``. ``dead_on_unwind``; At a high level, this attribute indicates that the pointer argument is dead; if the call unwinds, in the sense that the caller will not depend on the; contents of the memory. Stores that would only be visible on the unwind; path can be elided. More precisely, the behavior is as-if any memory written through the; pointer during the execution of the function is overwritten with a poison; value on unwind. This includes memory written by the implicit write implied; by the ``writable`` attribute. The caller is allowed to access the affected; memory, but all loads that are not preceded by a store will return poison. This attribute cannot be applied to return values. .. _gc:. Garbage Collector Strategy Names; --------------------------------. Each function may specify a garbage collector strategy name, which is simply a; string:. .. code-block:: llvm. define void @f() gc ""name"" { ... }. The supported values of *name* includes those :ref:`built in to LLVM; <builtin-gc-strategies>` and any provided by loaded plugins. Specifying a GC; strategy will cause the compiler to alter its output in order to support the; named garbage collection algorithm. Note that LLVM itself does not contain a; garbage collector, this functionality is restricted to generating machine code; which can interoperate with a collector provided externally. .. _prefixdata:. Prefix Data; -----------. Prefix data is data associated with a function which the code; generator will emit immediately before the function's entrypoint.; The purpose of this feature is to allow frontends to associate; language-specific runtime metadata with specific functions and make it; available through the function pointer while still allowing the; function pointer to be called. To access the data for a given function, a program may bitcast the; function pointer to a pointer to the constant's type and dereference; index -1. This implies that the IR symbol points just past the end of; the pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:72078,plugin,plugins,72078,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['plugin'],['plugins']
Modifiability,"in; a single commit, designing away a common source of temporary build breakage.; * Moving code across sub-project (during refactoring for instance) in a single; commit enables accurate `git blame` when tracking code change history.; * Tooling based on `git grep` works natively across sub-projects, allowing to; easier find refactoring opportunities across projects (for example reusing a; datastructure initially in LLDB by moving it into libSupport).; * Having all the sources present encourages maintaining the other sub-projects; when changing API. Finally, the monorepo maintains the property of the existing SVN repository that; the sub-projects move synchronously, and a single revision number (or commit; hash) identifies the state of the development across all projects. .. _build_single_project:. Building a single sub-project; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Even though there is a single source tree, you are not required to build; all sub-projects together. It is trivial to configure builds for a single; sub-project. For example::. mkdir build && cd build; # Configure only LLVM (default); cmake path/to/monorepo; # Configure LLVM and lld; cmake path/to/monorepo -DLLVM_ENABLE_PROJECTS=lld; # Configure LLVM and clang; cmake path/to/monorepo -DLLVM_ENABLE_PROJECTS=clang. .. _git-svn-mirror:. Outstanding Questions; ---------------------. Read-only sub-project mirrors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. With the Monorepo, it is undecided whether the existing single-subproject; mirrors (e.g. https://git.llvm.org/git/compiler-rt.git) will continue to; be maintained. Read/write SVN bridge; ^^^^^^^^^^^^^^^^^^^^^. GitHub supports a read/write SVN bridge for its repositories. However,; there have been issues with this bridge working correctly in the past,; so it's not clear if this is something that will be supported going forward. Monorepo Drawbacks; ------------------. * Using the monolithic repository may add overhead for those contributing to a; standalone sub-project, particula",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:10165,config,configure,10165,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['config'],['configure']
Modifiability,"in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77297,config,configured,77297,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['configured']
Modifiability,"inc` and `src` subdirectories. To see what classes are in a; library, you can check the `<library>/inc` directory for the list of; class definitions. For example, the physics library `libPhysics.so`; contains these class definitions:. ``` {.cpp}; > ls -m $ROOTSYS/math/physics/inc/; LinkDef.h, TFeldmanCousins.h, TGenPhaseSpace.h, TLorentzRotation.h,; TLorentzVector.h, TQuaternion.h, TRobustEstimator.h, TRolke.h,; TRotation.h, TVector2.h, TVector3.h; ```. ## How to Find More Information. website The ROOT web site has up to date documentation. The ROOT; source code automatically generates this documentation, so each class; is explicitly documented on its own web page, which is always up to; date with the latest official release of ROOT. The ROOT Reference Guide web pages can be found at class index; reference guide <https://root.cern/doc/master/classes.html>. Each; page contains a class description, and an explanation of each method.; It shows the class inheritance tree and lets you jump to the parent; class page by clicking on the class name. If you want more details,; you can even see the source. There is a help page available in the; little box on the upper right hand side of each class documentation; page. You can see on the next page what a typical class documentation; web page looks like. The ROOT web site also contains in addition to; this Reference Guide, ""How To's"", a list of publications and example; applications. ### Class Reference Guide. The top of any class reference page lets you jump to different parts; of the documentation. The first line links to the class index and the; index for the current module (a group of classes, often a library).; The second line links to the ROOT homepage and the class overviews.; The third line links the source information - a HTML version of the; source and header file as well as the CVS (the source management; system used for the ROOT development) information of the files. The; last line links the different parts of the cu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:24634,inherit,inheritance,24634,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['inherit'],['inheritance']
Modifiability,"include(GetLibraryName). if(LLVM_ENABLE_LIBXML2); set(imported_libs LibXml2::LibXml2); endif(). add_llvm_component_library(LLVMWindowsManifest; WindowsManifestMerger.cpp. ADDITIONAL_HEADER_DIRS; ${LLVM_MAIN_INCLUDE_DIR}/llvm/WindowsManifest; ${Backtrace_INCLUDE_DIRS}. LINK_LIBS; ${imported_libs}. LINK_COMPONENTS; Support; ). # This block is only needed for llvm-config. When we deprecate llvm-config and; # move to using CMake export, this block can be removed.; if(LLVM_ENABLE_LIBXML2); # CMAKE_BUILD_TYPE is only meaningful to single-configuration generators.; if(CMAKE_BUILD_TYPE); string(TOUPPER ${CMAKE_BUILD_TYPE} build_type); get_property(libxml2_library TARGET LibXml2::LibXml2 PROPERTY LOCATION_${build_type}); endif(); if(NOT libxml2_library); get_property(libxml2_library TARGET LibXml2::LibXml2 PROPERTY LOCATION); endif(); get_library_name(${libxml2_library} libxml2_library); set_property(TARGET LLVMWindowsManifest PROPERTY LLVM_SYSTEM_LIBS ${libxml2_library}); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/CMakeLists.txt:364,config,config,364,interpreter/llvm-project/llvm/lib/WindowsManifest/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/CMakeLists.txt,6,['config'],"['config', 'configuration']"
Modifiability,"include(UseLibtool); endif(). # Override the default target with an environment variable named by LLVM_TARGET_TRIPLE_ENV.; set(LLVM_TARGET_TRIPLE_ENV CACHE STRING ""The name of environment variable to override default target. Disabled by blank.""); mark_as_advanced(LLVM_TARGET_TRIPLE_ENV). if(CMAKE_SYSTEM_NAME MATCHES ""BSD|Linux|OS390""); set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default ON); else(); set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default OFF); endif(); set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR ${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default} CACHE BOOL; ""Enable per-target runtimes directory""). set(LLVM_PROFDATA_FILE """" CACHE FILEPATH; ""Profiling data file to use when compiling in order to improve runtime performance.""). if(LLVM_INCLUDE_TESTS); # Lit test suite requires at least python 3.6; set(LLVM_MINIMUM_PYTHON_VERSION 3.6); else(); # FIXME: it is unknown if this is the actual minimum bound; set(LLVM_MINIMUM_PYTHON_VERSION 3.0); endif(). # Find python before including config-ix, since it needs to be able to search; # for python modules.; find_package(Python3 ${LLVM_MINIMUM_PYTHON_VERSION} REQUIRED; COMPONENTS Interpreter). # All options referred to from HandleLLVMOptions have to be specified; # BEFORE this include, otherwise options will not be correctly set on; # first cmake run; include(config-ix). # By default, we target the host, but this can be overridden at CMake; # invocation time. Except on 64-bit AIX, where the system toolchain; # expect 32-bit objects by default.; if(""${LLVM_HOST_TRIPLE}"" MATCHES ""^powerpc64-ibm-aix""); string(REGEX REPLACE ""^powerpc64"" ""powerpc"" LLVM_DEFAULT_TARGET_TRIPLE_DEFAULT ""${LLVM_HOST_TRIPLE}""); else(); # Only set default triple when native target is enabled.; if (LLVM_NATIVE_TARGET); set(LLVM_DEFAULT_TARGET_TRIPLE_DEFAULT ""${LLVM_HOST_TRIPLE}""); endif(); endif(). set(LLVM_DEFAULT_TARGET_TRIPLE ""${LLVM_DEFAULT_TARGET_TRIPLE_DEFAULT}"" CACHE STRING; ""Default target for which LLVM will generate code."" ); message(STATUS ""LLVM default tar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:37581,config,config-ix,37581,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['config'],['config-ix']
Modifiability,"inconvenient; since the fuzzer needs to report a leak with a reproducer as soon as the leaky; mutation is found. However, running full leak detection after every mutation; is expensive. By default (``-detect_leaks=1``) libFuzzer will count the number of; ``malloc`` and ``free`` calls when executing every mutation.; If the numbers don't match (which by itself doesn't mean there is a leak); libFuzzer will invoke the more expensive LeakSanitizer_; pass and if the actual leak is found, it will be reported with the reproducer; and the process will exit. If your target has massive leaks and the leak detection is disabled; you will eventually run out of RAM (see the ``-rss_limit_mb`` flag). Developing libFuzzer; ====================. LibFuzzer is built as a part of LLVM project by default on macos and Linux.; Users of other operating systems can explicitly request compilation using; ``-DCOMPILER_RT_BUILD_LIBFUZZER=ON`` flag.; Tests are run using ``check-fuzzer`` target from the build directory; which was configured with ``-DCOMPILER_RT_INCLUDE_TESTS=ON`` flag. .. code-block:: console. ninja check-fuzzer. FAQ; =========================. Q. Why doesn't libFuzzer use any of the LLVM support?; -----------------------------------------------------. There are two reasons. First, we want this library to be used outside of the LLVM without users having to; build the rest of LLVM. This may sound unconvincing for many LLVM folks,; but in practice the need for building the whole LLVM frightens many potential; users -- and we want more users to use this code. Second, there is a subtle technical reason not to rely on the rest of LLVM, or; any other large body of code (maybe not even STL). When coverage instrumentation; is enabled, it will also instrument the LLVM support code which will blow up the; coverage set of the process (since the fuzzer is in-process). In other words, by; using more external dependencies we will slow down the fuzzer while the main; reason for it to exist is ext",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:27503,config,configured,27503,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['config'],['configured']
Modifiability,"ind a heap map given the stack address. The missing pieces are a) integration with rewriting (RS4GC) from the; abstract machine model and b) support for optionally decomposing on stack; objects so as not to require heap maps for them. The later is required; for ease of integration with some collectors. Lowering Quality and Representation Overhead; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The current statepoint lowering is known to be somewhat poor. In the very; long term, we'd like to integrate statepoints with the register allocator;; in the near term this is unlikely to happen. We've found the quality of; lowering to be relatively unimportant as hot-statepoints are almost always; inliner bugs. Concerns have been raised that the statepoint representation results in a; large amount of IR being produced for some examples and that this; contributes to higher than expected memory usage and compile times. There's; no immediate plans to make changes due to this, but alternate models may be; explored in the future. Relocations Along Exceptional Edges; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Relocations along exceptional paths are currently broken in ToT. In; particular, there is current no way to represent a rethrow on a path which; also has relocations. See `this llvm-dev discussion; <https://groups.google.com/forum/#!topic/llvm-dev/AE417XjgxvI>`_ for more; detail. Bugs and Enhancements; =====================. Currently known bugs and enhancements under consideration can be; tracked by performing a `bugzilla search; <https://bugs.llvm.org/buglist.cgi?cmdtype=runnamed&namedcmd=Statepoint%20Bugs&list_id=64342>`_; for [Statepoint] in the summary field. When filing new bugs, please; use this tag so that interested parties see the newly filed bug. As; with most LLVM features, design discussions take place on the `Discourse forums <https://discourse.llvm.org>`_ and patches; should be sent to `llvm-commits; <http://lists.llvm.org/mailman/listinfo/llvm-commits>`_ for review.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:36414,enhance,enhancements,36414,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['enhance'],['enhancements']
Modifiability,index/dex/dexp/Dexp.cpp; clang-tools-extra/clangd/index/remote/Client.cpp; clang-tools-extra/clangd/index/remote/Client.h; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.cpp; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.h; clang-tools-extra/clangd/index/remote/monitor/Monitor.cpp; clang-tools-extra/clangd/index/remote/server/Server.cpp; clang-tools-extra/clangd/index/remote/unimplemented/UnimplementedClient.cpp; clang-tools-extra/clangd/indexer/IndexerMain.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.h; clang-tools-extra/clangd/refactor/Rename.h; clang-tools-extra/clangd/refactor/Tweak.cpp; clang-tools-extra/clangd/refactor/Tweak.h; clang-tools-extra/clangd/refactor/tweaks/AddUsing.cpp; clang-tools-extra/clangd/refactor/tweaks/AnnotateHighlightings.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineInline.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineOutline.cpp; clang-tools-extra/clangd/refactor/tweaks/DumpAST.cpp; clang-tools-extra/clangd/refactor/tweaks/ExpandMacro.cpp; clang-tools-extra/clangd/refactor/tweaks/ExtractFunction.cpp; clang-tools-extra/clangd/refactor/tweaks/ObjCLocalizeStringLiteral.cpp; clang-tools-extra/clangd/refactor/tweaks/RemoveUsingNamespace.cpp; clang-tools-extra/clangd/refactor/tweaks/SwapIfBranches.cpp; clang-tools-extra/clangd/support/Cancellation.cpp; clang-tools-extra/clangd/support/Cancellation.h; clang-tools-extra/clangd/support/Context.cpp; clang-tools-extra/clangd/support/Context.h; clang-tools-extra/clangd/support/FileCache.cpp; clang-tools-extra/clangd/support/FileCache.h; clang-tools-extra/clangd/support/Function.h; clang-tools-extra/clangd/support/Logger.cpp; clang-tools-extra/clangd/support/Markup.cpp; clang-tools-extra/clangd/support/Markup.h; clang-tools-extra/clangd/support/MemoryTree.cpp; clang-tools-extra/clangd/support/MemoryTree.h; clang-tools-extra/clangd/support/Path.cpp; clang-tools-extra/clangd/support/Path.h; clang-,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:80505,refactor,refactor,80505,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,"ine namespace declaration. The attribute takes; one or more strings (called tags); the order does not matter. See https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Attributes.html for; details. Tags on an inline namespace are called ""implicit tags"", all other tags are; ""explicit tags"". Mangling; ========. All tags that are ""active"" on an <unqualified-name> are emitted after the; <unqualified-name>, before <template-args> or <discriminator>, and are part of; the same <substitution> the <unqualified-name> is. They are mangled as:. .. code-block:: none. <abi-tags> ::= <abi-tag>* # sort by name; <abi-tag> ::= B <tag source-name>. Example:. .. code-block:: c++. __attribute__((abi_tag(""test""))); void Func();; // gets mangled as: _Z4FuncB4testv (prettified as `Func[abi:test]()`). Active tags; ===========. A namespace does not have any active tags. For types (class / struct / union /; enum), the explicit tags are the active tags. For variables and functions, the active tags are the explicit tags plus any; ""required tags"" which are not in the ""available tags"" set:. .. code-block:: none. derived-tags := (required-tags - available-tags); active-tags := explicit-tags + derived-tags. Required tags for a function; ============================. If a function is used as a local scope for another name, and is part of; another function as local scope, it doesn't have any required tags. If a function is used as a local scope for a guard variable name, it doesn't; have any required tags. Otherwise the function requires any implicit or explicit tag used in the name; for the return type. Example:. .. code-block:: c++. namespace A {; inline namespace B __attribute__((abi_tag)) {; struct C { int x; };; }; }. A::C foo(); // gets mangled as: _Z3fooB1Bv (prettified as `foo[abi:B]()`). Required tags for a variable; ============================. A variable requires any implicit or explicit tag used in its type. Available tags; ==============. All tags used in the prefix and in the template argument",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst:1429,variab,variables,1429,interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,1,['variab'],['variables']
Modifiability,"ined enums are stored as a leaf field with a single subfield named `_0`.; The parent field has no attached columns.; The subfield corresponds to the integer type the underlies the enum.; Unscoped and scoped enums are supported as long as the enum has a dictionary. ### User-defined classes. User-defined classes might behave either as a record or as a collection of elements of a given type.; The behavior depends on whether the class has an associated collection proxy. #### Regular class / struct. User defined C++ classes are supported with the following limitations; - The class must have a dictionary; - All persistent members and base classes must be themselves types with RNTuple I/O support; - Transient members must be marked, e.g. by a `//!` comment; - The class must not be in the `std` namespace; - The class must be empty or splittable (e.g., the class must not provide a custom streamer); - There is no support for polymorphism,; i.e. a field of class `A` cannot store class `B` that derives from `A`; - Virtual inheritance is unsupported. User classes are stored as a record parent field with no attached columns.; Direct base classes and persistent members are stored as subfields with their respective types.; The field name of member subfields is identical to the C++ field name.; The field name of base class subfields are numbered and preceded by a colon (`:`), i.e. `:_0`, `:_1`, ... #### Classes with an associated collection proxy. User classes that specify a collection proxy behave as collections of a given value type. The on-disk representation of non-associative collections is identical to a `std::vector<T>`, using two fields:; - Collection parent field whose principal column is of type `(Split)Index[64|32]`.; - Child field of type `T`, which must be a type with RNTuple I/O support. The on-disk representation of associative collections is identical to a `std::map<K, V>`, using two fields:; - Collection parent field whose principal column is of type `(Split)Index[64",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:45254,inherit,inheritance,45254,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['inherit'],['inheritance']
Modifiability,"ined. Variables are provided; to hold temporary values while processing the body. See `Defvar in a Record; Body`_ for more details. When class ``C2`` inherits from class ``C1``, it acquires all the field; definitions of ``C1``. As those definitions are merged into class ``C2``, any; template arguments passed to ``C1`` by ``C2`` are substituted into the; definitions. In other words, the abstract record fields defined by ``C1`` are; expanded with the template arguments before being merged into ``C2``. .. _def:. ``def`` --- define a concrete record; ------------------------------------. A ``def`` statement defines a new concrete record. .. productionlist::; Def: ""def"" [`NameValue`] `RecordBody`; NameValue: `Value` (parsed in a special mode). The name value is optional. If specified, it is parsed in a special mode; where undefined (unrecognized) identifiers are interpreted as literal; strings. In particular, global identifiers are considered unrecognized.; These include global variables defined by ``defvar`` and ``defset``. A; record name can be the null string. If no name value is given, the record is *anonymous*. The final name of an; anonymous record is unspecified but globally unique. Special handling occurs if a ``def`` appears inside a ``multiclass``; statement. See the ``multiclass`` section below for details. A record can inherit from one or more classes by specifying the; :token:`ParentClassList` clause at the beginning of its record body. All of; the fields in the parent classes are added to the record. If two or more; parent classes provide the same field, the record ends up with the field value; of the last parent class. As a special case, the name of a record can be passed as a template argument; to that record's parent classes. For example:. .. code-block:: text. class A <dag d> {; dag the_dag = d;; }. def rec1 : A<(ops rec1)>;. The DAG ``(ops rec1)`` is passed as a template argument to class ``A``. Notice; that the DAG includes ``rec1``, the record being ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:27884,variab,variables,27884,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['variab'],['variables']
Modifiability,"iner only contains one class of objects, but if it really; contains a mixture, it is possible to ask each object about its class; using the `InheritsFrom` method. For example if `myObject` is a **`TObject`** pointer:. ``` {.cpp}; if (myObject->InheritsFrom(""TParticle"") {; printf(""myObject is a TParticlen"");; }; ```. As the name suggests, this test works even if the object is a subclass; of **`TParticle`**. The member function `IsA()` can be used instead of; `InheritsFrom` to make the test exact. The `InheritsFrom` and `IsA`; methods use the extensive Run Time Type Information (RTTI) available via; the ROOT meta-classes. ### Types of Collections. The ROOT system implements the following basic types of collections:; unordered collections, ordered collections and sorted collections. Next; figure shows the inheritance hierarchy for the primary collection; classes. All primary collection classes derive from the abstract base; class **`TCollection`**. ![The inheritance hierarchy of the primary collection classes](pictures/020001A3.jpg). ### Ordered Collections (Sequences). Sequences are collections that are externally ordered because they; maintain internal elements according to the order in which they were; added. The following sequences are available:. - **`TList`**. - **`THashList`**. - **`TOrdCollection`**. - **`TObjArray`**. - **`TClonesArray`**. The **`TOrdCollection`**, **`TObjArray`** as well as the; **`TClonesArray`** can be sorted using their Sort() member function (for; this, the stored objects must provide a comparison function by; overriding TObject::Compare() and also must enable sorting by overriding; TObject::IsSortable() to return true). Ordered collections all derive; from the abstract base class **`TSeqCollection`**. Sorted collections; are ordered by an internal (automatic) sorting mechanism. The following; sorted collections are available (the stored items must be sortable):. - **`TSortedList`**. - **`TBtree`**. Unordered collections don't maintain th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:3907,inherit,inheritance,3907,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['inherit'],['inheritance']
Modifiability,"ines: 1 vs. ShortNamespaceLines: 0; namespace b { namespace b {; int foo; int foo;; int bar; int bar;; } // namespace b } // namespace b. .. _SkipMacroDefinitionBody:. **SkipMacroDefinitionBody** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <SkipMacroDefinitionBody>`; Do not format macro definition body. .. _SortIncludes:. **SortIncludes** (``SortIncludesOptions``) :versionbadge:`clang-format 3.8` :ref:`¶ <SortIncludes>`; Controls if and how clang-format will sort ``#includes``. Possible values:. * ``SI_Never`` (in configuration: ``Never``); Includes are never sorted. .. code-block:: c++. #include ""B/A.h""; #include ""A/B.h""; #include ""a/b.h""; #include ""A/b.h""; #include ""B/a.h"". * ``SI_CaseSensitive`` (in configuration: ``CaseSensitive``); Includes are sorted in an ASCIIbetical or case sensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""B/A.h""; #include ""B/a.h""; #include ""a/b.h"". * ``SI_CaseInsensitive`` (in configuration: ``CaseInsensitive``); Includes are sorted in an alphabetical or case insensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""a/b.h""; #include ""B/A.h""; #include ""B/a.h"". .. _SortJavaStaticImport:. **SortJavaStaticImport** (``SortJavaStaticImportOptions``) :versionbadge:`clang-format 12` :ref:`¶ <SortJavaStaticImport>`; When sorting Java imports, by default static imports are placed before; non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,; static imports are placed after non-static imports. Possible values:. * ``SJSIO_Before`` (in configuration: ``Before``); Static imports are placed before non-static imports. .. code-block:: java. import static org.example.function1;. import org.example.ClassA;. * ``SJSIO_After`` (in configuration: ``After``); Static imports are placed after non-static imports. .. code-block:: java. import org.example.ClassA;. import static org.example.function1;. .. _SortUsingDeclarations:. **SortUsingDeclarations** (``SortUsingDeclaration",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:109662,config,configuration,109662,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ing an histogram with a function if it is represented as an histogram with zero errors (equivalent to the case of options ""F1"" or ""F2"" in the original HDIFF routine of HBOOK). The bug has been fixed also for the TH2 and TH3 corresponding method. In addition in the case of TH3 use now all 6 axis combinations for estimating the maximum deviation. This is consistent with what is done in the 2D case.; Improved the TH1::Chi2Test for the treatment of empty bins in the histograms. If both histograms have one empty bin, the number of degree of freedom is decreased by one but the test is performed without reporting an error. If only one histogram is having an empty bin it is considered in the comparison. Fixed a bug in preserving the global statistic information after scaling, adding or rebinning the histogram. TH2. Improve TH2::FitFitSliceX and TH2::FitFitSliceY by adding the possibility to return the generated histograms in a TObjArray when the passed pointer is not null. Support also variable bin size histograms. Improve histogram projections. The implementation of TH2::ProjectionX and TH2::ProjectionY has been combined in a single private method. TH3. Fixed a couple of bugs in TH3::Project3DProfile. TProfile and TProfile2D. Add a new option ""W"" in TProfile::ProjectionX and TProfile::ProjectionXY to be able to return the equivalent weighted filled histogram. Its bin content is equal to the profile bin content multiplied by the bin entries. Implement in the TProfile a new option, ""G"" for the bin error. This option can be used, bin by bin, for the combination of measurements y with known gaussian error dy. In this case the profile must be filled; with a weight = 1./dy**2 and the resulting error from the combination (1./sqrt(Sum(1./dy**2) ) ) will be calculated by the profile. . THnSparse. Implement THnSparse::Projection and THnSparse::Merge. New Tutorials. tutorials/hist/sparsehist.C: an example how to use the new multi dim histogram class THnSparse.; tutorials/hist/drawspar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v520/index.html:1821,variab,variable,1821,hist/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v520/index.html,2,['variab'],['variable']
Modifiability,"ing and objects drawing, one can provide number of URL parameters in address string like:. - file - name of the file, which will be automatically open with page loading; - files - array of file names for loading; - json - name of JSON file with stored ROOT object like histogram or canvas; - item - item name to be displayed; - opt - drawing option for the item; - items - array of items name to be displayed; - opts - array of drawing options for the items; - expand - item name(s) to be expanded in the hierarchy browser; - focus - item name to be focused on in the hierarchy browser; - title - set browser title; - dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; - layout - can be 'simple', 'flex', 'tabs', 'gridNxM', 'horizNMK', 'vertNMK'; - browser - layout of the browser 'fix' (default), 'float', 'no' (hidden), 'off' (fully disabled); - nobrowser - do not display file browser (same as browser=no); - float - display floating browser (same as browser=float); - status - configure status line 'no' (default), 'off' (completely disable), 'size'; - inject - name of extra JavaScript to load, see several examples in demo/ subdir; - optimize - drawing optimization 0:off, 1:only large histograms (default), 2:always; - palette - id of default color palette, 51..121 - new ROOT6 palette (default 57); - interactive - enable/disable interactive functions 0 - disable all, 1 - enable all; - noselect - hide file-selection part in the browser (only when file name is specified); - mathjax - use MathJax for latex output; - latex - 'off', 'symbols', 'normal', 'mathjax', 'alwaysmath' control of TLatex processor; - style - name of TStyle object to define global JSROOT style; - toolbar - show canvas tool buttons 'off', 'on' and 'popup', 'left' or 'right' for position, 'vert' for vertical; - divsize - fixed size in pixels for main div element like &dvisize=1500x800; - canvsize - default canvas size in pixels like &canvsize=1200x800; - optstat - ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:2023,config,configure,2023,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['config'],['configure']
Modifiability,"ing and running; arbitrary tests, and to expose a single convenient interface to these; tests. :program:`lit` itself doesn't know how to run tests, rather this logic is; defined by *test suites*. TEST SUITES; ~~~~~~~~~~~. As described in :ref:`test-discovery`, tests are always located inside a *test; suite*. Test suites serve to define the format of the tests they contain, the; logic for finding those tests, and any additional information to run the tests. :program:`lit` identifies test suites as directories containing ``lit.cfg`` or; ``lit.site.cfg`` files (see also :option:`--config-prefix`). Test suites are; initially discovered by recursively searching up the directory hierarchy for; all the input files passed on the command line. You can use; :option:`--show-suites` to display the discovered test suites at startup. Once a test suite is discovered, its config file is loaded. Config files; themselves are Python modules which will be executed. When the config file is; executed, two important global variables are predefined:. **lit_config**. The global **lit** configuration object (a *LitConfig* instance), which defines; the builtin test formats, global configuration parameters, and other helper; routines for implementing test configurations. **config**. This is the config object (a *TestingConfig* instance) for the test suite,; which the config file is expected to populate. The following variables are also; available on the *config* object, some of which must be set by the config and; others are optional or predefined:. **name** *[required]* The name of the test suite, for use in reports and; diagnostics. **test_format** *[required]* The test format object which will be used to; discover and run tests in the test suite. Generally this will be a builtin test; format available from the *lit.formats* module. **test_source_root** The filesystem path to the test suite root. For out-of-dir; builds this is the directory that will be scanned for tests. **test_exec_root** F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:14919,config,config,14919,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,2,"['config', 'variab']","['config', 'variables']"
Modifiability,"ing behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indicates; that the address is not significant, only the content. Constants marked; like this can be merged with other constants if they have the same; initializer. Note that a constant with significant address *can* be; merged with a ``unnamed_addr`` constant, the result being a constant; whose address is significant. If the ``local_unnamed_addr`` attribute is given, the address is known to; not be significant within the module. A global variable may be declared to reside in a target-specific; numbered address space. For targets that support them, address spaces; may affect how optimizations are performed and/or what target; instructions are used to access the variable. The default address space; is zero. The address space qualifier must precede any other attributes. LLVM allows an explicit section to be specified for globals. If the; target",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:31926,variab,variables,31926,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"ing diagnostics; of static analysis tools, such as the Clang Static Analyzer.; `Documentation <https://clang.llvm.org/docs/AttributeReference.html#suppress>`__. - Support ""Deducing this"" (P0847R7). (Worked out of the box); (`af4751738db8 <https://github.com/llvm/llvm-project/commit/af4751738db89a142a8880c782d12d4201b222a8>`__). - Added a new checker ``core.BitwiseShift`` which reports situations where; bitwise shift operators produce undefined behavior (because some operand is; negative or too large).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#core-bitwiseshift-c-c>`__. - Added a new experimental checker ``alpha.core.StdVariant`` to detect variant; accesses via wrong alternatives.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-core-stdvariant-c>`__.; (`#66481 <https://github.com/llvm/llvm-project/pull/66481>`_). - Added a new experimental checker ``alpha.cplusplus.ArrayDelete`` to detect; destructions of arrays of polymorphic objects that are destructed as their; base class (`CERT EXP51-CPP <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-cplusplus-arraydelete-c>`__.; (`0e246bb67573 <https://github.com/llvm/llvm-project/commit/0e246bb67573799409d0085b89902a330998ddcc>`_). - Added a new checker configuration option ``InvalidatingGetEnv=[true,false]`` to; ``security.cert.env.InvalidPtr``. It's not set by default.; If set, ``getenv`` calls won't invalidate previously returned pointers.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__.; (`#67663 <https://github.com/llvm/llvm-project/pull/67663>`_). Crash and bug fixes; ^^^^^^^^^^^^^^^^^^^. - Fixed a crash caused by ``builtin_bit_cast``.; (`#69922 <https://github.com/llvm/llvm-project/issues/69922>`_). - Fixed a ``core.StackAddressEscape`` crash on temporary objec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:70005,polymorphi,polymorphic,70005,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['polymorphi'],['polymorphic']
Modifiability,"ing format; ```; 0 1 2 3; 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | |; + Size +-+; |  |T|; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | Number of Items (for list frames) |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | FRAME PAYLOAD |; | ... |; ```. _Size_: The absolute value gives the (uncompressed) size in bytes of the frame and the payload. _T(ype)_: Can be either 0 for a **record frame** or 1 for a **list frame**.; The type should be interpreted as the sign bit of the size, i.e. negative sizes indicate list frames. _Number of items_: Only used for list frames to indicate the length of the list in the frame payload. File format readers should use the size provided in the frame to seek to the data that follows a frame; instead of summing up the sizes of the elements in the frame.; This approach ensures that frames can be extended in future file format versions; without breaking the deserialization of older readers. ## Locators and Envelope Links. A locator is a generalized way to specify a certain byte range on the storage medium.; For disk-based storage, the locator is just byte offset and byte size.; For other storage systems, the locator contains enough information to retrieve the referenced block,; e.g. in object stores, the locator can specify a certain object ID.; The locator has the following format. ```; 0 1 2 3; 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | Size |T|; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | |; + Offset +; | |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; ```. _Size_: If `T` is zero, the number of bytes to read, i.e. the compressed size of the referenced block.; Otherwise, the 16 least-significant bits, i.e. bits 0:15, specify the size of the locator itself (see below",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:8992,extend,extended,8992,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['extend'],['extended']
Modifiability,"ing information. This is because invariant.group is tied; to the SSA value of the pointer operand. .. code-block:: llvm. %v = load i8, ptr %x, !invariant.group !0; ; if %x mustalias %y then we can replace the above instruction with; %v = load i8, ptr %y. Note that this is an experimental feature, which means that its semantics might; change in the future. '``type``' Metadata; ^^^^^^^^^^^^^^^^^^^. See :doc:`TypeMetadata`. '``associated``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^. The ``associated`` metadata may be attached to a global variable definition with; a single argument that references a global object (optionally through an alias). This metadata lowers to the ELF section flag ``SHF_LINK_ORDER`` which prevents; discarding of the global variable in linker GC unless the referenced object is; also discarded. The linker support for this feature is spotty. For best; compatibility, globals carrying this metadata should:. - Be in ``@llvm.compiler.used``.; - If the referenced global variable is in a comdat, be in the same comdat. ``!associated`` can not express many-to-one relationship. A global variable with; the metadata should generally not be referenced by a function: the function may; be inlined into other functions, leading to more references to the metadata.; Ideally we would want to keep metadata alive as long as any inline location is; alive, but this many-to-one relationship is not representable. Moreover, if the; metadata is retained while the function is discarded, the linker will report an; error of a relocation referencing a discarded section. The metadata is often used with an explicit section consisting of valid C; identifiers so that the runtime can find the metadata section with; linker-defined encapsulation symbols ``__start_<section_name>`` and; ``__stop_<section_name>``. It does not have any effect on non-ELF targets. Example:. .. code-block:: text. $a = comdat any; @a = global i32 1, comdat $a; @b = internal global i32 2, comdat $a, section ""abc"", !as",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:318454,variab,variable,318454,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"ing multiple tests divided into logical blocks, one; or more ``CHECK:`` directives may inadvertently succeed by matching lines in a; later block. While an error will usually eventually be generated, the check; flagged as causing the error may not actually bear any relationship to the; actual source of the problem. In order to produce better error messages in these cases, the ""``CHECK-LABEL:``""; directive can be used. It is treated identically to a normal ``CHECK``; directive except that FileCheck makes an additional assumption that a line; matched by the directive cannot also be matched by any other check present in; ``match-filename``; this is intended to be used for lines containing labels or; other unique identifiers. Conceptually, the presence of ``CHECK-LABEL`` divides; the input stream into separate blocks, each of which is processed independently,; preventing a ``CHECK:`` directive in one block matching a line in another block.; If ``--enable-var-scope`` is in effect, all local variables are cleared at the; beginning of the block. For example,. .. code-block:: llvm. define %struct.C* @C_ctor_base(%struct.C* %this, i32 %x) {; entry:; ; CHECK-LABEL: C_ctor_base:; ; CHECK: mov [[SAVETHIS:r[0-9]+]], r0; ; CHECK: bl A_ctor_base; ; CHECK: mov r0, [[SAVETHIS]]; %0 = bitcast %struct.C* %this to %struct.A*; %call = tail call %struct.A* @A_ctor_base(%struct.A* %0); %1 = bitcast %struct.C* %this to %struct.B*; %call2 = tail call %struct.B* @B_ctor_base(%struct.B* %1, i32 %x); ret %struct.C* %this; }. define %struct.D* @D_ctor_base(%struct.D* %this, i32 %x) {; entry:; ; CHECK-LABEL: D_ctor_base:. The use of ``CHECK-LABEL:`` directives in this case ensures that the three; ``CHECK:`` directives only accept lines corresponding to the body of the; ``@C_ctor_base`` function, even if the patterns match lines found later in; the file. Furthermore, if one of these three ``CHECK:`` directives fail,; FileCheck will recover by continuing to the next block, allowing multiple test; fa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:22373,variab,variables,22373,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variables']
Modifiability,"ing pointers to complete objects; Not resolved. 2787; open; Kind of explicit object copy/move assignment function; Not resolved. 2788; open; Correspondence and redeclarations; Not resolved. 2789; DR; Overload resolution with implicit and explicit object member functions; Clang 18. 2790; open; Aggregate initialization and user-defined conversion sequence; Not resolved. 2791; DR; Unclear phrasing about ""returning to the caller""; Unknown. 2792; DR; Clean up specification of noexcept operator; Unknown. 2793; DR; Block-scope declaration conflicting with parameter name; Unknown. 2794; open; Uniqueness of lambdas in alias templates; Not resolved. 2795; DR; Overlapping empty subobjects with different cv-qualification; Unknown. 2796; DR; Function pointer conversions for relational operators; Unknown. 2797; open; Meaning of ""corresponds"" for rewritten operator candidates; Not resolved. 2798; DR; Manifestly constant evaluation of the static_assert message; Clang 17. 2799; drafting; Inheriting default constructors; Not resolved. 2800; review; Instantiating constexpr variables for potential constant evaluation; Not resolved. 2801; DR; Reference binding with reference-related types; Unknown. 2802; open; Constrained auto and redeclaration with non-abbreviated syntax; Not resolved. 2803; tentatively ready; Overload resolution for reference binding of similar types; Unknown. 2804; open; Lookup for determining rewrite targets; Not resolved. 2805; open; Underspecified selection of deallocation function; Not resolved. 2806; DR; Make a type-requirement a type-only context; Unknown. 2807; DR; Destructors declared consteval; Unknown. 2808; review; Explicit specialization of defaulted special member function; Not resolved. 2809; tentatively ready; An implicit definition does not redeclare a function; Unknown. 2810; tentatively ready; Requiring the absence of diagnostics for templates; Unknown. 2811; tentatively ready; Clarify ""use"" of main; Unknown. 2812; open; Allocation with explicit alig",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:194136,Inherit,Inheriting,194136,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Inherit'],['Inheriting']
Modifiability,"ing the enumeration are not actually retained and; released. .. admonition:: Rationale. This is an optimization made possible because fast enumeration loops promise; to keep the objects retained during enumeration, and the collection itself; cannot be synchronously modified. It can be overridden by explicitly; qualifying the variable with ``__strong``, which will make the variable; mutable again and cause the loop to retain the objects it encounters. .. _arc.misc.blocks:. Blocks; ------. The implicit ``const`` capture variables created when evaluating a block; literal expression have the same ownership semantics as the local variables; they capture. The capture is performed by reading from the captured variable; and initializing the capture variable with that value; the capture variable is; destroyed when the block literal is, i.e. at the end of the enclosing scope. The :ref:`inference <arc.ownership.inference>` rules apply equally to; ``__block`` variables, which is a shift in semantics from non-ARC, where; ``__block`` variables did not implicitly retain during capture. ``__block`` variables of retainable object owner type are moved off the stack; by initializing the heap copy with the result of moving from the stack copy. With the exception of retains done as part of initializing a ``__strong``; parameter variable or reading a ``__weak`` variable, whenever these semantics; call for retaining a value of block-pointer type, it has the effect of a; ``Block_copy``. The optimizer may remove such copies when it sees that the; result is used only as an argument to a call. When a block pointer type is converted to a non-block pointer type (such as; ``id``), ``Block_copy`` is called. This is necessary because a block allocated; on the stack won't get copied to the heap when the non-block pointer escapes.; A block pointer is implicitly converted to ``id`` when it is passed to a; function as a variadic argument. .. _arc.misc.exceptions:. Exceptions; ----------. By default in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:96662,variab,variables,96662,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,['variab'],['variables']
Modifiability,"ing to call ``[super dealloc]`` in such a; method is nearly always a bug. Sometimes, the object is simply trying to; prevent itself from being destroyed, but ``dealloc`` is really far too late; for the object to be raising such objections. Somewhat more legitimately, an; object may have been pool-allocated and should not be deallocated with; ``free``; for now, this can only be supported with a ``dealloc``; implementation outside of ARC. Such an implementation must be very careful; to do all the other work that ``NSObject``'s ``dealloc`` would, which is; outside the scope of this document to describe. The instance variables for an ARC-compiled class will be destroyed at some; point after control enters the ``dealloc`` method for the root class of the; class. The ordering of the destruction of instance variables is unspecified,; both within a single class and between subclasses and superclasses. .. admonition:: Rationale. The traditional, non-ARC pattern for destroying instance variables is to; destroy them immediately before calling ``[super dealloc]``. Unfortunately,; message sends from the superclass are quite capable of reaching methods in; the subclass, and those methods may well read or write to those instance; variables. Making such message sends from dealloc is generally discouraged,; since the subclass may well rely on other invariants that were broken during; ``dealloc``, but it's not so inescapably dangerous that we felt comfortable; calling it undefined behavior. Therefore we chose to delay destroying the; instance variables to a point at which message sends are clearly disallowed:; the point at which the root class's deallocation routines take over. In most code, the difference is not observable. It can, however, be observed; if an instance variable holds a strong reference to an object whose; deallocation will trigger a side-effect which must be carefully ordered with; respect to the destruction of the super class. Such code violates the design; principle",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:89105,variab,variables,89105,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variables']
Modifiability,"ing up your existing ``/usr/bin/ld`` and creating a symbolic link; with ``ln -s /usr/bin/ld.gold /usr/bin/ld``. Alternatively, you can build; with clang's ``-fuse-ld=gold`` or add ``-fuse-ld=gold`` to LDFLAGS, which will; cause the clang driver to invoke ``/usr/bin/ld.gold`` directly. If you have gold installed, check for plugin support by running; ``/usr/bin/ld.gold -plugin``. If it complains ""missing argument"" then; you have plugin support. If not, and you get an error such as ""unknown option"",; then you will either need to build gold or install a version with plugin; support. * Download, configure and build gold with plugin support:. .. code-block:: bash. $ git clone --depth 1 git://sourceware.org/git/binutils-gdb.git binutils; $ mkdir build; $ cd build; $ ../binutils/configure --enable-gold --enable-plugins --disable-werror; $ make all-gold. That should leave you with ``build/gold/ld-new`` which supports; the ``-plugin`` option. Running ``make`` will additionally build; ``build/binutils/ar`` and ``nm-new`` binaries supporting plugins. Once you're ready to switch to using gold, backup your existing; ``/usr/bin/ld`` then replace it with ``ld-new``. Alternatively, install; in ``/usr/bin/ld.gold`` and use ``-fuse-ld=gold`` as described earlier. Optionally, add ``--enable-gold=default`` to the above configure invocation; to automatically install the newly built gold as the default linker with; ``make install``. * Build the LLVMgold plugin. Run CMake with; ``-DLLVM_BINUTILS_INCDIR=/path/to/binutils/include``. The correct include; path will contain the file ``plugin-api.h``. Usage; =====. You should produce bitcode files from ``clang`` with the option; ``-flto``. This flag will also cause ``clang`` to look for the gold plugin in; the ``lib`` directory under its prefix and pass the ``-plugin`` option to; ``ld``. It will not look for an alternate linker without ``-fuse-ld=gold``,; which is why you otherwise need gold to be the installed system linker in; your path. ``ar`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:2506,plugin,plugins,2506,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['plugin'],['plugins']
Modifiability,"ing variables, improves the; modelling, and hence increases the classification and regression; performance. Presently, the Category method works for; classification only, but regression will follow soon. Please; contact us if urgently needed. An example scripts and data files illustrating how the new; Category method is configured and used. Please check the macros; test/TMVAClassificationCategory.C and; test/TMVAClassificationCategoryApplication.C or the; corresponding executables.; Regression functionality for gradient boosted trees using a Huber loss function. Comments. On Input Data: . New TMVA event vector building. The code for splitting the input; data into training and test samples for all classes and the; mixing of those samples to one training and one test sample has; been rewritten completely. The new code is more performant and; has a clearer structure. This fixes several bugs which have been; reported by the TMVA users. On Minimization: . Variables, targets and spectators are now checked if they are; constant. (The execution of TMVA is stopped for variables and; targets, a warning is given for spectators.). On Regression:; ; The analysis type is no longer defined by calling a dedicated; TestAllMethods-member-function of the Factory, but with the; option ""AnalysisType"" in the Factory. The default value is; ""Auto"" where TMVA tries to determine the most suitable analysis; type from the targets and classes the user has defined. Other; values are ""regression"", ""classification"" and ""multiclass"" for; the forthcoming multiclass classification.; Missing regression evaluation plots for training sample were; added. On Cut method:. Removed obsolete option ""FVerySmart"" from Cuts method. On MLP method:; ; Display of convergence information in the progress bar for MLP during training. Creation of animated gifs for MLP convergence monitoring (please; contact authors if you want to do this). On Datasets: . Checks are performed if events are unvoluntarily cut by using a; n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html:1680,Variab,Variables,1680,tmva/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html,1,['Variab'],['Variables']
Modifiability,"ing"" algorithm and bases the; determination of the best node-split during the training; on a random subset of variables only, which is; individually chosen for each split.; ; BDT: Move to TRandom2 for the ""bagging"" algorithm; and throw random weights according to Poisson; statistics. (This way the random weights are closer to a; resampling with replacement algorithm.); ; TMlpANN: Extended options to; TMultilayerPerceptron learning methods. Added example for; reader application: TMVApplication.py; . GUI:. Parallel Coordinates: New GUI button for Parallel; Coordinate plotting.; . Application:. Added Python example for reader application: TMVApplication.py; . Bug fixes:. TMlpANN: fixed crash with ROOT>=5.17 when using; large number of test events; also corrected bias in cross; validation: before the test events were used, which led to; an overestimated performance evaluation in case of a small; number of degrees of freedom; separate now training tree; in two parts for training and validation with configurable; ValidationFraction; ; Cuts: Corrected inconsistency in MethodCuts:; the signal efficiency written out into the weight file does; not correspond to the center of the bin within which the; background rejection is maximised (as before) but to the; lower left edge of it. This is because the cut optimisation; algorithm determines the best background rejection for all; signal efficiencies belonging into a bin. Since the best; background rejection is in general obtained for the lowest; possible signal efficiency, the reference signal efficiency; is the lowest value in the bin.; ; Cuts: Fixed Cuts (optimisaton) method -> event; with smallest value was not included in search for optimal; cut (thanks to Dimitris Varouchas, LAL-Orsay, for helping; us detecting the problem).; ; Genetic Algorithm: Corrected configurable random; seed in GeneticAlgorithm (thanks to David Gonzalez Maline,; CERN, for pointing this out); ; GUI: Fixes in input-variable and MVA plotting:; under/over-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html:4735,config,configurable,4735,tmva/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html,2,['config'],['configurable']
Modifiability,"ing; the option of automatic loading), standard classes are never duplicated, and; there is no additional ""per-module"" overhead.; Thus, eventually (depending on the number of classes bound, across how many; modules, what use fraction, etc.), this initial cost is recouped when; compared to other binders.; As a rule of thumb, if about 10% of classes are used, it takes several; hundreds of bound classes before the cppyy-approach is beneficial.; In High Energy Physics, from which it originated, cppyy is regularly used in; software stacks of many thousands of classes, where this advantage is very; important. `Distributing headers`; ----------------------. cppyy requires C/C++ headers to be available at run-time, which was never a; problem in the developer-centric world from which it originated: software; always had supported C++ APIs already, made available through header files,; and Python simply piggy-backed onto those.; JIT-ing code in those headers, which potentially picked up system headers; that were configured differently, was thus also never a problem.; Or rather, the same problem exists for C++, and configuration for C++ to; resolve potential issues translates transparently to Python. There are only two alternatives: precompile headers into LLVM bitcode and; distribute those or provide a restricted set of headers.; Precompiled headers (and modules) were never designed to be portable and; relocatable, however, thus that may not be the panacea it seems.; A restricted set of headers is some work, but cppyy can operate on abstract; interface classes just fine (including Python-side cross-inheritance). `Large deployment`; ------------------. The single biggest headache in maintaining an installation of Python; extension modules is that Python patch releases can break them.; The two typical solutions are to either restrict the choice of Python; interpreter and version that are supported (common in HPC) or to provide; binaries (wheels) for a large range of different int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:10003,config,configured,10003,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['config'],['configured']
Modifiability,"ingle; Assignment <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_; - the concepts are really quite natural once you grok them. Note that instead of adding virtual methods to the ExprAST class; hierarchy, it could also make sense to use a `visitor; pattern <http://en.wikipedia.org/wiki/Visitor_pattern>`_ or some other; way to model this. Again, this tutorial won't dwell on good software; engineering practices: for our purposes, adding a virtual method is; simplest. The second thing we want is a ""LogError"" method like we used for the; parser, which will be used to report errors found during code generation; (for example, use of an undeclared parameter):. .. code-block:: c++. static std::unique_ptr<LLVMContext> TheContext;; static std::unique_ptr<IRBuilder<>> Builder(TheContext);; static std::unique_ptr<Module> TheModule;; static std::map<std::string, Value *> NamedValues;. Value *LogErrorV(const char *Str) {; LogError(Str);; return nullptr;; }. The static variables will be used during code generation. ``TheContext``; is an opaque object that owns a lot of core LLVM data structures, such as; the type and constant value tables. We don't need to understand it in; detail, we just need a single instance to pass into APIs that require it. The ``Builder`` object is a helper object that makes it easy to generate; LLVM instructions. Instances of the; `IRBuilder <https://llvm.org/doxygen/IRBuilder_8h_source.html>`_; class template keep track of the current place to insert instructions; and has methods to create new instructions. ``TheModule`` is an LLVM construct that contains functions and global; variables. In many ways, it is the top-level structure that the LLVM IR; uses to contain code. It will own the memory for all of the IR that we; generate, which is why the codegen() method returns a raw Value\*,; rather than a unique_ptr<Value>. The ``NamedValues`` map keeps track of which values are defined in the; current scope and what their LLVM representation is. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:3164,variab,variables,3164,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['variab'],['variables']
Modifiability,"ining the needed ROOT version, while all the technicalities to set; up the environment are taken care of inside system-installed scripts,; leaving the user's configuration directory clean and uncluttered. ### Local environment configuration. All the local environment files are loaded at the time of the; client's startup following a certain order. - `common.before`. - `local.before`. - `local.conf`. - `$VafConf_LocalPodLocation/PoD_env.sh`. - `common.after`. - `local.after`. The `common.*` files are sourced both for the local and the remote; environment. This might be convenient to avoid repeating the same; configuration in different places. Each file is looked for first in the system-wide directory and then in; the user's directory. If a configuration file does not exist, it is; silently skipped. The `$VafConf_LocalPodLocation/PoD_env.sh` environment script, provided; with each PROOF on Demand installation, *must exist*: without this file,; the VAF client won't start. ### List of VAF-specific variables. There are some special variables that need to be set in one of the above; configuration files. `$VafConf_LocalPodLocation`; : Full path to the PoD installation on the client. > The `$VafConf_LocalPodLocation` variable must be set before the; > `PoD_env.sh` script gets sourced, so set it either in; > `common.before`, `local.before` or `local.conf`. Since PoD is; > usually system-wide installed, its location is normally; > system-wide set in either the `local.conf` file by the system; > administrator. `$VafConf_RemotePodLocation`; : Full path to the PoD installation on the VAF master node. *Note: this variable should be set in the configuration files for; the local environment despite it refers to a software present on the; remote nodes.*. `$VafConf_PodRms` *(optional)*; : Name of the Resource Management System used for submitting PoD jobs.; Run `pod-submit -l` to see the possible values. If not set, defaults to `condor`. `$VafConf_PodQueue` *(optional)*; : Queue name ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:3307,variab,variables,3307,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['variab'],['variables']
Modifiability,"initial state providing the starting point $\vec{r_0}$; and direction $\vec{n_0}$ .; There are several ways of doing that. ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ```. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ``` {.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ```. A navigator holds several variables describing the current navigation; state: current point position, current direction distance to next; boundary, isotropic safety, pointer to current and next nods as well as; several tracking flags related to volume boundary conditions or other; properties required for track propagation in geometry. Each geometry; query affects these variables, so the only way in testing several; navigation alternatives and remembering the active navigation state is; to use parallel navigation. The following paragraphs will describe the; usage of a single navigator. All setters/getters for navigation state; parameters as well as navigation queries provided by **`TGeoNavigator`**; are interfaced by **`TGeoManager`** and will act on the current; navigator. ### Initializing the Starting Point. The current point (`x,y,z`) known by the modeller is stored as; `Double_t fCurrentPoint[3]` by the navigator class. This array of the; three coordinates is defined in the current global reference system and; can be retrieved any time:. ``` {.cpp}; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; ```. Initializing this point can be done ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:103232,variab,variables,103232,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['variab'],['variables']
Modifiability,"initializer2(). * ``BCIS_AfterColon`` (in configuration: ``AfterColon``); Break constructor initializers after the colon and commas. .. code-block:: c++. Constructor() :; initializer1(),; initializer2(). .. _BreakInheritanceList:. **BreakInheritanceList** (``BreakInheritanceListStyle``) :versionbadge:`clang-format 7` :ref:`¶ <BreakInheritanceList>`; The inheritance list style to use. Possible values:. * ``BILS_BeforeColon`` (in configuration: ``BeforeColon``); Break inheritance list before the colon and after the commas. .. code-block:: c++. class Foo; : Base1,; Base2; {};. * ``BILS_BeforeComma`` (in configuration: ``BeforeComma``); Break inheritance list before the colon and commas, and align; the commas with the colon. .. code-block:: c++. class Foo; : Base1; , Base2; {};. * ``BILS_AfterColon`` (in configuration: ``AfterColon``); Break inheritance list after the colon and commas. .. code-block:: c++. class Foo :; Base1,; Base2; {};. * ``BILS_AfterComma`` (in configuration: ``AfterComma``); Break inheritance list only after the commas. .. code-block:: c++. class Foo : Base1,; Base2; {};. .. _BreakStringLiterals:. **BreakStringLiterals** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <BreakStringLiterals>`; Allow breaking string literals when formatting. In C, C++, and Objective-C:. .. code-block:: c++. true:; const char* x = ""veryVeryVeryVeryVeryVe""; ""ryVeryVeryVeryVeryVery""; ""VeryLongString"";. false:; const char* x =; ""veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString"";. In C# and Java:. .. code-block:: c++. true:; string x = ""veryVeryVeryVeryVeryVe"" +; ""ryVeryVeryVeryVeryVery"" +; ""VeryLongString"";. false:; string x =; ""veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString"";. C# interpolated strings are not broken. In Verilog:. .. code-block:: c++. true:; string x = {""veryVeryVeryVeryVeryVe"",; ""ryVeryVeryVeryVeryVery"",; ""VeryLongString""};. false:; string x =; ""veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString"";. .. _ColumnLimit:. **C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:55712,config,configuration,55712,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,2,"['config', 'inherit']","['configuration', 'inheritance']"
Modifiability,"ink your program with ``-fsanitize=memtag`` flag. This; will only work when targeting AArch64 with MemTag extension. One; possible way to achieve that is to add ``-target; aarch64-linux -march=armv8+memtag`` to compilation flags. Implementation; ==============. See `HardwareAssistedAddressSanitizer`_ for a general overview of a; tag-based approach to memory safety. MemTagSanitizer follows a; similar implementation strategy, but with the tag storage (shadow); provided by the hardware. A quick overview of MTE hardware capabilities:. * Every 16 aligned bytes of memory can be assigned a 4-bit Allocation Tag.; * Every pointer can have a 4-bit Address Tag that is in its most significant byte.; * Most memory access instructions generate an exception if Address Tag != Allocation Tag.; * Special instructions are provided for fast tag manipulation. Stack instrumentation; =====================. Stack-based memory errors are detected by updating Allocation Tag for; each local variable to a random value at the start of its lifetime,; and resetting it to the stack pointer Address Tag at the end of; it. Unallocated stack space is expected to match the Address Tag of; SP; this allows to skip tagging of any variable when memory safety can; be statically proven. Allocating a truly random tag for each stack variable in a large; function may incur significant code size overhead, because it means; that each variable's address is an independent, non-rematerializable; value; thus a function with N local variables will have extra N live; values to keep through most of its life time. For this reason MemTagSanitizer generates at most one random tag per; function, called a ""base tag"". Other stack variables, if there are; any, are assigned tags at a fixed offset from the base. Please refer to `this document; <https://github.com/google/sanitizers/wiki/Stack-instrumentation-with-ARM-Memory-Tagging-Extension-(MTE)>`_; for more details about stack instrumentation. Heap tagging; ============. **Note",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst:1927,variab,variable,1927,interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst,1,['variab'],['variable']
Modifiability,"inkage,; Constant *Initializer = 0, const std::string &Name = """", Module* Parent = 0)``. Create a new global variable of the specified type. If ``isConstant`` is true; then the global variable will be marked as unchanging for the program. The; Linkage parameter specifies the type of linkage (internal, external, weak,; linkonce, appending) for the variable. If the linkage is InternalLinkage,; WeakAnyLinkage, WeakODRLinkage, LinkOnceAnyLinkage or LinkOnceODRLinkage, then; the resultant global variable will have internal linkage. AppendingLinkage; concatenates together all instances (in different translation units) of the; variable into a single variable but is only applicable to arrays. See the; `LLVM Language Reference <LangRef.html#modulestructure>`_ for further details; on linkage types. Optionally an initializer, a name, and the module to put; the variable into may be specified for the global variable as well. * ``bool isConstant() const``. Returns true if this is a global variable that is known not to be modified at; runtime. * ``bool hasInitializer()``. Returns true if this ``GlobalVariable`` has an initializer. * ``Constant *getInitializer()``. Returns the initial value for a ``GlobalVariable``. It is not legal to call; this method if there is no initializer. .. _BasicBlock:. The ``BasicBlock`` class; ------------------------. ``#include ""llvm/IR/BasicBlock.h""``. header source: `BasicBlock.h; <https://llvm.org/doxygen/BasicBlock_8h_source.html>`_. doxygen info: `BasicBlock Class; <https://llvm.org/doxygen/classllvm_1_1BasicBlock.html>`_. Superclass: Value_. This class represents a single entry single exit section of the code, commonly; known as a basic block by the compiler community. The ``BasicBlock`` class; maintains a list of Instruction_\ s, which form the body of the block. Matching; the language definition, the last element of this list of instructions is always; a terminator instruction. In addition to tracking the list of instructions that make up the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:160407,variab,variable,160407,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['variab'],['variable']
Modifiability,"inker behavior. In particular, we start searching on; the LD_LIBRARY_PATH descending to the system libraries. The algorithm is very; efficient because it uses bloom filters[[5]]. This in turn allows ROOT symbol; to be extended to system libraries. ### Module Registration Approaches. The C++ modules system supports /*preloading*/ of all modules at startup time.; The current implementation of loading of C++ modules in clang has an overhead; and is between 40-60 MB depending on the ROOT configuration while there might; be 2x slowdown depending on the workflow. These issues are very likely to be; addressed by the LLVM community in midterm. Preloading of all C++ modules is semantically the closest to C++ behavior.; However, in order to achieve performance ROOT loads them on demand using; a global module index file. It has sufficient information to map a looked up; identifier to the module which contains the corresponding definition. Switching; back to preloading of all C++ modules is done by setting the `ROOT_USE_GMI`; environment variable to false.; ; ### Supported Platforms. We support all platforms with glibc++ versions: 5.2 onward. We support OSX from XCode 10 onward. ## Changes required by the users; * Self-contained header files -- every header file should be able to compile; on its own. For instance, `cat header.h header.h | gcc -fsyntax-only -xc++ -`.; This command concatenates `header.h` twice before compiling it to make sure; it has proper include protectors.; * Enable it in `rootcling` -- rootcling can produce a C++ Modules-aware; dictionary when it is invoked with `-cxxmodule` flag.; * Modularization of external dependencies -- if a header file is not explicitly; nominated as part of a module and it is transitively included in two modules,; both modules contain that header file content. In other words, the header is; duplicated. In turn, this leads to performance regressions. If a dictionary; depends on a header (directly or indirectly) from a external library",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:14493,variab,variable,14493,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['variab'],['variable']
Modifiability,"inlessly. Additionally it should be a simple reference; manual to figure out how stuff works. Quick Start Guide; =================. This section of the manual runs through a simple CommandLine'ification of a; basic compiler tool. This is intended to show you how to jump into using the; CommandLine library in your own program, and show you some of the cool things it; can do. To start out, you need to include the CommandLine header file into your program:. .. code-block:: c++. #include ""llvm/Support/CommandLine.h"". Additionally, you need to add this as the first line of your main program:. .. code-block:: c++. int main(int argc, char **argv) {; cl::ParseCommandLineOptions(argc, argv);; ...; }. ... which actually parses the arguments and fills in the variable declarations. Now that you are ready to support command line arguments, we need to tell the; system which ones we want, and what type of arguments they are. The CommandLine; library uses a declarative syntax to model command line arguments with the; global variable declarations that capture the parsed values. This means that; for every command line option that you would like to support, there should be a; global variable declaration to capture the result. For example, in a compiler,; we would like to support the Unix-standard '``-o <filename>``' option to specify; where to put the output. With the CommandLine library, this is represented like; this:. .. _scalars arguments:; .. _here:. .. code-block:: c++. cl::opt<string> OutputFilename(""o"", cl::desc(""Specify output filename""), cl::value_desc(""filename""));. This declares a global variable ""``OutputFilename``"" that is used to capture the; result of the ""``o``"" argument (first parameter). We specify that this is a; simple scalar option by using the ""``cl::opt``"" template (as opposed to the; ""``cl::list``"" template), and tell the CommandLine library that the data; type that we are parsing is a string. The second and third parameters (which are optional) are used to sp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:4566,variab,variable,4566,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variable']
Modifiability,"inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if they are non-virtual or; can be safely devirtualized. Bifurcation; ^^^^^^^^^^^. ExprEngine::BifurcateCall implements the ``-analyzer-config ipa=dynamic-bifurcate``; mode. When a call is made on an object with imprecise dynamic type information; (RuntimeDefinition::mayHaveOtherDefinitions() evaluates to TRUE), ExprEngine; bifurcates the path and marks the object's region (retrieved from the; RuntimeDefinition object) with a path-sensitive ""mode"" in the ProgramState. Currently, there are 2 modes:. * ``DynamicDispatchModeInlined`` - Models the case where the dynamic type information; of the receiver (MemoryRegion) is assumed to be perfectly constrained so; that a given definition of a method is expected to be the code actually; called. When this mode is set, ExprEngine uses the Decl from; RuntimeDefinition to inline any dynamically dispatched call sent to this; receiver because the function definition is considered to be fully resolved. * ``DynamicDispatchModeConservative`` - Models the case where the dynamic type; information is assumed to be incorrect, for example, implies that the method; definition is overr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:12986,config,config,12986,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['config'],['config']
Modifiability,"inserting the new instruction into the basic block at the location where the; old instruction was, and replacing any uses of the old instruction with the; new instruction. The following example illustrates the replacement of one; ``AllocaInst`` with another. .. code-block:: c++. AllocaInst* instToReplace = ...;; BasicBlock::iterator ii(instToReplace);. ReplaceInstWithInst(instToReplace->getParent(), ii,; new AllocaInst(Type::Int32Ty, 0, ""ptrToReplacedInt""));. Replacing multiple uses of Users and Values; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". You can use ``Value::replaceAllUsesWith`` and ``User::replaceUsesOfWith`` to; change more than one use at a time. See the doxygen documentation for the; `Value Class <https://llvm.org/doxygen/classllvm_1_1Value.html>`_ and `User Class; <https://llvm.org/doxygen/classllvm_1_1User.html>`_, respectively, for more; information. .. _schanges_deletingGV:. Deleting GlobalVariables; ^^^^^^^^^^^^^^^^^^^^^^^^. Deleting a global variable from a module is just as easy as deleting an; Instruction. First, you must have a pointer to the global variable that you; wish to delete. You use this pointer to erase it from its parent, the module.; For example:. .. code-block:: c++. GlobalVariable *GV = .. ;. GV->eraseFromParent();. .. _threading:. Threads and LLVM; ================. This section describes the interaction of the LLVM APIs with multithreading,; both on the part of client applications, and in the JIT, in the hosted; application. Note that LLVM's support for multithreading is still relatively young. Up; through version 2.5, the execution of threaded hosted applications was; supported, but not threaded client access to the APIs. While this use case is; now supported, clients *must* adhere to the guidelines specified below to ensure; proper operation in multithreaded mode. Note that, on Unix-like platforms, LLVM requires the presence of GCC's atomic; intrinsics in order to support threaded operation. If you need a; multithreading-capa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:120538,variab,variable,120538,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['variab'],['variable']
Modifiability,"instance, ``[n(0)] { return ++n; }``). C++14 generic lambdas; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_generic_lambdas)`` or; ``__has_extension(cxx_generic_lambdas)`` to determine if support for generic; (polymorphic) lambdas is enabled; (for instance, ``[] (auto x) { return x + 1; }``). C++14 relaxed constexpr; ^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_relaxed_constexpr)`` or; ``__has_extension(cxx_relaxed_constexpr)`` to determine if variable; declarations, local variable modification, and control flow constructs; are permitted in ``constexpr`` functions. C++14 return type deduction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_return_type_deduction)`` or; ``__has_extension(cxx_return_type_deduction)`` to determine if support; for return type deduction for functions (using ``auto`` as a return type); is enabled. C++14 runtime-sized arrays; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_runtime_array)`` or; ``__has_extension(cxx_runtime_array)`` to determine if support; for arrays of runtime bound (a restricted form of variable-length arrays); is enabled.; Clang's implementation of this feature is incomplete. C++14 variable templates; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_variable_templates)`` or; ``__has_extension(cxx_variable_templates)`` to determine if support for; templated variable declarations is enabled. C11; ---. The features listed below are part of the C11 standard. As a result, all these; features are enabled with the ``-std=c11`` or ``-std=gnu11`` option when; compiling C code. Additionally, because these features are all; backward-compatible, they are available as extensions in all language modes. C11 alignment specifiers; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_alignas)`` or ``__has_extension(c_alignas)`` to determine; if support for alignment specifiers using ``_Alignas`` is enabled. Use ``__has_feature(c_alignof)`` or ``__has_extension(c_alignof)`` to determine; if support for the ``_Alignof`` keyword i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:50972,variab,variable-length,50972,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['variab'],['variable-length']
Modifiability,"instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `lib",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18510,plugin,plugin,18510,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,2,['plugin'],['plugin']
Modifiability,"int non-default options after command line parsing. .. option:: --version. Display the version of the tool. .. option:: @<FILE>. Read command-line options from `<FILE>`. If no input file is specified, :program:`llvm-debuginfo-analyzer`; defaults to read `a.out` and return an error when no input file is found. If `-` is used as the input file, :program:`llvm-debuginfo-analyzer`; reads the input from its standard input stream. .. _attributes_:. ATTRIBUTES; ~~~~~~~~~~; The following options enable attributes given for the printed elements.; The attributes are divided in categories based on the type of data being; added, such as: internal offsets in the binary file, location descriptors,; register names, user source filenames, additional element transformations,; toolchain name, binary file format, etc. .. option:: --attribute=<value[,value,...]>. With **value** being one of the options in the following lists. .. code-block:: text. =all: Include all the below attributes.; =extended: Add low-level attributes.; =standard: Add standard high-level attributes. The following attributes describe the most common information for a; logical element. They help to identify the lexical scope level; the; element visibility across modules (global, local); the toolchain name; that produced the binary file. .. code-block:: text. =global: Element referenced across Compile Units.; =format: Object file format name.; =level: Lexical scope level (File=0, Compile Unit=1).; =local: Element referenced only in the Compile Unit.; =producer: Toolchain identification name. The following attributes describe files and directory names from the; user source code, where the elements are declared or defined; functions; with public visibility across modules. These options allow to map the; elements to their user code location, for cross references purposes. .. code-block:: text. =directories: Directories referenced in the debug information.; =filename: Filename where the element is defined.; =files: Files",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:4808,extend,extended,4808,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['extend'],['extended']
Modifiability,"int() methods:; virtual void Print(Option_t *wildcard="""") const;; virtual void Print(Option_t *wildcard, Option_t *option) const;; with; virtual void Print(Option_t *option="""") const;; virtual void Print(Option_t *option, Int_t recurse) const;; virtual void Print(Option_t *option, const char* wildcard,; Int_t recurse=1) const;; virtual void Print(Option_t *option, TPRegexp& regexp,; Int_t recurse=1) const;. Introduce three new protected methods used to print out collection details.; These are called from the Print() methods and make overriding of what; is printed for a collection / entries easier.; virtual void PrintCollectionHeader(Option_t* option) const;; virtual const char* GetCollectionEntryName(TObject* entry) const;; virtual void PrintCollectionEntry(TObject* entry, Option_t* option,; Int_t recurse) const;. Improve performance of reading TExMap object (50 times faster) using an updated,; slightly larger (16%) on file format for the TExMap object. ACLiC; Fix problem finding rootcint in the --prefix configuration.; Change the naming convention for the temporary files created by ACLiC, instead of randomly named ACLiC now uses:scriptname_scriptextension_ACLiC_function.extension; When ACLiC need to revert to the temp directory for storing the library, it now create the directory; structure under a directory named after the userid. Allow white space in the name of the directory where a script to be compiled by ACLiC resides.; Add optional 5th argument to CompileMacro to allow set the file bit; mode of the directory created.; Avoid looking for Microsoft's link.exe when we already have it (and hence avoid complaining about cygpath when cygwin is not even installed. Meta. Insure that the TClass list of methods is refreshed when new functions are added to the dictionary. TStyle. In TStyle::Reset, the Frame; Fill Color default value did not match the TFrame; Fill Color default value. TSystem. DirName now properly handle; repeated '/'; this allow mkdir(""a/b//c"",true); to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v522/index.html:1128,config,configuration,1128,core/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v522/index.html,2,['config'],['configuration']
Modifiability,"inter to; the right class. Casting to the wrong class will give wrong results and; may well crash the program! Therefore, the user has to be very careful.; Often a container only contains one class of objects, but if it really; contains a mixture, it is possible to ask each object about its class; using the `InheritsFrom` method. For example if `myObject` is a **`TObject`** pointer:. ``` {.cpp}; if (myObject->InheritsFrom(""TParticle"") {; printf(""myObject is a TParticlen"");; }; ```. As the name suggests, this test works even if the object is a subclass; of **`TParticle`**. The member function `IsA()` can be used instead of; `InheritsFrom` to make the test exact. The `InheritsFrom` and `IsA`; methods use the extensive Run Time Type Information (RTTI) available via; the ROOT meta-classes. ### Types of Collections. The ROOT system implements the following basic types of collections:; unordered collections, ordered collections and sorted collections. Next; figure shows the inheritance hierarchy for the primary collection; classes. All primary collection classes derive from the abstract base; class **`TCollection`**. ![The inheritance hierarchy of the primary collection classes](pictures/020001A3.jpg). ### Ordered Collections (Sequences). Sequences are collections that are externally ordered because they; maintain internal elements according to the order in which they were; added. The following sequences are available:. - **`TList`**. - **`THashList`**. - **`TOrdCollection`**. - **`TObjArray`**. - **`TClonesArray`**. The **`TOrdCollection`**, **`TObjArray`** as well as the; **`TClonesArray`** can be sorted using their Sort() member function (for; this, the stored objects must provide a comparison function by; overriding TObject::Compare() and also must enable sorting by overriding; TObject::IsSortable() to return true). Ordered collections all derive; from the abstract base class **`TSeqCollection`**. Sorted collections; are ordered by an internal (automatic) sorting mech",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:3755,inherit,inheritance,3755,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['inherit'],['inheritance']
Modifiability,"inters of interior pointers are not explicitly; tracked and reported. * A different format is used for encoding stack maps. * Safe-point polls are only needed before loop-back edges; and before tail-calls (not needed at function-entry). Custom GC Strategies; ====================. If none of the built in GC strategy descriptions met your needs above, you will; need to define a custom GCStrategy and possibly, a custom LLVM pass to perform; lowering. Your best example of where to start defining a custom GCStrategy; would be to look at one of the built in strategies. You may be able to structure this additional code as a loadable plugin library.; Loadable plugins are sufficient if all you need is to enable a different; combination of built in functionality, but if you need to provide a custom; lowering pass, you will need to build a patched version of LLVM. If you think; you need a patched build, please ask for advice on llvm-dev. There may be an; easy way we can extend the support to make it work for your use case without; requiring a custom build. Collector Requirements; ----------------------. You should be able to leverage any existing collector library that includes the following elements:. #. A memory allocator which exposes an allocation function your compiled; code can call. #. A binary format for the stack map. A stack map describes the location; of references at a safepoint and is used by precise collectors to identify; references within a stack frame on the machine stack. Note that collectors; which conservatively scan the stack don't require such a structure. #. A stack crawler to discover functions on the call stack, and enumerate the; references listed in the stack map for each call site. #. A mechanism for identifying references in global locations (e.g. global; variables). #. If you collector requires them, an LLVM IR implementation of your collectors; load and store barriers. Note that since many collectors don't require; barriers at all, LLVM defaults t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:22248,extend,extend,22248,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['extend'],['extend']
Modifiability,"into it. Each reference to the variable does a reload; from the stack. Also, note that we didn't modify the if/then/else; expression, so it still inserts a PHI node. While we could make an; alloca for it, it is actually easier to create a PHI node for it, so we; still just make the PHI. Here is the code after the mem2reg pass runs:. .. code-block:: llvm. define double @fib(double %x) {; entry:; %cmptmp = fcmp ult double %x, 3.000000e+00; %booltmp = uitofp i1 %cmptmp to double; %ifcond = fcmp one double %booltmp, 0.000000e+00; br i1 %ifcond, label %then, label %else. then:; br label %ifcont. else:; %subtmp = fsub double %x, 1.000000e+00; %calltmp = call double @fib(double %subtmp); %subtmp5 = fsub double %x, 2.000000e+00; %calltmp6 = call double @fib(double %subtmp5); %addtmp = fadd double %calltmp, %calltmp6; br label %ifcont. ifcont: ; preds = %else, %then; %iftmp = phi double [ 1.000000e+00, %then ], [ %addtmp, %else ]; ret double %iftmp; }. This is a trivial case for mem2reg, since there are no redefinitions of; the variable. The point of showing this is to calm your tension about; inserting such blatant inefficiencies :). After the rest of the optimizers run, we get:. .. code-block:: llvm. define double @fib(double %x) {; entry:; %cmptmp = fcmp ult double %x, 3.000000e+00; %booltmp = uitofp i1 %cmptmp to double; %ifcond = fcmp ueq double %booltmp, 0.000000e+00; br i1 %ifcond, label %else, label %ifcont. else:; %subtmp = fsub double %x, 1.000000e+00; %calltmp = call double @fib(double %subtmp); %subtmp5 = fsub double %x, 2.000000e+00; %calltmp6 = call double @fib(double %subtmp5); %addtmp = fadd double %calltmp, %calltmp6; ret double %addtmp. ifcont:; ret double 1.000000e+00; }. Here we see that the simplifycfg pass decided to clone the return; instruction into the end of the 'else' block. This allowed it to; eliminate some branches and the PHI node. Now that all symbol table references are updated to use stack variables,; we'll add the assignment operator. New As",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:19112,variab,variable,19112,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"into portions; of a vector register. Since DWARF stack value entries have a base type and AMDGPU registers are a; vector of dwords, the ability to specify that a base type is a vector is; required. See ``DW_AT_LLVM_vector_size`` in :ref:`amdgpu-dwarf-base-type-entries`. .. _amdgpu-dwarf-operation-to-create-vector-composite-location-descriptions:. 2.10 DWARF Operations to Create Vector Composite Location Descriptions; ----------------------------------------------------------------------. AMDGPU optimized code may spill vector registers to non-global address space; memory, and this spilling may be done only for SIMT lanes that are active on; entry to the subprogram. To support this the CFI rule for the partially spilled; register needs to use an expression that uses the EXEC register as a bit mask to; select between the register (for inactive lanes) and the stack spill location; (for active lanes that are spilled). This needs to evaluate to a location; description, and not a value, as a debugger needs to change the value if the; user assigns to the variable. Another usage is to create an expression that evaluates to provide a vector of; logical PCs for active and inactive lanes in a SIMT execution model. Again the; EXEC register is used to select between active and inactive PC values. In order; to represent a vector of PC values, a way to create a composite location; description that is a vector of a single location is used. It may be possible to use existing DWARF to incrementally build the composite; location description, possibly using the DWARF operations for control flow to; create a loop. However, for the AMDGPU that would require loop iteration of 64.; A concern is that the resulting DWARF would have a significant size and would be; reasonably common as it is needed for every vector register that is spilled in a; function. AMDGPU can have up to 512 vector registers. Another concern is the; time taken to evaluate such non-trivial expressions repeatedly. To avoi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:25231,variab,variable,25231,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variable']
Modifiability,inuit2Minimizer.h; MinuitParameter.h; MnApplication.h; MnConfig.h; MnContours.h; MnCovarianceSqueeze.h; MnCross.h; MnEigen.h; MnFcn.h; MnFumiliMinimize.h; MnFunctionCross.h; MnGlobalCorrelationCoeff.h; MnHesse.h; MnLineSearch.h; MnMachinePrecision.h; MnMatrix.h; MnMatrixfwd.h; MnMigrad.h; MnMinimize.h; MnMinos.h; MnParabola.h; MnParabolaFactory.h; MnParabolaPoint.h; MnParameterScan.h; MnPlot.h; MnPosDef.h; MnPrint.h; MnScan.h; MnSeedGenerator.h; MnSimplex.h; MnStrategy.h; MnTiny.h; MnTraceObject.h; MnUserCovariance.h; MnUserFcn.h; MnUserParameterState.h; MnUserParameters.h; MnUserTransformation.h; MnVectorTransform.h; ModularFunctionMinimizer.h; NegativeG2LineSearch.h; Numerical2PGradientCalculator.h; ParametricFunction.h; ScanBuilder.h; ScanMinimizer.h; SimplexBuilder.h; SimplexMinimizer.h; SimplexParameters.h; SimplexSeedGenerator.h; SinParameterTransformation.h; SqrtLowParameterTransformation.h; SqrtUpParameterTransformation.h; StackAllocator.h; VariableMetricBuilder.h; VariableMetricEDMEstimator.h; VariableMetricMinimizer.h; VectorOuterProduct.h; ). set(MINUIT2_SOURCES; AnalyticalGradientCalculator.cxx; BFGSErrorUpdator.cxx; CombinedMinimumBuilder.cxx; DavidonErrorUpdator.cxx; ExternalInternalGradientCalculator.cxx; FumiliBuilder.cxx; FumiliErrorUpdator.cxx; FumiliGradientCalculator.cxx; FumiliMinimizer.cxx; FumiliStandardChi2FCN.cxx; FumiliStandardMaximumLikelihoodFCN.cxx; HessianGradientCalculator.cxx; InitialGradientCalculator.cxx; LaEigenValues.cxx; LaInnerProduct.cxx; LaInverse.cxx; LaOuterProduct.cxx; LaSumOfElements.cxx; LaVtMVSimilarity.cxx; MPIProcess.cxx; MinimumBuilder.cxx; Minuit2Minimizer.cxx; MnApplication.cxx; MnContours.cxx; MnCovarianceSqueeze.cxx; MnEigen.cxx; MnFcn.cxx; MnFumiliMinimize.cxx; MnFunctionCross.cxx; MnGlobalCorrelationCoeff.cxx; MnHesse.cxx; MnLineSearch.cxx; MnMachinePrecision.cxx; MnMinos.cxx; MnParabolaFactory.cxx; MnParameterScan.cxx; MnPlot.cxx; MnPosDef.cxx; MnPrint.cxx; MnPrintImpl.cxx; MnScan.cxx; MnSeedGenerator.cxx; MnSt,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/CMakeLists.txt:2154,Variab,VariableMetricEDMEstimator,2154,math/minuit2/src/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/CMakeLists.txt,1,['Variab'],['VariableMetricEDMEstimator']
Modifiability,"io 2015; - Extensions SDK (you'll be prompted to install it if you open ClangFormat.sln). The extension is built using CMake to generate the usual LLVM.sln by setting; the following CMake vars:. - BUILD_CLANG_FORMAT_VS_PLUGIN=ON. - NUGET_EXE_DIR=path/to/nuget_dir (unless nuget.exe is already available in PATH). example:; cd /d C:\code\llvm; mkdir build & cd build; cmake -DBUILD_CLANG_FORMAT_VS_PLUGIN=ON -DNUGET_EXE_DIR=C:\nuget .. Once LLVM.sln is generated, build the clang_format_vsix target, which will build; ClangFormat.sln, the C# extension application. The CMake build will copy clang-format.exe and LICENSE.TXT into the ClangFormat/; directory so they can be bundled with the plug-in, as well as creating; ClangFormat/source.extension.vsixmanifest. Once the plug-in has been built with; CMake once, it can be built manually from the ClangFormat.sln solution in Visual; Studio. ===========; Debugging; ===========. Once you've built the clang_format_vsix project from LLVM.sln at least once,; open ClangFormat.sln in Visual Studio, then:. - Make sure the ""Debug"" target is selected; - Open the ClangFormat project properties; - Select the Debug tab; - Set ""Start external program:"" to where your devenv.exe is installed. Typically; it's ""C:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\IDE\devenv.exe""; - Set ""Command line arguments"" to: /rootsuffix Exp; - You can now set breakpoints if you like; - Press F5 to build and run with debugger. If all goes well, a new instance of Visual Studio will be launched in a special; mode where it uses the experimental hive instead of the normal configuration hive.; By default, when you build a VSIX project in Visual Studio, it auto-registers the; extension in the experimental hive, allowing you to test it. In the new Visual Studio; instance, open or create a C++ solution, and you should now see the Clang Format; entries in the Tool menu. You can test it out, and any breakpoints you set will be; hit where you can debug as usual.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/README.txt:1748,config,configuration,1748,interpreter/llvm-project/clang/tools/clang-format-vs/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/README.txt,1,['config'],['configuration']
Modifiability,"ion &F, FunctionAnalysisManager &AM);`` method. We start by showing you how to construct a pass, from setting up the build,; creating the pass, to executing and testing it. Looking at existing passes is; always a great way to learn details. .. warning::; This document deals with the new pass manager. LLVM uses the legacy pass; manager for the codegen pipeline. For more details, see; :doc:`WritingAnLLVMPass` and :doc:`NewPassManager`. Quick Start --- Writing hello world; ===================================. Here we describe how to write the ""hello world"" of passes. The ""HelloWorld""; pass is designed to simply print out the name of non-external functions that; exist in the program being compiled. It does not modify the program at all,; it just inspects it. The code below already exists; feel free to create a pass with a different; name alongside the HelloWorld source files. .. _writing-an-llvm-npm-pass-build:. Setting up the build; --------------------. First, configure and build LLVM as described in :doc:`GettingStarted`. Next, we will reuse an existing directory (creating a new directory involves; messing around with more CMake files than we want). For this example, we'll use; ``llvm/lib/Transforms/Utils/HelloWorld.cpp``, which has already been created.; If you'd like to create your own pass, add a new source file into; ``llvm/lib/Transforms/Utils/CMakeLists.txt`` (assuming you want your pass in; the ``Transforms/Utils`` directory. Now that we have the build set up for a new pass, we need to write the code; for the pass itself. .. _writing-an-llvm-npm-pass-basiccode:. Basic code required; -------------------. Now that the build is setup for a new pass, we just have to write it. First we need to define the pass in a header file. We'll create; ``llvm/include/llvm/Transforms/Utils/HelloWorld.h``. The file should; contain the following boilerplate:. .. code-block:: c++. #ifndef LLVM_TRANSFORMS_HELLONEW_HELLOWORLD_H; #define LLVM_TRANSFORMS_HELLONEW_HELLOWORLD_H. #include",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst:2069,config,configure,2069,interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,1,['config'],['configure']
Modifiability,"ion 5,; and the new semantics for DWARF Version 6 which has been done for some; other features. Another option is to limit the execution to be on the same stack only to; the evaluation of an expression E that is the value of a; ``DW_AT_location`` attribute of a ``DW_TAG_dwarf_procedure`` debugging; information entry. The DWARF would be ill-formed if E is a location list; expression that does not match exactly one location list entry. In all; other cases the evaluation of an expression E that is the value of a; ``DW_AT_location`` attribute would evaluate E with the current context,; except the result kind is a location description, the compilation unit; is the one that contains D, and the initial stack is empty. The location; description result is pushed on the stack. * If D has a ``DW_AT_const_value`` attribute with a value V, then it is as; if a ``DW_OP_implicit_value V`` operation was executed. *This allows a call operation to be used to compute the location; description for any variable or formal parameter regardless of whether the; producer has optimized it to a constant. This is consistent with the*; ``DW_OP_implicit_pointer`` *operation.*. .. note::. Alternatively, could deprecate using ``DW_AT_const_value`` for; ``DW_TAG_variable`` and ``DW_TAG_formal_parameter`` debugger information; entries that are constants and instead use ``DW_AT_location`` with an; operation expression that results in a location description with one; implicit location description. Then this rule would not be required. * Otherwise, there is no effect and no changes are made to the stack. .. note::. In DWARF Version 5, if D does not have a ``DW_AT_location`` then; ``DW_OP_call*`` is defined to have no effect. It is unclear that this is; the right definition as a producer should be able to rely on using; ``DW_OP_call*`` to get a location description for any non-\; ``DW_TAG_dwarf_procedure`` debugging information entries. Also, the; producer should not be creating DWARF with ``DW_OP_call*`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:80473,variab,variable,80473,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variable']
Modifiability,"ion body; with respect to control flow in that goto, break, and continue do not; escape the Block. Exceptions are treated *normally* in that when; thrown they pop stack frames until a catch clause is found. Objective-C Extensions; ======================. Objective-C extends the definition of a Block reference type to be; that also of id. A variable or expression of Block type may be; messaged or used as a parameter wherever an id may be. The converse is; also true. Block references may thus appear as properties and are; subject to the assign, retain, and copy attribute logic that is; reserved for objects. All Blocks are constructed to be Objective-C objects regardless of; whether the Objective-C runtime is operational in the program or; not. Blocks using automatic (stack) memory are objects and may be; messaged, although they may not be assigned into ``__weak`` locations; if garbage collection is enabled. Within a Block literal expression within a method definition; references to instance variables are also imported into the lexical; scope of the compound statement. These variables are implicitly; qualified as references from self, and so self is imported as a const; copy. The net effect is that instance variables can be mutated. The :block-term:`Block_copy` operator retains all objects held in; variables of automatic storage referenced within the Block expression; (or form strong references if running under garbage collection).; Object variables of ``__block`` storage type are assumed to hold; normal pointers with no provision for retain and release messages. Foundation defines (and supplies) ``-copy`` and ``-release`` methods for; Blocks. In the Objective-C and Objective-C++ languages, we allow the; ``__weak`` specifier for ``__block`` variables of object type. If; garbage collection is not enabled, this qualifier causes these; variables to be kept without retain messages being sent. This; knowingly leads to dangling pointers if the Block (or a copy) outlives; the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:9407,variab,variables,9407,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['variab'],['variables']
Modifiability,"ion for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for the target being; built for, and `driver` is the name of the currently used driver. The algorithm; first attempts to use the canonical name for the driver used, then falls back; to the one found in the executable name. The following canonical driver names are used:. - ``clang`` for the ``gcc`` driver (used to compile C programs); - ``clang++`` for the ``gxx`` driver (used to compile C++ programs); - ``clang-cpp`` for the ``cpp`` driver (pure preprocessor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31698,config,configuration,31698,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['configuration']
Modifiability,"ion in the tablegen file; ``clang/include/clang/Driver/Options.td``. This is done by instantiating the; ``Option`` class (defined in ``llvm/include/llvm/Option/OptParser.td``). The; instance is typically created through one of the helper classes that encode the; acceptable ways to specify the option value on the command line:. * ``Flag`` - the option does not accept any value,; * ``Joined`` - the value must immediately follow the option name within the same; argument,; * ``Separate`` - the value must follow the option name in the next command line; argument,; * ``JoinedOrSeparate`` - the value can be specified either as ``Joined`` or; ``Separate``,; * ``CommaJoined`` - the values are comma-separated and must immediately follow; the option name within the same argument (see ``Wl,`` for an example). The helper classes take a list of acceptable prefixes of the option (e.g.; ``""-""``, ``""--""`` or ``""/""``) and the option name:. .. code-block:: diff. // Options.td. + def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">;. Then, specify additional attributes via mix-ins:. * ``HelpText`` holds the text that will be printed besides the option name when; the user requests help (e.g. via ``clang --help``).; * ``Group`` specifies the ""category"" of options this option belongs to. This is; used by various tools to categorize and sometimes filter options.; * ``Flags`` may contain ""tags"" associated with the option. These may affect how; the option is rendered, or if it's hidden in some contexts.; * ``Visibility`` should be used to specify the drivers in which a particular; option would be available. This attribute will impact tool --help; * ``Alias`` denotes that the option is an alias of another option. This may be; combined with ``AliasArgs`` that holds the implied value. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; + Group<f_Group>, Visibility<[ClangOption, CC1Option]>,; + HelpText<""Load pass plugin from a dynamic shared object file."">",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:29948,plugin,plugin,29948,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['plugin'],['plugin']
Modifiability,"ion is `PHI` instructions: these become implicit definitions at; control flow merges once regalloc finishes, and any debug numbers attached to; `PHI` instructions are lost. To circumvent this, debug numbers of `PHI`s are; recorded at the start of register allocation (`phi-node-elimination`), then; `DBG_PHI` instructions are inserted after regalloc finishes. This requires some; maintenance of which register a variable is located in during regalloc, but at; single positions (block entry points) rather than ranges of instructions. An example, before regalloc:. ```text; bb.2:; %2 = PHI %1, %bb.0, %2, %bb.1, debug-instr-number 1; ```. After:. ```text; bb.2:; DBG_PHI $rax, 1; ```. # `LiveDebugValues`. After optimisations and code layout complete, information about variable; values must be translated into variable locations, i.e. registers and stack; slots. This is performed in the [`LiveDebugValues` pass][LiveDebugValues], where; the debug instructions and machine code are separated out into two independent; functions:; * One that assigns values to variable names,; * One that assigns values to machine registers and stack slots. LLVM's existing SSA tools are used to place `PHI`s for each function, between; variable values and the values contained in machine locations, with value; propagation eliminating any unnecessary `PHI`s. The two can then be joined up; to map variables to values, then values to locations, for each instruction in; the function. Key to this process is being able to identify the movement of values between; registers and stack locations, so that the location of values can be preserved; for the full time that they are resident in the machine. # Required target support and transition guide. Instruction referencing will work on any target, but likely with poor coverage.; Supporting instruction referencing well requires:; * Target hooks to be implemented to allow `LiveDebugValues` to follow values; through the machine,; * Target-specific optimisations to be in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md:4617,variab,variable,4617,interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,1,['variab'],['variable']
Modifiability,"ion of the CERNLIB algorithm; DGAUSS by Sigfried Kolbig, and it is used by the TF1::Integral method. The second one uses the Gauss Legendre quadrature formula. It is used by the TF1::IntegralFast method.; These classes implement both the same virtual interface as the adaptive integration methods provided by the MathMore library. They can all be created and used easily via the common class ROOT::Math::IntegratorOneDim providing the interfaces for numerical integration.; New template methods have been also included in the common Integration class in order to be able to integrate automatically any C++ callable object. ROOT::Math::RichardsonDerivator implementing numerical derivation using the Richardson's extrapolation formula (use 2 derivative estimates to compute a third, more accurate estimation). This is used by the TD1::Derivative method. ; BrentRootFinder for finding the root of one-dimensional function using the Brent algorithm. The class inherits from a virtual interface, which is also implemented by the MathMore root finder methods. The user can instantiate, via the common ROOT::Math::RootFinder class, all the various root finder algorithms. The BrentRootFinder class is used by TF1::GetX . ; A similar class, BrentMinimizer1D, provides the possibility to find the minimum of one-dimensional functions using the Brent algorithm. This class is used by TF1::GetMinimum or TF1::GetMaximum; Use ROOT convention for all enumeration names defining the type of numerical algorithms (start with k, like kADAPTIVE for the integration type). This affects both MathCore and MathMore.; . In addition we use now the ROOT convention for all enumeration names defining the type of numerical algorithms. The names start with k, like kADAPTIVE for the integration type. This change affects both MathCore and MathMore and it breaks backward compatibility. MathCore Function interfaces; Mathcore provides as well interfaces for the evaluation of mathematical and parametric functions to be used ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:7797,inherit,inherits,7797,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['inherit'],['inherits']
Modifiability,"ion or; from the target. This is because the ``__FLT_EVAL_METHOD__`` macro; cannot expand to the correct evaluation method in the presence of a ``#pragma``; which alters the evaluation method. An error is issued if; ``__FLT_EVAL_METHOD__`` is expanded inside a scope modified by; ``#pragma clang fp eval_method``. .. _fp-constant-eval:. A note about Floating Point Constant Evaluation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In C, the only place floating point operations are guaranteed to be evaluated; during translation is in the initializers of variables of static storage; duration, which are all notionally initialized before the program begins; executing (and thus before a non-default floating point environment can be; entered). But C++ has many more contexts where floating point constant; evaluation occurs. Specifically: for static/thread-local variables,; first try evaluating the initializer in a constant context, including in the; constant floating point environment (just like in C), and then, if that fails,; fall back to emitting runtime code to perform the initialization (which might; in general be in a different floating point environment). Consider this example when compiled with ``-frounding-math``. .. code-block:: console. constexpr float func_01(float x, float y) {; return x + y;; }; float V1 = func_01(1.0F, 0x0.000001p0F);. The C++ rule is that initializers for static storage duration variables are; first evaluated during translation (therefore, in the default rounding mode),; and only evaluated at runtime (and therefore in the runtime rounding mode) if; the compile-time evaluation fails. This is in line with the C rules;; C11 F.8.5 says: *All computation for automatic initialization is done (as if); at execution time; thus, it is affected by any operative modes and raises; floating-point exceptions as required by IEC 60559 (provided the state for the; FENV_ACCESS pragma is ‘‘on’’). All computation for initialization of objects; that have static o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:73206,variab,variables,73206,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variables']
Modifiability,ion sequences in non-call contexts; Unknown. 2292; CD5; simple-template-id is ambiguous between class-name and type-name; Clang 9. 2293; CD5; Requirements for simple-template-id used as a class-name; Unknown. 2294; CD5; Dependent auto static data members; Unknown. 2295; CD5; Aggregates with deleted defaulted constructors; Unknown. 2296; open; Are default argument instantiation failures in the “immediate context”?; Not resolved. 2297; open; Unclear specification of atomic operations; Not resolved. 2298; open; Actions and expression evaluation; Not resolved. 2299; CD5; constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address comparison between different member subobjects; Unknown. 2303; CD5; Partial ordering and recursive variadic inheritance; Clang 12. 2304; NAD; Incomplete type vs overload resolution; Unknown. 2305; CD5; Explicit instantiation of constexpr or inline variable template; Unknown. 2306; NAD; Nested friend templates of class templates; Unknown. 2307; CD5; Unclear definition of “equivalent to a nontype template parameter”; Unknown. 2308; NAD; Structured bindings and lambda capture; Unknown. 2309; CD5; Restrictions on nested statements within constexpr functions; Unknown. 2310; CD5; Type completeness and derived-to-base pointer conversions; Unknown. 2311; open; Missed case for guaranteed copy elision; Not resolved. 2312; CD6; Structured bindings and mutable; Unknown. 2313; CD5; Redeclaration of structured binding reference variables; Unknown. 2314; dup; Structured bindings and lambda capture; Unknown. 2315; CD5; What is the “corresponding special member” of a variant member?; Unknown. 2316; drafting; Simplifying class conversions in conditional expressions; Not resolved. 2317; CD5; Self-referential default member initializers; Unknown. 2318; CD5; Nondeduced contexts in deduction from a braced-init-list; Unknown. 2319; draf,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:157276,variab,variable,157276,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['variab'],['variable']
Modifiability,"ion support in RooFit classes. **Approach 1:** For very simple cases like `RooRatio`, it may be preferable to; write the entire code in a single string. **Approach 2:** Another approach could be to extract free functions in a; separate header file.; Since Clad prefers the code for models to be within a single translation unit,; in many classes, this has been implemented by moving the computational; aspects of the RooFit class; to free functions in a single header file named [MathFuncs] (and/or; [MathFuncs], where relevant). This approach enables easier debugging; (e.g., you can standalone-compile the generated code with just a few header; files copied outside ROOT). *Refactoring* It is important to refactor the code such that:. - the footprint of the generated code is minimized by referring to existing; functions with the definition known by interpreter (i.e., they are in public; header files). - to reuse common code, both in the generated code, and in the existing; RooAbsReal::evaluate() method (meaning that the refactoring of `evaluate()` is; optional, but it is recommended). \htmlonly; <div class=""pyrootbox"">; \endhtmlonly. *Implement Code Generation support in custom classes*: Framework developers; that want to implement Code Generation support for their custom classes, this; approach of extracting free functions in a separate header file is not; suitable, since they can't put the code in a header that is part of the ROOT; installation. Please note the following recommendations:. - while developing your custom class, add these functions to your classes; header file (e.g., as part of the class definition), and. - if/when your class is upstreamed to RooFit, expect to move into the; `RooFit::detail` namespace and their implementations into `MathFuncs.h`. \htmlonly; </div>; \endhtmlonly. *Overriding the Translate Function*: The `RooAbsArg::translate()` function; needs to be overridden to specify how the class is translating to C++ code; that is using the aforemention",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:6429,refactor,refactoring,6429,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['refactor'],['refactoring']
Modifiability,"ion units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. Performance; -----------. A performance overhead of less than 1% has been measured by running the; Dromaeo benchmark suite against an instrumented version of the Chromium; web browser. Another good performance benchmark for this mechanism is the; virtual-call-heavy SPEC 2006 xalancbmk. Note that this scheme has not yet been optimized for binary size; an increase; of up to 15% has been observed for Chromium. Bad Cast Checking; =================. This scheme checks that pointer casts are made to an object of the correct; dynamic type; that is, the dynamic type of the object must be a derived class; of the pointee type of the cast. The checks are currently only introduced; where the class being casted to is a polymorphic class. Bad casts are not in themselves control flow integrity violations, but they; can also create security vulnerabilities, and the implementation uses many; of the same mechanisms. There are two types of bad cast that may be forbidden: bad casts; from a base class to a derived class (which can be checked with; ``-fsanitize=cfi-derived-cast``), and bad casts from a pointer of; type ``void*`` or another unrelated type (which can be checked with; ``-fsanitize=cfi-unrelated-cast``). The difference between these two types of casts is that the first is defined; by the C++ standard to produce an undefined value, while the second is not; in itself undefined behavior (it is well defined to cast the pointer back; to its original type) unless the object is uninitialized and the cast is a; ``static_cast`` (see C++14 [basic.life]p5). If a program as a matter of policy forbids the second type of cast, that; restriction can normally be enforced. However i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:5486,polymorphi,polymorphic,5486,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,1,['polymorphi'],['polymorphic']
Modifiability,"ion"". Here are a few observations about this:. First, you're right that LLVM does lose information. For example, as of; this writing, there is no way to distinguish in the LLVM IR whether an; SSA-value came from a C ""int"" or a C ""long"" on an ILP32 machine (other; than debug info). Both get compiled down to an 'i32' value and the; information about what it came from is lost. The more general issue; here, is that the LLVM type system uses ""structural equivalence"" instead; of ""name equivalence"". Another place this surprises people is if you; have two types in a high-level language that have the same structure; (e.g. two different structs that have a single int field): these types; will compile down into a single LLVM type and it will be impossible to; tell what it came from. Second, while LLVM does lose information, LLVM is not a fixed target: we; continue to enhance and improve it in many different ways. In addition; to adding new features (LLVM did not always support exceptions or debug; info), we also extend the IR to capture important information for; optimization (e.g. whether an argument is sign or zero extended,; information about pointers aliasing, etc). Many of the enhancements are; user-driven: people want LLVM to include some specific feature, so they; go ahead and extend it. Third, it is *possible and easy* to add language-specific optimizations,; and you have a number of choices in how to do it. As one trivial; example, it is easy to add language-specific optimization passes that; ""know"" things about code compiled for a language. In the case of the C; family, there is an optimization pass that ""knows"" about the standard C; library functions. If you call ""exit(0)"" in main(), it knows that it is; safe to optimize that into ""return 0;"" because C specifies what the; 'exit' function does. In addition to simple library knowledge, it is possible to embed a; variety of other language-specific information into the LLVM IR. If you; have a specific need and run into ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:10004,extend,extend,10004,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['extend'],['extend']
Modifiability,"ion, ROOT::Math::IParamMultiGradFunction interfaces, where the parameter values are now required for calculating the partial derivatives with respect to the parameters.; This changes the signature of the pure abstract method, DoParameterDerivative(const double *x, const double * p, , which takes also a pointer (type const double *) to the parameters.; In addition, these classes do not inherit anymore from the function gradient interface (ROOT::Math::IGradFunction and ROOT::Math::IMultiGradFunction). They define only the parameter gradient which is needed for fitting and not the coordinate gradient. A derived class, like ROOT::Math::Polynomial, implementing both functionality (coordinate and parameter gradient) inherits then from both interfaces.; . More detailed description of the current MathCore release can be found at this location. MathMore; This new release contains:. Modify and rename the class ROOT::Math::RootFinder to ROOT::Math::GSLRootFinder to distinguish from the main interface class which has been put in the Mathcore library and it can create the GSLRootFinder using the plug-in manager. Furthermore, the class ROOT::Math::GSLRootFinder is not anymore a template class on the algorithm. They type of root-finder algorithm can now be selected via an enumeration; Fixed a bug in the ROOT::Math::GSLNLSMultiFi class.; Changes also in the class for the new enumeration names (all names start with k, like kADAPTIVE for the integration types).; . More detailed description of the current MathMore release can be found at this location. GenVector; The new physics vector classes have been moved out from the MathCore library in a new library, libGenVector. The library contains as well the CINT dictionary including main instantiations for the template classes. For this release the instantiation of some extra methods, in particular of the class ROOT::Math::TRansform3D have been added in the dictionary library.; Due to a CINT limitation, the dictionary for explicit template ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:10532,plug-in,plug-in,10532,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['plug-in'],['plug-in']
Modifiability,"ion. The point lies on the plane and the normal vector; points outside the half space. The half space is the only shape; which is infinite and can be used only in Boolean operations that; result in non-infinite composite shapes (see also ""Composite Shapes""; below). A half space has to be defined using the constructor:. ``` {.cpp}; TGeoHalfSpace (const char *name, Double_t *point[3],; Double_t *norm[3]);; ```. ### Composite Shapes. Composite shapes are Boolean combinations of two or more shape; components. The supported Boolean operations are union (+), intersection; (\*) and subtraction(-). Composite shapes derive from the base; **`TGeoShape`** class, therefore providing all shape features:; computation of bounding box, finding if a given point is inside or; outside the combination, as well as computing the distance to; entering/exiting. They can be directly used for creating volumes or used; in the definition of other composite shapes. Composite shapes are provided in order to complement and extend the set; of basic shape primitives. They have a binary tree internal structure,; therefore all shape-related geometry queries are signals propagated from; top level down to the final leaves, while the provided answers are; assembled and interpreted back at top. This `CSG`; `(composite solid geometry)` hierarchy is effective for small number of; components, while performance drops dramatically for large structures.; Building a complete geometry in this style is virtually possible but; highly not recommended. #### The Structure of Composite Shapes. A composite shape can always be looked as the result of a Boolean; operation between only two shape components. All information identifying; these two components as well as their positions with respect to the; frame of the composite is represented by an object called Boolean node.; A composite shape has a pointer to such a Boolean node. Since the shape; components may also be composites, they will also contain binary Boolean; no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:42883,extend,extend,42883,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['extend'],['extend']
Modifiability,"ion. To do this, most of the debugging information (descriptors for types,; variables, functions, source files, etc) is inserted by the language front-end; in the form of LLVM metadata. Debug information is designed to be agnostic about the target debugger and; debugging information representation (e.g. DWARF/Stabs/etc). It uses a generic; pass to decode the information that represents variables, types, functions,; namespaces, etc: this allows for arbitrary source-language semantics and; type-systems to be used, as long as there is a module written for the target; debugger to interpret the information. To provide basic functionality, the LLVM debugger does have to make some; assumptions about the source-level language being debugged, though it keeps; these to a minimum. The only common features that the LLVM debugger assumes; exist are `source files <LangRef.html#difile>`_, and `program objects; <LangRef.html#diglobalvariable>`_. These abstract objects are used by a; debugger to form stack traces, show information about local variables, etc. This section of the documentation first describes the representation aspects; common to any source-language. :ref:`ccxx_frontend` describes the data layout; conventions used by the C and C++ front-ends. Debug information descriptors are `specialized metadata nodes; <LangRef.html#specialized-metadata>`_, first-class subclasses of ``Metadata``. .. _format_common_intrinsics:. Debugger intrinsic functions; ----------------------------. LLVM uses several intrinsic functions (name prefixed with ""``llvm.dbg``"") to; track source local variables through optimization and code generation. ``llvm.dbg.declare``; ^^^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. void @llvm.dbg.declare(metadata, metadata, metadata). This intrinsic provides information about a local element (e.g., variable).; The first argument is metadata holding the address of variable, typically a; static alloca in the function entry block. The second argument is a; `local variabl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:7793,variab,variables,7793,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variables']
Modifiability,"ion.; [Ubuntu Packaging Guide]:http://packaging.ubuntu.com/html/getting-set-up.html#create-your-gpg-key. #### Windows; CPT is meant to be executed on cmd.exe prompt. Make sure you have set the; environment properly before continuing.; Below is a list of required packages for Windows (Win32-x86):. [MSYS Git] for Windows. [Python] for Windows. Microsoft Visual Studio 11 (2012), with Microsoft Visual C++ 2012. [MSYS Git]:http://msysgit.github.io/; [Python]:https://www.python.org/. ###### Setting Up:; Unlike other UNIX-like platforms, Windows requires you to follow some rules.; Do not ignore this section unless you want CPT to fail mid-way with wierd; errors. You should require these instructions only once. * While installing the packages make sure the executable is in a path that; doesn't contain spaces. For example, you should install Python in a path like. ```sh; C:\Python27; ```; rather than. ```sh; C:\Program Files (x86)\Python 2.7; ```; * Path to all the required executables should be present in the Windows; **PATH** environment variable.; * In case of MSYS Git, choose the option ""Run Git from Windows; Command Prompt"" during installation. A good way to check if everything is detected properly by the script is to; run the following command:; ```sh; cd tools/packaging/; ./cpt.py --check-requirements; ```. #### Red Hat Linux (Fedora/Scientific Linux CERN); This section applies to all distros based on Red Hat Linux like Fedora, and; Scientific Linux CERN (SLC). Apparently, you can build RPM packages in any; distro regardless of the package manager it uses. This has been tested on; Fedora, SLC, Ubuntu, and CrunchBang. If you are interested, you can test it; on your favourite platform and email me the results. Depending on the package manager of your distro, you can install the; packages required by CPT to build RPM bundles. For a Red Hat based distro; (which uses ```yum``` package manager), you can use the following command; (also performed automatically by CPT):; ```sh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md:4495,variab,variable,4495,interpreter/cling/tools/packaging/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md,1,['variab'],['variable']
Modifiability,"ion: ``AlwaysBreak``); Always break after an open bracket, if the parameters don't fit; on a single line, e.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2);. * ``BAS_BlockIndent`` (in configuration: ``BlockIndent``); Always break after an open bracket, if the parameters don't fit; on a single line. Closing brackets will be placed on a new line.; E.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2; ). .. note::. This currently only applies to braced initializer lists (when; ``Cpp11BracedListStyle`` is ``true``) and parentheses. .. _AlignArrayOfStructures:. **AlignArrayOfStructures** (``ArrayInitializerAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <AlignArrayOfStructures>`; if not ``None``, when using initialization for an array of structs; aligns the fields into columns. .. note::. As of clang-format 15 this option only applied to arrays with equal; number of columns per row. Possible values:. * ``AIAS_Left`` (in configuration: ``Left``); Align array column and left justify the columns e.g.:. .. code-block:: c++. struct test demo[] =; {; {56, 23, ""hello""},; {-1, 93463, ""world""},; {7, 5, ""!!"" }; };. * ``AIAS_Right`` (in configuration: ``Right``); Align array column and right justify the columns e.g.:. .. code-block:: c++. struct test demo[] =; {; {56, 23, ""hello""},; {-1, 93463, ""world""},; { 7, 5, ""!!""}; };. * ``AIAS_None`` (in configuration: ``None``); Don't align array initializer columns. .. _AlignConsecutiveAssignments:. **AlignConsecutiveAssignments** (``AlignConsecutiveStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlignConsecutiveAssignments>`; Style of aligning consecutive assignments. ``Consecutive`` will result in formattings like:. .. code-block:: c++. int a = 1;; int somelongname = 2;; double c = 3;. Nested configuration flags:. Alignment options. They can also be read as a whole for compatibility. The choices are:; - None; - Consecutive; - AcrossEmptyLines; - AcrossComments; - AcrossEmptyLinesAndComments. F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:8651,config,configuration,8651,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ion::viewCFGOnly()`` (does; not include the instructions), the ``MachineFunction::viewCFG()`` and; ``MachineFunction::viewCFGOnly()``, and the ``SelectionDAG::viewGraph()``; methods. Within GDB, for example, you can usually use something like ``call; DAG.viewGraph()`` to pop up a window. Alternatively, you can sprinkle calls to; these functions in your code in places you want to debug. Getting this to work requires a small amount of setup. On Unix systems; with X11, install the `graphviz <http://www.graphviz.org>`_ toolkit, and make; sure 'dot' and 'gv' are in your path. If you are running on macOS, download; and install the macOS `Graphviz program; <http://www.pixelglow.com/graphviz/>`_ and add; ``/Applications/Graphviz.app/Contents/MacOS/`` (or wherever you install it) to; your path. The programs need not be present when configuring, building or; running LLVM and can simply be installed when needed during an active debug; session. ``SelectionDAG`` has been extended to make it easier to locate *interesting*; nodes in large complex graphs. From gdb, if you ``call DAG.setGraphColor(node,; ""color"")``, then the next ``call DAG.viewGraph()`` would highlight the node in; the specified color (choices of colors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ===========================================. LLVM has a plethora of data structures in the ``llvm/ADT/`` directory, and we; commonly use STL dat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:53935,extend,extended,53935,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['extend'],['extended']
Modifiability,"ion; macros referencing other macros will be; ignored.; * Overloading by arity is supported: for example, given the macro; definitions A=x, A()=y, A(a)=a. .. code-block:: c++. A; -> x;; A(); -> y;; A(z); -> z;; A(a, b); // will not be expanded. .. _MaxEmptyLinesToKeep:. **MaxEmptyLinesToKeep** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <MaxEmptyLinesToKeep>`; The maximum number of consecutive empty lines to keep. .. code-block:: c++. MaxEmptyLinesToKeep: 1 vs. MaxEmptyLinesToKeep: 0; int f() { int f() {; int = 1; int i = 1;; i = foo();; i = foo(); return i;; }; return i;; }. .. _NamespaceIndentation:. **NamespaceIndentation** (``NamespaceIndentationKind``) :versionbadge:`clang-format 3.7` :ref:`¶ <NamespaceIndentation>`; The indentation used for namespaces. Possible values:. * ``NI_None`` (in configuration: ``None``); Don't indent in namespaces. .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. * ``NI_Inner`` (in configuration: ``Inner``); Indent only in inner namespaces (nested in other namespaces). .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. * ``NI_All`` (in configuration: ``All``); Indent in all namespaces. .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. .. _NamespaceMacros:. **NamespaceMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <NamespaceMacros>`; A vector of macros which are used to open namespace blocks. These are expected to be macros of the form:. .. code-block:: c++. NAMESPACE(<namespace-name>, ...) {; <namespace-content>; }. For example: TESTSUITE. .. _ObjCBinPackProtocolList:. **ObjCBinPackProtocolList** (``BinPackStyle``) :versionbadge:`clang-format 7` :ref:`¶ <ObjCBinPackProtocolList>`; Controls bin-packing Objective-C protocol conformance list; items into as few lines as possible when they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objectiv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:87304,config,configuration,87304,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ion`` flag. Flags that specify; ``CC1Option`` but not ``ClangOption`` will only be accessible via ``-cc1``.; This is similar for other driver modes, such as ``clang-cl`` or ``flang``. Next, parse (or manufacture) the command line arguments in the Clang driver and; use them to construct the ``-cc1`` job:. .. code-block:: diff. void Clang::ConstructJob(const ArgList &Args /*...*/) const {; ArgStringList CmdArgs;; // ... + for (const Arg *A : Args.filtered(OPT_fpass_plugin_EQ)) {; + CmdArgs.push_back(Args.MakeArgString(Twine(""-fpass-plugin="") + A->getValue()));; + A->claim();; + }; }. The last step is implementing the ``-cc1`` command line argument; parsing/generation that initializes/serializes the option class (in our case; ``CodeGenOptions``) stored within ``CompilerInvocation``. This can be done; automatically by using the marshalling annotations on the option definition:. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; Group<f_Group>, Flags<[CC1Option]>,; HelpText<""Load pass plugin from a dynamic shared object file."">,; + MarshallingInfoStringVector<CodeGenOpts<""PassPlugins"">>;. Inner workings of the system are introduced in the :ref:`marshalling; infrastructure <OptionMarshalling>` section and the available annotations are; listed :ref:`here <OptionMarshallingAnnotations>`. In case the marshalling infrastructure does not support the desired semantics,; consider simplifying it to fit the existing model. This makes the command line; more uniform and reduces the amount of custom, manually written code. Remember; that the ``-cc1`` command line interface is intended only for Clang developers,; meaning it does not need to mirror the driver interface, maintain backward; compatibility or be compatible with GCC. If the option semantics cannot be encoded via marshalling annotations, you can; resort to parsing/serializing the command line arguments manually:. .. code-block:: diff. // CompilerInvocation.cpp. static bool ParseCodeGe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:32102,plugin,plugin,32102,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['plugin'],['plugin']
Modifiability,"ional standalone. The accompanying update; of the Manual is expected mid-September. ; ; BASIC FUNCTIONALITY. rf101_basics.C - Fitting, plotting, toy data generation on one-dimensional p.d.f ; rf102_dataimport.C - Importing data from ROOT TTrees and THx histograms; rf103_interprfuncs.C - Interpreted functions and p.d.f.s; rf104_classfactory.C - The class factory for functions and p.d.f.s; rf105_funcbinding.C - Demonstration of binding ROOT Math functions as RooFit functions and pdfs; rf106_plotdecoration.C - Adding boxes with parameters, statistics to RooPlots.; rf107_plotstyles.C - Demonstration of various plotting styles of data, functions; rf108_plotbinning.C - Plotting unbinned data with alternate and variable binnings; rf109_chi2residpull.C - Calculating chi^2 from histograms and curves in RooPlots,; rf110_normintegration.C - Examples on normalization & integration of p.d.f.s, construction of cumulative distribution functions.; rf111_numintconfig.C - Configuration and customization of how numeric (partial) integrals. ; ADDITION AND CONVOLUTION. rf201_composite.C - Composite p.d.f with signal and background component; rf202_extendedmlfit.C - Setting up an extended maximum likelihood fit; rf203_ranges.C - Fitting and plotting in sub ranges; rf204_extrangefit.C - Extended maximum likelihood fit with alternate range definition; rf205_compplot.C - Options for plotting components of composite p.d.f.s.; rf206_treevistools.C - Tools for visualization of RooAbsArg expression trees; rf207_comptools.C - Tools and utilities for manipulation of composite objects; rf208_convolution.C - One-dimensional numeric convolution; rf209_anaconv.C - Decay function p.d.fs with optional B physics. ; MULTIDIMENSIONAL MODELS. rf301_composition.C - Multi-dimensional p.d.f.s through composition, e.g. substituting a p.d.f parameter with a function that depends on other observables; rf302_utilfuncs.C - Utility functions classes available for use in tailoring; rf303_conditional.C - Use of tailor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:1323,Config,Configuration,1323,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['Config'],['Configuration']
Modifiability,"ions (to allow processing '``ls -lad``'; naturally), ``ld`` style `prefix`_ options (to parse '``-lmalloc; -L/usr/lib``'), and interpreter style options. This document will hopefully let you jump in and start using CommandLine in your; utility quickly and painlessly. Additionally it should be a simple reference; manual to figure out how stuff works. Quick Start Guide; =================. This section of the manual runs through a simple CommandLine'ification of a; basic compiler tool. This is intended to show you how to jump into using the; CommandLine library in your own program, and show you some of the cool things it; can do. To start out, you need to include the CommandLine header file into your program:. .. code-block:: c++. #include ""llvm/Support/CommandLine.h"". Additionally, you need to add this as the first line of your main program:. .. code-block:: c++. int main(int argc, char **argv) {; cl::ParseCommandLineOptions(argc, argv);; ...; }. ... which actually parses the arguments and fills in the variable declarations. Now that you are ready to support command line arguments, we need to tell the; system which ones we want, and what type of arguments they are. The CommandLine; library uses a declarative syntax to model command line arguments with the; global variable declarations that capture the parsed values. This means that; for every command line option that you would like to support, there should be a; global variable declaration to capture the result. For example, in a compiler,; we would like to support the Unix-standard '``-o <filename>``' option to specify; where to put the output. With the CommandLine library, this is represented like; this:. .. _scalars arguments:; .. _here:. .. code-block:: c++. cl::opt<string> OutputFilename(""o"", cl::desc(""Specify output filename""), cl::value_desc(""filename""));. This declares a global variable ""``OutputFilename``"" that is used to capture the; result of the ""``o``"" argument (first parameter). We specify that this is a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:4300,variab,variable,4300,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variable']
Modifiability,"ionsOnASingleLine** (``ShortFunctionStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortFunctionsOnASingleLine>`; Dependent on the value, ``int f() { return 0; }`` can be put on a; single line. Possible values:. * ``SFS_None`` (in configuration: ``None``); Never merge functions into a single line. * ``SFS_InlineOnly`` (in configuration: ``InlineOnly``); Only merge functions defined inside a class. Same as ""inline"",; except it does not implies ""empty"": i.e. top level empty functions; are not merged either. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {; }. * ``SFS_Empty`` (in configuration: ``Empty``); Only merge empty functions. .. code-block:: c++. void f() {}; void f2() {; bar2();; }. * ``SFS_Inline`` (in configuration: ``Inline``); Only merge functions defined inside a class. Implies ""empty"". .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {}. * ``SFS_All`` (in configuration: ``All``); Merge all functions fitting on a single line. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() { bar(); }. .. _AllowShortIfStatementsOnASingleLine:. **AllowShortIfStatementsOnASingleLine** (``ShortIfStyle``) :versionbadge:`clang-format 3.3` :ref:`¶ <AllowShortIfStatementsOnASingleLine>`; Dependent on the value, ``if (a) return;`` can be put on a single line. Possible values:. * ``SIS_Never`` (in configuration: ``Never``); Never put short ifs on the same line. .. code-block:: c++. if (a); return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_WithoutElse`` (in configuration: ``WithoutElse``); Put short ifs on the same line only if there is no else statement. .. code-block:: c++. if (a) return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_OnlyFirstIf`` (in configuration: ``OnlyFirstIf``); Put short ifs, but not else ifs nor else statements, on the same line. .. code-block:: c++. if (a) return;. if (b) retur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:29638,config,configuration,29638,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ious tests. .. _format:. Debugging information format; ============================. LLVM debugging information has been carefully designed to make it possible for; the optimizer to optimize the program and debugging information without; necessarily having to know anything about debugging information. In; particular, the use of metadata avoids duplicated debugging information from; the beginning, and the global dead code elimination pass automatically deletes; debugging information for a function if it decides to delete the function. To do this, most of the debugging information (descriptors for types,; variables, functions, source files, etc) is inserted by the language front-end; in the form of LLVM metadata. Debug information is designed to be agnostic about the target debugger and; debugging information representation (e.g. DWARF/Stabs/etc). It uses a generic; pass to decode the information that represents variables, types, functions,; namespaces, etc: this allows for arbitrary source-language semantics and; type-systems to be used, as long as there is a module written for the target; debugger to interpret the information. To provide basic functionality, the LLVM debugger does have to make some; assumptions about the source-level language being debugged, though it keeps; these to a minimum. The only common features that the LLVM debugger assumes; exist are `source files <LangRef.html#difile>`_, and `program objects; <LangRef.html#diglobalvariable>`_. These abstract objects are used by a; debugger to form stack traces, show information about local variables, etc. This section of the documentation first describes the representation aspects; common to any source-language. :ref:`ccxx_frontend` describes the data layout; conventions used by the C and C++ front-ends. Debug information descriptors are `specialized metadata nodes; <LangRef.html#specialized-metadata>`_, first-class subclasses of ``Metadata``. .. _format_common_intrinsics:. Debugger intrinsic functions; --",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:7140,variab,variables,7140,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variables']
Modifiability,"iple times. **--bb** *basic-block-specifier*. Extract basic blocks(s) specified in *basic-block-specifier*. May be; specified multiple times. Each <function:bb[;bb]> specifier pair will create; a function. If multiple basic blocks are specified in one pair, the first; block in the sequence should dominate the rest. **--delete**. Delete specified Globals from Module. **-f**. Enable binary output on terminals. Normally, :program:`llvm-extract` will; refuse to write raw bitcode output if the output stream is a terminal. With; this option, :program:`llvm-extract` will write raw bitcode regardless of the; output device. **--func** *function-name*. Extract the function named *function-name* from the LLVM bitcode. May be; specified multiple times to extract multiple functions at once. **--rfunc** *function-regular-expr*. Extract the function(s) matching *function-regular-expr* from the LLVM bitcode.; All functions matching the regular expression will be extracted. May be; specified multiple times. **--glob** *global-name*. Extract the global variable named *global-name* from the LLVM bitcode. May be; specified multiple times to extract multiple global variables at once. **--rglob** *glob-regular-expr*. Extract the global variable(s) matching *global-regular-expr* from the LLVM; bitcode. All global variables matching the regular expression will be; extracted. May be specified multiple times. **--keep-const-init**. Preserve the values of constant globals. **--recursive**. Recursively extract all called functions. **-help**. Print a summary of command line options. **-o** *filename*. Specify the output filename. If filename is ""-"" (the default), then; :program:`llvm-extract` sends its output to standard output. **-S**. Write output in LLVM intermediate language (instead of bitcode). EXIT STATUS; -----------. If :program:`llvm-extract` succeeds, it will exit with 0. Otherwise, if an error; occurs, it will exit with a non-zero value. SEE ALSO; --------. :manpage:`bugpoint(1)`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-extract.rst:2297,variab,variable,2297,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-extract.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-extract.rst,4,['variab'],"['variable', 'variables']"
Modifiability,"ippet. The user can assume that in the provided code snippet the following variables; will be defined:. The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to; facilitate the rule definitions. The user can expect the following variables being predeclared:. * newObj; - variable representing the target in-memory object, its type is that of the; target object; * oldObj; - in normal conversion rules, an object of TVirtualObject class representing the; input data, guaranteed to hold the data members declared in the source property; of the rule; * buffer; - in raw conversion rules, an object of TBuffer class holding the data member; declared in source property of the rule; * names of the data members of the target object declared in the target property of the; rule declared to be the appropriate type; * onfile.xxx; - in normal conversion rules, names of the variables of basic types declared; in the source property of the rule. #### The C++ API. The schema evolution C++ API consists of two classes: `ROOT::TSchemaRuleSet` and; `ROOT::TSchemaRule`. Objects of the TSchemaRule class represent the rules and their fields have exactly the same; meaning as the ones of rules specified in the dictionaries. `TSchemaRuleSet` objects; manage the sets of rules and ensure their consistency. There can be no conflicting; rules in the rule sets. The rule sets are owned by the `TClass` objects corresponding to the; target classes defined in the rules and can be accessed using `TClass::{Get|Adopt}SchemaRules`. ### Manual Schema Evolution. If you have written your own `Streamer` as described in the section; ""Streamers with Special Additions"", you will have to manually add code; for each version and manage the evolution of your class. When you add or; remove data members, you must modify the `Streamer` by hand. ROOT; assumes that you have increased the class version numbe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:82264,variab,variables,82264,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['variab'],['variables']
Modifiability,"iptor;; const FOO foo;; };. void __block_invoke_10(struct __block_literal_10 *_block) {; printf(""%d\n"", _block->foo.value());; }. void __block_copy_10(struct __block_literal_10 *dst, struct __block_literal_10 *src) {; FOO_ctor(&dst->foo, &src->foo);; }. void __block_dispose_10(struct __block_literal_10 *src) {; FOO_dtor(&src->foo);; }. static struct __block_descriptor_10 {; unsigned long int reserved;; unsigned long int Block_size;; void (*copy_helper)(struct __block_literal_10 *dst, struct __block_literal_10 *src);; void (*dispose_helper)(struct __block_literal_10 *);; } __block_descriptor_10 = { 0, sizeof(struct __block_literal_10), __block_copy_10, __block_dispose_10 };. and the code would be:. .. code-block:: c++. {; FOO foo;; comp_ctor(&foo); // default constructor; struct __block_literal_10 _block_literal = {; &_NSConcreteStackBlock,; (1<<25)|(1<<26)|(1<<29), <uninitialized>,; __block_invoke_10,; &__block_descriptor_10,; };; comp_ctor(&_block_literal->foo, &foo); // const copy into stack version; struct __block_literal_10 &block = &_block_literal; // assign literal to block variable; block->invoke(block); // invoke block; comp_dtor(&_block_literal->foo); // destroy stack version of const block copy; comp_dtor(&foo); // destroy original version; }. C++ objects stored in ``__block`` storage start out on the stack in a; ``block_byref`` data structure as do other variables. Such objects (if not; ``const`` objects) must support a regular copy constructor. The ``block_byref``; data structure will have copy and destroy helper routines synthesized by the; compiler. The copy helper will have code created to perform the copy; constructor based on the initial stack ``block_byref`` data structure, and will; also set the (1<<26) bit in addition to the (1<<25) bit. The destroy helper; will have code to do the destructor on the object stored within the supplied; ``block_byref`` heap data structure. For example,. .. code-block:: c++. __block FOO blockStorageFoo;. requires the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:25757,variab,variable,25757,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variable']
Modifiability,"ir build && cd build; cmake .. -GNinja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ \; -DLLVM_USE_SANITIZE_COVERAGE=YES -DLLVM_USE_SANITIZER=Address; ninja clang-objc-fuzzer. ======================; Running clang-objc-fuzzer; ======================; bin/clang-objc-fuzzer CORPUS_DIR. e.g. using the example objc corpus,. bin/clang-objc-fuzzer <path to corpus_examples/objc> <path to new directory to store corpus findings>. =======================================================; Building clang-proto-fuzzer (Linux-only instructions); =======================================================; Install the necessary dependencies:; - binutils // needed for libprotobuf-mutator; - liblzma-dev // needed for libprotobuf-mutator; - libz-dev // needed for libprotobuf-mutator; - docbook2x // needed for libprotobuf-mutator; - Recent version of protobuf [3.3.0 is known to work]. Within your LLVM build directory, run CMake with the following variable; definitions:; - CMAKE_C_COMPILER=clang; - CMAKE_CXX_COMPILER=clang++; - LLVM_USE_SANITIZE_COVERAGE=YES; - LLVM_USE_SANITIZER=Address; - CLANG_ENABLE_PROTO_FUZZER=ON. Then build the clang-proto-fuzzer and clang-proto-to-cxx targets. Optionally,; you may also build clang-fuzzer with this setup. Example:; cd $LLVM_SOURCE_DIR; mkdir build && cd build; cmake .. -GNinja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ \; -DLLVM_USE_SANITIZE_COVERAGE=YES -DLLVM_USE_SANITIZER=Address \; -DCLANG_ENABLE_PROTO_FUZZER=ON; ninja clang-proto-fuzzer clang-proto-to-cxx. This directory also contains a Dockerfile which sets up all required; dependencies and builds the fuzzers. ============================; Running clang-proto-fuzzer; ============================; bin/clang-proto-fuzzer CORPUS_DIR. Arguments can be specified after -ignore_remaining_args=1 to modify the compiler; invocation. For example, the following command line will fuzz LLVM with a; custom optimization level and target triple:; bin/clang-proto-fuzzer CORPUS_DIR -ignore_remai",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt:2896,variab,variable,2896,interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt,1,['variab'],['variable']
Modifiability,"ir to your compiler,; the build will also generate the `generate-coverage-report` target to generate; the code coverage report for LLVM, and the `clear-profile-data` utility target; to delete captured profile data. See documentation for; *LLVM_CODE_COVERAGE_TARGETS* and *LLVM_COVERAGE_SOURCE_DIRS* for more; information on configuring code coverage reports. **LLVM_CODE_COVERAGE_TARGETS**:STRING; If set to a semicolon separated list of targets, those targets will be used; to drive the code coverage reports. If unset, the target list will be; constructed using the LLVM build's CMake export list. **LLVM_COVERAGE_SOURCE_DIRS**:STRING; If set to a semicolon separated list of directories, the coverage reports; will limit code coverage summaries to just the listed directories. If unset,; coverage reports will include all sources identified by the tooling. **LLVM_INDIVIDUAL_TEST_COVERAGE**:BOOL; Enable individual test case coverage. When set to ON, code coverage data for; each test case will be generated and stored in a separate directory under the; config.test_exec_root path. This feature allows code coverage analysis of each; individual test case. Defaults to OFF. **LLVM_BUILD_LLVM_DYLIB**:BOOL; If enabled, the target for building the libLLVM shared library is added.; This library contains all of LLVM's components in a single shared library.; Defaults to OFF. This cannot be used in conjunction with BUILD_SHARED_LIBS.; Tools will only be linked to the libLLVM shared library if LLVM_LINK_LLVM_DYLIB; is also ON.; The components in the library can be customised by setting LLVM_DYLIB_COMPONENTS; to a list of the desired components.; This option is not available on Windows. **LLVM_BUILD_TESTS**:BOOL; Include LLVM unit tests in the 'all' build target. Defaults to OFF. Targets; for building each unit test are generated in any case. You can build a; specific unit test using the targets defined under *unittests*, such as; ADTTests, IRTests, SupportTests, etc. (Search for ``add_llvm_u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:16023,config,config,16023,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['config'],['config']
Modifiability,ir/unittests/Rewrite; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Support; - `5`; - `4`; - `1`; - :part:`80%`; * - mlir/unittests/TableGen; - `5`; - `3`; - `2`; - :part:`60%`; * - mlir/unittests/Transforms; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libompd/src; - `9`; - `9`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/include; - `8`; - `8`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openm,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122259,plugin,plugins,122259,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['plugin'],['plugins']
Modifiability,"irectNestedType`` function is added. It's useful; for formatters to quickly find directly nested type when it's known; where to search for it, avoiding more expensive global search via; ``SBTarget::FindFirstType``.; * ``lldb-vscode`` was renamed to ``lldb-dap`` and and its installation; instructions have been updated to reflect this. The underlying functionality; remains unchanged.; * The ``mte_ctrl`` register can now be read from AArch64 Linux core files.; * LLDB on AArch64 Linux now supports debugging the Scalable Matrix Extension; (SME) and Scalable Matrix Extension 2 (SME2) for both live processes and core; files. For details refer to the; `AArch64 Linux documentation <https://lldb.llvm.org/use/aarch64-linux.html>`_.; * LLDB now supports symbol and binary acquisition automatically using the; DEBUFINFOD protocol. The standard mechanism of specifying DEBUFINOD servers in; the ``DEBUGINFOD_URLS`` environment variable is used by default. In addition,; users can specify servers to request symbols from using the LLDB setting; ``plugin.symbol-locator.debuginfod.server_urls``, override or adding to the; environment variable. * When running on AArch64 Linux, ``lldb-server`` now provides register; field information for the following registers: ``cpsr``, ``fpcr``,; ``fpsr``, ``svcr`` and ``mte_ctrl``. ::. (lldb) register read cpsr; cpsr = 0x80001000; = (N = 1, Z = 0, C = 0, V = 0, SS = 0, IL = 0, <...>. This is only available when ``lldb`` is built with XML support.; Where possible the CPU's capabilities are used to decide which; fields are present, however this is not always possible or entirely; accurate. If in doubt, refer to the numerical value. * On Windows, LLDB can now read the thread names. Changes to Sanitizers; ---------------------; * HWASan now defaults to detecting use-after-scope bugs. * `SpecialCaseList <https://clang.llvm.org/docs/SanitizerSpecialCaseList.html#format>`_; used by sanitizer ignore lists (e.g. ``*_ignorelist.txt`` in the Clang; resource direct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:16805,plugin,plugin,16805,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,1,['plugin'],['plugin']
Modifiability,"irectories. - `cycle` =\* means all cycles (memory and file). - `cycle` ="""" means apply to a memory object. - `cycle` = 9999 also means apply to a memory object. - `namecycle` = """" means the same as `namecycle` =""T\*"". - `namecycle` = `T*` delete subdirectories. For example to delete a directory from a file, you must specify the; directory cycle:. ``` {.cpp}; root[] f->Delete(""Wed011003;1""); ```. Some other examples of `namecycle` format are:. - `foo`:delete the object named `foo` from memory. - `foo;1`: delete the cycle 1 of the object named `foo` from the file. - `foo;*`: delete all cycles of `foo` from the file and also from; memory. - `*;2`: delete all objects with cycle number 2 from the file. - `*;*: delete` all objects from memory and from the file. - `T*;*`: delete all objects from memory and from the file including; all subdirectories. ## Streamers. To follow the discussion on `Streamers`, you need to know what a; *simple* data type is. A variable is of a simple data type if it cannot; be decomposed into other types. Examples of simple data types are longs,; shorts, floats, and chars. In contrast, a variable is of a *composite*; data type if it can be decomposed. For example, classes, structures, and; arrays are composite types. Simple types are also called primitive; types, basic types, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:41955,variab,variable,41955,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['variab'],['variable']
Modifiability,"is a stack-allocated object and it points to the first byte of the; object, the object is dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. Calling ``llvm.lifetime.end`` on an already dead alloca is no-op. If ``ptr`` is a non-stack-allocated object or it does not point to the first; byte of the object, it is equivalent to simply filling all bytes of the object; with ``poison``. '``llvm.invariant.start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The memory object can belong to any address space. ::. declare ptr @llvm.invariant.start.p0(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.invariant.start``' intrinsic specifies that the contents of; a memory object will not change. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". This intrinsic indicates that until an ``llvm.invariant.end`` that uses; the return value, the referenced memory location is constant and; unchanging. '``llvm.invariant.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The memory object can belong to any address space. ::. declare void @llvm.invariant.end.p0(ptr <start>, i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.invariant.end``' intrinsic specifies that the contents of a; memory object are mutable. Arguments:; """""""""""""""""""". The first argument is the matching ``llvm.invariant.start`` intrinsic.; The second argument is a constant integer representing the size of the; object, or -1 if it is variable sized and the third argument is a; pointer to the object. Semantics:; """""""""""""""""""". This intrinsic indicates that the memory is mutable aga",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:864094,variab,variable,864094,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"is an error (emit an error and return null if there is already an; entry for VarName) but we choose to allow shadowing of variables. In; order to handle this correctly, we remember the Value that we are; potentially shadowing in ``OldVal`` (which will be null if there is no; shadowed variable). Once the loop variable is set into the symbol table, the code; recursively codegen's the body. This allows the body to use the loop; variable: any references to it will naturally find it in the symbol; table. .. code-block:: c++. // Emit the step value.; Value *StepVal = nullptr;; if (Step) {; StepVal = Step->codegen();; if (!StepVal); return nullptr;; } else {; // If not specified, use 1.0.; StepVal = ConstantFP::get(*TheContext, APFloat(1.0));; }. Value *NextVar = Builder->CreateFAdd(Variable, StepVal, ""nextvar"");. Now that the body is emitted, we compute the next value of the iteration; variable by adding the step value, or 1.0 if it isn't present.; '``NextVar``' will be the value of the loop variable on the next; iteration of the loop. .. code-block:: c++. // Compute the end condition.; Value *EndCond = End->codegen();; if (!EndCond); return nullptr;. // Convert condition to a bool by comparing non-equal to 0.0.; EndCond = Builder->CreateFCmpONE(; EndCond, ConstantFP::get(*TheContext, APFloat(0.0)), ""loopcond"");. Finally, we evaluate the exit value of the loop, to determine whether; the loop should exit. This mirrors the condition evaluation for the; if/then/else statement. .. code-block:: c++. // Create the ""after loop"" block and insert it.; BasicBlock *LoopEndBB = Builder->GetInsertBlock();; BasicBlock *AfterBB =; BasicBlock::Create(*TheContext, ""afterloop"", TheFunction);. // Insert the conditional branch into the end of LoopEndBB.; Builder->CreateCondBr(EndCond, LoopBB, AfterBB);. // Any new code will be inserted in AfterBB.; Builder->SetInsertPoint(AfterBB);. With the code for the body of the loop complete, we just need to finish; up the control flow for it. This code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:24278,variab,variable,24278,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['variab'],['variable']
Modifiability,"is an important; step: LLVM still doesn't have code which requires the new toolchains, but it; soon will. If you compile LLVM but don't read the forums, we should; tell you!. * Ensure that at least one LLVM release has had this soft-error. Not all; developers compile LLVM top-of-tree. These release-bound developers should; also be told about upcoming changes. * Turn the soft-error into a hard-error after said LLVM release has branched. * Update the :doc:`coding standards<CodingStandards>` to allow the new; features we've explicitly approved in the RFC. * Start using the new features in LLVM's codebase. Here's a `sample RFC; <https://discourse.llvm.org/t/rfc-migrating-past-c-11/50943>`_ and the; `corresponding change <https://reviews.llvm.org/D57264>`_. .. _ci-usage:. Working with the CI system; --------------------------. The main continuous integration (CI) tool for the LLVM project is the; `LLVM Buildbot <https://lab.llvm.org/buildbot/>`_. It uses different *builders*; to cover a wide variety of sub-projects and configurations. The builds are; executed on different *workers*. Builders and workers are configured and; provided by community members. The Buildbot tracks the commits on the main branch and the release branches.; This means that patches are built and tested after they are merged to the these; branches (aka post-merge testing). This also means it's okay to break the build; occasionally, as it's unreasonable to expect contributors to build and test; their patch with every possible configuration. *If your commit broke the build:*. * Fix the build as soon as possible as this might block other contributors or; downstream users.; * If you need more time to analyze and fix the bug, please revert your change to; unblock others. *If someone else broke the build and this blocks your work*. * Comment on the code review in `GitHub <https://github.com/llvm/llvm-project/pulls>`_; (if available) or email the author, explain the problem and how this impacts; you. Add a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:36073,config,configurations,36073,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['config'],['configurations']
Modifiability,"is compiled in the project. Each command object contains the translation unit's main file, the; working directory of the compile run and the actual compile command. Example:. ::. [; { ""directory"": ""/home/user/llvm/build"",; ""arguments"": [""/usr/bin/clang++"", ""-Irelative"", ""-DSOMEDEF=With spaces, quotes and \\-es."", ""-c"", ""-o"", ""file.o"", ""file.cc""],; ""file"": ""file.cc"" },. { ""directory"": ""/home/user/llvm/build"",; ""command"": ""/usr/bin/clang++ -Irelative -DSOMEDEF=\""With spaces, quotes and \\-es.\"" -c -o file.o file.cc"",; ""file"": ""file2.cc"" },. ...; ]. The contracts for each field in the command object are:. - **directory:** The working directory of the compilation. All paths; specified in the **command** or **file** fields must be either; absolute or relative to this directory.; - **file:** The main translation unit source processed by this; compilation step. This is used by tools as the key into the; compilation database. There can be multiple command objects for the; same file, for example if the same source file is compiled with; different configurations.; - **arguments:** The compile command argv as list of strings.; This should run the compilation step for the translation unit ``file``.; ``arguments[0]`` should be the executable name, such as ``clang++``.; Arguments should not be escaped, but ready to pass to ``execvp()``.; - **command:** The compile command as a single shell-escaped string.; Arguments may be shell quoted and escaped following platform conventions,; with '``""``' and '``\``' being the only special characters. Shell expansion; is not supported. Either **arguments** or **command** is required. **arguments** is preferred,; as shell (un)escaping is a possible source of errors.; - **output:** The name of the output created by this compilation step.; This field is optional. It can be used to distinguish different processing; modes of the same input file. Build System Integration; ========================. The convention is to name the file compile\_command",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst:3546,config,configurations,3546,interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,1,['config'],['configurations']
Modifiability,"is doesn't fully enforce all inter-library dependencies, and importantly; doesn't enforce header file circular dependencies created by inline functions.; A good way to answer the ""is this layered correctly"" would be to consider; whether a Unix linker would succeed at linking the program if all inline; functions were defined out-of-line. (& for all valid orderings of dependencies; - since linking resolution is linear, it's possible that some implicit; dependencies can sneak through: A depends on B and C, so valid orderings are; ""C B A"" or ""B C A"", in both cases the explicit dependencies come before their; use. But in the first case, B could still link successfully if it implicitly; depended on C, or the opposite in the second case). .. _minimal list of #includes:. ``#include`` as Little as Possible; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``#include`` hurts compile time performance. Don't do it unless you have to,; especially in header files. But wait! Sometimes you need to have the definition of a class to use it, or to; inherit from it. In these cases go ahead and ``#include`` that header file. Be; aware however that there are many cases where you don't need to have the full; definition of a class. If you are using a pointer or reference to a class, you; don't need the header file. If you are simply returning a class instance from a; prototyped function or method, you don't need it. In fact, for most cases, you; simply don't need the definition of a class. And not ``#include``\ing speeds up; compilation. It is easy to try to go too overboard on this recommendation, however. You; **must** include all of the header files that you are using --- you can include; them either directly or indirectly through another header file. To make sure; that you don't accidentally forget to include a header file in your module; header, make sure to include your module header **first** in the implementation; file (as mentioned above). This way there won't be any hidden dependencies that; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:32050,inherit,inherit,32050,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['inherit'],['inherit']
Modifiability,"is is not a safe way to distribute LLVM or; LLVM-based tools. The simplest example of building a distribution with reasonable performance is; captured in the DistributionExample CMake cache file located at; clang/cmake/caches/DistributionExample.cmake. The following command will perform; and install the distribution build:. .. code-block:: console. $ cmake -G Ninja -C <path to clang>/cmake/caches/DistributionExample.cmake <path to LLVM source>; $ ninja stage2-distribution; $ ninja stage2-install-distribution. Difference between ``install`` and ``install-distribution``; -----------------------------------------------------------. One subtle but important thing to note is the difference between the ``install``; and ``install-distribution`` targets. The ``install`` target is expected to; install every part of LLVM that your build is configured to generate except the; LLVM testing tools. Alternatively the ``install-distribution`` target, which is; recommended for building distributions, only installs specific parts of LLVM as; specified at configuration time by *LLVM_DISTRIBUTION_COMPONENTS*. Additionally by default the ``install`` target will install the LLVM testing; tools as the public tools. This can be changed well by setting; *LLVM_INSTALL_TOOLCHAIN_ONLY* to ``On``. The LLVM tools are intended for; development and testing of LLVM, and should only be included in distributions; that support LLVM development. When building with *LLVM_DISTRIBUTION_COMPONENTS* the build system also; generates a ``distribution`` target which builds all the components specified in; the list. This is a convenience build target to allow building just the; distributed pieces without needing to build all configured targets. .. _Multi-distribution configurations:. Multi-distribution configurations; ---------------------------------. The ``install-distribution`` target described above is for building a single; distribution. LLVM's build system also supports building multiple distributions,; whi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:3480,config,configuration,3480,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['config'],['configuration']
Modifiability,"is is useful in; cases where the memory accessed by the snippet depends on the location; of the snippet, like RIP-relative addressing. EXAMPLE 1: benchmarking instructions; ------------------------------------. Assume you have an X86-64 machine. To measure the latency of a single; instruction, run:. .. code-block:: bash. $ llvm-exegesis --mode=latency --opcode-name=ADD64rr. Measuring the uop decomposition or inverse throughput of an instruction works similarly:. .. code-block:: bash. $ llvm-exegesis --mode=uops --opcode-name=ADD64rr; $ llvm-exegesis --mode=inverse_throughput --opcode-name=ADD64rr. The output is a YAML document (the default is to write to stdout, but you can; redirect the output to a file using `--benchmarks-file`):. .. code-block:: none. ---; key:; opcode_name: ADD64rr; mode: latency; config: ''; cpu_name: haswell; llvm_triple: x86_64-unknown-linux-gnu; num_repetitions: 10000; measurements:; - { key: latency, value: 1.0058, debug_string: '' }; error: ''; info: 'explicit self cycles, selecting one aliasing configuration.; Snippet:; ADD64rr R8, R8, R10; '; ... To measure the latency of all instructions for the host architecture, run:. .. code-block:: bash. $ llvm-exegesis --mode=latency --opcode-index=-1. EXAMPLE 2: benchmarking a custom code snippet; ---------------------------------------------. To measure the latency/uops of a custom piece of code, you can specify the; `snippets-file` option (`-` reads from standard input). .. code-block:: bash. $ echo ""vzeroupper"" | llvm-exegesis --mode=uops --snippets-file=-. Real-life code snippets typically depend on registers or memory.; :program:`llvm-exegesis` checks the liveliness of registers (i.e. any register; use has a corresponding def or is a ""live in""). If your code depends on the; value of some registers, you need to use snippet annotations to ensure setup; is performed properly. For example, the following code snippet depends on the values of XMM1 (which; will be set by the tool) and the memory buff",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst:5618,config,configuration,5618,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,1,['config'],['configuration']
Modifiability,"is program to create a little endian version of the table. The table; is used in PPCISelLowering.cpp, PPCTargetLowering::LOWERVECTOR_SHUFFLE(). //===----------------------------------------------------------------------===//. Opportunies to use instructions from PPCInstrVSX.td during code gen; - Conversion instructions (Sections 7.6.1.5 and 7.6.1.6 of ISA 2.07); - Scalar comparisons (xscmpodp and xscmpudp); - Min and max (xsmaxdp, xsmindp, xvmaxdp, xvmindp, xvmaxsp, xvminsp). Related to this: we currently do not generate the lxvw4x instruction for either; v4f32 or v4i32, probably because adding a dag pattern to the recognizer requires; a single target type. This should probably be addressed in the PPCISelDAGToDAG logic. //===----------------------------------------------------------------------===//. Currently EXTRACT_VECTOR_ELT and INSERT_VECTOR_ELT are type-legal only; for v2f64 with VSX available. We should create custom lowering; support for the other vector types. Without this support, we generate; sequences with load-hit-store hazards. v4f32 can be supported with VSX by shifting the correct element into; big-endian lane 0, using xscvspdpn to produce a double-precision; representation of the single-precision value in big-endian; double-precision lane 0, and reinterpreting lane 0 as an FPR or; vector-scalar register. v2i64 can be supported with VSX and P8Vector in the same manner as; v2f64, followed by a direct move to a GPR. v4i32 can be supported with VSX and P8Vector by shifting the correct; element into big-endian lane 1, using a direct move to a GPR, and; sign-extending the 32-bit result to 64 bits. v8i16 can be supported with VSX and P8Vector by shifting the correct; element into big-endian lane 3, using a direct move to a GPR, and; sign-extending the 16-bit result to 64 bits. v16i8 can be supported with VSX and P8Vector by shifting the correct; element into big-endian lane 7, using a direct move to a GPR, and; sign-extending the 8-bit result to 64 bits.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt:10862,extend,extending,10862,interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt,6,['extend'],['extending']
Modifiability,"is release.; Previously, the individual likelihoods were normalized separately in each range, which meant that the relative number of events in each sub-range was not used to estimate the PDF parameters.; From now on, the likelihoods are normalized by the sum of integrals in each range. This implies that the likelihood takes into account all inter-range and intra-range information. ### Deprecation of the `RooMinuit` class. The `RooMinuit` class was the old interface between RooFit and minuit. With ROOT version 5.24, the more general `RooMinimizer` adapter was introduced, which became the default with ROOT 6.08. Before 6.26, it was possible to still use the `RooMinuit` by passing the `Minimizer(""OldMinuit"", ""minimizer"")` command argument to `RooAbsPdf::fitTo()`. This option is now removed. ### Increase of the `RooAbsArg` class version. The class version of `RooAbsArg` was incremented from 7 to 8 in this release. In some circumstances, this can cause warnings in `TStreamerInfo` for classes inheriting from `RooAbsArg` when reading; older RooFit models from a file. These warnings are harmless and can be avoided by incrementing also the class version of the inheriting class. ### Compile-time protection against creating empty `RooCmdArg`s from strings. The implicit [RooCmdArg](https://root.cern/doc/v626/classRooCmdArg.html) constructor from `const char*` was removed to avoid the accidental construction of meaningless RooCmdArgs that only have a name but no payload.; This causes new compiler errors in your code if you pass a string instead of a RooCmdArg to various RooFit functions, such as [RooAbsPdf::fitTo()](https://root.cern/doc/v626/classRooAbsPdf.html#a5f79f16f4a26a19c9e66fb5c080f59c5).; If this happens, please consult the documentation of [fitTo()](https://root.cern/doc/v626/classRooAbsPdf.html#a5f79f16f4a26a19c9e66fb5c080f59c5) to check which of the [free functions in the `RooFit` namespace](https://root.cern/doc/v626/group__CmdArgs.html) you need to use to achieve ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:30904,inherit,inheriting,30904,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['inherit'],['inheriting']
Modifiability,"is selected by; the code generator, that it is a two-address instruction, has a particular; encoding, etc. The contents and semantics of the information in the record are; specific to the needs of the X86 backend, and are only shown as an example. As you can see, a lot of information is needed for every instruction supported; by the code generator, and specifying it all manually would be unmaintainable,; prone to bugs, and tiring to do in the first place. Because we are using; TableGen, all of the information was derived from the following definition:. .. code-block:: text. let Defs = [EFLAGS],; isCommutable = 1, // X = ADD Y,Z --> X = ADD Z,Y; isConvertibleToThreeAddress = 1 in // Can transform into LEA.; def ADD32rr : I<0x01, MRMDestReg, (outs GR32:$dst),; (ins GR32:$src1, GR32:$src2),; ""add{l}\t{$src2, $dst|$dst, $src2}"",; [(set GR32:$dst, (add GR32:$src1, GR32:$src2))]>;. This definition makes use of the custom class ``I`` (extended from the custom; class ``X86Inst``), which is defined in the X86-specific TableGen file, to; factor out the common features that instructions of its class share. A key; feature of TableGen is that it allows the end-user to define the abstractions; they prefer to use when describing their information. Syntax; ======. TableGen has a syntax that is loosely based on C++ templates, with built-in; types and specification. In addition, TableGen's syntax introduces some; automation concepts like multiclass, foreach, let, etc. Basic concepts; --------------. TableGen files consist of two key parts: 'classes' and 'definitions', both of; which are considered 'records'. **TableGen records** have a unique name, a list of values, and a list of; superclasses. The list of values is the main data that TableGen builds for each; record; it is this that holds the domain specific information for the; application. The interpretation of this data is left to a specific `backend`_,; but the structure and format rules are taken care of and are fixed by; Table",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/index.rst:6891,extend,extended,6891,interpreter/llvm-project/llvm/docs/TableGen/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/index.rst,1,['extend'],['extended']
Modifiability,"is to be in the store: we are modeling reachable storage as; > storage. But if we're just modeling arbitrary analysis facts that need to be; > invalidated when a pointer escapes then we shouldn't try to gin up storage; > for them just to get invalidation for free. As a metaphor, i'd probably compare it to body farms - the difference between; ghost member variables and metadata symbols seems to me like the difference; between body farms and evalCall. Both are nice to have, and body farms are very; pleasant to work with, even if not omnipotent. I think it's fine for a; FunctionDecl's body in a body farm to have a local variable, even if such; variable doesn't actually exist, even if it cannot be seen from outside the; function call. I'm not seeing immediate practical difference between ""it does; actually exist"" and ""it doesn't actually exist, just a handy abstraction"".; Similarly, i think it's fine if we have a ``CXXRecordDecl`` with; implementation-defined contents, and try to farm up a member variable as a handy; abstraction (we don't even need to know its name or offset, only that it's there; somewhere). **Artem:**. We've discussed it in person with Devin, and he provided more points to think; about:. * If the initializer list consists of non-POD data, constructors of list's; objects need to take the sub-region of the list's region as this-region In the; current (v2) version of this patch, these objects are constructed elsewhere and; then trivial-copied into the list's metadata pointer region, which may be; incorrect. This is our overall problem with C++ constructors, which manifests in; this case as well. Additionally, objects would need to be constructed in the; analyzer's core, which would not be able to predict that it needs to take a; checker-specific region as this-region, which makes it harder, though it might; be mitigated by sharing the checker state traits. * Because ""ghost variables"" are not material to the user, we need to somehow; make super sure that t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:16610,variab,variable,16610,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['variab'],['variable']
Modifiability,"is transformation analyzes and transforms the induction variables (and; computations derived from them) into simpler forms suitable for subsequent; analysis and transformation. This transformation makes the following changes to each loop with an; identifiable induction variable:. * All loops are transformed to have a *single* canonical induction variable; which starts at zero and steps by one.; * The canonical induction variable is guaranteed to be the first PHI node in; the loop header block.; * Any pointer arithmetic recurrences are raised to use array subscripts. If the trip count of a loop is computable, this pass also makes the following; changes:. * The exit condition for the loop is canonicalized to compare the induction; value against the exit value. This turns loops like:. .. code-block:: c++. for (i = 7; i*i < 1000; ++i). into. .. code-block:: c++. for (i = 0; i != 25; ++i). * Any use outside of the loop of an expression derived from the indvar is; changed to compute the derived value outside of the loop, eliminating the; dependence on the exit value of the induction variable. If the only purpose; of the loop is to compute the exit value of some derived expression, this; transformation will make the loop dead. This transformation should be followed by strength reduction after all of the; desired loop transformations have been performed. Additionally, on targets; where it is profitable, the loop could be transformed to count down to zero; (the ""do loop"" optimization). ``inline``: Function Integration/Inlining; -----------------------------------------. Bottom-up inlining of functions into callees. .. _passes-instcombine:. ``instcombine``: Combine redundant instructions; -----------------------------------------------. Combine instructions to form fewer, simple instructions. This pass does not; modify the CFG. This pass is where algebraic simplification happens. This pass combines things like:. .. code-block:: llvm. %Y = add i32 %X, 1; %Z = add i32 %Y, 1. in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:18727,variab,variable,18727,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['variab'],['variable']
Modifiability,"is useful for filing bug reports against scan-build or the; analyzer, as we can see the exact options (and files) passed to the analyzer.; For more comprehensible logs, don't perform a parallel build.; Run './configure' through scan-build; If an analyzed project uses an autoconf generated configure script,; you will probably need to run configure script through; scan-build in order to analyze the project.; Example. $ scan-build ./configure; $ scan-build --keep-cc make. The reason configure also needs to be run through; scan-build is because scan-build scans your source files by; interposing on the compiler. This interposition is currently done by; scan-build temporarily setting the environment variable CC to; ccc-analyzer. The program ccc-analyzer acts like a fake; compiler, forwarding its command line arguments over to the compiler to perform; regular compilation and clang to perform static analysis.; Running configure typically generates makefiles that have hardwired; paths to the compiler, and by running configure through; scan-build that path is set to ccc-analyzer. Analyzing iPhone Projects; Conceptually Xcode projects for iPhone applications are nearly the same as; their cousins for desktop applications. scan-build can analyze these; projects as well, but users often encounter problems with just building their; iPhone projects from the command line because there are a few extra preparative; steps they need to take (e.g., setup code signing).; Recommendation: use ""Build and Analyze""; The absolute easiest way to analyze iPhone projects is to use the; Analyze; feature in Xcode (which is based on the Clang Static Analyzer). There a; user can analyze their project right from a menu without most of the setup; described later.; Instructions are available on this; website on how to use open source builds of the analyzer as a replacement for; the one bundled with Xcode.; Using scan-build directly; If you wish to use scan-build with your iPhone project, keep the; follow",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html:7738,config,configure,7738,interpreter/llvm-project/clang/www/analyzer/scan-build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html,4,['config'],['configure']
Modifiability,"is way we 'mount' `/usr/include/module.modulemap`; non-invasively. The reasons why we need to extend the C++ modules support; beyond ROOT is described bellow.; * rootcling -cxxmodule creates a single artifact *Name.pcm* after the library; name. At a final stage, ROOT might be able to integrate the Name.pcm with the; shared library itself.; * Improved correctness in number of cases -- in a few cases ROOT is more; correct. In particular, when resolving global variables and function; declarations which are not part of the ROOT PCH.; * Enhanced symbol resolution mechanisms, bloom filters -- standard ROOT relies; on information in ROOTMAP files to react when the llvm JIT issues an; unresolved symbol callback. C++ Modules-aware ROOT relies on a behavior much; closer to the standard linker behavior. In particular, we start searching on; the LD_LIBRARY_PATH descending to the system libraries. The algorithm is very; efficient because it uses bloom filters[[5]]. This in turn allows ROOT symbol; to be extended to system libraries. ### Module Registration Approaches. The C++ modules system supports /*preloading*/ of all modules at startup time.; The current implementation of loading of C++ modules in clang has an overhead; and is between 40-60 MB depending on the ROOT configuration while there might; be 2x slowdown depending on the workflow. These issues are very likely to be; addressed by the LLVM community in midterm. Preloading of all C++ modules is semantically the closest to C++ behavior.; However, in order to achieve performance ROOT loads them on demand using; a global module index file. It has sufficient information to map a looked up; identifier to the module which contains the corresponding definition. Switching; back to preloading of all C++ modules is done by setting the `ROOT_USE_GMI`; environment variable to false.; ; ### Supported Platforms. We support all platforms with glibc++ versions: 5.2 onward. We support OSX from XCode 10 onward. ## Changes required by the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:13669,extend,extended,13669,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['extend'],['extended']
Modifiability,"is->b; cxxDependentScopeMemberExpr(isArrow()); matches this->m; unresolvedMemberExpr(isArrow()); matches this->f<T>, f<T>. Matcher<VarDecl>hasAutomaticStorageDuration; Matches a variable declaration that has automatic storage duration. Example matches x, but not y, z, or a.; (matcher = varDecl(hasAutomaticStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>hasGlobalStorage; Matches a variable declaration that does not have local storage. Example matches y and z (matcher = varDecl(hasGlobalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasLocalStorage; Matches a variable declaration that has function scope and is a; non-static local variable. Example matches x (matcher = varDecl(hasLocalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasStaticStorageDuration; Matches a variable declaration that has static storage duration.; It includes the variable declared at namespace scope and those declared; with ""static"" and ""extern"" storage class specifiers. void f() {; int x;; static int y;; thread_local int z;; }; int a;; static int b;; extern int c;; varDecl(hasStaticStorageDuration()); matches the function declaration y, a, b and c. Matcher<VarDecl>hasThreadStorageDuration; Matches a variable declaration that has thread storage duration. Example matches z, but not x, z, or a.; (matcher = varDecl(hasThreadStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<VarDecl>isConstinit; Matches constinit variable declarations. Given:; constinit int foo = 42;; constinit const ch",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:124936,variab,variable,124936,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['variab'],['variable']
Modifiability,"isLValue()``). Different kinds of declarations have different rules:. * **Type names** (including classes, structs, enums, typedefs, etc) should be; nouns and start with an upper-case letter (e.g. ``TextFileReader``). * **Variable names** should be nouns (as they represent state). The name should; be camel case, and start with an upper case letter (e.g. ``Leader`` or; ``Boats``). * **Function names** should be verb phrases (as they represent actions), and; command-like function should be imperative. The name should be camel case,; and start with a lower case letter (e.g. ``openFile()`` or ``isFoo()``). * **Enum declarations** (e.g. ``enum Foo {...}``) are types, so they should; follow the naming conventions for types. A common use for enums is as a; discriminator for a union, or an indicator of a subclass. When an enum is; used for something like this, it should have a ``Kind`` suffix; (e.g. ``ValueKind``). * **Enumerators** (e.g. ``enum { Foo, Bar }``) and **public member variables**; should start with an upper-case letter, just like types. Unless the; enumerators are defined in their own small namespace or inside a class,; enumerators should have a prefix corresponding to the enum declaration name.; For example, ``enum ValueKind { ... };`` may contain enumerators like; ``VK_Argument``, ``VK_BasicBlock``, etc. Enumerators that are just; convenience constants are exempt from the requirement for a prefix. For; instance:. .. code-block:: c++. enum {; MaxSize = 42,; Density = 12; };. As an exception, classes that mimic STL classes can have member names in STL's; style of lower-case words separated by underscores (e.g. ``begin()``,; ``push_back()``, and ``empty()``). Classes that provide multiple; iterators should add a singular prefix to ``begin()`` and ``end()``; (e.g. ``global_begin()`` and ``use_begin()``). Here are some examples:. .. code-block:: c++. class VehicleMaker {; ...; Factory<Tire> F; // Avoid: a non-descriptive abbreviation.; Factory<Tire> Factory; // Bet",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:43567,variab,variables,43567,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['variab'],['variables']
Modifiability,ise restrictions on break and continue; Unknown. 2617; review; Default template arguments for template members of non-template classes; Not resolved. 2618; C++23; Substitution during deduction should exclude exception specifications; Unknown. 2619; C++23; Kind of initialization for a designated-initializer-list; Unknown. 2620; C++23; Nonsensical disambiguation rule; Unknown. 2621; C++23; Kind of lookup for using enum declarations; Clang 16. 2622; C++23; Compounding types from function and pointer-to-member types; Unknown. 2623; drafting; Invoking destroying operator delete for constructor failure; Not resolved. 2624; C++23; Array delete expression with no array cookie; Unknown. 2625; C++23; Deletion of pointer to out-of-lifetime object; Unknown. 2626; C++23; Rephrase ones' complement using base-2 representation; Unknown. 2627; C++23; Bit-fields and narrowing conversions; Unknown. 2628; DR; Implicit deduction guides should propagate constraints; No. 2629; C++23; Variables of floating-point type as switch conditions; Unknown. 2630; C++23; Syntactic specification of class completeness; Unknown. 2631; C++23; Immediate function evaluations in default arguments; Clang 16. 2632; review; 'user-declared' is not defined; Not resolved. 2633; open; typeid of constexpr-unknown dynamic type; Not resolved. 2634; tentatively ready; Avoid circularity in specification of scope for friend class declarations; Unknown. 2635; C++23; Constrained structured bindings; Clang 16. 2636; C++23; Update Annex E based on Unicode 15.0 UAX #31; N/A. 2637; tentatively ready; Injected-class-name as a simple-template-id; Unknown. 2638; tentatively ready; Improve the example for initializing by initializer list; Unknown. 2639; C++23; new-lines after phase 1; Unknown. 2640; C++23; Allow more characters in an n-char sequence; Clang 16. 2641; C++23; Redundant specification of value category of literals; Unknown. 2642; C++23; Inconsistent use of T and C; N/A. 2643; C++23; Completing a pointer to array of unk,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:181181,Variab,Variables,181181,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Variab'],['Variables']
Modifiability,"isible context (e.g., function prototype, struct definition, etc.). .. _Default pointer types in typeof:. Default pointer types in ``typeof()``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When ``typeof()`` takes an expression, it respects the bounds annotation on; the expression type, including the bounds annotation is implcit. For example,; the global variable ``g`` in the following code is implicitly ``__single`` so; ``typeof(g)`` gets ``char *__single``. The similar is true for the parameter; ``p``, so ``typeof(p)`` returns ``void *__single``. The local variable ``l`` is; implicitly ``__bidi_indexable``, so ``typeof(l)`` becomes; ``int *__bidi_indexable``. .. code-block:: C. char *g; // typeof(g) == char *__single. void foo(void *p) {; // typeof(p) == void *__single. int *l; // typeof(l) == int *__bidi_indexable; }. When the type of expression has an ""external"" bounds annotation, e.g.,; ``__sized_by``, ``__counted_by``, etc., the compiler may report an error on; ``typeof`` if the annotation creates a dependency with another declaration or; variable. For example, the compiler reports an error on ``typeof(p1)`` shown in; the following code because allowing it can potentially create another type; dependent on the parameter ``size`` in a different context (Please note that an; external bounds annotation on a parameter may only refer to another parameter of; the same function). On the other hand, ``typeof(p2)`` works resulting in ``int; *__counted_by(10)``, since it doesn't depend on any other declaration. .. TODO: add a section describing constraints on external bounds annotations. .. code-block:: C. void foo(int *__counted_by(size) p1, size_t size) {; // typeof(p1) == int *__counted_by(size); // -> a compiler error as it tries to create another type; // dependent on `size`. int *__counted_by(10) p2; // typeof(p2) == int *__counted_by(10); // -> no error. }. When ``typeof()`` takes a type name, the compiler doesn't apply an implicit; bounds annotation on the named pointer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:26352,variab,variable,26352,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['variab'],['variable']
Modifiability,ism.cpp; openmp/libomptarget/DeviceRTL/src/Reduction.cpp; openmp/libomptarget/DeviceRTL/src/State.cpp; openmp/libomptarget/DeviceRTL/src/Synchronization.cpp; openmp/libomptarget/DeviceRTL/src/Tasking.cpp; openmp/libomptarget/DeviceRTL/src/Utils.cpp; openmp/libomptarget/include/Debug.h; openmp/libomptarget/include/device.h; openmp/libomptarget/include/DeviceEnvironment.h; openmp/libomptarget/include/interop.h; openmp/libomptarget/include/omptarget.h; openmp/libomptarget/include/omptargetplugin.h; openmp/libomptarget/include/rtl.h; openmp/libomptarget/include/SourceInfo.h; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.cpp; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.h; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.cpp; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.h; openmp/libomptarget/plugins/amdgpu/impl/hsa_api.h; openmp/libomptarget/plugins/amdgpu/impl/impl.cpp; openmp/libomptarget/plugins/amdgpu/impl/impl_runtime.h; openmp/libomptarget/plugins/amdgpu/impl/internal.h; openmp/libomptarget/plugins/amdgpu/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/libomptarget/plugins/remote/include/Utils.h; openmp/libomptarget/plugins/remote/server/OffloadingServer.cpp; openmp/libomptarget/plugins/remote/server/Server.cpp; openmp/libomptarget/plugins/remote/server/Server.h; openmp/libomptarget/plugins/remote/src/Client.cpp; openmp/libomptarget/plugins/remote/src/Client.h; openmp/libomptarget/plugins/v,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:407245,plugin,plugins,407245,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,"ist its contents. ``` {.cpp}; root[] TFile f (""hsimple.root"",""UPDATE""); root[] f.ls(); TFile** hsimple.root; TFile* hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; ```. It shows the two lines starting with **`TFile`** followed by four lines; starting with the word ""`KEY`"". The four keys tell us that there are; four objects on disk in this file. The syntax of the listing is:. ``` {.cpp}; KEY: <class> <variable>;<cycle number> <title>; ```. For example, the first line in the list means there is an object in the; file on disk, called `hpx`. It is of the class **`TH1F`**; (one-dimensional histogram of floating numbers). The object's title is; ""This is the `px` distribution"". If the line starts with `OBJ`, the; object is in memory. The \<class\> is the name of the ROOT class; (T-something). The \<variable\> is the name of the object. The cycle; number along with the variable name uniquely identifies the object. The; \<title\> is the string given in the constructor of the object as title. ![The structure of TFile](pictures/030000E8.png). The figure shows a **`TFile`** with five objects in the top directory; `(kObjA;1, kObjA;2, kObjB;1, kObjC;1` and `kObjD;1)`. `ObjA` is on file; twice with two different cycle numbers. It also shows four objects in; memory (`mObjE`, `mObjeF`, `mObjM`, `mObjL`). It also shows several; subdirectories. ### The Current Directory. When you create a **`TFile`** object, it becomes the current directory.; Therefore, the last file to be opened is always the current directory.; To check your current directory you can type:. ``` {.cpp}; root[] gDirectory->pwd(); Rint:/; ```. This means that the current directory is the ROOT session (`Rint`). When; you create a file, and repeat the command the file becomes the current; directory. ``` {.cpp}; root[] TFile f1(""AFile1.root"");; root[] gDirectory->pwd(); AFile1.root:/; ```. If you create ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:21681,variab,variable,21681,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['variab'],['variable']
Modifiability,"istributions are in the MathMore library and are defined in; the header file `Math/ProbFuncInv.h`. The following picture illustrates the available statistical functions; (PDF, CDF and quantiles) in the case of the normal distribution. ![PDF, CDF and quantiles in the case of the normal distribution](pictures/03000128.png). ## Numerical Algorithms. ROOT provides C++ classes implementing numerical algorithms to solve a wide set of problem, like:. * Evaluation of function derivatives.; * Evaluation of integrals.; * Finding the roots of a function; * Finding the minimum/maximum of a function. In order to use these algorithm the user needs to provide a function.; ROOT provides a common way of specifying them via some interfaces. ## ROOT::Math Function interfaces. To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function.; In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ![ROOT::Math Function interface structure](pictures/function-hierarchy.png). ### One-dimensional Function Interfaces. These interfaces are used for numerical algorithms operating only on one-dimensional functions and cannot be applied to multi-dimensional functions.; For this case the users needs to define a function object which evaluates in one dimension, and the object will have to derivate from the following:. * `ROOT::Math::IBaseFunctionOneDim`: This class is the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing; `double operator() (const double )`. The user class defined only needs to reimplement the pure abstract method `double DoEval(double x)`,; that will do the work of evaluating the function at point x. Example on how to create a class that represents a mathematical function. The user only has to override two methods from `IBaseFunction",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:35026,inherit,inherit,35026,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['inherit'],['inherit']
Modifiability,"isual Studio 2019 and Python 3.9.6:. 1. Download and install `Visual Studio <https://visualstudio.microsoft.com/>`_.; 2. In the Visual Studio installer, Workloads tab, select the; **Desktop development with C++** workload. Under Individual components tab,; select **Git for Windows**.; 3. Complete the Visual Studio installation.; 4. Download and install the latest `Python 3 release <http://www.python.org/>`_.; 5. In the first install screen, select both **Install launcher for all users**; and **Add Python to the PATH**. This will allow installing psutil for all; users for the regression tests and make Python available from the command; line.; 6. In the second install screen, select (again) **Install for all users** and; if you want to develop `lldb <https://lldb.llvm.org/>`_, selecting; **Download debug binaries** is useful.; 7. Complete the Python installation.; 8. Run a ""Developer Command Prompt for VS 2019"" **as administrator**. This command; prompt provides correct path and environment variables to Visual Studio and; the installed tools.; 9. In the terminal window, type the commands:. .. code-block:: bat. c:; cd \. You may install the llvm sources in other location than ``c:\llvm`` but do not; install into a path containing spaces (e.g. ``c:\Documents and Settings\...``); as it will fail. 10. Register the Microsoft Debug Interface Access (DIA) DLLs. .. code-block:: bat. regsvr32 ""%VSINSTALLDIR%\DIA SDK\bin\msdia140.dll""; regsvr32 ""%VSINSTALLDIR%\DIA SDK\bin\amd64\msdia140.dll"". The DIA library is required for LLVM PDB tests and; `LLDB development <https://lldb.llvm.org/resources/build.html>`_. 11. Install psutil and obtain LLVM source code:. .. code-block:: bat. pip install psutil; git clone https://github.com/llvm/llvm-project.git llvm. Instead of ``git clone`` you may download a compressed source distribution; from the `releases page <https://github.com/llvm/llvm-project/releases>`_.; Select the last link: ``Source code (zip)`` and unpack the downloaded file us",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst:3858,variab,variables,3858,interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,1,['variab'],['variables']
Modifiability,"isualization system can be used to render rich content such as images,; therefore bringing more interactivity into the Jupyter’s world. You can find; more information on `Xeus Cling's Read the Docs; <https://xeus-cling.readthedocs.io/en/latest/>`_ webpage. 2. **Interactive CUDA C++ with Cling:**. `CUDA <https://blogs.nvidia.com/blog/2012/09/10/what-is-cuda-2/>`_ is a platform; and Application Programming Interface (API) created by `NVIDIA; <https://www.nvidia.com/en-us/>`_. It controls `GPU; <https://en.wikipedia.org/wiki/Graphics_processing_unit>`_ (Graphical Processing; Unit) for parallel programming, enabling developers to harness the power of; graphic processing units (GPUs) to speed up applications. As an example,; `PIConGPU <https://github.com/ComputationalRadiationPhysics/picongpu>`_ is a; CUDA-based plasma physics application to solve the dynamics of a plasma by; computing the motion of electrons and ions in the plasma field. Interactive GPU; programming was made possible by extending Cling functionality to compile CUDA; C++ code. The new Cling-CUDA C++ can be used on Jupyter Notebook platform, and; enables big, interactive simulation with GPUs, easy GPU development and; debugging, and effective GPU programming learning. 3. **Clad:**. `Clad <https://compiler-research.org/clad/>`_ enables automatic differentiation; (AD) for C++. It was first developed as a plugin for Cling, and is now a plugin; for Clang compiler. Clad is based on source code transformation. Given C++; source code of a mathematical function, it can automatically generate C++ code; for computing derivatives of the function. It supports both forward-mode and; reverse-mode AD. 4. **Cling for live coding music and musical instruments:**. The artistic live coding community has been growing steadily since around the; year 2000. The Temporary Organisation for the Permanence of Live Art Programming; (TOPLAP) has been around since 2004, Algorave (algorithmic rave parties); recently celebrated its tenth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/applications.rst:1655,extend,extending,1655,interpreter/cling/docs/chapters/applications.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/applications.rst,1,['extend'],['extending']
Modifiability,"it BB3 after BB4. We can; then eliminate beq and turn the unconditional branch to LBB2 to a bne. See McCat/18-imp/ComputeBoundingBoxes for an example. //===---------------------------------------------------------------------===//. Pre-/post- indexed load / stores:. 1) We should not make the pre/post- indexed load/store transform if the base ptr; is guaranteed to be live beyond the load/store. This can happen if the base; ptr is live out of the block we are performing the optimization. e.g. mov r1, r2; ldr r3, [r1], #4; ... vs. ldr r3, [r2]; add r1, r2, #4; ... In most cases, this is just a wasted optimization. However, sometimes it can; negatively impact the performance because two-address code is more restrictive; when it comes to scheduling. Unfortunately, liveout information is currently unavailable during DAG combine; time. 2) Consider spliting a indexed load / store into a pair of add/sub + load/store; to solve #1 (in TwoAddressInstructionPass.cpp). 3) Enhance LSR to generate more opportunities for indexed ops. 4) Once we added support for multiple result patterns, write indexed loads; patterns instead of C++ instruction selection code. 5) Use VLDM / VSTM to emulate indexed FP load / store. //===---------------------------------------------------------------------===//. Implement support for some more tricky ways to materialize immediates. For; example, to get 0xffff8000, we can use:. mov r9, #&3f8000; sub r9, r9, #&400000. //===---------------------------------------------------------------------===//. We sometimes generate multiple add / sub instructions to update sp in prologue; and epilogue if the inc / dec value is too large to fit in a single immediate; operand. In some cases, perhaps it might be better to load the value from a; constantpool instead. //===---------------------------------------------------------------------===//. GCC generates significantly better code for this function. int foo(int StackPtr, unsigned char *Line, unsigned char *Stack, int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt:8934,Enhance,Enhance,8934,interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,1,['Enhance'],['Enhance']
Modifiability,"it is initialized as follows:. .. code-block:: c. struct __block_literal_1 __block_literal_1 = {; &_NSConcreteGlobalBlock,; (1<<28)|(1<<29), <uninitialized>,; __block_invoke_1,; &__block_descriptor_1; };. that is, a different address is provided as the first value and a particular; (1<<28) bit is set in the ``flags`` field, and otherwise it is the same as for; stack based ``Block`` literals. This is an optimization that can be used for; any ``Block`` literal that imports no ``const`` or ``__block`` storage; variables. Imported Variables; ==================. Variables of ``auto`` storage class are imported as ``const`` copies. Variables; of ``__block`` storage class are imported as a pointer to an enclosing data; structure. Global variables are simply referenced and not considered as; imported. Imported ``const`` copy variables; ---------------------------------. Automatic storage variables not marked with ``__block`` are imported as; ``const`` copies. The simplest example is that of importing a variable of type ``int``:. .. code-block:: c. int x = 10;; void (^vv)(void) = ^{ printf(""x is %d\n"", x); }; x = 11;; vv();. which would be compiled to:. .. code-block:: c. struct __block_literal_2 {; void *isa;; int flags;; int reserved;; void (*invoke)(struct __block_literal_2 *);; struct __block_descriptor_2 *descriptor;; const int x;; };. void __block_invoke_2(struct __block_literal_2 *_block) {; printf(""x is %d\n"", _block->x);; }. static struct __block_descriptor_2 {; unsigned long int reserved;; unsigned long int Block_size;; } __block_descriptor_2 = { 0, sizeof(struct __block_literal_2) };. and:. .. code-block:: c. struct __block_literal_2 __block_literal_2 = {; &_NSConcreteStackBlock,; (1<<29), <uninitialized>,; __block_invoke_2,; &__block_descriptor_2,; x; };. In summary, scalars, structures, unions, and function pointers are generally; imported as ``const`` copies with no need for helper functions. Imported ``const`` copy of ``Block`` reference; ----------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:7101,variab,variable,7101,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variable']
Modifiability,"it isRef = 1;; }. ``let`` --- override fields in classes or records; -------------------------------------------------. A ``let`` statement collects a set of field values (sometimes called; *bindings*) and applies them to all the classes and records defined by; statements within the scope of the ``let``. .. productionlist::; Let: ""let"" `LetList` ""in"" ""{"" `Statement`* ""}""; :| ""let"" `LetList` ""in"" `Statement`; LetList: `LetItem` ("","" `LetItem`)*; LetItem: `TokIdentifier` [""<"" `RangeList` "">""] ""="" `Value`. The ``let`` statement establishes a scope, which is a sequence of statements; in braces or a single statement with no braces. The bindings in the; :token:`LetList` apply to the statements in that scope. The field names in the :token:`LetList` must name fields in classes inherited by; the classes and records defined in the statements. The field values are; applied to the classes and records *after* the records inherit all the fields from; their parent classes. So the ``let`` acts to override inherited field; values. A ``let`` cannot override the value of a template argument. Top-level ``let`` statements are often useful when a few fields need to be; overridden in several records. Here are two examples. Note that ``let``; statements can be nested. .. code-block:: text. let isTerminator = true, isReturn = true, isBarrier = true, hasCtrlDep = true in; def RET : I<0xC3, RawFrm, (outs), (ins), ""ret"", [(X86retflag 0)]>;. let isCall = true in; // All calls clobber the non-callee saved registers...; let Defs = [EAX, ECX, EDX, FP0, FP1, FP2, FP3, FP4, FP5, FP6, ST0,; MM0, MM1, MM2, MM3, MM4, MM5, MM6, MM7, XMM0, XMM1, XMM2,; XMM3, XMM4, XMM5, XMM6, XMM7, EFLAGS] in {; def CALLpcrel32 : Ii32<0xE8, RawFrm, (outs), (ins i32imm:$dst, variable_ops),; ""call\t${dst:call}"", []>;; def CALL32r : I<0xFF, MRM2r, (outs), (ins GR32:$dst, variable_ops),; ""call\t{*}$dst"", [(X86call GR32:$dst)]>;; def CALL32m : I<0xFF, MRM2m, (outs), (ins i32mem:$dst, variable_ops),; ""call\t{*}$dst"", []>;; }. N",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:33662,inherit,inherited,33662,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inherited']
Modifiability,"it was not because it was; stuffed directly into bar()"". The checker's direct responsibility, however, is to solve the ``*b == 2`` thing; (which is in fact the problem we're dealing with in this patch - escaping the; storage region of the object). So we're talking about one more operation over the program state (scanning; reachable symbols and regions) that cannot work without checker support. We can probably add a new callback ""checkReachableSymbols"" to solve this. This; is in fact also related to the dead symbols problem (we're scanning for live; symbols in the store and in the checkers separately, but we need to do so; simultaneously with a single worklist). Hmm, in fact this sounds like a good; idea; we can replace checkLiveSymbols with checkReachableSymbols. Or we could just have ghost member variables, and no checker support required at; all. For ghost member variables, the relation with their parent region (which; would be their superregion) is actually useful, the mutability of their contents; is expressed naturally, and the store automagically sees reachable symbols, live; symbols, escapes, invalidations, whatever. > In my view this differs from ghost variables in that (1) this storage does; > actually exist (it is just a library implementation detail where that storage; > lives) and (2) it is perfectly valid for a pointer into that storage to be; > returned and for another part of the program to read or write from that; > storage. (Well, in this case just read since it is allowed to be read-only; > memory). > What I'm not OK with is modeling abstract analysis state (for example, the; > count of a NSMutableArray or the typestate of a file handle) as a value stored; > in some ginned up region in the store.This takes an easy problem that the; > analyzer does well at (modeling typestate) and turns it into a hard one that; > the analyzer is bad at (reasoning about the contents of the heap). Yeah, i tend to agree on that. For simple typestates, this is probably a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:13671,variab,variables,13671,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['variab'],['variables']
Modifiability,"it` identifies test suites as directories containing ``lit.cfg`` or; ``lit.site.cfg`` files (see also :option:`--config-prefix`). Test suites are; initially discovered by recursively searching up the directory hierarchy for; all the input files passed on the command line. You can use; :option:`--show-suites` to display the discovered test suites at startup. Once a test suite is discovered, its config file is loaded. Config files; themselves are Python modules which will be executed. When the config file is; executed, two important global variables are predefined:. **lit_config**. The global **lit** configuration object (a *LitConfig* instance), which defines; the builtin test formats, global configuration parameters, and other helper; routines for implementing test configurations. **config**. This is the config object (a *TestingConfig* instance) for the test suite,; which the config file is expected to populate. The following variables are also; available on the *config* object, some of which must be set by the config and; others are optional or predefined:. **name** *[required]* The name of the test suite, for use in reports and; diagnostics. **test_format** *[required]* The test format object which will be used to; discover and run tests in the test suite. Generally this will be a builtin test; format available from the *lit.formats* module. **test_source_root** The filesystem path to the test suite root. For out-of-dir; builds this is the directory that will be scanned for tests. **test_exec_root** For out-of-dir builds, the path to the test suite root inside; the object directory. This is where tests will be run and temporary output files; placed. **environment** A dictionary representing the environment to use when executing; tests in the suite. **standalone_tests** When true, mark a directory with tests expected to be run; standalone. Test discovery is disabled for that directory. *lit.suffixes* and; *lit.excludes* must be empty when this variable is true. **s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:15363,variab,variables,15363,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,3,"['config', 'variab']","['config', 'variables']"
Modifiability,"ite. **XPASS**. The test succeeded, but it was expected to fail. This is used for tests which; were specified as expected to fail, but are now succeeding (generally because; the feature they test was broken and has been fixed). **FAIL**. The test failed. **UNRESOLVED**. The test result could not be determined. For example, this occurs when the test; could not be run, the test itself is invalid, or the test was interrupted. **UNSUPPORTED**. The test is not supported in this environment. This is used by test formats; which can report unsupported tests. **TIMEOUT**. The test was run, but it timed out before it was able to complete. This is; considered a failure. Depending on the test format tests may produce additional information about; their status (generally only for failures). See the :ref:`output-options`; section for more information. .. _lit-infrastructure:. LIT INFRASTRUCTURE; ------------------. This section describes the :program:`lit` testing architecture for users interested in; creating a new :program:`lit` testing implementation, or extending an existing one. :program:`lit` proper is primarily an infrastructure for discovering and running; arbitrary tests, and to expose a single convenient interface to these; tests. :program:`lit` itself doesn't know how to run tests, rather this logic is; defined by *test suites*. TEST SUITES; ~~~~~~~~~~~. As described in :ref:`test-discovery`, tests are always located inside a *test; suite*. Test suites serve to define the format of the tests they contain, the; logic for finding those tests, and any additional information to run the tests. :program:`lit` identifies test suites as directories containing ``lit.cfg`` or; ``lit.site.cfg`` files (see also :option:`--config-prefix`). Test suites are; initially discovered by recursively searching up the directory hierarchy for; all the input files passed on the command line. You can use; :option:`--show-suites` to display the discovered test suites at startup. Once a test suit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:13858,extend,extending,13858,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['extend'],['extending']
Modifiability,"ite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple represents, in the statistical; sense, three independent variables (Potential or Voltage, Pressure and; Temperature), and one variable (Current) which depends on the others; according to very simple laws, and an additional Gaussian smearing. This; set of variables mimics a measurement of an electrical resistance while; varying pressure and temperature. Imagine your task now consists in finding the relations among the; variables -- of course without knowing the code used to generate them.; You will see that the possibilities of the `NTuple` class enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session and use a; `TBrowser` to interactively inspect it:. ``` {.cpp}; root[0] TBrowser b; ```; You find the columns of your n-tuple written as *leafs*. Simply clicking; on them you can obtain histograms of the variables!. Next, try the following commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1] cond_data->Draw(""Current:Potential"",""Temperature<270""); ```. What do you obtain ?. Now try. ``` {.cpp}; root [2] cond_data-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:2757,variab,variables,2757,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['variab'],['variables']
Modifiability,"itectures on your system:. .. code-block:: shell. clang++ --offload-arch=native -xhip sample.cpp -o sample. Path Setting for Dependencies; =============================. Compiling a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the compiler options as the primary method for specifying these paths. While the environment variables ``ROCM_PATH``, ``HIP_PATH``, and ``HIP_DEVICE_LIB_PATH`` are supported, their use can lead to implicit dependencies that might",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4468,variab,variable,4468,interpreter/llvm-project/clang/docs/HIPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst,1,['variab'],['variable']
Modifiability,"iterals. .. code-block:: c++. true:; return ""Code""; ""\0\52\26\55\55\0""; ""x013""; ""\02\xBA"";; false:; return ""Code"" ""\0\52\26\55\55\0"" ""x013"" ""\02\xBA"";. .. _BreakAfterAttributes:. **BreakAfterAttributes** (``AttributeBreakingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <BreakAfterAttributes>`; Break after a group of C++11 attributes before variable or function; (including constructor/destructor) declaration/definition names or before; control statements, i.e. ``if``, ``switch`` (including ``case`` and; ``default`` labels), ``for``, and ``while`` statements. Possible values:. * ``ABS_Always`` (in configuration: ``Always``); Always break after attributes. .. code-block:: c++. [[maybe_unused]]; const int i;; [[gnu::const]] [[maybe_unused]]; int j;. [[nodiscard]]; inline int f();; [[gnu::const]] [[nodiscard]]; int g();. [[likely]]; if (a); f();; else; g();. switch (b) {; [[unlikely]]; case 1:; ++b;; break;; [[likely]]; default:; return;; }. * ``ABS_Leave`` (in configuration: ``Leave``); Leave the line breaking after attributes as is. .. code-block:: c++. [[maybe_unused]] const int i;; [[gnu::const]] [[maybe_unused]]; int j;. [[nodiscard]] inline int f();; [[gnu::const]] [[nodiscard]]; int g();. [[likely]] if (a); f();; else; g();. switch (b) {; [[unlikely]] case 1:; ++b;; break;; [[likely]]; default:; return;; }. * ``ABS_Never`` (in configuration: ``Never``); Never break after attributes. .. code-block:: c++. [[maybe_unused]] const int i;; [[gnu::const]] [[maybe_unused]] int j;. [[nodiscard]] inline int f();; [[gnu::const]] [[nodiscard]] int g();. [[likely]] if (a); f();; else; g();. switch (b) {; [[unlikely]] case 1:; ++b;; break;; [[likely]] default:; return;; }. .. _BreakAfterJavaFieldAnnotations:. **BreakAfterJavaFieldAnnotations** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <BreakAfterJavaFieldAnnotations>`; Break after each annotation on a field in Java files. .. code-block:: java. true: false:; @Partial vs. @Partial @Mock DataLoad loader;; @Mock; Dat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:44526,config,configuration,44526,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ith C++ Modules which is important but; unfair comparison. As we noted earlier, PCH is very efficient, it cannot be; extended to the experiments’ software stacks because of its design constraints.; On the contrary, the C++ Modules can be used in third-party code where the PCH; is not available. The comparisons are to give a good metric when we are ready to switch ROOT to use; C++ Modules by default. However, since it is essentially the same technology,; optimizations of C++ Modules also affect the PCH. We have a few tricks up in; the sleeves to but they come with given trade-offs. #### Preloading of C++ Modules. The main focus for the technology preview was not in performance until recently.; We have invested some resources in optimizations and we would like to show you; (probably outdated) performance results:. * Memory footprint -- mostly due to importing all C++ Modules at startup; we see overhead which depends on the number of preloaded modules. For; ROOT it is between 40-60 MB depending on the concrete configuration.; When the workload increases we notice that the overall memory performance; decreases in number of cases.; * Execution times -- likewise we have an execution overhead. For ; workflows which take ms the slowdown can be 2x. Increasing of the work; to seconds shows 50-60% slowdowns. The performance is dependent on many factors such as configuration of ROOT and; workflow. You can read more at our Intel IPCC-ROOT Showcase presentation; here (pp 25-33)[[8]]. #### Loading C++ Modules on Demand. In long term, we should optimize the preloading of modules to be a no-op and; avoid recursive behavior based on identifier lookup callbacks. Unfortunately,; at the moment the loading of C++ modules on demand shows significantly better; performance results. You can visit our continuous performance monitoring tool where we compare; the performance of ROOT against ROOT with a PCH [[9]].; *Note: if you get error 400, clean your cache or open a private browser session.*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:18375,config,configuration,18375,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['config'],['configuration']
Modifiability,"ith RNTuple I/O support.; The child fields are named `_0` and `_1`. #### std::tuple<T1, T2, ..., Tn>. A tuple is stored using an empty parent field with $n$ subfields of type `T1`, `T2`, ..., `Tn`.; All types must have RNTuple I/O support.; The child fields are named `_0`, `_1`, ... #### std::bitset\<N\>. A bitset is stored as a repetitive leaf field with an attached `Bit` column.; The bitset size `N` is stored as repetition parameter in the field meta-data.; Within the repetition blocks, bits are stored in little-endian order, i.e. the least significant bits come first. #### std::unique_ptr\<T\>, std::optional\<T\>. A unique pointer and an optional type have the same on disk representation.; They are represented as a collection of `T`s of zero or one elements.; The collection parent field has a principal column of type `(Split)Index[64|32]`.; It has a single subfield named `_0` for `T`, where `T` must have RNTuple I/O support.; Note that RNTuple does not support polymorphism, so the type `T` is expected to be `T` and not a child class of `T`. #### std::set\<T\>, std::unordered_set\<T\>, std::multiset\<T\>, std::unordered_multiset\<T\>. While STL (unordered) (multi)sets by definition are associative containers; (i.e., elements are referenced by their keys, which in the case for sets are equal to the values),; on disk they are represented as sequential collections.; This means that they have the same on-disk representation as `std::vector<T>`, using two fields:; - Collection parent field whose principal column is of type `(Split)Index[64|32]`.; - Child field of type `T`, which must be a type with RNTuple I/O support.; The name of the child field is `_0`. #### std::map\<K, V\>, std::unordered_map\<K, V\>, std::multimap\<K, V\>, std::unordered_multimap\<K, V\>. An (unordered) (multi)map is stored using a collection parent field,; whose principal column is of type `(Split)Index[64|32]` and a child field of type `std::pair<K, V>` named `_0`. ### std::atomic\<T\>. Atomic ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:43014,polymorphi,polymorphism,43014,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['polymorphi'],['polymorphism']
Modifiability,"ith it. We; open the file with the intent to update it, and list its contents. ``` {.cpp}; root[] TFile f (""hsimple.root"",""UPDATE""); root[] f.ls(); TFile** hsimple.root; TFile* hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; ```. It shows the two lines starting with **`TFile`** followed by four lines; starting with the word ""`KEY`"". The four keys tell us that there are; four objects on disk in this file. The syntax of the listing is:. ``` {.cpp}; KEY: <class> <variable>;<cycle number> <title>; ```. For example, the first line in the list means there is an object in the; file on disk, called `hpx`. It is of the class **`TH1F`**; (one-dimensional histogram of floating numbers). The object's title is; ""This is the `px` distribution"". If the line starts with `OBJ`, the; object is in memory. The \<class\> is the name of the ROOT class; (T-something). The \<variable\> is the name of the object. The cycle; number along with the variable name uniquely identifies the object. The; \<title\> is the string given in the constructor of the object as title. ![The structure of TFile](pictures/030000E8.png). The figure shows a **`TFile`** with five objects in the top directory; `(kObjA;1, kObjA;2, kObjB;1, kObjC;1` and `kObjD;1)`. `ObjA` is on file; twice with two different cycle numbers. It also shows four objects in; memory (`mObjE`, `mObjeF`, `mObjM`, `mObjL`). It also shows several; subdirectories. ### The Current Directory. When you create a **`TFile`** object, it becomes the current directory.; Therefore, the last file to be opened is always the current directory.; To check your current directory you can type:. ``` {.cpp}; root[] gDirectory->pwd(); Rint:/; ```. This means that the current directory is the ROOT session (`Rint`). When; you create a file, and repeat the command the file becomes the current; directory. ``` {.cpp}; root[] TFile f1(""AFile1.root"");",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:21610,variab,variable,21610,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['variab'],['variable']
Modifiability,"ith the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file_advanced.C; ```. The `Branch()` function requires a pointer to a variable and a; definition of the variable type. The following table lists some of the possible; values.; Please note that ROOT is not checking the input and mistakes are likely; to result in serious problems. This holds especially if values are read; as another type than they have been written, e.g. when storing a; variable as float and reading it as double. List of variable types that can be used to define the type of a branch in ROOT:. type size C++ identifier; ------------------ -------- --------------- ------------; signed integer 32 bit int I; 64 bit long L; unsigned integer 32 bit unsigned int i; 64 bit unsigned long l; floating point 32 bit float F; 64 bit double D; boolean - bool O. ### Processing N-tuples Spanning over Several Files ###. Usually n-tuples or trees span over many files and it would be difficult; to add them manually. ROOT thus kindly provides a helper class in the; form of `TChain`. Its usage is shown in the following macro which is; very similar to the previous example. The constructor of a `TChain`; takes the name of the `TTree` (or `TNuple`) as an argument. The files; are added with the function `Add(fileName)`, where one can also use; wild-cards as shown in the example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_with_chain.C; ```. ### *For the advanced user:* Processing tree",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:5324,variab,variable,5324,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['variab'],['variable']
Modifiability,"ith; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fs",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:78492,variab,variables,78492,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variables']
Modifiability,"ithIntArgument[10])(int);. Variadic ``...`` arguments are supported. [variadic.c] A Block that; takes no arguments must specify void in the argument list [voidarg.c].; An empty parameter list does not represent, as K&R provide, an; unspecified argument list. Note: both gcc and clang support K&R style; as a convenience. A Block reference may be cast to a pointer of arbitrary type and vice; versa. [cast.c] A Block reference may not be dereferenced via the; pointer dereference operator ``*``, and thus a Block's size may not be; computed at compile time. [sizeof.c]. Block Literal Expressions; =========================. A :block-term:`Block literal expression` produces a reference to a; Block. It is introduced by the use of the ``^`` token as a unary; operator. .. code-block:: c. Block_literal_expression ::= ^ block_decl compound_statement_body; block_decl ::=; block_decl ::= parameter_list; block_decl ::= type_expression. where type expression is extended to allow ``^`` as a Block reference; (pointer) where ``*`` is allowed as a function reference (pointer). The following Block literal:. .. code-block:: c. ^ void (void) { printf(""hello world\n""); }. produces a reference to a Block with no arguments with no return value. The return type is optional and is inferred from the return; statements. If the return statements return a value, they all must; return a value of the same type. If there is no value returned the; inferred type of the Block is void; otherwise it is the type of the; return statement value. If the return type is omitted and the argument list is ``( void )``,; the ``( void )`` argument list may also be omitted. So:. .. code-block:: c. ^ ( void ) { printf(""hello world\n""); }. and:. .. code-block:: c. ^ { printf(""hello world\n""); }. are exactly equivalent constructs for the same expression. The type_expression extends C expression parsing to accommodate Block; reference declarations as it accommodates function pointer; declarations. Given:. .. code-block:: c. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:2703,extend,extended,2703,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['extend'],['extended']
Modifiability,"ithm, hsv modulo color component [15]. int bar_thickness; // applies only for bar display mode; int bar_empty_flag; // (empty bars, full bars) applies only for bar display mode; int border_color; // color of background of the picture; int full_border; // decides whether background is painted; int raster_en_dis; // decides whether the axes and rasters are shown; int raster_long; // decides whether the rasters are drawn as long lines; int raster_color; // color of the rasters; char *raster_description_x; // x axis description; char *raster_description_y; // y axis description. int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line. int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_color; // color of channel marks. // auxiliary variables, transform coefficients, for internal use only; double mx;; double my;; double px;; double py;. // auxiliary internal variables, working place; double gbezx,gbezy;; TPoint bz[4];; };; ```. The examples using different display parameters are shown in the next; few Figures. ![Display mode -polyline, width of pen=3](figures/image214.png). ![Display mode- bars, shown channel marks](figures/image216.png). ![Display mode- steps, log scale, shown channel marks](figures/image218.png). ![Display mode -Bezier curve interpolation, shown channel marks](figures/image220.png). ![Display mode- rainbow bars, color algorithm (model) RGB, number of color levels=1024, pen width=3](figures/image222.png). ![Display mode-empty bars, color algorithm YIQ, number of color levels 2048](figures/image224.png). ## 2-DIMENSIONAL SPECTRA. The 2-dimensional visualization function displays spectrum; (or its part) on the Canvas of a form. Before calling the function, one; has to fill in the `two_dim_pic` structure containing all parameters of the; displa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:73914,variab,variables,73914,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['variab'],['variables']
Modifiability,"itional flags might also be necessary. Your linked binary should now make use of the Scudo allocation and deallocation; functions. You may also build Scudo like this:. .. code:: console. cd $LLVM/compiler-rt/lib; clang++ -fPIC -std=c++17 -msse4.2 -O2 -pthread -shared \; -I scudo/standalone/include \; scudo/standalone/*.cpp \; -o $HOME/libscudo.so. and then use it with existing binaries as follows:. .. code:: console. LD_PRELOAD=$HOME/libscudo.so ./a.out. Clang; -----; With a recent version of Clang (post rL317337), the ""old"" version of the; allocator can be linked with a binary at compilation using the; ``-fsanitize=scudo`` command-line argument, if the target platform is supported.; Currently, the only other sanitizer Scudo is compatible with is UBSan; (eg: ``-fsanitize=scudo,undefined``). Compiling with Scudo will also enforce; PIE for the output binary. We will transition this to the standalone Scudo version in the future. Options; -------; Several aspects of the allocator can be configured on a per process basis; through the following ways:. - at compile time, by defining ``SCUDO_DEFAULT_OPTIONS`` to the options string; you want set by default;. - by defining a ``__scudo_default_options`` function in one's program that; returns the options string to be parsed. Said function must have the following; prototype: ``extern ""C"" const char* __scudo_default_options(void)``, with a; default visibility. This will override the compile time define;. - through the environment variable SCUDO_OPTIONS, containing the options string; to be parsed. Options defined this way will override any definition made; through ``__scudo_default_options``. - via the standard ``mallopt`` `API <https://man7.org/linux/man-pages/man3/mallopt.3.html>`_,; using parameters that are Scudo specific. When dealing with the options string, it follows a syntax similar to ASan, where; distinct options can be assigned in the same string, separated by colons. For example, using the environment variable:. .. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:7094,config,configured,7094,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['config'],['configured']
Modifiability,"itle positioning to native ROOT behavior; 8. Add interactivity (moving, context menu) for TLine, TBox, TText, TLatex, TDiamond, TGaxis, TASImage; 9. Use new gStyle attributes for candle and violin plots; 10. Implement autoplace for TLegend, also via context menu; 11. Change algorithm of building smooth (bezier) curves; 12. Let change physical node visibility in TGeo drawings; 13. Use TGaxis attributes from gStyle - fAxisMaxDigits, fStripDecimals and exponent offset; 14. Implement ""projxy"" draw option for TH2 - like projxy3 or projx1_y5; 15. Support custom function in TGaxis - when drawn in TWebCanvas; 16. Introduce settings.WithCredentials, set xhr.withCredentials = true when submitting HTTP requests; 17. Let superimpose TH3 and geo drawings; 18. Apply pad draw options like 'gridx' or 'logy' to all subpads; 19. Support new TScatter and TAnnotation classes; 20. Implement moving and resizing of subpads; 21. Implement zooming in the TASImage; 22. Let configure position and direction of camera for TGeo, let create URL for that; 23. Support labels rotation for simple axis in geometry; 24. Support many orthographic cameras with overlayed grid/labels; 25. Support InstancedMesh for TGeo drawing, let show really large geometries; 26. Implement 'inject=path/script_name.js' url option to inject scripts without emulating of v6; 27. Exclude 'HEAD' http request when reading ROOT file, all necessary info can be get from first real HTTP request; 28. Provide makeImage function for generation of svg, png and jpeg images in batch and interactively (#257); 29. Implement interactive zoom shifting when middle-mouse button down or single-touch moving; 30. Several improvements for touch devices or devices with small displays; 31. Remove settings.FrameNDC, use Style.fPadLeft/Right/Top/BottomMargin values instead; 32. Fix - rescan sumw2 when update TH1; 33. Fix - correct placing for TLegend header; 34. Fix - correctly align sub/super scripts in complex TLatex; 35. Fix - correctly set visibil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:13346,config,configure,13346,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['config'],['configure']
Modifiability,"itle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <https://wiki.sei.cmu.edu/confluence/display/c/ENV03-C.+Sanitize+the+environment+when+invoking+external+programs>`_. **Limitations**. * The taintedness property is not propagated through function calls which are; unknown (or too complex) to the analyzer, unless there is a specific; propagation rule built-in to the checker or given in the YAML configuration",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:73390,config,configuration-example,73390,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['config'],['configuration-example']
Modifiability,"ity = ROOT::Experimental::RLogScopedVerbosity(ROOT::Detail::RDF::RDFLogChannel(), ROOT::Experimental::ELogLevel.kInfo);`.; - With [ROOT-10023](https://sft.its.cern.ch/jira/browse/ROOT-10023) fixed, `RDataFrame` can now read and write certain branches containing unsplit objects, i.e. `TBranchObjects`. More information is available at [ROOT-10022](https://sft.its.cern.ch/jira/browse/ROOT-10022).; - CSV files can now be opened and processed from remote HTTP(S) locations; - `RDataFrame` results produced by the same action in different computation graphs can now be merged thanks to the new interface provided by `ROOT::Detail::RDF::RMergeableValue`, introduced in [#5552](https://github.com/root-project/root/pull/5552). A feature originally requested with [ROOT-9869](https://sft.its.cern.ch/jira/browse/ROOT-9869), it helps streamline `RDataFrame` workflows in a distributed environment. Currently only a subset of `RDataFrame` actions have their corresponding mergeable class, but in the future it will be possible to extend it to any action through the creation of a new `RMergeableValue` derived class. ### Behavior changes. - `Snapshot` now respects the basket size and split level of the original branch when copying branches to a new `TTree`.; - `Snapshot` now writes branches coming from friend `TTree`s even if they have the same name as branches in the main tree (`friendname_` is prepended to the name of the output branches). More details at [#7181](https://github.com/root-project/root/issues/7181).; - Just-in-time compilation of string expressions passed to `Filter` and `Define` now generates functions that take fundamental types by const value (rather than by non-const reference as before). This will break code that was assigning to column values in string expressions: this is an intended side effect as we want to prevent non-expert users from performing assignments (`=`) rather than comparisons (`==`). Expert users can resort to compiled callables if they absolutely have ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:7602,extend,extend,7602,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['extend'],['extend']
Modifiability,"ity refer to the; same object if they are in the same shared object. Usually, hidden; visibility indicates that the symbol will not be placed into the; dynamic symbol table, so no other module (executable or shared; library) can reference it directly.; ""``protected``"" - Protected style; On ELF, protected visibility indicates that the symbol will be; placed in the dynamic symbol table, but that references within the; defining module will bind to the local symbol. That is, the symbol; cannot be overridden by another module. A symbol with ``internal`` or ``private`` linkage must have ``default``; visibility. .. _dllstorageclass:. DLL Storage Classes; -------------------. All Global Variables, Functions and Aliases can have one of the following; DLL storage class:. ``dllimport``; ""``dllimport``"" causes the compiler to reference a function or variable via; a global pointer to a pointer that is set up by the DLL exporting the; symbol. On Microsoft Windows targets, the pointer name is formed by; combining ``__imp_`` and the function or variable name.; ``dllexport``; On Microsoft Windows targets, ""``dllexport``"" causes the compiler to provide; a global pointer to a pointer in a DLL, so that it can be referenced with the; ``dllimport`` attribute. the pointer name is formed by combining ``__imp_``; and the function or variable name. On XCOFF targets, ``dllexport`` indicates; that the symbol will be made visible to other modules using ""exported""; visibility and thus placed by the linker in the loader section symbol table.; Since this storage class exists for defining a dll interface, the compiler,; assembler and linker know it is externally referenced and must refrain from; deleting the symbol. A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage; class. .. _tls_model:. Thread Local Storage Models; ---------------------------. A variable may be defined as ``thread_local``, which means that it will; not be shared by threads (each thread will have a separat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:24797,variab,variable,24797,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"ivating example that shows how we could use these:. ::. # Define ':' for sequencing: as a low-precedence operator that ignores operands; # and just returns the RHS.; def binary : 1 (x y) y;. # Recursive fib, we could do this before.; def fib(x); if (x < 3) then; 1; else; fib(x-1)+fib(x-2);. # Iterative fib.; def fibi(x); var a = 1, b = 1, c in; (for i = 3, i < x in; c = a + b :; a = b :; b = c) :; b;. # Call it.; fibi(10);. In order to mutate variables, we have to change our existing variables; to use the ""alloca trick"". Once we have that, we'll add our new; operator, then extend Kaleidoscope to support new variable definitions. Adjusting Existing Variables for Mutation; =========================================. The symbol table in Kaleidoscope is managed at code generation time by; the '``NamedValues``' map. This map currently keeps track of the LLVM; ""Value\*"" that holds the double value for the named variable. In order; to support mutation, we need to change this slightly, so that; ``NamedValues`` holds the *memory location* of the variable in question.; Note that this change is a refactoring: it changes the structure of the; code, but does not (by itself) change the behavior of the compiler. All; of these changes are isolated in the Kaleidoscope code generator. At this point in Kaleidoscope's development, it only supports variables; for two things: incoming arguments to functions and the induction; variable of 'for' loops. For consistency, we'll allow mutation of these; variables in addition to other user-defined variables. This means that; these will both need memory locations. To start our transformation of Kaleidoscope, we'll change the; ``NamedValues`` map so that it maps to AllocaInst\* instead of Value\*. Once; we do this, the C++ compiler will tell us what parts of the code we need; to update:. .. code-block:: c++. static std::map<std::string, AllocaInst*> NamedValues;. Also, since we will need to create these allocas, we'll use a helper; function that e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:11893,variab,variable,11893,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"ivative(double x) const; {; return -cos(x);; }. };; ```. ### Multi-dimensional Function Interfaces. The most generic case of a multidimensional function has similar approach. Some examples will be shown next. It is important to notice, that one dimensional functions can be also implemented through; the interfaces that will be presented here. Nevertheless, the user needs to implement those following the indications of the previous chapter, for algorithm working exclusivly on one-dimensional; functions. For algorithms working on both one-dimensional and multi-dimensional functions they should instead use this interface. * `ROOT::Math::IBaseFunctionMultiDim`: This interface provides the `double operator() (const double*)` that takes an array of doubles with all the values for the different dimensions. In this case,; the user has to provide the functionality for two different functions: `double DoEval(const double*)` and `unsigned int NDim()`. The first ones evaluates the function given the array that represents; the multiple variables. The second returns the number of dimensions of the function. Example of implementing a basic multi-dimensional function:. ```{.cpp}; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionMultiDim; {; public:; double DoEval(const double* x) const; {; return x[0] + sin(x[1]);; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IBaseFunctionMultiDim* Clone() const; {; return new MyFunction();; }. };; ```. * `ROOT::Math::IGradientFunctionMultiDim`: This interface offers the same functionality as the base function plus the calculation of the derivative.; It only adds the `double Derivative(double* x, uint ivar)` method for the user to implement. This method must implement the derivative of the function with respect to the variable indicated with the; second parameter. Example of implementing a multi-dimensional gradient function. ```{.cpp}; #include ""Math/IFunction.h"". class MyGradientFunction: public ROOT::Mat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:38156,variab,variables,38156,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['variab'],['variables']
Modifiability,"ive run-loop (with a JIT!), and emitted debug information in; standalone executables - all in under 1000 lines of (non-comment/non-blank); code. Our little language supports a couple of interesting features: it; supports user defined binary and unary operators, it uses JIT; compilation for immediate evaluation, and it supports a few control flow; constructs with SSA construction. Part of the idea of this tutorial was to show you how easy and fun it; can be to define, build, and play with languages. Building a compiler; need not be a scary or mystical process! Now that you've seen some of; the basics, I strongly encourage you to take the code and hack on it.; For example, try adding:. - **global variables** - While global variables have questionable value; in modern software engineering, they are often useful when putting; together quick little hacks like the Kaleidoscope compiler itself.; Fortunately, our current setup makes it very easy to add global; variables: just have value lookup check to see if an unresolved; variable is in the global variable symbol table before rejecting it.; To create a new global variable, make an instance of the LLVM; ``GlobalVariable`` class.; - **typed variables** - Kaleidoscope currently only supports variables; of type double. This gives the language a very nice elegance, because; only supporting one type means that you never have to specify types.; Different languages have different ways of handling this. The easiest; way is to require the user to specify types for every variable; definition, and record the type of the variable in the symbol table; along with its Value\*.; - **arrays, structs, vectors, etc** - Once you add types, you can start; extending the type system in all sorts of interesting ways. Simple; arrays are very easy and are quite useful for many different; applications. Adding them is mostly an exercise in learning how the; LLVM `getelementptr <../../LangRef.html#getelementptr-instruction>`_ instruction; works: it is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:1621,variab,variables,1621,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,3,['variab'],"['variable', 'variables']"
Modifiability,"ive-C Language Features; =============================. .. _objcxx:. Objective-C++ Language Features; ===============================. .. _openmp:. OpenMP Features; ===============. Clang supports all OpenMP 4.5 directives and clauses. See :doc:`OpenMPSupport`; for additional details. Use `-fopenmp` to enable OpenMP. Support for OpenMP can be disabled with; `-fno-openmp`. Use `-fopenmp-simd` to enable OpenMP simd features only, without linking; the runtime library; for combined constructs; (e.g. ``#pragma omp parallel for simd``) the non-simd directives and clauses; will be ignored. This can be disabled with `-fno-openmp-simd`. Controlling implementation limits; ---------------------------------. .. option:: -fopenmp-use-tls. Controls code generation for OpenMP threadprivate variables. In presence of; this option all threadprivate variables are generated the same way as thread; local variables, using TLS support. If `-fno-openmp-use-tls`; is provided or target does not support TLS, code generation for threadprivate; variables relies on OpenMP runtime library. .. _opencl:. OpenCL Features; ===============. Clang can be used to compile OpenCL kernels for execution on a device; (e.g. GPU). It is possible to compile the kernel into a binary (e.g. for AMDGPU); that can be uploaded to run directly on a device (e.g. using; `clCreateProgramWithBinary; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.1.pdf#111>`_) or; into generic bitcode files loadable into other toolchains. Compiling to a binary using the default target from the installation can be done; as follows:. .. code-block:: console. $ echo ""kernel void k(){}"" > test.cl; $ clang test.cl. Compiling for a specific target can be done by specifying the triple corresponding; to the target, for example:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl; $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. Compiling to bitcode can be done as follows:. .. code-block:: console. $ clang -c ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:140310,variab,variables,140310,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variables']
Modifiability,"iver. ``%clang_cpp``; Invokes the Clang driver for C++. ``%clang_cl``; Invokes the CL-compatible Clang driver. ``%clangxx``; Invokes the G++-compatible Clang driver. ``%clang_cc1``; Invokes the Clang frontend. ``%itanium_abi_triple``, ``%ms_abi_triple``; These substitutions can be used to get the current target triple adjusted to; the desired ABI. For example, if the test suite is running with the; ``i686-pc-win32`` target, ``%itanium_abi_triple`` will expand to; ``i686-pc-mingw32``. This allows a test to run with a specific ABI without; constraining it to a specific triple. **FileCheck-specific substitutions:**. ``%ProtectFileCheckOutput``; This should precede a ``FileCheck`` call if and only if the call's textual; output affects test results. It's usually easy to tell: just look for; redirection or piping of the ``FileCheck`` call's stdout or stderr. .. _Test-specific substitutions:. **Test-specific substitutions:**. Additional substitutions can be defined as follows:. - Lit configuration files (e.g., ``lit.cfg`` or ``lit.local.cfg``) can define; substitutions for all tests in a test directory. They do so by extending the; substitution list, ``config.substitutions``. Each item in the list is a tuple; consisting of a pattern and its replacement, which lit applies using python's; ``re.sub`` function.; - To define substitutions within a single test file, lit supports the; ``DEFINE:`` and ``REDEFINE:`` directives, described in detail below. So that; they have no effect on other test files, these directives modify a copy of the; substitution list that is produced by lit configuration files. For example, the following directives can be inserted into a test file to define; ``%{cflags}`` and ``%{fcflags}`` substitutions with empty initial values, which; serve as the parameters of another newly defined ``%{check}`` substitution:. .. code-block:: llvm. ; DEFINE: %{cflags} =; ; DEFINE: %{fcflags} =. ; DEFINE: %{check} = \; ; DEFINE: %clang_cc1 -verify -fopenmp -fopenmp-versi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:28640,config,configuration,28640,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['config'],['configuration']
Modifiability,"ization; .. _`gold plugin interface`: http://gcc.gnu.org/wiki/whopr/driver. .. _lto-how-to-build:. How to build it; ===============. You need to have gold with plugin support and build the LLVMgold plugin.; The gold linker is installed as ld.gold. To see whether gold is the default; on your system, run ``/usr/bin/ld -v``. It will report ""GNU; gold"" or else ""GNU ld"" if not. If gold is already installed at; ``/usr/bin/ld.gold``, one option is to simply make that the default by; backing up your existing ``/usr/bin/ld`` and creating a symbolic link; with ``ln -s /usr/bin/ld.gold /usr/bin/ld``. Alternatively, you can build; with clang's ``-fuse-ld=gold`` or add ``-fuse-ld=gold`` to LDFLAGS, which will; cause the clang driver to invoke ``/usr/bin/ld.gold`` directly. If you have gold installed, check for plugin support by running; ``/usr/bin/ld.gold -plugin``. If it complains ""missing argument"" then; you have plugin support. If not, and you get an error such as ""unknown option"",; then you will either need to build gold or install a version with plugin; support. * Download, configure and build gold with plugin support:. .. code-block:: bash. $ git clone --depth 1 git://sourceware.org/git/binutils-gdb.git binutils; $ mkdir build; $ cd build; $ ../binutils/configure --enable-gold --enable-plugins --disable-werror; $ make all-gold. That should leave you with ``build/gold/ld-new`` which supports; the ``-plugin`` option. Running ``make`` will additionally build; ``build/binutils/ar`` and ``nm-new`` binaries supporting plugins. Once you're ready to switch to using gold, backup your existing; ``/usr/bin/ld`` then replace it with ``ld-new``. Alternatively, install; in ``/usr/bin/ld.gold`` and use ``-fuse-ld=gold`` as described earlier. Optionally, add ``--enable-gold=default`` to the above configure invocation; to automatically install the newly built gold as the default linker with; ``make install``. * Build the LLVMgold plugin. Run CMake with; ``-DLLVM_BINUTILS_INCDIR=/path/to/bin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:2029,plugin,plugin,2029,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['plugin'],['plugin']
Modifiability,"ize No 100000 − Number of Monte Carlo events in toy sample. Sigma No -1 − If > 0: new points are generated according to Gauss around best value and with Sigma in units of interval length. Seed No 100 − Seed for the random generator (0 takes random seeds). Configuration options for setup and tuning of specific fitter :. Configuration options reference for fitting method: TMinuit (MT). Option Array Default value Predefined values Description. ErrorLevel No 1 − TMinuit: error level: 0.5=logL fit, 1=chi-squared fit. PrintLevel No -1 − TMinuit: output level: -1=least, 0, +1=all garbage. FitStrategy No 2 − TMinuit: fit strategy: 2=best. PrintWarnings No False − TMinuit: suppress warnings. UseImprove No True − TMinuit: use IMPROVE. UseMinos No True − TMinuit: use MINOS. SetBatch No False − TMinuit: use batch mode. MaxCalls No 1000 − TMinuit: approximate maximum number of function calls. Tolerance No 0.1 − TMinuit: tolerance to the function value at the minimum. Configuration options for setup and tuning of specific fitter :. Configuration options reference for fitting method: Genetic Algorithm (GA). Option Array Default value Predefined values Description. PopSize No 300 − Population size for GA. Steps No 40 − Number of steps for convergence. Cycles No 3 − Independent cycles of GA fitting. SC_steps No 10 − Spread control, steps. SC_rate No 5 − Spread control, rate: factor is changed depending on the rate. SC_factor No 0.95 − Spread control, factor. ConvCrit No 0.001 − Convergence criteria. SaveBestGen No 1 − Saves the best n results from each generation. They are included in the last cycle. SaveBestCycle No 10 − Saves the best n results from each cycle. They are included in the last cycle. The value should be set to at least 1.0. Trim No False − Trim the population to PopSize after assessing the fitness of each individual. Seed No 100 − Set seed of random generator (0 gives random seeds). Configuration options given in the ""PrepareForTrainingAndTesting"" call; these options ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:31077,Config,Configuration,31077,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['Config'],['Configuration']
Modifiability,"ize how the build will be generated. Options are boolean; variables, with possible values ON/OFF. Options and variables are defined on the; CMake command line like this:. .. code-block:: console. $ cmake -DVARIABLE=value path/to/llvm/source. You can set a variable after the initial CMake invocation to change its; value. You can also undefine a variable:. .. code-block:: console. $ cmake -UVARIABLE path/to/llvm/source. Variables are stored in the CMake cache. This is a file named ``CMakeCache.txt``; stored at the root of your build directory that is generated by ``cmake``.; Editing it yourself is not recommended. Variables are listed in the CMake cache and later in this document with; the variable name and type separated by a colon. You can also specify the; variable and type on the CMake command line:. .. code-block:: console. $ cmake -DVARIABLE:TYPE=value path/to/llvm/source. Frequently-used CMake variables; -------------------------------. Here are some of the CMake variables that are used often, along with a; brief explanation. For full documentation, consult the CMake manual,; or execute ``cmake --help-variable VARIABLE_NAME``. See `Frequently; Used LLVM-related Variables`_ below for information about commonly; used variables that control features of LLVM and enabled subprojects. .. _cmake_build_type:. **CMAKE_BUILD_TYPE**:STRING; This configures the optimization level for ``make`` or ``ninja`` builds. Possible values:. =========================== ============= ========== ========== ==========================; Build Type Optimizations Debug Info Assertions Best suited for; =========================== ============= ========== ========== ==========================; **Release** For Speed No No Users of LLVM and Clang; **Debug** None Yes Yes Developers of LLVM; **RelWithDebInfo** For Speed Yes No Users that also need Debug; **MinSizeRel** For Size No No When disk space matters; =========================== ============= ========== ========== ==========================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:6620,variab,variables,6620,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,"ize of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is that parameters are allowed to change types; during the M minimization and analysis of a $\mbox{FCN}$ function.; Several applications in M have methods available to make variable; parameters fixed and vice-versa; to impose, change, or remove limits; from variable parameters; and even to define completely new parameters; at any time during a run. In addition, some M applications (notably the; $\mbox{MINOS}$ error analysis) cause one or more variable parameters; to be temporarily fixed during the calculation. Therefore, the; correspondence between external and internal parameter lists is in; general a dynamic one, and the number of internal parameters is not; necessarily constant. For more details about parameter interaction see [api:parameters]. ### The transformation for parameters with limits ###. [intro:limits]. For variable parameters with double sided limits $a$ (lower) and $b$; (upper), M uses the following transformation:. $$\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}$$. so that the internal value $P_{\mathrm{int}}$ can take on any value,; while the external value $P_{\mathrm{ext}}$ can take on values only; between the lower limit $a$ and the upper limit $b$. Since the; transformation is necessarily non-linear, it would transform a nice; linear problem into a nasty non-linear one, which is the reason why; limits should be avoided if not necessary. In addition, the; transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced; in the numerical calculation of the $\mbox{FCN}$ value. The effects; of non-linearity and numerical roundoff bo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:8164,variab,variable,8164,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability,"izer may not be able to vectorize math library functions; that correspond to these intrinsics if the library calls access external state; such as ""errno"". To allow better optimization of C/C++ math library functions,; use ""-fno-math-errno"". The loop vectorizer knows about special instructions on the target and will; vectorize a loop containing a function call that maps to the instructions. For; example, the loop below will be vectorized on Intel x86 if the SSE4.1 roundps; instruction is available. .. code-block:: c++. void foo(float *f) {; for (int i = 0; i != 1024; ++i); f[i] = floorf(f[i]);; }. Partial unrolling during vectorization; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Modern processors feature multiple execution units, and only programs that contain a; high degree of parallelism can fully utilize the entire width of the machine.; The Loop Vectorizer increases the instruction level parallelism (ILP) by; performing partial-unrolling of loops. In the example below the entire array is accumulated into the variable 'sum'.; This is inefficient because only a single execution port can be used by the processor.; By unrolling the code the Loop Vectorizer allows two or more execution ports; to be used simultaneously. .. code-block:: c++. int foo(int *A, int n) {; unsigned sum = 0;; for (int i = 0; i < n; ++i); sum += A[i];; return sum;; }. The Loop Vectorizer uses a cost model to decide when it is profitable to unroll loops.; The decision to unroll the loop depends on the register pressure and the generated code size. Epilogue Vectorization; ^^^^^^^^^^^^^^^^^^^^^^. When vectorizing a loop, often a scalar remainder (epilogue) loop is necessary; to execute tail iterations of the loop if the loop trip count is unknown or it; does not evenly divide the vectorization and unroll factors. When the; vectorization and unroll factors are large, it's possible for loops with smaller; trip counts to end up spending most of their time in the scalar (rather than; the vector) code. In",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst:10693,variab,variable,10693,interpreter/llvm-project/llvm/docs/Vectorizers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst,1,['variab'],['variable']
Modifiability,"izing Tracks. In case the modeller is interfaced with a tracking engine, one might; consider quite useful being able to store and visualize at least a part; of the tracks in the context of the geometry. The base class; **`TVirtualGeoTrack`** provides this functionality. It currently has one; implementation inside the drawing package (**`TGeoTrack`** class). A; track can be defined like:. ``` {.cpp}; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; ```. Where: `id` is user-defined id of the track, `pdg` - `pdg` code,; `parent` - a pointer to parent track, `particle` - a pointer to an; arbitrary particle object (may be a **`TParticle`**). A track has a list of daughters that have to be filled using the; following method:. ``` {.cpp}; TVirtualGeoTrack *TVirtualGeoTrack::AddDaughter(Int_t id,Int_t pdg,; TObject *particle=0);; ```. The method above is pure virtual and have to create a track daughter; object. Tracks are fully customizable objects when inheriting from; **`TVirtualGeoTrack`** class. We will describe the structure and; functionality provided by the default implementation of these, which are; **`TGeoTrack`** objects. A **`TGeoTrack`** is storing a list of `control points` `(x,y,z)`; belonging to the track, having also time information `(t)`. The painting; algorithm of such tracks allows drawing them in any time interval after; their creation. The track position at a given time is computed by; interpolation between control points. ``` {.cpp}; myTrack->AddPoint(x,y,z,t);; ```. The creation and management of tracks is in fact fully controlled by the; **`TGeoManager`** class. This holds a list of `primary tracks` that is; also visible during browsing as `Tracks` folder. Primary tracks are; tracks having no parent in the tracking history (for instance the output; of particle generators may be considered as primaries from tracking; point of view). The manager class holds; in**` TGeoManager::fCurrentTrack` a pointer to the curr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:125261,inherit,inheriting,125261,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['inherit'],['inheriting']
Modifiability,"ject()` method. ``` {.cpp}; root[] T->Project(""quietHisto"",""fNtrack""); ```. #### Making a Profile Histogram; \index{histogram!profile}. In case of a two dimensional expression, you can generate a; **`TProfile`** histogram instead of a two dimensional histogram by; specifying the `'prof'` or '`profs'` option. The `prof` option is; automatically selected when the output is redirected into a; **`TProfile`**. For example `y:x>>pf` where `pf `is an existing; **`TProfile`** histogram. #### Tree Information. Once we have drawn a tree, we can get information about the tree. These; are the methods used to get information from a drawn tree **`TTree`**:. - `GetSelectedRows`: Returns the number of entries accepted by the; selection expression. In case where no selection was specified, it; returns the number of entries processed. - `GetV1`: Returns a pointer to the float array of the first variable. - `GetV2`: Returns a pointer to the float array of second variable. - `GetV3`: Returns a pointer to the float array of third variable. - `GetW`: Returns a pointer to the float array of Weights where the; weight equals the result of the selection expression. To read the drawn values of `fNtrack` into an array, and loop through; the entries follow the lines below. First, open the file and draw the; `fNtrack` variable:. ``` {.cpp}; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack""); ```. Then declare a pointer to a float and use the GetV1 method to retrieve; the first dimension of the tree. In this example we only drew one; dimension (`fNtrack`) if we had drawn two, we could use GetV2 to get the; second one. ``` {.cpp}; root[] Float_t *a; root[] a = T->GetV1(); ```. Loop through the first 10 entries and print the values of `fNtrack`:. ``` {.cpp}; root[] for (int i = 0; i < 10; i++); root[] cout << a[i] << "" "" << endl // need an endl to see the values; 594 597 606 595 604 610 604 602 603 596; ```. By default, `TTree::Draw` creates these arrays with `fEstimate` words; whe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:119100,variab,variable,119100,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,ject/issues/78128>`_). - Clang now allows parenthesized initialization of arrays in `operator new[]`.; Fixes: (`#68198 <https://github.com/llvm/llvm-project/issues/68198>`_). - Fixes CTAD for aggregates on nested template classes. Fixes:; (`#77599 <https://github.com/llvm/llvm-project/issues/77599>`_). - Fix crash when importing the same module with an dynamic initializer twice; in different visibility.; Fixes (`#67893 <https://github.com/llvm/llvm-project/issues/67893>`_). - Remove recorded `#pragma once` state for headers included in named modules.; Fixes (`#77995 <https://github.com/llvm/llvm-project/issues/77995>`_). - Set the ``__cpp_auto_cast`` feature test macro in C++23 mode. - Fix crash for inconsistent deducing state of function return types; in importing modules.; Fixes (`#78830 <https://github.com/llvm/llvm-project/issues/78830>`_); Fixes (`#60085 <https://github.com/llvm/llvm-project/issues/60085>`_). - Fixed a bug where variables referenced by requires-clauses inside; nested generic lambdas were not properly injected into the constraint scope.; (`#73418 <https://github.com/llvm/llvm-project/issues/73418>`_). - Fix incorrect code generation caused by the object argument of ``static operator()`` and ``static operator[]`` calls not being evaluated.; Fixes (`#67976 <https://github.com/llvm/llvm-project/issues/67976>`_). - Fix crash when using an immediate-escalated function at global scope.; (`#82258 <https://github.com/llvm/llvm-project/issues/82258>`_); - Correctly immediate-escalate lambda conversion functions.; (`#82258 <https://github.com/llvm/llvm-project/issues/82258>`_); - Fix a crash when an unresolved overload set is encountered on the RHS of a ``.*`` operator.; (`#53815 <https://github.com/llvm/llvm-project/issues/53815>`_). - Fixed a regression in CTAD that a friend declaration that befriends itself may cause; incorrect constraint substitution.; (`#86769 <https://github.com/llvm/llvm-project/issues/86769>`_). Bug Fixes to AST Handling; ^^^^^^^^,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:55224,variab,variables,55224,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['variab'],['variables']
Modifiability,"jects and are the; second case where that requires copy and dispose helper functions to be; generated. The copy helper functions generated by the compiler should use the; ``_Block_object_assign`` runtime helper function and in the dispose helper the; ``_Block_object_dispose`` runtime helper function should be called. For example, ``Block`` foo in the following:. .. code-block:: c. struct Opaque *__attribute__((NSObject)) objectPointer = ...;; ...; void (^foo)(void) = ^{ CFPrint(objectPointer); };. would have the following helper functions generated:. .. code-block:: c. void __block_copy_foo(struct __block_literal_5 *dst, struct __block_literal_5 *src) {; _Block_object_assign(&dst->objectPointer, src-> objectPointer, BLOCK_FIELD_IS_OBJECT);; }. void __block_dispose_foo(struct __block_literal_5 *src) {; _Block_object_dispose(src->objectPointer, BLOCK_FIELD_IS_OBJECT);; }. Imported ``__block`` marked variables; -------------------------------------. Layout of ``__block`` marked variables; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The compiler must embed variables that are marked ``__block`` in a specialized; structure of the form:. .. code-block:: c. struct _block_byref_foo {; void *isa;; struct Block_byref *forwarding;; int flags; //refcount;; int size;; typeof(marked_variable) marked_variable;; };. Variables of certain types require helper functions for when ``Block_copy()``; and ``Block_release()`` are performed upon a referencing ``Block``. At the ""C""; level only variables that are of type ``Block`` or ones that have; ``__attribute__((NSObject))`` marked require helper functions. In Objective-C; objects require helper functions and in C++ stack based objects require helper; functions. Variables that require helper functions use the form:. .. code-block:: c. struct _block_byref_foo {; void *isa;; struct _block_byref_foo *forwarding;; int flags; //refcount;; int size;; // helper functions called via Block_copy() and Block_release(); void (*byref_keep)(void *dst, void *",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:11445,variab,variables,11445,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability,"jects; will be committed to the workspace, thus leaving no 'partial builds'. Compact demo of several new major features. The macro below demonstrates in a couple of lines a number of major new features in RooFit 3.00: Use of. workspace factory to quickly create and store (compiled) models; workspace CINT interface to easily access contents in a typesafe way; new adaptive ND numeric integration technique to normalize arbitrary p.d.f. in fast; and reliable way; new adaptive TFoam sampling technique to efficiently generate toy MC data from strongly; peaked datasets; parallel processing in likelihood construction and use of profile likelihood operator; to represent profile likelihoods as regular RooFit functions. void demo(); {; // Construct compiled 2-D model that requires numeric integration for normalization; RooWorkspace w(""w"",1) ;; w.factory(""CEXPR::model('1/((x-a)*(x-a)+0.001)+1/((y-b)*(y-b)+0.001)',x[-1,1],y[-1,1],a[-5,5],b[-5,5])"") ;. // Generate data from model (using TFoam adaptive sampling algorithm); RooDataSet* d = w::model.generate(RooArgSet(w::x,w::y),1000) ;; w::model.fitTo(*d) ;. // Make 2D plot on (x,y); TH2* hh = w::model.createHistogram(""x,y"",40,40) ;; hh->SetLineColor(kBlue) ;. // Make Projection on x (integrate over y); RooPlot* framex = w::x.frame(Title(""Data and p.d.f. projected on X"")) ;; d->plotOn(framex) ;; w::model.plotOn(framex) ;. // Construct likelihood, profile likelihood in a, and draw the latter; RooAbsReal* nll = w::model.createNLL(*d,NumCPU(2)) ;; RooAbsReal* pll = nll->createProfile(w::a) ;; RooPlot* framea = w::a.frame(Title(""Profile likelihood in parameter a"")) ;; pll->plotOn(framea) ;. // Construct 2D cumulative distribution function from p.d.f.; RooAbsReal* cdfxy = w::model.createCdf(RooArgSet(w::x,w::y),ScanNoCdf()) ;; TH2* hhcdf = cdfxy->createHistogram(""x,y"",40,40) ;; hhcdf->SetLineColor(kRed) ;. TCanvas* c = new TCanvas(""c"",""c"",650,650) ; c->Divide(2,2) ;; c->cd(1) ; hh->Draw(""surf"") ; c->cd(2) ; framex->Draw() ;; c->cd(3) ; f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:22699,adapt,adaptive,22699,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['adapt'],['adaptive']
Modifiability,"js to calculate rendering order; - comp - show left and right components of TGeoCompositeShape; - compx - show all sub-components of TGeoCompositeShape. In the URL string several global settings can be changed:. - geosegm - grads per segment is cylindrical shapes, default is 6; - geocomp - compress results of composite shape production, default is true. It is possible to display only part of geometry model. For instance, one could select sub-item like:. - [file=rootgeom.root&item=simple1/TOP/REPLICA_1](https://root.cern/js/latest/?file=../files/geom/rootgeom.root&item=simple1/TOP/REPLICA_1). Or one can use simple selection syntax (work only with first-level volumes):. - [item=simple1&opt=-bar1-bar2](https://root.cern/js/latest/?file=../files/geom/rootgeom.root&item=simple1;1&opt=-bar1-bar2). Syntax uses '+' sign to enable visibility flag of specified volume and '-' sign to disable visibility.; One could use wildcard symbol like '+TUBE1*'. Another way to configure visibility flags is usage of ROOT macros, which typically looks like:. ```cpp; {; TGeoManager::Import(""http://root.cern/files/alice2.root"");; gGeoManager->DefaultColors();; // gGeoManager->SetVisLevel(4);; gGeoManager->GetVolume(""HALL"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCC"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCA"")->InvisibleAll();; // ...; gGeoManager->GetVolume(""ALIC"")->Draw(""ogl"");; new TBrowser;; }; ```. Example of such macro can be found in root tutorials. From provided macro only following calls will be executed in JSROOT:. * `gGeoManager->DefaultColors()`; * `gGeoManager->GetVolume(""HALL"")->InvisibleAll()`; * `gGeoManager->GetVolume(""HALL"")->SetTransparency(30)`; * `gGeoManager->GetVolume(""HALL"")->SetLineColor(5)`; * `gGeoManager->GetVolume(""ALIC"")->Draw(""ogl"")`. All other will be ignored. Example of major LHC detectors:; * ALICE: [full](https://root.cern/js/latest/?file=https://root.cern/files/alice2.root&item=Geometry;1&opt=macro:https://root.cern/js/files/geomAlice.C); * ATLAS: [",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:23091,config,configure,23091,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['config'],['configure']
Modifiability,"k !1 dso_local i32 @pthread_create(ptr, ptr, ptr, ptr). ...; !2 = !{i64 2, i64 3, i1 false}; !1 = !{!2}. Another example is shown below. The callback callee is the second argument of; the ``__kmpc_fork_call`` function (``i64 2``). The callee is given two unknown; values (each identified by a ``i64 -1``) and afterwards all; variadic arguments that are passed to the ``__kmpc_fork_call`` call (due to the; final ``i1 true``). .. FIXME why does the llvm-sphinx-docs builder give a highlighting; error if the below is set to highlight as 'llvm', despite that we; have misc.highlighting_failure set?. .. code-block:: text. declare !callback !0 dso_local void @__kmpc_fork_call(ptr, i32, ptr, ...). ...; !1 = !{i64 2, i64 -1, i64 -1, i1 true}; !0 = !{!1}. '``exclude``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^. ``exclude`` metadata may be attached to a global variable to signify that its; section should not be included in the final executable or shared library. This; option is only valid for global variables with an explicit section targeting ELF; or COFF. This is done using the ``SHF_EXCLUDE`` flag on ELF targets and the; ``IMAGE_SCN_LNK_REMOVE`` and ``IMAGE_SCN_MEM_DISCARDABLE`` flags for COFF; targets. Additionally, this metadata is only used as a flag, so the associated; node must be empty. The explicit section should not conflict with any other; sections that the user does not want removed after linking. .. code-block:: text. @object = private constant [1 x i8] c""\00"", section "".foo"" !exclude !0. ...; !0 = !{}. '``unpredictable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``unpredictable`` metadata may be attached to any branch or switch; instruction. It can be used to express the unpredictability of control; flow. Similar to the llvm.expect intrinsic, it may be used to alter; optimizations related to compare and branch instructions. The metadata; is treated as a boolean value; if it exists, it signals that the branch; or switch that it is attached to is completely unpredictable. .. _md",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:291572,variab,variables,291572,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"k the validity of a given geometry is shooting random; points. This can be called with the method; **`TGeoVolume`**`::RandomPoints()` and it draws a volume with the current; visualization settings. Random points are generated in the bounding box; of the drawn volume. The points are drawn with the color of their; deepest container. Only points inside visible nodes are drawn. ![Random rays](pictures/030001E2.png). A ray tracing method can be called `TGeoVolume::RandomRays()`. This; shoots rays from a given point in the local reference frame with random; directions. The intersections with displayed nodes appear as segments; having the color of the touched node. ## The Drawing Package. ![](pictures/030001E3.png)The modeller provides a powerful drawing; package, supporting several different options of visualization. A; library separated from the main one provides all functionality being; linked with the underlying ROOT visualization system. This library is; dynamically loaded by the plug-in manager only when drawing features are; requested. The geometrical structures that can be visualized are volumes; and volume hierarchies. The main component of the visualization system is volume primitive; painting in a ROOT pad. Starting from this one, several specific options; or subsystems are available, like: X3D viewing using hidden line and; surface removal algorithms, OpenGL viewing\* or ray tracing. The method `TGeoManager::GetGeomPainter()`loads the painting library in; memory. This is generally not needed since it is called automatically by; `TGeoVolume::Draw()` as well as by few other methods setting; visualization attributes. ### Drawing Volumes and Hierarchies of Volumes. The first thing one would like to do after building some geometry is to; visualize the volume tree. This provides the fastest validation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ``` {.cpp}; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:136679,plug-in,plug-in,136679,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['plug-in'],['plug-in']
Modifiability,"k, nor is there; any streamerinfo for such a member. A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a; pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL); is written. If the declaration line has a comment beginning with ""//->"", this indicates; that the pointer value will never be null, which allows a performance optimization.; Another optimization is that if two or more pointers pointing to the same object are; streamed in the same I/O operation, the object is written only once. The remaining; pointers reference the object through a unique object identifier. This saves space; and avoids the infinite loop that might otherwise arise if the directed graph of object; instance pointer references contains a cycle. If a data member is a pointer to a simple type, the Streamer presumes it is an array,; with the dimension defined in a comment of the form ""//[<length>]"", where length is; either an integer constant or a variable that is an integer data member of the class.; If a variable is used, it must be defined ahead of its use or in a base class. The above describes the function of the StreamerInfo record in decomposing a; self-identifying object if the user uses the streamer generated by ""rootcint"".; There are two reasons why a user may need to write a specialized streamer for a class.; One reason is that it may be necessary to execute some code before or after data is read; or written, for example, to initialize some non-persistent data members after the; persistent data is read. In this case, the custom streamer can use the StreamerInfo record; to decompose a self-identifying object in the exact same manner as the generated; streamer would have done. An example is given (for the Event class) in the Root User's; Guide (URL below) (Input/Output chapter, Streamers subchapter). On the other hand, if; the user needs to writ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md:8680,variab,variable,8680,io/doc/TFile/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md,1,['variab'],['variable']
Modifiability,"k:: text. error: no matching function for call to 'operator new'; 13 | new (__builtin_memset) S {};; | ^ ~~~~~~~~~~~~~~~~~~. note: candidate function not viable: no known conversion from '<builtin fn type>' to 'int' for 2nd argument; 5 | void* operator new(__SIZE_TYPE__, int);; | ^. After:. .. code-block:: text. error: builtin functions must be directly called; 13 | new (__builtin_memset) S {};; | ^. - Clang now diagnoses import before module declarations but not in global; module fragment.; (`#67627 <https://github.com/llvm/llvm-project/issues/67627>`_). - Clang now diagnoses include headers with angle in module purviews, which is; not usually intended.; (`#68615 <https://github.com/llvm/llvm-project/issues/68615>`_). - Clang now won't mention invisible namespace when diagnose invisible declarations; inside namespace. The original diagnostic message is confusing.; (`#73893 <https://github.com/llvm/llvm-project/issues/73893>`_). Improvements to Clang's time-trace; ----------------------------------; - Two time-trace scope variables are added. A time trace scope variable of; ``ParseDeclarationOrFunctionDefinition`` with the function's source location; is added to record the time spent parsing the function's declaration or; definition. Another time trace scope variable of ``ParseFunctionDefinition``; is also added to record the name of the defined function. Bug Fixes in This Version; -------------------------; - Fixed an issue where a class template specialization whose declaration is; instantiated in one module and whose definition is instantiated in another; module may end up with members associated with the wrong declaration of the; class, which can result in miscompiles in some cases.; - Fix crash on use of a variadic overloaded operator.; (`#42535 <https://github.com/llvm/llvm-project/issues/42535>`_); - Fix a hang on valid C code passing a function type as an argument to; ``typeof`` to form a function declaration.; (`#64713 <https://github.com/llvm/llvm-project/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:32603,variab,variables,32603,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['variab'],['variables']
Modifiability,"k``, including; ``__weak`` ``__block`` variables. C++ Extensions; ==============. Block literal expressions within functions are extended to allow const; use of C++ objects, pointers, or references held in automatic storage. As usual, within the block, references to captured variables become; const-qualified, as if they were references to members of a const; object. Note that this does not change the type of a variable of; reference type. For example, given a class Foo:. .. code-block:: c. Foo foo;; Foo &fooRef = foo;; Foo *fooPtr = &foo;. A Block that referenced these variables would import the variables as; const variations:. .. code-block:: c. const Foo block_foo = foo;; Foo &block_fooRef = fooRef;; Foo *const block_fooPtr = fooPtr;. Captured variables are copied into the Block at the instant of; evaluating the Block literal expression. They are also copied when; calling ``Block_copy()`` on a Block allocated on the stack. In both; cases, they are copied as if the variable were const-qualified, and; it's an error if there's no such constructor. Captured variables in Blocks on the stack are destroyed when control; leaves the compound statement that contains the Block literal; expression. Captured variables in Blocks on the heap are destroyed; when the reference count of the Block drops to zero. Variables declared as residing in ``__block`` storage may be initially; allocated in the heap or may first appear on the stack and be copied; to the heap as a result of a ``Block_copy()`` operation. When copied; from the stack, ``__block`` variables are copied using their normal; qualification (i.e. without adding const). In C++11, ``__block``; variables are copied as x-values if that is possible, then as l-values; if not; if both fail, it's an error. The destructor for any initial; stack-based version is called at the variable's normal end of scope. References to ``this``, as well as references to non-static members of; any enclosing class, are evaluated by capturing ``this",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:11909,variab,variable,11909,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['variab'],['variable']
Modifiability,"kdir PATH_TO_MINIUT2_BUILD; cd PATH_TO_MINUIT2_BUILD; cmake PATH_TO_MINUIT2_SOURCE; cmake --build .; ```. Of course, GUIs, IDEs, etc. that work with [CMake] will work with this package. The standard method of CMake building, with a build directory inside the Minuit2 source directory and using the makefile generator, would look like:. ```bash; cd PATH_TO_MINUIT2_SOURCE; mkdir build; cd build; cmake ..; make; ```. The standard [CMake] variables, such as `CMAKE_BUILD_TYPE` and `CMAKE_INSTALL_PREFIX`, work with Minuit2. There are two other options:. * `minuit2_mpi` activates the (outdated C++) MPI bindings.; * `minuit2_omp` activates OpenMP (make sure all FCNs are threadsafe). ## Testing. You can run `ctest` or `make test` to run the Minuit2 test suite. ## Installing or using in another package. You can install the package using `cmake --build --target install .` (or `make install` if directly using the make system), or you can use it from the build directory. You can also include it in another CMake project using `add_subdirectory()` and linking to the `Minuit2` target. Since this package also exports targets, `find_package(Minuit2)` will also work once this package is built or installed. (For the curious, CMake adds a config script to `~/.cmake/packages` when building or; `$CMAKE_INSTALL_PREFIX/share/cmake/Modules` when installing a package that has export commands.). To repeat; using this in your own CMake project usually amounts to:. ```cmake; find_package(Minuit2); # OR; add_subdirectory(Minuit2). target_link_libraries(MyExeOrLib PUBLIC Minuit2::Minuit2); ```. You do not need to add include directories or anything else for Minuit2; the CMake target system handles all of this for you. ## Packaging. To build a binary package (add other generators with `-G`):; ```bash; make package; ```. [DEVELOP.md]: ./DEVELOP.md; [ROOT]: https://root.cern; [minuitdoc]: https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html#minuit2-package; [CMake]: https://cmake.org; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/README.md:1885,config,config,1885,math/minuit2/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/README.md,1,['config'],['config']
Modifiability,"kePrimer` page. It has a basic overview of the CMake language. .. _Quick start:. Quick start; ===========. We use here the command-line, non-interactive CMake interface. #. `Download <http://www.cmake.org/cmake/resources/software.html>`_ and install; CMake. Version 3.20.0 is the minimum required. #. Open a shell. Your development tools must be reachable from this shell; through the PATH environment variable. #. Create a build directory. Building LLVM in the source; directory is not supported. cd to this directory:. .. code-block:: console. $ mkdir mybuilddir; $ cd mybuilddir. #. Execute this command in the shell replacing `path/to/llvm/source/root` with; the path to the root of your LLVM source tree:. .. code-block:: console. $ cmake path/to/llvm/source/root. CMake will detect your development environment, perform a series of tests, and; generate the files required for building LLVM. CMake will use default values; for all build parameters. See the `Options and variables`_ section for; a list of build parameters that you can modify. This can fail if CMake can't detect your toolset, or if it thinks that the; environment is not sane enough. In this case, make sure that the toolset that; you intend to use is the only one reachable from the shell, and that the shell; itself is the correct one for your development environment. CMake will refuse; to build MinGW makefiles if you have a POSIX shell reachable through the PATH; environment variable, for instance. You can force CMake to use a given build; tool; for instructions, see the `Usage`_ section, below. You may; also wish to control which targets LLVM enables, or which LLVM; components are built; see the `Frequently Used LLVM-related; variables`_ below. #. After CMake has finished running, proceed to use IDE project files, or start; the build from the build directory:. .. code-block:: console. $ cmake --build . The ``--build`` option tells ``cmake`` to invoke the underlying build; tool (``make``, ``ninja``, ``xcodebuild",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:2072,variab,variables,2072,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,"keRule(; cxxMemberCallExpr(; on(expr(hasType(namedDecl(hasName(""std::string"")))); 	 .bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. Example: rewriting method calls; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In this example, we delete an ""intermediary"" method call in a string of; invocations. This scenario can arise, for example, if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(""``child`` accessor is being removed; call "",; 		member(m), "" directly on parent""));. This rule isn't quite what we want: it will rewrite ``my_object.child().foo()`` to; ``my_object.foo()``, but it will also rewrite ``my_ptr->child().foo()`` to; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------------. The above examples demonstrate just the basics of rewrite rules. Every element; we",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:8048,rewrite,rewrite,8048,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['rewrite'],['rewrite']
Modifiability,"keep(struct _block_byref_blockStorageFoo *dst, struct _block_byref_blockStorageFoo *src) {; FOO_ctor(&dst->blockStorageFoo, &src->blockStorageFoo);; }. void _block_byref_obj_dispose(struct _block_byref_blockStorageFoo *src) {; FOO_dtor(&src->blockStorageFoo);; }. for the appropriately named constructor and destructor for the class/struct; ``FOO``. To support member variable and function access the compiler will synthesize a; ``const`` pointer to a block version of the ``this`` pointer. .. _RuntimeHelperFunctions:. Runtime Helper Functions; ========================. The runtime helper functions are described in; ``/usr/local/include/Block_private.h``. To summarize their use, a ``Block``; requires copy/dispose helpers if it imports any block variables, ``__block``; storage variables, ``__attribute__((NSObject))`` variables, or C++ ``const``; copied objects with constructor/destructors. The (1<<26) bit is set and; functions are generated. The block copy helper function should, for each of the variables of the type; mentioned above, call:. .. code-block:: c. _Block_object_assign(&dst->target, src->target, BLOCK_FIELD_<apropos>);. in the copy helper and:. .. code-block:: c. _Block_object_dispose(->target, BLOCK_FIELD_<apropos>);. in the dispose helper where ``<apropos>`` is:. .. code-block:: c. enum {; BLOCK_FIELD_IS_OBJECT = 3, // id, NSObject, __attribute__((NSObject)), block, ...; BLOCK_FIELD_IS_BLOCK = 7, // a block variable; BLOCK_FIELD_IS_BYREF = 8, // the on stack structure holding the __block variable. BLOCK_FIELD_IS_WEAK = 16, // declared __weak. BLOCK_BYREF_CALLER = 128, // called from byref copy/dispose helpers; };. and of course the constructors/destructors for ``const`` copied C++ objects. The ``block_byref`` data structure similarly requires copy/dispose helpers for; block variables, ``__attribute__((NSObject))`` variables, or C++ ``const``; copied objects with constructor/destructors, and again the (1<<26) bit is set; and functions are generated in the sam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:28135,variab,variables,28135,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability,"kground-only, but when performing an inverted hypothesis test the null is a signal+background model. The new convention is that the p-value for both the null and the alternate are taken from the same tail (as specified by the test statistic). Both CLs+b and CLb are equivalent to these p-values, and the HypoTestResult has a simple switch SetBackgroundIsAlt() to specify the pairing between (null p-value, alternate p-value) and (CLb, CLs+b). HypoTestInverter, HypoTestInverterResult, HypoTestInverterPlot. These classes have been rewritten for using them with the new hypothesis test calculators. The HypoTestInverter; class can now be constructed by any generic HypoTestCalculator, and both the HybridCalculator and the new; FrequentistCalculator are supported. The HypoTestInverter class can be constructed in two ways: either passing an; HypoTestCalculator and a data set or by passing the model for the signal, for the background and a data set.; In the first case the user configure the HypoTestCalculator before passing to the HypoTestInverter.; It must be configured using as null model the signal plus background model as alternate model the background; model. Optionally the user can pass the parameter to scan, if it is not passed, the first parameter of interest of the; null model will be used. In the second case (when passing directly the model and the data) the HypoTestInverter; can be configured to use either the frequentist or the hybrid calculator. The user can then configure the class; afterwards. For example set the test statistic to use via the method SetTestStatistic, number of toys to run; for each hypothesis, by retrieving the contained HypoTestCalculator:. HypoTestInverter inverter(obsData, model_B, model_SB, parameterToScan, HypoTestInverter::kFrequentist);; ProfileLikelihoodRatioTestStat profLR( *model_SB->GetPdf() );; inverter.SetTestStatistic(&profLR);; FrequentistCalculator * htcalc = (FrequentistCalculator*) inverter.GetHypoTestCalculator();; htcalc->SetToy",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html:3809,config,configure,3809,roofit/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html,2,['config'],['configure']
Modifiability,known. 796; CD2; Lifetime of a closure object with members captured by reference; Unknown. 797; CD2; Converting a no-capture lambda to a function type; Unknown. 798; C++11; Overloaded subscript operator described in clause 5; Unknown. 799; CD2; Can reinterpret_cast be used to cast an operand to its own type?; Unknown. 800; NAD; Safely-derived pointers and object pointers converted from function pointers; Unknown. 801; CD2; Casting away constness in a cast to rvalue reference type; Unknown. 803; CD2; sizeof an enumeration type with a fixed underlying type; Unknown. 804; CD2; Deducing the type in new auto(x); Unknown. 805; CD2; Which exception to throw for overflow in array size calculation; Unknown. 806; CD2; Enumeration types in integral constant expressions; Unknown. 807; NAD; typeid expressions in constant expressions; Unknown. 808; CD2; Non-type decl-specifiers versus max-munch; Unknown. 809; CD2; Deprecation of the register keyword; Unknown. 810; CD2; Block-scope thread_local variables should be implicitly static; Unknown. 811; CD2; Unclear implications of const-qualification; Unknown. 812; CD2; Duplicate names in inline namespaces; Unknown. 813; open; typename in a using-declaration with a non-dependent name; Not resolved. 814; CD2; Attribute to indicate that a function throws nothing; Unknown. 815; CD2; Parameter pack expansion inside attributes; Unknown. 816; CD2; Diagnosing violations of [[final]]; Unknown. 817; CD2; Meaning of [[final]] applied to a class definition; Unknown. 818; CD2; Function parameter packs in non-final positions; Unknown. 819; NAD; Access control and deleted implicitly-declared special member functions; Unknown. 820; CD2; Deprecation of export; Unknown. 822; NAD; Additional contexts for template aliases; Unknown. 823; CD2; Literal types with constexpr conversions as non-type template arguments; Unknown. 828; CD2; Destruction of exception objects; Unknown. 829; NAD; At what point is std::unexpected called?; Unknown. 830; CD2; Deprecating ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:55127,variab,variables,55127,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['variab'],['variables']
Modifiability,"knownValue == 42. call void @foo(ptr %ptr); %newPtr2 = call ptr @llvm.launder.invariant.group.p0(ptr %ptr); %d = load i8, ptr %newPtr2, !invariant.group !0 ; Can't step through launder.invariant.group to get value of %ptr. ...; declare void @foo(ptr); declare ptr @getPointer(ptr); declare ptr @llvm.launder.invariant.group.p0(ptr). !0 = !{}. The invariant.group metadata must be dropped when replacing one pointer by; another based on aliasing information. This is because invariant.group is tied; to the SSA value of the pointer operand. .. code-block:: llvm. %v = load i8, ptr %x, !invariant.group !0; ; if %x mustalias %y then we can replace the above instruction with; %v = load i8, ptr %y. Note that this is an experimental feature, which means that its semantics might; change in the future. '``type``' Metadata; ^^^^^^^^^^^^^^^^^^^. See :doc:`TypeMetadata`. '``associated``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^. The ``associated`` metadata may be attached to a global variable definition with; a single argument that references a global object (optionally through an alias). This metadata lowers to the ELF section flag ``SHF_LINK_ORDER`` which prevents; discarding of the global variable in linker GC unless the referenced object is; also discarded. The linker support for this feature is spotty. For best; compatibility, globals carrying this metadata should:. - Be in ``@llvm.compiler.used``.; - If the referenced global variable is in a comdat, be in the same comdat. ``!associated`` can not express many-to-one relationship. A global variable with; the metadata should generally not be referenced by a function: the function may; be inlined into other functions, leading to more references to the metadata.; Ideally we would want to keep metadata alive as long as any inline location is; alive, but this many-to-one relationship is not representable. Moreover, if the; metadata is retained while the function is discarded, the linker will report an; error of a relocation referencing a di",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:317998,variab,variable,317998,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"l = nullptr;; FoundDeclsList = Look up all Decls in the ""to"" Ctx with the same name of FromD;; for (auto FoundDecl : FoundDeclsList) {; if (StructurallyEquivalentDecls(FoundDecl, FromD)) {; ToDecl = FoundDecl;; Mark FromD as imported;; break;; } else {; Report ODR violation;; return error;; }; }; if (FoundDeclsList is empty) {; Import dependent declarations and types of ToDecl;; ToDecl = create a new AST node in ""to"" Ctx;; Mark FromD as imported;; }; return ToDecl;; }. Two AST nodes are *structurally equivalent* if they are. - builtin types and refer to the same type, e.g. ``int`` and ``int`` are structurally equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and their types are structurally equivalent. We could extend the definition of structural equivalency to templates similarly. If A and B are AST nodes and *A depends on B*, then we say that A is a **dependant** of B and B is a **dependency** of A.; The words ""dependant"" and ""dependency"" are nouns in British English.; Unfortunately, in American English, the adjective ""dependent"" is used for both meanings.; In this document, with the ""dependent"" adjective we always address the dependencies, the B node in the example. API; ---. Let's create a tool which uses the ASTImporter class!; First, we build two ASTs from virtual files; the content of the virtual files are synthesized from string literals:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc""); // empty file; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");. The first AST corresponds to the destination (""to"") context - which is empty - and the second for the source (""from"") context.; Next, we define a matcher to match",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:4138,extend,extend,4138,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,1,['extend'],['extend']
Modifiability,"l AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. .. code-block:: c++. true:; switch (level) {; case log::info : return ""info:"";; case log::warning: return ""warning:"";; default : return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. .. _AlignEscapedNewlines:. **AlignEscapedNewlines** (``EscapedNewlineAlignmentStyle``) :versionbadge:`clang-format 5` :ref:`¶ <AlignEscapedNewlines>`; Options for aligning backslashes in escaped newlines. Possible values:. * ``ENAS_DontAlign`` (in configuration: ``DontAlign``); Don't align escaped newlines. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. * ``ENAS_Left`` (in configuration: ``Left``); Align escaped newlines as far left as possible. .. code-block:: c++. true:; #define A \; int aaaa; \; int b; \; int dddddddddd;. false:. * ``ENAS_Right`` (in configuration: ``Right``); Align escaped newlines in the right-most column. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. .. _AlignOperands:. **AlignOperands** (``OperandAlignmentStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AlignOperands>`; If ``true``, horizontally align operands of binary and ternary; expressions. Possible values:. * ``OAS_DontAlign`` (in configuration: ``DontAlign``); Do not align operands of binary and ternary expressions.; The wrapped lines are indented ``ContinuationIndentWidth`` spaces from; the start of the line. * ``OAS_Align`` (in configuration: ``Align``); Horizontally align operands of binary and ternary expressions. Specifically, this aligns operands of a single expression that needs; to be split over multiple lines, e.g.:. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb +; ccccccccccccccc;. When ``BreakBeforeBinaryOperators`` is set, the wrapped operator is; aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:21154,config,configuration,21154,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"l View:; [000] {File} 'pr-43860-dwarf-gcc.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [002] {Producer} 'GNU C++14 9.3.0'; [002] 2 {Function} extern declared_inlined 'InlineFunction' -> 'int'; [003] {Block}; [004] 5 {Variable} 'Var_2' -> 'int'; [003] 2 {Parameter} 'Param' -> 'int'; [003] 3 {Variable} 'Var_1' -> 'int'; [002] 11 {Function} extern not_inlined 'test' -> 'int'; [003] 12 {Variable} 'A' -> 'int'; [003] 13 {InlinedFunction} declared_inlined 'InlineFunction' -> 'int'; [004] {Block}; [005] {Variable} 'Var_2' -> 'int'; [004] {Parameter} 'Param' -> 'int'; [004] {Variable} 'Var_1' -> 'int'; [003] 11 {Parameter} 'Param_1' -> 'int'; [003] 11 {Parameter} 'Param_2' -> 'int'. From the previous logical views, we can see that the CodeView debug; information generated by the Clang compiler shows the variables **Var_1**; and **Var_2** are at the same lexical scope (**4**) in the function; **InlineFuction**. The DWARF generated by GCC/Clang and CodeView; generated by MSVC, show those variables at the correct lexical scope:; **3** and **4** respectively. Using the :program:`llvm-debuginfo-analyzer` selection facilities, we; can produce a simple tabular output showing just the logical elements; that have in their name the *var* pattern. The logical view is sorted; by the variables name. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level,format; --output-sort=name; --select-regex --select-nocase --select=Var; --report=list; --print=symbols; pr-43860-*.o. .. code-block:: none. Logical View:; [000] {File} 'pr-43860-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [004] {Variable} 'Var_1' -> 'int'; [004] {Variable} 'Var_2' -> 'int'. Logical View:; [000] {File} 'pr-43860-codeview-msvc.o' -> COFF-i386. [001] {CompileUnit} 'pr-43860.cpp'; [003] {Variable} 'Var_1' -> 'int'; [004] {Variable} 'Var_2' -> 'int'. Logical View:; [000] {File} 'pr-43860-dwarf-clang.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [004] {Variable} 'Var_1' ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:53259,variab,variables,53259,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['variab'],['variables']
Modifiability,"l call which could use it is known to the compiler, or; whether another translation unit could introduce more calls through the vtable.; This is not the same as the linkage of the vtable, because call sites could be; using a pointer of a more widely-visible base class. For example, consider this; code:. .. code-block:: c++. __attribute__((visibility(""default""))); struct A {; virtual void f();; };. __attribute__((visibility(""hidden""))); struct B : A {; virtual void f();; };. With LTO, we know that all code which can see the declaration of ``B`` is; visible to us. However, a pointer to a ``B`` could be cast to ``A*`` and passed; to another linkage unit, which could then call ``f`` on it. This call would; load from the vtable for ``B`` (using the object pointer), and then call; ``B::f``. This means we can't remove the function pointer from ``B``'s vtable,; or the implementation of ``B::f``. However, if we can see all code which knows; about any dynamic base class (which would be the case if ``B`` only inherited; from classes with hidden visibility), then this optimisation would be valid. This concept is represented in IR by the ``!vcall_visibility`` metadata; attached to vtable objects, with the following values:. .. list-table::; :header-rows: 1; :widths: 10 90. * - Value; - Behavior. * - 0 (or omitted); - **Public**; Virtual function calls using this vtable could be made from external; code. * - 1; - **Linkage Unit**; All virtual function calls which might use this vtable are in the; current LTO unit, meaning they will be in the current module once; LTO linking has been performed. * - 2; - **Translation Unit**; All virtual function calls which might use this vtable are in the; current module. In addition, all function pointer loads from a vtable marked with the; ``!vcall_visibility`` metadata (with a non-zero value) must be done using the; :ref:`llvm.type.checked.load <type.checked.load>` intrinsic, so that virtual; calls sites can be correlated with the vtables which",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TypeMetadata.rst:9594,inherit,inherited,9594,interpreter/llvm-project/llvm/docs/TypeMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TypeMetadata.rst,1,['inherit'],['inherited']
Modifiability,"l entry point that can rebuild a; stack frame from the values located by the stack map. '``llvm.experimental.patchpoint.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void; @llvm.experimental.patchpoint.void(i64 <id>, i32 <numBytes>,; ptr <target>, i32 <numArgs>, ...); declare i64; @llvm.experimental.patchpoint.i64(i64 <id>, i32 <numBytes>,; ptr <target>, i32 <numArgs>, ...). Overview:; """""""""""""""""". The '``llvm.experimental.patchpoint.*``' intrinsics creates a function; call to the specified ``<target>`` and records the location of specified; values in the stack map. Operands:; """""""""""""""""". The first operand is an ID, the second operand is the number of bytes; reserved for the patchable region, the third operand is the target; address of a function (optionally null), and the fourth operand; specifies how many of the following variable operands are considered; function call arguments. The remaining variable number of operands are; the ``live values`` for which locations will be recorded in the stack; map. Semantics:; """""""""""""""""""". The patch point intrinsic generates a stack map. It also emits a; function call to the address specified by ``<target>`` if the address; is not a constant null. The function call and its arguments are; lowered according to the calling convention specified at the; intrinsic's callsite. Variants of the intrinsic with non-void return; type also return a value according to calling convention. On PowerPC, note that ``<target>`` must be the ABI function pointer for the; intended target of the indirect call. Specifically, when compiling for the; ELF V1 ABI, ``<target>`` is the function-descriptor address normally used as; the C/C++ function-pointer representation. Requesting zero patch point arguments is valid. In this case, all; variable operands are handled just like; ``llvm.experimental.stackmap.*``. The difference is that space will; still be reserved for patching, a call will be emitted, and a return; v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:8190,variab,variable,8190,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['variab'],['variable']
Modifiability,"l every part of LLVM that your build is configured to generate except the; LLVM testing tools. Alternatively the ``install-distribution`` target, which is; recommended for building distributions, only installs specific parts of LLVM as; specified at configuration time by *LLVM_DISTRIBUTION_COMPONENTS*. Additionally by default the ``install`` target will install the LLVM testing; tools as the public tools. This can be changed well by setting; *LLVM_INSTALL_TOOLCHAIN_ONLY* to ``On``. The LLVM tools are intended for; development and testing of LLVM, and should only be included in distributions; that support LLVM development. When building with *LLVM_DISTRIBUTION_COMPONENTS* the build system also; generates a ``distribution`` target which builds all the components specified in; the list. This is a convenience build target to allow building just the; distributed pieces without needing to build all configured targets. .. _Multi-distribution configurations:. Multi-distribution configurations; ---------------------------------. The ``install-distribution`` target described above is for building a single; distribution. LLVM's build system also supports building multiple distributions,; which can be used to e.g. have one distribution containing just tools and; another for libraries (to enable development). These are configured by setting; the *LLVM_DISTRIBUTIONS* variable to hold a list of all distribution names; (which conventionally start with an uppercase letter, e.g. ""Development""), and; then setting the *LLVM_<distribution>_DISTRIBUTION_COMPONENTS* variable to the; list of targets for that distribution. For each distribution, the build system; generates an ``install-${distribution}-distribution`` target, where; ``${distribution}`` is the name of the distribution in lowercase, to install; that distribution. Each distribution creates its own set of CMake exports, and the target to; install the CMake exports for a particular distribution for a project is named; ``${project}",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:4215,config,configurations,4215,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['config'],['configurations']
Modifiability,"l functions. The aim of these classes is to extend and improve the fitting functionality provided in ROOT via the TVirtualFitter classes and the fitting methods present in many data analysis object, such as TH1::Fit.; ; The fit data are decoupled from the fitter class and described by the dedicated fit data classes like the ROOT::Fit::BinData for bin data containing coordinate values of any dimensions, bin content values and optionally errors in coordinate and bin content, and ROOT::Fit::UnBinData classes for any dimension un-bin data.; The fitter class, ROOT::Fit::Fitter, provides the functionality for fitting those data with any model function implementing the parametric function interface, ROOT::Math::IParamMultiFunction. Fit methods such as least square, bin and un-bin likelihood are supported. The fit solution is then found by using the ROOT::Math::Minimizer interface class and the results are stored in the ROOT::Fit::FitResult class. Fit parameter can be configured individually using the ROOT::Fit::FitParameterSettings class.; ; Various implementation of the minimizer interface can be used automatically using the ROOT plug-in manager mechanism, including the linear fitter for a fast and direct solution, in case of a linear least square model, or by using Minuit, Minuit2 or GSL minimization methods provided by the MathMore library. Functions for filling the new ROOT::Fit::BinData classes with all the histogram and graph types have been added in the histogram library (libHist) and graph library:; ; ROOT::Fit::FillData( BinData & , const TH1 *, TF1 * ) for histograms (in libHist); ROOT::Fit::FillData( BinData & , const TGraph2D *, TF1 * ) for 2D graphs (in libHist); ROOT::Fit::FillData( BinData & , const TGraph *, TF1 * ) for all 1D graphs (in libGraf); ROOT::Fit::FillData( BinData & , const TMultiGraph *, TF1 * ) for multi-graphs (in libGraf); . MathCore Numerical Algorithms. Classes implementing numerical methods which can be used by all the other ROOT library ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:5054,config,configured,5054,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['config'],['configured']
Modifiability,"l just use it to emit code. Expression Code Generation; ==========================. Generating LLVM code for expression nodes is very straightforward: less; than 45 lines of commented code for all four of our expression nodes.; First we'll do numeric literals:. .. code-block:: c++. Value *NumberExprAST::codegen() {; return ConstantFP::get(*TheContext, APFloat(Val));; }. In the LLVM IR, numeric constants are represented with the; ``ConstantFP`` class, which holds the numeric value in an ``APFloat``; internally (``APFloat`` has the capability of holding floating point; constants of Arbitrary Precision). This code basically just creates; and returns a ``ConstantFP``. Note that in the LLVM IR that constants; are all uniqued together and shared. For this reason, the API uses the; ""foo::get(...)"" idiom instead of ""new foo(..)"" or ""foo::Create(..)"". .. code-block:: c++. Value *VariableExprAST::codegen() {; // Look this variable up in the function.; Value *V = NamedValues[Name];; if (!V); LogErrorV(""Unknown variable name"");; return V;; }. References to variables are also quite simple using LLVM. In the simple; version of Kaleidoscope, we assume that the variable has already been; emitted somewhere and its value is available. In practice, the only; values that can be in the ``NamedValues`` map are function arguments.; This code simply checks to see that the specified name is in the map (if; not, an unknown variable is being referenced) and returns the value for; it. In future chapters, we'll add support for `loop induction; variables <LangImpl05.html#for-loop-expression>`_ in the symbol table, and for `local; variables <LangImpl07.html#user-defined-local-variables>`_. .. code-block:: c++. Value *BinaryExprAST::codegen() {; Value *L = LHS->codegen();; Value *R = RHS->codegen();; if (!L || !R); return nullptr;. switch (Op) {; case '+':; return Builder->CreateFAdd(L, R, ""addtmp"");; case '-':; return Builder->CreateFSub(L, R, ""subtmp"");; case '*':; return Builder->CreateFMul(L, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:5700,variab,variable,5700,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['variab'],['variable']
Modifiability,"l macros are expressions, and require a semi-colon to be; added; sometimes this is not the case, and this allows to make; clang-format aware of such cases. For example: Q_UNUSED. .. _TabWidth:. **TabWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <TabWidth>`; The number of columns used for tab stops. .. _TypeNames:. **TypeNames** (``List of Strings``) :versionbadge:`clang-format 17` :ref:`¶ <TypeNames>`; A vector of non-keyword identifiers that should be interpreted as type; names. A ``*``, ``&``, or ``&&`` between a type name and another non-keyword; identifier is annotated as a pointer or reference token instead of a; binary operator. .. _TypenameMacros:. **TypenameMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <TypenameMacros>`; A vector of macros that should be interpreted as type declarations; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. STACK_OF(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. TypenameMacros: ['STACK_OF', 'LIST']. For example: OpenSSL STACK_OF, BSD LIST_ENTRY. .. _UseCRLF:. **UseCRLF** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <UseCRLF>`; This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``. .. _UseTab:. **UseTab** (``UseTabStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <UseTab>`; The way to use tab characters in the resulting file. Possible values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; align",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:131604,config,configuration,131604,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,2,['config'],"['configuration', 'configured']"
Modifiability,"l memory cache lines will be automatically invalidated by writes; from CUs associated with other L2 caches, or writes from the CPU, due to; the cache probe caused by the PTE C-bit.; * XGMI accesses from the CPU to local memory may be cached on the CPU.; Subsequent access from the GPU will automatically invalidate or writeback; the CPU cache due to the L2 probe filter.; * To ensure coherence of local memory writes of CUs with different L1 caches; in the same agent a ``buffer_wbl2`` is required. It does nothing if the; agent is configured to have a single L2, or will writeback dirty L2 cache; lines if configured to have multiple L2 caches.; * To ensure coherence of local memory writes of CUs in different agents a; ``buffer_wbl2 sc1`` is required. It will writeback dirty L2 cache lines.; * To ensure coherence of local memory reads of CUs with different L1 caches; in the same agent a ``buffer_inv sc1`` is required. It does nothing if the; agent is configured to have a single L2, or will invalidate non-local L2; cache lines if configured to have multiple L2 caches.; * To ensure coherence of local memory reads of CUs in different agents a; ``buffer_inv sc0 sc1`` is required. It will invalidate non-local L2 cache; lines if configured to have multiple L2 caches. * PCIe access from the GPU to the CPU can be kept coherent by using the MTYPE; UC (uncached) which bypasses the L2. Scalar memory operations are only used to access memory that is proven to not; change during the execution of the kernel dispatch. This includes constant; address space and global address space for program scope ``const`` variables.; Therefore, the kernel machine code does not have to maintain the scalar cache to; ensure it is coherent with the vector caches. The scalar and vector caches are; invalidated between kernel dispatches by CP since constant address space data; may change between kernel dispatch executions. See; :ref:`amdgpu-amdhsa-memory-spaces`. The one exception is if scalar writes are used",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:289359,config,configured,289359,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,2,['config'],['configured']
Modifiability,"l other; cross-coding is based on strings that are run on the Python interpreter; and vise-versa. With the ROOT v4.00/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first before use. It is possible to switch between interpreters; by calling **`TPython::Prompt()`** on the ROOT side, while returning with; `^D` (`EOF`). State is preserved between successive switches, and string; based cross calls can nest as long as shared resources are properly; handled. ``` {.cpp}; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; ```. ### Installation. There are several ways of obtaining `PyROOT`, and which is best depends; on your specific situation. If you work at CERN, you can use the; installation available on `afs`. Otherwise, you will want to build from; source, as `PyROOT` is not build by default in the binaries distributed; from the ROOT project site. If you download the ROOT binaries, take care; to download and install the Python distribution from; <http://www.python.org/> against which they were built. #### Environment Settings. ROOT installations with the build of `PyROOT` enabled are available from; the CERN `afs` cell `/afs/cern.ch/sw/root/<version>/<platform>`. To use; them, simply modify your shell environment accordingly. For Unix:. `export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:5304,variab,variables,5304,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['variab'],['variables']
Modifiability,"l pointer, then a null pointer is passed as the argument,; and no further work is required for the pass-by-writeback.; #. Otherwise, a temporary of type ``T __autoreleasing`` is created and; initialized to a null pointer.; #. If the parameter is not an Objective-C method parameter marked ``out``,; then ``*p`` is read, and the result is written into the temporary with; primitive semantics.; #. The address of the temporary is passed as the argument to the actual call.; #. After the call completes, the temporary is loaded with primitive; semantics, and that value is assigned into ``*p``. .. admonition:: Rationale. This is all admittedly convoluted. In an ideal world, we would see that a; local variable is being passed to an out-parameter and retroactively modify; its type to be ``__autoreleasing`` rather than ``__strong``. This would be; remarkably difficult and not always well-founded under the C type system.; However, it was judged unacceptably invasive to require programmers to write; ``__autoreleasing`` on all the variables they intend to use for; out-parameters. This was the least bad solution. .. _arc.ownership.restrictions.records:. Ownership-qualified fields of structs and unions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A member of a struct or union may be declared to have ownership-qualified; type. If the type is qualified with ``__unsafe_unretained``, the semantics; of the containing aggregate are unchanged from the semantics of an unqualified type in a non-ARC mode. If the type is qualified with ``__autoreleasing``, the program is ill-formed. Otherwise, if the type is nontrivially ownership-qualified, additional rules apply. Both Objective-C and Objective-C++ support nontrivially ownership-qualified; fields. Due to formal differences between the standards, the formal; treatment is different; however, the basic language model is intended to; be the same for identical code. .. admonition:: Rationale. Permitting ``__strong`` and ``__weak`` references ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:51086,variab,variables,51086,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variables']
Modifiability,"l temperature. MinTemp No 1e-06 − Mimimum temperature. Eps No 1e-10 − Epsilon. TempScale No 1 − Temperature scale. AdaptiveSpeed No 1 − Adaptive speed. TempAdaptiveStep No 0.009875 − Step made in each generation temperature adaptive. UseDefaultScale No False − Use default temperature scale for temperature minimisation algorithm. UseDefaultTemp No False − Use default initial temperature. KernelTemp No IncAdaptive IncAdaptive, DecAdaptive, Sqrt, Log, Sin, Homo, Geo Temperature minimisation algorithm. Configuration options for setup and tuning of specific fitter :. Configuration options reference for fitting method: Monte Carlo sampling (MC). Option Array Default value Predefined values Description. SampleSize No 100000 − Number of Monte Carlo events in toy sample. Sigma No -1 − If > 0: new points are generated according to Gauss around best value and with Sigma in units of interval length. Seed No 100 − Seed for the random generator (0 takes random seeds). Configuration options for setup and tuning of specific fitter :. Configuration options reference for fitting method: TMinuit (MT). Option Array Default value Predefined values Description. ErrorLevel No 1 − TMinuit: error level: 0.5=logL fit, 1=chi-squared fit. PrintLevel No -1 − TMinuit: output level: -1=least, 0, +1=all garbage. FitStrategy No 2 − TMinuit: fit strategy: 2=best. PrintWarnings No False − TMinuit: suppress warnings. UseImprove No True − TMinuit: use IMPROVE. UseMinos No True − TMinuit: use MINOS. SetBatch No False − TMinuit: use batch mode. MaxCalls No 1000 − TMinuit: approximate maximum number of function calls. Tolerance No 0.1 − TMinuit: tolerance to the function value at the minimum. Configuration options for setup and tuning of specific fitter :. Configuration options reference for fitting method: Genetic Algorithm (GA). Option Array Default value Predefined values Description. PopSize No 300 − Population size for GA. Steps No 40 − Number of steps for convergence. Cycles No 3 − Independent cycles",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:30364,Config,Configuration,30364,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['Config'],['Configuration']
Modifiability,"l to an immediate function.; (`#66324 <https://github.com/llvm/llvm-project/issues/66324>`_). - Fix crash for a lambda attribute with a statement expression; that contains a `return`.; (`#48527 <https://github.com/llvm/llvm-project/issues/48527>`_). - Clang now no longer asserts when an UnresolvedLookupExpr is used as an; expression requirement. (`#66612 <https://github.com/llvm/llvm-project/issues/66612>`_). - Clang now disambiguates NTTP types when printing diagnostics where the; NTTP types are compared with the 'diff' method.; (`#66744 <https://github.com/llvm/llvm-project/issues/66744>`_). - Fix crash caused by a spaceship operator returning a comparision category by; reference. Fixes:; (`#64162 <https://github.com/llvm/llvm-project/issues/64162>`_); - Fix a crash when calling a consteval function in an expression used as; the size of an array.; (`#65520 <https://github.com/llvm/llvm-project/issues/65520>`_). - Clang no longer tries to capture non-odr-used variables that appear; in the enclosing expression of a lambda expression with a noexcept specifier.; (`#67492 <https://github.com/llvm/llvm-project/issues/67492>`_). - Fix crash when fold expression was used in the initialization of default; argument. Fixes:; (`#67395 <https://github.com/llvm/llvm-project/issues/67395>`_). - Fixed a bug causing destructors of constant-evaluated structured bindings; initialized by array elements to be called in the wrong evaluation context. - Fix crash where ill-formed code was being treated as a deduction guide and; we now produce a diagnostic. Fixes:; (`#65522 <https://github.com/llvm/llvm-project/issues/65522>`_). - Fixed a bug where clang incorrectly considered implicitly generated deduction; guides from a non-templated constructor and a templated constructor as ambiguous,; rather than prefer the non-templated constructor as specified in; [standard.group]p3. - Fixed a crash caused by incorrect handling of dependence on variable templates; with non-type template parameters o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:50682,variab,variables,50682,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['variab'],['variables']
Modifiability,"l variables that can be shared in the parallel regions; are stored in the global memory. In `Cuda` mode local variables are not shared; between the threads and it is user responsibility to share the required data; between the threads in the parallel regions. Often, the optimizer is able to; reduce the cost of `Generic` mode to the level of `Cuda` mode, but the flag,; as well as other assumption flags, can be used for tuning. Features not supported or with limited support for Cuda devices; ---------------------------------------------------------------. - Cancellation constructs are not supported. - Doacross loop nest is not supported. - User-defined reductions are supported only for trivial types. - Nested parallelism: inner parallel regions are executed sequentially. - Debug information for OpenMP target regions is supported, but sometimes it may; be required to manually specify the address class of the inspected variables.; In some cases the local variables are actually allocated in the global memory,; but the debug info may be not aware of it. .. _OpenMP implementation details:. OpenMP 5.0 Implementation Details; =================================. The following table provides a quick overview over various OpenMP 5.0 features; and their implementation status. Please post on the; `Discourse forums (Runtimes - OpenMP category)`_ for more; information or if you want to help with the; implementation. +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; |Category | Feature | Status | Reviews |; +==============================+==============================================================+==========================+=======================================================================+; | loop | support != in the canonical loop form | :good:`done` | D54441 |; +------------------------------+--------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:2739,variab,variables,2739,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['variab'],['variables']
Modifiability,"l(""#id"") references; 17. Use latest three.js r85; 18. Fix 'transpXY' URL parameter handling - it was used as opacity, but opacity=1-transparency. ## Changes in 5.1.2; 1. Fix - support newest TFormula in TF1 (#127); 2. Fix - ignore NaN value in saved TF1 buffer; 3. Fix - correctly treat transparency in geo painter; 4. Fix - disable useFontCache for SVG mathjax output; 5. Fix - produce PNG image for objects with special symbols in names. ## Changes in 5.1.1; 1. Fix - invoke callback in JSROOT.draw() at proper time; 2. Fix - support TGeoHMatrix, produced after GDML conversion; 3. Fix - support also TGeoScale and TGeoGenTrans matrices; 4. Fix - update histograms with all provided functions (#125). ## Changes in 5.1.0; 1. New 'float' browser kind overlays with objects drawing; 2. Browser can be enabled after drawing with 'nobrowser' mode; 3. One can hide browser or switch browser kind at any time; 4. New 'horizontal' and 'vertical' layouts for object display.; One could configure several frames, each divided on sub-frames.; Like display=horiz231 will create three horizontal frames,; divided on 2,3 and 1 sub-frames.; 5. One could enable status line where current tooltip info will be shown; 6. Improve enlarge functionality - now works with all layouts; 7. Do not display all canvas tool buttons by default - provide toggle button instead; 8. Let move TAxis title, its position now similar to ROOT graphics; 9. Support 'col0' option for TH2Poly class to suppress empty bins; 10. Implement for TH3 'box2', 'box3', 'glbox2', 'glcol' draw options; 11. Support more superscript/subscript letters in normal text output; 12. Correctly handle unzoom with logx/logy scales; 13. Let disable stamp parameter in file url with ""-"" sign at the end of file name; 14. Let use quotes in the URL parameters to protect complex arguments with special symbols; 15. Introduce direct streamers - like TBasket or TRef; Benefit - one can add custom streamers of such kind or reuse existing; 16. Handle TMatrixTSym",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:44613,config,configure,44613,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['config'],['configure']
Modifiability,"l(), Scope));; }. This both tells the main ``IRBuilder`` where we are, but also what scope; we're in. The scope can either be on compile-unit level or be the nearest; enclosing lexical block like the current function.; To represent this we create a stack of scopes in ``DebugInfo``:. .. code-block:: c++. std::vector<DIScope *> LexicalBlocks;. and push the scope (function) to the top of the stack when we start; generating the code for each function:. .. code-block:: c++. KSDbgInfo.LexicalBlocks.push_back(SP);. Also, we may not forget to pop the scope back off of the scope stack at the; end of the code generation for the function:. .. code-block:: c++. // Pop off the lexical block for the function since we added it; // unconditionally.; KSDbgInfo.LexicalBlocks.pop_back();. Then we make sure to emit the location every time we start to generate code; for a new AST object:. .. code-block:: c++. KSDbgInfo.emitLocation(this);. Variables; =========. Now that we have functions, we need to be able to print out the variables; we have in scope. Let's get our function arguments set up so we can get; decent backtraces and see how our functions are being called. It isn't; a lot of code, and we generally handle it when we're creating the; argument allocas in ``FunctionAST::codegen``. .. code-block:: c++. // Record the function arguments in the NamedValues map.; NamedValues.clear();; unsigned ArgIdx = 0;; for (auto &Arg : TheFunction->args()) {; // Create an alloca for this variable.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());. // Create a debug descriptor for the variable.; DILocalVariable *D = DBuilder->createParameterVariable(; SP, Arg.getName(), ++ArgIdx, Unit, LineNo, KSDbgInfo.getDoubleTy(),; true);. DBuilder->insertDeclare(Alloca, D, DBuilder->createExpression(),; DILocation::get(SP->getContext(), LineNo, 0, SP),; Builder->GetInsertBlock());. // Store the initial value into the alloca.; Builder->CreateStore(&Arg, Alloca);. // Add arguments to varia",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst:12986,variab,variables,12986,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,1,['variab'],['variables']
Modifiability,"l. ## Status and usage. **Status**: Experimental work in progress. Enabling is strongly advised against; except for development and testing. **Enable in Clang**: `-Xclang -fexperimental-assignment-tracking`. That causes Clang to get LLVM to run the pass `declare-to-assign`. The pass; converts conventional debug intrinsics to assignment tracking metadata and sets; the module flag `debug-info-assignment-tracking` to the value `i1 true`. To; check whether assignment tracking is enabled for a module call; `isAssignmentTrackingEnabled(const Module &M)` (from `llvm/IR/DebugInfo.h`). ## Design and implementation. ### Assignment markers: `llvm.dbg.assign`. `llvm.dbg.value`, a conventional debug intrinsic, marks out a position in the; IR where a variable takes a particular value. Similarly, Assignment Tracking; marks out the position of assignments with a new intrinsic called; `llvm.dbg.assign`. In order to know where in IR it is appropriate to use a memory location for a; variable, each assignment marker must in some way refer to the store, if any; (or multiple!), that performs the assignment. That way, the position of the; store and marker can be considered together when making that choice. Another; important benefit of referring to the store is that we can then build a two-way; mapping of stores<->markers that can be used to find markers that need to be; updated when stores are modified. An `llvm.dbg.assign` marker that is not linked to any instruction signals that; the store that performed the assignment has been optimised out, and therefore; the memory location will not be valid for at least some part of the program. Here's the `llvm.dbg.assign` signature. Each parameter is wrapped in; `MetadataAsValue`, and `Value *` type parameters are first wrapped in; `ValueAsMetadata`:. ```; void @llvm.dbg.assign(Value *Value,; DIExpression *ValueExpression,; DILocalVariable *Variable,; DIAssignID *ID,; Value *Address,; DIExpression *AddressExpression); ```. The first three paramete",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:2067,variab,variable,2067,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,1,['variab'],['variable']
Modifiability,"l. Accepted values are:. * add - Returns the sum of its two operands.; * div - Returns the quotient of its two operands.; * max - Returns the largest of its two operands.; * min - Returns the smallest of its two operands.; * mul - Returns the product of its two operands.; * sub - Returns the difference of its two operands. * ``<arguments>`` is a comma separated list of expressions. For example:. .. code-block:: llvm. ; CHECK: load r[[#REG:]], [r0]; ; CHECK: load r[[#REG+1]], [r1]; ; CHECK: Loading from 0x[[#%x,ADDR:]]; ; CHECK-SAME: to 0x[[#ADDR + 7]]. The above example would match the text:. .. code-block:: gas. load r5, [r0]; load r6, [r1]; Loading from 0xa0463440 to 0xa0463447. but would not match the text:. .. code-block:: gas. load r5, [r0]; load r7, [r1]; Loading from 0xa0463440 to 0xa0463443. Due to ``7`` being unequal to ``5 + 1`` and ``a0463443`` being unequal to; ``a0463440 + 7``. A numeric variable can also be defined to the result of a numeric expression,; in which case the numeric expression constraint is checked and if verified the; variable is assigned to the value. The unified syntax for both checking a; numeric expression and capturing its value into a numeric variable is thus; ``[[#%<fmtspec>,<NUMVAR>: <constraint> <expr>]]`` with each element as; described previously. One can use this syntax to make a testcase more; self-describing by using variables instead of values:. .. code-block:: gas. ; CHECK: mov r[[#REG_OFFSET:]], 0x[[#%X,FIELD_OFFSET:12]]; ; CHECK-NEXT: load r[[#]], [r[[#REG_BASE:]], r[[#REG_OFFSET]]]. which would match:. .. code-block:: gas. mov r4, 0xC; load r6, [r5, r4]. The ``--enable-var-scope`` option has the same effect on numeric variables as; on string variables. Important note: In its current implementation, an expression cannot use a; numeric variable defined earlier in the same CHECK directive. FileCheck Pseudo Numeric Variables; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Sometimes there's a need to verify output that contains line n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:32609,variab,variable,32609,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,2,['variab'],['variable']
Modifiability,"l; In 2020, the monorepo had just under 35 thousand commits. This works; out to an average of 4 commits per hour. Already, we can see that a; builder must cycle in less than 15 minutes to have a hope of being; useful. However, those commits are not uniformly distributed. They; tend to cluster strongly during US working hours. Looking at a couple; of recent (Nov 2021) working days, we routinely see ~10 commits per; hour during peek times, with occasional spikes as high as ~15 commits; per hour. Thus, as a rule of thumb, we should plan for our builder to; complete ~10-15 builds an hour. Resource Appropriately; At 10-15 builds per hour, we need to complete a new build on average every; 4 to 6 minutes. For anything except the fastest of hardware/build configs,; this is going to be well beyond the ability of a single machine. In buildbot; terms, we likely going to need multiple workers to build requests in parallel; under a single builder configuration. For some rough back of the envelope; numbers, if your build config takes e.g. 30 minutes, you will need something; on the order of 5-8 workers. If your build config takes ~2 hours, you'll; need something on the order of 20-30 workers. The rest of this section; focuses on how to reduce cycle times. Restrict what you build and test; Think hard about why you're setting up a bot, and restrict your build; configuration as much as you can. Basic functionality is probably; already covered by other bots, and you don't need to duplicate that; testing. You only need to be building and testing the *unique* parts; of the configuration. (e.g. For a multi-stage clang builder, you probably; don't need to be enabling every target or building all the various utilities.). It can sometimes be worthwhile splitting a single builder into two or more,; if you have multiple distinct purposes for the same builder. As an example,; if you want to both a) confirm that all of LLVM builds with your host; compiler, and b) want to do a multi-stage clang",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:9116,config,config,9116,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['config'],['config']
Modifiability,"l; read it from the file and create an object in memory. Here we draw the; profile histogram, and then we list the contents. ``` {.cpp}; root[] hprof->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] f->ls(); TFile** hsimple.root; TFile* hsimple.root; OBJ: TProfile hprof Profile of pz versus px : 0; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; ```. We now see a new line that starts with OBJ. This means that an object of; class **`TProfile`**, called `hprof` has been added in memory to this; directory. This new `hprof` in memory is independent from the `hprof` on; disk. If we make changes to the `hprof` in memory, they are not; propagated to the `hprof` on disk. A new version of `hprof` will be; saved once we call `Write`. You may wonder why `hprof` is added to the objects in the current; directory. `hprof` is of the class **`TProfile`** that inherits from; **`TH1D`**, which inherits from **`TH1`**. **`TH1`** is the basic; histogram. All histograms and trees are created in the current directory; (also see ""Histograms and the Current Directory""). The reference to ""all; histograms"" includes objects of any class descending directly or; indirectly from **`TH1`**. Hence, our **`TProfile`** `hprof` is created; in the current directory `f.`There was another side effect when we; called the `TH1::Draw` method. ROOT printed this statement:. ``` {.cpp}; <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; ```. It tells us that a **`TCanvas`** was created and it named it `c1`. This; is where ROOT is being nice, and it creates a canvas for drawing the; histogram if no canvas was named in the draw command, and if no active; canvas exists. The newly created canvas, however, is NOT listed in the; contents of the current directory. Why is that? The canvas is not added; to the current directory, because by default ONLY histograms and tr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:25586,inherit,inherits,25586,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,2,['inherit'],['inherits']
Modifiability,"lClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). FitMethod No GA GA, SA, MC, MCEvents, MINUIT, EventScan Minimisation Method (GA, SA, and MC are the primary methods to be used; the others have been introduced for testing purposes and are depreciated). EffMethod No EffSel EffSel, EffPDF Selection Method. CutRangeMin Yes -1 − Minimum of allowed cut range (set per variable). CutRangeMax Yes -1 − Maximum of allowed cut range (set per variable). VarProp Yes NotEnforced NotEnforced, FMax, FMin, FSmart Categorisation of cuts. Configuration options for MVA method :. Configuration options reference for MVA method: PDEFoam. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). SigBgSeparate No False − Separate foams for signal an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:25630,Config,Configuration,25630,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['Config'],['Configuration']
Modifiability,"lClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). NCycles No 3000 − Number of training cycles. HiddenLayers No N,N-1 − Specification of hidden layer architecture. Configuration options for MVA method :. Configuration options reference for MVA method: KNN. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). nkNN No 20 − Number of k-nearest neighbors. BalanceDepth No 6 − Binary tree balance depth. ScaleFrac No 0.8 − Fraction of events used to compute variable width. SigmaFact No 1 − Scale factor for sigma in Gaussian kernel. Kernel No Gaus − Use polynomial (=Poln) or Gaussian (=Gaus) kernel. Trim No False − Use equal number of signal and background events. UseKernel No False − Use polynomial kernel weight. UseWeight No T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:9786,variab,variable,9786,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,2,['variab'],['variable']
Modifiability,lOrigin.h; clang-tools-extra/clangd/index/YAMLSerialization.cpp; clang-tools-extra/clangd/index/dex/Iterator.cpp; clang-tools-extra/clangd/index/dex/Iterator.h; clang-tools-extra/clangd/index/dex/PostingList.cpp; clang-tools-extra/clangd/index/dex/PostingList.h; clang-tools-extra/clangd/index/dex/Token.h; clang-tools-extra/clangd/index/dex/Trigram.cpp; clang-tools-extra/clangd/index/dex/Trigram.h; clang-tools-extra/clangd/index/dex/dexp/Dexp.cpp; clang-tools-extra/clangd/index/remote/Client.cpp; clang-tools-extra/clangd/index/remote/Client.h; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.cpp; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.h; clang-tools-extra/clangd/index/remote/monitor/Monitor.cpp; clang-tools-extra/clangd/index/remote/server/Server.cpp; clang-tools-extra/clangd/index/remote/unimplemented/UnimplementedClient.cpp; clang-tools-extra/clangd/indexer/IndexerMain.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.h; clang-tools-extra/clangd/refactor/Rename.h; clang-tools-extra/clangd/refactor/Tweak.cpp; clang-tools-extra/clangd/refactor/Tweak.h; clang-tools-extra/clangd/refactor/tweaks/AddUsing.cpp; clang-tools-extra/clangd/refactor/tweaks/AnnotateHighlightings.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineInline.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineOutline.cpp; clang-tools-extra/clangd/refactor/tweaks/DumpAST.cpp; clang-tools-extra/clangd/refactor/tweaks/ExpandMacro.cpp; clang-tools-extra/clangd/refactor/tweaks/ExtractFunction.cpp; clang-tools-extra/clangd/refactor/tweaks/ObjCLocalizeStringLiteral.cpp; clang-tools-extra/clangd/refactor/tweaks/RemoveUsingNamespace.cpp; clang-tools-extra/clangd/refactor/tweaks/SwapIfBranches.cpp; clang-tools-extra/clangd/support/Cancellation.cpp; clang-tools-extra/clangd/support/Cancellation.h; clang-tools-extra/clangd/support/Context.cpp; clang-tools-extra/clangd/support/Context.h; clang-tools-extra/clangd/support,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:80079,refactor,refactor,80079,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,"l` or `cvmfs-server` ones. - As root user, run:. # cvmfs_config setup. - Start the `autofs` service: how to to this depends on your operating; system. On Ubuntu using Upstart:. # restart autofs. On RHEL-based or older Ubuntus:. # service autofs restart. - Prepare a `/etc/cvmfs/default.local` file (create it if it does not; exists) with the following configuration bits:. ``` {.bash}; CVMFS_HTTP_PROXY=http://your-proxy-server.domain.ch:3128,DIRECT; CVMFS_REPOSITORIES=your-experiment.cern.ch,sft.cern.ch; CVMFS_QUOTA_LIMIT=50000; ```. You need to properly specify your closest HTTP caching proxy:; separate many of them via commas. The last fallback value, `DIRECT`,; tells cvmfs to connect directly without using any proxy at all. Among the list of repositories (comma-separated), always specify; `sft.cern.ch` and the one containing the software to your experiment; (e.g., `cms.cern.ch`). The quota limit is, in Megabytes, the amount of local disk space to; use as cache. - Check the configuration and repositories with:. # cvmfs_config chksetup; OK; # cvmfs_config probe; Probing /cvmfs/cms.cern.ch... OK; Probing /cvmfs/sft.cern.ch... OK. > You might need special configurations for some custom software; > repositories! Special cases are not covered in this guide. ### Firewall configuration. [PROOF on Demand](http://pod.gsi.de/) is very flexible in handling; various cases of network topologies. The best solution would be to allow; all TCP communications between the cluster machines. No other incoming communication is required from the outside. Configuration steps for the head node only; ------------------------------------------. ### Setup HTTPS+SSH (sshcertauth) authentication. > Latest recommended sshcertauth version is 0.8.5.; >; > [Download](https://github.com/dberzano/sshcertauth/archive/v0.8.5.zip); > and [read the; > instructions](http://newton.ph.unito.it/~berzano/w/doku.php?id=proof:sshcertauth). If you want your users to connect to the PROOF cluster using their Grid; u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md:3385,config,configuration,3385,proof/doc/confman/ConfigProofPoD.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md,1,['config'],['configuration']
Modifiability,"l`` instance can be printed to an output stream with the ``<<``; operator. ``RecTy``; ---------. The ``RecTy`` class is used to represent the types of field values. It is; the base class for a series of subclasses, one for each of the; available field types. The ``RecTy`` class has one data member that is an; enumerated type specifying the specific type of field value. (A better; name for this class might be ``FieldTy``.). The ``RecTy`` class provides a few useful functions. * A virtual function to get the type name as a string. * A virtual function to check whether all the values of this type can; be converted to another given type. * A virtual function to check whether this type is a subtype of; another given type. * A function to get the corresponding ``list``; type for lists with elements of this type. For example, the function; returns the ``list<int>`` type when called with the ``int`` type. The subclasses that inherit from ``RecTy`` are; ``BitRecTy``,; ``BitsRecTy``,; ``CodeRecTy``,; ``DagRecTy``,; ``IntRecTy``,; ``ListRecTy``,; ``RecordRecTy``, and; ``StringRecTy``.; Some of these classes have additional members that; are described in the following subsections. *All* of the classes derived from ``RecTy`` provide the ``get()`` function.; It returns an instance of ``Recty`` corresponding to the derived class.; Some of the ``get()`` functions require an argument to; specify which particular variant of the type is desired. These arguments are; described in the following subsections. A ``RecTy`` instance can be printed to an output stream with the ``<<``; operator. .. warning::; It is not specified whether there is a single ``RecTy`` instance of a; particular type or multiple instances. ``BitsRecTy``; ~~~~~~~~~~~~~. This class includes a data member with the size of the ``bits`` value and a; function to get that size. The ``get()`` function takes the length of the sequence, *n*, and returns the; ``BitsRecTy`` type corresponding to ``bits<``\ *n*\ ``>``. ``ListRec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst:6763,inherit,inherit,6763,interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,1,['inherit'],['inherit']
Modifiability,"lag to remove labels which may exceed graphical range; 22. Let disable usage of TAxis custom labels via context menu; 23. Let configure default draw options via context menu, they can be preserved in the local storage; 24. Let save canvas as JSON file from context menu, object as JSON from inspector; 25. Upgrade three.js r162 -> r168, use r162 only in node.js because of ""gl"" module; 26. Create unified svg2pdf/jspdf ES6 modules, integrate in jsroot builds; 27. Let create multipage PDF document - in TWebCanvas batch mode; 28. Let add external links via `#url[link]{label}` syntax - including jsPDF support; 29. Support TAttMarker style with line width bigger than 1; 30. Internals - upgrade to eslint 9; 31. Internals - do not select pad (aka gPad) for objects drawing, always use assigned pad painter; 32. Fix - properly save zoomed ranges in drawingJSON(); 33. Fix - properly redraw TMultiGraph; 34. Fix - show empty bin in TProfile2D if it has entries #316; 35. Fix - unzooming on log scale was extending range forevever; 36. Fix - do not force style 8 for hist markers; 37. Fix - ensure minimal hist title height; 38. Fix - disable Bloom effects on Android TGeo displays; 39. Fix - handle reordering of fragments in multipart reply #319; 40. Fix - properly show non-zero entries #320; 41. Fix - display empty hist bin if fSumw2 not zero. ## Changes in 7.7.4; 1. Fix - TGraph Y range selection, do not cross 0; 2. Fix - correctly handle `#font[id]` in latex; 3. Fix - store canvas with embed geometry drawing; 4. Fix - upgrade rollup and import.meta polyfill. ## Changes in 7.7.3; 1. Fix - correctly handle in I/O empty std::map; 2. Fix - reading of small (<1KB) ROOT files; 3. Fix - race condition in zstd initialization #318; 4. Fix - deployment with zstd #317. ## Changes in 7.7.2; 1. Fix - hide empty title on the canvas; 2. Fix - properly handle zooming in THStack histogram; 3. Fix - always use 0 as minimum in THStack drawings; 4. Fix - always show all ticks for labeled axis; 5. Fix - ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:2492,extend,extending,2492,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['extend'],['extending']
Modifiability,"lang -fsyntax-only t.c; t.c:13:9: error: member reference base type 'pid_t' (aka 'int') is not a structure or union; myvar = myvar.x;; ~~~~~ ^. In C++, type preservation includes retaining any qualification written into type names. For example, if we take a small snippet of code such as:. namespace services {; struct WebService { };; }; namespace myapp {; namespace servers {; struct Server { };; }; }. using namespace myapp;; void addHTTPService(servers::Server const &server, ::services::WebService const *http) {; server += http;; }. and then compile it, we see that Clang is both providing accurate information and is retaining the types as written by the user (e.g., ""servers::Server"", ""::services::WebService""):. $ clang -fsyntax-only t.cpp; t.cpp:9:10: error: invalid operands to binary expression ('servers::Server const' and '::services::WebService const *'); server += http;; ~~~~~~ ^ ~~~~. Naturally, type preservation extends to uses of templates, and Clang retains information about how a particular template specialization (like std::vector<Real>) was spelled within the source code. For example:. $ clang -fsyntax-only t.cpp; t.cpp:12:7: error: incompatible type assigning 'vector<Real>', expected 'std::string' (aka 'class std::basic_string<char>'); str = vec;; ^ ~~~. Fix-it Hints; ""Fix-it"" hints provide advice for fixing small, localized problems; in source code. When Clang produces a diagnostic about a particular; problem that it can work around (e.g., non-standard or redundant; syntax, missing keywords, common mistakes, etc.), it may also provide; specific guidance in the form of a code transformation to correct the; problem. In the following example, Clang warns about the use of a GCC; extension that has been considered obsolete since 1993. The underlined; code should be removed, then replaced with the code below the; point line ("".x ="" or "".y ="", respectively). $ clang t.c; t.c:5:28: warning: use of GNU old-style field designator extension; struct point origin = {",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:5776,extend,extends,5776,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,2,['extend'],['extends']
Modifiability,"lang with PGO; =======================. If you prefer to not use the script or the cmake cache, this briefly goes over; how to build Clang/LLVM with PGO. First, you should have at least LLVM, Clang, and compiler-rt checked out; locally. Next, at a high level, you're going to need to do the following:. 1. Build a standard Release Clang and the relevant libclang_rt.profile library; 2. Build Clang using the Clang you built above, but with instrumentation; 3. Use the instrumented Clang to generate profiles, which consists of two steps:. - Running the instrumented Clang/LLVM/lld/etc. on tasks that represent how; users will use said tools.; - Using a tool to convert the ""raw"" profiles generated above into a single,; final PGO profile. 4. Build a final release Clang (along with whatever other binaries you need); using the profile collected from your benchmark. In more detailed steps:. 1. Configure a Clang build as you normally would. It's highly recommended that; you use the Release configuration for this, since it will be used to build; another Clang. Because you need Clang and supporting libraries, you'll want; to build the ``all`` target (e.g. ``ninja all`` or ``make -j4 all``). 2. Configure a Clang build as above, but add the following CMake args:. - ``-DLLVM_BUILD_INSTRUMENTED=IR`` -- This causes us to build everything; with instrumentation.; - ``-DLLVM_BUILD_RUNTIME=No`` -- A few projects have bad interactions when; built with profiling, and aren't necessary to build. This flag turns them; off.; - ``-DCMAKE_C_COMPILER=/path/to/stage1/clang`` - Use the Clang we built in; step 1.; - ``-DCMAKE_CXX_COMPILER=/path/to/stage1/clang++`` - Same as above. In this build directory, you simply need to build the ``clang`` target (and; whatever supporting tooling your benchmark requires). 3. As mentioned above, this has two steps: gathering profile data, and then; massaging it into a useful form:. a. Build your benchmark using the Clang generated in step 2. The 'standard'; benchmark",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst:3778,config,configuration,3778,interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst,1,['config'],['configuration']
Modifiability,"lang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operation.; Although the rules in one action may have a number of different implementations,; they should strive to produce a similar result. It should be easy for users to; identify which refactoring action produced the result regardless of which; refactoring action rule was used. The distinction between actions and rules enables the creation of actions; that define a set of different rules that produce similar results. For example,; the ""add missing switch cases"" refactoring operation typically adds missing; cases to one switch at a time. However, it could be useful to have a; refactoring that works on all switches that operate on a particular enum, as; one could then automatically update all of them after adding a new enum; constant. To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a single switch. The second rule will; describe a global operation that works across translation units and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:2462,refactor,refactoring,2462,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,2,['refactor'],['refactoring']
Modifiability,"lang-target-id`. .. _code-object-composition:. Bundled Code Object Composition; -------------------------------. * Each entry of a bundled code object must have a different bundle entry ID.; * There can be multiple entries for the same processor provided they differ; in target feature settings.; * If there is an entry with a target feature specified as *Any*, then all; entries must specify that target feature as *Any* for the same processor. There may be additional target specific restrictions. .. _compatibility-bundle-entry-id:. Compatibility Rules for Bundle Entry ID; ---------------------------------------. A code object, specified using its Bundle Entry ID, can be loaded and; executed on a target processor, if:. * Their offload kinds are the same.; * Their target triples are compatible.; * Their Target IDs are compatible as defined in :ref:`compatibility-target-id`. .. _clang-target-id:. Target ID; =========. A target ID is used to indicate the processor and optionally its configuration,; expressed by a set of target features, that affect ISA generation. It is target; specific if a target ID is supported, or if the target triple alone is; sufficient to specify the ISA generation. It is used with the ``-mcpu=<target-id>`` and ``--offload-arch=<target-id>``; Clang compilation options to specify the kind of code to generate. It is also used as part of the bundle entry ID to identify the code object. See; :ref:`clang-bundle-entry-id`. Target ID syntax is defined by the following BNF syntax:. .. code::. <target-id> ::== <processor> ( "":"" <target-feature> ( ""+"" | ""-"" ) )*. Where:. **processor**; Is a the target specific processor or any alternative processor name. **target-feature**; Is a target feature name that is supported by the processor. Each target; feature must appear at most once in a target ID and can have one of three; values:. *Any*; Specified by omitting the target feature from the target ID.; A code object compiled with a target ID specifying the default",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:11024,config,configuration,11024,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,1,['config'],['configuration']
Modifiability,"language's runtime; library. The compiler plugin is responsible for generating code which conforms; to the binary interface defined by library, most essentially the :ref:`stack map; <stack-map>`. To subclass ``llvm::GCStrategy`` and register it with the compiler:. .. code-block:: c++. // lib/MyGC/MyGC.cpp - Example LLVM GC plugin. #include ""llvm/CodeGen/GCStrategy.h""; #include ""llvm/CodeGen/GCMetadata.h""; #include ""llvm/Support/Compiler.h"". using namespace llvm;. namespace {; class LLVM_LIBRARY_VISIBILITY MyGC : public GCStrategy {; public:; MyGC() {}; };. GCRegistry::Add<MyGC>; X(""mygc"", ""My bespoke garbage collector."");; }. This boilerplate collector does nothing. More specifically:. * ``llvm.gcread`` calls are replaced with the corresponding ``load``; instruction. * ``llvm.gcwrite`` calls are replaced with the corresponding ``store``; instruction. * No safe points are added to the code. * The stack map is not compiled into the executable. Using the LLVM makefiles, this code; can be compiled as a plugin using a simple makefile:. .. code-block:: make. # lib/MyGC/Makefile. LEVEL := ../..; LIBRARYNAME = MyGC; LOADABLE_MODULE = 1. include $(LEVEL)/Makefile.common. Once the plugin is compiled, code using it may be compiled using ``llc; -load=MyGC.so`` (though MyGC.so may have some other platform-specific; extension):. ::. $ cat sample.ll; define void @f() gc ""mygc"" {; entry:; ret void; }; $ llvm-as < sample.ll | llc -load=MyGC.so. It is also possible to statically link the collector plugin into tools, such as; a language-specific compiler front-end. .. _collector-algos:. Overview of available features; ------------------------------. ``GCStrategy`` provides a range of features through which a plugin may do useful; work. Some of these are callbacks, some are algorithms that can be enabled,; disabled, or customized. This matrix summarizes the supported (and planned); features and correlates them with the collection techniques which typically; require them. .. |v| unicode:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:25167,plugin,plugin,25167,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['plugin'],['plugin']
Modifiability,"lar.angle)),; y(polar.distance * sin(polar.angle)) {; }; Polar denormalize(IO &) {; return Polar(sqrt(x*x+y*y), arctan(x,y));; }. float x;; float y;; };. static void mapping(IO &io, Polar &polar) {; MappingNormalization<NormalizedPolar, Polar> keys(io, polar);. io.mapRequired(""x"", keys->x);; io.mapRequired(""y"", keys->y);; }; };. When writing YAML, the local variable ""keys"" will be a stack allocated; instance of NormalizedPolar, constructed from the supplied polar object which; initializes it x and y fields. The mapRequired() methods then write out the x; and y values as key/value pairs. When reading YAML, the local variable ""keys"" will be a stack allocated instance; of NormalizedPolar, constructed by the empty constructor. The mapRequired; methods will find the matching key in the YAML document and fill in the x and y; fields of the NormalizedPolar object keys. At the end of the mapping() method; when the local keys variable goes out of scope, the denormalize() method will; automatically be called to convert the read values back to polar coordinates,; and then assigned back to the second parameter to mapping(). In some cases, the normalized class may be a subclass of the native type and; could be returned by the denormalize() method, except that the temporary; normalized instance is stack allocated. In these cases, the utility template; MappingNormalizationHeap<> can be used instead. It just like; MappingNormalization<> except that it heap allocates the normalized object; when reading YAML. It never destroys the normalized object. The denormalize(); method can this return ""this"". Default values; --------------; Within a mapping() method, calls to io.mapRequired() mean that that key is; required to exist when parsing YAML documents, otherwise YAML I/O will issue an; error. On the other hand, keys registered with io.mapOptional() are allowed to not; exist in the YAML document being read. So what value is put in the field; for those optional keys?; There are two steps t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:19203,variab,variable,19203,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['variab'],['variable']
Modifiability,"lass A { int operator*(); };; const A &operator<<(const A &a, const A &b);; A a;; a << a; // <-- This matches. cxxOperatorCallExpr(hasOverloadedOperatorName(""<<""))) matches the; specified line and; cxxRecordDecl(hasMethod(hasOverloadedOperatorName(""*""))); matches the declaration of A. Usable as: Matcher<CXXOperatorCallExpr>, Matcher<FunctionDecl>. Matcher<FunctionDecl>hasTrailingReturn; Matches a function declared with a trailing return type. Example matches Y (matcher = functionDecl(hasTrailingReturn())); int X() {}; auto Y() -> int {}. Matcher<FunctionDecl>isConsteval; Matches consteval function declarations and if consteval/if ! consteval; statements. Given:; consteval int a();; void b() { if consteval {} }; void c() { if ! consteval {} }; void d() { if ! consteval {} else {} }; functionDecl(isConsteval()); matches the declaration of ""int a()"".; ifStmt(isConsteval()); matches the if statement in ""void b()"", ""void c()"", ""void d()"". Matcher<FunctionDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<FunctionDecl>isDefaulted; Matches defaulted function declarations. Given:; class A { ~A(); };; class B { ~B() = default; };; functionDecl(isDefaulted()); matches the declaration of ~B, but not ~A. Matcher<FunctionDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:90953,variab,variable,90953,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['variab'],['variable']
Modifiability,"lass.; ```{.cpp}; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rul",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:56292,adapt,adaptive,56292,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['adapt'],['adaptive']
Modifiability,"late instantiation used, like most other class templates.; * Custom streamers need to #include TBuffer.h explicitly (see [section Core Libraries](#core-libs)); * Check and flag short reads as errors in the xroot plugins. This fixes [ROOT-3341].; * Added support for AWS temporary security credentials to TS3WebFile by allowing the security token to be given.; * Resolve an issue when space is freed in a large `ROOT` file and a TDirectory is updated and stored the lower (less than 2GB) freed portion of the file [ROOT-8055]. - ##### TBufferJSON:; + support data members with `//[fN]` comment; + preliminary support of STL containers; + JSON data can be produced with `TObject::SaveAs()` method. ## TTree Libraries. * TChains can now be histogrammed without any C++ code, using the command line tool `rootdrawtree`. It is based on the new class `TSimpleAnalysis`.; * Do not automatically setup read cache during `TTree::Fill()`. This fixes [ROOT-8031].; * Make sure the option ""PARA"" in `TTree::Draw` is used with at least tow variables [ROOT-8196].; * The with `goff` option one can use as many variables as needed. There no more; limitation, like with the options `para`and `candle`.; * Fix detection of errors that appears in nested TTreeFormula [ROOT-8218]; * Better basket size optimization by taking into account meta data and rounding up to next 512 bytes, ensuring a complete cluster fits into a single basket. ### Fast Cloning. We added a cache specifically for the fast option of the TTreeCloner to significantly reduce the run-time when fast-cloning remote files to address [ROOT-5078]. It can be controlled from the `TTreeCloner`, `TTree::CopyEntries` or `hadd` interfaces. The new cache is enabled by default, to update the size of the cache or disable it from `TTreeCloner` use: `TTreeCloner::SetCacheSize`. To do the same from `TTree::CopyEntries` add to the option string ""cachesize=SIZE"". To update the size of the cache or disable it from `hadd`, use the command line option `-caches",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:9072,variab,variables,9072,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['variab'],['variables']
Modifiability,"late()` function is added to RooFit classes that includes a call; to this `evaluate()` function. `translate()` helps implement the Code; Squashing logic. All RooFit classes that should support AD need to use this; function. It creates a string of code, which is then just-in-time compiled; using Cling (C++ interpreter for ROOT). For each of the `translate()`; functions, it is important to call `addResult()` since this is what enables; the squashing to happen. #### Helper Functions. - **RooFit::Detail::CodeSquashContext**: this class maintains the context for squashing of; RooFit models into code. It keeps track of the results of various; expressions to avoid redundant calculations. - **Loop Scopes()**: `beginloop()` and `endloop()` are used to create a scope; for iterating over vector observables (collections of data). This is; especially useful when dealing with data that comes in sets or arrays. - **addToGlobalScope()**: helps add code statements to the global scope; (e.g., to declare variables). - **addToCodeBody()**: adds the input string to the squashed code body. If a; class implements a translate function that wants to emit something to the; squashed code body, it must call this function with the code it wants to; emit. In case of loops, it automatically determines if the code needs to be; stored inside or outside the scope of that loop. - **makeValidVarName()**: takes a string (e.g., a variable name) and converts; it into a valid C++ variable name by replacing any forbidden characters with; underscores. - **buildArg()**: helps convert RooFit objects into arrays or other C++; representations for efficient computation. - **addResult()**: adds (or overwrites) the string representing the result of; a node. > For each `translate()` function, it is important to call `addResult()` since; this is what enables the squashing to happen. - **getResult()**: gets the result for the given node using the node name.; This node also performs the necessary code generation throu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:31662,variab,variables,31662,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['variab'],['variables']
Modifiability,"lateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<CXXRecordDecl>isFinal; Matches if the given method or class declaration is final. Given:; class A final {};. struct B {; virtual void f();; };. struct C : B {; void f() final;; };; matches A and C::f, but not B, C, or B::f. Matcher<CXXRecordDecl>isLambda; Matches the generated class of lambda expressions. Given:; auto x = []{};. cxxRecordDecl(isLambda()) matches the implicit class declaration of; decltype(x). Matcher<CXXRecordDecl>isSameOrDerivedFromstd::string BaseName; Overloaded method as shortcut for; isSameOrDerivedFrom(hasName(...)). Matcher<CXXRecordDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; template <typename T> class X {}; class A {}; X<A> x;; or; template <typename T> class X {}; class A {}; template class X<A>;; or; template <typename T> class X {}; class A {}; extern template class X<A>;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); matches the template instantiation of X<A>. But given; template <typename T> class X {}; class A {};; template <> class X<A> {}; X<A> x;; cxxRecordDecl(hasName(""::X""), isTemplateInstantiation()); does not match, as X<A> is an explicit template specialization. Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<CXXRewrittenBinaryOperator>hasAnyOperatorNameStringRef, ..., StringRef; Matches operator expressions (binary or unary) that have any of the; specified names. hasAnyOperatorName(""+"", ""-""); Is equivalent to; anyOf(hasOperatorName(""+""), hasOperatorName(""-"")). Matcher<CXXRewrittenBinaryOperator>hasOperatorNamest",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:74506,variab,variable,74506,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['variab'],['variable']
Modifiability,"lation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; information via different options - for example,; ``--target=arm-none-eabi -march=armv7-m`` and; ``--target=armv7m-none-eabi`` are equivalent.; Clang normalizes the command line before passing them to the multilib system.; To see what flags are emitted for a given set of command line options, use; the ``-print-multi-flags-experimental`` command line option; along with the rest of the options you want to use.; #. Load ``multilib.yaml`` from sysroot.; #. Generate additional flags. ``multilib.yaml`` contains a ``Mappings`` section,; which specifies how to generate additional flags based on the flags derived; from command line options. Flags are matched using regular expressions.; These regular expressions shall use the POSIX extended regular expression; syntax.; #. Match flags against multilib variants. If the generated flags are a superset; of the flags specified for a multilib variant then the variant is considered; a match.; If more than one variant matches then a toolchain may opt to either use only; the *last* matching multilib variant, or may use all matching variants,; thereby :ref:`layering<multilib-layering>` them.; #. Generate ``-isystem`` and ``-L`` options. Iterate in reverse order over; the matching multilib variants, and generate ``-isystem`` and ``-L``; options based on the multilib variant's directory. .. _multilib-layering:. Multilib layering; =================. When Clang selects multilib variants, it may find that more than one variant; matches. It is up to the ToolChain subclass to decide what to do in this case.; There are two options permitted:. #. Use only the *last* matching multilib variant. This option exists primarily; for compatibility with the previous multilib design.; #",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:3223,extend,extended,3223,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['extend'],['extended']
Modifiability,"lation tool using Clang Transformer. .. contents::; :local:. What is Clang Transformer?; --------------------------. Clang Transformer is a framework for writing C++ diagnostics and program; transformations. It is built on the clang toolchain and the LibTooling library,; but aims to hide much of the complexity of clang's native, low-level libraries. The core abstraction of Transformer is the *rewrite rule*, which specifies how; to change a given program pattern into a new form. Here are some examples of; tasks you can achieve with Transformer:. * warn against using the name ``MkX`` for a declared function,; * change ``MkX`` to ``MakeX``, where ``MkX`` is the name of a declared function,; * change ``s.size()`` to ``Size(s)``, where ``s`` is a ``string``,; * collapse ``e.child().m()`` to ``e.m()``, for any expression ``e`` and method named; ``m``. All of the examples have a common form: they identify a pattern that is the; target of the transformation, they specify an *edit* to the code identified by; the pattern, and their pattern and edit refer to common variables, like ``s``,; ``e``, and ``m``, that range over code fragments. Our first and second examples also; specify constraints on the pattern that aren't apparent from the syntax alone,; like ""``s`` is a ``string``."" Even the first example (""warn ..."") shares this form,; even though it doesn't change any of the code -- it's ""edit"" is simply a no-op. Transformer helps users succinctly specify rules of this sort and easily execute; them locally over a collection of files, apply them to selected portions of; a codebase, or even bundle them as a clang-tidy check for ongoing application. Who is Clang Transformer for?; -----------------------------. Clang Transformer is for developers who want to write clang-tidy checks or write; tools to modify a large number of C++ files in (roughly) the same way. What; qualifies as ""large"" really depends on the nature of the change and your; patience for repetitive editing. In our ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:1206,variab,variables,1206,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['variab'],['variables']
Modifiability,"latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; classes are available, and which libraries to load for them. When `TSystem::Load(""ALib"")` is called, ROOT uses this informa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:19294,plugin,plugin,19294,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,2,['plugin'],['plugin']
Modifiability,"lback to the external path, if the other one isn't available.; # This is the same behavior (try ""internal"", then check the LLVM_EXTERNAL_...; # variable) as in add_llvm_external_project; if(NOT EXISTS ${COMPILER_RT_SRC_ROOT}); # We don't want to set it if LLVM_EXTERNAL_COMPILER_RT_SOURCE_DIR is """"; if(LLVM_EXTERNAL_COMPILER_RT_SOURCE_DIR); set(COMPILER_RT_SRC_ROOT ${LLVM_EXTERNAL_COMPILER_RT_SOURCE_DIR}); endif(); endif(). if(LLVM_BUILD_EXTERNAL_COMPILER_RT AND EXISTS ${COMPILER_RT_SRC_ROOT}/). # Add compiler-rt as an external project.; set(COMPILER_RT_PREFIX ${CMAKE_BINARY_DIR}/projects/compiler-rt). set(STAMP_DIR ${CMAKE_CURRENT_BINARY_DIR}/compiler-rt-stamps/); set(BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}/compiler-rt-bins/). add_custom_target(compiler-rt-clear; COMMAND ${CMAKE_COMMAND} -E remove_directory ${BINARY_DIR}; COMMAND ${CMAKE_COMMAND} -E remove_directory ${STAMP_DIR}; COMMENT ""Clobberring compiler-rt build and stamp directories""; ). # Find all variables that start with COMPILER_RT and populate a variable with; # them.; get_cmake_property(variableNames VARIABLES); foreach(variableName ${variableNames}); if(variableName MATCHES ""^COMPILER_RT""); string(REPLACE "";"" ""\;"" value ""${${variableName}}""); list(APPEND COMPILER_RT_PASSTHROUGH_VARIABLES; -D${variableName}=${value}); endif(); endforeach(). set(compiler_rt_configure_deps); if(TARGET cxx-headers); list(APPEND compiler_rt_configure_deps ""cxx-headers""); endif(); if(LLVM_INCLUDE_TESTS); list(APPEND compiler_rt_configure_deps LLVMTestingSupport); endif(). include(GetClangResourceDir); get_clang_resource_dir(output_resource_dir PREFIX ${LLVM_BINARY_DIR}); get_clang_resource_dir(install_resource_dir); ExternalProject_Add(compiler-rt; DEPENDS llvm-config clang ${compiler_rt_configure_deps}; PREFIX ${COMPILER_RT_PREFIX}; SOURCE_DIR ${COMPILER_RT_SRC_ROOT}; STAMP_DIR ${STAMP_DIR}; BINARY_DIR ${BINARY_DIR}; CMAKE_ARGS ${CLANG_COMPILER_RT_CMAKE_ARGS}; -DCMAKE_C_COMPILER=${LLVM_RUNTIME_OUTPUT_INTDIR}/clang; -DCMAKE_CX",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/runtime/CMakeLists.txt:1642,variab,variables,1642,interpreter/llvm-project/clang/runtime/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/runtime/CMakeLists.txt,2,['variab'],"['variable', 'variables']"
Modifiability,"ld be a; qualified array type.; . Unclear type relationship between a format specifier and its argument; N2562; Clang 16. String functions for freestanding implementations; N2524; No. Digit separators; N2626; Clang 13. Missing +(x) in table; N2641; Yes. Add support for preprocessing directives elifdef and elifndef; N2645; Clang 13. [[maybe_unused]] for labels; N2662; Clang 16. Zeros compare equal; N2670; Yes. Negative values; N2671; Yes. 5.2.4.2.2	cleanup; N2672; Yes. Towards Integer Safety; N2683; Clang 18. Adding Fundamental Type for N-bit Integers. ; N2763; Clang 15. ; N2775; Clang 15. ; N2969; Clang 15. ; N3035; Clang 15. #warning directive; N2686; Yes. Sterile characters; N2686; Yes. Numerically equal; N2716; Yes. char16_t & char32_t string literals shall be UTF-16 & UTF-32; N2728; Yes. IEC 60559 binding; N2749; Unknown. __has_include for C; N2799; Yes. Annex F overflow and underflow; N2747; Yes. Remove UB from Incomplete Types in Function Parameters; N2770; Yes. Variably-modified types; N2778; Yes. Types do not have types; N2781; Yes. 5.2.4.2.2	cleanup (N2672 update); N2806; Yes. Allow 16-bit ptrdiff_t; N2808; Yes. Proposal to update CFP freestanding requirements; N2823; Unknown. Types and sizes; N2838; Yes. Clarifying integer terms; N2837; Yes. Clarification for max exponent macros; N2843; Unknown. Clarification about expression transformations; N2846; Unknown. Contradiction about INFINITY macro; N2848; Unknown. Require exact-width integer type interfaces; N2872; Yes. @, $, and ‘ in the source/execution character set; N2701; Yes. Quantum exponent of NaN (version 2); N2754; Unknown. The noreturn attribute; N2764; Clang 15. *_HAS_SUBNORM==0 implies what?; N2797; Yes. Disambiguate the storage class of some compound literals; N2819; Unknown. Add annotations for unreachable control flow v2; N2826; Clang 17. Unicode Sequences More Than 21 Bits are a Constraint Violation r0; N2828; Clang 3.6. Identifier Syntax using Unicode Standard Annex 31; N2836; Clang 15. No func",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:10482,Variab,Variably-modified,10482,interpreter/llvm-project/clang/www/c_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html,1,['Variab'],['Variably-modified']
Modifiability,"ld contain an entry for each DWARF DIE whose; ``DW_TAG`` is a ``DW_TAG_label``, ``DW_TAG_inlined_subroutine``, or; ``DW_TAG_subprogram`` that has address attributes: ``DW_AT_low_pc``,; ``DW_AT_high_pc``, ``DW_AT_ranges`` or ``DW_AT_entry_pc``. It also contains; ``DW_TAG_variable`` DIEs that have a ``DW_OP_addr`` in the location (global and; static variables). All global and static variables should be included,; including those scoped within functions and classes. For example using the; following code:. .. code-block:: c. static int var = 0;. void f (); {; static int var = 0;; }. Both of the static ``var`` variables would be included in the table. All; functions should emit both their full names and their basenames. For C or C++,; the full name is the mangled name (if available) which is usually in the; ``DW_AT_MIPS_linkage_name`` attribute, and the ``DW_AT_name`` contains the; function basename. If global or static variables have a mangled name in a; ``DW_AT_MIPS_linkage_name`` attribute, this should be emitted along with the; simple name found in the ``DW_AT_name`` attribute. ""``.apple_types``"" sections should contain an entry for each DWARF DIE whose; tag is one of:. * DW_TAG_array_type; * DW_TAG_class_type; * DW_TAG_enumeration_type; * DW_TAG_pointer_type; * DW_TAG_reference_type; * DW_TAG_string_type; * DW_TAG_structure_type; * DW_TAG_subroutine_type; * DW_TAG_typedef; * DW_TAG_union_type; * DW_TAG_ptr_to_member_type; * DW_TAG_set_type; * DW_TAG_subrange_type; * DW_TAG_base_type; * DW_TAG_const_type; * DW_TAG_immutable_type; * DW_TAG_file_type; * DW_TAG_namelist; * DW_TAG_packed_type; * DW_TAG_volatile_type; * DW_TAG_restrict_type; * DW_TAG_atomic_type; * DW_TAG_interface_type; * DW_TAG_unspecified_type; * DW_TAG_shared_type. Only entries with a ``DW_AT_name`` attribute are included, and the entry must; not be a forward declaration (``DW_AT_declaration`` attribute with a non-zero; value). For example, using the following code:. .. code-block:: c. int main (); {; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:78286,variab,variables,78286,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variables']
Modifiability,"ld specify more than one of the options at a time, for example,; ""``compiler -O3 -O2``"". The CommandLine library would not be able to catch; this erroneous input for us. #. We would have to test 4 different variables to see which ones are set. #. This doesn't map to the numeric levels that we want... so we cannot easily; see if some level >= ""``-O1``"" is enabled. To cope with these problems, we can use an enum value, and have the CommandLine; library fill it in with the appropriate level directly, which is used like this:. .. code-block:: c++. enum OptLevel {; g, O1, O2, O3; };. cl::opt<OptLevel> OptimizationLevel(cl::desc(""Choose optimization level:""),; cl::values(; clEnumVal(g , ""No optimizations, enable debugging""),; clEnumVal(O1, ""Enable trivial optimizations""),; clEnumVal(O2, ""Enable default optimizations""),; clEnumVal(O3, ""Enable expensive optimizations"")));. ...; if (OptimizationLevel >= O2) doPartialRedundancyElimination(...);; ... This declaration defines a variable ""``OptimizationLevel``"" of the; ""``OptLevel``"" enum type. This variable can be assigned any of the values that; are listed in the declaration. The CommandLine library enforces that; the user can only specify one of the options, and it ensure that only valid enum; values can be specified. The ""``clEnumVal``"" macros ensure that the command; line arguments matched the enum values. With this option added, our help output; now is:. ::. USAGE: compiler [options] <input file>. OPTIONS:; Choose optimization level:; -g - No optimizations, enable debugging; -O1 - Enable trivial optimizations; -O2 - Enable default optimizations; -O3 - Enable expensive optimizations; -f - Enable binary output on terminals; -help - display available options (-help-hidden for more); -o <filename> - Specify output filename; -quiet - Don't print informational messages. In this case, it is sort of awkward that flag names correspond directly to enum; names, because we probably don't want an enum definition named ""``g``"" in our; p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:15070,variab,variable,15070,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variable']
Modifiability,"ld this be named ``DW_OP_LLVM_offset_uconst`` to match; ``DW_OP_plus_uconst``, or ``DW_OP_LLVM_offset_constu`` to match; ``DW_OP_constu``?. 3. ``DW_OP_LLVM_bit_offset`` *New*. ``DW_OP_LLVM_bit_offset`` pops two stack entries. The first must be an; integral type value that represents a bit displacement B. The second must be; a location description L. It adds the value of B to the bit offset of each single location description; SL of L, and pushes the updated L. It is an evaluation error if the updated bit offset of any SL is less than 0; or greater than or equal to the size of the location storage specified by; SL. 4. ``DW_OP_push_object_address``. ``DW_OP_push_object_address`` pushes the location description L of the; current object. *This object may correspond to an independent variable that is part of a; user presented expression that is being evaluated. The object location; description may be determined from the variable's own debugging information; entry or it may be a component of an array, structure, or class whose; address has been dynamically determined by an earlier step during user; expression evaluation.*. *This operation provides explicit functionality (especially for arrays; involving descriptors) that is analogous to the implicit push of the base; location description of a structure prior to evaluation of a*; ``DW_AT_data_member_location`` *to access a data member of a structure.*. .. note::. This operation could be removed and the object location description; specified as the initial stack as for ``DW_AT_data_member_location``. Or this operation could be used instead of needing to specify an initial; stack. The latter approach is more composable as access to the object may; be needed at any point of the expression, and passing it as the initial; stack requires the entire expression to be aware where on the stack it is.; If this were done, ``DW_AT_use_location`` would require a; ``DW_OP_push_object2_address`` operation for the second object. Or a more ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:100151,variab,variable,100151,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variable']
Modifiability,"lder::AddFolder`** method. This method takes two parameters: the; name and title of the folder to be added. It returns a pointer of the; newly created folder. The code below creates the folder hierarchy shown in the browser. In; this macro, the folder is also added to the list of browsable. This way,; it is visible in the browser on the top level. ``` {.cpp}; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list of browsables; gROOT->GetListOfBrowsables()->Add(aliroot,""aliroot"");. // Create and add the constants folder; TFolder *constants=aliroot->AddFolder(""Constants"",; ""Detector constants"");. // Create and add the pdg folder to pdg; TFolder *pdg = constants->AddFolder(""DatabasePDG"",""PDG database"");. // Create and add the run folder; TFolder *run = aliroot->AddFolder(""Run"",""Run dependent folders"");. // Create and add the configuration folder to run; TFolder *configuration = run->AddFolder(""Configuration"",; ""Run configuration"");. // Create and add the run_mc folder; TFolder *run_mc = aliroot->AddFolder(""RunMC"",; ""MonteCarlo run dependent folders"");. // Create and add the configuration_mc folder to run_mc; TFolder *configuration_mc = run_mc->AddFolder(""Configuration"",; ""MonteCarlo run configuration"");; }; ```. ### Posting Data to a Folder (Producer). ![](pictures/030000E4.png). A **`TFolder`** can contain other folders as shown above or any; **`TObject`** descendents. In general, users will not post a single; object to a folder; they will store a collection or multiple collections; in a folder. For example, to add an array to a folder:. ``` {.cpp}; TObjArray *array;; run_mc->Add(array);; ```. ### Reading Data from a Folder (Consumer). One can search for a folder or an object in a folder using the; `TROOT::FindObjectAny` method. It analyzes the string passed as its; argument and searches in the hierarchy until it finds an object or; folder matchin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:3536,config,configuration,3536,documentation/users-guide/FoldersTasks.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md,3,['config'],['configuration']
Modifiability,"le *var* is bound to each element in the *list*. The; expression is evaluated for each element and presumably uses *acc* and; *var* to calculate the accumulated value, which ``!foldl`` stores back in; *acc*. The type of *acc* is the same as *init*; the type of *var* is the; same as the elements of *list*; *expr* must have the same type as *init*. The following example computes the total of the ``Number`` field in the; list of records in ``RecList``::. int x = !foldl(0, RecList, total, rec, !add(total, rec.Number));. If your goal is to filter the list and produce a new list that includes only; some of the elements, see ``!filter``. ``!foreach(``\ *var*\ ``,`` *sequence*\ ``,`` *expr*\ ``)``; This operator creates a new ``list``/``dag`` in which each element is a; function of the corresponding element in the *sequence* ``list``/``dag``.; To perform the function, TableGen binds the variable *var* to an element; and then evaluates the expression. The expression presumably refers; to the variable *var* and calculates the result value. If you simply want to create a list of a certain length containing; the same value repeated multiple times, see ``!listsplat``. ``!ge(``\ *a*\ `,` *b*\ ``)``; This operator produces 1 if *a* is greater than or equal to *b*; 0 otherwise.; The arguments must be ``bit``, ``bits``, ``int``, or ``string`` values. ``!getdagarg<``\ *type*\ ``>(``\ *dag*\ ``,``\ *key*\ ``)``; This operator retrieves the argument from the given *dag* node by the; specified *key*, which is either an integer index or a string name. If that; argument is not convertible to the specified *type*, ``?`` is returned. ``!getdagname(``\ *dag*\ ``,``\ *index*\ ``)``; This operator retrieves the argument name from the given *dag* node by the; specified *index*. If that argument has no name associated, ``?`` is; returned. ``!getdagop(``\ *dag*\ ``)`` --or-- ``!getdagop<``\ *type*\ ``>(``\ *dag*\ ``)``; This operator produces the operator of the given *dag* node.; Example: ``!getd",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:65064,variab,variable,65064,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['variab'],['variable']
Modifiability,"le baseline and experiment result files by taking the minimum; runtime each:. ```bash; % test-suite/utils/compare.py base0.json base1.json base2.json vs exp0.json exp1.json exp2.json; ```. ### Continuous Tracking with LNT. LNT is a set of client and server tools for continuously monitoring; performance. You can find more information at; [https://llvm.org/docs/lnt](https://llvm.org/docs/lnt). The official LNT instance; of the LLVM project is hosted at [http://lnt.llvm.org](http://lnt.llvm.org). External Suites; ---------------. External suites such as SPEC can be enabled by either. - placing (or linking) them into the `test-suite/test-suite-externals/xxx` directory (example: `test-suite/test-suite-externals/speccpu2000`); - using a configuration option such as `-D TEST_SUITE_SPEC2000_ROOT=path/to/speccpu2000`. You can find further information in the respective README files such as; `test-suite/External/SPEC/README`. For the SPEC benchmarks you can switch between the `test`, `train` and; `ref` input datasets via the `TEST_SUITE_RUN_TYPE` configuration option.; The `train` dataset is used by default. Custom Suites; -------------. You can build custom suites using the test-suite infrastructure. A custom suite; has a `CMakeLists.txt` file at the top directory. The `CMakeLists.txt` will be; picked up automatically if placed into a subdirectory of the test-suite or when; setting the `TEST_SUITE_SUBDIRS` variable:. ```bash; % cmake -DTEST_SUITE_SUBDIRS=path/to/my/benchmark-suite ../test-suite; ```. Profile Guided Optimization; ---------------------------. Profile guided optimization requires to compile and run twice. First the; benchmark should be compiled with profile generation instrumentation enabled; and setup for training data. The lit runner will merge the profile files; using `llvm-profdata` so they can be used by the second compilation run. Example:; ```bash; # Profile generation run using LLVM IR PGO:; % cmake -DTEST_SUITE_PROFILE_GENERATE=ON \; -DTEST_SUITE_USE_IR_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:9468,config,configuration,9468,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['config'],['configuration']
Modifiability,"le data; members are written to the buffer directly. Eventually the buffer; contains all simple data members of all the classes that make up this; particular object. Data members that are references (as; `MyClass &fObj;`) are never saved, it is always the responsibility of; the object's constructor to set them properly. ### Automatically Generated Streamers. A `Streamer `usually calls other `Streamers`: the `Streamer `of its; parents and data members. This architecture depends on all classes; having `Streamers`, because eventually they will be called. To ensure; that a class has a `Streamer`, `rootcling` automatically creates one in; the `ClassDef` macro that is defined in `$ROOTSYS/include/Rtypes.h`.; `ClassDef` defines several methods for any class, and one of them is the; `Streamer`. The automatically generated `Streamer `is complete and can; be used as long as no customization is needed. The `Event` class is defined in `$ROOTSYS/test/Event.h`. Looking at the; class definition, we find that it inherits from **`TObject`**. It is a; simple example of a class with diverse data members. ``` {.cpp}; class Event : public TObject {; private:; TDirectory *fTransient; //! current directory; Float_t fPt; //! transient value; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr; //|| don't split; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; ...; ```. The Event class is added to the dictionary by the `rootcling`; utility. This is the `rootcling` statement in the; `$ROOTSYS/test/Makefile`:. ``` {.cpp}; @rootcling -f EventDict.cxx -c Event.h EventLinkDef.h; ```. The `EventDict.cxx` file contains the automatically generated; `Streamer `for Event:. ``` {.cpp}; void Event::Streamer(TBuffer &R__b){; // Stream an object of class Event.; if (R__b.IsReading()) {; Event::Class()->ReadBuffer(R__b, this);; } else {; Event::Class()->Wr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:44212,inherit,inherits,44212,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['inherit'],['inherits']
Modifiability,"le gets; loaded), not the Python class object.; In short, whether a binding is created at ""compile-time"" or at run-time has; no measurable bearing on performance. What does affect performance is the overhead to cross the language barrier.; This consists of unboxing Python objects to extract or convert the underlying; objects or data to something that matches what C++ expects; overload; resolution based on the unboxed arguments; offset calculations; and finally; the actual dispatch.; As a practical matter, overload resolution is the most costly part, followed; by the unboxing and conversion.; Best performance is achieved by specialization of the paths through the; run-time: recognize early the case at hand and select an optimized path.; For that reason, `PyPy`_ is so fast: JIT-ed traces operate on unboxed objects; and resolved overloads are baked into the trace, incurring no further cost.; Similarly, this is why pybind11 is so slow: its code generation is the C++; compiler's template engine, so complex path selection and specialization is; very hard to do in a performance-portable way. In cppyy, a great deal of attention has gone into built-in specialization; paths, which drives its performance.; For example, basic inheritance sequentially lines up classes, whereas; multiple (virtual) inheritance usually requires thunks.; Thus, when calling base class methods on a derived instance, the latter; requires offset calculations that depend on that instance, whereas the former; has fixed offsets fully determined by the class definitions themselves.; By labeling classes appropriately, single inheritance classes (by far the; most common case) do not incur the overhead in PyPy's JIT-ed traces that is; otherwise unavoidable for multiple virtual inheritance.; As another example, consider that the C++ standard does not allow modifying; a ``std::vector`` while looping over it, whereas Python has no such; restriction, complicating loops.; Thus, cppyy has specialized ``std::vector`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:2662,portab,portable,2662,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['portab'],['portable']
Modifiability,"le into Qt Creator.; This option is only useful in combination with ``-DLLVM_ENABLE_DOXYGEN=ON``;; otherwise this has no effect. **LLVM_ENABLE_EH**:BOOL; Build LLVM with exception-handling support. This is necessary if you wish to; link against LLVM libraries and make use of C++ exceptions in your own code; that need to propagate through LLVM code. Defaults to OFF. **LLVM_ENABLE_EXPENSIVE_CHECKS**:BOOL; Enable additional time/memory expensive checking. Defaults to OFF. **LLVM_ENABLE_HTTPLIB**:BOOL; Enables the optional cpp-httplib dependency which is used by llvm-debuginfod; to serve debug info over HTTP. `cpp-httplib <https://github.com/yhirose/cpp-httplib>`_; must be installed, or `httplib_ROOT` must be set. Defaults to OFF. **LLVM_ENABLE_FFI**:BOOL; Indicates whether the LLVM Interpreter will be linked with the Foreign Function; Interface library (libffi) in order to enable calling external functions.; If the library or its headers are installed in a custom; location, you can also set the variables FFI_INCLUDE_DIR and; FFI_LIBRARY_DIR to the directories where ffi.h and libffi.so can be found,; respectively. Defaults to OFF. **LLVM_ENABLE_IDE**:BOOL; Tell the build system that an IDE is being used. This in turn disables the; creation of certain convenience build system targets, such as the various; ``install-*`` and ``check-*`` targets, since IDEs don't always deal well with; a large number of targets. This is usually autodetected, but it can be; configured manually to explicitly control the generation of those targets. **LLVM_ENABLE_LIBCXX**:BOOL; If the host compiler and linker supports the stdlib flag, -stdlib=libc++ is; passed to invocations of both so that the project is built using libc++; instead of stdlibc++. Defaults to OFF. **LLVM_ENABLE_LLVM_LIBC**: BOOL; If the LLVM libc overlay is installed in a location where the host linker; can access it, all built executables will be linked against the LLVM libc; overlay before linking against the system libc. Def",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:21951,variab,variables,21951,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,"le is loaded. The order of; functions with the same priority is not defined. If the third field is non-null, and points to a global variable; or function, the initializer function will only run if the associated; data from the current module is not discarded.; On ELF the referenced global variable or function must be in a comdat. .. _llvmglobaldtors:. The '``llvm.global_dtors``' Global Variable; -------------------------------------------. .. code-block:: llvm. %0 = type { i32, ptr, ptr }; @llvm.global_dtors = appending global [1 x %0] [%0 { i32 65535, ptr @dtor, ptr @data }]. The ``@llvm.global_dtors`` array contains a list of destructor; functions, priorities, and an associated global or function.; The functions referenced by this array will be called in descending; order of priority (i.e. highest first) when the module is unloaded. The; order of functions with the same priority is not defined. If the third field is non-null, and points to a global variable; or function, the destructor function will only run if the associated; data from the current module is not discarded.; On ELF the referenced global variable or function must be in a comdat. Instruction Reference; =====================. The LLVM instruction set consists of several different classifications; of instructions: :ref:`terminator instructions <terminators>`, :ref:`binary; instructions <binaryops>`, :ref:`bitwise binary; instructions <bitwiseops>`, :ref:`memory instructions <memoryops>`, and; :ref:`other instructions <otherops>`. .. _terminators:. Terminator Instructions; -----------------------. As mentioned :ref:`previously <functionstructure>`, every basic block in a; program ends with a ""Terminator"" instruction, which indicates which; block should be executed after the current block is finished. These; terminator instructions typically yield a '``void``' value: they produce; control flow, not values (the one exception being the; ':ref:`invoke <i_invoke>`' instruction). The terminator instructions a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:353999,variab,variable,353999,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"le length array type, add forward references; Yes. 328; C99; String literals in compound literal initialization. Partial; Clang properly implements the use of string literals in a compound; literal initializer, but fails to diagnose use of a variably-modified; type at file scope. DR339 (about variably-modified types) is marked as; a duplicate of DR328.; . 329; C99; Math functions and directed rounding; N/A. 330; C99; Externally visible exceptional conditions; N/A. 331; NAD; permit FE_DIVBYZERO when errno says EDOM; N/A. 332; C99; gets is generally unsafe; N/A. 333; C99; Missing Predefined Macro Name; Yes. 334; Open; Missing semantics of comparison macros; Not resolved. 335; NAD; _Bool bit-fields; Yes. 336; C99; What does TMP_MAX actually indicate?; N/A. 337; C99; stdio.h macro definition problems; N/A. 338; C99; C99 seems to exclude indeterminate value from being an uninitialized register; Yes. 339; Dup; Variably modified compound literal; Duplicate of 328. 340; C99; Composite types for variable-length arrays; Yes. 341; C99; [*] in abstract declarators; Yes. 342; Dup; VLAs and conditional expressions; Duplicate of 340. 343; C99; Initializing qualified wchar_t arrays; Yes. 344; C99; Casts in preprocessor conditional expressions; Yes. 345; C99; Where does parameter scope start?; Yes. 400; C11; realloc with size zero problems; Unknown. 401; C11; ""happens before"" can not be cyclic; Yes. 402; C11; Memory model coherence is not aligned with C++11; Yes. 403; C11; malloc() and free() in the memory model; N/A. 404; C11; Joke fragment remains in a footnote; Yes. 405; C11; The mutex specification; N/A. 406; C11; Visible sequences of side effects are redundant; Yes. 407; C11; Memory ordering of atomics; Unknown. 408; NAD; Should locks provide intra-thread synchronization; N/A. 409; C11; f(inf) is inf being a range error; N/A. 410; C11; ilogb inconsistent with lrint, lround; N/A. 411; C11; Predefined macro values; Yes. 412; C11; #elif; Yes. 413; NAD; Initialization; Yes. 414; C11",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:20927,variab,variable-length,20927,interpreter/llvm-project/clang/www/c_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html,2,['variab'],['variable-length']
Modifiability,"le name.; ``dllexport``; On Microsoft Windows targets, ""``dllexport``"" causes the compiler to provide; a global pointer to a pointer in a DLL, so that it can be referenced with the; ``dllimport`` attribute. the pointer name is formed by combining ``__imp_``; and the function or variable name. On XCOFF targets, ``dllexport`` indicates; that the symbol will be made visible to other modules using ""exported""; visibility and thus placed by the linker in the loader section symbol table.; Since this storage class exists for defining a dll interface, the compiler,; assembler and linker know it is externally referenced and must refrain from; deleting the symbol. A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage; class. .. _tls_model:. Thread Local Storage Models; ---------------------------. A variable may be defined as ``thread_local``, which means that it will; not be shared by threads (each thread will have a separated copy of the; variable). Not all targets support thread-local variables. Optionally, a; TLS model may be specified:. ``localdynamic``; For variables that are only used within the current shared library.; ``initialexec``; For variables in modules that will not be loaded dynamically.; ``localexec``; For variables defined in the executable and only used within it. If no explicit model is given, the ""general dynamic"" model is used. The models correspond to the ELF TLS models; see `ELF Handling For; Thread-Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for; more information on under which circumstances the different models may; be used. The target may choose a different TLS model if the specified; model is not supported, or if a better choice of model can be made. A model can also be specified in an alias, but then it only governs how; the alias is accessed. It will not have any effect in the aliasee. For platforms without linker support of ELF TLS model, the -femulated-tls; flag can be used to generate GCC compatible emulate",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:25817,variab,variables,25817,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"le throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened to trigger an activity in the right moment.; Now TMonaLisaWriter keeps internally track of every; activity; and regularly sends summaries valid for all the files which had; activity in the last time interval.; Additionally, it's now finalized the infrastructure able to; measure; and keep track of the file Open latency. A packet is sent for each; successful Open, sending the measures of the latencies for the; various phases of the open. Currently exploited fully by TAlienFile; and TXNetFile. Easy to report from other TFiles too.; Now, the hook for the Close() func triggers sending of a; packet containing various information about the performance related to; that file only.; Added support also for performance monitoring when writing. RGLITE: A ROOT GRID interface. RGLite plug-in - a ROOT plug-in module, which implements the ROOT Grid; interface and offers to ROOT users possibilities to perform a number of; operations using gLite middleware from within ROOT. Supported features:. Workload Management System operations:; ; job submission – normal, DAG and parametric; jobs (gLite; WMProxy API), ; smart look-up algorithm for WMP-Endpoints, ; job status querying (gLite LB API), ; job output retrieving (Globus GridFTP). . File Catalog operations (gLite/LCG LFC API):; ; smart session manager, ; set/query the current working catalog directory, ; list files, directories and their stats, ; add/remove files in a catalog namespace, ; add/remove directories, ; add/remove replicas from a given file. . An executive logging. ; Support of an external XML configuration file with; according XML; schema. . Usage examples:. Job operations. // loading RGLite plug-in. TGrid::Connect(""glite"");; // submitting Grid job. TGridJob *job = gGrid->Submit(""JDLs/simple.jdl"");; // getting status object. TGridJobStatus *status = job->GetJobStatus();; // getting status of the jo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v520/index.html:3072,plug-in,plug-in,3072,net/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v520/index.html,4,['plug-in'],['plug-in']
Modifiability,"le to determine; how to run the tests. This file is just Python code and thus is very; flexible, but we've standardized it for the LLVM regression tests. If; you're adding a directory of tests, just copy ``lit.local.cfg`` from; another directory to get running. The standard ``lit.local.cfg`` simply; specifies which files to look in for tests. Any directory that contains; only directories does not need the ``lit.local.cfg`` file. Read the :doc:`Lit; documentation <CommandGuide/lit>` for more information. Each test file must contain lines starting with ""RUN:"" that tell :program:`lit`; how to run it. If there are no RUN lines, :program:`lit` will issue an error; while running a test. RUN lines are specified in the comments of the test program using the; keyword ``RUN`` followed by a colon, and lastly the command (pipeline); to execute. Together, these lines form the ""script"" that :program:`lit`; executes to run the test case. The syntax of the RUN lines is similar to a; shell's syntax for pipelines including I/O redirection and variable; substitution. However, even though these lines may *look* like a shell; script, they are not. RUN lines are interpreted by :program:`lit`.; Consequently, the syntax differs from shell in a few ways. You can specify; as many RUN lines as needed. :program:`lit` performs substitution on each RUN line to replace LLVM tool names; with the full paths to the executable built for each tool (in; ``$(LLVM_OBJ_ROOT)/bin``). This ensures that :program:`lit` does; not invoke any stray LLVM tools in the user's path during testing. Each RUN line is executed on its own, distinct from other lines unless; its last character is ``\``. This continuation character causes the RUN; line to be concatenated with the next one. In this way you can build up; long pipelines of commands without making huge line lengths. The lines; ending in ``\`` are concatenated until a RUN line that doesn't end in; ``\`` is found. This concatenated set of RUN lines then constitut",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:8799,variab,variable,8799,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['variab'],['variable']
Modifiability,"le's subclass can then be added to the list of refactoring action's; rules for a particular action using the ``createRefactoringActionRule``; function. For example, the class that's shown above can be added to the; list of action rules using the following code:. .. code-block:: c++. RefactoringActionRules Rules;; Rules.push_back(; createRefactoringActionRule<DeleteSelectedRange>(; SourceRangeSelectionRequirement()); );. The ``createRefactoringActionRule`` function takes in a list of refactoring; action rule requirement values. These values describe the initiation; requirements that have to be satisfied by the refactoring engine before the; provided action rule can be constructed and invoked. The next section; describes how these requirements are evaluated and lists all the possible; requirements that can be used to construct a refactoring action rule. Refactoring Action Rule Requirements; ------------------------------------. A refactoring action rule requirement is a value whose type derives from the; ``RefactoringActionRuleRequirement`` class. The type must define an; ``evaluate`` member function that returns a value of type ``Expected<...>``.; When a requirement value is used as an argument to; ``createRefactoringActionRule``, that value is evaluated during the initiation; of the action rule. The evaluated result is then passed to the rule's; constructor unless the evaluation produced an error. For example, the; ``DeleteSelectedRange`` sample rule that's defined in the previous section; will be evaluated using the following steps:. #. ``SourceRangeSelectionRequirement``'s ``evaluate`` member function will be; called first. It will return an ``Expected<SourceRange>``. #. If the return value is an error the initiation will fail and the error; will be reported to the client. Note that the client may not report the; error to the user. #. Otherwise the source range return value will be used to construct the; ``DeleteSelectedRange`` rule. The rule will then be invoked ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:6900,refactor,refactoring,6900,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['refactor'],['refactoring']
Modifiability,"le, customize differently the quotas.Fix an issue with TTreeFriends. New tutorial showing how to use friends in PROOF.Package; management: add support for arguments in the SETUP function: it is; possible now to pass a string or a list of objects. The; TProof::EnablePackage interface has been extended to support this.Optimize; the validation step in the case not all the entries are required. The; validation step is stopped as soon as the requested number of events is; reached. If the parameter ""PROOF_ValidateByFile"" is set to 1, the; number of files is exactly what needed; otherwise the number of files; may exceed the number of files needed by (Number_Of_Workers - 1) .; New directive 'xpd.datadir' to better control the user data directories and their permission settings. In TPacketizerUnit, add the possibility to exactly share the number of cycles between the workers.; See the parameter PROOF_PacketizerFixedNum.Implement; a timer to terminate idle sessions. The timeout value is controlled by; the variable ProofServ.IdleTimeout (value in seconds). This variable; can be set for all sessions in the xproofd config file via the 'xpd.putrc' directive.; Add the possibility to control the use of sub-mergers with; the ROOTrc variable Proof.SubMergers. It has the same meaning of the; parameter 'PROOF_UseMergers'. The capabilities of the latter have been; extended: now -1 means disable the use of submergers (before  negative values were ignored and there was no way for the user to disable the use of submergers). . Packetizer optimizations: improved worked distribution when; the number of files left to be processed is smaller than the number of; workers and at least one file has a number of events significantly; larger than the average; better apply the upper/lower limits on the; expected packet processing time.; Add the possibility to single-out disk partitions in the; packetizer; this works adding the beginning of a path in the name; defining a new TFileNode (e.g. 'host://disk",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:6563,variab,variable,6563,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,2,['variab'],['variable']
Modifiability,"le, we create a list of items, or; Atoms, that are contained in the data for each name. First comes the type of; the data in each atom:. .. code-block:: c. enum AtomType; {; eAtomTypeNULL = 0u,; eAtomTypeDIEOffset = 1u, // DIE offset, check form for encoding; eAtomTypeCUOffset = 2u, // DIE offset of the compiler unit header that contains the item in question; eAtomTypeTag = 3u, // DW_TAG_xxx value, should be encoded as DW_FORM_data1 (if no tags exceed 255) or DW_FORM_data2; eAtomTypeNameFlags = 4u, // Flags from enum NameFlags; eAtomTypeTypeFlags = 5u, // Flags from enum TypeFlags; };. The enumeration values and their meanings are:. .. code-block:: none. eAtomTypeNULL - a termination atom that specifies the end of the atom list; eAtomTypeDIEOffset - an offset into the .debug_info section for the DWARF DIE for this name; eAtomTypeCUOffset - an offset into the .debug_info section for the CU that contains the DIE; eAtomTypeDIETag - The DW_TAG_XXX enumeration value so you don't have to parse the DWARF to see what it is; eAtomTypeNameFlags - Flags for functions and global variables (isFunction, isInlined, isExternal...); eAtomTypeTypeFlags - Flags for types (isCXXClass, isObjCClass, ...). Then we allow each atom type to define the atom type and how the data for each; atom type data is encoded:. .. code-block:: c. struct Atom; {; uint16_t type; // AtomType enum value; uint16_t form; // DWARF DW_FORM_XXX defines; };. The ``form`` type above is from the DWARF specification and defines the exact; encoding of the data for the Atom type. See the DWARF specification for the; ``DW_FORM_`` definitions. .. code-block:: c. struct HeaderData; {; uint32_t die_offset_base;; uint32_t atom_count;; Atoms atoms[atom_count0];; };. ``HeaderData`` defines the base DIE offset that should be added to any atoms; that are encoded using the ``DW_FORM_ref1``, ``DW_FORM_ref2``,; ``DW_FORM_ref4``, ``DW_FORM_ref8`` or ``DW_FORM_ref_udata``. It also defines; what is contained in each ``HashData`` objec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:73125,variab,variables,73125,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variables']
Modifiability,"le. $ cmake -UVARIABLE path/to/llvm/source. Variables are stored in the CMake cache. This is a file named ``CMakeCache.txt``; stored at the root of your build directory that is generated by ``cmake``.; Editing it yourself is not recommended. Variables are listed in the CMake cache and later in this document with; the variable name and type separated by a colon. You can also specify the; variable and type on the CMake command line:. .. code-block:: console. $ cmake -DVARIABLE:TYPE=value path/to/llvm/source. Frequently-used CMake variables; -------------------------------. Here are some of the CMake variables that are used often, along with a; brief explanation. For full documentation, consult the CMake manual,; or execute ``cmake --help-variable VARIABLE_NAME``. See `Frequently; Used LLVM-related Variables`_ below for information about commonly; used variables that control features of LLVM and enabled subprojects. .. _cmake_build_type:. **CMAKE_BUILD_TYPE**:STRING; This configures the optimization level for ``make`` or ``ninja`` builds. Possible values:. =========================== ============= ========== ========== ==========================; Build Type Optimizations Debug Info Assertions Best suited for; =========================== ============= ========== ========== ==========================; **Release** For Speed No No Users of LLVM and Clang; **Debug** None Yes Yes Developers of LLVM; **RelWithDebInfo** For Speed Yes No Users that also need Debug; **MinSizeRel** For Size No No When disk space matters; =========================== ============= ========== ========== ==========================. * Optimizations make LLVM/Clang run faster, but can be an impediment for; step-by-step debugging.; * Builds with debug information can use a lot of RAM and disk space and is; usually slower to run. You can improve RAM usage by using ``lld``, see; the :ref:`LLVM_USE_LINKER <llvm_use_linker>` option.; * Assertions are internal checks to help you find bugs. They typically slo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:6999,config,configures,6999,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['config'],['configures']
Modifiability,"le:. If JITDylib ``JD`` contains definitions for symbols ``foo_body`` and; ``bar_body``, we can create lazy entry points ``Foo`` and ``Bar`` in JITDylib; ``JD2`` by calling:. .. code-block:: c++. auto ReexportFlags = JITSymbolFlags::Exported | JITSymbolFlags::Callable;; JD2.define(; lazyReexports(CallThroughMgr, StubsMgr, JD,; SymbolAliasMap({; { Mangle(""foo""), { Mangle(""foo_body""), ReexportedFlags } },; { Mangle(""bar""), { Mangle(""bar_body""), ReexportedFlags } }; }));. A full example of how to use lazyReexports with the LLJIT class can be found at; ``llvm/examples/OrcV2Examples/LLJITWithLazyReexports``. Supporting Custom Compilers; ===========================. TBD. .. _transitioning_orcv1_to_orcv2:. Transitioning from ORCv1 to ORCv2; =================================. Since LLVM 7.0, new ORC development work has focused on adding support for; concurrent JIT compilation. The new APIs (including new layer interfaces and; implementations, and new utilities) that support concurrency are collectively; referred to as ORCv2, and the original, non-concurrent layers and utilities; are now referred to as ORCv1. The majority of the ORCv1 layers and utilities were renamed with a 'Legacy'; prefix in LLVM 8.0, and have deprecation warnings attached in LLVM 9.0. In LLVM; 12.0 ORCv1 will be removed entirely. Transitioning from ORCv1 to ORCv2 should be easy for most clients. Most of the; ORCv1 layers and utilities have ORCv2 counterparts [2]_ that can be directly; substituted. However there are some design differences between ORCv1 and ORCv2; to be aware of:. 1. ORCv2 fully adopts the JIT-as-linker model that began with MCJIT. Modules; (and other program representations, e.g. Object Files) are no longer added; directly to JIT classes or layers. Instead, they are added to ``JITDylib``; instances *by* layers. The ``JITDylib`` determines *where* the definitions; reside, the layers determine *how* the definitions will be compiled.; Linkage relationships between ``JITDylibs`` determine h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:19452,layers,layers,19452,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['layers'],['layers']
Modifiability,"le; TH1F *ht = new TH1F(""ht"",""The ROOT seism"",10,0,10*bintime);; Float_t signal = 1000;; ht->SetMaximum(signal);; ht->SetMinimum(-signal);; ht->SetStats(0);; ht->SetLineColor(2);; ht->GetXaxis()->SetTimeDisplay(1);; ht->GetYaxis()->SetNdivisions(520);; ht->Draw();. for (Int_t i=1;i<2300;i++) {; // Build a signal : noisy damped sine; Float_t noise = gRandom->Gaus(0,120);; if (i > 700); noise += signal*sin((i-700.)*6.28/30)*exp((700.-i)/300.);; ht->SetBinContent(i,noise);; c1->Modified();; c1->Update();; gSystem->ProcessEvents();; //canvas can be edited during the loop; }; printf(""Real Time = %8.3fs,Cpu Time = %8.3fsn"",sw.RealTime(),; sw.CpuTime());; }; ```. ## Graphical Objects Attributes. ### Text Attributes. When a class contains text or derives from a text class, it needs to be; able to set text attributes like font type, size, and color. To do so,; the class inherits from the **`TAttText`** class (a secondary; inheritance), which defines text attributes. **`TLatex`** and; **`TText`** inherit from **`TAttText`**. #### Setting Text Alignment. Text alignment may be set by a method call. What is said here applies to; all objects deriving from **`TAttText`**, and there are many. We will; take an example that may be transposed to other types. Suppose ""`la`"" is; a **`TLatex`** object. The alignment is set with:. ``` {.cpp}; root[] la->SetTextAlign(align); ```. The parameter `align` is a `short` describing the alignment:. `align = 10*HorizontalAlign + VerticalAlign`. For horizontal alignment, the following convention applies:. - 1 = left. - 2 = centered. - 3 = right. For vertical alignment, the following convention applies:. - 1 = bottom. - 2 = centered. - 3 = top. For example, align: 11 = left adjusted and bottom adjusted; 32 = right; adjusted and vertically centered. #### Setting Text Angle. Use `TAttText::SetTextAngle` to set the text angle. The `angle` is the; degrees of the horizontal. ``` {.cpp}; root[] la->SetTextAngle(angle); ```. #### Setting Text Color. Use `TAt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:69091,inherit,inherit,69091,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['inherit'],['inherit']
Modifiability,"le; otherwise, it; is a substitution. :program:`FileCheck` variables can be defined multiple times, and substitutions; always get the latest value. Variables can also be substituted later on the; same line they were defined on. For example:. .. code-block:: llvm. ; CHECK: op [[REG:r[0-9]+]], [[REG]]. Can be useful if you want the operands of ``op`` to be the same register,; and don't care exactly which register it is. If ``--enable-var-scope`` is in effect, variables with names that; start with ``$`` are considered to be global. All others variables are; local. All local variables get undefined at the beginning of each; CHECK-LABEL block. Global variables are not affected by CHECK-LABEL.; This makes it easier to ensure that individual tests are not affected; by variables set in preceding tests. FileCheck Numeric Substitution Blocks; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. :program:`FileCheck` also supports numeric substitution blocks that allow; defining numeric variables and checking for numeric values that satisfy a; numeric expression constraint based on those variables via a numeric; substitution. This allows ``CHECK:`` directives to verify a numeric relation; between two numbers, such as the need for consecutive registers to be used. The syntax to capture a numeric value is; ``[[#%<fmtspec>,<NUMVAR>:]]`` where:. * ``%<fmtspec>,`` is an optional format specifier to indicate what number; format to match and the minimum number of digits to expect. * ``<NUMVAR>:`` is an optional definition of variable ``<NUMVAR>`` from the; captured value. The syntax of ``<fmtspec>`` is: ``#.<precision><conversion specifier>`` where:. * ``#`` is an optional flag available for hex values (see; ``<conversion specifier>`` below) which requires the value matched to be; prefixed by ``0x``.; * ``.<precision>`` is an optional printf-style precision specifier in which; ``<precision>`` indicates the minimum number of digits that the value matched; must have, expecting leading zeros if needed",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:28027,variab,variables,28027,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,2,['variab'],['variables']
Modifiability,leFitAPI.h; TMVA/RuleFit.h; TMVA/RuleFitParams.h; TMVA/Rule.h; TMVA/SdivSqrtSplusB.h; TMVA/SeparationBase.h; TMVA/SimulatedAnnealingFitter.h; TMVA/SimulatedAnnealing.h; TMVA/SVEvent.h; TMVA/SVKernelFunction.h; TMVA/SVKernelMatrix.h; TMVA/SVWorkingSet.h; TMVA/TActivationChooser.h; TMVA/TActivation.h; TMVA/TActivationIdentity.h; TMVA/TActivationRadial.h; TMVA/TActivationReLU.h; TMVA/TActivationSigmoid.h; TMVA/TActivationTanh.h; TMVA/Timer.h; TMVA/TNeuron.h; TMVA/TNeuronInputAbs.h; TMVA/TNeuronInputChooser.h; TMVA/TNeuronInput.h; TMVA/TNeuronInputSqSum.h; TMVA/TNeuronInputSum.h; TMVA/Tools.h; TMVA/TrainingHistory.h; TMVA/TransformationHandler.h; TMVA/TSpline1.h; TMVA/TSpline2.h; TMVA/TSynapse.h; TMVA/Types.h; TMVA/VariableDecorrTransform.h; TMVA/VariableGaussTransform.h; TMVA/VariableIdentityTransform.h; TMVA/VariableImportance.h; TMVA/VariableInfo.h; TMVA/VariableNormalizeTransform.h; TMVA/VariablePCATransform.h; TMVA/VariableRearrangeTransform.h; TMVA/VariableTransformBase.h; TMVA/VariableTransform.h; TMVA/VarTransformHandler.h; TMVA/Version.h; TMVA/Volume.h; # TMVA/DNN/Adadelta.h; # TMVA/DNN/Adagrad.h; # TMVA/DNN/Adam.h; # TMVA/DNN/BatchNormLayer.h; # TMVA/DNN/DataLoader.h; # TMVA/DNN/DeepNet.h; # TMVA/DNN/DenseLayer.h; # TMVA/DNN/DLMinimizers.h; # TMVA/DNN/Functions.h; # TMVA/DNN/GeneralLayer.h; # TMVA/DNN/ReshapeLayer.h; # TMVA/DNN/RMSProp.h; # TMVA/DNN/SGD.h; # TMVA/DNN/TensorDataLoader.h; # TMVA/DNN/CNN/ContextHandles.h; # TMVA/DNN/CNN/ConvLayer.h; # TMVA/DNN/CNN/MaxPoolLayer.h; # TMVA/DNN/RNN/RNNLayer.h; # TMVA/DNN/Architectures/Reference.h; # TMVA/DNN/Architectures/Reference/DataLoader.h; # TMVA/DNN/Architectures/Reference/TensorDataLoader.h; # TMVA/DNN/Architectures/Cpu.h; # TMVA/DNN/Architectures/Cpu/CpuBuffer.h; # TMVA/DNN/Architectures/Cpu/CpuMatrix.h; # TMVA/DNN/Architectures/Cpu/CpuTensor.h; ${TMVA_EXTRA_HEADERS}; SOURCES; src/BDTEventWrapper.cxx; src/BinarySearchTree.cxx; src/BinarySearchTreeNode.cxx; src/BinaryTree.cxx; src/CCPruner.cxx; src/CCTreeWrap,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/CMakeLists.txt:4299,Variab,VariableTransform,4299,tmva/tmva/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/CMakeLists.txt,1,['Variab'],['VariableTransform']
Modifiability,"leak sanitizer, which automatically runs with address; sanitizer. When asan starts up, it checks if somebody defined the symbols in `SanitizerConfig.cxx`. In the standard asan runtime, these; functions are weak symbols, i.e. one can just override them with the desired configuration. That's what's happening here. This can be achieved in two ways:; 1. `LD_PRELOAD`: A micro library `libROOTSanitizerConfig.<dylib|so>` is created with the setup in this folder, and can be found in `<builddir>/lib/`.; Loading it with `LD_PRELOAD` will bring ROOT's default sanitiser config into any non-sanitised executable, e.g. python.; 2. ROOT executables will get the config automatically, using a static version of the config library, `libROOTStaticSanitizerConfig.a`.; All ROOT executables statically link against it, so they start up without reporting lots of unfixable memory leaks (e.g. llvm). #### Small linker magic to get the config symbols into ROOT's executables; When linking a ROOT executable, the setup functions from the sanitiser config library might get ignored, because they are not used in any of our executables.; In `cmake/modules/SetUp{Linux|MacOS}.cmake`, the functions are therefore marked as ""undefined"" for the linker, so it starts copying; them into all ROOT executables.; This way, root.exe, cling, ... can start up with a sane default config. ### Use your own address/leak sanitizer configuration; The default configurations can be overridden using the environment variables `ASAN_OPTIONS` and `LSAN_OPTIONS`. Refer to the; [address sanitizer documentation](https://github.com/google/sanitizers/wiki/AddressSanitizer) or use `ASAN_OPTIONS=help=1` when starting; up a sanitised executable (e.g. `root.exe`). A template for a leak suppression file can be found in `$ROOTSYS/etc/lsan-root.supp`. ## Create your own sanitised executable; ROOT exports a library target called `ROOT::ROOTStaticSanitizerConfig` that can be used to create sanitised executables with ROOT's default; address sani",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md:1207,config,config,1207,core/sanitizer/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md,2,['config'],['config']
Modifiability,"lection to ``__overload__``; * Automatic smartification of normal object passed as smartptr by value; * Fix crash when handing a by-value object to make_shared; * Fixed a few shared/unique_ptr corner cases; * Fixed conversion of ``std::function`` taking an STL class parameter; * No longer attempt auto-cast on classes without RTTI; * Fix for ``iter()`` iteration on generic STL container. 2020-03-15: 1.6.2; -----------------. * Respect ``__len__`` when using bound C++ objects in boolean expressions; * Support UTF-8 encoded ``unicode`` through ``std::string``; * Support for ``std::byte``; * Enable assignment to function pointer variable; * Allow passing cppyy.nullptr where a function pointer is expected; * Disable copy construction into constructed object (use ``__assign__`` instead); * Cover more cases when to set a lifeline; * Lower priority of implicit conversion to temporary with initializer_list ctor; * Add type reduction pythonization for trimming expression template type trees; * Allow mixing ``std::string`` and ``str`` as dictionary keys; * Support C-style pointer-to-struct as array; * Support C-style enum variable declarations; * Fixed const_iterator by-ref return type regression; * Resolve enums into the actual underlying type instead of int; * Remove '-isystem' from makepch flags; * Extended documentation. 2020-01-04: 1.6.1; -----------------. * Mapped C++ exception reporting detailing; * Mapped C++ exception cleanup bug fix; * STL vector constructor passes the CPython sequence construction; * STL vector slicing passes the CPython sequence slicing tests; * Extended documentation. 2019-12-23: 1.6.0; -----------------. * Classes derived from ``std::exception`` can be used as Python exceptions; * Template handling detailing (for Eigen); * Support keyword arguments; * Added add_library_path at module level; * Extended documentation; * Fix regression bugs: #176, #179, #180, #182. 2019-11-07: 1.5.7; -----------------. * Allow implicit converions for move arguments",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:14568,variab,variable,14568,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,1,['variab'],['variable']
Modifiability,"lection(SourceRange Selection) : Selection(Selection) {}. Expected<AtomicChanges>; createSourceReplacements(RefactoringRuleContext &Context) override {; AtomicChange Replacement(Context.getSources(), Selection.getBegin());; Replacement.replace(Context.getSource,; CharSourceRange::getCharRange(Selection), """");; return { Replacement };; }; private:; SourceRange Selection;; };. The rule's subclass can then be added to the list of refactoring action's; rules for a particular action using the ``createRefactoringActionRule``; function. For example, the class that's shown above can be added to the; list of action rules using the following code:. .. code-block:: c++. RefactoringActionRules Rules;; Rules.push_back(; createRefactoringActionRule<DeleteSelectedRange>(; SourceRangeSelectionRequirement()); );. The ``createRefactoringActionRule`` function takes in a list of refactoring; action rule requirement values. These values describe the initiation; requirements that have to be satisfied by the refactoring engine before the; provided action rule can be constructed and invoked. The next section; describes how these requirements are evaluated and lists all the possible; requirements that can be used to construct a refactoring action rule. Refactoring Action Rule Requirements; ------------------------------------. A refactoring action rule requirement is a value whose type derives from the; ``RefactoringActionRuleRequirement`` class. The type must define an; ``evaluate`` member function that returns a value of type ``Expected<...>``.; When a requirement value is used as an argument to; ``createRefactoringActionRule``, that value is evaluated during the initiation; of the action rule. The evaluated result is then passed to the rule's; constructor unless the evaluation produced an error. For example, the; ``DeleteSelectedRange`` sample rule that's defined in the previous section; will be evaluated using the following steps:. #. ``SourceRangeSelectionRequirement``'s ``evaluate`` m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:6575,refactor,refactoring,6575,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['refactor'],['refactoring']
Modifiability,"lem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember to delete[] it. Unqualified lookup in templates. Some versions of GCC accept the f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10781,Variab,Variables,10781,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['Variab'],['Variables']
Modifiability,"lem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68250,config,configuration,68250,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['config'],['configuration']
Modifiability,"lement (e.g., variable).; The first argument is metadata holding the address of variable, typically a; static alloca in the function entry block. The second argument is a; `local variable <LangRef.html#dilocalvariable>`_ containing a description of; the variable. The third argument is a `complex expression; <LangRef.html#diexpression>`_. An `llvm.dbg.declare` intrinsic describes the; *address* of a source variable. .. code-block:: text. %i.addr = alloca i32, align 4; call void @llvm.dbg.declare(metadata i32* %i.addr, metadata !1,; metadata !DIExpression()), !dbg !2; !1 = !DILocalVariable(name: ""i"", ...) ; int i; !2 = !DILocation(...); ...; %buffer = alloca [256 x i8], align 8; ; The address of i is buffer+64.; call void @llvm.dbg.declare(metadata [256 x i8]* %buffer, metadata !3,; metadata !DIExpression(DW_OP_plus, 64)), !dbg !4; !3 = !DILocalVariable(name: ""i"", ...) ; int i; !4 = !DILocation(...). A frontend should generate exactly one call to ``llvm.dbg.declare`` at the point; of declaration of a source variable. Optimization passes that fully promote the; variable from memory to SSA values will replace this call with possibly multiple; calls to `llvm.dbg.value`. Passes that delete stores are effectively partial; promotion, and they will insert a mix of calls to ``llvm.dbg.value`` to track; the source variable value when it is available. After optimization, there may be; multiple calls to ``llvm.dbg.declare`` describing the program points where the; variables lives in memory. All calls for the same concrete source variable must; agree on the memory location. ``llvm.dbg.value``; ^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. void @llvm.dbg.value(metadata, metadata, metadata). This intrinsic provides information when a user source variable is set to a new; value. The first argument is the new value (wrapped as metadata). The second; argument is a `local variable <LangRef.html#dilocalvariable>`_ containing a; description of the variable. The third argument is a `complex e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:9586,variab,variable,9586,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"lename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tel",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68874,variab,variable,68874,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['variab'],['variable']
Modifiability,"lent; numerical accuracy and computational performances. Furthermore, it contains new; functionality, like the possibility to set single side parameter limits or the; FUMILI algorithm, which is an optimized method for least square and log likelihood; minimizations. The package has been originally developed by M. Winkler and F. James.; More information on the new C++ version can be found on the; [MINUIT Web Site](http://www.cern.ch/minuit). Minuit2, originally developed in the SEAL project, is now distributed within %ROOT.; The API has been then changed in this new version to follow the %ROOT coding convention; (function names starting with capital letters) and the classes have been moved inside; the namespace _ROOT::Minuit2_. In addition, the %ROOT distribution contains classes; needed to integrate Minuit2 in the %ROOT framework. A new class has been introduced, ROOT::Minuit2::Minuit2Minimizer, which implements; the interface ROOT::Math::Minimizer. Within %ROOT, it can be instantiates also using; the %ROOT plug-in manager. This class provides a convenient entry point for using Minuit2\.; An example of using this interface is the %ROOT tutorial _tutorials/fit/NumericalMinimization.C_; or the Minuit2 test program; [<tt>testMinimize.cxx</tt>](https://github.com/cxx-hep/root-cern/blob/master/math/minuit2/test/testMinimize.cxx). A standalone version of Minuit2 (independent of %ROOT) can be easily built and installed using `CMake`. See this [`README`](https://github.com/root-project/root/blob/master/math/minuit2/README.md) for the instructions on how to get the sources, building and installing a stand-alone Minuit2. The [Minuit2 User Guide](https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html); provides all the information needed for using directly (without add-on packages like %ROOT) Minuit2. ## References. 1. F. James, _Fortran MINUIT Reference Manual_ ([html](https://cern-tex.web.cern.ch/cern-tex/minuit/minmain.html));; 2. F. James and M. Winkler, _C++ MINUIT Use",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.md:1289,plug-in,plug-in,1289,math/minuit2/doc/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.md,1,['plug-in'],['plug-in']
Modifiability,"ler runtime; ----------------. The compiler runtime library provides definitions of functions implicitly; invoked by the compiler to support operations not natively supported by; the underlying hardware (for instance, 128-bit integer multiplications),; and where inline expansion of the operation is deemed unsuitable. The default runtime library is target-specific. For targets where GCC is; the dominant compiler, Clang currently defaults to using libgcc_s. On most; other targets, compiler-rt is used by default. compiler-rt (LLVM); ^^^^^^^^^^^^^^^^^^. `LLVM's compiler runtime library <https://compiler-rt.llvm.org/>`_ provides a; complete set of runtime library functions containing all functions that; Clang will implicitly call, in ``libclang_rt.builtins.<arch>.a``. You can instruct Clang to use compiler-rt with the ``--rtlib=compiler-rt`` flag.; This is not supported on every platform. If using libc++ and/or libc++abi, you may need to configure them to use; compiler-rt rather than libgcc_s by passing ``-DLIBCXX_USE_COMPILER_RT=YES``; and/or ``-DLIBCXXABI_USE_COMPILER_RT=YES`` to ``cmake``. Otherwise, you; may end up with both runtime libraries linked into your program (this is; typically harmless, but wasteful). libgcc_s (GNU); ^^^^^^^^^^^^^^. `GCC's runtime library <https://gcc.gnu.org/onlinedocs/gccint/Libgcc.html>`_; can be used in place of compiler-rt. However, it lacks several functions; that LLVM may emit references to, particularly when using Clang's; ``__builtin_*_overflow`` family of intrinsics. You can instruct Clang to use libgcc_s with the ``--rtlib=libgcc`` flag.; This is not supported on every platform. Atomics library; ---------------. If your program makes use of atomic operations and the compiler is not able; to lower them all directly to machine instructions (because there either is; no known suitable machine instruction or the operand is not known to be; suitably aligned), a call to a runtime library ``__atomic_*`` function; will be generated. A run",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:6528,config,configure,6528,interpreter/llvm-project/clang/docs/Toolchain.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst,1,['config'],['configure']
Modifiability,"ler to build a dummy; executable to clearly report unresolved symbols. ACLiC makes a shared library with a dictionary containing the; classes and functions declared in the script. It also adds the; classes and functions declared in included files with the same name; as the script file and any of the following extensions: `.h`, `.hh`,; `.hpp`, `.hxx`, `.hPP`, `.hXX`. This means that, by default, you; cannot combine scripts from different files into one library by using; `#include` statements; you will need to compile each script; separately. In a future release, we plan to add the global variables; declared in the script to the dictionary also. If you are curious; about the specific calls, you can raise the ROOT debug level: gDebug=3; and ACLiC will print these steps. If you need to keep the intermediate; files around, for example when debugging the script using gdb, use; gDebug=7. ### Moving between Interpreter and Compiler. The best way to develop portable scripts is to make sure you can; always run them with both, the interpreter and with ACLiC. To do so,; do not use the Cling extensions and program around the Cling; limitations. When it is not possible or desirable to program around; the Cling limitations, you can use the C preprocessor symbols defined; for Cling and `rootcling`. The preprocessor symbol `__CLING__` is defined for both ROOT and; `rootcling`. The symbol `__ROOTCLING__` (and `__MAKECINT__` for backward; compatibility) is only defined in `rootcling`. Use `!defined(__CLING__) || defined(__ROOTCLING__)` to bracket code that; needs to be seen by the compiler and `rootcling`, but will be invisible; to the interpreter. Use `!defined(__CLING__) `to bracket code that should be seen only by; the compiler and not by Cling nor `rootcling. `For example, the following; will hide the declaration and initialization of the array `gArray`; from both Cling and `rootcling`. ``` {.cpp}; #if !defined(__CLING__); int gArray[] = { 2, 3, 4};; #endif; ```. Because ACLiC call",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:21218,portab,portable,21218,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['portab'],['portable']
Modifiability,"les ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DPGO_INSTRUMENT_LTO=Thin \; <path to source>/llvm. By default, clang will generate profile data by compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DATA_SOURCE_DIR=<path to llvm-test-suite> \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DEPS=runtimes. The BOOTSTRAP\_ prefixes tells CMake to pass the variables on to the instrumented; stage two build. And the CLANG_PGO_TRAINING_DEPS option let's you specify; additional build targets to build before building the external project. The; LLVM Test Suite requires compiler-rt to build, so we need to add the; `runtimes` target as a dependency. After configuration, building the stage2-instrumented-generate-profdata target; will automatically build the stage1 compiler, build the instrumented compiler; with the stage1 compiler, and then run the instrumented compiler against the; perf training data:. .. code-block:: console. $ ninja stage2-instrumented-generate-profdata. If you let that run for a few hours or so, it will place a profdata file in your; build directory. This takes a really long time because it builds clang twice,; and you *must* have compiler-rt in your build tree. This process uses any source files under the perf-training directory as training; data as long as the source files are marked up with LIT-style RUN lines. After it fi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:7009,variab,variables,7009,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['variab'],['variables']
Modifiability,"les is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:35066,config,configuration,35066,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['configuration']
Modifiability,"let read ROOT files from arbitrary place; 5. Let 'hook' save file functionality to use alternative method to store image files; 6. Implement 'tabs' layout for objects display (#238); 7. Upgrade d3.js to version 7.6.1; 8. Fix - adjust pad margins when moving palette and frame. ## Changes in 7.1.1; 1. Fix - let modify node visibility bits via context menu; 2. Fix - menu position adjusting; 3. Fix - tree_draw.js example, export treeDraw function from main.mjs; 4. Fix - TH3 scatter plot with large number of bins converted to box2; 5. Fix - create geo css entries also when expand object in hierarchy (#240). ## Changes in 7.1.0; 1. Let change `settings` and `gStyle` parameters via ""Settings"" menu of the top hierarchy item; 2. Settings and gStyle can be stored as cookies, automatically read when next time loading webpage; 3. `settings.OnlyLastCycle` defines if only last object version shown in TFile (also as `&lastcycle` URL parameter); 4. `settings.DarkMode` configures dark mode for GUI and drawings (also as `&dark` URL parameter); 5. Support new `TGraph2DAsymmErrors` class; 6. Support `gStyle.fOptDate` and `gStyle.fOptFile` (also as `&optdate` and `&optfile` URL parameter); 7. Support `gStyle.fDateX` and `gStyle.fDateY` used for positioning date and file on canvas; 8. Support `gStyle.fHistTopMargin` (also as `&histmargin=value` URL parameter); 9. Let save frame, title and stats properties to `gStyle` via correspondent context menus; 10. Support majority of special symbols in TMathText; 11. Fix several issues with TPaveText. ## Changes in 7.0.2; 1. Fix - TH2 arrow drawing; 2. Fix - interactive change of fonts attributes; 3. Fix - proper draw results of TTree::Draw; 4. Fix - draw new histogram on same canvas. ## Changes in 7.0.1; 1. Fix problem with irregular axis labels; 2. Correctly scale and tilt large number of axes labels. ## Changes in 7.0.0; 1. Use ES6 modules for code organization; 2. Rewrite code with ES6 classes; one have to use class syntax to derive from it; 3. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:17734,config,configures,17734,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['config'],['configures']
Modifiability,"lete clusters not matter the; size (even with the size was larger than 2GB!). This patch resolves the issue by limiting the amount of memory used to:. The requested size if more than one cluster fits in the cache.; Twice the requested size if at least one basket per branch fits in the cache.; Four time the requested size in the case where the cache can not even hold one basket per branch. The filling will restart at the next cluster boundary in the case a) and will; restart at the maximum of entry number read in the cache in the case b) and c).; Baskets that are below this boundary and did not fit in the cache will be read; individually.; Repaired the basket flushing frequency when the TTree has already more than one cluster size.; Repaired binning of string histogram generated by TTree::Draw.; Many bug fixes and fix for issues discovery by Coverity, see change log for more details.; In TTree::MakeProxy add proper support for top level stl collection of objects and for stl collection of objects that are 'empty' in the file (and thus we know nothing about its content).; Avoid deficiency in hadd when the resulting TTree is longer than the AutoSave length *and* the TFileMerger needs to handle the input files in more than one pass for example when there is more than 1000 input files or the -n option is passed to hadd.; Fix support for emulated class that derived from an abstract class.; This can happen when reading a file containing an ancient; class layout where the derived class is no longer provided in the; compiled code but the abstract base class is still provided. It also happens when using schema evolution rules on a class derived; from an abstract base class (in which case the system introduce; implicitly an emulated class deriving from the same base classes; as the evolved from class). To fix the issue, we introduce the TClass::GetStreamerInfoAbstractEmulated; which will return a StreamerInfo representing an emulated version of the; class even if it is loaded. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v534/index.html:4849,evolve,evolved,4849,tree/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v534/index.html,2,['evolve'],['evolved']
Modifiability,"level set with; `tbb::task_scheduler_init` but will require instead the usage of `tbb::global_control`:. ```cpp; //tbb::task_scheduler_init init(2); // does not affect the number of threads ROOT will use anymore. tbb::global_control c(tbb::global_control::max_allowed_parallelism, 2);; ROOT::TThreadExecutor p1; // will use 2 threads; ROOT::TThreadExecutor p2(/*nThreads=*/8); // will still use 2 threads; ```. Note that the preferred way to steer ROOT's concurrency level is still through; [`ROOT::EnableImplicitMT`](https://root.cern/doc/master/namespaceROOT.html#a06f2b8b216b615e5abbc872c9feff40f); or by passing the appropriate parameter to executors' constructors, as in; [`TThreadExecutor::TThreadExecutor`](https://root.cern/doc/master/classROOT_1_1TThreadExecutor.html#ac7783d52c56cc7875d3954cf212247bb). See the discussion at [ROOT-11014](https://sft.its.cern.ch/jira/browse/ROOT-11014) for more context. ### Dynamic Path: `ROOT_LIBRARY_PATH`. A new way to set ROOT's ""Dynamic Path"" was added: the; environment variable `ROOT_LIBRARY_PATH`. On Unix it should contain a colon; separated list of paths, on Windows a semicolon separated list. It is; intended to be cross platform and to be specific to ROOT (and thus not; interfere with the system's shared linker).; The final ""Dynamic Path"" is now composed of these sources in order:; 1. `ROOT_LIBRARY_PATH` environment variable; 2. System specific shared linker environment variables like; `LD_LIBRARY_PATH`, `LIBPATH`, or `PATH`.; 3. Setting from rootrc; 4. ROOT's builtin library directory. ### Interpreter. - cling's LLVM is upgraded to version 9.0; - New interface to enable/disable optional cling features. Currently, it can be used to enable/disable support for redefinitions. See [this](https://github.com/root-project/cling/issues/360) issue for more information. ### Multithreading. - Fix an uninitialized variable in global read-write lock which could have caused deadlocks or crashes in some rare cases.; - Default global read-write",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:3022,variab,variable,3022,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['variab'],['variable']
Modifiability,lgorithm_impl.h; pstl/include/pstl/internal/glue_execution_defs.h; pstl/include/pstl/internal/glue_memory_defs.h; pstl/include/pstl/internal/glue_memory_impl.h; pstl/include/pstl/internal/glue_numeric_defs.h; pstl/include/pstl/internal/glue_numeric_impl.h; pstl/include/pstl/internal/numeric_fwd.h; pstl/include/pstl/internal/parallel_backend.h; pstl/include/pstl/internal/parallel_backend_omp.h; pstl/include/pstl/internal/parallel_backend_serial.h; pstl/include/pstl/internal/parallel_backend_utils.h; pstl/include/pstl/internal/parallel_impl.h; pstl/include/pstl/internal/omp/parallel_for.h; pstl/include/pstl/internal/omp/parallel_for_each.h; pstl/include/pstl/internal/omp/parallel_invoke.h; pstl/include/pstl/internal/omp/parallel_reduce.h; pstl/include/pstl/internal/omp/parallel_scan.h; pstl/include/pstl/internal/omp/parallel_stable_partial_sort.h; pstl/include/pstl/internal/omp/parallel_transform_scan.h; pstl/include/pstl/internal/omp/util.h; third-party/benchmark/cmake/thread_safety_attributes.cpp; third-party/benchmark/src/arraysize.h; third-party/benchmark/src/benchmark_api_internal.h; third-party/benchmark/src/benchmark_register.h; third-party/benchmark/src/benchmark_runner.h; third-party/benchmark/src/check.h; third-party/benchmark/src/colorprint.h; third-party/benchmark/src/commandlineflags.h; third-party/benchmark/src/complexity.h; third-party/benchmark/src/counter.h; third-party/benchmark/src/cycleclock.h; third-party/benchmark/src/internal_macros.h; third-party/benchmark/src/log.h; third-party/benchmark/src/mutex.h; third-party/benchmark/src/perf_counters.h; third-party/benchmark/src/re.h; third-party/benchmark/src/sleep.h; third-party/benchmark/src/statistics.h; third-party/benchmark/src/string_util.h; third-party/benchmark/src/thread_manager.h; third-party/benchmark/src/thread_timer.h; third-party/benchmark/src/timers.h; utils/bazel/llvm-project-overlay/clang/include/clang/Config/config.h; utils/bazel/llvm-project-overlay/llvm/include/llvm/Config/config.h; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:418698,config,config,418698,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,2,['config'],['config']
Modifiability,lias template; Unknown. 2022; CD4; Copy elision in constant expressions; Unknown. 2023; drafting; Composite reference result type of conditional operator; Not resolved. 2024; CD4; Dependent types and unexpanded parameter packs; Unknown. 2025; dup; Declaration matching via alias templates; Unknown. 2026; CD4; Zero-initialization and constexpr; Clang 11. 2027; CD4; Unclear requirements for multiple alignas specifiers; Unknown. 2028; drafting; Converting constructors in rvalue reference initialization; Not resolved. 2029; dup; Abstract class return type in decltype operand; Unknown. 2030; NAD; Access of injected-class-name with template arguments; Unknown. 2031; CD4; Missing incompatibility for &&; Unknown. 2032; CD4; Default template-arguments of variable templates; Unknown. 2033; CD4; Redundant restriction on partial specialization argument; Unknown. 2034; NAD; Deprecating uncaught_exception(); Unknown. 2035; CD3; Multi-section example is confusing; Unknown. 2036; NAD; Refactoring parameters-and-qualifiers; Unknown. 2037; drafting; Alias templates and template declaration matching; Not resolved. 2038; CD4; Document C++14 incompatibility of new braced deduction rule; Unknown. 2039; CD4; Constant conversions to bool; Unknown. 2040; CD4; trailing-return-type no longer ambiguous; Unknown. 2041; CD4; Namespace for explicit class template specialization; Unknown. 2042; drafting; Exceptions and deallocation functions; Not resolved. 2043; drafting; Generalized template arguments and array-to-pointer decay; Not resolved. 2044; CD4; decltype(auto) and void; Unknown. 2045; CD5; “Identical” template parameter lists; Unknown. 2046; C++17; Incomplete thread specifications; Unknown. 2047; CD4; Coordinating “throws anything” specifications; Unknown. 2048; open; C-style casts that cast away constness vs static_cast; Not resolved. 2049; drafting; List initializer in non-type template default argument; Clang 18. 2050; NAD; Consolidate specification of linkage; Unknown. 2051; CD5; Simpli,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:138398,Refactor,Refactoring,138398,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Refactor'],['Refactoring']
Modifiability,"lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the compiler options as the primary method for specifying these paths. While the environment variables ``ROCM_PATH``, ``HIP_PATH``, and ``HIP_DEVICE_LIB_PATH`` are supported, their use can lead to implicit dependencies that might cause issues in the long run. Use them with caution. Predefined Macros; =================. .. list-table::; :header-rows: 1. * - Macro; - Description; * - ``__CLANG_RDC__``; - Defined when Clang is compiling code in Relocatable Device Code (RDC) mode. RDC, enabled with the ``-fgpu-rdc`` compiler option, is necessary for linking device codes across translation units.; * - ``__HIP__``; - Defined when compiling with HIP language support, indicating that the code targets the HIP environment.; * - ``__HIPCC__``; - Alias to ``__HIP__``.; * - ``__HIP_DEVICE_COMPILE__``; - Defined during device code compilation in Clang's separate compilation process for the host and each offloading GPU architecture.; * - ``__HIP_MEMORY_SCOPE_SINGLETHREAD``; - Represents single-thread memory scope in HIP (value is 1).; * - ``__HIP_MEMORY_SCOPE_WAVEFRONT``; - Represents wavefront memory scope in HIP (value is 2).; * - ``__HIP_MEMORY_SCOPE_WORKGROU",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:5330,variab,variables,5330,interpreter/llvm-project/clang/docs/HIPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst,1,['variab'],['variables']
Modifiability,lib/Evaluate/character.h; flang/lib/Evaluate/check-expression.cpp; flang/lib/Evaluate/common.cpp; flang/lib/Evaluate/complex.cpp; flang/lib/Evaluate/constant.cpp; flang/lib/Evaluate/expression.cpp; flang/lib/Evaluate/fold-character.cpp; flang/lib/Evaluate/fold-complex.cpp; flang/lib/Evaluate/fold-designator.cpp; flang/lib/Evaluate/fold-implementation.h; flang/lib/Evaluate/fold-logical.cpp; flang/lib/Evaluate/fold-real.cpp; flang/lib/Evaluate/fold-reduction.cpp; flang/lib/Evaluate/fold-reduction.h; flang/lib/Evaluate/fold.cpp; flang/lib/Evaluate/formatting.cpp; flang/lib/Evaluate/host.cpp; flang/lib/Evaluate/host.h; flang/lib/Evaluate/initial-image.cpp; flang/lib/Evaluate/int-power.h; flang/lib/Evaluate/integer.cpp; flang/lib/Evaluate/intrinsics-library.cpp; flang/lib/Evaluate/intrinsics.cpp; flang/lib/Evaluate/logical.cpp; flang/lib/Evaluate/real.cpp; flang/lib/Evaluate/shape.cpp; flang/lib/Evaluate/static-data.cpp; flang/lib/Evaluate/tools.cpp; flang/lib/Evaluate/type.cpp; flang/lib/Evaluate/variable.cpp; flang/lib/Frontend/CompilerInstance.cpp; flang/lib/Frontend/FrontendAction.cpp; flang/lib/Frontend/FrontendOptions.cpp; flang/lib/Frontend/TextDiagnostic.cpp; flang/lib/Frontend/TextDiagnosticBuffer.cpp; flang/lib/Frontend/TextDiagnosticPrinter.cpp; flang/lib/FrontendTool/ExecuteCompilerInvocation.cpp; flang/lib/Lower/Allocatable.cpp; flang/lib/Lower/Bridge.cpp; flang/lib/Lower/CallInterface.cpp; flang/lib/Lower/Coarray.cpp; flang/lib/Lower/ComponentPath.cpp; flang/lib/Lower/ConvertExpr.cpp; flang/lib/Lower/ConvertType.cpp; flang/lib/Lower/ConvertVariable.cpp; flang/lib/Lower/DumpEvaluateExpr.cpp; flang/lib/Lower/IntervalSet.h; flang/lib/Lower/IntrinsicCall.cpp; flang/lib/Lower/IO.cpp; flang/lib/Lower/IterationSpace.cpp; flang/lib/Lower/Mangler.cpp; flang/lib/Lower/OpenACC.cpp; flang/lib/Lower/OpenMP.cpp; flang/lib/Lower/PFTBuilder.cpp; flang/lib/Lower/RTBuilder.h; flang/lib/Lower/Runtime.cpp; flang/lib/Lower/SymbolMap.cpp; flang/lib/Optimizer/Builder/BoxValue.cpp;,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:117207,variab,variable,117207,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['variab'],['variable']
Modifiability,"libLLVM shared library. Defaults; to OFF. Setting LLVM_LINK_LLVM_DYLIB to ON also sets LLVM_BUILD_LLVM_DYLIB; to ON.; This option is not available on Windows. **LLVM_LIT_ARGS**:STRING; Arguments given to lit. ``make check`` and ``make clang-test`` are affected.; By default, ``'-sv --no-progress-bar'`` on Visual C++ and Xcode, ``'-sv'`` on; others. **LLVM_LIT_TOOLS_DIR**:PATH; The path to GnuWin32 tools for tests. Valid on Windows host. Defaults to; the empty string, in which case lit will look for tools needed for tests; (e.g. ``grep``, ``sort``, etc.) in your %PATH%. If GnuWin32 is not in your; %PATH%, then you can set this variable to the GnuWin32 directory so that; lit can find tools needed for tests in that directory. **LLVM_NATIVE_TOOL_DIR**:STRING; Full path to a directory containing executables for the build host; (containing binaries such as ``llvm-tblgen`` and ``clang-tblgen``). This is; intended for cross-compiling: if the user sets this variable and the; directory contains executables with the expected names, no separate; native versions of those executables will be built. **LLVM_NO_INSTALL_NAME_DIR_FOR_BUILD_TREE**:BOOL; Defaults to ``OFF``. If set to ``ON``, CMake's default logic for library IDs; on Darwin in the build tree will be used. Otherwise the install-time library; IDs will be used in the build tree as well. Mainly useful when other CMake; library ID control variables (e.g., ``CMAKE_INSTALL_NAME_DIR``) are being; set to non-standard values. **LLVM_OPTIMIZED_TABLEGEN**:BOOL; If enabled and building a debug or asserts build the CMake build system will; generate a Release build tree to build a fully optimized tablegen for use; during the build. Enabling this option can significantly speed up build times; especially when building LLVM in Debug configurations. **LLVM_PARALLEL_COMPILE_JOBS**:STRING; Define the maximum number of concurrent compilation jobs. **LLVM_PARALLEL_LINK_JOBS**:STRING; Define the maximum number of concurrent link jobs. **LLVM_RA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:31550,variab,variable,31550,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variable']
Modifiability,"licenses/. TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION. 1. Definitions. ""License"" shall mean the terms and conditions for use, reproduction,; and distribution as defined by Sections 1 through 9 of this document. ""Licensor"" shall mean the copyright owner or entity authorized by; the copyright owner that is granting the License. ""Legal Entity"" shall mean the union of the acting entity and all; other entities that control, are controlled by, or are under common; control with that entity. For the purposes of this definition,; ""control"" means (i) the power, direct or indirect, to cause the; direction or management of such entity, whether by contract or; otherwise, or (ii) ownership of fifty percent (50%) or more of the; outstanding shares, or (iii) beneficial ownership of such entity. ""You"" (or ""Your"") shall mean an individual or Legal Entity; exercising permissions granted by this License. ""Source"" form shall mean the preferred form for making modifications,; including but not limited to software source code, documentation; source, and configuration files. ""Object"" form shall mean any form resulting from mechanical; transformation or translation of a Source form, including but; not limited to compiled object code, generated documentation,; and conversions to other media types. ""Work"" shall mean the work of authorship, whether in Source or; Object form, made available under the License, as indicated by a; copyright notice that is included in or attached to the work; (an example is provided in the Appendix below). ""Derivative Works"" shall mean any work, whether in Source or Object; form, that is based on (or derived from) the Work and for which the; editorial revisions, annotations, elaborations, or other modifications; represent, as a whole, an original work of authorship. For the purposes; of this License, Derivative Works shall not include works that remain; separable from, or merely link (or bind by name) to the interfaces of,; the Work and Derivative",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/LICENSE.TXT:1363,config,configuration,1363,interpreter/llvm-project/clang/LICENSE.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/LICENSE.TXT,5,['config'],['configuration']
Modifiability,"licitly provide a single; definition in a DLL, (dllexported instantiation definition) or to signal that; the definition is available elsewhere (dllimport instantiation declaration). It; also doesn't apply to inline members with static local variables, to ensure; that the same instance of the variable is used inside and outside the DLL. Using this flag can cause problems when inline functions that would otherwise; be dllexported refer to internal symbols of a DLL. For example:. .. code-block:: c. void internal();. struct __declspec(dllimport) S {; void foo() { internal(); }; }. Normally, references to `S::foo()` would use the definition in the DLL from; which it was exported, and which presumably also has the definition of; `internal()`. However, when using ``/Zc:dllexportInlines-``, the inline; definition of `S::foo()` is used directly, resulting in a link error since; `internal()` is not available. Even worse, if there is an inline definition of; `internal()` containing a static local variable, we will now refer to a; different instance of that variable than in the DLL:. .. code-block:: c. inline int internal() { static int x; return x++; }. struct __declspec(dllimport) S {; int foo() { return internal(); }; }. This could lead to very subtle bugs. Using ``-fvisibility-inlines-hidden`` can; lead to the same issue. To avoid it in this case, make `S::foo()` or; `internal()` non-inline, or mark them `dllimport/dllexport` explicitly. Finding Clang runtime libraries; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. clang-cl supports several features that require runtime library support:. - Address Sanitizer (ASan): ``-fsanitize=address``; - Undefined Behavior Sanitizer (UBSan): ``-fsanitize=undefined``; - Code coverage: ``-fprofile-instr-generate -fcoverage-mapping``; - Profile Guided Optimization (PGO): ``-fprofile-generate``; - Certain math operations (int128 division) require the builtins library. In order to use these features, the user must link the right runtime libraries; into th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:189783,variab,variable,189783,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,2,['variab'],['variable']
Modifiability,"licting; sources of ownership, or if it has redundant ownership modifiers, or if it has; ``__autoreleasing`` ownership. * ``assign`` implies ``__unsafe_unretained`` ownership.; * ``copy`` implies ``__strong`` ownership, as well as the usual behavior of; copy semantics on the setter.; * ``retain`` implies ``__strong`` ownership.; * ``strong`` implies ``__strong`` ownership.; * ``unsafe_unretained`` implies ``__unsafe_unretained`` ownership.; * ``weak`` implies ``__weak`` ownership. With the exception of ``weak``, these modifiers are available in non-ARC; modes. A property's specified ownership is preserved in its metadata, but otherwise; the meaning is purely conventional unless the property is synthesized. If a; property is synthesized, then the :arc-term:`associated instance variable` is; the instance variable which is named, possibly implicitly, by the; ``@synthesize`` declaration. If the associated instance variable already; exists, then its ownership qualification must equal the ownership of the; property; otherwise, the instance variable is created with that ownership; qualification. A property of retainable object pointer type which is synthesized without a; source of ownership has the ownership of its associated instance variable, if it; already exists; otherwise, :when-revised:`[beginning Apple 3.1, LLVM 3.1]`; :revision:`its ownership is implicitly` ``strong``. Prior to this revision, it; was ill-formed to synthesize such a property. .. admonition:: Rationale. Using ``strong`` by default is safe and consistent with the generic ARC rule; about :ref:`inferring ownership <arc.ownership.inference.variables>`. It is,; unfortunately, inconsistent with the non-ARC rule which states that such; properties are implicitly ``assign``. However, that rule is clearly; untenable in ARC, since it leads to default-unsafe code. The main merit to; banning the properties is to avoid confusion with non-ARC practice, which did; not ultimately strike us as sufficient to justify req",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:35471,variab,variable,35471,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,['variab'],['variable']
Modifiability,"lied as input to the M minimizers such as VariableMetricMinimizer or; MnMigrad (see [api:migrad]). Later values are determined by M as it; searches for the minimum or performs whatever analysis is requested by; the user. ### FCNBase::up() ###. [howto:errordef] Returns the value of $\mbox{up}$ (default value; $= 1.$), defining parameter errors. M defines parameter errors as the; change in parameter value required to change the function value by; $\mbox{up}$. Normally, for chisquared fits $\mbox{up = 1}$, and; for negative log likelihood, $\mbox{up = 0.5}$. ### $\mbox{FCN}$ function with gradient ###. By default first derivatives are calculated numerically by M . In case; the user wants to supply their own gradient calculator (e.g. analytical; derivatives), they need to implement the FCNGradientBase interface. ![](figures/fcngradientbase.png). The size of the output vector is the same as of the input one. The same; is true for the position of the elements (first derivative of the; function with respect to the $n_\mathrm{th}$ variable has index $n$ in; the output vector). ## M parameters ##. Interaction with the parameters of the function are essential both for M; and the user. Different interfaces are provided, depending on the level; of interaction. ### Minimal required interface ###. Starting values of parameters and uncertainties can be provided to M by; the user via std::vector$<$double$>$ vector containers. Any interaction; with the parameters before minimization (fix, release, limits, etc.) is; not possible then. Optionally if the user wants to provide starting values for the; covariance, they have to provide the values in a std::vector$<$double$>$; vector container stored in upper triangular packed storage format (see; [api:covariance]). ### MnUserParameters ###. A more functional interface to the user parameters is provided through M; via the class MnUserParameters. The user can add parameters giving them; a name and starting values. More information can be fou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:30190,variab,variable,30190,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability,"lignment``, ``object-size``, ``local-bounds``, and ``vptr`` checks do not apply; to pointers to types with the ``volatile`` qualifier. Minimal Runtime; ===============. There is a minimal UBSan runtime available suitable for use in production; environments. This runtime has a small attack surface. It only provides very; basic issue logging and deduplication, and does not support ``-fsanitize=vptr``; checking. To use the minimal runtime, add ``-fsanitize-minimal-runtime`` to the clang; command line options. For example, if you're used to compiling with; ``-fsanitize=undefined``, you could enable the minimal runtime with; ``-fsanitize=undefined -fsanitize-minimal-runtime``. Stack traces and report symbolization; =====================================; If you want UBSan to print symbolized stack trace for each error report, you; will need to:. #. Compile with ``-g`` and ``-fno-omit-frame-pointer`` to get proper debug; information in your binary.; #. Run your program with environment variable; ``UBSAN_OPTIONS=print_stacktrace=1``.; #. Make sure ``llvm-symbolizer`` binary is in ``PATH``. Logging; =======. The default log file for diagnostics is ""stderr"". To log diagnostics to another; file, you can set ``UBSAN_OPTIONS=log_path=...``. Silencing Unsigned Integer Overflow; ===================================; To silence reports from unsigned integer overflow, you can set; ``UBSAN_OPTIONS=silence_unsigned_overflow=1``. This feature, combined with; ``-fsanitize-recover=unsigned-integer-overflow``, is particularly useful for; providing fuzzing signal without blowing up logs. Issue Suppression; =================. UndefinedBehaviorSanitizer is not expected to produce false positives.; If you see one, look again; most likely it is a true positive!. Disabling Instrumentation with ``__attribute__((no_sanitize(""undefined"")))``; ----------------------------------------------------------------------------. You disable UBSan checks for particular functions with; ``__attribute__((no_sani",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:12629,variab,variable,12629,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['variab'],['variable']
Modifiability,"limits or the FUMILI algorithm, which is an optimized method for least square and log likelihood minimizations. The package has been originally developed by M. Winkler and F. James. More information on the new C++ version can be found on the <a href=""http://www.cern.ch/minuit"">MINUIT Web Site</a> and in particular the online doc can be found here <a href=""http://www.cern.ch/mathlibs/sw/html/Minuit2.html"">here</a>.<p>; Minuit2, originally developed in the SEAL project, is now distributed within ROOT. The API has been then changed in this new version to follow the ROOT coding convention (function names starting with capital letters) and the classes have been moved inside the namespace <em>ROOT::Minuit2</em>. In addition, the ROOT distribution contains classes like TFitterMinuit and TFitterFumili needed to integrate Minuit2 in the ROOT framework. <p>; In the latest version (from 5.17.08) a new class has been introduced, ROOT::Minuit2::Minuit2Minimizer, which implements the interface; ROOT::Math::Minimizer from <a href=""http://www.cern.ch/mathlibs/sw/html/MathCore.html"">MathCore</a>.; . It can be instantiates also using the ROOT plug-in manager. It is a convenient entry point for using Minuit2. <h3>References</h3>; <p>; <ol>; <li>; F. James, <em>Fortran MINUIT Reference Manual</em> (<a href=""https://cern-tex.web.cern.ch/cern-tex/minuit/minmain.html"">html</a>); </li>; <li>; F. James and M. Winkler, <em>C++ MINUIT User's Guide</em> (<a href=""http://seal.cern.ch/documents/minuit/mnusersguide.pdf"">pdf</a>); </li>; <li>; F. James, <em>Minuit Tutorial on Function Minimization</em> (<a href=""http://seal.cern.ch/documents/minuit/mntutorial.pdf"">pdf</a>); </li>; <li>; F. James, <em>The Interpretation of Errors in Minuit</em> (<a href=""http://seal.cern.ch/documents/minuit/mnerror.pdf"">pdf</a>); </li>; </ol>; <p>; <hr>; <h3>See also:</h3>; <ul>; <li>Recommended <a href=""http://www.cern.ch/mathlibs/sw/html/Minuit2.html"">Online doc for all Minuit2 classes</a></li>; </ul>; END_HTML; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/index.txt:1566,plug-in,plug-in,1566,math/minuit2/doc/index.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/index.txt,2,['plug-in'],['plug-in']
Modifiability,ling/Core; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/include/clang/Tooling/DependencyScanning; - `5`; - `5`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Inclusions; - `3`; - `3`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Refactoring; - `15`; - `12`; - `3`; - :part:`80%`; * - clang/include/clang/Tooling/Refactoring/Extract; - `2`; - `2`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Refactoring/Rename; - `6`; - `5`; - `1`; - :part:`83%`; * - clang/include/clang/Tooling/Syntax; - `5`; - `5`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Syntax/Pseudo; - `5`; - `5`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Transformer; - `8`; - `6`; - `2`; - :part:`75%`; * - clang/include/clang-c; - `10`; - `3`; - `7`; - :part:`30%`; * - clang/INPUTS; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/lib/Analysis; - `28`; - `3`; - `25`; - :part:`10%`; * - clang/lib/Analysis/FlowSensitive; - `7`; - `7`; - `0`; - :good:`100%`; * - clang/lib/Analysis/plugins/CheckerDependencyHandling; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/lib/Analysis/plugins/CheckerOptionHandling; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/Analysis/plugins/SampleAnalyzer; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/lib/APINotes; - `3`; - `3`; - `0`; - :good:`100%`; * - clang/lib/ARCMigrate; - `22`; - `0`; - `22`; - :none:`0%`; * - clang/lib/AST; - `81`; - `2`; - `79`; - :part:`2%`; * - clang/lib/AST/Interp; - `44`; - `18`; - `26`; - :part:`40%`; * - clang/lib/ASTMatchers; - `3`; - `1`; - `2`; - :part:`33%`; * - clang/lib/ASTMatchers/Dynamic; - `6`; - `1`; - `5`; - :part:`16%`; * - clang/lib/Basic; - `39`; - `13`; - `26`; - :part:`33%`; * - clang/lib/Basic/Targets; - `50`; - `25`; - `25`; - :part:`50%`; * - clang/lib/CodeGen; - `87`; - `9`; - `78`; - :part:`10%`; * - clang/lib/CrossTU; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/DirectoryWatcher; - `2`; - `2`; - `0`; - :good:`100%`; * - clang/lib/DirectoryWatcher/default; - `1`; - `0`; - `1`; - :,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:6697,plugin,plugins,6697,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['plugin'],['plugins']
Modifiability,"ling` for details how `pragma` can be; used. NOTE: You should not call ACLiC with a script that has a function; called `main()`. ### Intermediate Steps and Files. ACLiC executes two steps and a third one if needed. These are:. - Calling `rootcling` to create a dictionary using `rootcling`.; - Calling the compiler to build the shared library from the script.; - If there are errors, it calls the compiler to build a dummy; executable to clearly report unresolved symbols. ACLiC makes a shared library with a dictionary containing the; classes and functions declared in the script. It also adds the; classes and functions declared in included files with the same name; as the script file and any of the following extensions: `.h`, `.hh`,; `.hpp`, `.hxx`, `.hPP`, `.hXX`. This means that, by default, you; cannot combine scripts from different files into one library by using; `#include` statements; you will need to compile each script; separately. In a future release, we plan to add the global variables; declared in the script to the dictionary also. If you are curious; about the specific calls, you can raise the ROOT debug level: gDebug=3; and ACLiC will print these steps. If you need to keep the intermediate; files around, for example when debugging the script using gdb, use; gDebug=7. ### Moving between Interpreter and Compiler. The best way to develop portable scripts is to make sure you can; always run them with both, the interpreter and with ACLiC. To do so,; do not use the Cling extensions and program around the Cling; limitations. When it is not possible or desirable to program around; the Cling limitations, you can use the C preprocessor symbols defined; for Cling and `rootcling`. The preprocessor symbol `__CLING__` is defined for both ROOT and; `rootcling`. The symbol `__ROOTCLING__` (and `__MAKECINT__` for backward; compatibility) is only defined in `rootcling`. Use `!defined(__CLING__) || defined(__ROOTCLING__)` to bracket code that; needs to be seen by the compiler a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:20849,variab,variables,20849,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['variab'],['variables']
Modifiability,"link-time, but it is the extra time required that concerns me. Link-time; > optimization is severely time-constrained. If we were to reimplement any of these optimizations, I assume that we; could do them a translation unit at a time, just as GCC does now. This; would lead to a pipeline like this:. Static optimizations, xlation unit at a time:; .c --GCC--> .llvm --llvmopt--> .llvm . Link time optimizations:; .llvm --llvm-ld--> .llvm --llvm-link-opt--> .llvm . Of course, many optimizations could be shared between llvmopt and; llvm-link-opt, but the wouldn't need to be shared... Thus compile time; could be faster, because we are using a ""smarter"" IR (SSA based). > BTW, about SGI, ""borrowing"" SSA-based optimizations from one compiler and; > putting it into another is not necessarily easier than re-doing it.; > Optimization code is usually heavily tied in to the specific IR they use. Understood. The only reason that I brought this up is because SGI's IR is; more similar to LLVM than it is different in many respects (SSA based,; relatively low level, etc), and could be easily adapted. Also their; optimizations are written in C++ and are actually somewhat; structured... of course it would be no walk in the park, but it would be; much less time consuming to adapt, say, SSA-PRE than to rewrite it. > But your larger point is valid that adding SSA based optimizations is; > feasible and should be fun. (Again, link time cost is the issue.). Assuming linktime cost wasn't an issue, the question is: ; Does using GCC's backend buy us anything?. > It also occurs to me that GCC is probably doing quite a bit of back-end; > optimization (step 16 in your list). Do you have a breakdown of that?. Not really. The irritating part of GCC is that it mixes it all up and; doesn't have a clean separation of concerns. A lot of the ""back end; optimization"" happens right along with other data optimizations (ie, CSE; of machine specific things). As far as REAL back end optimizations go, it looks som",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations2.txt:1333,adapt,adapted,1333,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations2.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-01-GCCOptimizations2.txt,1,['adapt'],['adapted']
Modifiability,"lit - LLVM Integrated Tester; ============================. .. program:: lit. SYNOPSIS; --------. :program:`lit` [*options*] [*tests*]. DESCRIPTION; -----------. :program:`lit` is a portable tool for executing LLVM and Clang style test; suites, summarizing their results, and providing indication of failures.; :program:`lit` is designed to be a lightweight testing tool with as simple a; user interface as possible. :program:`lit` should be run with one or more *tests* to run specified on the; command line. Tests can be either individual test files or directories to; search for tests (see :ref:`test-discovery`). Each specified test will be executed (potentially concurrently) and once all; tests have been run :program:`lit` will print summary information on the number; of tests which passed or failed (see :ref:`test-status-results`). The; :program:`lit` program will execute with a non-zero exit code if any tests; fail. By default :program:`lit` will use a succinct progress display and will only; print summary information for test failures. See :ref:`output-options` for; options controlling the :program:`lit` progress display and output. :program:`lit` also includes a number of options for controlling how tests are; executed (specific features may depend on the particular test format). See; :ref:`execution-options` for more information. Finally, :program:`lit` also supports additional options for only running a; subset of the options specified on the command line, see; :ref:`selection-options` for more information. :program:`lit` parses options from the environment variable ``LIT_OPTS`` after; parsing options from the command line. ``LIT_OPTS`` is primarily useful for; supplementing or overriding the command-line options supplied to :program:`lit`; by ``check`` targets defined by a project's build system. :program:`lit` can also read options from response files which are specified as; inputs using the ``@path/to/file.rsp`` syntax. Arguments read from a file must; be one p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:182,portab,portable,182,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['portab'],['portable']
Modifiability,"lized, x is being read, report a bug.; }; ```. For this purpose we can use lattice in a form of a mapping from variable; declarations to initialization states; each initialization state is represented; by the following lattice:. ![Lattice for definitive initialization analysis](DataFlowAnalysisIntroImages/DefinitiveInitializationLattice.svg). A lattice element could also capture the source locations of the branches that; lead us to the corresponding program point. Diagnostics would use this; information to show a sample buggy code path to the user. ## Example: refactoring raw pointers to `unique_ptr`. Modern idiomatic C++ uses smart pointers to express memory ownership, however in; pre-C++11 code one can often find raw pointers that own heap memory blocks. Imagine that we would like to refactor raw pointers that own memory to; `unique_ptr`. There are multiple ways to design a data flow analysis for this; problem; let's look at one way to do it. For example, we would like to refactor the following code that uses raw; pointers:. ```c++; void UniqueOwnership1() {; int *pi = new int;; if (...) {; Borrow(pi);; delete pi;; } else {; TakeOwnership(pi);; }; }; ```. into code that uses `unique_ptr`:. ```c++; void UniqueOwnership1() {; auto pi = std::make_unique<int>();; if (...) {; Borrow(pi.get());; } else {; TakeOwnership(pi.release());; }; }; ```. This problem can be solved with a lattice in form of map from value declarations; to pointer states:. ![Lattice that identifies candidates for unique_ptr refactoring](DataFlowAnalysisIntroImages/UniquePtrLattice.svg). We can perform the refactoring if at the exit of a function `pi` is; `Compatible`. ```c++; void UniqueOwnership1() {; int *pi; // pi is Compatible; pi = new int; // pi is Defined; if (...) {; Borrow(pi); // pi is Defined; delete pi; // pi is Compatible; } else {; TakeOwnership(pi); // pi is Compatible; }; // pi is Compatible; }; ```. Let's look at an example where the raw pointer owns two different memory blocks:. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:21857,refactor,refactor,21857,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['refactor'],['refactor']
Modifiability,"ll CMake build for building a C++ ""Hello World""; program. The example uses only CMake language-defined functions. .. code-block:: cmake. cmake_minimum_required(VERSION 3.20.0); project(HelloWorld); add_executable(HelloWorld HelloWorld.cpp). The CMake language provides control flow constructs in the form of foreach loops; and if blocks. To make the example above more complicated you could add an if; block to define ""APPLE"" when targeting Apple platforms:. .. code-block:: cmake. cmake_minimum_required(VERSION 3.20.0); project(HelloWorld); add_executable(HelloWorld HelloWorld.cpp); if(APPLE); target_compile_definitions(HelloWorld PUBLIC APPLE); endif(). Variables, Types, and Scope; ===========================. Dereferencing; -------------. In CMake variables are ""stringly"" typed. All variables are represented as; strings throughout evaluation. Wrapping a variable in ``${}`` dereferences it; and results in a literal substitution of the name for the value. CMake refers to; this as ""variable evaluation"" in their documentation. Dereferences are performed; *before* the command being called receives the arguments. This means; dereferencing a list results in multiple separate arguments being passed to the; command. Variable dereferences can be nested and be used to model complex data. For; example:. .. code-block:: cmake. set(var_name var1); set(${var_name} foo) # same as ""set(var1 foo)""; set(${${var_name}}_var bar) # same as ""set(foo_var bar)"". Dereferencing an unset variable results in an empty expansion. It is a common; pattern in CMake to conditionally set variables knowing that it will be used in; code paths that the variable isn't set. There are examples of this throughout; the LLVM CMake build system. An example of variable empty expansion is:. .. code-block:: cmake. if(APPLE); set(extra_sources Apple.cpp); endif(); add_executable(HelloWorld HelloWorld.cpp ${extra_sources}). In this example the ``extra_sources`` variable is only defined if you're; targeting an Apple pla",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:3091,variab,variable,3091,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['variab'],['variable']
Modifiability,"ll fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; =================================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:34741,config,configuration,34741,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['configuration']
Modifiability,"ll of links to slides, video, and sometimes code. When deciding between creating a type hierarchy (with either tagged or virtual; dispatch) and using templates or concepts-based polymorphism, consider whether; there is some refinement of an abstract base class which is a semantically; meaningful type on an interface boundary. If anything more refined than the; root abstract interface is meaningless to talk about as a partial extension of; the semantic model, then your use case likely fits better with polymorphism and; you should avoid using virtual dispatch. However, there may be some exigent; circumstances that require one technique or the other to be used. If you do need to introduce a type hierarchy, we prefer to use explicitly; closed type hierarchies with manual tagged dispatch and/or RTTI rather than the; open inheritance model and virtual dispatch that is more common in C++ code.; This is because LLVM rarely encourages library consumers to extend its core; types, and leverages the closed and tag-dispatched nature of its hierarchies to; generate significantly more efficient code. We have also found that a large; amount of our usage of type hierarchies fits better with tag-based pattern; matching rather than dynamic dispatch across a common interface. Within LLVM we; have built custom helpers to facilitate this design. See this document's; section on :ref:`isa and dyn_cast <isa>` and our :doc:`detailed document; <HowToSetUpLLVMStyleRTTI>` which describes how you can implement this; pattern for use with the LLVM helpers. .. _abi_breaking_checks:. ABI Breaking Checks; -------------------. Checks and asserts that alter the LLVM C++ ABI are predicated on the; preprocessor symbol `LLVM_ENABLE_ABI_BREAKING_CHECKS` -- LLVM; libraries built with `LLVM_ENABLE_ABI_BREAKING_CHECKS` are not ABI; compatible LLVM libraries built without it defined. By default,; turning on assertions also turns on `LLVM_ENABLE_ABI_BREAKING_CHECKS`; so a default +Asserts build is not ABI compat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:132577,extend,extend,132577,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['extend'],['extend']
Modifiability,"ll render an order of; magnitude faster with the COL2 option. The COL2 option will also scale its performance based on the size of the pixmap; the histogram image is being rendered into. It also is much better optimized for; sessions where the user is forwarding X11 windows through an `ssh` connection. For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; and COLZ options. There is one major difference and that concerns the treatment of; bins with zero content. The COL2 and COLZ2 options color these bins the color of zero. This has been implemented by Jeromy Tompkins <Tompkins@nscl.msu.edu>. ## Geometry Libraries; A new module geom/vecgeom was introduced to give transparent access to VecGeom ; solid primitives. VecGeom is a high performance geometry package (link) providing ; SIMD vectorization for the CPU-intensive geometry algorithms used for geometry; navigation. The module creates a new library libConverterVG.so depending on the; VecGeom main library and loaded using the ROOT plug-in mechanism. The main functionality provided by the new vecgeom module is to make a conversion ; in memory of all the shapes in a loaded TGeo geometry into a special adapter; shape TGeoVGShape, redirecting all navigation calls to the corresponding VecGeom ; solid. The library loading and geometry conversion can be done with a single call ; `TVirtualGeoConverter::Instance()->ConvertGeometry()`; . After the conversion is done, all existing TGeo functionality is available as for; a native geometry, only that most of the converted solids provide better navigation ; performance, despite the overhead introduced by the new adapter shape. Prerequisites: installation of VecGeom. ; The installation instructions are available at <http://geant.web.cern.ch/content/installation>; Due to the fact that VecGeom provides for the moment static libraries ; and depends on ROOT, is is advised to compile first ROOT without VecGeom support, ; then compile VecGeom against this RO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:23420,plug-in,plug-in,23420,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['plug-in'],['plug-in']
Modifiability,"ll. Tab completion, output and graphics inlining have been added. These functionalities are automatically available upon import of the ROOT module in a Notebook or at startup of a ROOT prompt kernel.; We made it easier to use ROOT notebooks locally, by providing a 'root --notebook' command option to start a local notebook server customised with all the ROOT features. New tutorials and code examples have been provided. The simplest example showing the integration of ROOT with the notebook technology can be found [here](https://root.cern.ch/notebooks/HowTos/HowTo_ROOT-Notebooks.html) and many more snippets [here](https://root.cern.ch/code-examples#notebooks). Support for capturing large outputs (stderr/stdout) coming from C++ libraries has been added. ## JavaScript ROOT. - support registered in THttpServer commands with arguments.; - provide workaround for websites using require.js and older jquery-ui; - support custom requests to remote objects, demonstrated in httptextlog.C tutorial; - rewrite draw.htm (page for individual object drawing) to support all custom features as main gui does; - See also the [JSRoot 3.9 examples page](https://root.cern.ch/js/3.9/) and the [JSRoot 3.9 release notes](https://github.com/linev/jsroot/releases/tag/3.9). ## Class Reference Guide. The ROOT [reference guide](https://root.cern.ch/doc/master/index.html) is moving; to the Doxygen system. Doxygen is the de-facto standard for code documentation. It offers; many nice features we are now exploring and trying to get the best of them. Having; [MathJax rendered math formula](https://root.cern.ch/doc/master/classTSpectrum2.html#a482a7f144b9cc1b0405d0ac0d8cc9bbb); is one of them. The documentation can be structured in a more logical way; [using groups](https://root.cern.ch/doc/master/modules.html). Still there is a lot; to do but big progresses have been done. We developed also a Doxygen filter allowing; to execute macros given as examples in the documentation and show the; [resulting picture ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:23270,rewrite,rewrite,23270,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['rewrite'],['rewrite']
Modifiability,"ller raw profile size, and; better runtime performance. Frontend-based instrumentation, on the other hand,; has better source correlation, so it should be used with source line-based; coverage testing. The flag ``-fcs-profile-generate`` also instruments programs using the same; instrumentation method as ``-fprofile-generate``. However, it performs a; post-inline late instrumentation and can produce context-sensitive profiles. Here are the steps for using profile guided optimization with; instrumentation:. 1. Build an instrumented version of the code by compiling and linking with the; ``-fprofile-generate`` or ``-fprofile-instr-generate`` option. .. code-block:: console. $ clang++ -O2 -fprofile-instr-generate code.cc -o code. 2. Run the instrumented executable with inputs that reflect the typical usage.; By default, the profile data will be written to a ``default.profraw`` file; in the current directory. You can override that default by using option; ``-fprofile-instr-generate=`` or by setting the ``LLVM_PROFILE_FILE``; environment variable to specify an alternate file. If non-default file name; is specified by both the environment variable and the command line option,; the environment variable takes precedence. The file name pattern specified; can include different modifiers: ``%p``, ``%h``, ``%m``, ``%t``, and ``%c``. Any instance of ``%p`` in that file name will be replaced by the process; ID, so that you can easily distinguish the profile output from multiple; runs. .. code-block:: console. $ LLVM_PROFILE_FILE=""code-%p.profraw"" ./code. The modifier ``%h`` can be used in scenarios where the same instrumented; binary is run in multiple different host machines dumping profile data; to a shared network based storage. The ``%h`` specifier will be substituted; with the hostname so that profiles collected from different hosts do not; clobber each other. While the use of ``%p`` specifier can reduce the likelihood for the profiles; dumped from different processes to clobbe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:103942,variab,variable,103942,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variable']
Modifiability,"llocas, we'll use a helper; function that ensures that the allocas are created in the entry block of; the function:. .. code-block:: c++. /// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of; /// the function. This is used for mutable variables etc.; static AllocaInst *CreateEntryBlockAlloca(Function *TheFunction,; const std::string &VarName) {; IRBuilder<> TmpB(&TheFunction->getEntryBlock(),; TheFunction->getEntryBlock().begin());; return TmpB.CreateAlloca(Type::getDoubleTy(*TheContext), nullptr,; VarName);; }. This funny looking code creates an IRBuilder object that is pointing at; the first instruction (.begin()) of the entry block. It then creates an; alloca with the expected name and returns it. Because all values in; Kaleidoscope are doubles, there is no need to pass in a type to use. With this in place, the first functionality change we want to make belongs to; variable references. In our new scheme, variables live on the stack, so; code generating a reference to them actually needs to produce a load; from the stack slot:. .. code-block:: c++. Value *VariableExprAST::codegen() {; // Look this variable up in the function.; AllocaInst *A = NamedValues[Name];; if (!A); return LogErrorV(""Unknown variable name"");. // Load the value.; return Builder->CreateLoad(A->getAllocatedType(), A, Name.c_str());; }. As you can see, this is pretty straightforward. Now we need to update; the things that define the variables to set up the alloca. We'll start; with ``ForExprAST::codegen()`` (see the `full code listing <#id1>`_ for; the unabridged code):. .. code-block:: c++. Function *TheFunction = Builder->GetInsertBlock()->getParent();. // Create an alloca for the variable in the entry block.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);. // Emit the start code first, without 'variable' in scope.; Value *StartVal = Start->codegen();; if (!StartVal); return nullptr;. // Store the value into the alloca.; Builder->CreateStore(StartV",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:13746,variab,variables,13746,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability,"llvm-addr2line - a drop-in replacement for addr2line; ====================================================. .. program:: llvm-addr2line. SYNOPSIS; --------. :program:`llvm-addr2line` [*options*]. DESCRIPTION; -----------. :program:`llvm-addr2line` is an alias for the :manpage:`llvm-symbolizer(1)`; tool with different defaults. The goal is to make it a drop-in replacement for; GNU's :program:`addr2line`. Here are some of those differences:. - ``llvm-addr2line`` interprets all addresses as hexadecimal and ignores an; optional ``0x`` prefix, whereas ``llvm-symbolizer`` attempts to determine; the base from the literal's prefix and defaults to decimal if there is no; prefix. - ``llvm-addr2line`` defaults not to print function names. Use `-f`_ to enable; that. - ``llvm-addr2line`` defaults not to demangle function names. Use `-C`_ to; switch the demangling on. - ``llvm-addr2line`` defaults not to print inlined frames. Use `-i`_ to show; inlined frames for a source code location in an inlined function. - ``llvm-addr2line`` uses `--output-style=GNU`_ by default. - ``llvm-addr2line`` parses options from the environment variable; ``LLVM_ADDR2LINE_OPTS`` instead of from ``LLVM_SYMBOLIZER_OPTS``. SEE ALSO; --------. :manpage:`llvm-symbolizer(1)`. .. _-f: llvm-symbolizer.html#llvm-symbolizer-opt-f; .. _-C: llvm-symbolizer.html#llvm-symbolizer-opt-c; .. _-i: llvm-symbolizer.html#llvm-symbolizer-opt-i; .. _--output-style=GNU: llvm-symbolizer.html#llvm-symbolizer-opt-output-style; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-addr2line.rst:1128,variab,variable,1128,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-addr2line.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-addr2line.rst,1,['variab'],['variable']
Modifiability,"llvm-config - Print LLVM compilation options; ============================================. .. program:: llvm-config. SYNOPSIS; --------. **llvm-config** *option* [*components*...]. DESCRIPTION; -----------. **llvm-config** makes it easier to build applications that use LLVM. It can; print the compiler flags, linker flags and object libraries needed to link; against LLVM. EXAMPLES; --------. To link against the JIT:. .. code-block:: sh. g++ `llvm-config --cxxflags` -o HowToUseJIT.o -c HowToUseJIT.cpp; g++ `llvm-config --ldflags` -o HowToUseJIT HowToUseJIT.o \; `llvm-config --libs engine bcreader scalaropts`. OPTIONS; -------. **--assertion-mode**. Print the assertion mode used when LLVM was built (ON or OFF). **--bindir**. Print the installation directory for LLVM binaries. **--build-mode**. Print the build mode used when LLVM was built (e.g. Debug or Release). **--build-system**. Print the build system used to build LLVM (e.g. `cmake` or `gn`). **--cflags**. Print the C compiler flags needed to use LLVM headers. **--cmakedir**. Print the installation directory for LLVM CMake modules. **--components**. Print all valid component names. **--cppflags**. Print the C preprocessor flags needed to use LLVM headers. **--cxxflags**. Print the C++ compiler flags needed to use LLVM headers. **--has-rtti**. Print whether or not LLVM was built with rtti (YES or NO). **--help**. Print a summary of **llvm-config** arguments. **--host-target**. Print the target triple used to configure LLVM. **--ignore-libllvm**. Ignore libLLVM and link component libraries instead. **--includedir**. Print the installation directory for LLVM headers. **--ldflags**. Print the flags needed to link against LLVM libraries. **--libdir**. Print the installation directory for LLVM libraries. **--libfiles**. Similar to **--libs**, but print the full path to each library file. This is; useful when creating makefile dependencies, to ensure that a tool is relinked if; any library it uses changes. **--libnames**",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-config.rst:5,config,config,5,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-config.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-config.rst,7,['config'],['config']
Modifiability,"llvm-extract - extract a function from an LLVM module; =====================================================. .. program:: llvm-extract. SYNOPSIS; --------. :program:`llvm-extract` [*options*] **--func** *function-name* [*filename*]. DESCRIPTION; -----------. The :program:`llvm-extract` command takes the name of a function and extracts; it from the specified LLVM bitcode file. It is primarily used as a debugging; tool to reduce test cases from larger programs that are triggering a bug. In addition to extracting the bitcode of the specified function,; :program:`llvm-extract` will also remove unreachable global variables,; prototypes, and unused types. The :program:`llvm-extract` command reads its input from standard input if; filename is omitted or if filename is ``-``. The output is always written to; standard output, unless the **-o** option is specified (see below). OPTIONS; -------. **--alias** *alias-name*. Extract the alias named *function-name* from the LLVM bitcode. May be; specified multiple times to extract multiple alias at once. **--ralias** *alias-regular-expr*. Extract the alias matching *alias-regular-expr* from the LLVM bitcode.; All alias matching the regular expression will be extracted. May be; specified multiple times. **--bb** *basic-block-specifier*. Extract basic blocks(s) specified in *basic-block-specifier*. May be; specified multiple times. Each <function:bb[;bb]> specifier pair will create; a function. If multiple basic blocks are specified in one pair, the first; block in the sequence should dominate the rest. **--delete**. Delete specified Globals from Module. **-f**. Enable binary output on terminals. Normally, :program:`llvm-extract` will; refuse to write raw bitcode output if the output stream is a terminal. With; this option, :program:`llvm-extract` will write raw bitcode regardless of the; output device. **--func** *function-name*. Extract the function named *function-name* from the LLVM bitcode. May be; specified multiple times to ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-extract.rst:617,variab,variables,617,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-extract.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-extract.rst,1,['variab'],['variables']
Modifiability,"llvm-locstats - calculate statistics on DWARF debug location; ============================================================. .. program:: llvm-locstats. SYNOPSIS; --------. :program:`llvm-locstats` [*options*] [*filename*]. DESCRIPTION; -----------. :program:`llvm-locstats` works like a wrapper around :program:`llvm-dwarfdump`.; It parses :program:`llvm-dwarfdump` statistics regarding debug location by; pretty printing it in a more human readable way. The line 0% shows the number and the percentage of DIEs with no location; information, but the line 100% shows the information for DIEs where there is; location information in all code section bytes (where the variable or parameter; is in the scope). The line [50%,60%) shows the number and the percentage of DIEs; where the location information is between 50 and 60 percentage of its scope; covered. OPTIONS; -------. .. option:: --only-variables. calculate the location statistics only for local variables. .. option:: --only-formal-parameters. calculate the location statistics only for formal parameters. .. option:: --ignore-debug-entry-values. ignore the location statistics on locations containing the; debug entry values DWARF operation. .. option:: --draw-plot. make histogram of location buckets generated (requires; matplotlib). .. option:: --compare. compare the debug location coverage on two files provided, and draw; a plot showing the difference (requires matplotlib). EXIT STATUS; -----------. :program:`llvm-locstats` returns 0 if the input file were parsed; successfully. Otherwise, it returns 1. EXAMPLE 1; --------------. Pretty print the location coverage on the standard output. .. code-block:: none. llvm-locstats a.out. =================================================; Debug Location Statistics; =================================================; cov% samples percentage(~); -------------------------------------------------; 0% 1 16%; (0%,10%) 0 0%; [10%,20%) 0 0%; [20%,30%) 0 0%; [30%,40%) 0 0%; [40%,50%) 0 0%; [50%",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-locstats.rst:665,variab,variable,665,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-locstats.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-locstats.rst,3,['variab'],"['variable', 'variables']"
Modifiability,"llvm.dbg.assign`; intrinsics and `DIAssignID` attachments as if the stores represent source; assignments, just like the in frontend. This isn’t perfect, as stores may have; been moved, modified or deleted before inlining, but it does at least keep the; information about the variable correct within the non-inlined scope. **Splitting** stores: SROA and passes that split stores treat `llvm.dbg.assign`; intrinsics similarly to `llvm.dbg.declare` intrinsics. Clone the; `llvm.dbg.assign` intrinsics linked to the store, update the FragmentInfo in; the `ValueExpression`, and give the split stores (and cloned intrinsics) new; `DIAssignID` attachments each. In other words, treat the split stores as; separate assignments. For partial DSE (e.g. shortening a memset), we do the; same except that `llvm.dbg.assign` for the dead fragment gets an `Undef`; `Address`. **Promoting** allocas and store/loads: `llvm.dbg.assign` intrinsics implicitly; describe joined values in memory locations at CFG joins, but this is not; necessarily the case after promoting (or partially promoting) the; variable. Passes that promote variables are responsible for inserting; `llvm.dbg.assign` intrinsics after the resultant PHIs generated during; promotion. `mem2reg` already has to do this (with `llvm.dbg.value`) for; `llvm.dbg.declare`s. Where a store has no linked intrinsic, the store is; assumed to represent an assignment for variables stored at the destination; address. #### Debug intrinsic updates. **Moving** a debug intrinsic: avoid moving `llvm.dbg.assign` intrinsics where; possible, as they represent a source-level assignment, whose position in the; program should not be affected by optimization passes. **Deleting** a debug intrinsic: Nothing new to do. Just like for conventional; debug intrinsics, unless it is unreachable, it’s almost always incorrect to; delete a `llvm.dbg.assign` intrinsic. ### Lowering `llvm.dbg.assign` to MIR. To begin with only SelectionDAG ISel will be supported. `llvm.dbg.ass",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:8044,variab,variable,8044,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,1,['variab'],['variable']
Modifiability,"lly. - the generated kernel binary does not contain indirect calls because they; are eliminated using compiler optimizations e.g. devirtualization. - the selected target supports the function pointer like functionality e.g.; most CPU targets. **Example of Use**:. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_function_pointers : enable; void foo(); {; void (*fp)(); // compiled - no diagnostic generated; }. #pragma OPENCL EXTENSION __cl_clang_function_pointers : disable; void bar(); {; void (*fp)(); // error - pointers to function are not allowed; }. ``__cl_clang_variadic_functions``; ---------------------------------. With this extension it is possible to enable variadic arguments in functions; using regular OpenCL extension pragma mechanism detailed in `the OpenCL; Extension Specification, section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. This is not conformant behavior and it can only be used portably when the; functions with variadic prototypes do not get generated in binary e.g. the; variadic prototype is used to specify a function type with any number of; arguments in metaprogramming algorithms in C++ for OpenCL. This extensions can also be used when the kernel code is intended for targets; supporting the variadic arguments e.g. majority of CPU targets. **Example of Use**:. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_variadic_functions : enable; void foo(int a, ...); // compiled - no diagnostic generated. #pragma OPENCL EXTENSION __cl_clang_variadic_functions : disable; void bar(int a, ...); // error - variadic prototype is not allowed. ``__cl_clang_non_portable_kernel_param_types``; ----------------------------------------------. With this extension it is possible to enable the use of some restricted types; in kernel parameters specified in `C++ for OpenCL v1.0 s2.4; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html#kernel_function>`_.; The restrictions can be re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:88430,portab,portably,88430,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['portab'],['portably']
Modifiability,lo 2n arithmetic for implicitly-unsigned types; Unknown. 1516; CD3; Definition of “virtual function call”; Unknown. 1517; drafting; Unclear/missing description of behavior during construction/destruction; Not resolved. 1518; CD4; Explicit default constructors and copy-list-initialization; Clang 4. 1519; NAD; Conflicting default and variadic constructors; Unknown. 1520; NAD; Alias template specialization vs pack expansion; Unknown. 1521; drafting; T{expr} with reference types; Not resolved. 1522; CD3; Access checking for initializer_list array initialization; Unknown. 1523; CD5; Point of declaration in range-based for; Unknown. 1524; drafting; Incompletely-defined class template base; Not resolved. 1525; NAD; Array bound inference in temporary array; Unknown. 1526; dup; Dependent-class lookup in the current instantiation; Unknown. 1527; CD3; Assignment from braced-init-list; Unknown. 1528; CD3; Repeated cv-qualifiers in declarators; Unknown. 1529; drafting; Nomenclature for variable vs reference non-static data member; Not resolved. 1530; drafting; Member access in out-of-lifetime objects; Not resolved. 1531; CD3; Definition of “access” (verb); Unknown. 1532; CD3; Explicit instantiation and member templates; Unknown. 1533; CD3; Function pack expansion for member initialization; Unknown. 1534; dup; cv-qualification of prvalue of type “array of class”; Unknown. 1535; CD3; typeid in core constant expressions; Unknown. 1536; drafting; Overload resolution with temporary from initializer list; Not resolved. 1537; CD3; Optional compile-time evaluation of constant expressions; Unknown. 1538; CD3; C-style cast in braced-init-list assignment; Unknown. 1539; CD3; Definition of “character type”; Unknown. 1540; NAD; Use of address constants in constant expressions; Unknown. 1541; CD3; cv void return types; Unknown. 1542; drafting; Compound assignment of braced-init-list; Not resolved. 1543; CD3; Implicit conversion sequence for empty initializer list; Unknown. 1544; CD3; Linkage o,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:102894,variab,variable,102894,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['variab'],['variable']
Modifiability,"loading). TSystem. Better handle the cases where the information in the rootmap file is (almost) empty. ; Avoid infinite loop if one of the dependent library is missing. Meta. Add new fast accessors to Merge routines (See the I/O package for more details.; Improve error message in case a schema evolution rule can not be loaded when the library is loaded; (from the generic 'it conflicts with one of the other rules' to 'the target member ... is unknown'.; Add the ability to explicitly forbid (or allow) the splitting of a class; (TClass::SetSplit ) so that user can inforce the use of a custom streamer in all possible split cases.; Improve the performance of TProcessUUID::AddUUID by reintroducing the THashList.; This significanly improve the performance of reading file with very large number of ; directories (A file with 100,000 directories was traversed in more than 8 minutes; and is now traversed in 15s) without noticeable affecting small files. TFolder. Several enhancement and clarification to TFolder::FindFullPathName. TStyle. Add the fill color attribute (SetLegendFillColor() and the font; attribute (SetLegendFont(). A new TStyle called ""Modern"" has been implemented. It can be set with:. gROOT->SetStyle(""Modern"");; ; It has very little decoration. It was made looking at the default styles; usually used by the experiments.; ; A new parameter Canvas.Style in etc/system.rootrc allows; to define the default style. If it is not specified, the Modern; style is used. To use the old default style one can set it to Classic or add. gROOT->SetStyle(""Classic"");; ; to your scripts. We seek feedback on improving the Modern style.; Please leave comments in the forum.; ; The following table shows the two plots hpx->Draw() and hpxpy->Draw(""colz""); in the ""Classic"" and ""Modern"" styles.; . Classic Style; Modern Style. An other example:; ; Classic style:. Modern style:. ACLiC. ACLiC now passes the macro __ACLIC__ to both the rootcint and compiler phases. TWinNTSystem. Fix 64-bit compa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html:2233,enhance,enhancement,2233,core/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html,2,['enhance'],['enhancement']
Modifiability,"loating>` type.; This instruction is assumed to execute in the default :ref:`floating-point; environment <floatenv>`. NaN values follow the usual :ref:`NaN behaviors <floatnan>`, except that _if_ a; NaN payload is propagated from the input (""Quieting NaN propagation"" or; ""Unchanged NaN propagation"" cases), then the low order bits of the NaN payload; which cannot fit in the resulting type are discarded. Note that if discarding; the low order bits leads to an all-0 payload, this cannot be represented as a; signaling NaN (it would represent an infinity instead), so in that case; ""Unchanged NaN propagation"" is not possible. Example:; """""""""""""""". .. code-block:: llvm. %X = fptrunc double 16777217.0 to float ; yields float:16777216.0; %Y = fptrunc double 1.0E+300 to half ; yields half:+infinity. '``fpext .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fpext <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``fpext``' extends a floating-point ``value`` to a larger floating-point; value. Arguments:; """""""""""""""""""". The '``fpext``' instruction takes a :ref:`floating-point <t_floating>`; ``value`` to cast, and a :ref:`floating-point <t_floating>` type to cast it; to. The source type must be smaller than the destination type. Semantics:; """""""""""""""""""". The '``fpext``' instruction extends the ``value`` from a smaller; :ref:`floating-point <t_floating>` type to a larger :ref:`floating-point; <t_floating>` type. The ``fpext`` cannot be used to make a; *no-op cast* because it always changes bits. Use ``bitcast`` to make a; *no-op cast* for a floating-point cast. NaN values follow the usual :ref:`NaN behaviors <floatnan>`, except that _if_ a; NaN payload is propagated from the input (""Quieting NaN propagation"" or; ""Unchanged NaN propagation"" cases), then it is copied to the high order bits of; the resulting payload, and the remaining low order bits are zero. Example:; """""""""""""""". .. code-block:: llvm. %X = fpext float 3.125 to double ; yields",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:447157,extend,extends,447157,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['extend'],['extends']
Modifiability,"lobal ``V``. * ``V`` in a record body shadows template argument ``V``. * ``V`` in template arguments shadows a global ``V``. * ``V`` in a ``foreach`` statement list shadows any ``V`` in surrounding record or; global scopes. Variables defined in a ``foreach`` go out of scope at the end of; each loop iteration, so their value in one iteration is not available in; the next iteration. The following ``defvar`` will not work::. defvar i = !add(i, 1). How records are built; ---------------------. The following steps are taken by TableGen when a record is built. Classes are simply; abstract records and so go through the same steps. 1. Build the record name (:token:`NameValue`) and create an empty record. 2. Parse the parent classes in the :token:`ParentClassList` from left to; right, visiting each parent class's ancestor classes from top to bottom. a. Add the fields from the parent class to the record.; b. Substitute the template arguments into those fields.; c. Add the parent class to the record's list of inherited classes. 3. Apply any top-level ``let`` bindings to the record. Recall that top-level; bindings only apply to inherited fields. 4. Parse the body of the record. * Add any fields to the record.; * Modify the values of fields according to local ``let`` statements.; * Define any ``defvar`` variables. 5. Make a pass over all the fields to resolve any inter-field references. 6. Add the record to the final record list. Because references between fields are resolved (step 5) after ``let`` bindings are; applied (step 3), the ``let`` statement has unusual power. For example:. .. code-block:: text. class C <int x> {; int Y = x;; int Yplus1 = !add(Y, 1);; int xplus1 = !add(x, 1);; }. let Y = 10 in {; def rec1 : C<5> {; }; }. def rec2 : C<5> {; let Y = 10;; }. In both cases, one where a top-level ``let`` is used to bind ``Y`` and one; where a local ``let`` does the same thing, the results are:. .. code-block:: text. def rec1 { // C; int Y = 10;; int Yplus1 = 11;; int xplus1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:53791,inherit,inherited,53791,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inherited']
Modifiability,"lobal, which must be a; power of 2. If not present, or if the alignment is set to zero, the; alignment of the global is set by the target to whatever it feels; convenient. If an explicit alignment is specified, the global is forced; to have exactly that alignment. Targets and optimizers are not allowed; to over-align the global if the global has an assigned section. In this; case, the extra alignment could be observable: for example, code could; assume that the globals are densely packed in their section and try to; iterate over them as an array, alignment padding would break this; iteration. For TLS variables, the module flag ``MaxTLSAlign``, if present,; limits the alignment to the given value. Optimizers are not allowed to; impose a stronger alignment on these variables. The maximum alignment; is ``1 << 32``. For global variable declarations, as well as definitions that may be; replaced at link time (``linkonce``, ``weak``, ``extern_weak`` and ``common``; linkage types), the allocation size and alignment of the definition it resolves; to must be greater than or equal to that of the declaration or replaceable; definition, otherwise the behavior is undefined. Globals can also have a :ref:`DLL storage class <dllstorageclass>`,; an optional :ref:`runtime preemption specifier <runtime_preemption_model>`,; an optional :ref:`global attributes <glattrs>` and; an optional list of attached :ref:`metadata <metadata>`. Variables and aliases can have a; :ref:`Thread Local Storage Model <tls_model>`. Globals cannot be or contain :ref:`Scalable vectors <t_vector>` because their; size is unknown at compile time. They are allowed in structs to facilitate; intrinsics returning multiple values. Generally, structs containing scalable; vectors are not considered ""sized"" and cannot be used in loads, stores, allocas,; or GEPs. The only exception to this rule is for structs that contain scalable; vectors of the same type (e.g. ``{<vscale x 2 x i32>, <vscale x 2 x i32>}``; contains the sa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:35265,variab,variable,35265,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"lobalRefs[GlobalRefsSize];; };. - **Signature** - Unknown. In practice only the value of ``4`` has been; observed. It is hypothesized that this value corresponds to the set of; ``CV_SIGNATURE_xx`` defines in ``cvinfo.h``, with the value of ``4``; meaning that this module has C13 line information (as opposed to C11 line; information). A corollary of this is that we expect to only ever see; C13 line info, and that we do not understand the format of C11 line info. - **Symbols** - The :ref:`CodeView Symbol Substream <modi_symbol_substream>`.; ``SymbolSize`` is equal to the value of ``SymByteSize`` for the; corresponding module's entry in the :ref:`Module Info Substream; <dbi_mod_info_substream>` of the :doc:`DBI Stream <DbiStream>`. - **C11LineInfo** - A block containing CodeView line information in C11; format. ``C11Size`` is equal to the value of ``C11ByteSize`` from the; :ref:`Module Info Substream <dbi_mod_info_substream>` of the; :doc:`DBI Stream <DbiStream>`. If this value is ``0``, then C11 line; information is not present. As mentioned previously, the format of; C11 line info is not understood and we assume all line in modern PDBs; to be in C13 format. - **C13LineInfo** - A block containing CodeView line information in C13; format. ``C13Size`` is equal to the value of ``C13ByteSize`` from the; :ref:`Module Info Substream <dbi_mod_info_substream>` of the; :doc:`DBI Stream <DbiStream>`. If this value is ``0``, then C13 line; information is not present. - **GlobalRefs** - The meaning of this substream is not understood. .. _modi_symbol_substream:. The CodeView Symbol Substream; =============================. The CodeView Symbol Substream. This is an array of variable length; records describing the functions, variables, inlining information,; and other symbols defined in the compiland. The entire array consumes; ``SymbolSize-4`` bytes. The format of a CodeView Symbol Record (and; thusly, an array of CodeView Symbol Records) is described in; :doc:`CodeViewSymbols`.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/ModiStream.rst:2763,variab,variable,2763,interpreter/llvm-project/llvm/docs/PDB/ModiStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/ModiStream.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"local operation; that's initiated when the user selects a single switch. The second rule will; describe a global operation that works across translation units and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then analyze; the selection and other options passed to the refactoring action, and will pick; the most appropriate rule for the given selection and other options. Rule Types; ^^^^^^^^^^. Clang's refactoring engine supports several different refactoring rules:. - ``SourceChangeRefactoringRule`` produces source replacements that are applied; to the source files. Subclasses that choose to implement this rule have to; implement the ``createSourceReplacements`` member function. This type of; rule is typically used to implement local refactorings that transform the; source in one translation unit only. - ``FindSymbolOccurrencesRefactoringRule`` produces a ""partial"" refactoring; result: a set of occurrences that refer to a particular symbol. This type; of rule is typically used to implement an interactive renaming action that; allows users to specify which occurrences should be renamed during the; refactoring. Subclasses that choose to implement this rule have to implement; the ``findSymbolOccurrences`` member function. The following set of quick checks might help if you are unsure about the type; of rule you should use:. #. If you would like to transform the source in one translation unit and if; you don't need any cross-TU information, then the; ``SourceChangeRefactoringRule`` should work for you. #. If you would like to implement a rename-like operation with potential; interactive components, then ``FindSymbolOccurrencesRefactoringRule`` might; work for you. How to Create a Rule; ^^^^^^^^^^^^^^^^^^^^. Once you determine which type of rule is suitable for your needs you can; implement the refactoring by subclassing the rule and implementing its; inter",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:4147,refactor,refactoring,4147,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['refactor'],['refactoring']
Modifiability,"location list expression E' matches a single location list; entry with operation expression E, the same as the ``exprloc`` case and; evaluate on the same stack. But this is not attractive as if the attribute is for a variable that; happens to end with a non-singleton stack, it will not simply put a; location description on the stack. Presumably the intent of using; ``DW_OP_call*`` on a variable or formal parameter debugger information; entry is to push just one location description on the stack. That; location description may have more than one single location description. The previous rule for ``exprloc`` also has the same problem, as normally; a variable or formal parameter location expression may leave multiple; entries on the stack and only return the top entry. GDB implements ``DW_OP_call*`` by always executing E on the same stack.; If the location list has multiple matching entries, it simply picks the; first one and ignores the rest. This seems fundamentally at odds with; the desire to support multiple places for variables. So, it feels like ``DW_OP_call*`` should both support pushing a location; description on the stack for a variable or formal parameter, and also; support being able to execute an operation expression on the same stack.; Being able to specify a different operation expression for different; program locations seems a desirable feature to retain. A solution to that is to have a distinct ``DW_AT_LLVM_proc`` attribute; for the ``DW_TAG_dwarf_procedure`` debugging information entry. Then the; ``DW_AT_location`` attribute expression is always executed separately; and pushes a location description (that may have multiple single; location descriptions), and the ``DW_AT_LLVM_proc`` attribute expression; is always executed on the same stack and can leave anything on the; stack. The ``DW_AT_LLVM_proc`` attribute could have the new classes; ``exprproc``, ``loclistproc``, and ``loclistsptrproc`` to indicate that; the expression is executed on the same sta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:77660,variab,variables,77660,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variables']
Modifiability,"lock:: c++. #include ""B/A.h""; #include ""A/B.h""; #include ""a/b.h""; #include ""A/b.h""; #include ""B/a.h"". * ``SI_CaseSensitive`` (in configuration: ``CaseSensitive``); Includes are sorted in an ASCIIbetical or case sensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""B/A.h""; #include ""B/a.h""; #include ""a/b.h"". * ``SI_CaseInsensitive`` (in configuration: ``CaseInsensitive``); Includes are sorted in an alphabetical or case insensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""a/b.h""; #include ""B/A.h""; #include ""B/a.h"". .. _SortJavaStaticImport:. **SortJavaStaticImport** (``SortJavaStaticImportOptions``) :versionbadge:`clang-format 12` :ref:`¶ <SortJavaStaticImport>`; When sorting Java imports, by default static imports are placed before; non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,; static imports are placed after non-static imports. Possible values:. * ``SJSIO_Before`` (in configuration: ``Before``); Static imports are placed before non-static imports. .. code-block:: java. import static org.example.function1;. import org.example.ClassA;. * ``SJSIO_After`` (in configuration: ``After``); Static imports are placed after non-static imports. .. code-block:: java. import org.example.ClassA;. import static org.example.function1;. .. _SortUsingDeclarations:. **SortUsingDeclarations** (``SortUsingDeclarationsOptions``) :versionbadge:`clang-format 5` :ref:`¶ <SortUsingDeclarations>`; Controls if and how clang-format will sort using declarations. Possible values:. * ``SUD_Never`` (in configuration: ``Never``); Using declarations are never sorted. .. code-block:: c++. using std::chrono::duration_cast;; using std::move;; using boost::regex;; using boost::regex_constants::icase;; using std::string;. * ``SUD_Lexicographic`` (in configuration: ``Lexicographic``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. Sort; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:110264,config,configuration,110264,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"lock:: c++. A; -> x;; A(); -> y;; A(z); -> z;; A(a, b); // will not be expanded. .. _MaxEmptyLinesToKeep:. **MaxEmptyLinesToKeep** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <MaxEmptyLinesToKeep>`; The maximum number of consecutive empty lines to keep. .. code-block:: c++. MaxEmptyLinesToKeep: 1 vs. MaxEmptyLinesToKeep: 0; int f() { int f() {; int = 1; int i = 1;; i = foo();; i = foo(); return i;; }; return i;; }. .. _NamespaceIndentation:. **NamespaceIndentation** (``NamespaceIndentationKind``) :versionbadge:`clang-format 3.7` :ref:`¶ <NamespaceIndentation>`; The indentation used for namespaces. Possible values:. * ``NI_None`` (in configuration: ``None``); Don't indent in namespaces. .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. * ``NI_Inner`` (in configuration: ``Inner``); Indent only in inner namespaces (nested in other namespaces). .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. * ``NI_All`` (in configuration: ``All``); Indent in all namespaces. .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. .. _NamespaceMacros:. **NamespaceMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <NamespaceMacros>`; A vector of macros which are used to open namespace blocks. These are expected to be macros of the form:. .. code-block:: c++. NAMESPACE(<namespace-name>, ...) {; <namespace-content>; }. For example: TESTSUITE. .. _ObjCBinPackProtocolList:. **ObjCBinPackProtocolList** (``BinPackStyle``) :versionbadge:`clang-format 7` :ref:`¶ <ObjCBinPackProtocolList>`; Controls bin-packing Objective-C protocol conformance list; items into as few lines as possible when they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; protocol conformance list items into as few lines as possible; whenever they go over ``ColumnLimit``. If ``Always``, always bin-packs Objective-C protocol conf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:87486,config,configuration,87486,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"lock:: c++. STACK_OF(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. TypenameMacros: ['STACK_OF', 'LIST']. For example: OpenSSL STACK_OF, BSD LIST_ENTRY. .. _UseCRLF:. **UseCRLF** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <UseCRLF>`; This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``. .. _UseTab:. **UseTab** (``UseTabStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <UseTab>`; The way to use tab characters in the resulting file. Possible values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:. **WhitespaceSensitiveMacros** (``List of Strings``) :versionbadge:`clang-format 11` :ref:`¶ <WhitespaceSensitiveMacros>`; A vector of macros which are whitespace-sensitive and should not; be touched. These are expected to be macros of the form:. .. code-block:: c++. STRINGIZE(...). In the .clang-format configuration file, this can be configured like:. .",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:132516,config,configuration,132516,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"lock; `myblock`. It is usually possible to drop the `.myblock` reference and simply; use `bb.42`. - If there are no memory operands or blocks referencing the IR then the; IR function can be replaced by a parameterless dummy function like; `define @func() { ret void }`. - It is possible to drop the whole IR section of the MIR file if it only; contains dummy functions (see above). The .mir loader will create the; IR functions automatically in this case. .. _limitations:. Limitations; -----------. Currently the MIR format has several limitations in terms of which state it; can serialize:. - The target-specific state in the target-specific ``MachineFunctionInfo``; subclasses isn't serialized at the moment. - The target-specific ``MachineConstantPoolValue`` subclasses (in the ARM and; SystemZ backends) aren't serialized at the moment. - The ``MCSymbol`` machine operands don't support temporary or local symbols. - A lot of the state in ``MachineModuleInfo`` isn't serialized - only the CFI; instructions and the variable debug information from MMI is serialized right; now. These limitations impose restrictions on what you can test with the MIR format.; For now, tests that would like to test some behaviour that depends on the state; of temporary or local ``MCSymbol`` operands or the exception handling state in; MMI, can't use the MIR format. As well as that, tests that test some behaviour; that depends on the state of the target specific ``MachineFunctionInfo`` or; ``MachineConstantPoolValue`` subclasses can't use the MIR format at the moment. High Level Structure; ====================. .. _embedded-module:. Embedded Module; ---------------. When the first YAML document contains a `YAML block literal string`_, the MIR; parser will treat this string as an LLVM assembly language string that; represents an embedded LLVM IR module.; Here is an example of a YAML document that contains an LLVM module:. .. code-block:: llvm. define i32 @inc(i32* %x) {; entry:; %0 = load i32, i32* %",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:5820,variab,variable,5820,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['variab'],['variable']
Modifiability,"lock_byref`` heap data structure. For example,. .. code-block:: c++. __block FOO blockStorageFoo;. requires the normal constructor for the embedded ``blockStorageFoo`` object:. .. code-block:: c++. FOO_ctor(& _block_byref_blockStorageFoo->blockStorageFoo);. and at scope termination the destructor:. .. code-block:: c++. FOO_dtor(& _block_byref_blockStorageFoo->blockStorageFoo);. Note that the forwarding indirection is *NOT* used. The compiler would need to generate (if used from a block literal) the following; copy/dispose helpers:. .. code-block:: c++. void _block_byref_obj_keep(struct _block_byref_blockStorageFoo *dst, struct _block_byref_blockStorageFoo *src) {; FOO_ctor(&dst->blockStorageFoo, &src->blockStorageFoo);; }. void _block_byref_obj_dispose(struct _block_byref_blockStorageFoo *src) {; FOO_dtor(&src->blockStorageFoo);; }. for the appropriately named constructor and destructor for the class/struct; ``FOO``. To support member variable and function access the compiler will synthesize a; ``const`` pointer to a block version of the ``this`` pointer. .. _RuntimeHelperFunctions:. Runtime Helper Functions; ========================. The runtime helper functions are described in; ``/usr/local/include/Block_private.h``. To summarize their use, a ``Block``; requires copy/dispose helpers if it imports any block variables, ``__block``; storage variables, ``__attribute__((NSObject))`` variables, or C++ ``const``; copied objects with constructor/destructors. The (1<<26) bit is set and; functions are generated. The block copy helper function should, for each of the variables of the type; mentioned above, call:. .. code-block:: c. _Block_object_assign(&dst->target, src->target, BLOCK_FIELD_<apropos>);. in the copy helper and:. .. code-block:: c. _Block_object_dispose(->target, BLOCK_FIELD_<apropos>);. in the dispose helper where ``<apropos>`` is:. .. code-block:: c. enum {; BLOCK_FIELD_IS_OBJECT = 3, // id, NSObject, __attribute__((NSObject)), block, ...; BLOCK_FIELD_IS_BLO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:27498,variab,variable,27498,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variable']
Modifiability,"lock_copy()``; performed upon them the underlying storage for the variables may move to the; heap. In Objective-C Garbage Collection Only compilation environments the heap; used is the garbage collected one and no further action is required. Otherwise; the compiler must issue a call to potentially release any heap storage for; ``__block`` variables at all escapes or terminations of their scope. The call; should be:. .. code-block:: c. _Block_object_dispose(&_block_byref_foo, BLOCK_FIELD_IS_BYREF);. Nesting; ^^^^^^^. ``Blocks`` may contain ``Block`` literal expressions. Any variables used within; inner blocks are imported into all enclosing ``Block`` scopes even if the; variables are not used. This includes ``const`` imports as well as ``__block``; variables. Objective C Extensions to ``Blocks``; ====================================. Importing Objects; -----------------. Objects should be treated as ``__attribute__((NSObject))`` variables; all; ``copy_helper``, ``dispose_helper``, ``byref_keep``, and ``byref_dispose``; helper functions should use ``_Block_object_assign`` and; ``_Block_object_dispose``. There should be no code generated that uses; ``*-retain`` or ``*-release`` methods. ``Blocks`` as Objects; ---------------------. The compiler will treat ``Blocks`` as objects when synthesizing property setters; and getters, will characterize them as objects when generating garbage; collection strong and weak layout information in the same manner as objects, and; will issue strong and weak write-barrier assignments in the same manner as; objects. ``__weak __block`` Support; --------------------------. Objective-C (and Objective-C++) support the ``__weak`` attribute on ``__block``; variables. Under normal circumstances the compiler uses the Objective-C runtime; helper support functions ``objc_assign_weak`` and ``objc_read_weak``. Both; should continue to be used for all reads and writes of ``__weak __block``; variables:. .. code-block:: c. objc_read_weak(&block->byref_i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:18747,variab,variables,18747,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability,"logic is; defined by *test suites*. TEST SUITES; ~~~~~~~~~~~. As described in :ref:`test-discovery`, tests are always located inside a *test; suite*. Test suites serve to define the format of the tests they contain, the; logic for finding those tests, and any additional information to run the tests. :program:`lit` identifies test suites as directories containing ``lit.cfg`` or; ``lit.site.cfg`` files (see also :option:`--config-prefix`). Test suites are; initially discovered by recursively searching up the directory hierarchy for; all the input files passed on the command line. You can use; :option:`--show-suites` to display the discovered test suites at startup. Once a test suite is discovered, its config file is loaded. Config files; themselves are Python modules which will be executed. When the config file is; executed, two important global variables are predefined:. **lit_config**. The global **lit** configuration object (a *LitConfig* instance), which defines; the builtin test formats, global configuration parameters, and other helper; routines for implementing test configurations. **config**. This is the config object (a *TestingConfig* instance) for the test suite,; which the config file is expected to populate. The following variables are also; available on the *config* object, some of which must be set by the config and; others are optional or predefined:. **name** *[required]* The name of the test suite, for use in reports and; diagnostics. **test_format** *[required]* The test format object which will be used to; discover and run tests in the test suite. Generally this will be a builtin test; format available from the *lit.formats* module. **test_source_root** The filesystem path to the test suite root. For out-of-dir; builds this is the directory that will be scanned for tests. **test_exec_root** For out-of-dir builds, the path to the test suite root inside; the object directory. This is where tests will be run and temporary output files; placed. **enviro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:15028,config,configuration,15028,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,3,['config'],"['configuration', 'configurations']"
Modifiability,"logic or if you care that you're calling some; *particular* constructor. Those should look like function calls using; parentheses rather than like aggregate initialization. Similarly, if you need; to explicitly name the type and call its constructor to create a temporary,; don't use a braced initializer list. Instead, use a braced initializer list; (without any type for temporaries) when doing aggregate initialization or; something notionally equivalent. Examples:. .. code-block:: c++. class Foo {; public:; // Construct a Foo by reading data from the disk in the whizbang format, ...; Foo(std::string filename);. // Construct a Foo by looking up the Nth element of some global data ...; Foo(int N);. // ...; };. // The Foo constructor call is reading a file, don't use braces to call it.; std::fill(foo.begin(), foo.end(), Foo(""name""));. // The pair is being constructed like an aggregate, use braces.; bar_map.insert({my_key, my_value});. If you use a braced initializer list when initializing a variable, use an equals before the open curly brace:. .. code-block:: c++. int data[] = {0, 1, 2, 3};. Use ``auto`` Type Deduction to Make Code More Readable; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Some are advocating a policy of ""almost always ``auto``"" in C++11, however LLVM; uses a more moderate stance. Use ``auto`` if and only if it makes the code more; readable or easier to maintain. Don't ""almost always"" use ``auto``, but do use; ``auto`` with initializers like ``cast<Foo>(...)`` or other places where the; type is already obvious from the context. Another time when ``auto`` works well; for these purposes is when the type would have been abstracted away anyways,; often behind a container's typedef such as ``std::vector<T>::iterator``. Similarly, C++14 adds generic lambda expressions where parameter types can be; ``auto``. Use these where you would have used a template. Beware unnecessary copies with ``auto``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The convenie",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:26195,variab,variable,26195,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['variab'],['variable']
Modifiability,"lons.; getNextToken();; break;; case tok_def:; HandleDefinition();; break;; case tok_extern:; HandleExtern();; break;; default:; HandleTopLevelExpression();; break;; }; }; }. The most interesting part of this is that we ignore top-level; semicolons. Why is this, you ask? The basic reason is that if you type; ""4 + 5"" at the command line, the parser doesn't know whether that is the; end of what you will type or not. For example, on the next line you; could type ""def foo..."" in which case 4+5 is the end of a top-level; expression. Alternatively you could type ""\* 6"", which would continue; the expression. Having top-level semicolons allows you to type ""4+5;"",; and the parser will know you are done. Conclusions; ===========. With just under 400 lines of commented code (240 lines of non-comment,; non-blank code), we fully defined our minimal language, including a; lexer, parser, and AST builder. With this done, the executable will; validate Kaleidoscope code and tell us if it is grammatically invalid.; For example, here is a sample interaction:. .. code-block:: bash. $ ./a.out; ready> def foo(x y) x+foo(y, 4.0);; Parsed a function definition.; ready> def foo(x y) x+y y;; Parsed a function definition.; Parsed a top-level expr; ready> def foo(x y) x+y );; Parsed a function definition.; Error: unknown token when expecting an expression; ready> extern sin(a);; ready> Parsed an extern; ready> ^D; $. There is a lot of room for extension here. You can define new AST nodes,; extend the language in many ways, etc. In the `next; installment <LangImpl03.html>`_, we will describe how to generate LLVM; Intermediate Representation (IR) from the AST. Full Code Listing; =================. Here is the complete code listing for our running example. .. code-block:: bash. # Compile; clang++ -g -O3 toy.cpp; # Run; ./a.out. Here is the code:. .. literalinclude:: ../../../examples/Kaleidoscope/Chapter2/toy.cpp; :language: c++. `Next: Implementing Code Generation to LLVM IR <LangImpl03.html>`_. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:25053,extend,extend,25053,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['extend'],['extend']
Modifiability,"loop (15 mins) after client disconnectionsAvoid potential deadlocks when trying to remove a node from a clusterCorrect matching of incoming connection with previously dropped connectionCorrect export of cluster identificationCorrectly propagate information about files that could not be stagedPrevent endsess deadlock when parallel streams stall due to large WAN RTTFix infinite wait for primary login that will never; happen if you are a manager without a meta-managerPrevent annoying (but not deadly) infinite loop should a; server go offline that is subject to a locate request display.Client sideBetter handling of errno, especially for parallel streamsAllow the client to cycle through all the remaining valid security protocols in the list of protocols returned by the serverMake the readahead strategy more conservativeFix a rare race condition happening when destroying instances with outstanding open requestsEnforce cache coherency in the case of reads+writes in the same fileCorrectly guess the filesize of a file opened for writing in sync modeMake server host name check more flexible for GSI authenticationFix some relevant issues with cache handling on the client, including a rare but fatal bug in; determining the cache holes list and the end of a cache lookupMore complete detection of async read errorsGeneralFix problem in handling the return code; of X509_REQ_verify; in XrdCryptosslX509Req.ccAvoid SEGV when doing an lsd admin command with; authenticated xrootd clientsClose race conditions that allowed a supervisor/manager; to subscribe without declaring a data port. Initialize nostage state in; XrdCmsState to prevent erroneous state declaration during; initialization.Fix a problem with the subject name of proxies of level; > 1; this was creating a failure when a Globus application was; trying to use the proxy certificateFix a problem with cache refreshing in XrdSutCache; affecting automatic reloading of password filesFor now, turn off IPV6 processing as it seems to cr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v524/index.html:2416,flexible,flexible,2416,net/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v524/index.html,2,['flexible'],['flexible']
Modifiability,"low and instruction referencing debug info, corresponding to the earlier; LLVM IR:. ```text; %2:gr32 = ADD32rr %0, %1, implicit-def $eflags, debug-instr-number 1; DBG_INSTR_REF 1, 0, !123, !456, debug-location !789; ```. While the function remains in SSA form, virtual register `%2` is sufficient to; identify the value computed by the instruction -- however the function; eventually leaves SSA form, and register optimisations will obscure which; register the desired value is in. Instead, a more consistent way of identifying; the instruction's value is to refer to the `MachineOperand` where the value is; defined: independently of which register is defined by that `MachineOperand`. In; the code above, the `DBG_INSTR_REF` instruction refers to instruction number; one, operand zero, while the `ADD32rr` has a `debug-instr-number` attribute; attached indicating that it is instruction number one. De-coupling variable locations from registers avoids difficulties involving; register allocation and optimisation, but requires additional instrumentation; when the instructions are optimised instead. Optimisations that replace; instructions with optimised versions that compute the same value must either; preserve the instruction number, or record a substitution from the old; instruction / operand number pair to the new instruction / operand pair -- see; `MachineFunction::substituteDebugValuesForInst`. If debug info maintenance is; not performed, or an instruction is eliminated as dead code, the variable; location is safely dropped and marked ""optimised out"". The exception is; instructions that are mutated rather than replaced, which always need debug info; maintenance. # Register allocator considerations. When the register allocator runs, debugging instructions do not directly refer; to any virtual registers, and thus there is no need for expensive location; maintenance during regalloc (i.e. `LiveDebugVariables`). Debug instructions are; unlinked from the function, then linked back ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md:2410,coupling,coupling,2410,interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,2,"['coupling', 'variab']","['coupling', 'variable']"
Modifiability,"lp improve the user experience, by allowing; conversion to a desired 'to' type, when the 'from' type is unknown or unclear. Significance of this Feature; ----------------------------. The 'Value' object enables wrapping a memory region that comes from the; JIT, and bringing it back to the compiled code (and vice versa).; This is a very useful functionality when:. - connecting an interpreter to the compiled code, or; - connecting an interpreter in another language. For example, this feature helps transport values across boundaries. A notable; example is the cppyy project code makes use of this feature to enable running C++; within Python. It enables transporting values/information between C++; and Python. Note: `cppyy <https://github.com/wlav/cppyy/>`_ is an automatic, run-time,; Python-to-C++ bindings generator, for calling C++ from Python and Python from C++.; It uses LLVM along with a C++ interpreter (e.g., Cling) to enable features like; run-time instantiation of C++ templates, cross-inheritance, callbacks,; auto-casting, transparent use of smart pointers, etc. In a nutshell, this feature enables a new way of developing code, paving the; way for language interoperability and easier interactive programming. Implementation Details; ======================. Interpreter as a REPL vs. as a Library; --------------------------------------. 1 - If we're using the interpreter in interactive (REPL) mode, it will dump; the value (i.e., value printing). .. code-block:: console. if (LastValue.isValid()) {; if (!V) {; LastValue.dump();; LastValue.clear();; } else; *V = std::move(LastValue);; }. 2 - If we're using the interpreter as a library, then it will pass the value; to the user. Incremental AST Consumer; ------------------------. The ``IncrementalASTConsumer`` class wraps the original code generator; ``ASTConsumer`` and it performs a hook, to traverse all the top-level decls, to; look for expressions to synthesize, based on the ``isSemiMissing()`` condition. If this conditi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:11167,inherit,inheritance,11167,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['inherit'],['inheritance']
Modifiability,"ls, with CMake your build type is defined at configuration.; If you want to change your build type, you can re-run cmake with the following; invocation:. .. code-block:: console. % cmake -G ""Unix Makefiles"" -DCMAKE_BUILD_TYPE=<type> SRC_ROOT. Between runs, CMake preserves the values set for all options. CMake has the; following build types defined:. Debug. These builds are the default. The build system will compile the tools and; libraries unoptimized, with debugging information, and asserts enabled. Release. For these builds, the build system will compile the tools and libraries; with optimizations enabled and not generate debug info. CMakes default; optimization level is -O3. This can be configured by setting the; ``CMAKE_CXX_FLAGS_RELEASE`` variable on the CMake command line. RelWithDebInfo. These builds are useful when debugging. They generate optimized binaries with; debug information. CMakes default optimization level is -O2. This can be; configured by setting the ``CMAKE_CXX_FLAGS_RELWITHDEBINFO`` variable on the; CMake command line. Once you have LLVM configured, you can build it by entering the *OBJ_ROOT*; directory and issuing the following command:. .. code-block:: console. % make. If the build fails, please `check here`_ to see if you are using a version of; GCC that is known not to compile LLVM. If you have multiple processors in your machine, you may wish to use some of the; parallel build options provided by GNU Make. For example, you could use the; command:. .. code-block:: console. % make -j2. There are several special targets which are useful when working with the LLVM; source code:. ``make clean``. Removes all files generated by the build. This includes object files,; generated C/C++ files, libraries, and executables. ``make install``. Installs LLVM header files, libraries, tools, and documentation in a hierarchy; under ``$PREFIX``, specified with ``CMAKE_INSTALL_PREFIX``, which; defaults to ``/usr/local``. ``make docs-llvm-html``. If configured wi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:29476,config,configured,29476,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,2,"['config', 'variab']","['configured', 'variable']"
Modifiability,"ls. This method takes two call sites (``CS1``; & ``CS2``), returns ``NoModRef`` if neither call writes to memory read or; written by the other, ``Ref`` if ``CS1`` reads memory written by ``CS2``,; ``Mod`` if ``CS1`` writes to memory read or written by ``CS2``, or ``ModRef`` if; ``CS1`` might read or write memory written to by ``CS2``. Note that this; relation is not commutative. Other useful ``AliasAnalysis`` methods; --------------------------------------. Several other tidbits of information are often collected by various alias; analysis implementations and can be put to good use by various clients. The ``getModRefInfoMask`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``getModRefInfoMask`` method returns a bound on Mod/Ref information for; the supplied pointer, based on knowledge about whether the pointer points to; globally-constant memory (for which it returns ``NoModRef``) or; locally-invariant memory (for which it returns ``Ref``). Globally-constant; memory includes functions, constant global variables, and the null pointer.; Locally-invariant memory is memory that we know is invariant for the lifetime; of its SSA value, but not necessarily for the life of the program: for example,; the memory pointed to by ``readonly`` ``noalias`` parameters is known-invariant; for the duration of the corresponding function call. Given Mod/Ref information; ``MRI`` for a memory location ``Loc``, ``MRI`` can be refined with a statement; like ``MRI &= AA.getModRefInfoMask(Loc);``. Another useful idiom is; ``isModSet(AA.getModRefInfoMask(Loc))``; this checks to see if the given; location can be modified at all. For convenience, there is also a method; ``pointsToConstantMemory(Loc)``; this is synonymous with; ``isNoModRef(AA.getModRefInfoMask(Loc))``. .. _never access memory or only read memory:. The ``doesNotAccessMemory`` and ``onlyReadsMemory`` methods; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These methods are used to provide very simple mod/ref informati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:7398,variab,variables,7398,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['variab'],['variables']
Modifiability,ls/TableGen; - `22`; - `3`; - `19`; - :part:`13%`; * - clang-tools-extra/clang-apply-replacements/include/clang-apply-replacements/Tooling; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-apply-replacements/lib/Tooling; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-apply-replacements/tool; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-change-namespace; - `2`; - `0`; - `2`; - :none:`0%`; * - clang-tools-extra/clang-change-namespace/tool; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clang-doc; - `17`; - `16`; - `1`; - :part:`94%`; * - clang-tools-extra/clang-doc/tool; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-include-fixer; - `13`; - `8`; - `5`; - :part:`61%`; * - clang-tools-extra/clang-include-fixer/find-all-symbols; - `17`; - `13`; - `4`; - :part:`76%`; * - clang-tools-extra/clang-include-fixer/find-all-symbols/tool; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clang-include-fixer/plugin; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-include-fixer/tool; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clang-move; - `4`; - `1`; - `3`; - :part:`25%`; * - clang-tools-extra/clang-move/tool; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-query; - `5`; - `4`; - `1`; - :part:`80%`; * - clang-tools-extra/clang-query/tool; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clang-reorder-fields; - `2`; - `1`; - `1`; - :part:`50%`; * - clang-tools-extra/clang-reorder-fields/tool; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clang-tidy; - `20`; - `14`; - `6`; - :part:`70%`; * - clang-tools-extra/clang-tidy/abseil; - `42`; - `31`; - `11`; - :part:`73%`; * - clang-tools-extra/clang-tidy/altera; - `11`; - `9`; - `2`; - :part:`81%`; * - clang-tools-extra/clang-tidy/android; - `33`; - `23`; - `10`; - :part:`69%`; * - clang-tools-extra/clang-tidy/boost; - `3`; - `3`; - `0`; - :good:`100%`; * - clang-tools-extra/clang-tidy,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:15874,plugin,plugin,15874,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['plugin'],['plugin']
Modifiability,"ls/gui/guitest.C`; contains the complete source code. ![Widgets created by ROOT GUI classes](pictures/02000204.jpg). Any custom widget can be created by sub classing existing widgets. To; achieve a better understanding of the widgets' properties they are; separated by their type and their inheritance. As all of them inherit; from **`TGObject`** and most from **`TGWidget`**, these base classes are; described first. ### TGObject. **`TGObject`** is the base class for all ROOT GUI classes. It inherits; from **`TObject`**. The two data members of this class contain important; information about X11/Win32 window identifier and the connection to the; host's graphics system. Every GUI element, which derives from; **`TGObject`** has access to the **`TGClient`** via the data member; `fClient` of **`TGObject. TGClient`** creates the connection with the; host's graphics system and sets up the complete graphics system for all; widgets. ### TGWidget. The widgets base class **`TGWidget`** is typically used as a mix-in; class via multiple inheritances. Its properties are available for all; deriving widgets: **`TGButton`**, **`TGComboBox`**, **`TGTab`**,; **`TGColorPalette`**, **`TGColorPick`**, **`TGDoubleSlider`**,; **`TGListTree`**, **`TGNumberEntry`**, **`TGScrollBar`**,; **`TGShutterItem`**, **`TGTextEntry`**, **`TGSlider`**, **`TGListBox`**,; **`TGView.`**. This class has four data members keeping information about the widget id; - important for event processing, the window which handles the widget's; events, the widget status flags and the assigned command (if there is; any). The general properties of **`TGWidget`** are specified by; `SetFlags(Int_t flags)` and `ClearFlags(Int_t flags)` methods. The; status flags are: `kWidgetWantFocus`, `kWidgetHasFocus`, and; `kWidgetIsEnabled`. The method `Associate(const TGWindow* w)` - sets the; window which handles the widget events.; `SetCommand(const char* command)` - sets the command to be executed. The; command string can be gatherin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:21564,inherit,inheritances,21564,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['inherit'],['inheritances']
Modifiability,"lse statement. .. code-block:: c++. // Create the ""after loop"" block and insert it.; BasicBlock *LoopEndBB = Builder->GetInsertBlock();; BasicBlock *AfterBB =; BasicBlock::Create(*TheContext, ""afterloop"", TheFunction);. // Insert the conditional branch into the end of LoopEndBB.; Builder->CreateCondBr(EndCond, LoopBB, AfterBB);. // Any new code will be inserted in AfterBB.; Builder->SetInsertPoint(AfterBB);. With the code for the body of the loop complete, we just need to finish; up the control flow for it. This code remembers the end block (for the; phi node), then creates the block for the loop exit (""afterloop""). Based; on the value of the exit condition, it creates a conditional branch that; chooses between executing the loop again and exiting the loop. Any; future code is emitted in the ""afterloop"" block, so it sets the; insertion position to it. .. code-block:: c++. // Add a new entry to the PHI node for the backedge.; Variable->addIncoming(NextVar, LoopEndBB);. // Restore the unshadowed variable.; if (OldVal); NamedValues[VarName] = OldVal;; else; NamedValues.erase(VarName);. // for expr always returns 0.0.; return Constant::getNullValue(Type::getDoubleTy(*TheContext));; }. The final code handles various cleanups: now that we have the ""NextVar""; value, we can add the incoming value to the loop PHI node. After that,; we remove the loop variable from the symbol table, so that it isn't in; scope after the for loop. Finally, code generation of the for loop; always returns 0.0, so that is what we return from; ``ForExprAST::codegen()``. With this, we conclude the ""adding control flow to Kaleidoscope"" chapter; of the tutorial. In this chapter we added two control flow constructs,; and used them to motivate a couple of aspects of the LLVM IR that are; important for front-end implementors to know. In the next chapter of our; saga, we will get a bit crazier and add `user-defined; operators <LangImpl06.html>`_ to our poor innocent language. Full Code Listing; ==========",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:25764,variab,variable,25764,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['variab'],['variable']
Modifiability,"lse { else if (c); if (c) { d();; d(); else; } else { e();; e();; }; }. .. _RemoveParentheses:. **RemoveParentheses** (``RemoveParenthesesStyle``) :versionbadge:`clang-format 17` :ref:`¶ <RemoveParentheses>`; Remove redundant parentheses. .. warning::. Setting this option to any value other than ``Leave`` could lead to; incorrect code formatting due to clang-format's lack of complete semantic; information. As such, extra care should be taken to review code changes; made by this option. Possible values:. * ``RPS_Leave`` (in configuration: ``Leave``); Do not remove parentheses. .. code-block:: c++. class __declspec((dllimport)) X {};; co_return (((0)));; return ((a + b) - ((c + d)));. * ``RPS_MultipleParentheses`` (in configuration: ``MultipleParentheses``); Replace multiple parentheses with single parentheses. .. code-block:: c++. class __declspec(dllimport) X {};; co_return (0);; return ((a + b) - (c + d));. * ``RPS_ReturnStatement`` (in configuration: ``ReturnStatement``); Also remove parentheses enclosing the expression in a; ``return``/``co_return`` statement. .. code-block:: c++. class __declspec(dllimport) X {};; co_return 0;; return (a + b) - (c + d);. .. _RemoveSemicolon:. **RemoveSemicolon** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <RemoveSemicolon>`; Remove semicolons after the closing brace of a non-empty function. .. warning::. Setting this option to ``true`` could lead to incorrect code formatting; due to clang-format's lack of complete semantic information. As such,; extra care should be taken to review code changes made by this option. .. code-block:: c++. false: true:. int max(int a, int b) { int max(int a, int b) {; return a > b ? a : b; return a > b ? a : b;; }; }. .. _RequiresClausePosition:. **RequiresClausePosition** (``RequiresClausePositionStyle``) :versionbadge:`clang-format 15` :ref:`¶ <RequiresClausePosition>`; The position of the ``requires`` clause. Possible values:. * ``RCPS_OwnLine`` (in configuration: ``OwnLine``); Always p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:103376,config,configuration,103376,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"lse − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). NCycles No 200 − Number of training cycles. HiddenLayers No N,N-1 − Specification of hidden layer architecture (N stands for number of variables; any integers may also be used). ValidationFraction No 0.5 − Fraction of events in training tree used for cross validation. LearningMethod No Stochastic Stochastic, Batch, SteepestDescent, RibierePolak, FletcherReeves, BFGS Learning method. Configuration options for setup and tuning of specific fitter :. Configuration options reference for fitting method: Simulated Annealing (SA). Option Array Default value Predefined values Description. MaxCalls No 100000 − Maximum number of minimisation calls. InitialTemp No 1e+06 − Initial temperature. MinTemp No 1e-06 − Mimimum temperature. Eps No 1e-10 − Epsilon. TempScale No 1 − Temperature scale. AdaptiveSpeed No 1 − Adaptive speed. TempAdaptiveStep No 0.009875 − Step made in each generation temperature adaptive. UseDefaultScale No False − Use default temperature scale for temperature minimisation algorithm. UseDefaultTemp No False − Use default initial temperature. KernelTemp No IncAdaptive IncAdaptive, DecAdaptive, Sqrt, Log, Sin, Homo, Geo Temperature minimisation algorithm. Configuration options for setup and tuning of specific fitter :. Configuration options reference for fitting method: Monte Carlo sampling (MC). Option Array Default value Predefined values Description. SampleSize No 100000 − Number of Monte Carlo events in toy sample. Sigma No -1 − If > 0: new points are generated according to Gauss around best value and with Sigma in units of interval length. Seed No 100 − Seed for the random generator (0 takes random seeds). Configuration options for setup and tuning of specific fitter :. Configuration options reference for fitting method: TMinuit (MT). Option Array Default value Predefined values Description. ErrorLevel No 1 − TMinuit: error level: 0.5=lo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:29619,adapt,adaptive,29619,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,2,['adapt'],['adaptive']
Modifiability,"lse:; a &= 2;; bbb = 2;. * ``bool AlignFunctionPointers`` Only for ``AlignConsecutiveDeclarations``. Whether function pointers are; aligned. .. code-block:: c++. true:; unsigned i;; int &r;; int *p;; int (*f)();. false:; unsigned i;; int &r;; int *p;; int (*f)();. * ``bool PadOperators`` Only for ``AlignConsecutiveAssignments``. Whether short assignment; operators are left-padded to the same length as long ones in order to; put all assignment operators to the right of the left hand side. .. code-block:: c++. true:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. false:; a >>= 2;; bbb = 2;. a = 2;; bbb >>= 2;. .. _AlignConsecutiveBitFields:. **AlignConsecutiveBitFields** (``AlignConsecutiveStyle``) :versionbadge:`clang-format 11` :ref:`¶ <AlignConsecutiveBitFields>`; Style of aligning consecutive bit fields. ``Consecutive`` will align the bitfield separators of consecutive lines.; This will result in formattings like:. .. code-block:: c++. int aaaa : 1;; int b : 12;; int ccc : 8;. Nested configuration flags:. Alignment options. They can also be read as a whole for compatibility. The choices are:; - None; - Consecutive; - AcrossEmptyLines; - AcrossComments; - AcrossEmptyLinesAndComments. For example, to align across empty lines and not across comments, either; of these work. .. code-block:: c++. AlignConsecutiveMacros: AcrossEmptyLines. AlignConsecutiveMacros:; Enabled: true; AcrossEmptyLines: true; AcrossComments: false. * ``bool Enabled`` Whether aligning is enabled. .. code-block:: c++. #define SHORT_NAME 42; #define LONGER_NAME 0x007f; #define EVEN_LONGER_NAME (2); #define foo(x) (x * x); #define bar(y, z) (y + z). int a = 1;; int somelongname = 2;; double c = 3;. int aaaa : 1;; int b : 12;; int ccc : 8;. int aaaa = 12;; float b = 23;; std::string ccc;. * ``bool AcrossEmptyLines`` Whether to align across empty lines. .. code-block:: c++. true:; int a = 1;; int somelongname = 2;; double c = 3;. int d = 3;. false:; int a = 1;; int somelongname = 2;; double c = 3;. int d = 3;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:11852,config,configuration,11852,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"lse; makes the test fail only if the last command in the pipe fails. **available_features** A set of features that can be used in `XFAIL`,; `REQUIRES`, and `UNSUPPORTED` directives. TEST DISCOVERY; ~~~~~~~~~~~~~~. Once test suites are located, :program:`lit` recursively traverses the source; directory (following *test_source_root*) looking for tests. When :program:`lit`; enters a sub-directory, it first checks to see if a nested test suite is; defined in that directory. If so, it loads that test suite recursively,; otherwise it instantiates a local test config for the directory (see; :ref:`local-configuration-files`). Tests are identified by the test suite they are contained within, and the; relative path inside that suite. Note that the relative path may not refer to; an actual file on disk; some test formats (such as *GoogleTest*) define; ""virtual tests"" which have a path that contains both the path to the actual; test file and a subpath to identify the virtual test. .. _local-configuration-files:. LOCAL CONFIGURATION FILES; ~~~~~~~~~~~~~~~~~~~~~~~~~. When :program:`lit` loads a subdirectory in a test suite, it instantiates a; local test configuration by cloning the configuration for the parent directory; --- the root of this configuration chain will always be a test suite. Once the; test configuration is cloned :program:`lit` checks for a *lit.local.cfg* file; in the subdirectory. If present, this file will be loaded and can be used to; specialize the configuration for each individual directory. This facility can; be used to define subdirectories of optional tests, or to change other; configuration parameters --- for example, to change the test format, or the; suffixes which identify test files. SUBSTITUTIONS; ~~~~~~~~~~~~~. :program:`lit` allows patterns to be substituted inside RUN commands. It also; provides the following base set of substitutions, which are defined in; TestRunner.py:. ======================= ==============; Macro Substitution; ================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:18199,config,configuration-files,18199,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['config'],['configuration-files']
Modifiability,"lso, a colon (``:``) and additional text may; follow ``// clang-format off`` or ``// clang-format on`` to explain why; clang-format is turned off or back on. .. code-block:: c++. int formatted_code;; // clang-format off; void unformatted_code ;; // clang-format on; void formatted_code_again;. Configuring Style in Code; =========================. When using ``clang::format::reformat(...)`` functions, the format is specified; by supplying the `clang::format::FormatStyle; <https://clang.llvm.org/doxygen/structclang_1_1format_1_1FormatStyle.html>`_; structure. Configurable Format Style Options; =================================. This section lists the supported style options. Value type is specified for; each option. For enumeration types possible values are specified both as a C++; enumeration member (with a prefix, e.g. ``LS_Auto``), and as a value usable in; the configuration (without a prefix: ``Auto``). .. _BasedOnStyle:. **BasedOnStyle** (``String``) :ref:`¶ <BasedOnStyle>`; The style used for all options not specifically set in the configuration. This option is supported only in the :program:`clang-format` configuration; (both within ``-style='{...}'`` and the ``.clang-format`` file). Possible values:. * ``LLVM``; A style complying with the `LLVM coding standards; <https://llvm.org/docs/CodingStandards.html>`_; * ``Google``; A style complying with `Google's C++ style guide; <https://google.github.io/styleguide/cppguide.html>`_; * ``Chromium``; A style complying with `Chromium's style guide; <https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md>`_; * ``Mozilla``; A style complying with `Mozilla's style guide; <https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html>`_; * ``WebKit``; A style complying with `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ``Microsoft``; A style complying with `Microsoft's style guide; <https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:5190,config,configuration,5190,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"lt in. Configuration steps for all nodes; ---------------------------------. ### Setup CernVM-FS. [CernVM-FS](http://cernvm.cern.ch/portal/filesystem) should be installed; on all machines as the preferred method for software distribution. > Configuration instructions for the latest CernVM-FS can be found; > [here](http://cernvm.cern.ch/portal/filesystem/techinformation). A brief step-by-step procedure to install CernVM-FS is hereby described. - Download and install the latest stable version from; [here](http://cernvm.cern.ch/portal/filesystem): pick one which is; appropriate to your operating system. You need the `cvmfs` package,; you *don't* need the `cvmfs-devel` or `cvmfs-server` ones. - As root user, run:. # cvmfs_config setup. - Start the `autofs` service: how to to this depends on your operating; system. On Ubuntu using Upstart:. # restart autofs. On RHEL-based or older Ubuntus:. # service autofs restart. - Prepare a `/etc/cvmfs/default.local` file (create it if it does not; exists) with the following configuration bits:. ``` {.bash}; CVMFS_HTTP_PROXY=http://your-proxy-server.domain.ch:3128,DIRECT; CVMFS_REPOSITORIES=your-experiment.cern.ch,sft.cern.ch; CVMFS_QUOTA_LIMIT=50000; ```. You need to properly specify your closest HTTP caching proxy:; separate many of them via commas. The last fallback value, `DIRECT`,; tells cvmfs to connect directly without using any proxy at all. Among the list of repositories (comma-separated), always specify; `sft.cern.ch` and the one containing the software to your experiment; (e.g., `cms.cern.ch`). The quota limit is, in Megabytes, the amount of local disk space to; use as cache. - Check the configuration and repositories with:. # cvmfs_config chksetup; OK; # cvmfs_config probe; Probing /cvmfs/cms.cern.ch... OK; Probing /cvmfs/sft.cern.ch... OK. > You might need special configurations for some custom software; > repositories! Special cases are not covered in this guide. ### Firewall configuration. [PROOF on Demand](http://pod.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md:2749,config,configuration,2749,proof/doc/confman/ConfigProofPoD.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md,1,['config'],['configuration']
Modifiability,"lt value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). TransformOutput No False − Transform likelihood output by inverse sigmoid function. Configuration options for MVA method :. Configuration options reference for MVA method: MLP. Option Array Default value Predefined values Description. NCycles No 500 − Number of training cycles. HiddenLayers No N,N-1 − Specification of hidden layer architecture. NeuronType No sigmoid − Neuron activation function type. RandomSeed No 1 − Random seed for initial synapse weights (0 means unique seed for each run; default value '1'). EstimatorType No MSE MSE, CE, linear, sigmoid, tanh, radial MSE (Mean Square Estimator) for Gaussian Likelihood or CE(Cross-Entropy) for Bernoulli Likelihood. NeuronInputType No sum sum, sqsum, abssum Neuron input function type. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the give",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:20823,Config,Configuration,20823,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['Config'],['Configuration']
Modifiability,lticlass.cxx; src/ResultsRegression.cxx; src/ROCCalc.cxx; src/ROCCurve.cxx; src/RootFinder.cxx; src/RuleCut.cxx; src/Rule.cxx; src/RuleEnsemble.cxx; src/RuleFitAPI.cxx; src/RuleFit.cxx; src/RuleFitParams.cxx; src/SdivSqrtSplusB.cxx; src/SeparationBase.cxx; src/SimulatedAnnealing.cxx; src/SimulatedAnnealingFitter.cxx; src/SVEvent.cxx; src/SVKernelFunction.cxx; src/SVKernelMatrix.cxx; src/SVWorkingSet.cxx; src/TActivationChooser.cxx; src/TActivation.cxx; src/TActivationIdentity.cxx; src/TActivationRadial.cxx; src/TActivationReLU.cxx; src/TActivationSigmoid.cxx; src/TActivationTanh.cxx; src/Timer.cxx; src/TNeuron.cxx; src/TNeuronInputAbs.cxx; src/TNeuronInputChooser.cxx; src/TNeuronInput.cxx; src/TNeuronInputSqSum.cxx; src/TNeuronInputSum.cxx; src/Tools.cxx; src/TrainingHistory.cxx; src/TransformationHandler.cxx; src/TSpline1.cxx; src/TSpline2.cxx; src/TSynapse.cxx; src/Types.cxx; src/VariableDecorrTransform.cxx; src/VariableGaussTransform.cxx; src/VariableIdentityTransform.cxx; src/VariableImportance.cxx; src/VariableInfo.cxx; src/VariableNormalizeTransform.cxx; src/VariablePCATransform.cxx; src/VariableRearrangeTransform.cxx; src/VariableTransformBase.cxx; src/VariableTransform.cxx; src/VarTransformHandler.cxx; src/Volume.cxx; src/DNN/Architectures/Reference.cxx; src/DNN/Architectures/Reference/DataLoader.cxx; src/DNN/Architectures/Reference/TensorDataLoader.cxx; src/DNN/Architectures/Cpu.cxx; src/DNN/Architectures/Cpu/CpuBuffer.cxx; src/DNN/Architectures/Cpu/CpuMatrix.cxx; ${TMVA_EXTRA_SOURCES}; DEPENDENCIES; TreePlayer; Tree; Hist; Matrix; Minuit; MLP; MathCore; Core; RIO; XMLIO; ${TMVA_EXTRA_DEPENDENCIES}; DICTIONARY_OPTIONS; -writeEmptyRootPCM; INSTALL_OPTIONS; ${installoptions}; ${EXTRA_DICT_OPTS}; ). if(MSVC); target_compile_definitions(TMVA PRIVATE _USE_MATH_DEFINES); endif(). if(vdt OR builtin_vdt); target_link_libraries(TMVA PRIVATE VDT::VDT); endif(); if(builtin_vdt); add_dependencies(TMVA VDT); endif(). if(tmva-cpu); target_include_directories(TMVA PRIVATE,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/CMakeLists.txt:8625,Variab,VariableImportance,8625,tmva/tmva/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/CMakeLists.txt,1,['Variab'],['VariableImportance']
Modifiability,luated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and definitions of variable templates; Unknown. 1730; drafting; Can a variable template have an unnamed type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexcept; Unknown. 1741; C++14; odr-use of class object in lvalue-to-rvalue conversion; Unknown. 1742; CD5; using-declarations and scoped enumerators; Unknown. 1743; NAD; init-captures in nested lambdas; Unknown. 1744; CD4; Unordered init,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:117214,variab,variable,117214,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['variab'],['variable']
Modifiability,"lude(CheckSymbolExists); check_library_exists(dl dlopen """" HAVE_LIBDL); if( HAVE_LIBDL ); list(APPEND CMAKE_REQUIRED_LIBRARIES dl); endif(); list(APPEND CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE); check_symbol_exists(dladdr dlfcn.h CLANG_HAVE_DLADDR); list(REMOVE_ITEM CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE); if( HAVE_LIBDL ); list(REMOVE_ITEM CMAKE_REQUIRED_LIBRARIES dl); endif(); endif(). set(CLANG_RESOURCE_DIR """" CACHE STRING; ""Relative directory from the Clang binary to its resource files.""). set(C_INCLUDE_DIRS """" CACHE STRING; ""Colon separated list of directories clang will search for headers.""). set(GCC_INSTALL_PREFIX """" CACHE PATH ""Directory where gcc is installed."" ); set(DEFAULT_SYSROOT """" CACHE STRING; ""Default <path> to all compiler invocations for --sysroot=<path>."" ); if(GCC_INSTALL_PREFIX); message(WARNING ""GCC_INSTALL_PREFIX is deprecated and will be removed. Use ""; ""configuration files (https://clang.llvm.org/docs/UsersManual.html#configuration-files)""; ""to specify the default --gcc-install-dir= or --gcc-triple=. --gcc-toolchain= is discouraged. ""; ""See https://github.com/llvm/llvm-project/pull/77537 for detail.""); endif(). set(ENABLE_LINKER_BUILD_ID OFF CACHE BOOL ""pass --build-id to ld""). set(ENABLE_X86_RELAX_RELOCATIONS ON CACHE BOOL; ""enable x86 relax relocations by default""). set(PPC_LINUX_DEFAULT_IEEELONGDOUBLE OFF CACHE BOOL; ""Enable IEEE binary128 as default long double format on PowerPC Linux.""). set(CLANG_SPAWN_CC1 OFF CACHE BOOL; ""Whether clang should use a new process for the CC1 invocation""). option(CLANG_DEFAULT_PIE_ON_LINUX ""Default to -fPIE and -pie on linux-gnu"" ON). set(CLANG_DEFAULT_LINKER """" CACHE STRING; ""Default linker to use (linker name or absolute path, empty for platform default)""). set(CLANG_DEFAULT_CXX_STDLIB """" CACHE STRING; ""Default C++ stdlib to use (\""libstdc++\"" or \""libc++\"", empty for platform default""); if (NOT(CLANG_DEFAULT_CXX_STDLIB STREQUAL """" OR; CLANG_DEFAULT_CXX_STDLIB STREQUAL ""libstdc++"" OR; CLANG_DEFAULT_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:7003,config,configuration-files,7003,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['config'],['configuration-files']
Modifiability,lude/SourceInfo.h; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.cpp; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.h; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.cpp; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.h; openmp/libomptarget/plugins/amdgpu/impl/hsa_api.h; openmp/libomptarget/plugins/amdgpu/impl/impl.cpp; openmp/libomptarget/plugins/amdgpu/impl/impl_runtime.h; openmp/libomptarget/plugins/amdgpu/impl/internal.h; openmp/libomptarget/plugins/amdgpu/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/libomptarget/plugins/remote/include/Utils.h; openmp/libomptarget/plugins/remote/server/OffloadingServer.cpp; openmp/libomptarget/plugins/remote/server/Server.cpp; openmp/libomptarget/plugins/remote/server/Server.h; openmp/libomptarget/plugins/remote/src/Client.cpp; openmp/libomptarget/plugins/remote/src/Client.h; openmp/libomptarget/plugins/ve/src/rtl.cpp; openmp/libomptarget/src/api.cpp; openmp/libomptarget/src/interface.cpp; openmp/libomptarget/src/interop.cpp; openmp/libomptarget/src/omptarget.cpp; openmp/libomptarget/src/private.h; openmp/libomptarget/src/rtl.cpp; openmp/libomptarget/tools/deviceinfo/llvm-omp-device-info.cpp; openmp/runtime/doc/doxygen/libomp_interface.h; openmp/runtime/src/extractExternal.cpp; openmp/runtime/src/kmp.h; openmp/runtime/src/kmp_affinity.h; openmp/runtime/src/kmp_alloc.cpp; openmp/runtime/src/kmp_atomic.cpp; openmp/runtime/src/kmp_atomic.h; openmp/runtime/,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:407804,plugin,plugins,407804,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,"lude` directory is automatically appended to the; include path, so you do not have to worry about including it. To add; library that should be used during linking of the shared library use; something like:. ``` {.cpp}; gSystem->AddLinkedLibs(""-L/my/path -lanylib"");; ```. This is especially useful for static libraries. For shared ones you; can also simply load them before trying to compile the script:. ``` {.cpp}; gSystem->Load(""mydir/mylib"");; ```. ACLiC uses the directive `fMakeSharedLibs` to create the shared; library. If loading the shared library fails, it tries to output a; list of missing symbols by creating an executable (on some platforms; like OSF, this does not HAVE to be an executable) containing the; script. It uses the directive `fMakeExe` to do so. For both; directives, before passing them to `TSystem::Exec()`, it expands the; variables `$SourceFiles`, `$SharedLib`, `$LibName`, `$IncludePath`,; `$LinkedLibs`, `$ExeName `and` $ObjectFiles`. See `SetMakeSharedLib()`; for more information on those variables. When the file being passed to; ACLiC is on a read only file system, ACLiC warns the user and creates; the library in a temporary directory:. ``` {.cpp}; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC>: creating shared library; /tmp//scratch/aclic/subs/./readonly/t_C.so; ```. To select the temporary directory ACLiC looks at `$TEMP`, `$TEMP_DIR`,; `$TEMPDIR`, `$TMP`, `$TMPDIR`, `$TMP_DIR `or uses `/tmp (`or `C:/)`.; Also, a new interface `TSystem::Get/SetBuildDir` is introduced; to let users select an alternative 'root' for building of the ACLiC; libraries. For `filename/full/path/name/macro.C`, the library is; created as `fBuildDir/full/path/name/macro_C.so.`. ### Dictionary Generation. You can direct what is added to the dictionary generated by ACLiC in; two ways. The simplest way is to add at the end of script (i.e. after; th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:17878,variab,variables,17878,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['variab'],['variables']
Modifiability,"luding constructor/destructor) declaration/definition names or before; control statements, i.e. ``if``, ``switch`` (including ``case`` and; ``default`` labels), ``for``, and ``while`` statements. Possible values:. * ``ABS_Always`` (in configuration: ``Always``); Always break after attributes. .. code-block:: c++. [[maybe_unused]]; const int i;; [[gnu::const]] [[maybe_unused]]; int j;. [[nodiscard]]; inline int f();; [[gnu::const]] [[nodiscard]]; int g();. [[likely]]; if (a); f();; else; g();. switch (b) {; [[unlikely]]; case 1:; ++b;; break;; [[likely]]; default:; return;; }. * ``ABS_Leave`` (in configuration: ``Leave``); Leave the line breaking after attributes as is. .. code-block:: c++. [[maybe_unused]] const int i;; [[gnu::const]] [[maybe_unused]]; int j;. [[nodiscard]] inline int f();; [[gnu::const]] [[nodiscard]]; int g();. [[likely]] if (a); f();; else; g();. switch (b) {; [[unlikely]] case 1:; ++b;; break;; [[likely]]; default:; return;; }. * ``ABS_Never`` (in configuration: ``Never``); Never break after attributes. .. code-block:: c++. [[maybe_unused]] const int i;; [[gnu::const]] [[maybe_unused]] int j;. [[nodiscard]] inline int f();; [[gnu::const]] [[nodiscard]] int g();. [[likely]] if (a); f();; else; g();. switch (b) {; [[unlikely]] case 1:; ++b;; break;; [[likely]] default:; return;; }. .. _BreakAfterJavaFieldAnnotations:. **BreakAfterJavaFieldAnnotations** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <BreakAfterJavaFieldAnnotations>`; Break after each annotation on a field in Java files. .. code-block:: java. true: false:; @Partial vs. @Partial @Mock DataLoad loader;; @Mock; DataLoad loader;. .. _BreakArrays:. **BreakArrays** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <BreakArrays>`; If ``true``, clang-format will always break after a Json array ``[``; otherwise it will scan until the closing ``]`` to determine if it should; add newlines between elements (prettier compatible). .. note::. This is currently only for formatting JSON. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:44906,config,configuration,44906,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"lue for the starting value, we add it to the Phi; node. Note that the Phi will eventually get a second value for the; backedge, but we can't set it up yet (because it doesn't exist!). .. code-block:: c++. // Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.; Value *OldVal = NamedValues[VarName];; NamedValues[VarName] = Variable;. // Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.; if (!Body->codegen()); return nullptr;. Now the code starts to get more interesting. Our 'for' loop introduces a; new variable to the symbol table. This means that our symbol table can; now contain either function arguments or loop variables. To handle this,; before we codegen the body of the loop, we add the loop variable as the; current value for its name. Note that it is possible that there is a; variable of the same name in the outer scope. It would be easy to make; this an error (emit an error and return null if there is already an; entry for VarName) but we choose to allow shadowing of variables. In; order to handle this correctly, we remember the Value that we are; potentially shadowing in ``OldVal`` (which will be null if there is no; shadowed variable). Once the loop variable is set into the symbol table, the code; recursively codegen's the body. This allows the body to use the loop; variable: any references to it will naturally find it in the symbol; table. .. code-block:: c++. // Emit the step value.; Value *StepVal = nullptr;; if (Step) {; StepVal = Step->codegen();; if (!StepVal); return nullptr;; } else {; // If not specified, use 1.0.; StepVal = ConstantFP::get(*TheContext, APFloat(1.0));; }. Value *NextVar = Builder->CreateFAdd(Variable, StepVal, ""nextvar"");. Now that the body is emitted, we compute the next value of the iteration; variable by adding the step value,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:23203,variab,variable,23203,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['variab'],['variable']
Modifiability,"lues[Name];; if (!A); return LogErrorV(""Unknown variable name"");. // Load the value.; return Builder->CreateLoad(A->getAllocatedType(), A, Name.c_str());; }. As you can see, this is pretty straightforward. Now we need to update; the things that define the variables to set up the alloca. We'll start; with ``ForExprAST::codegen()`` (see the `full code listing <#id1>`_ for; the unabridged code):. .. code-block:: c++. Function *TheFunction = Builder->GetInsertBlock()->getParent();. // Create an alloca for the variable in the entry block.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);. // Emit the start code first, without 'variable' in scope.; Value *StartVal = Start->codegen();; if (!StartVal); return nullptr;. // Store the value into the alloca.; Builder->CreateStore(StartVal, Alloca);; ... // Compute the end condition.; Value *EndCond = End->codegen();; if (!EndCond); return nullptr;. // Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.; Value *CurVar = Builder->CreateLoad(Alloca->getAllocatedType(), Alloca,; VarName.c_str());; Value *NextVar = Builder->CreateFAdd(CurVar, StepVal, ""nextvar"");; Builder->CreateStore(NextVar, Alloca);; ... This code is virtually identical to the code `before we allowed mutable; variables <LangImpl05.html#code-generation-for-the-for-loop>`_. The big difference is that we; no longer have to construct a PHI node, and we use load/store to access; the variable as needed. To support mutable argument variables, we need to also make allocas for; them. The code for this is also pretty simple:. .. code-block:: c++. Function *FunctionAST::codegen() {; ...; Builder->SetInsertPoint(BB);. // Record the function arguments in the NamedValues map.; NamedValues.clear();; for (auto &Arg : TheFunction->args()) {; // Create an alloca for this variable.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());. // Store the initial value into the alloca.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:15024,variab,variable,15024,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,lugins/amdgpu/impl/hsa_api.h; openmp/libomptarget/plugins/amdgpu/impl/impl.cpp; openmp/libomptarget/plugins/amdgpu/impl/impl_runtime.h; openmp/libomptarget/plugins/amdgpu/impl/internal.h; openmp/libomptarget/plugins/amdgpu/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/libomptarget/plugins/remote/include/Utils.h; openmp/libomptarget/plugins/remote/server/OffloadingServer.cpp; openmp/libomptarget/plugins/remote/server/Server.cpp; openmp/libomptarget/plugins/remote/server/Server.h; openmp/libomptarget/plugins/remote/src/Client.cpp; openmp/libomptarget/plugins/remote/src/Client.h; openmp/libomptarget/plugins/ve/src/rtl.cpp; openmp/libomptarget/src/api.cpp; openmp/libomptarget/src/interface.cpp; openmp/libomptarget/src/interop.cpp; openmp/libomptarget/src/omptarget.cpp; openmp/libomptarget/src/private.h; openmp/libomptarget/src/rtl.cpp; openmp/libomptarget/tools/deviceinfo/llvm-omp-device-info.cpp; openmp/runtime/doc/doxygen/libomp_interface.h; openmp/runtime/src/extractExternal.cpp; openmp/runtime/src/kmp.h; openmp/runtime/src/kmp_affinity.h; openmp/runtime/src/kmp_alloc.cpp; openmp/runtime/src/kmp_atomic.cpp; openmp/runtime/src/kmp_atomic.h; openmp/runtime/src/kmp_barrier.h; openmp/runtime/src/kmp_cancel.cpp; openmp/runtime/src/kmp_debug.cpp; openmp/runtime/src/kmp_debug.h; openmp/runtime/src/kmp_debugger.cpp; openmp/runtime/src/kmp_debugger.h; openmp/runtime/src/kmp_dispatch.cpp; openmp/runtime/src/kmp_dispatch.h; openmp/runtime/src,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:408087,plugin,plugins,408087,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,lugins/amdgpu/impl/impl.cpp; openmp/libomptarget/plugins/amdgpu/impl/impl_runtime.h; openmp/libomptarget/plugins/amdgpu/impl/internal.h; openmp/libomptarget/plugins/amdgpu/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/libomptarget/plugins/remote/include/Utils.h; openmp/libomptarget/plugins/remote/server/OffloadingServer.cpp; openmp/libomptarget/plugins/remote/server/Server.cpp; openmp/libomptarget/plugins/remote/server/Server.h; openmp/libomptarget/plugins/remote/src/Client.cpp; openmp/libomptarget/plugins/remote/src/Client.h; openmp/libomptarget/plugins/ve/src/rtl.cpp; openmp/libomptarget/src/api.cpp; openmp/libomptarget/src/interface.cpp; openmp/libomptarget/src/interop.cpp; openmp/libomptarget/src/omptarget.cpp; openmp/libomptarget/src/private.h; openmp/libomptarget/src/rtl.cpp; openmp/libomptarget/tools/deviceinfo/llvm-omp-device-info.cpp; openmp/runtime/doc/doxygen/libomp_interface.h; openmp/runtime/src/extractExternal.cpp; openmp/runtime/src/kmp.h; openmp/runtime/src/kmp_affinity.h; openmp/runtime/src/kmp_alloc.cpp; openmp/runtime/src/kmp_atomic.cpp; openmp/runtime/src/kmp_atomic.h; openmp/runtime/src/kmp_barrier.h; openmp/runtime/src/kmp_cancel.cpp; openmp/runtime/src/kmp_debug.cpp; openmp/runtime/src/kmp_debug.h; openmp/runtime/src/kmp_debugger.cpp; openmp/runtime/src/kmp_debugger.h; openmp/runtime/src/kmp_dispatch.cpp; openmp/runtime/src/kmp_dispatch.h; openmp/runtime/src/kmp_dispatch_hier.h; openmp/runtime/src/kmp_environ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:408139,plugin,plugins,408139,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,lugins/amdgpu/impl/impl_runtime.h; openmp/libomptarget/plugins/amdgpu/impl/internal.h; openmp/libomptarget/plugins/amdgpu/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/libomptarget/plugins/remote/include/Utils.h; openmp/libomptarget/plugins/remote/server/OffloadingServer.cpp; openmp/libomptarget/plugins/remote/server/Server.cpp; openmp/libomptarget/plugins/remote/server/Server.h; openmp/libomptarget/plugins/remote/src/Client.cpp; openmp/libomptarget/plugins/remote/src/Client.h; openmp/libomptarget/plugins/ve/src/rtl.cpp; openmp/libomptarget/src/api.cpp; openmp/libomptarget/src/interface.cpp; openmp/libomptarget/src/interop.cpp; openmp/libomptarget/src/omptarget.cpp; openmp/libomptarget/src/private.h; openmp/libomptarget/src/rtl.cpp; openmp/libomptarget/tools/deviceinfo/llvm-omp-device-info.cpp; openmp/runtime/doc/doxygen/libomp_interface.h; openmp/runtime/src/extractExternal.cpp; openmp/runtime/src/kmp.h; openmp/runtime/src/kmp_affinity.h; openmp/runtime/src/kmp_alloc.cpp; openmp/runtime/src/kmp_atomic.cpp; openmp/runtime/src/kmp_atomic.h; openmp/runtime/src/kmp_barrier.h; openmp/runtime/src/kmp_cancel.cpp; openmp/runtime/src/kmp_debug.cpp; openmp/runtime/src/kmp_debug.h; openmp/runtime/src/kmp_debugger.cpp; openmp/runtime/src/kmp_debugger.h; openmp/runtime/src/kmp_dispatch.cpp; openmp/runtime/src/kmp_dispatch.h; openmp/runtime/src/kmp_dispatch_hier.h; openmp/runtime/src/kmp_environment.cpp; openmp/runtime/src/kmp_environment.h; op,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:408190,plugin,plugins,408190,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,"lusterPool is an internal class owned be a page source.; The cluster pool maintains an I/O thread that asynchronously prefetches the next few clusters.; Through `RPageSource::SetEntryRange()`, the cluster pool is instructed to not read beyond the given limit.; This is used in the RNTuple data source when multiple threads work on different clusters of the same file. ### RMiniFile; The RMiniFile is an internal class used to read and write RNTuple data in a ROOT file.; It provides a minimal subset of the `TFile` functionality.; Its purpose is to reduce the coupling between RNTuple and the ROOT I/O library. For writing data, the RMiniFile can either use a proper `TFile` (descendant) or a C file stream (only for new ROOT files with a single RNTuple).; For reading, the `RMiniFile` always uses an `RRawFile`. ### RRawFile; The RRawFile internal abstract class provides an interface to read byte ranges from a file, including vector reads.; Concrete implementations exist for local files, XRootD and HTTP (the latter two through the ROOT plugin mechanism).; The local file implementation on Linux uses uring for vector reads, if available.; `RRawFileTFile` wraps an existing `TFile` and provides access to the full set of implementations, e.g. `TMemFile`. Tooling; -------. ### RNTupleMerger; The `RNTupleMerger` is an internal class and part of the core RNTuple library.; It concatenates RNTuple data from several sources into a combined sink.; It implements ""fast merging"", i.e. copy-based merging that does not decompress and recompress pages.; The RNTupler merger is used by the `TFileMerger` and thus provides RNTuple merge support in `hadd` and `TBufferMerger`. ### RNTupleImporter; The RNTupleImporter creates RNTuple data sets from ROOT trees.; It is part of the `ROOTNTupleUtil` library. ### RNTupleInspector; The RNTupleInspector provides insights of an RNTuple, e.g. the distribution of data volume wrt. column types.; It is part of the `ROOTNTupleUtil` library. Ownership Model; -------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:16142,plugin,plugin,16142,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['plugin'],['plugin']
Modifiability,"lvm-ar` to include additional information in the output. Modifiers (generic); ~~~~~~~~~~~~~~~~~~~. The modifiers below may be applied to any operation. .. option:: c. For the :option:`r` (replace)and :option:`q` (quick update) operations,; :program:`llvm-ar` will always create the archive if it doesn't exist.; Normally, :program:`llvm-ar` will print a warning message indicating that the; ``archive`` is being created. Using this modifier turns off; that warning. .. option:: D. Use zero for timestamps and UIDs/GIDs. This is set by default. .. option:: P. Use full paths when matching member names rather than just the file name.; This can be useful when manipulating an ``archive`` generated by another; archiver, as some allow paths as member names. This is the default behavior; for thin archives. .. option:: s. This modifier requests that an archive index (or symbol table) be added to the; ``archive``, as if using ranlib. The symbol table will contain all the; externally visible functions and global variables defined by all the bitcode; files in the archive. By default :program:`llvm-ar` generates symbol tables in; archives. This can also be used as an operation. .. option:: S. This modifier is the opposite of the :option:`s` modifier. It instructs; :program:`llvm-ar` to not build the symbol table. If both :option:`s` and; :option:`S` are used, the last modifier to occur in the options will prevail. .. option:: u. Only update ``archive`` members with *files* that have more recent; timestamps. .. option:: U. Use actual timestamps and UIDs/GIDs. Other; ~~~~~. .. option:: --format=<type>. This option allows for default, gnu, darwin or bsd ``<type>`` to be selected.; When creating an ``archive``, ``<type>`` will default to that of the host; machine. .. option:: -h, --help. Print a summary of command-line options and their meanings. .. option:: -M. This option allows for MRI scripts to be read through the standard input; stream. No other options are compatible with this optio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst:9101,variab,variables,9101,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst,1,['variab'],['variables']
Modifiability,"lvm-project/llvm/lib/libLLVMScalarOpts.a(NewGVN.cpp.o)' to global weak symbol; # 'llvm::ReverseIterate<bool>::value' from file 'interpreter/llvm-project/llvm/lib/libclingUtils.a(AST.cpp.o)'; # means the weak symbol cannot be overridden at runtime. This was likely caused by different; # translation units being compiled with different visibility settings.; # There is no apparent reason why this is happening and it looks like a compiler bug,; # so let's just disable the part of the code that provides this symbol.; # As it's in the validation part of LLVM and not in something that providing functionality,; # this shouldn't cause any problems.; # TODO: We maybe can remove this code once we upgrade to LLVM>=6.0 as this symbol; # was introduced quite recently into LLVM 5.0 and probably is also causing problems; # for some other projects.; set(LLVM_ENABLE_ABI_BREAKING_CHECKS OFF CACHE BOOL """" FORCE); set(LLVM_ABI_BREAKING_CHECKS FORCE_OFF CACHE BOOL """" FORCE). set(CMAKE_REQUIRED_QUIET 1) # Make the configuration of LLVM quiet. if(ROOT_ARCHITECTURE MATCHES arm64); set(ROOT_CLING_TARGET ""AArch64""); elseif(ROOT_ARCHITECTURE MATCHES arm); set(ROOT_CLING_TARGET ""ARM""); elseif(ROOT_ARCHITECTURE MATCHES ppc64); set(ROOT_CLING_TARGET ""PowerPC""); elseif(ROOT_ARCHITECTURE MATCHES s390); set(ROOT_CLING_TARGET ""SystemZ""); elseif(ROOT_ARCHITECTURE MATCHES riscv64); set(ROOT_CLING_TARGET ""RISCV""); elseif(ROOT_ARCHITECTURE MATCHES freebsd OR ROOT_ARCHITECTURE MATCHES linux OR ROOT_ARCHITECTURE MATCHES macosx); set(ROOT_CLING_TARGET ""X86""); elseif(ROOT_ARCHITECTURE MATCHES win32 OR ROOT_ARCHITECTURE MATCHES win64); set(ROOT_CLING_TARGET ""X86""); else(); set(ROOT_CLING_TARGET ""all""); endif(). if(NOT ""${ROOT_CLING_TARGET}"" STREQUAL ""all""); string(APPEND ROOT_CLING_TARGET "";NVPTX""); endif(). if(MSVC); # FIXME: since Visual Studio v16.4.0 the /O2 optimization flag make many (25%) of the tests failing; # Try to re-enable /O2 after the upgrade of llvm & clang; if (MSVC_VERSION GREATER_EQUAL 1924 ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:4546,config,configuration,4546,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['config'],['configuration']
Modifiability,"lvm.dbg.assign` marker that is not linked to any instruction signals that; the store that performed the assignment has been optimised out, and therefore; the memory location will not be valid for at least some part of the program. Here's the `llvm.dbg.assign` signature. Each parameter is wrapped in; `MetadataAsValue`, and `Value *` type parameters are first wrapped in; `ValueAsMetadata`:. ```; void @llvm.dbg.assign(Value *Value,; DIExpression *ValueExpression,; DILocalVariable *Variable,; DIAssignID *ID,; Value *Address,; DIExpression *AddressExpression); ```. The first three parameters look and behave like an `llvm.dbg.value`. `ID` is a; reference to a store (see next section). `Address` is the destination address; of the store and it is modified by `AddressExpression`. An empty/undef/poison; address means the address component has been killed (the memory address is no; longer a valid location). LLVM currently encodes variable fragment information; in `DIExpression`s, so as an implementation quirk the `FragmentInfo` for; `Variable` is contained within `ValueExpression` only. The formal LLVM-IR signature is:; ```; void @llvm.dbg.assign(metadata, metadata, metadata, metadata, metadata, metadata); ```. ### Instruction link: `DIAssignID`. `DIAssignID` metadata is the mechanism that is currently used to encode the; store<->marker link. The metadata node has no operands and all instances are; `distinct`; equality is checked for by comparing addresses. `llvm.dbg.assign` intrinsics use a `DIAssignID` metadata node instance as an; operand. This way it refers to any store-like instruction that has the same; `DIAssignID` attachment. E.g. For this test.cpp,. ```; int fun(int a) {; return a;; }; ```; compiled without optimisations:; ```; $ clang++ test.cpp -o test.ll -emit-llvm -S -g -O0 -Xclang -fexperimental-assignment-tracking; ```; we get:; ```; define dso_local noundef i32 @_Z3funi(i32 noundef %a) #0 !dbg !8 {; entry:; %a.addr = alloca i32, align 4, !DIAssignID !13; call vo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:3431,variab,variable,3431,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,1,['variab'],['variable']
Modifiability,"lvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 2)};. This formatting scheme also makes it particularly easy to get predictable,; consistent, and automatic formatting with tools like `Clang Format`_. .. _Clang Format: https://clang.llvm.org/docs/ClangFormat.html. Language and Compiler Issues; ----------------------------. Treat Compiler Warnings Like Errors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Compiler warnings are often useful and help improve the code. Those that are; not useful, can be often suppressed with a small code change. For example, an; assignment in the ``if`` condition is often a typo:. .. code-block:: c++. if (V = getValue()) {; ...; }. Several compilers will print a warning for the code above. It can be suppressed; by adding parentheses:. .. code-block:: c++. if ((V = getValue())) {; ...; }. Write Portable Code; ^^^^^^^^^^^^^^^^^^^. In almost all cases, it is possible to write completely portable code. When; you need to rely on non-portable code, put it behind a well-defined and; well-documented interface. Do not use RTTI or Exceptions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In an effort to reduce code and executable size, LLVM does not use exceptions; or RTTI (`runtime type information; <https://en.wikipedia.org/wiki/Run-time_type_information>`_, for example,; ``dynamic_cast<>``). That said, LLVM does make extensive use of a hand-rolled form of RTTI that use; templates like :ref:`isa\<>, cast\<>, and dyn_cast\<> <isa>`.; This form of RTTI is opt-in and can be; :doc:`added to any class <HowToSetUpLLVMStyleRTTI>`. Prefer C++-style casts; ^^^^^^^^^^^^^^^^^^^^^^. When casting, use ``static_cast``, ``reinterpret_cast``, and ``const_cast``,; rather than C-style casts. There are two exceptions to this:. * When casting to ``void`` to suppress warnings about unused variables (as an; alternative to ``[[maybe_unused]]``). Prefer C-style casts in this instance. * When casting between integral types (including enums that are not strongly-; typed), functi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:22115,portab,portable,22115,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['portab'],['portable']
Modifiability,"lways put short ifs, else ifs and else statements on the same; line. .. code-block:: c++. if (a) return;. if (b) return;; else return;. if (c) return;; else {; return;; }. .. _AllowShortLambdasOnASingleLine:. **AllowShortLambdasOnASingleLine** (``ShortLambdaStyle``) :versionbadge:`clang-format 9` :ref:`¶ <AllowShortLambdasOnASingleLine>`; Dependent on the value, ``auto lambda []() { return 0; }`` can be put on a; single line. Possible values:. * ``SLS_None`` (in configuration: ``None``); Never merge lambdas into a single line. * ``SLS_Empty`` (in configuration: ``Empty``); Only merge empty lambdas. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) {; return a;; };. * ``SLS_Inline`` (in configuration: ``Inline``); Merge lambda into a single line if the lambda is argument of a function. .. code-block:: c++. auto lambda = [](int x, int y) {; return x < y;; };; sort(a.begin(), a.end(), [](int x, int y) { return x < y; });. * ``SLS_All`` (in configuration: ``All``); Merge all lambdas fitting on a single line. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) { return a; };. .. _AllowShortLoopsOnASingleLine:. **AllowShortLoopsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <AllowShortLoopsOnASingleLine>`; If ``true``, ``while (true) continue;`` can be put on a single; line. .. _AlwaysBreakAfterDefinitionReturnType:. **AlwaysBreakAfterDefinitionReturnType** (``DefinitionReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlwaysBreakAfterDefinitionReturnType>`; The function definition return type breaking style to use. This; option is **deprecated** and is retained for backwards compatibility. Possible values:. * ``DRTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. * ``DRTBS_All`` (in configuration: ``All``); Always break after the return type. * ``DRTBS_TopLevel`` (in configuration: ``TopLevel``); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:31781,config,configuration,31781,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ly a good idea if:. - you've landed 3-5 patches of larger scope than ""fix a typo"". - you'd be willing to review changes that are closely related to yours. - you'd like to keep contributing to LLVM. Getting commit access; ---------------------. LLVM uses Git for committing changes. The details are in the `developer; policy; document <https://llvm.org/docs/DeveloperPolicy.html#obtaining-commit-access>`__. With great power; ----------------. Actually, this would be a great time to read the rest of the `developer; policy <https://llvm.org/docs/DeveloperPolicy.html>`__, too. At minimum,; you need to be subscribed to the relevant commits list before landing; changes (e.g. llvm-commits@lists.llvm.org), as discussion often happens; there if a new patch causes problems. Post-commit errors; ------------------. Once your change is submitted it will be picked up by automated build; bots that will build and test your patch in a variety of configurations. You can see all configurations and their current state in a waterfall; view at http://lab.llvm.org/buildbot/#/waterfall. The waterfall view is good; to get a general overview over the tested configurations and to see; which configuration have been broken for a while. The console view at http://lab.llvm.org/buildbot/#/console helps to get a; better understanding of the build results of a specific patch. If you; want to follow along how your change is affecting the build bots, **this; should be the first place to look at** - the colored bubbles correspond; to projects in the waterfall. If you see a broken build, do not despair - some build bots are; continuously broken; if your change broke the build, you will see a red; bubble in the console view, while an already broken build will show an; orange bubble. Of course, even when the build was already broken, a new; change might introduce a hidden new failure. | When you want to see more details how a specific build is broken,; click the red bubble.; | If post-commit error logs confus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:13768,config,configurations,13768,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['config'],['configurations']
Modifiability,"ly added to any distribution. Instead, you must include the targets; explicitly in some *LLVM_<distribution>_DISTRIBUTION_COMPONENTS* list. By default, each target can appear in multiple distributions; a target will be; installed as part of all distributions it appears in, and it'll be exported by; the last distribution it appears in (the order of distributions is the order; they appear in *LLVM_DISTRIBUTIONS*). We also define some umbrella targets (e.g.; ``llvm-libraries`` to install all LLVM libraries); a target can appear in a; different distribution than its umbrella, in which case the target will be; exported by the distribution it appears in (and not the distribution its; umbrella appears in). Set *LLVM_STRICT_DISTRIBUTIONS* to ``On`` if you want to; enforce a target appearing in only one distribution and umbrella distributions; being consistent with target distributions. We strongly encourage looking at ``clang/cmake/caches/MultiDistributionExample.cmake``; as an example of configuring multiple distributions. Special Notes for Library-only Distributions; --------------------------------------------. One of the most powerful features of LLVM is its library-first design mentality; and the way you can compose a wide variety of tools using different portions of; LLVM. Even in this situation using *BUILD_SHARED_LIBS* is not supported. If you; want to distribute LLVM as a shared library for use in a tool, the recommended; method is using *LLVM_BUILD_LLVM_DYLIB*, and you can use *LLVM_DYLIB_COMPONENTS*; to configure which LLVM components are part of libLLVM.; Note: *LLVM_BUILD_LLVM_DYLIB* is not available on Windows. Options for Optimizing LLVM; ===========================. There are four main build optimizations that our CMake build system supports.; When performing a bootstrap build it is not beneficial to do anything other than; setting *CMAKE_BUILD_TYPE* to ``Release`` for the stage-1 compiler. This is; because the more intensive optimizations are expensive to pe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:6827,config,configuring,6827,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['config'],['configuring']
Modifiability,"ly at the specified; address will not be the first instruction in the snippet. Using this; annotation requires the subprocess execution mode. This is useful in; cases where the memory accessed by the snippet depends on the location; of the snippet, like RIP-relative addressing. EXAMPLE 1: benchmarking instructions; ------------------------------------. Assume you have an X86-64 machine. To measure the latency of a single; instruction, run:. .. code-block:: bash. $ llvm-exegesis --mode=latency --opcode-name=ADD64rr. Measuring the uop decomposition or inverse throughput of an instruction works similarly:. .. code-block:: bash. $ llvm-exegesis --mode=uops --opcode-name=ADD64rr; $ llvm-exegesis --mode=inverse_throughput --opcode-name=ADD64rr. The output is a YAML document (the default is to write to stdout, but you can; redirect the output to a file using `--benchmarks-file`):. .. code-block:: none. ---; key:; opcode_name: ADD64rr; mode: latency; config: ''; cpu_name: haswell; llvm_triple: x86_64-unknown-linux-gnu; num_repetitions: 10000; measurements:; - { key: latency, value: 1.0058, debug_string: '' }; error: ''; info: 'explicit self cycles, selecting one aliasing configuration.; Snippet:; ADD64rr R8, R8, R10; '; ... To measure the latency of all instructions for the host architecture, run:. .. code-block:: bash. $ llvm-exegesis --mode=latency --opcode-index=-1. EXAMPLE 2: benchmarking a custom code snippet; ---------------------------------------------. To measure the latency/uops of a custom piece of code, you can specify the; `snippets-file` option (`-` reads from standard input). .. code-block:: bash. $ echo ""vzeroupper"" | llvm-exegesis --mode=uops --snippets-file=-. Real-life code snippets typically depend on registers or memory.; :program:`llvm-exegesis` checks the liveliness of registers (i.e. any register; use has a corresponding def or is a ""live in""). If your code depends on the; value of some registers, you need to use snippet annotations to ensure setup; i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst:5393,config,config,5393,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,1,['config'],['config']
Modifiability,"ly emit DWARF unwind when compact unwind encodings; aren't available. This is the default for arm64.; * ``always`` - Always emit DWARF unwind regardless.; * ``default`` - Use the platform-specific default (``always`` for all; non-arm64-platforms). ``no-compact-unwind`` is a performance optimization -- Clang will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:30997,config,configuration,30997,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['configuration']
Modifiability,"ly. - ``FindSymbolOccurrencesRefactoringRule`` produces a ""partial"" refactoring; result: a set of occurrences that refer to a particular symbol. This type; of rule is typically used to implement an interactive renaming action that; allows users to specify which occurrences should be renamed during the; refactoring. Subclasses that choose to implement this rule have to implement; the ``findSymbolOccurrences`` member function. The following set of quick checks might help if you are unsure about the type; of rule you should use:. #. If you would like to transform the source in one translation unit and if; you don't need any cross-TU information, then the; ``SourceChangeRefactoringRule`` should work for you. #. If you would like to implement a rename-like operation with potential; interactive components, then ``FindSymbolOccurrencesRefactoringRule`` might; work for you. How to Create a Rule; ^^^^^^^^^^^^^^^^^^^^. Once you determine which type of rule is suitable for your needs you can; implement the refactoring by subclassing the rule and implementing its; interface. The subclass should have a constructor that takes the inputs that; are needed to perform the refactoring. For example, if you want to implement a; rule that simply deletes a selection, you should create a subclass of; ``SourceChangeRefactoringRule`` with a constructor that accepts the selection; range:. .. code-block:: c++. class DeleteSelectedRange final : public SourceChangeRefactoringRule {; public:; DeleteSelection(SourceRange Selection) : Selection(Selection) {}. Expected<AtomicChanges>; createSourceReplacements(RefactoringRuleContext &Context) override {; AtomicChange Replacement(Context.getSources(), Selection.getBegin());; Replacement.replace(Context.getSource,; CharSourceRange::getCharRange(Selection), """");; return { Replacement };; }; private:; SourceRange Selection;; };. The rule's subclass can then be added to the list of refactoring action's; rules for a particular action using the ``createRefac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:5090,refactor,refactoring,5090,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['refactor'],['refactoring']
Modifiability,"ly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:6640,config,configuration,6640,interpreter/llvm-project/clang/www/hacking.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html,2,['config'],['configuration']
Modifiability,"ly. When a compilation is successful (there are no errors), the driver; checks the bit and emits an ""unused argument"" warning for any arguments; which were never accessed. This is conservative (the argument may not; have been used to do what the user wanted) but still catches the most; obvious cases. Relation to GCC Driver Concepts; -------------------------------. For those familiar with the gcc driver, this section provides a brief; overview of how things from the gcc driver map to the clang driver. - **Driver Driver**. The driver driver is fully integrated into the clang driver. The; driver simply constructs additional Actions to bind the architecture; during the *Pipeline* phase. The tool chain specific argument; translation is responsible for handling ``-Xarch_``. The one caveat is that this approach requires ``-Xarch_`` not be used; to alter the compilation itself (for example, one cannot provide; ``-S`` as an ``-Xarch_`` argument). The driver attempts to reject; such invocations, and overall there isn't a good reason to abuse; ``-Xarch_`` to that end in practice. The upside is that the clang driver is more efficient and does little; extra work to support universal builds. It also provides better error; reporting and UI consistency. - **Specs**. The clang driver has no direct correspondent for ""specs"". The; majority of the functionality that is embedded in specs is in the; Tool specific argument translation routines. The parts of specs which; control the compilation pipeline are generally part of the *Pipeline*; stage. - **Toolchains**. The gcc driver has no direct understanding of tool chains. Each gcc; binary roughly corresponds to the information which is embedded; inside a single ToolChain. The clang driver is intended to be portable and support complex; compilation environments. All platform and tool chain specific code; should be protected behind either abstract or well defined interfaces; (such as whether the platform supports use as a driver driver).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:16503,portab,portable,16503,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['portab'],['portable']
Modifiability,"lysisIntroImages/OutputParameterIdentificationLattice.svg). To determine whether a statement reads or writes a field we can implement; symbolic evaluation of `DeclRefExpr`s, `LValueToRValue` casts, pointer; dereference operator and `MemberExpr`s. ### Using data flow results to identify output parameters. Let's take a look at how we use data flow analysis to identify an output; parameter. The refactoring can be safely done when the data flow algorithm; computes a normal state with all of the fields proven to be overwritten in the; exit basic block of the function. ```c++; struct Customer {; int account_id;; std::string name;; };. void GetCustomer(Customer* c) {; // Overwritten: {}; c->account_id = ...; // Overwritten: {c->account_id}; if (...) {; c->name = ...; // Overwritten: {c->account_id, c->name}; } else {; c->name = ...; // Overwritten: {c->account_id, c->name}; }; // Overwritten: {c->account_id, c->name}; }; ```. When the data flow algorithm computes a normal state, but not all fields are; proven to be overwritten we can't perform the refactoring. ```c++; void target(bool b, Customer* c) {; // Overwritten: {}; if (b) {; c->account_id = 42; // Overwritten: {c->account_id}; } else {; c->name = ""Konrad""; // Overwritten: {c->name}; }; // Overwritten: {}; }; ```. Similarly, when the data flow algorithm computes a failure state, we also can't; perform the refactoring. ```c++; Customer* kGlobalCustomer;. void GetCustomer(Customer* c) {; // Overwritten: {}; c->account_id = ...; // Overwritten: {c->account_id}; if (...) {; print(c->name); // Unsafe read; } else {; kGlobalCustomer = c; // Pointer escape; }; // Unsafe read, Pointer escape; }; ```. ## Example: finding dead stores. Let's say we want to find redundant stores, because they indicate potential; bugs. ```c++; x = GetX();; x = GetY();; ```. The first store to `x` is never read, probably there is a bug. The implementation of dead store analysis is very similar to output parameter; analysis: we need to track stores",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:19011,refactor,refactoring,19011,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['refactor'],['refactoring']
Modifiability,"m ROOT; --------------------. When configuring the ROOT source, enable the Dataset Stager by adding; `--enable-afdsmgrd`. Check in the list of enabled features if you have; ""afdsmgrd"". After running `make` (and, optionally, `make install`) you'll find the; daemon in the same directory of `root.exe`. The configuration file and init.d startup script will be in; `$ROOTSYS/etc/proof`. The daemon can and **must** run as unprivileged; user. Configuration; -------------. The Dataset Stager can share its configuration file with PROOF, as; some directives are the same and unknown directives are just ignored. Directives are one per line and lines beginning with a pound sign (`#`); are used for comments. > The configuration file is automatically checked at each loop: this; > means you can change configuration without restarting the daemon or; > stopping your current transfers. A detailed description of each directive follows. set *VARIABLE=value*; : This statement will substitute every occurrence of `$VARIABLE` with; its *value* in the rest of the configuration file. You can have; multiple `set` statements. xpd.stagereqrepo [dir:]*directory*; : This directive is shared with PROOF: *directory* is the full path to; the dataset repository. **Defaults to empty:** without this; directive the daemon is not operative. The `dir:` prefix is optional. dsmgrd.purgenoopds *true|false*; : Set it to *true* **(default is false)** to remove a dataset when no file to stage; is found. If no file to stage is found, but corrupted files exist, the; dataset is kept to signal failures. Used in combination with `xpd.stagereqrepo`; makes it ""disposable"": only the datasets effectively needed for signaling; the staging status will be kept, improving scalability and stability. dsmgrd.urlregex *regex* *subst*; : Each source URL present in the datasets will be matched to *regex*; and substituted to *subst*. *regex* supports grouping using; parentheses, and groups can be referenced in order using the dollar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md:1695,config,configuration,1695,proof/doc/confman/DatasetStager.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md,1,['config'],['configuration']
Modifiability,"m a remote storage; to your local storage. For each file to transfer, a script is called. The script can be; customized to support your source and destination protocol. Staging requests are issued from the ROOT console, where you can also; control the progress of your staging. Installation; ------------. The Dataset Stager is distributed both on a repository on its own and as; part of ROOT. The easiest way to compile it is to do it inside ROOT. Installing from ROOT; --------------------. When configuring the ROOT source, enable the Dataset Stager by adding; `--enable-afdsmgrd`. Check in the list of enabled features if you have; ""afdsmgrd"". After running `make` (and, optionally, `make install`) you'll find the; daemon in the same directory of `root.exe`. The configuration file and init.d startup script will be in; `$ROOTSYS/etc/proof`. The daemon can and **must** run as unprivileged; user. Configuration; -------------. The Dataset Stager can share its configuration file with PROOF, as; some directives are the same and unknown directives are just ignored. Directives are one per line and lines beginning with a pound sign (`#`); are used for comments. > The configuration file is automatically checked at each loop: this; > means you can change configuration without restarting the daemon or; > stopping your current transfers. A detailed description of each directive follows. set *VARIABLE=value*; : This statement will substitute every occurrence of `$VARIABLE` with; its *value* in the rest of the configuration file. You can have; multiple `set` statements. xpd.stagereqrepo [dir:]*directory*; : This directive is shared with PROOF: *directory* is the full path to; the dataset repository. **Defaults to empty:** without this; directive the daemon is not operative. The `dir:` prefix is optional. dsmgrd.purgenoopds *true|false*; : Set it to *true* **(default is false)** to remove a dataset when no file to stage; is found. If no file to stage is found, but corrupted files exist,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md:1144,config,configuration,1144,proof/doc/confman/DatasetStager.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md,1,['config'],['configuration']
Modifiability,"m is uniquely defined. For example, given three observables ; x, y and z, one can define a parameterized named range 'R' of x in terms of y and of y in terms of z; and ask to calculate the three dimensional integral of any function or p.d.f in terms of (x,y,z); over that range 'R' and it will be calculated correctly, taking recursive range dependencies into; account. A definition of a range 'R' on the other hand where the bounds of x depend on y and; the bounds of y depend on x is not allowed, and an error message will be printed to complain about; the ambiguity of the problem definition. Integrals over non-rectangular regions are created the; same way as integrals over rectangular regions using the RooAbsReal::createIntegral() function, the; chosen mode of operation depends on the shape of the requestion integration range. Note that in general integration over non (hyper)rectangular regions will be more computationally; intensive as only a subset of the observables can be integrated analytically (all of those that do not; have parameterized ranges plus those that have parameterized ranges but are not involved in the; parameterization of others (e.g. x and y in the example above). Running integrals and Cumulative distribution functions. It is now possible to create running integrals from any RooAbsReal function and; to create cumulative distribution functions from any RooAbsPdf using the following; methods:. // Create int[xlo,x] f(x') dx' from f(x); RooAbsReal* runInt = func.createRunningIntegral(x) ;. // Create int[xlo,x] f(x') dx' from p.d.f f(x) normalized over x; RooAbsReal* cdf = pdf.createCdf(x) ;. // Create int[xlo,x] f(x',y) dx' from p.d.f f(x,y) normalized over (x,y); RooAbsReal* cdf = pdf.createCdf(x,y) ;. ; As with the similarly styled function createIntegral running integrals and c.d.f. can be created; over any number of observables, e.g createCdf(RooArgSet(x,y,z)) will create a three-dimensional; cumulative distribution function. C.d.f and running integr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:4931,parameteriz,parameterized,4931,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,6,['parameteriz'],"['parameterization', 'parameterized']"
Modifiability,"m objects; <LangRef.html#diglobalvariable>`_. These abstract objects are used by a; debugger to form stack traces, show information about local variables, etc. This section of the documentation first describes the representation aspects; common to any source-language. :ref:`ccxx_frontend` describes the data layout; conventions used by the C and C++ front-ends. Debug information descriptors are `specialized metadata nodes; <LangRef.html#specialized-metadata>`_, first-class subclasses of ``Metadata``. .. _format_common_intrinsics:. Debugger intrinsic functions; ----------------------------. LLVM uses several intrinsic functions (name prefixed with ""``llvm.dbg``"") to; track source local variables through optimization and code generation. ``llvm.dbg.declare``; ^^^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. void @llvm.dbg.declare(metadata, metadata, metadata). This intrinsic provides information about a local element (e.g., variable).; The first argument is metadata holding the address of variable, typically a; static alloca in the function entry block. The second argument is a; `local variable <LangRef.html#dilocalvariable>`_ containing a description of; the variable. The third argument is a `complex expression; <LangRef.html#diexpression>`_. An `llvm.dbg.declare` intrinsic describes the; *address* of a source variable. .. code-block:: text. %i.addr = alloca i32, align 4; call void @llvm.dbg.declare(metadata i32* %i.addr, metadata !1,; metadata !DIExpression()), !dbg !2; !1 = !DILocalVariable(name: ""i"", ...) ; int i; !2 = !DILocation(...); ...; %buffer = alloca [256 x i8], align 8; ; The address of i is buffer+64.; call void @llvm.dbg.declare(metadata [256 x i8]* %buffer, metadata !3,; metadata !DIExpression(DW_OP_plus, 64)), !dbg !4; !3 = !DILocalVariable(name: ""i"", ...) ; int i; !4 = !DILocation(...). A frontend should generate exactly one call to ``llvm.dbg.declare`` at the point; of declaration of a source variable. Optimization passes that fully promote the; variable f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:8645,variab,variable,8645,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"m required version of CMake has been updated to 3.9 or newer to be; able to take advantage of new features such as native support for the CUDA; language, among other things. Please refer to CMake's release notes for further; information. The method to select the C++ standard has changed. Now the recommended way; to select the C++ standard is via the option `-DCMAKE_CXX_STANDARD=XX`, which; is the idiomatic way to do it in CMake. The old options still work, but have; been deprecated and will be removed in a future release. Build option descriptions have been updated to indicate which builtins require; an active network connection during the build. You can inspect the list of; options and their descriptions by running `cmake -LH $PWD` in the build; directory. The build system has been updated to remove most file globbing to improve; the reliability of incremental builds when source files are added or removed. A new check has been added to make ROOT fail during the configuration step; if incompatible versions of the Python interpreter and its libraries are; selected. The `all=ON` option now tries to enable more options. Some options had their; default value toggled to disabled, which affected `all=ON`. Now all options; are listed explicitly so that they are enabled regardless of their default; value. ### Builtins. The following builtins had their versions updated for this release:. * VecCore 0.5.2; * Vc 1.4.1; * XRootD 4.8.5; * OpenSSL 1.0.2q; * PCRE 8.42. ### Header location and `ROOT_GENERATE_DICTIONARY` / `ROOT_STANDARD_LIBRARY_PACKAGE`. A change in the argument handling of `ROOT_GENERATE_DICTIONARY` and `ROOT_STANDARD_LIBRARY_PACKAGE` might need your attention:; these macros now respect whether a header file was passed with its full relative path (the common case), or with a full path.; The latter allows to find headers at runtime - at the cost of a loss of relocatability: you cannot move the library containing; that dictionary to a different directory, because the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:23004,config,configuration,23004,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['config'],['configuration']
Modifiability,"m that class. So ``root[""!instanceof""][""Instruction""]``, for; example, would list the names of all the records deriving from the; class ``Instruction``. For each ``def`` record, the root object also has a key for the record; name. The corresponding value is a subsidiary object containing the; following fixed keys:. * ``!superclasses``: an array of strings giving the names of all the; classes that this record derives from. * ``!fields``: an array of strings giving the names of all the variables; in this record that were defined with the ``field`` keyword. * ``!name``: a string giving the name of the record. This is always; identical to the key in the JSON root object corresponding to this; record's dictionary. (If the record is anonymous, the name is; arbitrary.). * ``!anonymous``: a boolean indicating whether the record's name was; specified by the TableGen input (if it is ``false``), or invented by; TableGen itself (if ``true``). For each variable defined in a record, the ``def`` object for that; record also has a key for the variable name. The corresponding value; is a translation into JSON of the variable's value, using the; conventions described below. Some TableGen data types are translated directly into the; corresponding JSON type:. * A completely undefined value (e.g. for a variable declared without; initializer in some superclass of this record, and never initialized; by the record itself or any other superclass) is emitted as the JSON; ``null`` value. * ``int`` and ``bit`` values are emitted as numbers. Note that; TableGen ``int`` values are capable of holding integers too large to; be exactly representable in IEEE double precision. The integer; literal in the JSON output will show the full exact integer value.; So if you need to retrieve large integers with full precision, you; should use a JSON reader capable of translating such literals back; into 64-bit integers without losing precision, such as Python's; standard ``json`` module. * ``string`` and ``cod",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst:16632,variab,variable,16632,interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,2,['variab'],['variable']
Modifiability,"m these examples how to navigate in such; a multi-dimensional space of variables and unveil relations between; variables using n-tuples. ### Reading N-tuples. For completeness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the content of a n-tuple:; after loading the n-tuple, its branches are assigned to variables and; `GetEntry(long)` automatically fills them with the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file_advanced.C; ```. The `Branch()` function requires a pointer to a variable and a; definition of the variable type. The following table lists some of the possible; values.; Please note that ROOT is not checking the input and mistakes are likely; to result in serious problems. This holds especially if values are read; as another type than they have been written, e.g. when storing a; variable as float and reading it as double. List of variable types that can be used to define the type of a branch in ROOT:. type size C++ identifier; ------------------ -------- --------------- ------------; signed integer 32 bit int I; 64 bit long L; unsigned integer 32 bit unsigned int i; 64 bit unsigned long l; floating point 32 bit float F; 64 bit double D; boolean - bool O. ### Processing N-tuples Spanning over Several Files ###. Usually n-tuples or trees span over many files and it would be difficul",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:4859,variab,variables,4859,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['variab'],['variables']
Modifiability,"m-nm` does not print an address for any; symbol in an LLVM bitcode file, even symbols which are defined in the bitcode; file. OPTIONS; -------. .. program:: llvm-nm. .. option:: -B. Use BSD output format. Alias for ``--format=bsd``. .. option:: -X. Specify the type of XCOFF object file, ELF object file, or IR object file input; from command line or from archive files that llvm-nm should examine. The; mode must be one of the following:; ; 32; Process only 32-bit object files.; 64; Process only 64-bit object files.; 32_64; Process both 32-bit and 64-bit object files.; any; Process all the supported object files. On AIX OS, the default is to process 32-bit object files only and to ignore; 64-bit objects. The can be changed by setting the OBJECT_MODE environment; variable. For example, OBJECT_MODE=64 causes :program:`llvm-nm` to process; 64-bit objects and ignore 32-bit objects. The -X flag overrides the OBJECT_MODE; variable. On other operating systems, the default is to process all object files: the; OBJECT_MODE environment variable is not supported. .. option:: --debug-syms, -a. Show all symbols, even those usually suppressed. .. option:: --defined-only, -U. Print only symbols defined in this file. .. option:: --demangle, -C. Demangle symbol names. .. option:: --dynamic, -D. Display dynamic symbols instead of normal symbols. .. option:: --export-symbols. Print sorted symbols with their visibility (if applicable), with duplicates; removed. .. option:: --extern-only, -g. Print only symbols whose definitions are external; that is, accessible from; other files. .. option:: --format=<format>, -f. Select an output format; *format* may be *sysv*, *posix*, *darwin*, *bsd* or; *just-symbols*.; The default is *bsd*. .. option:: --help, -h. Print a summary of command-line options and their meanings. .. option:: -j. Print just the symbol names. Alias for `--format=just-symbols``. .. option:: --line-numbers, -l. Use debugging information to print the filenames and line numbers wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-nm.rst:3821,variab,variable,3821,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-nm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-nm.rst,1,['variab'],['variable']
Modifiability,"m. The string ""`->`"" in the comment field of the; members `*fTracks` and `*fH` instructs the automatic `Streamer` to; assume that the objects `*fTracks` and `*fH` are never null pointers and; that `fTracks->Streamer` can be used instead of the more time consuming; form `R__b << fTracks`. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; static TClonesArray *fgTracks;; static TH1F *fgHist;; // ... list of methods; ClassDef(Event,1) //Event structure; };; ```. ### The EventHeader Class. The `EventHeader` class (also defined in `Event.h`) does not inherit; from **`TObject`**. Beginning with ROOT 3.0, an object can be placed on; a branch even though it does not inherit from **`TObject`**. In previous; releases branches were restricted to objects inheriting from the; **`TObject`**. However, it has always been possible to write a class not; inheriting from **`TObject`** to a tree by encapsulating it in a; **`TObject`** descending class as is the case in `EventHeader` and; `Event`. ``` {.cpp}; class EventHeader {; private:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;; // ... list of methods; ClassDef(EventHeader,1) //Event Header; };; ```. ### The Track Class. The `Track` class descends from **`TObject`** since tracks are in a; **`TClonesArray`** (i.e. a ROOT collection class) and contains a; selection of basic types and an array of vertices. Its **`TObject`**; inheritance enables `Track` to be in a collection and in `Event` is a; **`TClonesArray`** of `Tracks`. ``` {.cpp}; class Track : public TObject {; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass squar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:60345,inherit,inheriting,60345,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['inherit'],['inheriting']
Modifiability,"m.gcread`` calls are replaced with the corresponding ``load``; instruction. * ``llvm.gcwrite`` calls are replaced with the corresponding ``store``; instruction. * No safe points are added to the code. * The stack map is not compiled into the executable. Using the LLVM makefiles, this code; can be compiled as a plugin using a simple makefile:. .. code-block:: make. # lib/MyGC/Makefile. LEVEL := ../..; LIBRARYNAME = MyGC; LOADABLE_MODULE = 1. include $(LEVEL)/Makefile.common. Once the plugin is compiled, code using it may be compiled using ``llc; -load=MyGC.so`` (though MyGC.so may have some other platform-specific; extension):. ::. $ cat sample.ll; define void @f() gc ""mygc"" {; entry:; ret void; }; $ llvm-as < sample.ll | llc -load=MyGC.so. It is also possible to statically link the collector plugin into tools, such as; a language-specific compiler front-end. .. _collector-algos:. Overview of available features; ------------------------------. ``GCStrategy`` provides a range of features through which a plugin may do useful; work. Some of these are callbacks, some are algorithms that can be enabled,; disabled, or customized. This matrix summarizes the supported (and planned); features and correlates them with the collection techniques which typically; require them. .. |v| unicode:: 0x2714; :trim:. .. |x| unicode:: 0x2718; :trim:. +------------+------+--------+----------+-------+---------+-------------+----------+------------+; | Algorithm | Done | Shadow | refcount | mark- | copying | incremental | threaded | concurrent |; | | | stack | | sweep | | | | |; +============+======+========+==========+=======+=========+=============+==========+============+; | stack map | |v| | | | |x| | |x| | |x| | |x| | |x| |; +------------+------+--------+----------+-------+---------+-------------+----------+------------+; | initialize | |v| | |x| | |x| | |x| | |x| | |x| | |x| | |x| |; | roots | | | | | | | | |; +------------+------+--------+----------+-------+---------+-------------+---",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:25872,plugin,plugin,25872,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['plugin'],['plugin']
Modifiability,"m.memcpy.i32(; i8* getelementptr ([10 x i8]* @out.4543, i32 0, i32 0),; i8* getelementptr ([7 x i8]* @""\01LC28700"", i32 0, i32 0), i32 7, i32 1) ; %101 = call@printf(i8* ... @out.4543, i32 0, i32 0)) nounwind . It is basically doing:. memcpy(globalarray, ""string"");; printf(..., globalarray);; ; Anyway, by knowing that printf just reads the memory and forward substituting; the string directly into the printf, this eliminates reads from globalarray.; Since this pattern occurs frequently in crafty (due to the ""DisplayTime"" and; other similar functions) there are many stores to ""out"". Once all the printfs; stop using ""out"", all that is left is the memcpy's into it. This should allow; globalopt to remove the ""stored only"" global. //===---------------------------------------------------------------------===//. This code:. define inreg i32 @foo(i8* inreg %p) nounwind {; %tmp0 = load i8* %p; %tmp1 = ashr i8 %tmp0, 5; %tmp2 = sext i8 %tmp1 to i32; ret i32 %tmp2; }. could be dagcombine'd to a sign-extending load with a shift.; For example, on x86 this currently gets this:. 	movb	(%eax), %al; 	sarb	$5, %al; 	movsbl	%al, %eax. while it could get this:. 	movsbl	(%eax), %eax; 	sarl	$5, %eax. //===---------------------------------------------------------------------===//. GCC PR31029:. int test(int x) { return 1-x == x; } // --> return false; int test2(int x) { return 2-x == x; } // --> return x == 1 ?. Always foldable for odd constants, what is the rule for even?. //===---------------------------------------------------------------------===//. PR 3381: GEP to field of size 0 inside a struct could be turned into GEP; for next field in struct (which is at same address). For example: store of float into { {{}}, float } could be turned into a store to; the float directly. //===---------------------------------------------------------------------===//. The arg promotion pass should make use of nocapture to make its alias analysis; stuff much more precise. //===-------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:42514,extend,extending,42514,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,2,['extend'],['extending']
Modifiability,"ma``); Break constructor initializers before the colon and commas, and align; the commas with the colon. .. code-block:: c++. Constructor(); : initializer1(); , initializer2(). * ``BCIS_AfterColon`` (in configuration: ``AfterColon``); Break constructor initializers after the colon and commas. .. code-block:: c++. Constructor() :; initializer1(),; initializer2(). .. _BreakInheritanceList:. **BreakInheritanceList** (``BreakInheritanceListStyle``) :versionbadge:`clang-format 7` :ref:`¶ <BreakInheritanceList>`; The inheritance list style to use. Possible values:. * ``BILS_BeforeColon`` (in configuration: ``BeforeColon``); Break inheritance list before the colon and after the commas. .. code-block:: c++. class Foo; : Base1,; Base2; {};. * ``BILS_BeforeComma`` (in configuration: ``BeforeComma``); Break inheritance list before the colon and commas, and align; the commas with the colon. .. code-block:: c++. class Foo; : Base1; , Base2; {};. * ``BILS_AfterColon`` (in configuration: ``AfterColon``); Break inheritance list after the colon and commas. .. code-block:: c++. class Foo :; Base1,; Base2; {};. * ``BILS_AfterComma`` (in configuration: ``AfterComma``); Break inheritance list only after the commas. .. code-block:: c++. class Foo : Base1,; Base2; {};. .. _BreakStringLiterals:. **BreakStringLiterals** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <BreakStringLiterals>`; Allow breaking string literals when formatting. In C, C++, and Objective-C:. .. code-block:: c++. true:; const char* x = ""veryVeryVeryVeryVeryVe""; ""ryVeryVeryVeryVeryVery""; ""VeryLongString"";. false:; const char* x =; ""veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString"";. In C# and Java:. .. code-block:: c++. true:; string x = ""veryVeryVeryVeryVeryVe"" +; ""ryVeryVeryVeryVeryVery"" +; ""VeryLongString"";. false:; string x =; ""veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString"";. C# interpolated strings are not broken. In Verilog:. .. code-block:: c++. true:; string x = {""veryVeryVeryVeryV",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:55549,config,configuration,55549,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,2,"['config', 'inherit']","['configuration', 'inheritance']"
Modifiability,"made; projectable and corresponding TEveElementListProjected class; introduced. This also fixed the problem with render-state not being; propagated to projected classes. The check whether to project a sub-tree of elements is still performed.; TEveGeoShapeProjected has been introduced to represent the 3D; projection of a TEveGeoShape (2D projection is handled by; TEvePolygonSetProjected). Points, lines and tracks use the same projected class for both 2D; and 3D projections. An example showing this functionality has been added as a new tab in; projection_prescale.C.; TEveManager now allows simultaneous usage of several objects; editors. Simply click on the top name-button in object editor to; create a standalone editor for this object in a separate window. This; facilitates operation when several objects need to be modifed in; parallel.; New tutorial alice_vsd.C has been added. It shows; how to read Visualization Summary Data files (VSD).; Code for operating three view configuration (3D / RPhi / Rhoz); has been extracted from alice_esd.C tutorial; into MultiView.C tutorial. This is now also used; by alice_vsd.C and can serve as an example to those that; need to implement similar functionality. Screenshot of calorimeters.C tutorial. Note the; individual tower selection propagated accross all the views. Screenshot of alice_vsd.C tutorial also showing the; functionality of the MultiView class. New title is also; visible in the GUI editor. Minor changes. Object editors in Eve now show the title as button.; ; Left mouse opens a floating editor that can be positioned; anywhere on the screen. This allows a user to have commonly used; editors always accessible. Maximum number of floating editors is; limited to 10.; Right mouse opens context menu for the object. In TEveFrambox add support for drawing of back-polygons for 3D; frame-boxes. Those should be transparent, otherwise the things inside; are not visible.; TEveRGBAPalette - implement additional flag fFixColorRange specif",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v526/index.html:3618,config,configuration,3618,graf3d/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v526/index.html,2,['config'],['configuration']
Modifiability,"make -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. If you want to use clang instead of GCC, you can add; ``-DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++``.; You can also use ``ccmake``, which provides a curses interface to configure; CMake variables. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using make:. .. code-block:: console. $ make check-all. Setup Clang Tooling Using CMake on Windows; ==========================================. For Windows developers, the Visual Studio project generators in CMake do; not support `CMAKE_EXPORT_COMPILE_COMMANDS; <https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html>`_.; However, the Ninja generator does support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate it. Next, assuming you already have Visual Studio installed on your machine, you; need to have the appropriate environment variables configured so that CMake; will locate the MSVC compiler for the Ninja generator. The `documentation; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#path_and_environment>`_; describes the necessary environment variable settings, but the simplest thing; is to use a `developer command-prompt window; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_prompt_shortcuts>`_; or call a `developer command file; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_file_locations>`_; to s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:2326,variab,variable,2326,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,1,['variab'],['variable']
Modifiability,"makes the command line; more uniform and reduces the amount of custom, manually written code. Remember; that the ``-cc1`` command line interface is intended only for Clang developers,; meaning it does not need to mirror the driver interface, maintain backward; compatibility or be compatible with GCC. If the option semantics cannot be encoded via marshalling annotations, you can; resort to parsing/serializing the command line arguments manually:. .. code-block:: diff. // CompilerInvocation.cpp. static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args /*...*/) {; // ... + Opts.PassPlugins = Args.getAllArgValues(OPT_fpass_plugin_EQ);; }. static void GenerateCodeGenArgs(const CodeGenOptions &Opts,; SmallVectorImpl<const char *> &Args,; CompilerInvocation::StringAllocator SA /*...*/) {; // ... + for (const std::string &PassPlugin : Opts.PassPlugins); + GenerateArg(Args, OPT_fpass_plugin_EQ, PassPlugin, SA);; }. Finally, you can specify the argument on the command line:; ``clang -fpass-plugin=a -fpass-plugin=b`` and use the new member variable as; desired. .. code-block:: diff. void EmitAssemblyHelper::EmitAssemblyWithNewPassManager(/*...*/) {; // ...; + for (auto &PluginFN : CodeGenOpts.PassPlugins); + if (auto PassPlugin = PassPlugin::Load(PluginFN)); + PassPlugin->registerPassBuilderCallbacks(PB);; }. .. _OptionMarshalling:. Option Marshalling Infrastructure; ---------------------------------. The option marshalling infrastructure automates the parsing of the Clang; ``-cc1`` frontend command line arguments into ``CompilerInvocation`` and their; generation from ``CompilerInvocation``. The system replaces lots of repetitive; C++ code with simple, declarative tablegen annotations and it's being used for; the majority of the ``-cc1`` command line interface. This section provides an; overview of the system. **Note:** The marshalling infrastructure is not intended for driver-only; options. Only options of the ``-cc1`` frontend need to be marshalled to/from; ``Compiler",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:33616,plugin,plugin,33616,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,3,"['plugin', 'variab']","['plugin', 'variable']"
Modifiability,"mally encoded; as unsigned VBRs. However, forward references are rare, except in the; case of phi instructions. For phi instructions, operands are encoded as; `Signed VBRs`_ to deal with forward references. In version 2, the meaning of module records ``FUNCTION``, ``GLOBALVAR``,; ``ALIAS``, ``IFUNC`` and ``COMDAT`` change such that the first two operands; specify an offset and size of a string in a string table (see `STRTAB_BLOCK; Contents`_), the function name is removed from the ``FNENTRY`` record in the; value symbol table, and the top-level ``VALUE_SYMTAB_BLOCK`` may only contain; ``FNENTRY`` records. MODULE_CODE_TRIPLE Record; ^^^^^^^^^^^^^^^^^^^^^^^^^. ``[TRIPLE, ...string...]``. The ``TRIPLE`` record (code 2) contains a variable number of values representing; the bytes of the ``target triple`` specification string. MODULE_CODE_DATALAYOUT Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[DATALAYOUT, ...string...]``. The ``DATALAYOUT`` record (code 3) contains a variable number of values; representing the bytes of the ``target datalayout`` specification string. MODULE_CODE_ASM Record; ^^^^^^^^^^^^^^^^^^^^^^. ``[ASM, ...string...]``. The ``ASM`` record (code 4) contains a variable number of values representing; the bytes of ``module asm`` strings, with individual assembly blocks separated; by newline (ASCII 10) characters. .. _MODULE_CODE_SECTIONNAME:. MODULE_CODE_SECTIONNAME Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[SECTIONNAME, ...string...]``. The ``SECTIONNAME`` record (code 5) contains a variable number of values; representing the bytes of a single section name string. There should be one; ``SECTIONNAME`` record for each section name referenced (e.g., in global; variable or function ``section`` attributes) within the module. These records; can be referenced by the 1-based index in the *section* fields of ``GLOBALVAR``; or ``FUNCTION`` records. MODULE_CODE_DEPLIB Record; ^^^^^^^^^^^^^^^^^^^^^^^^^. ``[DEPLIB, ...string...]``. The ``DEPLIB`` record (code 6) contains a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:25673,variab,variable,25673,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability,"mand; default constructor creates two dummy histograms; can now be filled with weights (only Bayesian methods and the normal; approximation are supported) ; update TEfficiency::SavePrimitive to store also the set bits. TGraphAsymmErrors. add option to TGraphAsymmErrors::Divide for interpreting the given; histograms as ratio of Poisson means. TMultiGraph. The following macro did not show the x-axis in TimeDisplay mode. The; mg->GetYaxis()->UnZoom(); command erased the TimeDisplay attribute of; the axis. (fix from beischer@physik.rwth-aachen.de). {; TMultiGraph* mg = new TMultiGraph;; TGraph* g = new TGraph;; for (int i = 0; i < 100; i++) g->SetPoint(i, 1289420808+i, i+2);; mg->Add(g, ""P"");; mg->Draw(""AP"");; mg->GetXaxis()->SetTimeDisplay(1);; mg->GetYaxis()->UnZoom();; gPad->Modified();; gPad->Update();; }. TPaletteAxis. In TPaletteAxis::Paint() now makes sure the min and max of the; palette are not 0 when the histogram content is 0. on Ubuntu the following macro crashed. A char variable was too small. {; TCanvas *tmp = new TCanvas();; TH2F *h1 = new TH2F(""h1"",""h1"",40,0.,10.,40,1.e-2,1.e2);; h1->Fill(5,10);; h1->Draw(""COLZ"");; tmp->SetLogz();; h1->GetZaxis()->SetNdivisions(110,kFALSE);; }. THistPainter. The option E0 forces the error bars drawing even if the data point are; outside the plot frame. This option did not clip the error bars correctly. Make sure the unique canvas name generated in SetShowProjection; starts with a letter, and not with a number, to avoid to generate wrong macro; when the canvas is saved as a .C file. TGraphPainter. In TGraphPainter::PaintGraphErrors and related functions, the caps; that are drawn when option ""[]"" is specified are drawn as a sequence of three; separate lines. This results in an ugly concave jag at each corner. The caps are; now drawn using TPad::PaintPolyLine, the default miter line joins makes those; jags go away. TPainter3dAlgorithms. Protection against possible NaN added. The following macro produced wrong; plots. {; TCanv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html:1870,variab,variable,1870,hist/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v532/index.html,2,['variab'],['variable']
Modifiability,"master/) for; examples. The summary itself should not exceed 50 characters (excluding the scope tag), be meaningful (i.e., it; describes the change) and should be written in the; [present imperative mood](https://git.kernel.org/pub/scm/git/git.git/tree/Documentation/SubmittingPatches?id=HEAD#n239); (e.g. `Add this awesome feature` instead of `Adds this awesome feature` or `Added this awesome feature`). The commit message that follow the summary can be used to provide more context to the change.; It should describe the **why**, rather than the **what** and **how** (we can gather this from the commit summary and the; change diff, respectively).; The commit message should be wrapped at 72 characters. > [!TIP]; > We provide a commit message template to help with following the above guidelines. It can be found in the root of this; > repository as [`.git-commit-template`](https://github.com/root-project/root/blob/master/.git-commit-template),; > and can be set to automatically be used for every commit with the following command:; > ```sh; > $ git config commit.template .git-commit-template; > ```. ## Your Pull Request. > [!NOTE]; > For the mechanics on how to create pull requests, please visit; > [this page](https://root.cern/for_developers/creating_pr). The title of your PR follows the same principle as the commit summary. If your PR only involves one commit, you can; reuse this summary. For non-functional changes (e.g. to the documentation) or changes for which you want to; **temporarily** prevent Jenkins from being triggered (e.g., for a draft PR), use `[skip-CI]` as the first tag.; Note that for functional changes this tag needs to be removed and it has to pass the CI before merging to ensure; the change does not break anything. The PR description describes (and in case of multiple commits, summarizes) the change in more detail.; Again, try to describe the **why** (and in this case, to a lesser extent the **what**), rather than the **how**. If your PR is related to an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md:3845,config,config,3845,CONTRIBUTING.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md,1,['config'],['config']
Modifiability,"may be executing on different SAs) of an agent can be; reordered relative to each other. A ``s_waitcnt vmcnt(0) & vscnt(0)`` is; required to ensure synchronization between vector memory operations of; different SAs. It ensures a previous vector memory operation has completed; before executing a subsequent vector memory and so can be used to meet the; requirements of acquire, release and sequential consistency.; * The L2 cache can be kept coherent with other agents on some targets, or ranges; of virtual addresses can be set up to bypass it to ensure system coherence.; * On GFX10.3 and GFX11 a memory attached last level (MALL) cache exists for GPU memory.; The MALL cache is fully coherent with GPU memory and has no impact on system; coherence. All agents (GPU and CPU) access GPU memory through the MALL cache. Scalar memory operations are only used to access memory that is proven to not; change during the execution of the kernel dispatch. This includes constant; address space and global address space for program scope ``const`` variables.; Therefore, the kernel machine code does not have to maintain the scalar cache to; ensure it is coherent with the vector caches. The scalar and vector caches are; invalidated between kernel dispatches by CP since constant address space data; may change between kernel dispatch executions. See; :ref:`amdgpu-amdhsa-memory-spaces`. The one exception is if scalar writes are used to spill SGPR registers. In this; case the AMDGPU backend ensures the memory location used to spill is never; accessed by vector memory operations at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:340187,variab,variables,340187,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['variab'],['variables']
Modifiability,"mber``, ``tag: DW_TAG_inheritance``, or; ``tag: DW_TAG_friend``; or :ref:`subprograms <DISubprogram>` with; ``isDefinition: false``. .. _DISubrange:. DISubrange; """""""""""""""""""". ``DISubrange`` nodes are the elements for ``DW_TAG_array_type`` variants of; :ref:`DICompositeType`. - ``count: -1`` indicates an empty array.; - ``count: !10`` describes the count with a :ref:`DILocalVariable`.; - ``count: !12`` describes the count with a :ref:`DIGlobalVariable`. .. code-block:: text. !0 = !DISubrange(count: 5, lowerBound: 0) ; array counting from 0; !1 = !DISubrange(count: 5, lowerBound: 1) ; array counting from 1; !2 = !DISubrange(count: -1) ; empty array. ; Scopes used in rest of example; !6 = !DIFile(filename: ""vla.c"", directory: ""/path/to/file""); !7 = distinct !DICompileUnit(language: DW_LANG_C99, file: !6); !8 = distinct !DISubprogram(name: ""foo"", scope: !7, file: !6, line: 5). ; Use of local variable as count value; !9 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed); !10 = !DILocalVariable(name: ""count"", scope: !8, file: !6, line: 42, type: !9); !11 = !DISubrange(count: !10, lowerBound: 0). ; Use of global variable as count value; !12 = !DIGlobalVariable(name: ""count"", scope: !8, file: !6, line: 22, type: !9); !13 = !DISubrange(count: !12, lowerBound: 0). .. _DIEnumerator:. DIEnumerator; """""""""""""""""""""""". ``DIEnumerator`` nodes are the elements for ``DW_TAG_enumeration_type``; variants of :ref:`DICompositeType`. .. code-block:: text. !0 = !DIEnumerator(name: ""SixKind"", value: 7); !1 = !DIEnumerator(name: ""SevenKind"", value: 7); !2 = !DIEnumerator(name: ""NegEightKind"", value: -8). DITemplateTypeParameter; """""""""""""""""""""""""""""""""""""""""""""". ``DITemplateTypeParameter`` nodes represent type parameters to generic source; language constructs. They are used (optionally) in :ref:`DICompositeType` and; :ref:`DISubprogram` ``templateParams:`` fields. .. code-block:: text. !0 = !DITemplateTypeParameter(name: ""Ty"", type: !1). DITemplateValueParameter; """""""""""""""""""""""""""""""""""""""""""""""". ``DIT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:254592,variab,variable,254592,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"mbers. It was invented in 1977 by John Tukey. The five numbers are:. 1. The minimum value of the distribution D (Min).; 2. The lower quartile (Q1): 25% of the data points in D are less than Q1.; 3. The median (M): 50% of the data points in D are less than M.; 4. The upper quartile (Q3): 75% of the data points in D are less than Q3.; 5. The maximum value of the distribution D (Max). ![A box plot describes a distribution with only five numbers. ](pictures/bp1.png). In ROOT Box Plots (Candle Plots) can be produced from a TTree using the; “candle” option in TTree::Draw(). ``` {.cpp}; tree->Draw(“px:cos(py):sin(pz)”,””,”candle”);; ```. ### Using TTree::Scan; \index{tree!scan}. `TTree::Scan` can be used to print the content of the tree's entries; optional passing a selection. ``` {.cpp}; root[] MyTree->Scan();; ```. will print the first 8 variables of the tree. ``` {.cpp}; root[] MyTree->Scan(""*"");; ```. will print all the variable of the tree. Specific variables of the tree can be explicit selected by list them in; column separated list:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"");; ```. will print the values of `var1`, `var2` and `var3`. A selection can be; applied in the second argument:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"",""var1==0"");; ```. will print the values of `var1`, `var2` and `var3` for the entries where; var1 is exactly 0. `TTree::Scan` returns the number of entries passing the selection. By; default 50 rows are shown before `TTree::Scan` pauses and ask you to; press the Enter key to see the next 50 rows. You can change the default; number of rows to be shown before \<CR\> via; `mytree->SetScanfield(maxrows)` where maxrows is 50 by default. If; maxrows is set to 0 all rows of the **`Tree`** are shown. This option is; interesting when dumping the contents of a Tree to an ascii file, eg; from the command line:. ``` {.cpp}; root[] tree->SetScanField(0);; root[] tree->Scan(""*""); >tree.log; ```. will create a file `tree.log`. Arrays (within an e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:104970,variab,variables,104970,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,mbiguity; Unknown. 2260; CD5; Explicit specializations of deleted member functions; Unknown. 2261; extension; Explicit instantiation of in-class friend definition; Extension. 2262; C++17; Attributes for asm-definition; Unknown. 2263; drafting; Default argument instantiation for friends; Not resolved. 2264; drafting; Memberwise copying with indeterminate value; Not resolved. 2265; drafting; Delayed pack expansion and member redeclarations; Not resolved. 2266; CD5; Has dependent type vs is type-dependent; Unknown. 2267; CD5; Copy-initialization of temporary in reference direct-initialization; No. 2268; C++17; Unions with mutable members in constant expressions revisited; Unknown. 2269; dup; Additional recursive references in aggregate DMIs; Unknown. 2270; NAD; Non-inline functions and explicit instantiation declarations; Unknown. 2271; C++17; Aliasing this; Unknown. 2272; C++17; Implicit initialization of aggregate members of reference type; Unknown. 2273; CD5; Inheriting constructors vs implicit default constructor; Unknown. 2274; NAD; Generic lambda capture vs constexpr if; Unknown. 2275; drafting; Type-dependence of function template; Not resolved. 2276; C++17; Dependent noexcept and function type-dependence; Unknown. 2277; CD5; Ambiguity inheriting constructors with default arguments; Unknown. 2278; CD5; Copy elision in constant expressions reconsidered; Unknown. 2279; NAD; Multiple attribute-specifiers in one attribute-list; Unknown. 2280; C++20; Matching a usual deallocation function with placement new; Unknown. 2281; drafting; Consistency of aligned operator delete replacement; Not resolved. 2282; C++20; Consistency with mismatched aligned/non-over-aligned allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvert,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:154925,Inherit,Inheriting,154925,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Inherit'],['Inheriting']
Modifiability,"mble llvm+clang+libcxx at a given revision. Currently; ^^^^^^^^^. ::. svn co https://llvm.org/svn/llvm-project/llvm/trunk llvm -r $REVISION; cd llvm/tools; svn co https://llvm.org/svn/llvm-project/clang/trunk clang -r $REVISION; cd ../projects; svn co https://llvm.org/svn/llvm-project/libcxx/trunk libcxx -r $REVISION. Or using git-svn::. git clone https://llvm.org/git/llvm.git; cd llvm/; git svn init https://llvm.org/svn/llvm-project/llvm/trunk --username=<username>; git config svn-remote.svn.fetch :refs/remotes/origin/main; git svn rebase -l; git checkout `git svn find-rev -B r258109`; cd tools; git clone https://llvm.org/git/clang.git; cd clang/; git svn init https://llvm.org/svn/llvm-project/clang/trunk --username=<username>; git config svn-remote.svn.fetch :refs/remotes/origin/main; git svn rebase -l; git checkout `git svn find-rev -B r258109`; cd ../../projects/; git clone https://llvm.org/git/libcxx.git; cd libcxx; git svn init https://llvm.org/svn/llvm-project/libcxx/trunk --username=<username>; git config svn-remote.svn.fetch :refs/remotes/origin/main; git svn rebase -l; git checkout `git svn find-rev -B r258109`. Note that the list would be longer with more sub-projects. .. _workflow-monocheckout-multicommit:. Monorepo Variant; ^^^^^^^^^^^^^^^^. The repository contains natively the source for every sub-projects at the right; revision, which makes this straightforward::. git clone https://github.com/llvm/llvm-project.git; cd llvm-projects; git checkout $REVISION. As before, at this point clang, llvm, and libcxx are stored in directories; alongside each other. .. _workflow-cross-repo-commit:. Commit an API Change in LLVM and Update the Sub-projects; --------------------------------------------------------. Today this is possible, even though not common (at least not documented) for; subversion users and for git-svn users. For example, few Git users try to update; LLD or Clang in the same commit as they change an LLVM API. The multirepo variant does not address",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:16346,config,config,16346,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['config'],['config']
Modifiability,"mdgpu-dwarf-extensions` section gives an overview of; the extensions devised to address the missing features. The extensions seek to; be general in nature and backwards compatible with DWARF Version 5. Their goal; is to be applicable to meeting the needs of any heterogeneous system and not be; vendor or architecture specific. That is followed by appendix; :ref:`amdgpu-dwarf-changes-relative-to-dwarf-version-5` which contains the; textual changes for the extensions relative to the DWARF Version 5 standard.; There are a number of notes included that raise open questions, or provide; alternative approaches that may be worth considering. Then appendix; :ref:`amdgpu-dwarf-further-examples` links to the AMD GPU specific usage of the; extensions that includes an example. Finally, appendix; :ref:`amdgpu-dwarf-references` provides references to further information. .. _amdgpu-dwarf-extensions:. 2. Extensions; =============. The extensions continue to evolve through collaboration with many individuals and; active prototyping within the GDB debugger and LLVM compiler. Input has also; been very much appreciated from the developers working on the Perforce TotalView; HPC Debugger and GCC compiler. The inputs provided and insights gained so far have been incorporated into this; current version. The plan is to participate in upstreaming the work and; addressing any feedback. If there is general interest then some or all of these; extensions could be submitted as future DWARF standard proposals. The general principles in designing the extensions have been:. 1. Be backwards compatible with the DWARF Version 5 [:ref:`DWARF; <amdgpu-dwarf-DWARF>`] standard. 2. Be vendor and architecture neutral. They are intended to apply to other; heterogeneous hardware devices including GPUs, DSPs, FPGAs, and other; specialized hardware. These collectively include similar characteristics and; requirements as AMDGPU devices. 3. Provide improved optimization support for non-GPU code. For example, some; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:3216,evolve,evolve,3216,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['evolve'],['evolve']
Modifiability,"me T>; void baz(T t); requires C<T> {... * ``RCPS_SingleLine`` (in configuration: ``SingleLine``); Try to put everything in the same line if possible. Otherwise normal; line breaking rules take over. .. code-block:: c++. // Fitting:; template <typename T> requires C<T> struct Foo {... template <typename T> requires C<T> void bar(T t) {... template <typename T> void bar(T t) requires C<T> {... // Not fitting, one possible example:; template <typename LongName>; requires C<LongName>; struct Foo {... template <typename LongName>; requires C<LongName>; void bar(LongName ln) {. template <typename LongName>; void bar(LongName ln); requires C<LongName> {. .. _RequiresExpressionIndentation:. **RequiresExpressionIndentation** (``RequiresExpressionIndentationKind``) :versionbadge:`clang-format 16` :ref:`¶ <RequiresExpressionIndentation>`; The indentation used for requires expression bodies. Possible values:. * ``REI_OuterScope`` (in configuration: ``OuterScope``); Align requires expression body relative to the indentation level of the; outer scope the requires expression resides in.; This is the default. .. code-block:: c++. template <typename T>; concept C = requires(T t) {; ...; }. * ``REI_Keyword`` (in configuration: ``Keyword``); Align requires expression body relative to the ``requires`` keyword. .. code-block:: c++. template <typename T>; concept C = requires(T t) {; ...; }. .. _SeparateDefinitionBlocks:. **SeparateDefinitionBlocks** (``SeparateDefinitionStyle``) :versionbadge:`clang-format 14` :ref:`¶ <SeparateDefinitionBlocks>`; Specifies the use of empty lines to separate definition blocks, including; classes, structs, enums, and functions. .. code-block:: c++. Never v.s. Always; #include <cstring> #include <cstring>; struct Foo {; int a, b, c; struct Foo {; }; int a, b, c;; namespace Ns { };; class Bar {; public: namespace Ns {; struct Foobar { class Bar {; int a; public:; int b; struct Foobar {; }; int a;; private: int b;; int t; };; int method1() {; // ... private",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:106418,config,configuration,106418,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"me as ``SBPO_ControlStatements`` except this option doesn't apply to; ForEach and If macros. This is useful in projects where ForEach/If; macros are treated as function calls instead of control statements.; ``SBPO_ControlStatementsExceptForEachMacros`` remains an alias for; backward compatibility. .. code-block:: c++. void f() {; Q_FOREACH(...) {; f();; }; }. * ``SBPO_NonEmptyParentheses`` (in configuration: ``NonEmptyParentheses``); Put a space before opening parentheses only if the parentheses are not; empty i.e. '()'. .. code-block:: c++. void() {; if (true) {; f();; g (x, y, z);; }; }. * ``SBPO_Always`` (in configuration: ``Always``); Always put a space before opening parentheses, except when it's; prohibited by the syntax rules (in function-like macro definitions) or; when determined by other style rules (after unary operators, opening; parentheses, etc.). .. code-block:: c++. void f () {; if (true) {; f ();; }; }. * ``SBPO_Custom`` (in configuration: ``Custom``); Configure each individual space before parentheses in; ``SpaceBeforeParensOptions``. .. _SpaceBeforeParensOptions:. **SpaceBeforeParensOptions** (``SpaceBeforeParensCustom``) :versionbadge:`clang-format 14` :ref:`¶ <SpaceBeforeParensOptions>`; Control of individual space before parentheses. If ``SpaceBeforeParens`` is set to ``Custom``, use this to specify; how each individual space before parentheses case should be handled.; Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; SpaceBeforeParens: Custom; SpaceBeforeParensOptions:; AfterControlStatements: true; AfterFunctionDefinitionName: true. Nested configuration flags:. Precise control over the spacing before parentheses. .. code-block:: c++. # Should be declared this way:; SpaceBeforeParens: Custom; SpaceBeforeParensOptions:; AfterControlStatements: true; AfterFunctionDefinitionName: true. * ``bool AfterControlStatements`` If ``true``, put space between control statement keywords; (for/if/while...) and opening parentheses. .. code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:118023,config,configuration,118023,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"me found; in the executable instead::. x86_64-pc-linux-gnu-clang-g++.cfg. Note that options such as ``--driver-mode=``, ``--target=``, ``-m32`` affect; the search algorithm. For example, the aforementioned executable called with; ``-m32`` argument will instead search for::. i386-pc-linux-gnu-clang++.cfg. If none of the aforementioned files are found, the driver will instead search; for separate driver and target configuration files and attempt to load both.; The former is named ``<driver>.cfg`` while the latter is named; ``<triple>.cfg``. Similarly to the previous variants, the canonical driver name; will be preferred, and the compiler will fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:34059,config,configuration,34059,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['configuration']
Modifiability,"me of value produced. High Level Structure; ====================. Module Structure; ----------------. LLVM programs are composed of ``Module``'s, each of which is a; translation unit of the input programs. Each module consists of; functions, global variables, and symbol table entries. Modules may be; combined together with the LLVM linker, which merges function (and; global variable) definitions, resolves forward declarations, and merges; symbol table entries. Here is an example of the ""hello world"" module:. .. code-block:: llvm. ; Declare the string constant as a global constant.; @.str = private unnamed_addr constant [13 x i8] c""hello world\0A\00"". ; External declaration of the puts function; declare i32 @puts(ptr nocapture) nounwind. ; Definition of main function; define i32 @main() {; ; Call puts function to write out the string to stdout.; call i32 @puts(ptr @.str); ret i32 0; }. ; Named metadata; !0 = !{i32 42, null, !""string""}; !foo = !{!0}. This example is made up of a :ref:`global variable <globalvars>` named; ""``.str``"", an external declaration of the ""``puts``"" function, a; :ref:`function definition <functionstructure>` for ""``main``"" and; :ref:`named metadata <namedmetadatastructure>` ""``foo``"". In general, a module is made up of a list of global values (where both; functions and global variables are global values). Global values are; represented by a pointer to a memory location (in this case, a pointer; to an array of char, and a pointer to a function), and have one of the; following :ref:`linkage types <linkage>`. .. _linkage:. Linkage Types; -------------. All Global Variables and Functions have one of the following types of; linkage:. ``private``; Global values with ""``private``"" linkage are only directly; accessible by objects in the current module. In particular, linking; code into a module with a private global value may cause the; private to be renamed as necessary to avoid collisions. Because the; symbol is private to the module, all references ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:6691,variab,variable,6691,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"me that the LLVM sources are at ../llvm; $ cmake -GNinja ../llvm -DCMAKE_BUILD_TYPE=Release \; -DCMAKE_C_FLAGS_RELEASE=""-fxray-instrument"" -DCMAKE_CXX_FLAGS=""-fxray-instrument"" \; # Once this finishes, we should build llc; $ ninja llc. To verify that we have an XRay instrumented binary, we can use ``objdump`` to; look for the ``xray_instr_map`` section. ::. $ objdump -h -j xray_instr_map ./bin/llc; ./bin/llc: file format elf64-x86-64. Sections:; Idx Name Size VMA LMA File off Algn; 14 xray_instr_map 00002fc0 00000000041516c6 00000000041516c6 03d516c6 2**0; CONTENTS, ALLOC, LOAD, READONLY, DATA. Getting Traces; --------------. By default, XRay does not write out the trace files or patch the application; before main starts. If we run ``llc`` it should work like a normally built; binary. If we want to get a full trace of the application's operations (of the; functions we do end up instrumenting with XRay) then we need to enable XRay; at application start. To do this, XRay checks the ``XRAY_OPTIONS`` environment; variable. ::. # The following doesn't create an XRay trace by default.; $ ./bin/llc input.ll. # We need to set the XRAY_OPTIONS to enable some features.; $ XRAY_OPTIONS=""patch_premain=true xray_mode=xray-basic verbosity=1"" ./bin/llc input.ll; ==69819==XRay: Log file in 'xray-log.llc.m35qPB'. At this point we now have an XRay trace we can start analysing. The ``llvm-xray`` Tool; ----------------------. Having a trace then allows us to do basic accounting of the functions that were; instrumented, and how much time we're spending in parts of the code. To make; sense of this data, we use the ``llvm-xray`` tool which has a few subcommands; to help us understand our trace. One of the things we can do is to get an accounting of the functions that have; been instrumented. We can see an example accounting with ``llvm-xray account``:. ::. $ llvm-xray account xray-log.llc.m35qPB --top=10 --sort=sum --sortorder=dsc --instr_map=./bin/llc; Functions with latencies: 29; funci",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRayExample.rst:1930,variab,variable,1930,interpreter/llvm-project/llvm/docs/XRayExample.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRayExample.rst,1,['variab'],['variable']
Modifiability,"members is displayed: you can e.g. show or hide non-public methods. If you; just want to use ROOT you should hide them - you cannot access protected or private; members anyway. And you can select whether member that are inherited from a base class; should be shown. Again, if you just want to use ROOT you should probably show them,; as you often want to use them whether they are defined in the current class or in one; of its base classes. Whatever you set these options to should be stored in a cookie,; so you will have the same setting next time you look at the class documentation. Access (public / protected / private); Not all members are available to everyone (check any C++ introduction to learn why).; Public members have a green bar on their left, protected ones have a yellow one, and; private members are marked with a red bar. Of course you won't see any protected or; private members if you hide them in the display options. Inheritance; You can often access members of a class's base classes, just as if they are defined; in the derived class. A histogram,; for example, has a name, and you can access it using GetName() as defined in its base; class TNamed. If you want to see; all available members, and not just the ones defined in the current class, in the; display options. They will be prefixed with the name of; the class they are defined in. Class Charts; The class charts are shown in a tabbed box; click on the names ontop to select a tab. Inheritance; This chart shows the inheritance hierarchy for the current class. Arrows point to; base classes. You can click the classes to get to their reference page. Inherited Members; The second chart shows a list of all members of all base classes. You can see at what; level they are defined or at what level they are defined. Members that are accessible; (public) have a green background, protected ones have a yellow background, and private; members have a red background. Members with a dark gray background are re-implemente",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html:6421,Inherit,Inheritance,6421,etc/html/HELP.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html,1,['Inherit'],['Inheritance']
Modifiability,mensional plots of p.d.f.s and datasets; rf310_sliceplot.C -Projecting p.d.f and data slices in discrete observables; rf311_rangeplot.C -Projecting p.d.f and data ranges in continuous observables; rf312_multirangefit.C - Performing fits in multiple (disjoint) ranges in one or more dimensions; rf313_paramranges.C - Working with parameterized ranges to define non-rectangular regions; rf314_paramfitrange.C - Working with parameterized ranges in a fit.; rf315_projectpdf.C - Marginizalization of multi-dimensional p.d.f.s through integration; rf316_llratioplot.C - Using the likelihood ratio technique to construct a signal enhanced 1-D projection of a multi-dimensional p.d.f.; ; DATA AND CATEGORIES. rf401_importttreethx.C -Overview of advanced option for importing data from ROOT TTree and THx histograms; rf402_datahandling.C - Tools for manipulation of (un)binned datasets; rf403_weightedevts.C - Using weights in unbinned datasets; rf404_categories.C - Working with RooCategory objects to describe discrete variables; rf405_realtocatfuncs.C - Demonstration of real-->discrete mapping functions; rf406_cattocatfuncs.C - Demonstration of discrete-->discrete (invertable) functions; rf407_latextables.C - Latex printing of lists and sets of RooArgSets; ; ORGANIZATION AND SIMULTANEOUS FITS. rf501_simultaneouspdf.C - Using simultaneous p.d.f.s to describe simultaneous fits to multiple datasets; rf502_wspacewrite.C - Creating and writing a workspace; rf503_wspaceread.C - Reading and using a workspace; rf504_simwstool.C - Using RooSimWSTool to construct a simultaneous p.d.f that is built of variations of an input p.d.f; rf505_asciicfg.C - Reading and writing ASCII configuration files; rf506_msgservice.C - Tuning and customizing the RooFit message logging facility; rf507_debugtools.C - Using the RooFit memory tracing debug tool; rf508_listsetmanip.C - RooArgSet and RooArgList tools and tricks; ; LIKELIHOOD AND MINIMIZATION. rf601_intminuit.C - Interactive minimization with MINUIT; rf602_,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:3876,variab,variables,3876,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,2,['variab'],['variables']
Modifiability,"ment-tracking; ```; we get:; ```; define dso_local noundef i32 @_Z3funi(i32 noundef %a) #0 !dbg !8 {; entry:; %a.addr = alloca i32, align 4, !DIAssignID !13; call void @llvm.dbg.assign(metadata i1 undef, metadata !14, metadata !DIExpression(), metadata !13, metadata i32* %a.addr, metadata !DIExpression()), !dbg !15; store i32 %a, i32* %a.addr, align 4, !DIAssignID !16; call void @llvm.dbg.assign(metadata i32 %a, metadata !14, metadata !DIExpression(), metadata !16, metadata i32* %a.addr, metadata !DIExpression()), !dbg !15; %0 = load i32, i32* %a.addr, align 4, !dbg !17; ret i32 %0, !dbg !18; }. ...; !13 = distinct !DIAssignID(); !14 = !DILocalVariable(name: ""a"", ...); ...; !16 = distinct !DIAssignID(); ```. The first `llvm.dbg.assign` refers to the `alloca` through `!DIAssignID !13`,; and the second refers to the `store` through `!DIAssignID !16`. ### Store-like instructions. In the absence of a linked `llvm.dbg.assign`, a store to an address that is; known to be the backing storage for a variable is considered to represent an; assignment to that variable. This gives us a safe fall-back in cases where `llvm.dbg.assign` intrinsics have; been deleted, the `DIAssignID` attachment on the store has been dropped, or the; optimiser has made a once-indirect store (not tracked with Assignment Tracking); direct. ### Middle-end: Considerations for pass-writers. #### Non-debug instruction updates. **Cloning** an instruction: nothing new to do. Cloning automatically clones a; `DIAssignID` attachment. Multiple instructions may have the same `DIAssignID`; instruction. In this case, the assignment is considered to take place in; multiple positions in the program. **Moving** a non-debug instruction: nothing new to do. Instructions linked to an; `llvm.dbg.assign` have their initial IR position marked by the position of the; `llvm.dbg.assign`. **Deleting** a non-debug instruction: nothing new to do. Simple DSE does not; require any change; it’s safe to delete an instruction with a `D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:5339,variab,variable,5339,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,2,['variab'],['variable']
Modifiability,"ment. .. code-block:: c++. if (a) return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_OnlyFirstIf`` (in configuration: ``OnlyFirstIf``); Put short ifs, but not else ifs nor else statements, on the same line. .. code-block:: c++. if (a) return;. if (b) return;; else if (b); return;; else; return;. if (c) return;; else {; return;; }. * ``SIS_AllIfsAndElse`` (in configuration: ``AllIfsAndElse``); Always put short ifs, else ifs and else statements on the same; line. .. code-block:: c++. if (a) return;. if (b) return;; else return;. if (c) return;; else {; return;; }. .. _AllowShortLambdasOnASingleLine:. **AllowShortLambdasOnASingleLine** (``ShortLambdaStyle``) :versionbadge:`clang-format 9` :ref:`¶ <AllowShortLambdasOnASingleLine>`; Dependent on the value, ``auto lambda []() { return 0; }`` can be put on a; single line. Possible values:. * ``SLS_None`` (in configuration: ``None``); Never merge lambdas into a single line. * ``SLS_Empty`` (in configuration: ``Empty``); Only merge empty lambdas. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) {; return a;; };. * ``SLS_Inline`` (in configuration: ``Inline``); Merge lambda into a single line if the lambda is argument of a function. .. code-block:: c++. auto lambda = [](int x, int y) {; return x < y;; };; sort(a.begin(), a.end(), [](int x, int y) { return x < y; });. * ``SLS_All`` (in configuration: ``All``); Merge all lambdas fitting on a single line. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) { return a; };. .. _AllowShortLoopsOnASingleLine:. **AllowShortLoopsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <AllowShortLoopsOnASingleLine>`; If ``true``, ``while (true) continue;`` can be put on a single; line. .. _AlwaysBreakAfterDefinitionReturnType:. **AlwaysBreakAfterDefinitionReturnType** (``DefinitionReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlwaysBreakAfterDefinitionReturnType>`; T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:31358,config,configuration,31358,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"mentation; <https://cmake.org/cmake/help/v3.5/command/set.html#set-cache-entry>`_. Scope; -----. CMake inherently has a directory-based scoping. Setting a variable in a; CMakeLists file, will set the variable for that file, and all subdirectories.; Variables set in a CMake module that is included in a CMakeLists file will be; set in the scope they are included from, and all subdirectories. When a variable that is already set is set again in a subdirectory it overrides; the value in that scope and any deeper subdirectories. The CMake set command provides two scope-related options. PARENT_SCOPE sets a; variable into the parent scope, and not the current scope. The CACHE option sets; the variable in the CMakeCache, which results in it being set in all scopes. The; CACHE option will not set a variable that already exists in the CACHE unless the; FORCE option is specified. In addition to directory-based scope, CMake functions also have their own scope.; This means variables set inside functions do not bleed into the parent scope.; This is not true of macros, and it is for this reason LLVM prefers functions; over macros whenever reasonable. .. note::; Unlike C-based languages, CMake's loop and control flow blocks do not have; their own scopes. Control Flow; ============. CMake features the same basic control flow constructs you would expect in any; scripting language, but there are a few quirks because, as with everything in; CMake, control flow constructs are commands. If, ElseIf, Else; ----------------. .. note::; For the full documentation on the CMake if command go; `here <https://cmake.org/cmake/help/v3.4/command/if.html>`_. That resource is; far more complete. In general CMake if blocks work the way you'd expect:. .. code-block:: cmake. if(<condition>); message(""do stuff""); elseif(<condition>); message(""do other stuff""); else(); message(""do other other stuff""); endif(). The single most important thing to know about CMake's if blocks coming from a C; background is tha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:7061,variab,variables,7061,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['variab'],['variables']
Modifiability,"ments can be used in the fields of the parent class to; initialize them in a custom manner. That is, record or class ``A`` can; request parent class ``S`` with one set of template arguments, while record or class; ``B`` can request ``S`` with a different set of arguments. Without template; arguments, many more classes would be required, one for each combination of; the template arguments. Both classes and concrete records can include fields that are uninitialized.; The uninitialized ""value"" is represented by a question mark (``?``). Classes; often have uninitialized fields that are expected to be filled in when those; classes are inherited by concrete records. Even so, some fields of concrete; records may remain uninitialized. TableGen provides *multiclasses* to collect a group of record definitions in; one place. A multiclass is a sort of macro that can be ""invoked"" to define; multiple concrete records all at once. A multiclass can inherit from other; multiclasses, which means that the multiclass inherits all the definitions; from its parent multiclasses. `Appendix C: Sample Record`_ illustrates a complex record in the Intel X86; target and the simple way in which it is defined. Source Files; ============. TableGen source files are plain ASCII text files. The files can contain; statements, comments, and blank lines (see `Lexical Analysis`_). The standard file; extension for TableGen files is ``.td``. TableGen files can grow quite large, so there is an include mechanism that; allows one file to include the content of another file (see `Include; Files`_). This allows large files to be broken up into smaller ones, and; also provides a simple library mechanism where multiple source files can; include the same library file. TableGen supports a simple preprocessor that can be used to conditionalize; portions of ``.td`` files. See `Preprocessing Facilities`_ for more; information. Lexical Analysis; ================. The lexical and syntax notation used here is intended to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:5441,inherit,inherit,5441,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,2,['inherit'],"['inherit', 'inherits']"
Modifiability,"ments from [src, src + nelem - 1] in tableSrc to; // [dst, dst + nelem - 1] in tableDst; void copy(int dst, int src, int nelem) {; __builtin_wasm_table_copy(tableDst, tableSrc, dst, src, nelem);; }. Builtin Functions; =================. Clang supports a number of builtin library functions with the same syntax as; GCC, including things like ``__builtin_nan``, ``__builtin_constant_p``,; ``__builtin_choose_expr``, ``__builtin_types_compatible_p``,; ``__builtin_assume_aligned``, ``__sync_fetch_and_add``, etc. In addition to; the GCC builtins, Clang supports a number of builtins that GCC does not, which; are listed here. Please note that Clang does not and will not support all of the GCC builtins; for vector operations. Instead of using builtins, you should use the functions; defined in target-specific header files like ``<xmmintrin.h>``, which define; portable wrappers for these. Many of the Clang versions of these functions are; implemented directly in terms of :ref:`extended vector support; <langext-vectors>` instead of builtins, in order to reduce the number of; builtins that we need to implement. ``__builtin_alloca``; --------------------. ``__builtin_alloca`` is used to dynamically allocate memory on the stack. Memory; is automatically freed upon function termination. **Syntax**:. .. code-block:: c++. __builtin_alloca(size_t n). **Example of Use**:. .. code-block:: c++. void init(float* data, size_t nbelems);; void process(float* data, size_t nbelems);; int foo(size_t n) {; auto mem = (float*)__builtin_alloca(n * sizeof(float));; init(mem, n);; process(mem, n);; /* mem is automatically freed at this point */; }. **Description**:. ``__builtin_alloca`` is meant to be used to allocate a dynamic amount of memory; on the stack. This amount is subject to stack allocation limits. Query for this feature with ``__has_builtin(__builtin_alloca)``. ``__builtin_alloca_with_align``; -------------------------------. ``__builtin_alloca_with_align`` is used to dynamically allocate m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:96707,extend,extended,96707,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['extend'],['extended']
Modifiability,"ments in registers. Live out values are typically return values in; registers. Live in values are marked as such, and are given a dummy ""defining""; instruction during live intervals analysis. If the last basic block of a; function is a ``return``, then it's marked as using all live out values in the; function. ``PHI`` nodes need to be handled specially, because the calculation of the live; variable information from a depth first traversal of the CFG of the function; won't guarantee that a virtual register used by the ``PHI`` node is defined; before it's used. When a ``PHI`` node is encountered, only the definition is; handled, because the uses will be handled in other basic blocks. For each ``PHI`` node of the current basic block, we simulate an assignment at; the end of the current basic block and traverse the successor basic blocks. If a; successor basic block has a ``PHI`` node and one of the ``PHI`` node's operands; is coming from the current basic block, then the variable is marked as *alive*; within the current basic block and all of its predecessor basic blocks, until; the basic block with the defining instruction is encountered. Live Intervals Analysis; ^^^^^^^^^^^^^^^^^^^^^^^. We now have the information available to perform the live intervals analysis and; build the live intervals themselves. We start off by numbering the basic blocks; and machine instructions. We then handle the ""live-in"" values. These are in; physical registers, so the physical register is assumed to be killed by the end; of the basic block. Live intervals for virtual registers are computed for some; ordering of the machine instructions ``[1, N]``. A live interval is an interval; ``[i, j)``, where ``1 >= i >= j > N``, for which a variable is live. .. note::; More to come... .. _Register Allocation:; .. _register allocator:. Register Allocation; -------------------. The *Register Allocation problem* consists in mapping a program; :raw-html:`<b><tt>` P\ :sub:`v`\ :raw-html:`</tt></b>`, tha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:56962,variab,variable,56962,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['variab'],['variable']
Modifiability,"merical calculation; of the FCN value. The effects of non-linearity and numerical round off; both become more important as the external value gets closer to one of; the limits (expressed as the distance to nearest limit divided by; distance between limits). The user must therefore be aware of the fact; that, for example, if they put limits of (0, 1010) on a parameter, then; the values 0.0 and 1. 0 will be indistinguishable to the accuracy of; most machines. The transformation also affects the parameter error matrix, of course,; so Minuit does a transformation of the error matrix (and the; ''parabolic'' parameter errors) when there are parameter limits. Users; should however realize that the transformation is only a linear; approximation, and that it cannot give a meaningful result if one or; more parameters is very close to a limit, where; $\frac{\partial Pext}{\partial Pint} \neq 0$. Therefore, it is; recommended that:. - Limits on variable parameters should be used only when needed in; order to prevent the parameter from taking on unphysical values. - When a satisfactory minimum has been found using limits, the; limits should then be removed if possible, in order to perform or; re-perform the error analysis without limits. ### How to Get the Right Answer from Minuit. `Minuit` offers the user a choice of several minimization algorithms.; The `MIGRAD` algorithm is in general the best minimized for nearly all; functions. It is a variable-metric method with inexact line search, a; stable metric updating scheme, and checks for positive-definiteness.; Its main weakness is that it depends heavily on knowledge of the first; derivatives, and fails miserably if they are very inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. #### Getting the Right Minimum with Limits. If MIGRAD converges normally to a point where no parameter is near one; of its limits,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:57137,variab,variable,57137,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['variab'],['variable']
Modifiability,"merly implement in class RooTreeData. Methods in class RooTreeData; that were not specific to the storage technology have been moved to; class RooAbsData. If your user code only uses the classes RooDataSet,RooDataHist and RooAbsData; nothing will change: Existing RooDataSets and RooDataHists; (that inherit from RooTreeData) can be read in without problems in; RooFit 3.00 and will be converted on the fly to the new dataset structure; in memory. User code that explicitly uses RooTreeData pointers should; be changed to RooAbsData pointers. This change should be transparent; for all uses, with the exception of the RooTreeData::tree() method.; Explicit access to tree implementation can still be obtained; through the RooTreeDataStore::tree() method. (A pointer to the datastore; can be obtained through the RooAbsData::store() method.); Note that in future releases it is no longer guaranteed that all datasets are implemented; with a plain TTree implementation, so any user code that uses the tree; implementation directly should implement checks that the implementation; is indeed tree-based (data->store()->InheritsFrom(RooTreeDataStore::Class())==true)). In future release additional implementations of RooAbsDataStore will; be provided that will support new dataset functionality such as the; ability to construct 'joint' dataset from two input datasets without; the need to copy the input data and 'filtered' datasets that represent; a reduced view (in dimensions or by selecting events) of a dataset; without the need to copy content. Various workspace improvements. A number of smaller and larger improvements has been made to the RooWorkspace class. Direct interactive access to contents from CINT -; One can now directly access the contents of any RooWorkspace; on the ROOT commandline through CINT if the RooWorkspace::exportToCint() call is made.; In CINT, all workspace objects will appear as correctly typed references to workspace objects in; a C++ namespace with the same name as ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:15606,Inherit,InheritsFrom,15606,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['Inherit'],['InheritsFrom']
Modifiability,"mespace to minimize side-effects. Optionally, you can add; CLI-style arguments which are handed to the script through 'sys.argv' in; the normal way. `Exec(const char* cmd) `- the argument is a string of Python code that; is executed as a statement. There is no return value, but an error; message will be printed if there are problems such as syntax errors. `Eval(const char* expr) `- the argument is a string of Python code that; is evaluated as an expression. The result of the expression is returned,; if it is either a builtin type (int, long, float, double, and; `const char*` are supported), a Python type that can cross, or a ROOT; type. If a ROOT type is returned, an explicit cast to void\* is needed; to assign the return value to a local pointer (which may have a; different type), whereas builtin types will be cast implicitly, if; possible, to the type of the local variable to which they are assigned. `Bind(TObject* obj,const char* label)` - transfer a ROOT object from the; Cling to the Python interpreter, where it will be referenced with a; variable called ""`label`"". `Prompt()` - Transfer the interactive prompt to Python. With the ROOT v4.00/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first with `gSystem->Load()` before use. Refer back to the other; example of the use of **`TPython`** that was given in ""Access to Python; from ROOT"". To show in detail how Python access can be used, an example Python; module is needed, as follows:. ``` {.cpp}; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; ```. This module can now be loaded into a Cling session, the class used to; instantiate objects, and their member functions called for showing how; different types can cross:. ``` {.cpp}; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyP",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:17128,variab,variable,17128,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['variab'],['variable']
Modifiability,"metadata is allocated a virtual register, that virtual register is used as the; variable location. If the SDNode is folded into a machine instruction or; otherwise transformed into a non-register, the variable location becomes; unavailable. Locations that are unavailable are treated as if they have been optimized out:; in IR the location would be assigned ``undef`` by a debug intrinsic, and in MIR; the equivalent location is used. After MIR locations are assigned to each variable, machine pseudo-instructions; corresponding to each ``llvm.dbg.value`` intrinsic are inserted. There are two; forms of this type of instruction. The first form, ``DBG_VALUE``, appears thus:. .. code-block:: text. DBG_VALUE %1, $noreg, !123, !DIExpression(). And has the following operands:; * The first operand can record the variable location as a register,; a frame index, an immediate, or the base address register if the original; debug intrinsic referred to memory. ``$noreg`` indicates the variable; location is undefined, equivalent to an ``undef`` dbg.value operand.; * The type of the second operand indicates whether the variable location is; directly referred to by the DBG_VALUE, or whether it is indirect. The; ``$noreg`` register signifies the former, an immediate operand (0) the; latter.; * Operand 3 is the Variable field of the original debug intrinsic.; * Operand 4 is the Expression field of the original debug intrinsic. The second form, ``DBG_VALUE_LIST``, appears thus:. .. code-block:: text. DBG_VALUE_LIST !123, !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_plus), %1, %2. And has the following operands:; * The first operand is the Variable field of the original debug intrinsic.; * The second operand is the Expression field of the original debug intrinsic.; * Any number of operands, from the 3rd onwards, record a sequence of variable; location operands, which may take any of the same values as the first; operand of the ``DBG_VALUE`` instruction above. These variable loca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:27557,variab,variable,27557,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"meters*: toggles the display of the histogram or graph; fit parameters. - *Can Edit Histogram*: enables/disables the possibility to edit; histogram bin contents. ![](pictures/0300000D.png). #### Inspect Menu. - *ROOT*: inspects the top-level ***`gROOT`*** object (in a new; canvas). - *Start Browser*: starts a new object browser (in a separate; window). - *GUI Builder*: starts the GUI builder application (in a separate; window). ![](pictures/0300000E.png). #### Help Menu. - *Canvas:* help on canvas as a whiteboard area for drawing. - *Menus*: help on canvas menus. - *Graphics Editor*: help on primitives' drawing and objects'; editor. - *Browser*: help on the ROOT objects' and files' browser. - *Objects*: help on DrawClass, Inspect and Dump context menu items. - *PostScript*: help on how to print a canvas to a PostScript file; format. - *About ROOT*: pops up the ROOT Logo with the version number. ![](pictures/0300000F.png). #### Classes Menu. - *Classes*: starts the ClassTree viewer that draws inheritance tree; for a list of classes. #### Toolbar. The following menu shortcuts and utilities are available from the; toolbar:. ![](pictures/03000010.png) Create a new canvas window. ![](pictures/03000011.png) Popup the Open File dialog. ![](pictures/03000012.png) Popup the Save As... dialog. ![](pictures/03000013.png) Popup the Print dialog. ![](pictures/03000014.png) Interrupts the current drawing process. ![](pictures/03000015.png) Redraw the canvas. ![](pictures/03000016.png) Inspect the ***`gROOT`*** object. ![](pictures/03000017.png) Create a new objects' browser. You can create the following graphical objects using the toolbar; buttons for primitive drawing. Tool tips are provided for helping; your choice. ![](pictures/03000018.png) **An Arc or circle**: Click on the center; of the arc, and then move the mouse. A rubber band circle is shown.; Click again with the left button to freeze the arc. ![](pictures/03000019.png) **A Line**: Click with the left button at; the po",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:11775,inherit,inheritance,11775,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['inherit'],['inheritance']
Modifiability,"method ExitOnException() which allows to set the behaviour of; TApplication in case of an exception (sigsegv, sigbus, sigill, sigfpe).; The default is to trap the signal and continue with the event loop,; using this method one can specify to exit with the signal number to the; shell, or to abort() which in addition generates a core dump. New command line argument -x which forces ROOT to exit on an exception.; Add TSystem::AddDynamicPath. Build. New option '-t' for rmkdepend to allow the caller to fully specify the name to be used as a target; This supersedes the name calculated from the input file name and the -p and -o option. ACLiC. Allow ACLiC to use a flat directory structure when a build directory is specified.; To use a flat structure do:. gSystem->SetBuildDir(whereIwant, kTRUE); // the default for the 2nd parameter is kFALSE. Or use '-' in the option of CompileMacro. gSystem->CompileMacro(myscript,""k-"",...);. Meta. Implement polymorphism for Emulated object (still not supporting polymorphism; of Emulated Object inheriting from compiled class).; This avoids memory leaks when the user data model relies on polymorphism; and does not the shared library defining the classes theand avoid splicing if the data is copied. TStreamerInfo::New inserts the address of the creating TStreamerInfo into; the object. This address is inserted in each emulated that does not inherit; from an emulated class and is positioned after all the base classes (which; are compiled classes). A derived class will set this value inside each; of its emulated base class.; TStreamerInfo::Destruct and the new method TStreamerInfo::GetActualClass; use this information to detect the TStreamerInfo actually used to create; the object and hence run the proper emulated destructor. Add a new function GenerateDictionary to TInterpreter which allows for the quick and easy creation of a dictionary; given one (or more) class name(s) and the name(s) of its header files. gInterpreter->GenerateDictionary(""vector",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html:2332,polymorphi,polymorphism,2332,core/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html,6,"['inherit', 'polymorphi']","['inheriting', 'polymorphism']"
Modifiability,mic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openmp/runtime/src/thirdparty/ittnotify/legacy; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer/tests/ompt; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests/custom_data_storage; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/tools/multiplex/tests/print; - `2`; - `2`; - `0`; - :good:`100%`; * - polly/include/polly; - `25`; - `25`; - `0`; - :good:`100%`; * -,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122844,plugin,plugins,122844,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['plugin'],['plugins']
Modifiability,"mics use in signal handlers; N2547; Clang 3.1. Thread-local storage; N2659; Clang 3.3 (5). Dynamic initialization and destruction with concurrency; N2660; Clang 2.9. C99 Features in C++11. __func__ predefined identifier; N2340; Clang 2.9. C99 preprocessor; N1653; Clang 2.9. long long; N1811; Clang 2.9. Extended integral types; N1988; N/A (6). (1): The [[carries_dependency]] attribute; has no effect.; (2): No compiler changes are required for an implementation; such as Clang that does not provide garbage collection.; (3): All compare-exchange operations are emitted as; strong compare-exchanges.; (4): memory_order_consume is lowered to; memory_order_acquire.; (5): thread_local support; requires a C++ runtime library providing __cxa_thread_atexit, such; as libc++abi 3.6 or later,; or libsupc++ 4.8 or later.; (6): No compiler changes are required for an implementation; such as Clang that does not provide any extended integer types.; __int128 is not treated as an extended integer type,; because changing intmax_t would be an ABI-incompatible; change. C++98 implementation status; Clang implements all of the ISO C++ 1998 standard; (including the defects addressed in the ISO C++ 2003 standard); except for export (which was removed in C++11). Defect reports; Clang generally aims to implement resolutions to Defect Reports (bug fixes; against prior standards) retroactively, in all prior standard versions where; the fix is meaningful. Significant Defect Report changes to language features; after the publication of the relevant standard are marked (DR) in the above; table.; Clang also has a test suite for conformance to resolutions for issues on the; C++ core issues list,; most of which are considered Defect Reports.; Implementation status for C++ core issues based on; that test suite is tracked on a separate page.; Technical specifications and standing documents; ISO C++ also publishes a number of documents describing additional language; and library features that are not part of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:18814,extend,extended,18814,interpreter/llvm-project/clang/www/cxx_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html,2,['extend'],['extended']
Modifiability,"mir-conversions. Generate LLVM IR conversions. .. option:: -gen-llvmir-intrinsics. Generate LLVM IR intrinsics. .. option:: -llvmir-intrinsics-filter. Only keep the intrinsics with the specified substring in their record name. .. option:: -dialect-opclass-base. The base class for the ops in the dialect we are to emit. .. option:: -gen-op-decls. Generate operation declarations. .. option:: -gen-op-defs. Generate operation definitions. .. option:: -asmformat-error-is-fatal. Emit a fatal error if format parsing fails. .. option:: -op-exclude-regex. Regular expression of name of ops to exclude (no filter if empty). .. option:: -op-include-regex. Regular expression of name of ops to include (no filter if empty). .. option:: -gen-op-doc. Generate operation documentation. .. option:: -gen-pass-decls. Generate operation documentation. .. option:: -name namestring. The name of this group of passes. .. option:: -gen-pass-doc. Generate pass documentation. .. option:: -gen-rewriters. Generate pattern rewriters. .. option:: -gen-spirv-avail-impls. Generate SPIR-V operation utility definitions. .. option:: -gen-spirv-capability-implication. Generate utility function to return implied capabilities for a given capability. .. option:: -gen-spirv-enum-avail-decls. Generate SPIR-V enum availability declarations. .. option:: -gen-spirv-enum-avail-defs. Generate SPIR-V enum availability definitions. .. option:: -gen-spirv-op-utils. Generate SPIR-V operation utility definitions. .. option:: -gen-spirv-serialization. Generate SPIR-V (de)serialization utilities and functions. .. option:: -gen-struct-attr-decls. Generate struct utility declarations. .. option:: -gen-struct-attr-defs. Generate struct utility definitions. .. option:: -gen-typedef-decls. Generate TypeDef declarations. .. option:: -gen-typedef-defs. Generate TypeDef definitions. .. option:: -typedefs-dialect name. Generate types for this dialect. EXIT STATUS; -----------. If :program:`*-tblgen` succeeds, it will exit with 0. Ot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst:14567,rewrite,rewriters,14567,interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,1,['rewrite'],['rewriters']
Modifiability,"mizer type* (`MinimizerOptions::SetMinimizerType(const char *)`) .; * *Minimizer algorithm* (`MinimizerOptions::SetMinimizerAlgorithm(const char *)`).; * *Print Level* (`MinimizerOptions::SetPrintLevel(int )`) to set the verbose printing level (default is 0).; * *Tolerance* (`MinimizerOptions::SetTolerance(double )`) tolerance used to control the iterations.; * *Maximum number of function calls* (`MinimizerOptions::SetMaxFunctionCalls(int )`).; * *Maximum number of iterations* (`MinimizerOptions::SetMaxIterations(int )`). Note that this is not used by *Minuit*; * *FCN Upper value for Error Definition* (`MinimizerOptions::SetErrorDef(double )`). Value in the minimization function used to compute the parameter errors.; The default is to get the uncertainties at the 68% CL is a value of 1 for a chi-squared function minimization and 0.5 for a log-likelihood function.; * *Strategy* (`MinimizerOptions::SetStrategy(int )`), minimization strategy used. For each minimization strategy *Minuit* uses different configuration parameters; (e.g. different requirements in computing derivatives, computing full Hessian (strategy = 2) or an approximate version. The default is a value of 1. In this case the full Hessian matrix; is computed only after the minimization.; * *Precision* (`MinimizerOptions::SetPrecision(double )`). Precision value in the evaluation of the minimization function. Default is numerical double precision. Note that not all the options are implemented by all the minimizers.; For example in *Minuit* is possible to set the maximum number of function calls, but not the maximum number of iterations. The Strategy and the Precision options apply instead only for *Minuit* (and; *Minuit2*). The class supports also setting global default values for the options, by using the static functions `MinimizerOptions::SetDefault...` (for example `MinimizerOptions::SetDefaultPrintLevel(int )`). The; static functions can be also used to set the minimizer options when using `TH1::Fit` o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:43813,config,configuration,43813,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['config'],['configuration']
Modifiability,"mmandLine library, this is represented like; this:. .. _scalars arguments:; .. _here:. .. code-block:: c++. cl::opt<string> OutputFilename(""o"", cl::desc(""Specify output filename""), cl::value_desc(""filename""));. This declares a global variable ""``OutputFilename``"" that is used to capture the; result of the ""``o``"" argument (first parameter). We specify that this is a; simple scalar option by using the ""``cl::opt``"" template (as opposed to the; ""``cl::list``"" template), and tell the CommandLine library that the data; type that we are parsing is a string. The second and third parameters (which are optional) are used to specify what to; output for the ""``-help``"" option. In this case, we get a line that looks like; this:. ::. USAGE: compiler [options]. OPTIONS:; -h - Alias for -help; -help - display available options (-help-hidden for more); -o <filename> - Specify output filename. Because we specified that the command line option should parse using the; ``string`` data type, the variable declared is automatically usable as a real; string in all contexts that a normal C++ string object may be used. For; example:. .. code-block:: c++. ...; std::ofstream Output(OutputFilename.c_str());; if (Output.good()) ...; ... There are many different options that you can use to customize the command line; option handling library, but the above example shows the general interface to; these options. The options can be specified in any order, and are specified; with helper functions like `cl::desc(...)`_, so there are no positional; dependencies to remember. The available options are discussed in detail in the; `Reference Guide`_. Continuing the example, we would like to have our compiler take an input; filename as well as an output filename, but we do not want the input filename to; be specified with a hyphen (ie, not ``-filename.c``). To support this style of; argument, the CommandLine library allows for `positional`_ arguments to be; specified for the program. These positional argumen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:5907,variab,variable,5907,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variable']
Modifiability,"mment for explicit destructor call; Unknown. 1606; NAD; sizeof closure class; Unknown. 1607; C++14; Lambdas in template parameters; Unknown. 1608; C++14; Operator lookup in trailing return type; Unknown. 1609; open; Default arguments and function parameter packs; Not resolved. 1610; drafting; Cv-qualification in deduction of reference to array; Not resolved. 1611; C++14; Deleted default constructor for abstract class; Duplicate of 1658. 1612; C++14; Implicit lambda capture and anonymous unions; Unknown. 1613; C++14; Constant expressions and lambda capture; Unknown. 1614; CD4; Address of pure virtual function vs odr-use; Unknown. 1615; CD4; Alignment of types, variables, and members; Unknown. 1616; CD6; Disambiguation parsing and template parameters; Unknown. 1617; open; alignas and non-defining declarations; Not resolved. 1618; C++14; Gratuitously-unsigned underlying enum type; Unknown. 1619; open; Definition of current instantiation; Not resolved. 1620; open; User-defined literals and extended integer types; Not resolved. 1621; C++20; Member initializers in anonymous unions; Unknown. 1622; C++17; Empty aggregate initializer for union; Unknown. 1623; drafting; Deleted default union constructor and member initializers; Not resolved. 1624; NAD; Destruction of union members with member initializers; Unknown. 1625; open; Adding spaces between tokens in stringizing; Not resolved. 1626; open; constexpr member functions in brace-or-equal-initializers; Not resolved. 1627; NAD; Agreement of dependent alignas specifiers; Unknown. 1628; open; Deallocation function templates; Not resolved. 1629; C++14; Can a closure class be a literal type?; Unknown. 1630; CD4; Multiple default constructor templates; Unknown. 1631; CD4; Incorrect overload resolution for single-element initializer-list; Clang 3.7. 1632; CD5; Lambda capture in member initializers; Unknown. 1633; CD4; Copy-initialization in member initialization; Unknown. 1634; drafting; Temporary storage duration; Not resolved. 1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:109358,extend,extended,109358,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['extend'],['extended']
Modifiability,"mo.htm, which demonstrates online usage of JSROOT.; 17. One could use demo.htm directly with THttpServer providing address like:; <http://localhost:8080/jsrootsys/demo/demo.htm?addr=../../Files/job1.root/hpx/root.json.gz&layout=3x3>; 18. Also for online server process url options like 'item', 'items', 'layout'; 19. Possibility to generate URL, which reproduces opened page with layout and drawn items. ### August 2014; 1. All communication between server and browser done with JSON format.; 2. Fix small error in dtree.js - one should always set; last sibling (_ls) property while tree can be dynamically changed.; 3. In JSRootCore.js provide central function, which handles different kinds; of XMLHttpRequest. Use only async requests, also when getting file header.; 4. Fully reorganize data management in file/tree/directory/collection hierarchical; display. Now complete description collected in HPainter class and decoupled from; visualization, performed with dTree.js.; 5. Remove all global variables from the code.; 6. Automatic scripts/style loading handled via JSROOT.loadScript() function.; One can specify arbitrary scripts list, which asynchronously loaded by browser.; 7. Method to build simple GUI changed and more simplified :). The example in index.htm.; While loadScript and AssertPrerequisites functions moved to JSROOT, one; can easily build many different kinds of GUIs, reusing provided JSRootCore.js functions.; 8. In example.htm also use AssertPrerequisites to load necessary scripts.; This helps to keep code up-to-date even by big changes in JavaScript code.; 9. Provide monitoring of online THttpServer with similar interface as for ROOT files.; 10. Fix several errors in TKey Streamer, use member names as in ROOT itself.; 11. Keep the only version identifier JSROOT.version for JS code; 12. One can specify in JSROOT.AssertPrerequisites functionality which is required.; One could specify '2d', 'io' (default) or '3d'.; 13. Use new AssertPrerequisites functionality to loa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:74345,variab,variables,74345,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['variab'],['variables']
Modifiability,"modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indicates; that the address is not significant, only the content. Constants marked; like this can be merged with other constants if they have the same; initializer. Note that a constant with significant address *can* be; merged with a ``unnamed_addr`` constant, the result being a constant; whose address is significant. If the ``local_unnamed_addr`` attribute is given, the address is known to; not be significant within the module. A global variable may be declared to reside in a target-specific; numbered address space. For targets that support them, address spaces; may affect how optimizations are performed and/or what target; instructions are used to access the variable. The default address space; is zero. The address space qualifier must precede any other attributes. LLVM allows an explicit section to be specified for globals. If the; target supports it, it will emit globals to the section specified.; Additionally, the global can placed in a comdat if the target has the necessary; suppor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:32098,variab,variables,32098,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When Clang emits a diagnostic, it includes rich information in the; ou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:35122,config,configuration,35122,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['configuration']
Modifiability,"more than one; classifier within one. MethodBoost: boosts/bags any classifier; type. A special booking procedure for it was added to; Factory class. MethodDT: a classifier composed of a single; decision tree, boosted using MethodBoost. Results are; compatible with BDT, but BDT remains the default for boosted; decision trees, because it has pruning (among other; additional features). . Other improvements . Improved handling of small Likelihood values such that; Likelihood performance increases in analyses with many variables; (~>10). Thanks to Ralph Schaefer (Bonn U.) for reporting this. Nicer plotting: custom variable titles and units can be; assigned in ""AddVariable"" call. Introduced the inverse transformation InverseTransform for; the variable transformations into the framework. While this is; not necessary for classification, it is necessary for; regression. The inverse transformation of the normalization; transformation has been implemented. Started to extend the variable transformations to the; regression targets as well. MethodCuts now produces the 'optimal-cut' histograms needed; by macro mvaeffs.C. (macro 5a of TMVAGui.C); ; MsgLogger can be silenced in order to prevent excess output; during boosting. Third dataset type added centrally (Training, Validation; and Testing). The validation data is split off the original; training data set. Update of GUI and other Macros according to the new; features of PDF and the addition of MethodBoost.; ; Updates in TMVA 4.0.1. ""Spectator"" variables can be defined now which are computed; just as the input variables and which are written out into the; TestTree, but which don't participate in any MVA calculation; (useful for correlation studies).; ; New booking option ""IgnoreNegWeightsInTraining"" to test the; effect of events with negative weights on the training. This is; especially useful for methods, which do not properly deal with; such events. Note that this new option is not available for all; methods (a training interru",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v524/index.html:5605,extend,extend,5605,tmva/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v524/index.html,4,"['extend', 'variab']","['extend', 'variable']"
Modifiability,"more, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68423,config,configuration,68423,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['config'],['configuration']
Modifiability,"more; sense after reading the remainder of this guide. .. The code for this is exceptionally abstruse. These examples are a; best-effort attempt. * A template argument of a ``class``, such as the use of ``Bar`` in::. class Foo <int Bar> {; int Baz = Bar;; }. * The implicit template argument ``NAME`` in a ``class`` or ``multiclass``; definition (see `NAME`_). * A field local to a ``class``, such as the use of ``Bar`` in::. class Foo {; int Bar = 5;; int Baz = Bar;; }. * The name of a record definition, such as the use of ``Bar`` in the; definition of ``Foo``::. def Bar : SomeClass {; int X = 5;; }. def Foo {; SomeClass Baz = Bar;; }. * A field local to a record definition, such as the use of ``Bar`` in::. def Foo {; int Bar = 5;; int Baz = Bar;; }. Fields inherited from the record's parent classes can be accessed the same way. * A template argument of a ``multiclass``, such as the use of ``Bar`` in::. multiclass Foo <int Bar> {; def : SomeClass<Bar>;; }. * A variable defined with the ``defvar`` or ``defset`` statements. * The iteration variable of a ``foreach``, such as the use of ``i`` in::. foreach i = 0...5 in; def Foo#i;. .. productionlist::; SimpleValue8: `ClassID` ""<"" `ArgValueList` "">"". This form creates a new anonymous record definition (as would be created by an; unnamed ``def`` inheriting from the given class with the given template; arguments; see `def`_) and the value is that record. A field of the record can be; obtained using a suffix; see `Suffixed Values`_. Invoking a class in this manner can provide a simple subroutine facility.; See `Using Classes as Subroutines`_ for more information. .. productionlist::; SimpleValue9: `BangOperator` [""<"" `Type` "">""] ""("" `ValueListNE` "")""; :| `CondOperator` ""("" `CondClause` ("","" `CondClause`)* "")""; CondClause: `Value` "":"" `Value`. The bang operators provide functions that are not available with the other; simple values. Except in the case of ``!cond``, a bang operator takes a list; of arguments enclosed in parenthes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:17371,variab,variable,17371,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['variab'],['variable']
Modifiability,"mory, shadow, and; origin regions to each other with these masks and offsets:. * shadow_addr = memory_addr ^ 0x500000000000. * origin_addr = shadow_addr + 0x100000000000. As for LLVM SSA registers, we have not found it necessary to associate a label; with each byte or bit of data, as some other tools do. Instead, labels are; associated directly with registers. Loads will result in a union of; all shadow labels corresponding to bytes loaded, and stores will; result in a copy of the label of the stored value to the shadow of all; bytes stored to. Propagating labels through arguments; ------------------------------------. In order to propagate labels through function arguments and return values,; DataFlowSanitizer changes the ABI of each function in the translation unit.; There are currently two supported ABIs:. * Args -- Argument and return value labels are passed through additional; arguments and by modifying the return type. * TLS -- Argument and return value labels are passed through TLS variables; ``__dfsan_arg_tls`` and ``__dfsan_retval_tls``. The main advantage of the TLS ABI is that it is more tolerant of ABI mismatches; (TLS storage is not shared with any other form of storage, whereas extra; arguments may be stored in registers which under the native ABI are not used; for parameter passing and thus could contain arbitrary values). On the other; hand the args ABI is more efficient and allows ABI mismatches to be more easily; identified by checking for nonzero labels in nominally unlabelled programs. Implementing the ABI list; -------------------------. The `ABI list <DataFlowSanitizer.html#abi-list>`_ provides a list of functions; which conform to the native ABI, each of which is callable from an instrumented; program. This is implemented by replacing each reference to a native ABI; function with a reference to a function which uses the instrumented ABI.; Such functions are automatically-generated wrappers for the native functions.; For example, given the ABI ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:10295,variab,variables,10295,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,1,['variab'],['variables']
Modifiability,"mory>. namespace llvm {; namespace orc {. class KaleidoscopeJIT {; private:; ExecutionSession ES;; RTDyldObjectLinkingLayer ObjectLayer;; IRCompileLayer CompileLayer;. DataLayout DL;; MangleAndInterner Mangle;; ThreadSafeContext Ctx;. public:; KaleidoscopeJIT(JITTargetMachineBuilder JTMB, DataLayout DL); : ObjectLayer(ES,; []() { return std::make_unique<SectionMemoryManager>(); }),; CompileLayer(ES, ObjectLayer, ConcurrentIRCompiler(std::move(JTMB))),; DL(std::move(DL)), Mangle(ES, this->DL),; Ctx(std::make_unique<LLVMContext>()) {; ES.getMainJITDylib().addGenerator(; cantFail(DynamicLibrarySearchGenerator::GetForCurrentProcess(DL.getGlobalPrefix())));; }. Our class begins with six member variables: An ExecutionSession member, ``ES``,; which provides context for our running JIT'd code (including the string pool,; global mutex, and error reporting facilities); An RTDyldObjectLinkingLayer,; ``ObjectLayer``, that can be used to add object files to our JIT (though we will; not use it directly); An IRCompileLayer, ``CompileLayer``, that can be used to; add LLVM Modules to our JIT (and which builds on the ObjectLayer), A DataLayout; and MangleAndInterner, ``DL`` and ``Mangle``, that will be used for symbol mangling; (more on that later); and finally an LLVMContext that clients will use when; building IR files for the JIT. Next up we have our class constructor, which takes a `JITTargetMachineBuilder``; that will be used by our IRCompiler, and a ``DataLayout`` that we will use to; initialize our DL member. The constructor begins by initializing our; ObjectLayer. The ObjectLayer requires a reference to the ExecutionSession, and; a function object that will build a JIT memory manager for each module that is; added (a JIT memory manager manages memory allocations, memory permissions, and; registration of exception handlers for JIT'd code). For this we use a lambda; that returns a SectionMemoryManager, an off-the-shelf utility that provides all; the basic memory management funct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:6067,variab,variables,6067,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,1,['variab'],['variables']
Modifiability,"most basic and fundamental tools are kept in the; primary Clang tree. The rest of the tools are kept in a separate; directory tree, `clang-tools-extra; <https://github.com/llvm/llvm-project/tree/main/clang-tools-extra>`_. This document describes a high-level overview of the organization of; Clang Tools within the project as well as giving an introduction to some; of the more important tools. However, it should be noted that this; document is currently focused on Clang and Clang Tool developers, not on; end users of these tools. Clang Tools Organization; ========================. Clang Tools are CLI or GUI programs that are intended to be directly; used by C++ developers. That is they are *not* primarily for use by; Clang developers, although they are hopefully useful to C++ developers; who happen to work on Clang, and we try to actively dogfood their; functionality. They are developed in three components: the underlying; infrastructure for building a standalone tool based on Clang, core; shared logic used by many different tools in the form of refactoring and; rewriting libraries, and the tools themselves. The underlying infrastructure for Clang Tools is the; :doc:`LibTooling <LibTooling>` platform. See its documentation for much; more detailed information about how this infrastructure works. The; common refactoring and rewriting toolkit-style library is also part of; LibTooling organizationally. A few Clang Tools are developed along side the core Clang libraries as; examples and test cases of fundamental functionality. However, most of; the tools are developed in a side repository to provide easy separation; from the core libraries. We intentionally do not support public; libraries in the side repository, as we want to carefully review and; find good APIs for libraries as they are lifted out of a few tools and; into the core Clang library set. Regardless of which repository Clang Tools' code resides in, the; development process and practices for all Clang Tools are ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:1401,refactor,refactoring,1401,interpreter/llvm-project/clang/docs/ClangTools.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst,1,['refactor'],['refactoring']
Modifiability,"most important goals of M in are. - its numerical accuracy (equivalent to its Fortran version). - its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a; two-way strategy was imposed:. - a minimal required interface with minimum interaction with M objects; and with appropriate usage of the standard library (STL): the user's; implementation of the FCNBase class, initial parameter values and; uncertainties are provided by the to M user via std::vectors. - a rich interface which provides the user with more functionality; such as interaction with parameters. The core of the minimization functionality and related tools (the kernel; of M ) should be clearly separated from the user, who is interfacing via; defined user interfaces (the API). ## Internal and external parameters ##. Each of the parameters to the $\mbox{FCN}$ is defined by the user as; belonging to one of the following types:. - Freely variable: allowed to take on any value. - Variable with double sided limits: allowed to vary only between two; limits specified by the user. - Variable with single sided limits: allowed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is cre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:5150,variab,variable,5150,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability,"mp input. .. option:: --dump-input-context <N>. In the dump requested by ``--dump-input``, print ``<N>`` input lines before; and ``<N>`` input lines after any lines specified by ``--dump-input-filter``.; When there are multiple occurrences of this option, the largest specified; ``<N>`` has precedence. The default is 5. .. option:: --dump-input-filter <value>. In the dump requested by ``--dump-input``, print only input lines of kind; ``<value>`` plus any context specified by ``--dump-input-context``. When; there are multiple occurrences of this option, the ``<value>`` that appears; earliest in the list below has precedence. The default is ``error`` when; ``--dump-input=fail``, and it's ``all`` when ``--dump-input=always``. * ``all`` - All input lines; * ``annotation-full`` - Input lines with annotations; * ``annotation`` - Input lines with starting points of annotations; * ``error`` - Input lines with starting points of error annotations. .. option:: --enable-var-scope. Enables scope for regex variables. Variables with names that start with ``$`` are considered global and; remain set throughout the file. All other variables get undefined after each encountered ``CHECK-LABEL``. .. option:: -D<VAR=VALUE>. Sets a filecheck pattern variable ``VAR`` with value ``VALUE`` that can be; used in ``CHECK:`` lines. .. option:: -D#<FMT>,<NUMVAR>=<NUMERIC EXPRESSION>. Sets a filecheck numeric variable ``NUMVAR`` of matching format ``FMT`` to; the result of evaluating ``<NUMERIC EXPRESSION>`` that can be used in; ``CHECK:`` lines. See section; ``FileCheck Numeric Variables and Expressions`` for details on supported; numeric expressions. .. option:: -version. Show the version number of this program. .. option:: -v. Print good directive pattern matches. However, if ``-dump-input=fail`` or; ``-dump-input=always``, add those matches as input annotations instead. .. option:: -vv. Print information helpful in diagnosing internal FileCheck issues, such as; discarded overlapping ``CHECK-DAG",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:5918,variab,variables,5918,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variables']
Modifiability,mp/libomptarget/DeviceRTL/src/Synchronization.cpp; openmp/libomptarget/DeviceRTL/src/Tasking.cpp; openmp/libomptarget/DeviceRTL/src/Utils.cpp; openmp/libomptarget/include/Debug.h; openmp/libomptarget/include/device.h; openmp/libomptarget/include/DeviceEnvironment.h; openmp/libomptarget/include/interop.h; openmp/libomptarget/include/omptarget.h; openmp/libomptarget/include/omptargetplugin.h; openmp/libomptarget/include/rtl.h; openmp/libomptarget/include/SourceInfo.h; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.cpp; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.h; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.cpp; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.h; openmp/libomptarget/plugins/amdgpu/impl/hsa_api.h; openmp/libomptarget/plugins/amdgpu/impl/impl.cpp; openmp/libomptarget/plugins/amdgpu/impl/impl_runtime.h; openmp/libomptarget/plugins/amdgpu/impl/internal.h; openmp/libomptarget/plugins/amdgpu/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/libomptarget/plugins/remote/include/Utils.h; openmp/libomptarget/plugins/remote/server/OffloadingServer.cpp; openmp/libomptarget/plugins/remote/server/Server.cpp; openmp/libomptarget/plugins/remote/server/Server.h; openmp/libomptarget/plugins/remote/src/Client.cpp; openmp/libomptarget/plugins/remote/src/Client.h; openmp/libomptarget/plugins/ve/src/rtl.cpp; openmp/libomptarget/src/api.cpp; openmp/libomptarget/src/interface.cpp; openmp/libomptarget/s,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:407354,plugin,plugins,407354,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,"mpiled for a language. In the case of the C; family, there is an optimization pass that ""knows"" about the standard C; library functions. If you call ""exit(0)"" in main(), it knows that it is; safe to optimize that into ""return 0;"" because C specifies what the; 'exit' function does. In addition to simple library knowledge, it is possible to embed a; variety of other language-specific information into the LLVM IR. If you; have a specific need and run into a wall, please bring the topic up on; the llvm-dev list. At the very worst, you can always treat LLVM as if it; were a ""dumb code generator"" and implement the high-level optimizations; you desire in your front-end, on the language-specific AST. Tips and Tricks; ===============. There is a variety of useful tips and tricks that you come to know after; working on/with LLVM that aren't obvious at first glance. Instead of; letting everyone rediscover them, this section talks about some of these; issues. Implementing portable offsetof/sizeof; -------------------------------------. One interesting thing that comes up, if you are trying to keep the code; generated by your compiler ""target independent"", is that you often need; to know the size of some LLVM type or the offset of some field in an; llvm structure. For example, you might need to pass the size of a type; into a function that allocates memory. Unfortunately, this can vary widely across targets: for example the; width of a pointer is trivially target-specific. However, there is a; `clever way to use the getelementptr; instruction <http://nondot.org/sabre/LLVMNotes/SizeOf-OffsetOf-VariableSizedStructs.txt>`_; that allows you to compute this in a portable way. Garbage Collected Stack Frames; ------------------------------. Some languages want to explicitly manage their stack frames, often so; that they are garbage collected or to allow easy implementation of; closures. There are often better ways to implement these features than; explicit stack frames, but `LLVM does ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:11505,portab,portable,11505,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['portab'],['portable']
Modifiability,"mpiler IR, as an on-disk bitcode representation; (suitable for fast loading by a Just-In-Time compiler), and as a human; readable assembly language representation. This allows LLVM to provide a; powerful intermediate representation for efficient compiler; transformations and analysis, while providing a natural means to debug; and visualize the transformations. The three different forms of LLVM are; all equivalent. This document describes the human readable; representation and notation. The LLVM representation aims to be light-weight and low-level while; being expressive, typed, and extensible at the same time. It aims to be; a ""universal IR"" of sorts, by being at a low enough level that; high-level ideas may be cleanly mapped to it (similar to how; microprocessors are ""universal IR's"", allowing many source languages to; be mapped to them). By providing type information, LLVM can be used as; the target of optimizations: for example, through pointer analysis, it; can be proven that a C automatic variable is never accessed outside of; the current function, allowing it to be promoted to a simple SSA value; instead of a memory location. .. _wellformed:. Well-Formedness; ---------------. It is important to note that this document describes 'well formed' LLVM; assembly language. There is a difference between what the parser accepts; and what is considered 'well formed'. For example, the following; instruction is syntactically okay, but not well formed:. .. code-block:: llvm. %x = add i32 1, %x. because the definition of ``%x`` does not dominate all of its uses. The; LLVM infrastructure provides a verification pass that may be used to; verify that an LLVM module is well formed. This pass is automatically; run by the parser after parsing input assembly and by the optimizer; before it outputs bitcode. The violations pointed out by the verifier; pass indicate bugs in transformation passes or input to the parser. .. _identifiers:. Identifiers; ===========. LLVM identifiers come",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:1651,variab,variable,1651,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"mple2a.h`. ``` {.cpp}; #include <TQObject.h>; #include <RQ_OBJECT.h>. class TGWindow;; class TGMainFrame;; class TRootEmbeddedCanvas;. class MyMainFrame {; RQ_OBJECT(""MyMainFrame""); private:; TGMainFrame *fMain;; TRootEmbeddedCanvas *fEcanvas;; public:; MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h);; virtual ~MyMainFrame();; void DoDraw();; };; ```. `example2a.cxx`. ``` {.cpp}; #include <TApplication.h>; #include <TGClient.h>; #include <TCanvas.h>; #include <TF1.h>; #include <TRandom.h>; #include <TGButton.h>; #include <TRootEmbeddedCanvas.h>; #include ""example2a.h"". MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h) {...}; MyMainFrame::~MyMainFrame() { ... }; void MyMainFrame::DoDraw() { ... }; void example() { ... }. int main(int argc, char **argv) {; TApplication theApp(""App"",&argc,argv);; example();; theApp.Run();; return 0;; }; ```. The class `MyMainFrame` could derive from **`TGMainFrame`**. In that; case the `RQ_OBJECT` macro is not needed anymore, since the; functionality it provides is obtained now via inheritance from; **`TGMainFrame`**. This will reflect in the `MyMainFrame` class; declaration and in the code of the `MyMainFrame::MyMainFrame`; constructor as follows:. `example2b.h`. ``` {.cpp}; #include <TGFrame.h>; class MyMainFrame : public TGMainFrame {; private:; TRootEmbeddedCanvas *fEcanvas;; public:; MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h);; virtual ~MyMainFrame() { ... }; void DoDraw(){ ... }; ClassDef(MyMainFrame,0); };; ```. `example2b.cxx`. ``` {.cpp}; #include <TApplication.h>; #include <TGClient.h>; #include <TCanvas.h>; #include <TF1.h>; #include <TRandom.h>; #include <TGButton.h>; #include <TRootEmbeddedCanvas.h>; #include ""example2b.h"". MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h); : TGMainFrame(p,w,h) {. // Creates widgets of the example; fEcanvas = new TRootEmbeddedCanvas (""Ecanvas"",this,200,200);; AddFrame(fEcanvas, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY, 10,10,10,1));; TGHorizontalFram",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:18079,inherit,inheritance,18079,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['inherit'],['inheritance']
Modifiability,"mpression level |; | [42-\>45] | | |; +-------------------+------------------+---------------------------------------+; | 38 `->` 41 | `fSeekInfo` | Pointer to **`TStreamerInfo`** record |; | [46-\>53] | | |; +-------------------+------------------+---------------------------------------+; | 42 `->` 45 | `fNBytesInfo` | Number of bytes in |; | [54-\>57] | | **`TStreamerInfo`** record |; +-------------------+------------------+---------------------------------------+; | 46 `->` 63 | `fCompress` | Universal Unique ID |; | [58-\>75] | | |; +-------------------+------------------+---------------------------------------+. The first four bytes of the file header contain the string ""root"" which; identifies a file as a ROOT file. Because of this identifier, ROOT is; not dependent on the ""`.root`"" extension. It is still a good idea to use; the extension, just for us to recognize them easier. The `nfree` and; value is the number of free records. This variable along with; `FNBytesFree` keeps track of the free space in terms of records and; bytes. This count also includes the deleted records, which are available; again. ### The Top Directory Description. The 84 bytes after the file header contain the top directory; description, including the name, the date and time it was created, and; the date and time of the last modification. ``` {.cpp}; 20010404/092347 At:64 N=84 TFile; ```. ### The Histogram Records. What follows are the 15 histograms, in records of variable length. ``` {.cpp}; 20010404/092347 At:148 N=380 TH1F CX = 2.49; 20010404/092347 At:528 N=377 TH1F CX = 2.51; ```. The first 4 bytes of each record is an integer holding the number of; bytes in this record. A negative number flags the record as deleted, and; makes the space available for recycling in the next writing. The rest of; bytes in the header contain all the information to identify uniquely a; data block on the file. It is followed by the object data. The next table explains the values in each individual record",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:6584,variab,variable,6584,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['variab'],['variable']
Modifiability,"mproved buffer checking for ``std::initializer_list``; * Add convenience functions ``argc()`` and ``argv()`` to ``cppyy.ll``; * Added ``nullptr`` comparisons for for typed ``nullptr``; * Support for ``using`` pointer types as template arguments; * Walk the full inheritance tree to find the overloads; * Allow ``__destruct__`` override in Python derived class; * Allow ``NULL`` function pointers to be returned as ``std::function`` objects; * Add Python traceback to C++ exception ``what()``. 2022-10-03: 2.4.1; -----------------. * Drop Numba extension entry point. 2022-06-29: 2.4.0; -----------------. * Support for free (templated) functions in Numba; * Basic support for unboxing C++ public data members in Numba; * Basic support for calling methods of C++ structs in Numba; * Added conventional `__cpp_reflex__` method for inspection in Numba; * Support for globally overloaded ordering operators; * Special cases for `__repr__`/`__str__` returning C++ stringy types; * Fix lookup of templates of function with template args; * Correct typing of int8_t/uint8_t enums; * Basic support for hidden enums; * Support function pointer returns and optimize function point variables; * Fix reuse of CPPOverload proxies in vector calls from different threads; * Use `-march=native` instead of checking the cpu for avx; * Workaround for handling exceptions from JITed code on ARM; * Drop ``from cppyy.interactive import *`` from CPython 3.11; * Fix regression in converting `std::vector<T*` to `list`; * Update to the latest patch version of Cling (from 6.26.04). 2022-04-03: 2.3.1; -----------------; * Use portable type Py_ssize_t instead of ssize_t. 2022-03-08: 2.3.0; -----------------. * CUDA support (up to version 10.2); * Allow `std::string_view<char>` initialization from Python `str` (copies); * Provide access to extern ""C"" declared functions in namespaces; * Support for (multiple and nested) anonymous structs; * Pull forward upstream patch for PPC; * Only apply system_dirs patch (for asan) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:3878,variab,variables,3878,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,1,['variab'],['variables']
Modifiability,"mproving performance especially for TTree::Map() by about 35%. This has been achieved with a better caching strategy for request strings (especially avoiding to recalculate the auth base64 encoding), and with a drastic optimization in reading the response headers.; Fixes in the counting of the bytes read. TWebSystem. New implementation of TSystem allowing to use TSystem::AccessPathName() and GetPathInfo() to check if a web file exists and to get its size. Directory browsing is not available yet. NETX; ; TXNetFile. Several fixes and optimisations, mainly in the use of the cache; Fix an offset issue affecting the use of the cache with files in archives. TXNetSystem. A few optimizations in the use of retry mechanism, path locality checks, file online checks. XROOTD. Import a new version of XROOTD (20091202-0509); ; Fixes in bulk prepare and sync readv operations; Add support for 'make install' / 'make uninstall' and; other improvements in configure.classic; Several improvements / fixes:; ; reduced memory and CPU consumption;; extreme cp optimizations;; windows porting; new cache policies on the client side; new listing features implemented recently in the 'cns' module.; optimizations in cmsd and cnsd (performance improvements); support for openssl 1.0.0 (required by Fedora 12). Support for if/else if/else/fi constructs; Several portability fixes; ; Support 32-bit builds with icc on 64-bit platforms; Improved detection of libreadline and lib(n)curses. Increase the flexibility for configuring with an external xrootd; ; Add standard switches to disentangle lib and inc dirs;       --with-xrootd-incdir=<path_to dir_containing_XrdVersion.hh>;       --with-xrootd-libdir=<path_to_dir_containing_xrootd_plugins_and_libs>; ; When; passing a global xrootd dir with --with-xrootd, check both; src/XrdVersion.hh and include/xrootd/XrdVersion.hh so that both build; and install distributions are supported. Fix a problem with the xrootd build when running make via 'sudo' (issue #47644). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v526/index.html:1415,portab,portability,1415,net/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v526/index.html,4,"['config', 'portab']","['configuring', 'portability']"
Modifiability,mptarget/include/Debug.h; openmp/libomptarget/include/device.h; openmp/libomptarget/include/DeviceEnvironment.h; openmp/libomptarget/include/interop.h; openmp/libomptarget/include/omptarget.h; openmp/libomptarget/include/omptargetplugin.h; openmp/libomptarget/include/rtl.h; openmp/libomptarget/include/SourceInfo.h; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.cpp; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.h; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.cpp; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.h; openmp/libomptarget/plugins/amdgpu/impl/hsa_api.h; openmp/libomptarget/plugins/amdgpu/impl/impl.cpp; openmp/libomptarget/plugins/amdgpu/impl/impl_runtime.h; openmp/libomptarget/plugins/amdgpu/impl/internal.h; openmp/libomptarget/plugins/amdgpu/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/libomptarget/plugins/remote/include/Utils.h; openmp/libomptarget/plugins/remote/server/OffloadingServer.cpp; openmp/libomptarget/plugins/remote/server/Server.cpp; openmp/libomptarget/plugins/remote/server/Server.h; openmp/libomptarget/plugins/remote/src/Client.cpp; openmp/libomptarget/plugins/remote/src/Client.h; openmp/libomptarget/plugins/ve/src/rtl.cpp; openmp/libomptarget/src/api.cpp; openmp/libomptarget/src/interface.cpp; openmp/libomptarget/src/interop.cpp; openmp/libomptarget/src/omptarget.cpp; openmp/libomptarget/src/private.h; openmp/libomptarget/src/rtl.cpp; openmp/libomptarget/tools/devi,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:407504,plugin,plugins,407504,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,"mptyParentheses``. .. _SpacesInSquareBrackets:. **SpacesInSquareBrackets** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInSquareBrackets>`; If ``true``, spaces will be inserted after ``[`` and before ``]``.; Lambdas without arguments or unspecified size array declarations will not; be affected. .. code-block:: c++. true: false:; int a[ 5 ]; vs. int a[5];; std::unique_ptr<int[]> foo() {} // Won't be affected. .. _Standard:. **Standard** (``LanguageStandard``) :versionbadge:`clang-format 3.7` :ref:`¶ <Standard>`; Parse and format C++ constructs compatible with this standard. .. code-block:: c++. c++03: latest:; vector<set<int> > x; vs. vector<set<int>> x;. Possible values:. * ``LS_Cpp03`` (in configuration: ``c++03``); Parse and format as C++03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: []; unsigned char data = 'x';; emit signal(data); // This is parsed as variable declaration. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: [emit]; unsigned char data = 'x';; emit signal(data); // Now it's fine again. .. _State",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:129414,config,configuration,129414,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"mpute, as follows (using C syntax):. .. code-block:: c++. idx1 = (char*) &MyVar + 0; idx2 = (char*) &MyVar + 4; idx3 = (char*) &MyVar + 8. Since the type ``i32`` is known to be four bytes long, the indices 0, 1 and 2; translate into memory offsets of 0, 4, and 8, respectively. No memory is; accessed to make these computations because the address of ``@MyVar`` is passed; directly to the GEP instructions. The obtuse part of this example is in the cases of ``%idx2`` and ``%idx3``. They; result in the computation of addresses that point to memory past the end of the; ``@MyVar`` global, which is only one ``i32`` long, not three ``i32``\s long.; While this is legal in LLVM, it is inadvisable because any load or store with; the pointer that results from these GEP instructions would trigger undefined; behavior (UB). Why is the extra 0 index required?; ----------------------------------. Quick answer: there are no superfluous indices. This question arises most often when the GEP instruction is applied to a global; variable which is always a pointer type. For example, consider this:. .. code-block:: text. %MyStruct = external global { ptr, i32 }; ...; %idx = getelementptr { ptr, i32 }, ptr %MyStruct, i64 0, i32 1. The GEP above yields a ``ptr`` by indexing the ``i32`` typed field of the; structure ``%MyStruct``. When people first look at it, they wonder why the ``i64; 0`` index is needed. However, a closer inspection of how globals and GEPs work; reveals the need. Becoming aware of the following facts will dispel the; confusion:. #. The type of ``%MyStruct`` is *not* ``{ ptr, i32 }`` but rather ``ptr``.; That is, ``%MyStruct`` is a pointer (to a structure), not a structure itself. #. Point #1 is evidenced by noticing the type of the second operand of the GEP; instruction (``%MyStruct``) which is ``ptr``. #. The first index, ``i64 0`` is required to step over the global variable; ``%MyStruct``. Since the second argument to the GEP instruction must always; be a value of pointer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:5074,variab,variable,5074,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['variab'],['variable']
Modifiability,"mrchr``, ``sscanf``,; ``getc``, ``getc_unlocked``, ``getdelim``, ``getline``, ``getw``, ``memcmp``,; ``memcpy``, ``memmem``, ``memmove``, ``mbtowc``, ``pread``, ``qsort``,; ``qsort_r``, ``rawmemchr``, ``read``, ``recv``, ``recvfrom``, ``rindex``,; ``strcasestr``, ``strchr``, ``strchrnul``, ``strcasecmp``, ``strcmp``,; ``strcspn``, ``strncasecmp``, ``strncmp``, ``strndup``,; ``strndupa``, ``strpbrk``, ``strrchr``, ``strsep``, ``strspn``,; ``strstr``, ``strtol``, ``strtoll``, ``strtoul``, ``strtoull``, ``tolower``,; ``toupper``, ``ttyname``, ``ttyname_r``, ``wctomb``, ``wcwidth``. Default sinks:; ``printf``, ``setproctitle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/con",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:72698,config,configure,72698,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,2,['config'],"['configuration', 'configure']"
Modifiability,"ms in *list*. The; variable *acc* acts as the accumulator and is initialized to *init*.; The variable *var* is bound to each element in the *list*. The; expression is evaluated for each element and presumably uses *acc* and; *var* to calculate the accumulated value, which ``!foldl`` stores back in; *acc*. The type of *acc* is the same as *init*; the type of *var* is the; same as the elements of *list*; *expr* must have the same type as *init*. The following example computes the total of the ``Number`` field in the; list of records in ``RecList``::. int x = !foldl(0, RecList, total, rec, !add(total, rec.Number));. If your goal is to filter the list and produce a new list that includes only; some of the elements, see ``!filter``. ``!foreach(``\ *var*\ ``,`` *sequence*\ ``,`` *expr*\ ``)``; This operator creates a new ``list``/``dag`` in which each element is a; function of the corresponding element in the *sequence* ``list``/``dag``.; To perform the function, TableGen binds the variable *var* to an element; and then evaluates the expression. The expression presumably refers; to the variable *var* and calculates the result value. If you simply want to create a list of a certain length containing; the same value repeated multiple times, see ``!listsplat``. ``!ge(``\ *a*\ `,` *b*\ ``)``; This operator produces 1 if *a* is greater than or equal to *b*; 0 otherwise.; The arguments must be ``bit``, ``bits``, ``int``, or ``string`` values. ``!getdagarg<``\ *type*\ ``>(``\ *dag*\ ``,``\ *key*\ ``)``; This operator retrieves the argument from the given *dag* node by the; specified *key*, which is either an integer index or a string name. If that; argument is not convertible to the specified *type*, ``?`` is returned. ``!getdagname(``\ *dag*\ ``,``\ *index*\ ``)``; This operator retrieves the argument name from the given *dag* node by the; specified *index*. If that argument has no name associated, ``?`` is; returned. ``!getdagop(``\ *dag*\ ``)`` --or-- ``!getdagop<``\ *type*\ ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:64958,variab,variable,64958,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['variab'],['variable']
Modifiability,"mul nuw <ty> <op1>, <op2> ; yields ty:result; <result> = mul nsw <ty> <op1>, <op2> ; yields ty:result; <result> = mul nuw nsw <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``mul``' instruction returns the product of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``mul``' instruction must be; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both; arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the integer product of the two operands. If the result of the multiplication has unsigned overflow, the result; returned is the mathematical result modulo 2\ :sup:`n`\ , where n is the; bit width of the result. Because LLVM integers use a two's complement representation, and the; result is the same width as the operands, this instruction returns the; correct result for both signed and unsigned integers. If a full product; (e.g. ``i32`` * ``i32`` -> ``i64``) is needed, the operands should be; sign-extended or zero-extended as appropriate to the width of the full; product. ``nuw`` and ``nsw`` stand for ""No Unsigned Wrap"" and ""No Signed Wrap"",; respectively. If the ``nuw`` and/or ``nsw`` keywords are present, the; result value of the ``mul`` is a :ref:`poison value <poisonvalues>` if; unsigned and/or signed overflow, respectively, occurs. Example:; """""""""""""""". .. code-block:: text. <result> = mul i32 4, %var ; yields i32:result = 4 * %var. .. _i_fmul:. '``fmul``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fmul [fast-math flags]* <ty> <op1>, <op2> ; yields ty:result. Overview:; """""""""""""""""". The '``fmul``' instruction returns the product of its two operands. Arguments:; """""""""""""""""""". The two arguments to the '``fmul``' instruction must be; :ref:`floating-point <t_floating>` or :ref:`vector <t_vector>` of; floating-point values. Both arguments must have identical types. Semantics:; """""""""""""""""""". The value produced is the floating-point product of the two operands.; T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:383041,extend,extended,383041,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['extend'],['extended']
Modifiability,"multiclass. In the following example, the ``basic_s``; and ``basic_p`` multiclasses contain ``defm`` statements that refer to the; ``basic_r`` multiclass. The ``basic_r`` multiclass contains only ``def``; statements. .. code-block:: text. class Instruction <bits<4> opc, string Name> {; bits<4> opcode = opc;; string name = Name;; }. multiclass basic_r <bits<4> opc> {; def rr : Instruction<opc, ""rr"">;; def rm : Instruction<opc, ""rm"">;; }. multiclass basic_s <bits<4> opc> {; defm SS : basic_r<opc>;; defm SD : basic_r<opc>;; def X : Instruction<opc, ""x"">;; }. multiclass basic_p <bits<4> opc> {; defm PS : basic_r<opc>;; defm PD : basic_r<opc>;; def Y : Instruction<opc, ""y"">;; }. defm ADD : basic_s<0xf>, basic_p<0xf>;. The final ``defm`` creates the following records, five from the ``basic_s``; multiclass and five from the ``basic_p`` multiclass::. ADDSSrr, ADDSSrm; ADDSDrr, ADDSDrm; ADDX; ADDPSrr, ADDPSrm; ADDPDrr, ADDPDrm; ADDY. A ``defm`` statement, both at top level and in a multiclass, can inherit; from regular classes in addition to multiclasses. The rule is that the; regular classes must be listed after the multiclasses, and there must be at least; one multiclass. .. code-block:: text. class XD {; bits<4> Prefix = 11;; }; class XS {; bits<4> Prefix = 12;; }; class I <bits<4> op> {; bits<4> opcode = op;; }. multiclass R {; def rr : I<4>;; def rm : I<2>;; }. multiclass Y {; defm SS : R, XD; // First multiclass R, then regular class XD.; defm SD : R, XS;; }. defm Instr : Y;. This example will create four records, shown here in alphabetical order with; their fields. .. code-block:: text. def InstrSDrm {; bits<4> opcode = { 0, 0, 1, 0 };; bits<4> Prefix = { 1, 1, 0, 0 };; }. def InstrSDrr {; bits<4> opcode = { 0, 1, 0, 0 };; bits<4> Prefix = { 1, 1, 0, 0 };; }. def InstrSSrm {; bits<4> opcode = { 0, 0, 1, 0 };; bits<4> Prefix = { 1, 0, 1, 1 };; }. def InstrSSrr {; bits<4> opcode = { 0, 1, 0, 0 };; bits<4> Prefix = { 1, 0, 1, 1 };; }. It's also possible to use ``let`` st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:42179,inherit,inherit,42179,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inherit']
Modifiability,"must tell this to CMake with the ``-G`` option. .. todo::. Explain variables and cache. Move explanation here from #options section. .. _Options and variables:. Options and variables; =====================. Variables customize how the build will be generated. Options are boolean; variables, with possible values ON/OFF. Options and variables are defined on the; CMake command line like this:. .. code-block:: console. $ cmake -DVARIABLE=value path/to/llvm/source. You can set a variable after the initial CMake invocation to change its; value. You can also undefine a variable:. .. code-block:: console. $ cmake -UVARIABLE path/to/llvm/source. Variables are stored in the CMake cache. This is a file named ``CMakeCache.txt``; stored at the root of your build directory that is generated by ``cmake``.; Editing it yourself is not recommended. Variables are listed in the CMake cache and later in this document with; the variable name and type separated by a colon. You can also specify the; variable and type on the CMake command line:. .. code-block:: console. $ cmake -DVARIABLE:TYPE=value path/to/llvm/source. Frequently-used CMake variables; -------------------------------. Here are some of the CMake variables that are used often, along with a; brief explanation. For full documentation, consult the CMake manual,; or execute ``cmake --help-variable VARIABLE_NAME``. See `Frequently; Used LLVM-related Variables`_ below for information about commonly; used variables that control features of LLVM and enabled subprojects. .. _cmake_build_type:. **CMAKE_BUILD_TYPE**:STRING; This configures the optimization level for ``make`` or ``ninja`` builds. Possible values:. =========================== ============= ========== ========== ==========================; Build Type Optimizations Debug Info Assertions Best suited for; =========================== ============= ========== ========== ==========================; **Release** For Speed No No Users of LLVM and Clang; **Debug** None Yes Yes Devel",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:6405,variab,variable,6405,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variable']
Modifiability,"must; ``intermediate`` variable locations become machine variable locations.; Within IR, variable locations are always identified by a Value, but in MIR; there can be different types of variable locations. In addition, some IR; locations become unavailable, for example if the operation of multiple IR; instructions are combined into one machine instruction (such as; multiply-and-accumulate) then intermediate Values are lost. To track variable; locations through instruction selection, they are first separated into; locations that do not depend on code generation (constants, stack locations,; allocated virtual registers) and those that do. For those that do, debug; metadata is attached to SDNodes in SelectionDAGs. After instruction selection; has occurred and a MIR function is created, if the SDNode associated with debug; metadata is allocated a virtual register, that virtual register is used as the; variable location. If the SDNode is folded into a machine instruction or; otherwise transformed into a non-register, the variable location becomes; unavailable. Locations that are unavailable are treated as if they have been optimized out:; in IR the location would be assigned ``undef`` by a debug intrinsic, and in MIR; the equivalent location is used. After MIR locations are assigned to each variable, machine pseudo-instructions; corresponding to each ``llvm.dbg.value`` intrinsic are inserted. There are two; forms of this type of instruction. The first form, ``DBG_VALUE``, appears thus:. .. code-block:: text. DBG_VALUE %1, $noreg, !123, !DIExpression(). And has the following operands:; * The first operand can record the variable location as a register,; a frame index, an immediate, or the base address register if the original; debug intrinsic referred to memory. ``$noreg`` indicates the variable; location is undefined, equivalent to an ``undef`` dbg.value operand.; * The type of the second operand indicates whether the variable location is; directly referred to by the DBG",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:26777,variab,variable,26777,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"n <<.; Source: Stephen C. Dewhurst ""C++ Gotchas: Avoiding Common Problems in Coding; and Design"", advise 15. #include <iostream>. void test(int a) {; std::cout << a ? ""a"" : ""b""; // warn; }. void test(int a) {; a << a > 7 ? 1 : 2; // warn; }. different.ObjectUnused; (C++); The object was created but is not being used. struct S {; int x, y;; S(int xx, int yy) : x(xx), y(yy) {}; S(int xx) {; S(xx, 0); // warn; }; };. #include <exception>. void test() {; std::exception();; // warn (did you mean 'throw std::exception()'?); }. different.StaticArrayPtrCompare; (C); Pointer to static array is being compared to NULL. May the subscripting is; missing. void test() {; int a[1][1];; if (a[0] == 0) {}; // warn; }. different.ConversionToBool; (C, C++); Odd implicit conversion to boolean.; Note: possibly merge with ; alpha.core.BoolAssignment. bool test() {; return 1.; // warn; }. bool test() {; return """"; // warn; }. different.ArrayBound; (C++); Out-of-bound dynamic array access.; Note: possibly an enhancement to ; alpha.security.ArrayBoundV2. void test() {; int *p = new int[1];; int i = 1;; if(p[i]) {}; // warn; delete[] p;; }. different.StrcpyInputSize; (C); Buffer copy without checking the size of input.; Note: possibly an enhancement to ; alpha.unix.cstring.OutOfBounds. void test(char* string) {; char buf[24];; strcpy(buf, string); // warn; }. different.IntegerOverflow; (C); Integer overflow.; Note: partially handled by Clang core; (search for 'overflow in expression' warning in Clang tests).; Source: ; CWE-190. #include <limits.h>. int f(int x);. void test() {; f(INT_MAX + 1); // warn; }. #include <limits.h>. int test() {; int x = INT_MAX / 2 + 1;; return x * 2; // warn; }. different.SignExtension; (C); Unexpected sign extension might take place.; Source: ; CWE-194. unsigned long long test(long long sll) {; unsigned long long ull = sll; // warn; return ull;; }. void f(unsigned int i);. void test(int si) {; f(si); // warn; }. unsigned int test(int i) {; return i;; }. different.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:24162,enhance,enhancement,24162,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,2,['enhance'],['enhancement']
Modifiability,"n CMake from it:. .. code-block:: console. $ mkdir your/build/directory; $ cd your/build/directory; $ cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. If you want to use clang instead of GCC, you can add; ``-DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++``.; You can also use ``ccmake``, which provides a curses interface to configure; CMake variables. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using make:. .. code-block:: console. $ make check-all. Setup Clang Tooling Using CMake on Windows; ==========================================. For Windows developers, the Visual Studio project generators in CMake do; not support `CMAKE_EXPORT_COMPILE_COMMANDS; <https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html>`_.; However, the Ninja generator does support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate it. Next, assuming you already have Visual Studio installed on your machine, you; need to have the appropriate environment variables configured so that CMake; will locate the MSVC compiler for the Ninja generator. The `documentation; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#path_and_environment>`_; describes the necessary environment variable settings, but the simplest thing; is to use a `developer command-prompt window; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_prompt_shortcuts>`_; or call a `developer command file; <https://docs.microsoft.co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:2230,variab,variable,2230,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,1,['variab'],['variable']
Modifiability,"n ILP32 machine (other; than debug info). Both get compiled down to an 'i32' value and the; information about what it came from is lost. The more general issue; here, is that the LLVM type system uses ""structural equivalence"" instead; of ""name equivalence"". Another place this surprises people is if you; have two types in a high-level language that have the same structure; (e.g. two different structs that have a single int field): these types; will compile down into a single LLVM type and it will be impossible to; tell what it came from. Second, while LLVM does lose information, LLVM is not a fixed target: we; continue to enhance and improve it in many different ways. In addition; to adding new features (LLVM did not always support exceptions or debug; info), we also extend the IR to capture important information for; optimization (e.g. whether an argument is sign or zero extended,; information about pointers aliasing, etc). Many of the enhancements are; user-driven: people want LLVM to include some specific feature, so they; go ahead and extend it. Third, it is *possible and easy* to add language-specific optimizations,; and you have a number of choices in how to do it. As one trivial; example, it is easy to add language-specific optimization passes that; ""know"" things about code compiled for a language. In the case of the C; family, there is an optimization pass that ""knows"" about the standard C; library functions. If you call ""exit(0)"" in main(), it knows that it is; safe to optimize that into ""return 0;"" because C specifies what the; 'exit' function does. In addition to simple library knowledge, it is possible to embed a; variety of other language-specific information into the LLVM IR. If you; have a specific need and run into a wall, please bring the topic up on; the llvm-dev list. At the very worst, you can always treat LLVM as if it; were a ""dumb code generator"" and implement the high-level optimizations; you desire in your front-end, on the language-specific A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:10177,enhance,enhancements,10177,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,2,"['enhance', 'extend']","['enhancements', 'extend']"
Modifiability,"n SSA form by mem2reg, in the same way; that it uses use-def chains to identify control flow merges and insert phi; nodes for IR Values. However, because debug variable locations are defined for; every machine instruction, in effect every IR instruction uses every variable; location, which would lead to a large number of debugging intrinsics being; generated. Examining the example above, variable ``!30`` is assigned ``%input`` on both; conditional paths through the function, while ``!23`` is assigned differing; constant values on either path. Where control flow merges in ``%bb1`` we would; want ``!30`` to keep its location (``%input``), but ``!23`` to become undefined; as we cannot determine at runtime what value it should have in %bb1 without; inserting a PHI node. mem2reg does not insert the PHI node to avoid changing; codegen when debugging is enabled, and does not insert the other dbg.values; to avoid adding very large numbers of intrinsics. Instead, LiveDebugValues determines variable locations when control; flow merges. A dataflow analysis is used to propagate locations between blocks:; when control flow merges, if a variable has the same location in all; predecessors then that location is propagated into the successor. If the; predecessor locations disagree, the location becomes undefined. Once LiveDebugValues has run, every block should have all valid variable; locations described by DBG_VALUE instructions within the block. Very little; effort is then required by supporting classes (such as; DbgEntityHistoryCalculator) to build a map of each instruction to every; valid variable location, without the need to consider control flow. From; the example above, it is otherwise difficult to determine that the location; of variable ``!30`` should flow ""up"" into block ``%bb1``, but that the location; of variable ``!23`` should not flow ""down"" into the ``%exit`` block. .. _ccxx_frontend:. C/C++ front-end specific debug information; =====================================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:39408,variab,variable,39408,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"n `EventHeader`; object. The `EventHeader` class is described in the following paragraph.; `Event` also has two pointers, one to a **`TClonesArray`** of tracks and; one to a histogram. The string ""`->`"" in the comment field of the; members `*fTracks` and `*fH` instructs the automatic `Streamer` to; assume that the objects `*fTracks` and `*fH` are never null pointers and; that `fTracks->Streamer` can be used instead of the more time consuming; form `R__b << fTracks`. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; static TClonesArray *fgTracks;; static TH1F *fgHist;; // ... list of methods; ClassDef(Event,1) //Event structure; };; ```. ### The EventHeader Class. The `EventHeader` class (also defined in `Event.h`) does not inherit; from **`TObject`**. Beginning with ROOT 3.0, an object can be placed on; a branch even though it does not inherit from **`TObject`**. In previous; releases branches were restricted to objects inheriting from the; **`TObject`**. However, it has always been possible to write a class not; inheriting from **`TObject`** to a tree by encapsulating it in a; **`TObject`** descending class as is the case in `EventHeader` and; `Event`. ``` {.cpp}; class EventHeader {; private:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;; // ... list of methods; ClassDef(EventHeader,1) //Event Header; };; ```. ### The Track Class. The `Track` class descends from **`TObject`** since tracks are in a; **`TClonesArray`** (i.e. a ROOT collection class) and contains a; selection of basic types and an array of vertices. Its **`TObject`**; inheritance enables `Track` to be in a collection and in `Event` is a; **`TClonesArray`** of `Tracks`. ``` {.cpp}; class Track : public TObject {; private:; Float_t fPx; //X component ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:60144,inherit,inherit,60144,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['inherit'],['inherit']
Modifiability,"n ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefiles will only need to define a few; variables. Below is a list of the variables one can set and what they can; do:. Required Variables; ------------------. ``LEVEL``. This variable is the relative path from this ``Makefile`` to the top; directory of your project's source code. For example, if your source code; is in ``/tmp/src``, then the ``Makefile`` in ``/tmp/src/jump/high``; would set ``LEVEL`` to ``""../..""``. Variables for Building Subdirectories; -------------------------------------. ``DIRS``. This is a space separated list of subdirectories that should be built. They; will be built, one at a time, in the order specified. ``PARALLEL_DIRS``. This is a list of directories that can be built in parallel. These will be; built after the directories in DIRS have been built. ``OPTIONAL_DIRS``. This is a list of directories that can be built if they exist, but will not; cause an error if they do not exist. They are built serially in the order; in which they are listed. Variables for Building Libra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:4301,variab,variables,4301,interpreter/llvm-project/llvm/docs/Projects.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst,1,['variab'],['variables']
Modifiability,"n `test/` subdirectories are unit tests, mostly based on; [Google Test](https://github.com/google/googletest) and easily extended. Tests in; [roottest](https://github.com/root-project/roottest.git) are more involved (e.g., tests requiring custom dictionaries or; data files). When you create a branch in the main ROOT repository (i.e., this repository) and add a test to `roottest`,; make sure to do this under the same branch name (and open a PR for it). Our CI infrastructure automatically picks up the; changes defined in the `roottest` PR based on this branch name, and uses that for testing your PR here. ## Continuous Integration. To prevent bad surprises and make a better first impression, we; strongly encourage new developers to [run the tests](https://root.cern/for_developers/run_the_tests/); _before_ submitting a pull request. ROOT has automated CI tests :cop: that are used for pull requests:; - *Build and test*: a [Jenkins-based CI workflow](https://github.com/phsft-bot/build-configuration/blob/master/README.md); as well as a GitHub Actions CI workflow tests PRs automatically; only a; [project member](https://github.com/orgs/root-project/people) is allowed to initiate this build.; The results are posted to the pull request.; Compared to ROOT's nightly builds, PRs are tested with less tests, on less platforms.; - *Formatting check*: `clang-format` automatically checks that a PR; [follows](https://github.com/root-project/root/blob/master/.clang-format) ROOT's; [coding conventions](https://root.cern/contribute/coding_conventions/).; If coding violations are found, it provides you with a `patch` output that you likely want to apply to your PR.; - *Simple Static Analysis*: PRs are analyzed using [`clang-tidy`](https://clang.llvm.org/extra/clang-tidy/). Typically, PRs must pass all these tests; we will ask you to fix any issues that may arise.; Some tests are run only outside the PR testing system:; we might come back to you with additional reports after your contributi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md:6866,config,configuration,6866,CONTRIBUTING.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md,1,['config'],['configuration']
Modifiability,"n actions, e.g. Xterm-like fast movement between words using Ctrl+Left and Ctrl+Right, Ctrl+Del to delete the word under the cursor, or clearing the screen using Ctrl+L. Most users coming from a GUI will find these shortcuts convenient.; A list of the available key bindings is printed by; ```; root [] .help edit; ```. ## I/O Libraries. ### Faster reading from EOS. A new cross-protocol redirection has been added to allow files on EOS mounts to be opened; by `TFile::Open` via XRootD protocol rather than via FUSE when that is possible. The; redirection uses the `eos.url.xroot` extended file attribute that is present on files in EOS.; The attribute can be viewed with `getfattr -n eos.url.xroot [file]` on the command line.; When the URL passed into `TFile::Open` is a for a file on an EOS mount, the extended; attribute is used to attempt the redirection to XRootD protocol. If the redirection fails,; the file is opened using the plain file path as before. This feature is controlled by the; pre-existing configuration option `TFile.CrossProtocolRedirects` and is enabled by default.; It can be disabled by setting `TFile.CrossProtocolRedirects` to `0` in `rootrc`. ## TTree Libraries. ## RNTuple; ROOT's experimental successor of TTree has seen many updates during the last few months. Specifically, v6.28 includes the following changes:. - Complete support for big-endian architectures (PR [#10402](https://github.com/root-project/root/pull/10402)). - Support for `std::pair<T1, T2>` and `std::tuple<Ts...>` fields. - Support for C array fields whose type is of the form `T[N]`. Note that only single-dimension arrays are currently supported. - Improvements to the ROOT file embedding (PR [#10558](https://github.com/root-project/root/pull/10558)). In particular, a `RNTupleReader` or `RDataFrame` object can be created from a `TFile` instance as follows; ```; auto f = TFile::Open(""data.root"");; auto ntpl = f->Get<ROOT::Experimental::RNTuple>(""Events"");. auto reader = ROOT::Experimental::RN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:8318,config,configuration,8318,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['config'],['configuration']
Modifiability,"n compiling C++ code. While it is possible to link C++ code using libstdc++ and code using libc++; together into the same program (so long as you do not attempt to pass C++; standard library objects across the boundary), it is not generally possible; to have more than one C++ ABI library in a program. The version of the C++ ABI library used by Clang will be the one that the; chosen C++ standard library was linked against. Several implementations are; available:. libc++abi (LLVM); ^^^^^^^^^^^^^^^^. `libc++abi <https://libcxxabi.llvm.org/>`_ is LLVM's implementation of this; specification. libsupc++ (GNU); ^^^^^^^^^^^^^^^. libsupc++ is GCC's implementation of this specification. However, this; library is only used when libstdc++ is linked statically. The dynamic; library version of libstdc++ contains a copy of libsupc++. .. note::. Clang does not currently automatically link against libsupc++ when statically; linking libstdc++. You may need to manually add ``-lsupc++`` to support this; configuration when using ``-static`` or ``-static-libstdc++``. libcxxrt (PathScale); ^^^^^^^^^^^^^^^^^^^^. This is another implementation of the Itanium C++ ABI specification.; See `libcxxrt <https://github.com/pathscale/libcxxrt>`_. C++ standard library; --------------------. Clang supports use of either LLVM's libc++ or GCC's libstdc++ implementation; of the `C++ standard library <https://en.cppreference.com/w/cpp>`_. libc++ (LLVM); ^^^^^^^^^^^^^. `libc++ <https://libcxx.llvm.org/>`_ is LLVM's implementation of the C++; standard library, aimed at being a complete implementation of the C++; standards from C++11 onwards. You can instruct Clang to use libc++ with the ``-stdlib=libc++`` flag. libstdc++ (GNU); ^^^^^^^^^^^^^^^. `libstdc++ <https://gcc.gnu.org/onlinedocs/libstdc++/>`_ is GCC's; implementation of the C++ standard library. Clang supports libstdc++; 4.8.3 (released 2014-05-22) and later. Historically Clang implemented; workarounds for issues discovered in libstdc++, and these a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:11731,config,configuration,11731,interpreter/llvm-project/clang/docs/Toolchain.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst,1,['config'],['configuration']
Modifiability,"n configuration: ``Always``); Always put a space before opening parentheses, except when it's; prohibited by the syntax rules (in function-like macro definitions) or; when determined by other style rules (after unary operators, opening; parentheses, etc.). .. code-block:: c++. void f () {; if (true) {; f ();; }; }. * ``SBPO_Custom`` (in configuration: ``Custom``); Configure each individual space before parentheses in; ``SpaceBeforeParensOptions``. .. _SpaceBeforeParensOptions:. **SpaceBeforeParensOptions** (``SpaceBeforeParensCustom``) :versionbadge:`clang-format 14` :ref:`¶ <SpaceBeforeParensOptions>`; Control of individual space before parentheses. If ``SpaceBeforeParens`` is set to ``Custom``, use this to specify; how each individual space before parentheses case should be handled.; Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; SpaceBeforeParens: Custom; SpaceBeforeParensOptions:; AfterControlStatements: true; AfterFunctionDefinitionName: true. Nested configuration flags:. Precise control over the spacing before parentheses. .. code-block:: c++. # Should be declared this way:; SpaceBeforeParens: Custom; SpaceBeforeParensOptions:; AfterControlStatements: true; AfterFunctionDefinitionName: true. * ``bool AfterControlStatements`` If ``true``, put space between control statement keywords; (for/if/while...) and opening parentheses. .. code-block:: c++. true: false:; if (...) {} vs. if(...) {}. * ``bool AfterForeachMacros`` If ``true``, put space between foreach macros and opening parentheses. .. code-block:: c++. true: false:; FOREACH (...) vs. FOREACH(...); <loop-body> <loop-body>. * ``bool AfterFunctionDeclarationName`` If ``true``, put a space between function declaration name and opening; parentheses. .. code-block:: c++. true: false:; void f (); vs. void f();. * ``bool AfterFunctionDefinitionName`` If ``true``, put a space between function definition name and opening; parentheses. .. code-block:: c++. true: false:; void f () {} vs. void f(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:118678,config,configuration,118678,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"n either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (integers and floating-point) variables. ### Writing the Tree. Below is the function that writes the tree (`tree1w`). First, the; variables are defined (`px, py, pz,` `random` and `ev`). Then we add a; branch for each of the variables to the tree, by calling the; `TTree::Branch` method for each variable. ``` {.cpp}; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; ```. #### Creating Branches with A single Variable. This is the signature of `TTree::Branch` to create a branch with a list; of variables:. ``` {.cpp}; TBranch* TTree::Branch(const char* name,void* address,; const char* leaflist,; Int_t bufsize = 32000); ```. The first parameter is the branch name. The second parameter is the; address from which to read the value. The third parameter is the leaf; list with the name and type of each leaf. In this example, each branch; has only one leaf. In the box below, the branch is named `px` and has; one floating",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:35432,variab,variables,35432,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"n entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants of the following instructions have been; removed:. * ``and``; * ``or``; * ``lshr``; * ``ashr``; * ``zext``; * ``sext``; * ``fptrunc``; * ``fpext``; * ``fptoui``; * ``fptosi``; * ``uitofp``; * ``sitofp``. * Added `llvm.exp10` intrinsic. * Added a ``code_model`` attribute for the `global variable <LangRef.html#global-variables>`_. Changes to LLVM infrastructure; ------------------------------. * Minimum Clang version to build LLVM in C++20 configuration has been updated to clang-17.0.6. Changes to building LLVM; ------------------------. Changes to TableGen; -------------------. * Added constructs for debugging TableGen files:. * `dump` keyword to dump messages to standard error, see; https://github.com/llvm/llvm-project/pull/68793.; * `!repr` bang operator to inspect the content of values, see; https://github.com/llvm/llvm-project/pull/68716. Changes to Interprocedural Optimizations; ----------------------------------------. Changes to the AArch64 Backend; ------------------------------. * Added support for Cortex-A520, Cortex-A720 and Cortex-X4 CPUs. * Neoverse-N2 was incorrectly marked as an Armv8.5a core. This has been; changed to an Armv9.0a core. However, crypto options are not enabled; by default for Armv9 cores, so `-mcpu=neoverse-n2+crypto` is now required; to enable crypto for this core. As far as the compiler is concerned,; Armv9.0a has the same features enabled as Armv8.5a, with the exception; of crypto. * ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:2442,config,configuration,2442,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,1,['config'],['configuration']
Modifiability,"n environments where the call to; ``lit`` is issued indirectly. A test name can specified as a file name relative to the test suite directory.; For example:. .. code-block:: none. LIT_XFAIL=""affinity/kmp-hw-subset.c;offloading/memory_manager.cpp"". In this case, all of the following tests are treated as ``XFAIL``:. .. code-block:: none. libomp :: affinity/kmp-hw-subset.c; libomptarget :: nvptx64-nvidia-cuda :: offloading/memory_manager.cpp; libomptarget :: x86_64-pc-linux-gnu :: offloading/memory_manager.cpp. Alternatively, a test name can be specified as the full test name; reported in LIT output. For example, we can adjust the previous; example not to treat the ``nvptx64-nvidia-cuda`` version of; ``offloading/memory_manager.cpp`` as XFAIL:. .. code-block:: none. LIT_XFAIL=""affinity/kmp-hw-subset.c;libomptarget :: x86_64-pc-linux-gnu :: offloading/memory_manager.cpp"". .. option:: --xfail-not=LIST. Do not treat the specified tests as ``XFAIL``. The environment variable; ``LIT_XFAIL_NOT`` can also be used in place of this option. The syntax is the; same as for :option:`--xfail` and ``LIT_XFAIL``. :option:`--xfail-not` and; ``LIT_XFAIL_NOT`` always override all other ``XFAIL`` specifications,; including an :option:`--xfail` appearing later on the command line. The; primary purpose is to suppress an ``XPASS`` result without modifying a test; case that uses the ``XFAIL`` directive. ADDITIONAL OPTIONS; ------------------. .. option:: --debug. Run :program:`lit` in debug mode, for debugging configuration issues and; :program:`lit` itself. .. option:: --show-suites. List the discovered test suites and exit. .. option:: --show-tests. List all of the discovered tests and exit. EXIT STATUS; -----------. :program:`lit` will exit with an exit code of 1 if there are any FAIL or XPASS; results. Otherwise, it will exit with the status 0. Other exit codes are used; for non-test related failures (for example a user error or an internal program; error). .. _test-discovery:. TEST DISCO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:9944,variab,variable,9944,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['variab'],['variable']
Modifiability,"n general, low; values of $\mbox{level}$ mean fewer function calls and high values; mean more reliable minimization. Currently allowed values are 0 (low), 1; (default), and 2 (high). ### MnStrategy() ###. Default constructor, sets all settings according to; $\mbox{level}$$ = 1.$. ### MnStrategy(unsigned int level) ###. Explicit constructor for predefined settings of desired; $\mbox{level}$ 0 (low), 1 (default), or 2 (high). ### setLowStrategy(), setMediumStrategy(), setHighStrategy() ###. Methods to set specific strategy level. ### Other methods ###. In addition, methods for individual settings such as; setGradientNCycles() are provided. ## MnUserCovariance ##. [api:covariance] MnUserCovariance is the external covariance matrix; designed for the interaction of the user. The result of the minimization; (internal covariance matrix) is converted into the user representable; format. It can also be used as input prior to the minimization. The size; of the covariance matrix is according to the number of variable; parameters (free and limited). ### MnUserCovariance(const std::vector$<$double$>$&, unsigned int nrow) ###. Construct from data, positions of the elements in the array are arranged; according to the packed storage format. The size of the array must be; $nrow*(nrow+1)/2$. The array must contain the upper triangular part of; the symmetric matrix packed sequentially, column by column, so that; arr(0) contains covar(0,0), arr(1) and arr(2) contain covar(0,1) and; covar(1,1) respectively, and so on. The number of rows (columns) has to; be specified. ### MnUserCovariance(unsigned int nrow) ###. Specify the number of rows (columns) at instantiation. It will allocate; an array of the length $nrow*(nrow+1)/2$ and initialize it to $0$.; Elements can then be set using the method operator()(unsigned int,; unsigned int). ### MnUserCovariance::operator()(unsigned int, unsigned int) ###. Individual elements can be accessed via the operator(), both for reading; and writing. ## M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:52055,variab,variable,52055,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability,"n global values to suppress mangling.; #. Unnamed values are represented as an unsigned numeric value with; their prefix. For example, ``%12``, ``@2``, ``%44``.; #. Constants, which are described in the section Constants_ below. LLVM requires that values start with a prefix for two reasons: Compilers; don't need to worry about name clashes with reserved words, and the set; of reserved words may be expanded in the future without penalty.; Additionally, unnamed identifiers allow a compiler to quickly come up; with a temporary variable without having to avoid symbol table; conflicts. Reserved words in LLVM are very similar to reserved words in other; languages. There are keywords for different opcodes ('``add``',; '``bitcast``', '``ret``', etc...), for primitive type names ('``void``',; '``i32``', etc...), and others. These reserved words cannot conflict; with variable names, because none of them start with a prefix character; (``'%'`` or ``'@'``). Here is an example of LLVM code to multiply the integer variable; '``%X``' by 8:. The easy way:. .. code-block:: llvm. %result = mul i32 %X, 8. After strength reduction:. .. code-block:: llvm. %result = shl i32 %X, 3. And the hard way:. .. code-block:: llvm. %0 = add i32 %X, %X ; yields i32:%0; %1 = add i32 %0, %0 ; yields i32:%1; %result = add i32 %1, %1. This last way of multiplying ``%X`` by 8 illustrates several important; lexical features of LLVM:. #. Comments are delimited with a '``;``' and go until the end of line.; #. Unnamed temporaries are created when the result of a computation is; not assigned to a named value.; #. By default, unnamed temporaries are numbered sequentially (using a; per-function incrementing counter, starting with 0). However, when explicitly; specifying temporary numbers, it is allowed to skip over numbers. Note that basic blocks and unnamed function parameters are included in this; numbering. For example, if the entry basic block is not given a label name; and all function parameters are named",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:4505,variab,variable,4505,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"n goals for the driver, as; well as details of the internal implementation. Features and Goals; ==================. The Clang driver is intended to be a production quality compiler driver; providing access to the Clang compiler and tools, with a command line; interface which is compatible with the gcc driver. Although the driver is part of and driven by the Clang project, it is; logically a separate tool which shares many of the same goals as Clang:. .. contents:: Features; :local:. GCC Compatibility; -----------------. The number one goal of the driver is to ease the adoption of Clang by; allowing users to drop Clang into a build system which was designed to; call GCC. Although this makes the driver much more complicated than; might otherwise be necessary, we decided that being very compatible with; the gcc command line interface was worth it in order to allow users to; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possible.; - Don't parse arguments more than once.; - Provide a few simple interfaces for efficiently searching arguments. Simple; ------. Finally, the driver was designed to be ""as simple as possible"", gi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:1221,flexible,flexible,1221,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['flexible'],['flexible']
Modifiability,"n how to reduce cycle times. Restrict what you build and test; Think hard about why you're setting up a bot, and restrict your build; configuration as much as you can. Basic functionality is probably; already covered by other bots, and you don't need to duplicate that; testing. You only need to be building and testing the *unique* parts; of the configuration. (e.g. For a multi-stage clang builder, you probably; don't need to be enabling every target or building all the various utilities.). It can sometimes be worthwhile splitting a single builder into two or more,; if you have multiple distinct purposes for the same builder. As an example,; if you want to both a) confirm that all of LLVM builds with your host; compiler, and b) want to do a multi-stage clang build on your target, you; may be better off with two separate bots. Splitting increases resource; consumption, but makes it easy for each bot to keep up with commit flow.; Additionally, splitting bots may assist in triage by narrowing attention to; relevant parts of the failing configuration. In general, we recommend Release build types with Assertions enabled. This; generally provides a good balance between build times and bug detection for; most buildbots. There may be room for including some debug info (e.g. with; `-gmlt`), but in general the balance between debug info quality and build; times is a delicate one. Use Ninja & LLD; Ninja really does help build times over Make, particularly for highly; parallel builds. LLD helps to reduce both link times and memory usage; during linking significantly. With a build machine with sufficient; parallelism, link times tend to dominate critical path of the build, and are; thus worth optimizing. Use CCache and NOT incremental builds; Using ccache materially improves average build times. Incremental builds; can be slightly faster, but introduce the risk of build corruption due to; e.g. state changes, etc... At this point, the recommendation is not to; use incremental build",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:10374,config,configuration,10374,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['config'],['configuration']
Modifiability,"n instance; of TProofDataSetManagerFile; managing the <sandbox>/datasets; area is created. The directive 'Proof.DataSetManager' can be used to; modify the settings for TProofDataSetManagerFile or to load a; different dataset manager; for example, to '/pool/datasets' as area for; the dataset information, the following directive can be added to the; xrootd config file; xpd.putrc Proof.DataSetManager file dir:/pool/datasets. Interface to TProofMgr::GetSessionLogs() in the dialog; box. The graphics layout of the logbox has been re-designed, with new; buttons to grep the logs and to save them to a file. It is also; possible to choose the range of lines to be displayed and the subset of; nodes.; ; Support for connection control base on the UNIX group; (new directive 'xpd.allowedgroups; <grp1>,<grp2>, ...'). Improvements:. ; In the case of mismatch between the expected and actual; number of processed events, send back to the client the list of failed; packets.; Implement the classic strategy of the TPacketizer in; TPacketizerAdaptive; the strategy can be changed from adaptive; (default) to TPacketizer with: ""PROOF_PacketizerStrategy"" parameter to; PROOF; The max workers per node can now be also set in the; xrootd config file with.        xpd.putrc ; Packetizer.MaxWorkersPerNode: <desired number>. Make fCacheDir and fPackageDir controllable via directive; . Fixes. ; Two memory leaks in TProofServ affecting repeated runs; withing the same session. Fix a problem cleaning-up the input list on the workers; ; The type of ""PROOF_MaxSlavesPerNode"",;  ""PROOF_ForceLocal"" and;  ""PROOF_PacketAsAFraction"" parameters has been changed from; Long_t to Int_t. ; TProofCondor plug-in:; ; Adapt the signatures of the main constructors of; TProofCondor and TProofPEAC; (and of the related plug-in handlers) to the one of TProof.; Add the possibility to trigger the load of a generic; TProof-derived plug-in via; a directive the xrootd config file 'xpd.proofplugin', e.g.; 'xpd.proofplugin condor:'. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v520/index.html:1583,adapt,adaptive,1583,proof/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v520/index.html,13,"['Adapt', 'adapt', 'config', 'plug-in']","['Adapt', 'adaptive', 'config', 'plug-in']"
Modifiability,"n is available. See the discussion in the section about; :ref:`merging locations<WhenToMergeLocation>` for examples of when the rule for; dropping locations applies. Rules for updating debug values; ===============================. Deleting an IR-level Instruction; --------------------------------. When an ``Instruction`` is deleted, its debug uses change to ``undef``. This is; a loss of debug info: the value of one or more source variables becomes; unavailable, starting with the ``llvm.dbg.value(undef, ...)``. When there is no; way to reconstitute the value of the lost instruction, this is the best; possible outcome. However, it's often possible to do better:. * If the dying instruction can be RAUW'd, do so. The; ``Value::replaceAllUsesWith`` API transparently updates debug uses of the; dying instruction to point to the replacement value. * If the dying instruction cannot be RAUW'd, call ``llvm::salvageDebugInfo`` on; it. This makes a best-effort attempt to rewrite debug uses of the dying; instruction by describing its effect as a ``DIExpression``. * If one of the **operands** of a dying instruction would become trivially; dead, use ``llvm::replaceAllDbgUsesWith`` to rewrite the debug uses of that; operand. Consider the following example function:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %b = sext i16 %a to i32; %c = and i32 %b, 15; call void @llvm.dbg.value(metadata i32 %c, ...); %d = trunc i32 %c to i16; ret i16 %d; }. Now, here's what happens after the unnecessary truncation instruction ``%d`` is; replaced with a simplified instruction:. .. code-block:: llvm. define i16 @foo(i16 %a) {; call void @llvm.dbg.value(metadata i32 undef, ...); %simplified = and i16 %a, 15; ret i16 %simplified; }. Note that after deleting ``%d``, all uses of its operand ``%c`` become; trivially dead. The debug use which used to point to ``%c`` is now ``undef``,; and debug info is needlessly lost. To solve this problem, do:. .. code-block:: cpp. llvm::replaceAllDbgUsesWith(%c, th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:7229,rewrite,rewrite,7229,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['rewrite'],['rewrite']
Modifiability,"n is fully general: you can pass the address of the stack slot; to functions, you can store it in other variables, etc. In our example; above, we could rewrite the example to use the alloca technique to avoid; using a PHI node:. .. code-block:: llvm. @G = weak global i32 0 ; type of @G is i32*; @H = weak global i32 0 ; type of @H is i32*. define i32 @test(i1 %Condition) {; entry:; %X = alloca i32 ; type of %X is i32*.; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; store i32 %X.0, i32* %X ; Update X; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; store i32 %X.1, i32* %X ; Update X; br label %cond_next. cond_next:; %X.2 = load i32, i32* %X ; Read X; ret i32 %X.2; }. With this, we have discovered a way to handle arbitrary mutable; variables without the need to create Phi nodes at all:. #. Each mutable variable becomes a stack allocation.; #. Each read of the variable becomes a load from the stack.; #. Each update of the variable becomes a store to the stack.; #. Taking the address of a variable just uses the stack address; directly. While this solution has solved our immediate problem, it introduced; another one: we have now apparently introduced a lot of stack traffic; for very simple and common operations, a major performance problem.; Fortunately for us, the LLVM optimizer has a highly-tuned optimization; pass named ""mem2reg"" that handles this case, promoting allocas like this; into SSA registers, inserting Phi nodes as appropriate. If you run this; example through the pass, for example, you'll get:. .. code-block:: bash. $ llvm-as < example.ll | opt -passes=mem2reg | llvm-dis; @G = weak global i32 0; @H = weak global i32 0. define i32 @test(i1 %Condition) {; entry:; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; br label %cond_next. cond_next:; %X.01 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:6337,variab,variable,6337,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"n memory; location, loads from that location return undef. Relevant standard; This is intended to match shared variables in C/C++, and to be used in any; other context where memory access is necessary, and a race is impossible. (The; precise definition is in `LangRef Memory Model <LangRef.html#memmodel>`_.). Notes for frontends; The rule is essentially that all memory accessed with basic loads and stores; by multiple threads should be protected by a lock or other synchronization;; otherwise, you are likely to run into undefined behavior. If your frontend is; for a ""safe"" language like Java, use Unordered to load and store any shared; variable. Note that NotAtomic volatile loads and stores are not properly; atomic; do not try to use them as a substitute. (Per the C/C++ standards,; volatile does provide some limited guarantees around asynchronous signals, but; atomics are generally a better solution.). Notes for optimizers; Introducing loads to shared variables along a codepath where they would not; otherwise exist is allowed; introducing stores to shared variables is not. See; `Optimization outside atomic`_. Notes for code generation; The one interesting restriction here is that it is not allowed to write to; bytes outside of the bytes relevant to a store. This is mostly relevant to; unaligned stores: it is not allowed in general to convert an unaligned store; into two aligned stores of the same width as the unaligned store. Backends are; also expected to generate an i8 store as an i8 store, and not an instruction; which writes to surrounding bytes. (If you are writing a backend for an; architecture which cannot satisfy these restrictions and cares about; concurrency, please send an email to llvm-dev.). Unordered; ---------. Unordered is the lowest level of atomicity. It essentially guarantees that races; produce somewhat sane results instead of having undefined behavior. It also; guarantees the operation to be lock-free, so it does not depend on the data; being part",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:7157,variab,variables,7157,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,2,['variab'],['variables']
Modifiability,"n no target is explicitly specified.; It defaults to ""host"", meaning that it shall pick the architecture; of the machine where LLVM is being built. If you are building a cross-compiler,; set it to the target triple of your desired architecture. **LLVM_DOXYGEN_QCH_FILENAME**:STRING; The filename of the Qt Compressed Help file that will be generated when; ``-DLLVM_ENABLE_DOXYGEN=ON`` and; ``-DLLVM_ENABLE_DOXYGEN_QT_HELP=ON`` are given. Defaults to; ``org.llvm.qch``.; This option is only useful in combination with; ``-DLLVM_ENABLE_DOXYGEN_QT_HELP=ON``;; otherwise it has no effect. **LLVM_DOXYGEN_QHELPGENERATOR_PATH**:STRING; The path to the ``qhelpgenerator`` executable. Defaults to whatever CMake's; ``find_program()`` can find. This option is only useful in combination with; ``-DLLVM_ENABLE_DOXYGEN_QT_HELP=ON``; otherwise it has no; effect. **LLVM_DOXYGEN_QHP_CUST_FILTER_NAME**:STRING; See `Qt Help Project`_ for; more information. Defaults to the CMake variable ``${PACKAGE_STRING}`` which; is a combination of the package name and version string. This filter can then; be used in Qt Creator to select only documentation from LLVM when browsing; through all the help files that you might have loaded. This option is only; useful in combination with ``-DLLVM_ENABLE_DOXYGEN_QT_HELP=ON``;; otherwise it has no effect. .. _Qt Help Project: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-filters. **LLVM_DOXYGEN_QHP_NAMESPACE**:STRING; Namespace under which the intermediate Qt Help Project file lives. See `Qt; Help Project`_; for more information. Defaults to ""org.llvm"". This option is only useful in; combination with ``-DLLVM_ENABLE_DOXYGEN_QT_HELP=ON``; otherwise; it has no effect. **LLVM_DOXYGEN_SVG**:BOOL; Uses .svg files instead of .png files for graphs in the Doxygen output.; Defaults to OFF. .. _llvm_enable_assertions:. **LLVM_ENABLE_ASSERTIONS**:BOOL; Enables code assertions. Defaults to ON if and only if ``CMAKE_BUILD_TYPE``; is *Debug*. **LLVM_ENABLE_BINDINGS**",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:19290,variab,variable,19290,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variable']
Modifiability,"n operations when `-ffast-math` is used. Inductions; ^^^^^^^^^^. In this example the value of the induction variable ``i`` is saved into an; array. The Loop Vectorizer knows to vectorize induction variables. .. code-block:: c++. void bar(float *A, int n) {; for (int i = 0; i < n; ++i); A[i] = i;; }. If Conversion; ^^^^^^^^^^^^^. The Loop Vectorizer is able to ""flatten"" the IF statement in the code and; generate a single stream of instructions. The Loop Vectorizer supports any; control flow in the innermost loop. The innermost loop may contain complex; nesting of IFs, ELSEs and even GOTOs. .. code-block:: c++. int foo(int *A, int *B, int n) {; unsigned sum = 0;; for (int i = 0; i < n; ++i); if (A[i] > B[i]); sum += A[i] + 5;; return sum;; }. Pointer Induction Variables; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. This example uses the ""accumulate"" function of the standard c++ library. This; loop uses C++ iterators, which are pointers, and not integer indices.; The Loop Vectorizer detects pointer induction variables and can vectorize; this loop. This feature is important because many C++ programs use iterators. .. code-block:: c++. int baz(int *A, int n) {; return std::accumulate(A, A + n, 0);; }. Reverse Iterators; ^^^^^^^^^^^^^^^^^. The Loop Vectorizer can vectorize loops that count backwards. .. code-block:: c++. void foo(int *A, int n) {; for (int i = n; i > 0; --i); A[i] +=1;; }. Scatter / Gather; ^^^^^^^^^^^^^^^^. The Loop Vectorizer can vectorize code that becomes a sequence of scalar instructions; that scatter/gathers memory. .. code-block:: c++. void foo(int * A, int * B, int n) {; for (intptr_t i = 0; i < n; ++i); A[i] += B[i * 4];; }. In many situations the cost model will inform LLVM that this is not beneficial; and LLVM will only vectorize such code if forced with ""-mllvm -force-vector-width=#"". Vectorization of Mixed Types; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The Loop Vectorizer can vectorize programs with mixed types. The Vectorizer; cost model can estimate the cost of the t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst:7457,variab,variables,7457,interpreter/llvm-project/llvm/docs/Vectorizers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst,1,['variab'],['variables']
Modifiability,"n options for MVA method :. Configuration options reference for MVA method: PDERS. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). VolumeRangeMode No Adaptive Unscaled, MinMax, RMS, Adaptive, kNN Method to determine volume size. KernelEstimator No Box Box, Sphere, Teepee, Gauss, Sinc3, Sinc5, Sinc7, Sinc9, Sinc11, Lanczos2, Lanczos3, Lanczos5, Lanczos8, Trim Kernel estimation function. DeltaFrac No 3 − nEventsMin/Max for minmax and rms volume range. NEventsMin No 100 − nEventsMin for adaptive volume range. NEventsMax No 200 − nEventsMax for adaptive volume range. MaxVIterations No 150 − MaxVIterations for adaptive volume range. InitialScale No 0.99 − InitialScale for adaptive volume range. GaussSigma No 0.1 − Width (wrt volume size) of Gaussian kernel estimator. NormTree No False − Normalize binary search tree. Configuration options for MVA method :. Configuration options reference for MVA method: FDA. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:4386,Adapt,Adaptive,4386,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,2,['Adapt'],['Adaptive']
Modifiability,"n or variable name. On XCOFF targets, ``dllexport`` indicates; that the symbol will be made visible to other modules using ""exported""; visibility and thus placed by the linker in the loader section symbol table.; Since this storage class exists for defining a dll interface, the compiler,; assembler and linker know it is externally referenced and must refrain from; deleting the symbol. A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage; class. .. _tls_model:. Thread Local Storage Models; ---------------------------. A variable may be defined as ``thread_local``, which means that it will; not be shared by threads (each thread will have a separated copy of the; variable). Not all targets support thread-local variables. Optionally, a; TLS model may be specified:. ``localdynamic``; For variables that are only used within the current shared library.; ``initialexec``; For variables in modules that will not be loaded dynamically.; ``localexec``; For variables defined in the executable and only used within it. If no explicit model is given, the ""general dynamic"" model is used. The models correspond to the ELF TLS models; see `ELF Handling For; Thread-Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for; more information on under which circumstances the different models may; be used. The target may choose a different TLS model if the specified; model is not supported, or if a better choice of model can be made. A model can also be specified in an alias, but then it only governs how; the alias is accessed. It will not have any effect in the aliasee. For platforms without linker support of ELF TLS model, the -femulated-tls; flag can be used to generate GCC compatible emulated TLS code. .. _runtime_preemption_model:. Runtime Preemption Specifiers; -----------------------------. Global variables, functions and aliases may have an optional runtime preemption; specifier. If a preemption specifier isn't given explicitly, then a; symbol is assumed to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:26058,variab,variables,26058,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,n other observables; rf302_utilfuncs.C - Utility functions classes available for use in tailoring; rf303_conditional.C - Use of tailored p.d.f as conditional p.d.fs.s; rf304_uncorrprod.C - Simple uncorrelated multi-dimensional p.d.f.s; rf305_condcorrprod.C - Multi-dimensional p.d.f.s with conditional p.d.fs in product; rf306_condpereventerrors.C - Complete example with use of conditional p.d.f. with per-event errors; rf307_fullpereventerrors.C -Complete example with use of full p.d.f. with per-event errors; rf308_normintegration2d.C - Examples on normalization of p.d.f.s in more than one dimension; rf309_ndimplot.C - Making 2 and 3 dimensional plots of p.d.f.s and datasets; rf310_sliceplot.C -Projecting p.d.f and data slices in discrete observables; rf311_rangeplot.C -Projecting p.d.f and data ranges in continuous observables; rf312_multirangefit.C - Performing fits in multiple (disjoint) ranges in one or more dimensions; rf313_paramranges.C - Working with parameterized ranges to define non-rectangular regions; rf314_paramfitrange.C - Working with parameterized ranges in a fit.; rf315_projectpdf.C - Marginizalization of multi-dimensional p.d.f.s through integration; rf316_llratioplot.C - Using the likelihood ratio technique to construct a signal enhanced 1-D projection of a multi-dimensional p.d.f.; ; DATA AND CATEGORIES. rf401_importttreethx.C -Overview of advanced option for importing data from ROOT TTree and THx histograms; rf402_datahandling.C - Tools for manipulation of (un)binned datasets; rf403_weightedevts.C - Using weights in unbinned datasets; rf404_categories.C - Working with RooCategory objects to describe discrete variables; rf405_realtocatfuncs.C - Demonstration of real-->discrete mapping functions; rf406_cattocatfuncs.C - Demonstration of discrete-->discrete (invertable) functions; rf407_latextables.C - Latex printing of lists and sets of RooArgSets; ; ORGANIZATION AND SIMULTANEOUS FITS. rf501_simultaneouspdf.C - Using simultaneous p.d.f.s to describe ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:3192,parameteriz,parameterized,3192,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,2,['parameteriz'],['parameterized']
Modifiability,"n pick the size; int Alignment = alignment;. // CopyCost is the cost of copying a value between two registers; // default value 1 means a single instruction; // A negative value means copying is extremely expensive or impossible; int CopyCost = 1;; dag MemberList = regList;. // for register classes that are subregisters of this class; list<RegisterClass> SubRegClassList = [];. code MethodProtos = [{}]; // to insert arbitrary code; code MethodBodies = [{}];; }. To define a ``RegisterClass``, use the following 4 arguments:. * The first argument of the definition is the name of the namespace. * The second argument is a list of ``ValueType`` register type values that are; defined in ``include/llvm/CodeGen/ValueTypes.td``. Defined values include; integer types (such as ``i16``, ``i32``, and ``i1`` for Boolean),; floating-point types (``f32``, ``f64``), and vector types (for example,; ``v8i16`` for an ``8 x i16`` vector). All registers in a ``RegisterClass``; must have the same ``ValueType``, but some registers may store vector data in; different configurations. For example a register that can process a 128-bit; vector may be able to handle 16 8-bit integer elements, 8 16-bit integers, 4; 32-bit integers, and so on. * The third argument of the ``RegisterClass`` definition specifies the; alignment required of the registers when they are stored or loaded to; memory. * The final argument, ``regList``, specifies which registers are in this class.; If an alternative allocation order method is not specified, then ``regList``; also defines the order of allocation used by the register allocator. Besides; simply listing registers with ``(add R0, R1, ...)``, more advanced set; operators are available. See ``include/llvm/Target/Target.td`` for more; information. In ``SparcRegisterInfo.td``, three ``RegisterClass`` objects are defined:; ``FPRegs``, ``DFPRegs``, and ``IntRegs``. For all three register classes, the; first argument defines the namespace with the string ""``SP``"". ``FPRegs",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:22038,config,configurations,22038,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['config'],['configurations']
Modifiability,"n tag in a Debian; package (.deb); --rpm-tag RPM_TAG Package the snapshot of a given tag in an RPM package; (.rpm); --nsis-tag NSIS_TAG Package the snapshot of a given tag in an NSIS; installer (.exe); --dmg-tag DMG_TAG Package the snapshot of a given tag in a DMG package; (.dmg); --with-llvm-url WITH_LLVM_URL; Specify an alternate URL of LLVM repo; --with-clang-url WITH_CLANG_URL; Specify an alternate URL of Clang repo; --with-cling-url WITH_CLING_URL; Specify an alternate URL of Cling repo; --no-test Do not run test suite of Cling; --create-dev-env CREATE_DEV_ENV; Set up a release/debug environment; --with-workdir WITH_WORKDIR; Specify an alternate working directory for CPT; --make-proper MAKE_PROPER; Internal option to support calls from build system. ```; If you want CPT to build a package by detecting your platform automatically,; use the value 'pkg'.; ```sh; ./cpt.py --current-dev=pkg; ```; or; ```sh; ./cpt.py --last-stable=pkg; ```; ### Overriding Default Variables; There are a select number of variables which can be set to make CPT work; differently. This eliminates the need to manually edit the script.; You can overrride variables by using the following syntax:; ```$ ./cpt.py --with-cling-url=""http://github.com/ani07nov/cling"" --current-dev=tar```. List of variables in CPT which can be overridden:; - **CLING_GIT_URL**; * Specify the URL of the Git repository of Cling to be used by CPT; * **Default value:** ""http://root.cern.ch/git/cling.git""; * **Usage:** ```./cpt.py --with-cling-url=""http://github.com/ani07nov/cling"" --last-stable=deb```. - **CLANG_GIT_URL**; * Specify the URL of the Git repository of Clang to be used by CPT; * **Default value:** ""http://root.cern.ch/git/clang.git""; * **Usage:** ```./cpt.py --with-clang-url=""http://github.com/ani07nov/clang"" --last-stable=tar```. - **LLVM_GIT_URL**; * Specify the URL of the Git repository of LLVM to be used by CPT; * **Default value:** ""http://root.cern.ch/git/llvm.git""; * **Usage:** ```./cpt.py --with-llvm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md:8277,variab,variables,8277,interpreter/cling/tools/packaging/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md,1,['variab'],['variables']
Modifiability,"n the log dialog or form; TProofMgr::GetSessionLogs() .; To add options to valgrind execute; TProof::AddEnvVar(""PROOF_WRAPPERCMD"",; ""valgrind_opts:<options>"") before starting the; session. ; Add new static TProof::LogViewer(""<master>""); to graphically browse the session logs independently of the progress; dialog. The improved log window allows to chose a different master; and/or session  and displays human readable information about; the starting time of the session being browsed.; A set of scripts for quick interaction with a dataset; manager via PROOF are available under $ROOTSYS/etc/proof/utils/pq2 .; The scripts are prefixed; pq2 (proof; quick query - or; proof-dq2); and allow to {browse, register, remove, verify} datasets on a given; PROOF master. See $ROOTSYS/etc/proof/utils/pq2/README for more; information. Improvements. Enable by default schema evolution in TMessage; can be; disabled setting 'Proof.SchemaEvolution:; 0' .; Extend the functionality of the dataset API to obtaine; information on per-server base; add also two new methods:. TProof::SetDataSetTreeName(<dataset>,<treename>):; set/change the default tree name in the TFileCollection;; TProof::ExistsDataSet(<dataset>):; check; by-name the availability of a given dataset;. In ProofBench, . Load the macro before executing it. This allows to; circumvent a problem recently fixed giving less dependency on the; server version.; In make_dset.C, simplification of the body and of the; signature, eliminating one redundant argument. In TProofOutputFile, improve flexibility in defining the; URL for the local files server. The ""LOCALDATASERVER"" env is tested,; which can defined with placeholders via the xpd.putenv directive in the; xrootd/xproofd config files.; Improving parsing of lines with memory info.; This solves occasional crashes while generating the memory; plots.; In TProofMgr::GetSessionLogs:. add the possibility to postpone the retrieval of the; logs files when the TProofLog object is created. This impro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:5118,Extend,Extend,5118,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['Extend'],['Extend']
Modifiability,"n the longer TBits that are passed the length; of the shorter TBits are zero (i.e. the default value of each; bits is zero).; Properly handle scripts with line longer than 1024 characters.; Repair the handling of ACLiC options on the command line (for example a.C+g).; In TClass::BuildEmulatedRealData properly handle the case of TNamed member that are not base class.; On the command line:; ; Fix the tab-completion of filenames in the sub-directories.; Prevent the unadvertent replacement of an arrow with a dot when the left side is actually a pointer. More user friendly stacktrace in case of a crash, with hints where; the problem might be. On Linux and MacOS X these stacktraces are generated; by the script $ROOTSYS/etc/gdb-backtrace.sh. Using the Root.StackTraceMessage; resource one can customize the message printed by the script. The entire; script can be replaced using the Root.StacktraceScript resource.; Numerous minor bug fixes... New module editline ; The new module editline enhances the prompt, giving type and syntax feedback using e.g. colors.; Class names are highlighted blue when typed, indicating that it is known to ROOT.; Matching parenthesis pairs are highlighted green when typed, or when the cursor is moved to a bracket. This works for () {} and [] brackets.; Any mismatched brackets (those without a matching partner) will be highlighted red when typed or when the cursor is moved to the bracket.; Tab completion output is colored magenta to differentiate between tab completion output and user input.; All of the colors are configurable in the .rootrc file.; They can be specified as #rgb or #rrggbb or color names:; black, red, green, yellow, blue, magenta, cyan or white.; They can be followed by an optional bold (alias light) or underlined.; Rint.ReverseColor allows to quickly toggle between the default ""light on dark"" (yes) instead of ""dark on light"" (no), depending on the terminal background.; An example configuration would be:. Rint.TypeColor: blue; Rint.B",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v526/index.html:1515,enhance,enhances,1515,core/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v526/index.html,2,['enhance'],['enhances']
Modifiability,"n the stack and migrate them to the heap; only as a result of a ``Block_copy()`` operation. It is a runtime error to attempt to assign a reference to a; stack-based Block into any storage marked ``__weak``, including; ``__weak`` ``__block`` variables. C++ Extensions; ==============. Block literal expressions within functions are extended to allow const; use of C++ objects, pointers, or references held in automatic storage. As usual, within the block, references to captured variables become; const-qualified, as if they were references to members of a const; object. Note that this does not change the type of a variable of; reference type. For example, given a class Foo:. .. code-block:: c. Foo foo;; Foo &fooRef = foo;; Foo *fooPtr = &foo;. A Block that referenced these variables would import the variables as; const variations:. .. code-block:: c. const Foo block_foo = foo;; Foo &block_fooRef = fooRef;; Foo *const block_fooPtr = fooPtr;. Captured variables are copied into the Block at the instant of; evaluating the Block literal expression. They are also copied when; calling ``Block_copy()`` on a Block allocated on the stack. In both; cases, they are copied as if the variable were const-qualified, and; it's an error if there's no such constructor. Captured variables in Blocks on the stack are destroyed when control; leaves the compound statement that contains the Block literal; expression. Captured variables in Blocks on the heap are destroyed; when the reference count of the Block drops to zero. Variables declared as residing in ``__block`` storage may be initially; allocated in the heap or may first appear on the stack and be copied; to the heap as a result of a ``Block_copy()`` operation. When copied; from the stack, ``__block`` variables are copied using their normal; qualification (i.e. without adding const). In C++11, ``__block``; variables are copied as x-values if that is possible, then as l-values; if not; if both fail, it's an error. The destructor for any ini",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:11684,variab,variables,11684,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['variab'],['variables']
Modifiability,"n to stderr; --------------------------------------------. The ``PrintFunctionPass`` class is designed to be pipelined with other; ``FunctionPasses``, and prints out the functions of the module as they are; processed. ``print-module``: Print module to stderr; ----------------------------------------. This pass simply prints out the entire module when it is executed. ``regions``: Detect single entry single exit regions; ----------------------------------------------------. The ``RegionInfo`` pass detects single entry single exit regions in a function,; where a region is defined as any subgraph that is connected to the remaining; graph at only two spots. Furthermore, a hierarchical region tree is built. .. _passes-scalar-evolution:. ``scalar-evolution``: Scalar Evolution Analysis; -----------------------------------------------. The ``ScalarEvolution`` analysis can be used to analyze and categorize scalar; expressions in loops. It specializes in recognizing general induction; variables, representing them with the abstract and opaque ``SCEV`` class.; Given this analysis, trip counts of loops and other important properties can be; obtained. This analysis is primarily useful for induction variable substitution and; strength reduction. ``scev-aa``: ScalarEvolution-based Alias Analysis; -------------------------------------------------. Simple alias analysis implemented in terms of ``ScalarEvolution`` queries. This differs from traditional loop dependence analysis in that it tests for; dependencies within a single iteration of a loop, rather than dependencies; between different iterations. ``ScalarEvolution`` has a more complete understanding of pointer arithmetic; than ``BasicAliasAnalysis``' collection of ad-hoc analyses. ``stack-safety``: Stack Safety Analysis; ---------------------------------------. The ``StackSafety`` analysis can be used to determine if stack allocated; variables can be considered safe from memory access bugs. This analysis' primary purpose is to be ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:10619,variab,variables,10619,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['variab'],['variables']
Modifiability,"n to the cross one just; # for the native `llvm-config`!; DISABLE_LLVM_LINK_LLVM_DYLIB; ). # Compute the substitution values for various items.; get_property(SUPPORT_SYSTEM_LIBS TARGET LLVMSupport PROPERTY LLVM_SYSTEM_LIBS); get_property(WINDOWSMANIFEST_SYSTEM_LIBS TARGET LLVMWindowsManifest PROPERTY LLVM_SYSTEM_LIBS). foreach(l ${SUPPORT_SYSTEM_LIBS} ${WINDOWSMANIFEST_SYSTEM_LIBS}); if(MSVC); if(IS_ABSOLUTE ${l}); set(SYSTEM_LIBS ${SYSTEM_LIBS} ""${l}""); else(); set(SYSTEM_LIBS ${SYSTEM_LIBS} ""${l}.lib""); endif(); else(); if (l MATCHES ""^-""); # If it's an option, pass it without changes.; set(SYSTEM_LIBS ${SYSTEM_LIBS} ""${l}""); else(); # Otherwise assume it's a library name we need to link with.; if(IS_ABSOLUTE ${l}); set(SYSTEM_LIBS ${SYSTEM_LIBS} ""${l}""); else(); set(SYSTEM_LIBS ${SYSTEM_LIBS} ""-l${l}""); endif(); endif(); endif(); endforeach(). string(REPLACE "";"" "" "" SYSTEM_LIBS ""${SYSTEM_LIBS}""). # Fetch target specific compile options, e.g. RTTI option; get_property(COMPILE_FLAGS TARGET llvm-config PROPERTY COMPILE_FLAGS). # NOTE: We don't want to start extracting any random C/CXX flags that the; # user may add that could affect the ABI. We only want to extract flags; # that have been added by the LLVM build system.; string(REGEX MATCH ""-stdlib=[^ ]+"" LLVM_CXX_STDLIB_FLAG ${CMAKE_CXX_FLAGS}); string(REGEX MATCH ""-std=[^ ]+"" LLVM_C_STD_FLAG ${CMAKE_C_FLAGS}). # Use configure_file to create BuildVariables.inc.; set(LLVM_SRC_ROOT ${LLVM_MAIN_SRC_DIR}); set(LLVM_OBJ_ROOT ${LLVM_BINARY_DIR}); set(LLVM_CPPFLAGS ""${LLVM_DEFINITIONS}""); set(LLVM_CFLAGS ""${LLVM_C_STD_FLAG} ${LLVM_DEFINITIONS}""); # The language standard potentially affects the ABI/API of LLVM, so we want; # to make sure it is reported by llvm-config.; set(LLVM_CXXFLAGS ""${CMAKE_CXX${CMAKE_CXX_STANDARD}_STANDARD_COMPILE_OPTION} ${LLVM_CXX_STDLIB_FLAG} ${COMPILE_FLAGS} ${LLVM_DEFINITIONS}""); set(LLVM_BUILD_SYSTEM cmake); set(LLVM_HAS_RTTI ${LLVM_CONFIG_HAS_RTTI}); set(LLVM_DYLIB_VERSION ""${LLVM_VERSION_MAJO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/CMakeLists.txt:1586,config,config,1586,interpreter/llvm-project/llvm/tools/llvm-config/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/CMakeLists.txt,2,['config'],['config']
Modifiability,"n to; `include/clang/Basic/Attr.td; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/Attr.td>`_.; This tablegen definition must derive from the ``Attr`` (tablegen, not; semantic) type, or one of its derivatives. Most attributes will derive from the; ``InheritableAttr`` type, which specifies that the attribute can be inherited by; later redeclarations of the ``Decl`` it is associated with.; ``InheritableParamAttr`` is similar to ``InheritableAttr``, except that the; attribute is written on a parameter instead of a declaration. If the attribute; applies to statements, it should inherit from ``StmtAttr``. If the attribute is; intended to apply to a type instead of a declaration, such an attribute should; derive from ``TypeAttr``, and will generally not be given an AST representation.; (Note that this document does not cover the creation of type attributes.) An; attribute that inherits from ``IgnoredAttr`` is parsed, but will generate an; ignored attribute diagnostic when used, which may be useful when an attribute is; supported by another vendor but not supported by clang. The definition will specify several key pieces of information, such as the; semantic name of the attribute, the spellings the attribute supports, the; arguments the attribute expects, and more. Most members of the ``Attr`` tablegen; type do not require definitions in the derived definition as the default; suffice. However, every attribute must specify at least a spelling list, a; subject list, and a documentation list. Spellings; ~~~~~~~~~; All attributes are required to specify a spelling list that denotes the ways in; which the attribute can be spelled. For instance, a single semantic attribute; may have a keyword spelling, as well as a C++11 spelling and a GNU spelling. An; empty spelling list is also permissible and may be useful for attributes which; are created implicitly. The following spellings are accepted:. ================== =========================================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:128429,inherit,inherits,128429,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['inherit'],['inherits']
Modifiability,"n units, with equivalent; semantics. A program is ill-formed if it refers to the ``NSAutoreleasePool`` class. .. admonition:: Rationale. Autorelease pools are clearly important for the compiler to reason about, but; it is far too much to expect the compiler to accurately reason about control; dependencies between two calls. It is also very easy to accidentally forget; to drain an autorelease pool when using the manual API, and this can; significantly inflate the process's high-water-mark. The introduction of a; new scope is unfortunate but basically required for sane interaction with the; rest of the language. Not draining the pool during an unwind is apparently; required by the Objective-C exceptions implementation. .. _arc.misc.externally_retained:. Externally-Retained Variables; -----------------------------. In some situations, variables with strong ownership are considered; externally-retained by the implementation. This means that the variable is; retained elsewhere, and therefore the implementation can elide retaining and; releasing its value. Such a variable is implicitly ``const`` for safety. In; contrast with ``__unsafe_unretained``, an externally-retained variable still; behaves as a strong variable outside of initialization and destruction. For; instance, when an externally-retained variable is captured in a block the value; of the variable is retained and released on block capture and destruction. It; also affects C++ features such as lambda capture, ``decltype``, and template; argument deduction. Implicitly, the implementation assumes that the :ref:`self parameter in a; non-init method <arc.misc.self>` and the :ref:`variable in a for-in loop; <arc.misc.enumeration>` are externally-retained. Externally-retained semantics can also be opted into with the; ``objc_externally_retained`` attribute. This attribute can apply to strong local; variables, functions, methods, or blocks:. .. code-block:: objc. @class WobbleAmount;. @interface Widget : NSObject; -(vo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:92143,variab,variable,92143,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variable']
Modifiability,"n values for the failure cases are documented in the standard Linux man; pages of the functions and in the `POSIX standard <https://pubs.opengroup.org/onlinepubs/9699919799/>`_. .. code-block:: c. int unsafe_errno_read(int sock, void *data, int data_size) {; if (send(sock, data, data_size, 0) != data_size) {; // 'send' can be successful even if not all data was sent; if (errno == 1) { // An undefined value may be read from 'errno'; return 0;; }; }; return 1;; }. The checker :ref:`unix-StdCLibraryFunctions` must be turned on to get the; warnings from this checker. The supported functions are the same as by; :ref:`unix-StdCLibraryFunctions`. The ``ModelPOSIX`` option of that; checker affects the set of checked functions. **Parameters**. The ``AllowErrnoReadOutsideConditionExpressions`` option allows read of the; errno value if the value is not used in a condition (in ``if`` statements,; loops, conditional expressions, ``switch`` statements). For example ``errno``; can be stored into a variable without getting a warning by the checker. .. code-block:: c. int unsafe_errno_read(int sock, void *data, int data_size) {; if (send(sock, data, data_size, 0) != data_size) {; int err = errno;; // warning if 'AllowErrnoReadOutsideConditionExpressions' is false; // no warning if 'AllowErrnoReadOutsideConditionExpressions' is true; }; return 1;; }. Default value of this option is ``true``. This allows save of the errno value; for possible later error handling. **Limitations**. - Only the very first usage of ``errno`` is checked after an affected function; call. Value of ``errno`` is not followed when it is stored into a variable; or returned from a function.; - Documentation of function ``lseek`` is not clear about what happens if the; function returns different value than the expected file position but not -1.; To avoid possible false-positives ``errno`` is allowed to be used in this; case. .. _unix-Malloc:. unix.Malloc (C); """"""""""""""""""""""""""""""; Check for memory leaks, double free, and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:27751,variab,variable,27751,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['variab'],['variable']
Modifiability,n vs reference binding; Unknown. 2019; CD4; Member references omitted from description of storage duration; Unknown. 2020; CD5; Inadequate description of odr-use of implicitly-invoked functions; Unknown. 2021; dup; Function template redeclaration via alias template; Unknown. 2022; CD4; Copy elision in constant expressions; Unknown. 2023; drafting; Composite reference result type of conditional operator; Not resolved. 2024; CD4; Dependent types and unexpanded parameter packs; Unknown. 2025; dup; Declaration matching via alias templates; Unknown. 2026; CD4; Zero-initialization and constexpr; Clang 11. 2027; CD4; Unclear requirements for multiple alignas specifiers; Unknown. 2028; drafting; Converting constructors in rvalue reference initialization; Not resolved. 2029; dup; Abstract class return type in decltype operand; Unknown. 2030; NAD; Access of injected-class-name with template arguments; Unknown. 2031; CD4; Missing incompatibility for &&; Unknown. 2032; CD4; Default template-arguments of variable templates; Unknown. 2033; CD4; Redundant restriction on partial specialization argument; Unknown. 2034; NAD; Deprecating uncaught_exception(); Unknown. 2035; CD3; Multi-section example is confusing; Unknown. 2036; NAD; Refactoring parameters-and-qualifiers; Unknown. 2037; drafting; Alias templates and template declaration matching; Not resolved. 2038; CD4; Document C++14 incompatibility of new braced deduction rule; Unknown. 2039; CD4; Constant conversions to bool; Unknown. 2040; CD4; trailing-return-type no longer ambiguous; Unknown. 2041; CD4; Namespace for explicit class template specialization; Unknown. 2042; drafting; Exceptions and deallocation functions; Not resolved. 2043; drafting; Generalized template arguments and array-to-pointer decay; Not resolved. 2044; CD4; decltype(auto) and void; Unknown. 2045; CD5; “Identical” template parameter lists; Unknown. 2046; C++17; Incomplete thread specifications; Unknown. 2047; CD4; Coordinating “throws anything” specificat,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:138170,variab,variable,138170,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['variab'],['variable']
Modifiability,"n with `MyMainFrame::DoDraw():`. ``` {.cpp}; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; ```. In the same way we can connect to the signal `Clicked()` of the Exit; button with the system call `gApplication->Terminate(0).` We declare a; new slot `DoExit(),` implement it to invoke the termination call and; associate this slot with the signal `Clicked()` of the Exit button. The code of `example.C` can be changed as follows:. ``` {.cpp}; public:; ...; void DoExit(); // a new slot is added; }; void MyMainFrame::DoExit() {; gApplication->Terminate(0);; }; MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h) {; ...; TGTextButton *exit = new TGTextButton(hframe,""&Exit "");; // connects signal Clicked() with slot DoExit(); exit->Connect(""Clicked()"",""MyMainFrame"",this,""DoExit()"");; ...; }; ```. Here is an abstract view of the signal/slots connections in `example.C`:. ![](pictures/0200020C.jpg). To benefit from this mechanism your classes must inherit from; **`TQObject`** or otherwise the class definition must start with; `RQ_OBJECT(""ClassName"") `macro. This macro allows the signals/slots; communication mechanism to be applied between compiled and interpreted; classes in an interactive ROOT session without having the class derive; from **`TQObject`**. Every signal method declaration is followed by a; comment `""*SIGNAL*"".` Only instances of a class that defines a signal or; instances of its subclasses can emit the signal. The ROOT implementation; of a popular example presenting signals and slots is the next. Let's; have a minimal class declaration:. ``` {.cpp}; class MyClass {; private:; Int_t fValue;; public:; MyClass() { fValue=0; }; Int_t GetValue() const { return fValue; }; void SetValue(Int_t);; };; ```. It will become the following as interpreted:. ``` {.cpp}; class MyClass {; RQ_OBJECT(""MyClass""); private:; Int_t fValue;; public:; MyClass() { fValue=0; }; Int_t GetValue() const { return fValue; }; void SetValue(Int_t); // *SIGNAL*; };; ```. Both cla",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:42971,inherit,inherit,42971,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['inherit'],['inherit']
Modifiability,"n writing text to a stream; N/A. 131; C89; const member qualification and assignment; Yes. 132; Dup; Can undefined behavior occur at translation time, or only at run time?; Duplicate of 109. 133; NAD; Undefined behavior not previously listed in subclause G2; Yes. 134; NAD; What is an 'error number' for strerror?; N/A. 135; NAD; Can the size argument to 'fwrite' be zero?; N/A. 136; NAD; 'mktime' and time gaps; N/A. 137; NAD; 'printf' and negative floating point values; N/A. 138; C89; Is there an allocated storage duration?; Yes. 139; C89; Compatibility of complete and incomplete types; Yes. 140; NAD; Behavior of 'setvbuf'; N/A. 141; NAD; What is the meaning of EOF?; N/A. 142; C89; Reservation of macro names; Yes. 143; C89; 'fopen' modes; N/A. 144; C89; Preprocessing of preprocessing directives; Yes. 145; C89; Constant expressions; Unknown. 146; C89; Nugatory constraint; Yes. 147; C89; Sequence points in library functions; Yes. 148; NAD; Defining library functions; Yes. 149; C89; The term ""variable""; Yes. 150; C89; Initialization of a char array from a string literal; Yes. 151; C89; Behavior of 'printf' and flags; N/A. 152; NAD; Can you 'longjmp' out of a signal handler?; N/A. 153; Dup; Can 'f()' be considered a call to a function-like macro with one empty argument?; Duplicate of 3. 154; NAD; Consistency of implementation-defined values; Yes. 155; C89; Zero-sized allocations; N/A. 156; C89; Closed streams; N/A. 157; C89; Legitimacy of type synonyms; Yes. 158; C89; Null pointer conversions; Yes. 159; C89; Consistency of the C Standard Defects exist in the way the Standard refers to itself; Yes. 160; Open; Reservation of identifiers; Not resolved. 161; NAD; Details of reserved symbols; Yes. 162; C89; 'gmtime' and 'localtime'; N/A. 163; C89; Undeclared identifiers; Yes. 164; NAD; Bad declarations; Yes. 165; C89; Tags and incomplete types; Not resolved. 166; Open; Meaning of lvalue; Not resolved. 167; Open; Consistency of the C Standard (Defect Report UK 015); Not resolve",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:10083,variab,variable,10083,interpreter/llvm-project/clang/www/c_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html,2,['variab'],['variable']
Modifiability,"n you're; done with it. ### Use of Python Functions. It is possible to mix Python functions with ROOT and perform such; operations as plotting and fitting of histograms with them. In all; cases, the procedure consists of instantiating a ROOT **`TF1`**,; **`TF2`**, or **`TF3`** with the Python function and working with that; ROOT object. There are some memory issues, so it is for example not yet; possible to delete a **`TF1`** instance and then create another one with; the same name. In addition, the Python function, once used for; instantiating the **`TF1`**, is never deleted. Instead of a Python function, you can also use callable instances (e.g.,; an instance of a class that has implemented the `__call__` member; function). The signature of the Python callable should provide for one; or two arrays. The first array, which must always be present, shall; contain the `x`, `y`, `z`, and t values for the call. The second array,; which is optional and its size depends on the number given to the; **`TF1`** constructor, contains the values that parameterize the; function. For more details, see the **`TF1`** documentation and the; examples below. #### Plotting Python Function. This is an example of a parameter less Python function that is plotted; on a default canvas:. ``` {.cpp}; from ROOT import TF1, TCanvas. def identity( x ):; return x[0]. # create an identity function; f = TF1('pyf1', identity, -1., 1.). # plot the function; c = TCanvas(); f.Draw(); ```. Because no number of parameters is given to the **`TF1`** constructor,; '`0`' (the default) is assumed. This way, the '`identity'` function need; not handle a second argument, which would normally be used to pass the; function parameters. Note that the argument '`x`' is an array of size 4.; The following is an example of a parameterized Python callable instance; that is plotted on a default canvas:. ``` {.cpp}; from ROOT import TF1, TCanvas. class Linear:; def __call__( self, x, par ):; return par[0] + x[0]*par[1]. # c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:25931,parameteriz,parameterize,25931,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['parameteriz'],['parameterize']
Modifiability,"n"", num); }; Bool_t IsEqual(TObject *obj) const; { return num == ((TObjNum*)obj)->num; }; Bool_t IsSortable() const { return kTRUE; }; Int_t Compare(const TObject *obj) const; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; ```. ## The TIter Generic Iterator. As stated above, the **`TIterator`** class is abstract; it is not; possible to create **`TIterator`** objects. However, it should be; possible to write generic code to process all members of a collection so; there is a need for a generic iterator object. A **`TIter`** object acts; as generic iterator. It provides the same `Next()` and `Reset()` methods; as **`TIterator`** although it has no idea how to support them! It works; as follows:. - To create a **`TIter`** object its constructor must be passed an; object that inherits from **`TCollection`**. The **`TIter`**; constructor calls the `MakeIterator()` method of this collection to; get the appropriate iterator object that inherits from; **`TIterator`**. - The `Next()` and `Reset()` methods of **`TIter`** simply call the; `Next()` and `Reset()` methods of the iterator object. Therefore, **`TIter`** simply acts as a wrapper for an object of a; concrete class inheriting from **`TIterator`**. To see this working in practice, consider the **`TObjArray`**; collection. Its associated iterator is **`TObjArrayIter`**. Suppose; `myarray` is a pointer to a **`TObjArray`** that contains `MyClass`; objects, i.e. ``` {.cpp}; TObjArray *myarray;; ```. To create a **`TIter`** object called `myiter`:. ``` {.cpp}; TIter myiter(myarray);; ```. ![](pictures/020001A4.jpg). As shown in the diagram, this results in several methods being called:. - The **`TIter`** constructor is passed a **`TObjArray`**. - **`TIter`** asks embedded **`TCollection`** to make an iterator. - **`TCollection`** asks **`TObjArray`** to make an iterator. - **`TObjArray`** returns a **`TObjArrayIter`**. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:11031,inherit,inherits,11031,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['inherit'],['inherits']
Modifiability,"n),; or ``+`` (right align). The default is right aligned. ``style`` is an optional string consisting of a type specific that controls the; formatting of the value. For example, to format a floating point value as a percentage,; you can use the style option ``P``. Custom formatting; ^^^^^^^^^^^^^^^^^. There are two ways to customize the formatting behavior for a type. 1. Provide a template specialization of ``llvm::format_provider<T>`` for your; type ``T`` with the appropriate static format method. .. code-block:: c++. namespace llvm {; template<>; struct format_provider<MyFooBar> {; static void format(const MyFooBar &V, raw_ostream &Stream, StringRef Style) {; // Do whatever is necessary to format `V` into `Stream`; }; };; void foo() {; MyFooBar X;; std::string S = formatv(""{0}"", X);; }; }. This is a useful extensibility mechanism for adding support for formatting your own; custom types with your own custom Style options. But it does not help when you want; to extend the mechanism for formatting a type that the library already knows how to; format. For that, we need something else. 2. Provide a **format adapter** inheriting from ``llvm::FormatAdapter<T>``. .. code-block:: c++. namespace anything {; struct format_int_custom : public llvm::FormatAdapter<int> {; explicit format_int_custom(int N) : llvm::FormatAdapter<int>(N) {}; void format(llvm::raw_ostream &Stream, StringRef Style) override {; // Do whatever is necessary to format ``this->Item`` into ``Stream``; }; };; }; namespace llvm {; void foo() {; std::string S = formatv(""{0}"", anything::format_int_custom(42));; }; }. If the type is detected to be derived from ``FormatAdapter<T>``, ``formatv``; will call the; ``format`` method on the argument passing in the specified style. This allows; one to provide custom formatting of any type, including one which already has; a builtin format provider. ``formatv`` Examples; ^^^^^^^^^^^^^^^^^^^^; Below is intended to provide an incomplete set of examples demonstrating; the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:14048,extend,extend,14048,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['extend'],['extend']
Modifiability,"n). NTrees No 800 − Number of trees in the forest. MaxDepth No 3 − Max depth of the decision tree allowed. MinNodeSize No 5% − Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%). nCuts No 20 − Number of grid points in variable range used in finding optimal cut in node splitting. BoostType No AdaBoost AdaBoost, RealAdaBoost, Bagging, AdaBoostR2, Grad Boosting type for the trees in the forest . AdaBoostR2Loss No Quadratic Linear, Quadratic, Exponential Type of Loss function in AdaBoostR2. UseBaggedGrad No False − Use only a random subsample of all events for growing the trees in each iteration. (Only valid for GradBoost). Shrinkage No 1 − Learning rate for GradBoost algorithm. AdaBoostBeta No 0.5 − Learning rate for AdaBoost algorithm. UseRandomisedTrees No False − Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests). UseNvars No 2 − Size of the subset of variables used with RandomisedTree option. UsePoissonNvars No True − Interpret UseNvars not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option. BaggedSampleFraction No 0.6 − Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedGrad, Bagging,). UseYesNoLeaf No True − Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost. NegWeightTreatment No InverseBoostNegWeights InverseBoostNegWeights, IgnoreNegWeightsInTraining, PairNegWeightsGlobal, Pray How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining; Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!). NodePurityLimit No 0.5 − In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise. SeparationType No GiniIndex CrossEntrop",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:12864,variab,variables,12864,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,2,['variab'],['variables']
Modifiability,"n, which selects the shard to run. The environment; variable ``LIT_NUM_SHARDS`` can also be used in place of this; option. These two options provide a coarse mechanism for partitioning large; testsuites, for parallel execution on separate machines (say in a large; testing farm). .. option:: --order={lexical,random,smart}. Define the order in which tests are run. The supported values are:. - lexical - tests will be run in lexical order according to the test file; path. This option is useful when predictable test order is desired. - random - tests will be run in random order. - smart - tests that failed previously will be run first, then the remaining; tests, all in descending execution time order. This is the default as it; optimizes concurrency. .. option:: --run-shard=N. Select which shard to run, assuming the ``--num-shards=M`` option was; provided. The two options must be used together, and the value of ``N``; must be in the range ``1..M``. The environment variable; ``LIT_RUN_SHARD`` can also be used in place of this option. .. option:: --timeout=N. Spend at most ``N`` seconds (approximately) running each individual test.; ``0`` means no time limit, and ``0`` is the default. Note that this is not an; alias for :option:`--max-time`; the two are different kinds of maximums. .. option:: --filter=REGEXP. Run only those tests whose name matches the regular expression specified in; ``REGEXP``. The environment variable ``LIT_FILTER`` can be also used in place; of this option, which is especially useful in environments where the call; to ``lit`` is issued indirectly. .. option:: --filter-out=REGEXP. Filter out those tests whose name matches the regular expression specified in; ``REGEXP``. The environment variable ``LIT_FILTER_OUT`` can be also used in; place of this option, which is especially useful in environments where the; call to ``lit`` is issued indirectly. .. option:: --xfail=LIST. Treat those tests whose name is in the semicolon separated list ``LIST`` as; ``XFA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:7758,variab,variable,7758,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['variab'],['variable']
Modifiability,"n-defined bit-field types; Yes. 316; NAD; Unprototyped function types; Yes. 317; NAD; Function definitions with empty parentheses; Yes. 318; C99; (double)0.1f with FLT_EVAL_METHOD being 2; Unknown. 319; NAD; printf(""%a"", 1.0) and trailing zeros; N/A. 320; C99; Scope of variably modified type; Yes. 321; C99; Wide character code values for members of the basic character set; Yes. 322; C99; Problem with TC2 Change #67 (Add perror to the list defining byte input/output functions); N/A. 323; C99; Potential problems with TC2 #34, #35, and #36; N/A. 324; C99; Tokenization obscurities; Yes. 325; NAD; strerror(); N/A. 326; C99; asctime(); N/A. 327; C99; Italicize definition of variable length array type, add forward references; Yes. 328; C99; String literals in compound literal initialization. Partial; Clang properly implements the use of string literals in a compound; literal initializer, but fails to diagnose use of a variably-modified; type at file scope. DR339 (about variably-modified types) is marked as; a duplicate of DR328.; . 329; C99; Math functions and directed rounding; N/A. 330; C99; Externally visible exceptional conditions; N/A. 331; NAD; permit FE_DIVBYZERO when errno says EDOM; N/A. 332; C99; gets is generally unsafe; N/A. 333; C99; Missing Predefined Macro Name; Yes. 334; Open; Missing semantics of comparison macros; Not resolved. 335; NAD; _Bool bit-fields; Yes. 336; C99; What does TMP_MAX actually indicate?; N/A. 337; C99; stdio.h macro definition problems; N/A. 338; C99; C99 seems to exclude indeterminate value from being an uninitialized register; Yes. 339; Dup; Variably modified compound literal; Duplicate of 328. 340; C99; Composite types for variable-length arrays; Yes. 341; C99; [*] in abstract declarators; Yes. 342; Dup; VLAs and conditional expressions; Duplicate of 340. 343; C99; Initializing qualified wchar_t arrays; Yes. 344; C99; Casts in preprocessor conditional expressions; Yes. 345; C99; Where does parameter scope start?; Yes. 400; C11; real",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:20219,variab,variably-modified,20219,interpreter/llvm-project/clang/www/c_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html,2,['variab'],['variably-modified']
Modifiability,"n-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5941,plugin,plugin,5941,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,3,['plugin'],['plugin']
Modifiability,"n. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify the full system path configuration on the command; line.; * Use clang as usual, but prefix all arguments to the cc1 process with; `-Xclang`. For example, to run the ``print-function-names`` plugin over a source file in; clang, first build the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:5679,config,configuring,5679,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,2,['config'],"['configuration', 'configuring']"
Modifiability,"n.ch/). - [PROOF on Demand](http://pod.gsi.de/). - The VAF client *(see below)*: a convenience tool that sets up the; environment for your experiment's software both on your client and; on the PROOF worker nodes. > If you are the end user, you'll probably might skip the part that; > concerns how to configure the VAF client: your system administrator; > has probably and conveniently set it up for you. The Virtual Analysis Facility client; ------------------------------------. The Virtual Analysis Facility client takes care of setting the; environment for the end user required by your software's experiment. The; environment will both be set on the client and on each PROOF node. Technically it is a Bash shell script which provides shortcuts for PROOF; on Demand commands and ensures local and remote environment consistency:; by executing it you enter a new clean environment where all your; software dependencies have already been set up. Local and remote environment configuration is split into a series of; files, which give the possibility to:. - have a system-wide, sysadmin-provided experiment configuration. - execute user actions either *before* or *after* the execution of the; system-wide script (for instance, choosing the preferred version of; the experiment's software). - transfer a custom user **payload** on each PROOF worker (for instance,; user's client-generated Grid credentials to make PROOF workers; capable of accessing a remote authenticated storage). Configuration files are searched for in two different locations:. - a system-wide directory: `<client_install_dir>/etc`. - user's home directory: `~/.vaf`. > A system-wide configuration file always has precedence over user's; > configuration. It is thus possible for the sysadmin to enforce a; > policy where some scripts cannot ever be overridden. Thanks to this separation, users can maintain an uncluttered directory; with very simple configuration files that contain only what really needs; or is allowed to be cus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:1212,config,configuration,1212,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['config'],['configuration']
Modifiability,"n7"",""Node 7"");; TGraphNode *n8 = gs->AddNode(""n8"",""Node 8"");; TGraphNode *n9 = gs->AddNode(""n9"",""Node 9"");. n4->SetTextSize(0.03);; n6->SetTextSize(0.03);; n2->SetTextSize(0.04);. n3->SetTextFont(132);. n0->SetTextColor(kRed);. n9->SetFillColor(kRed-10);; n0->SetFillColor(kYellow-9);; n7->SetFillColor(kViolet-9);. // some edges ...; gs->AddEdge(n0,n1)->SetLineColor(kRed);; TGraphEdge *e06 = gs->AddEdge(n0,n6);; e06->SetLineColor(kRed-3);; e06->SetLineWidth(4);; gs->AddEdge(n1,n7);; gs->AddEdge(n4,n6);; gs->AddEdge(n3,n9);; gs->AddEdge(n6,n8);; gs->AddEdge(n7,n2);; gs->AddEdge(n8,n3);; gs->AddEdge(n2,n3);; gs->AddEdge(n9,n0);; gs->AddEdge(n1,n4);; gs->AddEdge(n1,n6);; gs->AddEdge(n2,n5);; gs->AddEdge(n3,n6);; gs->AddEdge(n4,n5);. TCanvas *c = new TCanvas(""c"",""c"",800,600);; c->SetFillColor(38);; gs->Draw();; return c;; }; . This new funtionnality relies on the graphivz package.; This package can be downloaded from; http://www.graphviz.org/. At installation time, to find graphviz, the ROOT's configure file looks in; standard locations. It is possible to define a specific location using the; configure flags:. --with-gviz-incdir=""the directory where gvc.h is""; --with-gviz-libdir=""the directory where the libgvc library is"". To install graphviz (if needed) it is recommended to use the following configure flags:. --enable-static=yes --enable-shared=no --with-pic --prefix=""graphviz installed here"". On 64 bits machines, the ROOT sources are compiled with the option -m64. In; that case graphviz should be also compiled in 64 bits mode. It might be the; default option, but on some machine it is not. In that case the environment; variable CC should be defined as:. CC=""gcc -m64"". before doing configure. On Windows machines it recommended to not install graphviz but to download the; pre-installed version from http://www.graphviz.org/. The ROOT configure command; remains the same.; Graphics Primitives; New class TGraphTime; TGraphTime is used to draw a set of objects evolving with n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html:3482,config,configure,3482,graf2d/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html,2,['config'],['configure']
Modifiability,"n; # LLVM_ENABLE_PROJECTS just generates a cryptic error message.; if (NOT ""lld"" IN_LIST LLVM_ENABLE_PROJECTS); message(FATAL_ERROR ""LLD is enabled in the bootstrap build, but lld is not in LLVM_ENABLE_PROJECTS""); endif(); add_dependencies(clang-bootstrap-deps lld); endif(). if (WIN32); # Build llvm-rc and llvm-mt which are needed by the Windows build.; add_dependencies(clang-bootstrap-deps llvm-rc); if(LLVM_ENABLE_LIBXML2); add_dependencies(clang-bootstrap-deps llvm-mt); endif(); endif(). # If the next stage is LTO we need to depend on LTO and possibly lld or LLVMgold; if(BOOTSTRAP_LLVM_ENABLE_LTO OR LLVM_ENABLE_LTO AND NOT LLVM_BUILD_INSTRUMENTED); if(APPLE); add_dependencies(clang-bootstrap-deps LTO); # on Darwin we need to set DARWIN_LTO_LIBRARY so that -flto will work; # using the just-built compiler, and we need to override DYLD_LIBRARY_PATH; # so that the host object file tools will use the just-built libLTO.; # However if System Integrity Protection is enabled the DYLD variables; # will be scrubbed from the environment of any base system commands. This; # includes /bin/sh, which ninja uses when executing build commands. To; # work around the envar being filtered away we pass it in as a CMake; # variable, and have LLVM's CMake append the envar to the archiver calls.; set(LTO_LIBRARY -DDARWIN_LTO_LIBRARY=${LLVM_SHLIB_OUTPUT_INTDIR}/libLTO.dylib; -DDYLD_LIBRARY_PATH=${LLVM_LIBRARY_OUTPUT_INTDIR}); elseif(MSVC); add_dependencies(clang-bootstrap-deps llvm-lib); set(${CLANG_STAGE}_AR -DCMAKE_AR=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-lib); elseif(NOT WIN32); add_dependencies(clang-bootstrap-deps llvm-ar llvm-ranlib); if(NOT BOOTSTRAP_LLVM_ENABLE_LLD AND LLVM_BINUTILS_INCDIR); add_dependencies(clang-bootstrap-deps LLVMgold); endif(); set(${CLANG_STAGE}_AR -DCMAKE_AR=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-ar); set(${CLANG_STAGE}_RANLIB -DCMAKE_RANLIB=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-ranlib); endif(); endif(). if(CLANG_BOOTSTRAP_EXTRA_DEPS); add_dependencies(clang-bootstrap",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:21934,variab,variables,21934,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['variab'],['variables']
Modifiability,"n; %noreset. def X: C;; ```. ------------- Classes -----------------; class C {; }; ------------- Defs -----------------; def X {	// C; }. `def` creates an instance of a class. Typically, the main loop of a TableGen backend will look for all defs that are instances of a certain class. For example if I am generating register information I would look for all defs that are instances of `RegisterInfo` in the example below. ```tablegen; class RegisterInfo {}; def X0: RegisterInfo {}; def X1: RegisterInfo {}; ```. ------------- Classes -----------------; class RegisterInfo {; }; ------------- Defs -----------------; def X0 {	// RegisterInfo; }; def X1 {	// RegisterInfo; }. ## Inheritance. Like many other languages with classes, a class in TableGen can inherit properties of another class. ```tablegen; class C {}; class D : C {}; ```. ------------- Classes -----------------; class C {; }; class D {	// C; }; ------------- Defs -----------------. Inheritance is done by putting the class you want to inherit from after `:`, before the opening `{`. You'll know that `D` inherits from `C` by the `// C` comment on the `class D {` line in the output. Not very interesting though, what are we actually inheriting? The members of the parent class. ```tablegen; class C {; int a;; }; class D : C {}; ```. ------------- Classes -----------------; class C {; int a = ?;; }; class D {	// C; int a = ?;; }; ------------- Defs -----------------. Note that `D` now has the `a` member which was defined in the class `C`. You can inherit from multiple classes. In that case the order that that happens in matches the order you write the class names after the `:`. ```tablegen; class C {; int a = 1;; }; class D {; int a = 2;; }; class E : C, D {}; ```. ------------- Classes -----------------; class C {; int a = 1;; }; class D {; int a = 2;; }; class E {	// C D; int a = 2;; }; ------------- Defs -----------------. Class `E` first inherits from class `C`. This gives `E` a member `a` with value `1`. Then it i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md:3221,inherit,inherit,3221,interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,1,['inherit'],['inherit']
Modifiability,"n; entry D in the current compilation unit for an integral base type matching the; address size of AS. An object P having the given pointer or reference type are; dereferenced as if the ``DW_OP_push_object_address; DW_OP_deref_type DR;; DW_OP_constu AS; DW_OP_form_aspace_address`` operation expression was evaluated; with the current context except: the result kind is location description; the; initial stack is empty; and the object is the location description of P. .. note::. What if the current context does not have a current target architecture; defined?. .. note::. With the expanded support for DWARF address spaces, it may be worth examining; if they can be used for what was formerly supported by DWARF 5 segments. That; would include specifying the address space of all code addresses (compilation; units, subprograms, subprogram entries, labels, subprogram types, etc.).; Either the code address attributes could be extended to allow a exprloc form; (so that ``DW_OP_form_aspace_address`` can be used) or the; ``DW_AT_LLVM_address_space`` attribute be allowed on all DIEs that allow; ``DW_AT_segment``. A.5.7 Structure, Union, Class and Interface Type Entries; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. A.5.7.3 Derived or Extended Structures, Classes and Interfaces; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++. 1. For a ``DW_AT_data_member_location`` attribute there are two cases:. 1. If the attribute is an integer constant B, it provides the offset in; bytes from the beginning of the containing entity. The result of the attribute is obtained by evaluating a; ``DW_OP_LLVM_offset B`` operation with an initial stack comprising the; location description of the beginning of the containing entity. The; result of the evaluation is the location description of the base of the; member entry. *If the beginning of the containing entity is not byte aligned, then the; beginning of the member entry has the same bit displacement within a; byte.*. 2. Oth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:179232,extend,extended,179232,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['extend'],['extended']
Modifiability,"nCL driver that support SPIR-V consumption or it can be compiled; further by offline SPIR-V consumer tools. Converting to SPIR-V produced with the optimization levels other than `-O0` is; currently available as an experimental feature and it is not guaranteed to work; in all cases. Clang also supports integrated generation of SPIR-V without use of ``llvm-spirv``; tool as an experimental feature when ``-fintegrated-objemitter`` flag is passed in; the command line. .. code-block:: console. $ clang --target=spirv32 -fintegrated-objemitter -c test.cl. Note that only very basic functionality is supported at this point and therefore; it is not suitable for arbitrary use cases. This feature is only enabled when clang; build is configured with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=SPIRV`` option. Linking is done using ``spirv-link`` from `the SPIRV-Tools project; <https://github.com/KhronosGroup/SPIRV-Tools#linker>`_. Similar to other external; linkers, Clang will expect ``spirv-link`` to be installed separately and to be; present in the ``PATH`` environment variable. Please refer to `the build and; installation instructions; <https://github.com/KhronosGroup/SPIRV-Tools#build>`_. .. code-block:: console. $ clang --target=spirv64 test1.cl test2.cl. More information about the SPIR-V target settings and supported versions of SPIR-V; format can be found in `the SPIR-V target guide; <https://llvm.org/docs/SPIRVUsage.html>`__. .. _clang-cl:. clang-cl; ========. clang-cl is an alternative command-line interface to Clang, designed for; compatibility with the Visual C++ compiler, cl.exe. To enable clang-cl to find system headers, libraries, and the linker when run; from the command-line, it should be executed inside a Visual Studio Native Tools; Command Prompt or a regular Command Prompt where the environment has been set; up using e.g. `vcvarsall.bat <https://msdn.microsoft.com/en-us/library/f2ccy3wt.aspx>`_. clang-cl can also be used from inside Visual Studio by selecting the LLVM",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:167986,variab,variable,167986,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variable']
Modifiability,"nDecl where the n'th TemplateArgument matches the given InnerMatcher. Given; template<typename T, typename U> class A {};; A<bool, int> b;; A<int, bool> c;. template<typename T> void f() {}; void func() { f<int>(); };; classTemplateSpecializationDecl(hasTemplateArgument(; 1, refersToType(asString(""int"")))); matches the specialization A<bool, int>. functionDecl(hasTemplateArgument(0, refersToType(asString(""int"")))); matches the specialization f<int>. Matcher<FunctionDecl>returnsMatcher<QualType> InnerMatcher; Matches the return type of a function declaration. Given:; class X { int f() { return 1; } };; cxxMethodDecl(returns(asString(""int""))); matches int f() { return 1; }. Matcher<IfStmt>hasConditionMatcher<Expr> InnerMatcher; Matches the condition expression of an if statement, for loop,; switch statement or conditional operator. Example matches true (matcher = hasCondition(cxxBoolLiteral(equals(true)))); if (true) {}. Matcher<IfStmt>hasConditionVariableStatementMatcher<DeclStmt> InnerMatcher; Matches the condition variable statement in an if statement. Given; if (A* a = GetAPointer()) {}; hasConditionVariableStatement(...); matches 'A* a = GetAPointer()'. Matcher<IfStmt>hasElseMatcher<Stmt> InnerMatcher; Matches the else-statement of an if statement. Examples matches the if statement; (matcher = ifStmt(hasElse(cxxBoolLiteral(equals(true))))); if (false) false; else true;. Matcher<IfStmt>hasInitStatementMatcher<Stmt> InnerMatcher; Matches selection statements with initializer. Given:; void foo() {; if (int i = foobar(); i > 0) {}; switch (int i = foobar(); i) {}; for (auto& a = get_range(); auto& x : a) {}; }; void bar() {; if (foobar() > 0) {}; switch (foobar()) {}; for (auto& x : get_range()) {}; }; ifStmt(hasInitStatement(anything())); matches the if statement in foo but not in bar.; switchStmt(hasInitStatement(anything())); matches the switch statement in foo but not in bar.; cxxForRangeStmt(hasInitStatement(anything())); matches the range for statement in foo bu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:207269,variab,variable,207269,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['variab'],['variable']
Modifiability,"nHesse. when the inversion of the hessian matrix failed, return MnInvertFailed instead of MnHesseFailed. Mathcore Fitting classes. Fix the fitting with the integral option in multi-dimensions.; Force the gradient calculation when requested in the minimizer; classes and avoid to perform the check when using TMinuit. This was; already the case in Minuit2.; Add new class ROOT::Fit::SparseData for dealing with binned sparse data. This class automatically merges the empty region, so they can be considered, whenever possible as a larger single bin. This improves the performances when doing likelihood fits on the sparse data.; Fix the likelihood fits for variable bin histograms. Now a correct normalization is applied according to the bin volume.; Add new methods in Minimizer class :. Minimizer::SetPrecision(double eps) to change in the minimizer the precision on which the objective functions are evaluated. By default the numerical double precision is used inside the minimizers. This method should be used only if the precision in the function evaluation is worse than the double precision.; std::string Minimizer::VariableName (unsigned int index) to return a name of the minimizer variable (i.e. a fitting parameter) given the integer index. Return an empty string if the variable is not found or of the minimizer does not re-implement this method.; int Minimizer::VariableIndex(const std::string & name) to return the index of a variable given a name. Return -1 if the variable is not found or if the specific minimizer does not re-implement this function. ROOT::Fit::FitResult: fix a problem in the I/O, the function pointer is now made temporary and cannot be stored. Change also the Print() method to print now the results also when the fit is invalid (when it did not converge correctly). Unuran. Add a new version 1.5.0. The new version implements a new method PINV,; that is a quite fast numerical inversion method that only requires only the density function of the distribution.; . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v526/index.html:3734,variab,variable,3734,math/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v526/index.html,10,"['Variab', 'variab']","['VariableIndex', 'VariableName', 'variable']"
Modifiability,"nRequirement`` evaluates to a source range when the; action is invoked with some sort of selection. This requirement should be; satisfied when a refactoring is initiated in an editor, even when the user; has not selected anything (the range will contain the cursor's location in; that case). .. FIXME: Future selection requirements. .. FIXME: Maybe mention custom selection requirements?. Other Requirements; ^^^^^^^^^^^^^^^^^^. There are several other requirements types that can be used when creating; a refactoring rule:. - The ``RefactoringOptionsRequirement`` requirement is an abstract class that; should be subclassed by requirements working with options. The more; concrete ``OptionRequirement`` requirement is a simple implementation of the; aforementioned class that returns the value of the specified option when; it's evaluated. The next section talks more about refactoring options and; how they can be used when creating a rule. Refactoring Options; -------------------. Refactoring options are values that affect a refactoring operation and are; specified either using command-line options or another client-specific; mechanism. Options should be created using a class that derives either from; the ``OptionalRequiredOption`` or ``RequiredRefactoringOption``. The following; example shows how one can created a required string option that corresponds to; the ``-new-name`` command-line option in clang-refactor:. .. code-block:: c++. class NewNameOption : public RequiredRefactoringOption<std::string> {; public:; StringRef getName() const override { return ""new-name""; }; StringRef getDescription() const override {; return ""The new name to change the symbol to"";; }; };. The option that's shown in the example above can then be used to create; a requirement for a refactoring rule using a requirement like; ``OptionRequirement``:. .. code-block:: c++. createRefactoringActionRule<RenameOccurrences>(; ...,; OptionRequirement<NewNameOption>()); );. .. FIXME: Editor Bindings section; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:9850,refactor,refactoring,9850,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,3,['refactor'],"['refactor', 'refactoring']"
Modifiability,"nStyle: InheritParentConfig, ColumnLimit: 20}``. .. START_FORMAT_STYLE_OPTIONS. .. _AccessModifierOffset:. **AccessModifierOffset** (``Integer``) :versionbadge:`clang-format 3.3` :ref:`¶ <AccessModifierOffset>`; The extra indent or outdent of access modifiers, e.g. ``public:``. .. _AlignAfterOpenBracket:. **AlignAfterOpenBracket** (``BracketAlignmentStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlignAfterOpenBracket>`; If ``true``, horizontally aligns arguments after an open bracket. This applies to round brackets (parentheses), angle brackets and square; brackets. Possible values:. * ``BAS_Align`` (in configuration: ``Align``); Align parameters on the open bracket, e.g.:. .. code-block:: c++. someLongFunction(argument1,; argument2);. * ``BAS_DontAlign`` (in configuration: ``DontAlign``); Don't align, instead use ``ContinuationIndentWidth``, e.g.:. .. code-block:: c++. someLongFunction(argument1,; argument2);. * ``BAS_AlwaysBreak`` (in configuration: ``AlwaysBreak``); Always break after an open bracket, if the parameters don't fit; on a single line, e.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2);. * ``BAS_BlockIndent`` (in configuration: ``BlockIndent``); Always break after an open bracket, if the parameters don't fit; on a single line. Closing brackets will be placed on a new line.; E.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2; ). .. note::. This currently only applies to braced initializer lists (when; ``Cpp11BracedListStyle`` is ``true``) and parentheses. .. _AlignArrayOfStructures:. **AlignArrayOfStructures** (``ArrayInitializerAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <AlignArrayOfStructures>`; if not ``None``, when using initialization for an array of structs; aligns the fields into columns. .. note::. As of clang-format 15 this option only applied to arrays with equal; number of columns per row. Possible values:. * ``AIAS_Left`` (in configuration: ``Left``); Align array column and left justify t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:7668,config,configuration,7668,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,nVariance.h; TMVA/ResultsClassification.h; TMVA/Results.h; TMVA/ResultsMulticlass.h; TMVA/ResultsRegression.h; TMVA/ROCCalc.h; TMVA/ROCCurve.h; TMVA/RootFinder.h; TMVA/RuleCut.h; TMVA/RuleEnsemble.h; TMVA/RuleFitAPI.h; TMVA/RuleFit.h; TMVA/RuleFitParams.h; TMVA/Rule.h; TMVA/SdivSqrtSplusB.h; TMVA/SeparationBase.h; TMVA/SimulatedAnnealingFitter.h; TMVA/SimulatedAnnealing.h; TMVA/SVEvent.h; TMVA/SVKernelFunction.h; TMVA/SVKernelMatrix.h; TMVA/SVWorkingSet.h; TMVA/TActivationChooser.h; TMVA/TActivation.h; TMVA/TActivationIdentity.h; TMVA/TActivationRadial.h; TMVA/TActivationReLU.h; TMVA/TActivationSigmoid.h; TMVA/TActivationTanh.h; TMVA/Timer.h; TMVA/TNeuron.h; TMVA/TNeuronInputAbs.h; TMVA/TNeuronInputChooser.h; TMVA/TNeuronInput.h; TMVA/TNeuronInputSqSum.h; TMVA/TNeuronInputSum.h; TMVA/Tools.h; TMVA/TrainingHistory.h; TMVA/TransformationHandler.h; TMVA/TSpline1.h; TMVA/TSpline2.h; TMVA/TSynapse.h; TMVA/Types.h; TMVA/VariableDecorrTransform.h; TMVA/VariableGaussTransform.h; TMVA/VariableIdentityTransform.h; TMVA/VariableImportance.h; TMVA/VariableInfo.h; TMVA/VariableNormalizeTransform.h; TMVA/VariablePCATransform.h; TMVA/VariableRearrangeTransform.h; TMVA/VariableTransformBase.h; TMVA/VariableTransform.h; TMVA/VarTransformHandler.h; TMVA/Version.h; TMVA/Volume.h; # TMVA/DNN/Adadelta.h; # TMVA/DNN/Adagrad.h; # TMVA/DNN/Adam.h; # TMVA/DNN/BatchNormLayer.h; # TMVA/DNN/DataLoader.h; # TMVA/DNN/DeepNet.h; # TMVA/DNN/DenseLayer.h; # TMVA/DNN/DLMinimizers.h; # TMVA/DNN/Functions.h; # TMVA/DNN/GeneralLayer.h; # TMVA/DNN/ReshapeLayer.h; # TMVA/DNN/RMSProp.h; # TMVA/DNN/SGD.h; # TMVA/DNN/TensorDataLoader.h; # TMVA/DNN/CNN/ContextHandles.h; # TMVA/DNN/CNN/ConvLayer.h; # TMVA/DNN/CNN/MaxPoolLayer.h; # TMVA/DNN/RNN/RNNLayer.h; # TMVA/DNN/Architectures/Reference.h; # TMVA/DNN/Architectures/Reference/DataLoader.h; # TMVA/DNN/Architectures/Reference/TensorDataLoader.h; # TMVA/DNN/Architectures/Cpu.h; # TMVA/DNN/Architectures/Cpu/CpuBuffer.h; # TMVA/DNN/Architectures/Cpu/CpuMatrix.h; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/CMakeLists.txt:4088,Variab,VariableIdentityTransform,4088,tmva/tmva/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/CMakeLists.txt,1,['Variab'],['VariableIdentityTransform']
Modifiability,"n`. **Deleting** a non-debug instruction: nothing new to do. Simple DSE does not; require any change; it’s safe to delete an instruction with a `DIAssignID`; attachment. An `llvm.dbg.assign` that uses a `DIAssignID` that is not attached; to any instruction indicates that the memory location isn’t valid. **Merging** stores: In many cases no change is required as `DIAssignID`; attachments are automatically merged if `combineMetadata` is called. One way or; another, the `DIAssignID` attachments must be merged such that new store; becomes linked to all the `llvm.dbg.assign` intrinsics that the merged stores; were linked to. This can be achieved simply by calling a helper function; `Instruction::mergeDIAssignID`. **Inlining** stores: As stores are inlined we generate `llvm.dbg.assign`; intrinsics and `DIAssignID` attachments as if the stores represent source; assignments, just like the in frontend. This isn’t perfect, as stores may have; been moved, modified or deleted before inlining, but it does at least keep the; information about the variable correct within the non-inlined scope. **Splitting** stores: SROA and passes that split stores treat `llvm.dbg.assign`; intrinsics similarly to `llvm.dbg.declare` intrinsics. Clone the; `llvm.dbg.assign` intrinsics linked to the store, update the FragmentInfo in; the `ValueExpression`, and give the split stores (and cloned intrinsics) new; `DIAssignID` attachments each. In other words, treat the split stores as; separate assignments. For partial DSE (e.g. shortening a memset), we do the; same except that `llvm.dbg.assign` for the dead fragment gets an `Undef`; `Address`. **Promoting** allocas and store/loads: `llvm.dbg.assign` intrinsics implicitly; describe joined values in memory locations at CFG joins, but this is not; necessarily the case after promoting (or partially promoting) the; variable. Passes that promote variables are responsible for inserting; `llvm.dbg.assign` intrinsics after the resultant PHIs generated during; pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:7237,variab,variable,7237,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,1,['variab'],['variable']
Modifiability,"nal, notEligibleToImport: 0, live: 0, dsoLocal: 0), insts: 2[, FuncFlags]?[, Calls]?[, TypeIdInfo]?[, Params]?[, Refs]?. The ``module`` field includes the summary entry id for the module containing; this definition, and the ``flags`` field contains information such as; the linkage type, a flag indicating whether it is legal to import the; definition, whether it is globally live and whether the linker resolved it; to a local definition (the latter two are populated during the thin link).; The ``insts`` field contains the number of IR instructions in the function.; Finally, there are several optional fields: :ref:`FuncFlags<funcflags_summary>`,; :ref:`Calls<calls_summary>`, :ref:`TypeIdInfo<typeidinfo_summary>`,; :ref:`Params<params_summary>`, :ref:`Refs<refs_summary>`. .. _variable_summary:. Global Variable Summary; ^^^^^^^^^^^^^^^^^^^^^^^. If the global value is a variable, the ``Summary`` entry will look like:. .. code-block:: text. variable: (module: ^0, flags: (linkage: external, notEligibleToImport: 0, live: 0, dsoLocal: 0)[, Refs]?. The variable entry contains a subset of the fields in a; :ref:`function summary <function_summary>`, see the descriptions there. .. _alias_summary:. Alias Summary; ^^^^^^^^^^^^^. If the global value is an alias, the ``Summary`` entry will look like:. .. code-block:: text. alias: (module: ^0, flags: (linkage: external, notEligibleToImport: 0, live: 0, dsoLocal: 0), aliasee: ^2). The ``module`` and ``flags`` fields are as described for a; :ref:`function summary <function_summary>`. The ``aliasee`` field; contains a reference to the global value summary entry of the aliasee. .. _funcflags_summary:. Function Flags; ^^^^^^^^^^^^^^. The optional ``FuncFlags`` field looks like:. .. code-block:: text. funcFlags: (readNone: 0, readOnly: 0, noRecurse: 0, returnDoesNotAlias: 0, noInline: 0, alwaysInline: 0, noUnwind: 1, mayThrow: 0, hasUnknownCall: 0). If unspecified, flags are assumed to hold the conservative ``false`` value of; ``0``. .. _ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:342464,variab,variable,342464,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"nalysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:66431,variab,variables,66431,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['variab'],['variables']
Modifiability,"nalysis results are not transitive (IE A noalias B,; and B noalias C, does not mean A noalias C), so it is not possible to; come up with a precise partitioning in all cases without variables to; represent every pair of possible aliases. Thus, partitioning; precisely may require introducing at least N^2 new virtual variables,; phi nodes, etc. Each of these variables may be clobbered at multiple def sites. To give an example, if you were to split up struct fields into; individual variables, all aliasing operations that may-def multiple struct; fields, will may-def more than one of them. This is pretty common (calls,; copies, field stores, etc). Experience with SSA forms for memory in other compilers has shown that; it is simply not possible to do this precisely, and in fact, doing it; precisely is not worth it, because now all the optimizations have to; walk tons and tons of virtual variables and phi nodes. So we partition. At the point at which you partition, again,; experience has shown us there is no point in partitioning to more than; one variable. It simply generates more IR, and optimizations still; have to query something to disambiguate further anyway. As a result, LLVM partitions to one variable. Precision in practice; ^^^^^^^^^^^^^^^^^^^^^. In practice, there are implementation details in LLVM that also affect the; results' precision provided by ``MemorySSA``. For example, AliasAnalysis has various; caps, or restrictions on looking through phis which can affect what ``MemorySSA``; can infer. Changes made by different passes may make MemorySSA either ""overly; optimized"" (it can provide a more accurate result than if it were recomputed; from scratch), or ""under optimized"" (it could infer more if it were recomputed).; This can lead to challenges to reproduced results in isolation with a single pass; when the result relies on the state acquired by ``MemorySSA`` due to being updated by; multiple subsequent passes.; Passes that use and update ``MemorySSA`` should d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:18289,variab,variable,18289,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['variab'],['variable']
Modifiability,"name. One can set the URL `../mylib/` for a library name `MyLib` by; setting `Root.Html.MyLib:` `../mylib/` or by calling; `THtml::SetLibURL(""MyLib"", ""../mylib/"")`. Occurrences of class `MyClass`; of `MyLib` will now be referenced as `../mylib/MyClass.html`. ### Search Engine. **`THtml`** can invoke external search engines. The ROOT reference guide; sets `Root.Html.Search` to <http://www.google.com/search?q=%s+site%3A%u>.; Calling **`THtml::SetSearchStemURL()`** will set the same. If this URL stem is; set, `THtml` will create search fields in the index pages. It will; send the words entered in these search fields as %s in the URL; %u will; be replaced by the current document's path, allowing a site- and; directory-specific search. ### ViewCVS. Most code is managed in a version control system like CVS. ViewCVS is a; WWW reader interface to the versioning control system that allows e.g.; tracking a file's changes. **`THtml`** will reference these pages; automatically if the `.rootrc` variable `Root.Html.ViewCVS` is set to; the URL stem of the ViewCVS. installation. Alternatively, one can call; THtml::SetViewCVS(). ### Wiki Pages. In some contexts it might be desirable to let users comment on classes,; e.g. for suggestions of use or alternatives, details of behavior, and; cross references to other relevant classes. A successful example of this; is the PHP.net documentation with its user annotations. **`THtml`** can; include a link to a class's Wiki page by setting the Wiki base URL via; `Root.Html.WikiURL` or **`THtml`**`::SetWikiURL()`. ## Tutorial. You can run the tutorial `htmlex.C` to see how **`THtml`** converts a; script to HTML and how it creates the corresponding class reference:. ``` {.cpp}; root[] .x $(ROOTSYS)/tutorials/htmlex.C+; ```. Have a look at the HTML version of the macro in; `htmldoc/htmlex.C.html `(which should be the same as the one at; <http://root.cern.ch/root/html/examples/htmlex.C.html>). It demonstrates how to generate documentation for your c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:11190,variab,variable,11190,documentation/users-guide/HTMLDoc.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md,1,['variab'],['variable']
Modifiability,"name];; #pragma link [C|C++|off] [global|typedef][name];; #pragma link [C|C++|off] [nestedclass|nestedtypedef];. #pragma link [C++|C|off|MACRO] function [name]<(argtypes)>;; #pragma link; [C++|C|off|MACRO] function [classname]::[name]<(argtypes)>;; #pragma link off all methods;; #pragma link [C|C++|off] defined_in [filename];; #pragma link; [C|C++|off] defined_in [class|struct|namespace] [name];; #pragma link [C|C++|off] all_function [classname];; #pragma link [C|C++|off] all_datamember [classname];; ```. The `[classname]` and the `[name]` can also contain wildcards. For; example:. ``` {.cpp}; #pragma link C++ class MyClass*;; ```. This will request the dictionary for all the class whose name start with; `'MyClass'` and are already known to Cling (class templates need to have; already been instantiated to be considered). ``` {.cpp}; #pragma link [C|C++|off] all [class|function|global|typedef];; ```. This pragma statement turns on or off the dictionary generation for all; classes, structures, namespaces, global variables, global functions and; typedefs seen so far by Cling. Example:. ``` {.cpp}; // some C++ header definition; #ifdef __ROOTCLING__; // turns off dictionary generation for all; #pragma link off all class;; #pragma link off all function;; #pragma link off all global;; #pragma link off all typedef;; #endif; ```. The next pragma statement selectively turns on or off the dictionary; generation for the specified `classs`, `struct`, `union`, `enum` or; `namespace`:. ``` {.cpp}; #pragma link; [C|C++|off][class|class+protected|; struct|union|enum|namespace][name];; ```. The Dictionary of all public members of class and struct will be; generated. If the '`class+protected`' flag is used, the dictionary for; protected members will also be generated. However, dictionary for; protected constructor and destructor will not be generated. This '; `class+protected` ' flag will help you only for plain protected member; access, but not for virtual function resolution. If you",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:25408,variab,variables,25408,documentation/users-guide/AddingaClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md,1,['variab'],['variables']
Modifiability,"namespace brace) and makes ""FixNamespaceComments"" omit adding; end comments for those. .. code-block:: c++. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace a { namespace a {; int foo; int foo;; } } // namespace a. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace b { namespace b {; int foo; int foo;; int bar; int bar;; } // namespace b } // namespace b. .. _SkipMacroDefinitionBody:. **SkipMacroDefinitionBody** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <SkipMacroDefinitionBody>`; Do not format macro definition body. .. _SortIncludes:. **SortIncludes** (``SortIncludesOptions``) :versionbadge:`clang-format 3.8` :ref:`¶ <SortIncludes>`; Controls if and how clang-format will sort ``#includes``. Possible values:. * ``SI_Never`` (in configuration: ``Never``); Includes are never sorted. .. code-block:: c++. #include ""B/A.h""; #include ""A/B.h""; #include ""a/b.h""; #include ""A/b.h""; #include ""B/a.h"". * ``SI_CaseSensitive`` (in configuration: ``CaseSensitive``); Includes are sorted in an ASCIIbetical or case sensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""B/A.h""; #include ""B/a.h""; #include ""a/b.h"". * ``SI_CaseInsensitive`` (in configuration: ``CaseInsensitive``); Includes are sorted in an alphabetical or case insensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""a/b.h""; #include ""B/A.h""; #include ""B/a.h"". .. _SortJavaStaticImport:. **SortJavaStaticImport** (``SortJavaStaticImportOptions``) :versionbadge:`clang-format 12` :ref:`¶ <SortJavaStaticImport>`; When sorting Java imports, by default static imports are placed before; non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,; static imports are placed after non-static imports. Possible values:. * ``SJSIO_Before`` (in configuration: ``Before``); Static imports are placed before non-static imports. .. code-block:: java. import static org.example.function1;. import org.example.ClassA;. * ``SJSIO_After`` (in co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:109421,config,configuration,109421,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,namespace for local type; Clang 9. 1691; C++14; Argument-dependent lookup and opaque enumerations; Clang 9. 1692; C++14; Associated namespaces of doubly-nested classes; Clang 9. 1693; C++14; Superfluous semicolons in class definitions; Unknown. 1694; CD4; Restriction on reference to temporary as a constant expression; Unknown. 1695; NAD; Lifetime extension via init-capture; Unknown. 1696; CD4; Temporary lifetime and non-static data member initializers; Clang 7. 1697; CD4; Lifetime extension and copy elision; Unknown. 1698; DR; Files ending in \; Unknown. 1699; open; Does befriending a class befriend its friends?; Not resolved. 1700; NAD; Does the special rvalue-reference deduction apply to alias templates?; Unknown. 1701; drafting; Array vs sequence in object representation; Not resolved. 1702; drafting; Rephrasing the definition of “anonymous union”; Not resolved. 1703; NAD; Language linkage of names of functions with internal linkage; Unknown. 1704; CD5; Type checking in explicit instantiation of variable templates; Unknown. 1705; CD4; Unclear specification of “more specialized”; Unknown. 1706; drafting; alignas pack expansion syntax; Not resolved. 1707; C++14; template in elaborated-type-specifier without nested-name-specifier; Unknown. 1708; CD4; overly-strict requirements for names with C language linkage; Unknown. 1709; drafting; Stringizing raw string literals containing newline; Not resolved. 1710; C++17; Missing template keyword in class-or-decltype; No. 1711; CD6; Missing specification of variable template partial specializations; Unknown. 1712; CD4; constexpr variable template declarations; Unknown. 1713; dup; Linkage of variable template specializations; Unknown. 1714; NAD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning e,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:115374,variab,variable,115374,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['variab'],['variable']
Modifiability,namic_hsa/hsa.cpp; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.h; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.cpp; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.h; openmp/libomptarget/plugins/amdgpu/impl/hsa_api.h; openmp/libomptarget/plugins/amdgpu/impl/impl.cpp; openmp/libomptarget/plugins/amdgpu/impl/impl_runtime.h; openmp/libomptarget/plugins/amdgpu/impl/internal.h; openmp/libomptarget/plugins/amdgpu/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/libomptarget/plugins/remote/include/Utils.h; openmp/libomptarget/plugins/remote/server/OffloadingServer.cpp; openmp/libomptarget/plugins/remote/server/Server.cpp; openmp/libomptarget/plugins/remote/server/Server.h; openmp/libomptarget/plugins/remote/src/Client.cpp; openmp/libomptarget/plugins/remote/src/Client.h; openmp/libomptarget/plugins/ve/src/rtl.cpp; openmp/libomptarget/src/api.cpp; openmp/libomptarget/src/interface.cpp; openmp/libomptarget/src/interop.cpp; openmp/libomptarget/src/omptarget.cpp; openmp/libomptarget/src/private.h; openmp/libomptarget/src/rtl.cpp; openmp/libomptarget/tools/deviceinfo/llvm-omp-device-info.cpp; openmp/runtime/doc/doxygen/libomp_interface.h; openmp/runtime/src/extractExternal.cpp; openmp/runtime/src/kmp.h; openmp/runtime/src/kmp_affinity.h; openmp/runtime/src/kmp_alloc.cpp; openmp/runtime/src/kmp_atomic.cpp; openmp/runtime/src/kmp_atomic.h; openmp/runtime/src/kmp_barrier.h; openmp/runtime/src/kmp_cancel.cpp; ope,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:407858,plugin,plugins,407858,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,namic_hsa/hsa.h; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.cpp; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.h; openmp/libomptarget/plugins/amdgpu/impl/hsa_api.h; openmp/libomptarget/plugins/amdgpu/impl/impl.cpp; openmp/libomptarget/plugins/amdgpu/impl/impl_runtime.h; openmp/libomptarget/plugins/amdgpu/impl/internal.h; openmp/libomptarget/plugins/amdgpu/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/libomptarget/plugins/remote/include/Utils.h; openmp/libomptarget/plugins/remote/server/OffloadingServer.cpp; openmp/libomptarget/plugins/remote/server/Server.cpp; openmp/libomptarget/plugins/remote/server/Server.h; openmp/libomptarget/plugins/remote/src/Client.cpp; openmp/libomptarget/plugins/remote/src/Client.h; openmp/libomptarget/plugins/ve/src/rtl.cpp; openmp/libomptarget/src/api.cpp; openmp/libomptarget/src/interface.cpp; openmp/libomptarget/src/interop.cpp; openmp/libomptarget/src/omptarget.cpp; openmp/libomptarget/src/private.h; openmp/libomptarget/src/rtl.cpp; openmp/libomptarget/tools/deviceinfo/llvm-omp-device-info.cpp; openmp/runtime/doc/doxygen/libomp_interface.h; openmp/runtime/src/extractExternal.cpp; openmp/runtime/src/kmp.h; openmp/runtime/src/kmp_affinity.h; openmp/runtime/src/kmp_alloc.cpp; openmp/runtime/src/kmp_atomic.cpp; openmp/runtime/src/kmp_atomic.h; openmp/runtime/src/kmp_barrier.h; openmp/runtime/src/kmp_cancel.cpp; openmp/runtime/src/kmp_debug.cpp; openmp/runtime/src/kmp_d,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:407917,plugin,plugins,407917,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,"namically; matched to a Block copy operation, allows recovery of the referenced; allocated memory. The ``__block`` Storage Qualifier; =================================. In addition to the new Block type we also introduce a new storage; qualifier, :block-term:`__block`, for local variables. [testme: a; __block declaration within a block literal] The ``__block`` storage; qualifier is mutually exclusive to the existing local storage; qualifiers auto, register, and static. [testme] Variables qualified by; ``__block`` act as if they were in allocated storage and this storage; is automatically recovered after last use of said variable. An; implementation may choose an optimization where the storage is; initially automatic and only ""moved"" to allocated (heap) storage upon; a Block_copy of a referencing Block. Such variables may be mutated as; normal variables are. In the case where a ``__block`` variable is a Block one must assume; that the ``__block`` variable resides in allocated storage and as such; is assumed to reference a Block that is also in allocated storage; (that it is the result of a ``Block_copy`` operation). Despite this; there is no provision to do a ``Block_copy`` or a ``Block_release`` if; an implementation provides initial automatic storage for Blocks. This; is due to the inherent race condition of potentially several threads; trying to update the shared variable and the need for synchronization; around disposing of older values and copying new ones. Such; synchronization is beyond the scope of this language specification. Control Flow; ============. The compound statement of a Block is treated much like a function body; with respect to control flow in that goto, break, and continue do not; escape the Block. Exceptions are treated *normally* in that when; thrown they pop stack frames until a catch clause is found. Objective-C Extensions; ======================. Objective-C extends the definition of a Block reference type to be; that also of id. A variable ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:7655,variab,variable,7655,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,2,['variab'],['variable']
Modifiability,"nce. Scudo is currently the default allocator in; `Fuchsia <https://fuchsia.dev/>`_, and in `Android <https://www.android.com/>`_; since Android 11. The name ""Scudo"" comes from the Italian word for; `shield <https://www.collinsdictionary.com/dictionary/italian-english/scudo>`_; (and Escudo in Spanish). Design; ======. Allocator; ---------; Scudo was designed with security in mind, but aims at striking a good balance; between security and performance. It was designed to be highly tunable and; configurable, and while we provide some default configurations, we encourage; consumers to come up with the parameters that will work best for their use; cases. The allocator combines several components that serve distinct purposes:. - the Primary allocator: fast and efficient, it services smaller allocation; sizes by carving reserved memory regions into blocks of identical size. There; are currently two Primary allocators implemented, specific to 32 and 64 bit; architectures. It is configurable via compile time options. - the Secondary allocator: slower, it services larger allocation sizes via the; memory mapping primitives of the underlying operating system. Secondary backed; allocations are surrounded by Guard Pages. It is also configurable via compile; time options. - the thread specific data Registry: defines how local caches operate for each; thread. There are currently two models implemented: the exclusive model where; each thread holds its own caches (using the ELF TLS); or the shared model; where threads share a fixed size pool of caches. - the Quarantine: offers a way to delay the deallocation operations, preventing; blocks to be immediately available for reuse. Blocks held will be recycled; once certain size criteria are reached. This is essentially a delayed freelist; which can help mitigate some use-after-free situations. This feature is fairly; costly in terms of performance and memory footprint, is mostly controlled by; runtime options and is disabled by default. A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:1467,config,configurable,1467,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['config'],['configurable']
Modifiability,"nceColon>`; If ``false``, spaces will be removed before inheritance colon. .. code-block:: c++. true: false:; class Foo : Bar {} vs. class Foo: Bar {}. .. _SpaceBeforeJsonColon:. **SpaceBeforeJsonColon** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <SpaceBeforeJsonColon>`; If ``true``, a space will be added before a JSON colon. For other; languages, e.g. JavaScript, use ``SpacesInContainerLiterals`` instead. .. code-block:: c++. true: false:; { {; ""key"" : ""value"" vs. ""key"": ""value""; } }. .. _SpaceBeforeParens:. **SpaceBeforeParens** (``SpaceBeforeParensStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <SpaceBeforeParens>`; Defines in which cases to put a space before opening parentheses. Possible values:. * ``SBPO_Never`` (in configuration: ``Never``); This is **deprecated** and replaced by ``Custom`` below, with all; ``SpaceBeforeParensOptions`` but ``AfterPlacementOperator`` set to; ``false``. * ``SBPO_ControlStatements`` (in configuration: ``ControlStatements``); Put a space before opening parentheses only after control statement; keywords (``for/if/while...``). .. code-block:: c++. void f() {; if (true) {; f();; }; }. * ``SBPO_ControlStatementsExceptControlMacros`` (in configuration: ``ControlStatementsExceptControlMacros``); Same as ``SBPO_ControlStatements`` except this option doesn't apply to; ForEach and If macros. This is useful in projects where ForEach/If; macros are treated as function calls instead of control statements.; ``SBPO_ControlStatementsExceptForEachMacros`` remains an alias for; backward compatibility. .. code-block:: c++. void f() {; Q_FOREACH(...) {; f();; }; }. * ``SBPO_NonEmptyParentheses`` (in configuration: ``NonEmptyParentheses``); Put a space before opening parentheses only if the parentheses are not; empty i.e. '()'. .. code-block:: c++. void() {; if (true) {; f();; g (x, y, z);; }; }. * ``SBPO_Always`` (in configuration: ``Always``); Always put a space before opening parentheses, except when it's; prohibited by the syntax rul",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:116757,config,configuration,116757,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ncept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compilation and linkage the application needs the path to the clang and llvm libraries and the invocation is order dependent since the linker cannot do backward searches. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclangEdit -lclangLex -lclangDriver -lclangCodeGen ; -lclangBasic -lclangAST ; `llvm-config ; --libs bitwriter mcjit orcjit native option ; ipo profiledata instrumentation objcarcopts` ; -lz -pthread -ldl -ltinfo ; -o embedcling; . Embedding cling requires the creation of the interpreter. Optionally compiler arguments and the resource directory of llvm can be passed. An example is the following:. #include ""cling/Interpreter/Interpreter.h"". int main(int argc, char** argv) {; const char* LLVMRESDIR = ""/usr/local/""; //path to llvm resource directory; cling::Interpreter interp(argc, argv, LLVMRESDIR);. interp.declare(""int p=0;"");; }; ; A more complete example could be found in tools/demo/cling-demo.cpp; Download . We are developing Cling according to the principle of Release early and release often. Binaries are available for download.; . Support ; Support is provided through a fast-response forum, where questions of all levels are welcomed. Queries can also be sent to our mailing list: cling-dev@cern.ch. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:2413,config,config,2413,interpreter/cling/www/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html,2,['config'],['config']
Modifiability,"ncrement it; store i32 %tmp2, i32* %X ; store it back; ... This code shows an example of how you can declare and manipulate a stack; variable in the LLVM IR. Stack memory allocated with the alloca; instruction is fully general: you can pass the address of the stack slot; to functions, you can store it in other variables, etc. In our example; above, we could rewrite the example to use the alloca technique to avoid; using a PHI node:. .. code-block:: llvm. @G = weak global i32 0 ; type of @G is i32*; @H = weak global i32 0 ; type of @H is i32*. define i32 @test(i1 %Condition) {; entry:; %X = alloca i32 ; type of %X is i32*.; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; store i32 %X.0, i32* %X ; Update X; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; store i32 %X.1, i32* %X ; Update X; br label %cond_next. cond_next:; %X.2 = load i32, i32* %X ; Read X; ret i32 %X.2; }. With this, we have discovered a way to handle arbitrary mutable; variables without the need to create Phi nodes at all:. #. Each mutable variable becomes a stack allocation.; #. Each read of the variable becomes a load from the stack.; #. Each update of the variable becomes a store to the stack.; #. Taking the address of a variable just uses the stack address; directly. While this solution has solved our immediate problem, it introduced; another one: we have now apparently introduced a lot of stack traffic; for very simple and common operations, a major performance problem.; Fortunately for us, the LLVM optimizer has a highly-tuned optimization; pass named ""mem2reg"" that handles this case, promoting allocas like this; into SSA registers, inserting Phi nodes as appropriate. If you run this; example through the pass, for example, you'll get:. .. code-block:: bash. $ llvm-as < example.ll | opt -passes=mem2reg | llvm-dis; @G = weak global i32 0; @H = weak global i32 0. define i32 @test(i1 %Condition) {; entry:; br i1 %Condition, label %cond_true, l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:6144,variab,variables,6144,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability,"nction object, or; a ``std::function``), it should be the last argument if at all possible. If there are multiple multi-line lambdas in a statement, or additional; parameters after the lambda, indent the block two spaces from the indent of the; ``[]``:. .. code-block:: c++. dyn_switch(V->stripPointerCasts(),; [] (PHINode *PN) {; // process phis...; },; [] (SelectInst *SI) {; // process selects...; },; [] (LoadInst *LI) {; // process loads...; },; [] (AllocaInst *AI) {; // process allocas...; });. Braced Initializer Lists; """""""""""""""""""""""""""""""""""""""""""""""". Starting from C++11, there are significantly more uses of braced lists to; perform initialization. For example, they can be used to construct aggregate; temporaries in expressions. They now have a natural way of ending up nested; within each other and within function calls in order to build up aggregates; (such as option structs) from local variables. The historically common formatting of braced initialization of aggregate; variables does not mix cleanly with deep nesting, general expression contexts,; function arguments, and lambdas. We suggest new code use a simple rule for; formatting braced initialization lists: act as-if the braces were parentheses; in a function call. The formatting rules exactly match those already well; understood for formatting nested function calls. Examples:. .. code-block:: c++. foo({a, b, c}, {1, 2, 3});. llvm::Constant *Mask[] = {; llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 0),; llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 1),; llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 2)};. This formatting scheme also makes it particularly easy to get predictable,; consistent, and automatic formatting with tools like `Clang Format`_. .. _Clang Format: https://clang.llvm.org/docs/ClangFormat.html. Language and Compiler Issues; ----------------------------. Treat Compiler Warnings Like Errors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Compiler warnings",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:20549,variab,variables,20549,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['variab'],['variables']
Modifiability,"nction. Required passes will still be run on ``optnone`` functions. For more implementation details, see; ``PassInstrumentation::runBeforePass()``. Registering passes as plugins; -----------------------------. LLVM provides a mechanism to register pass plugins within various tools like; ``clang`` or ``opt``. A pass plugin can add passes to default optimization; pipelines or to be manually run via tools like ``opt``. For more information,; see :doc:`NewPassManager`. Create a CMake project at the root of the repo alongside; other projects. This project must contain the following minimal; ``CMakeLists.txt``:. .. code-block:: cmake. add_llvm_pass_plugin(MyPassName source.cpp). See the definition of ``add_llvm_pass_plugin`` for more CMake details. The pass must provide at least one of two entry points for the new pass manager,; one for static registration and one for dynamically loaded plugins:. - ``llvm::PassPluginLibraryInfo get##Name##PluginInfo();``; - ``extern ""C"" ::llvm::PassPluginLibraryInfo llvmGetPassPluginInfo() LLVM_ATTRIBUTE_WEAK;``. Pass plugins are compiled and linked dynamically by default. Setting; ``LLVM_${NAME}_LINK_INTO_TOOLS`` to ``ON`` turns the project into a statically; linked extension. For an in-tree example, see ``llvm/examples/Bye/``. To make ``PassBuilder`` aware of statically linked pass plugins:. .. code-block:: c++. // Declare plugin extension function declarations.; #define HANDLE_EXTENSION(Ext) llvm::PassPluginLibraryInfo get##Ext##PluginInfo();; #include ""llvm/Support/Extension.def"". ... // Register plugin extensions in PassBuilder.; #define HANDLE_EXTENSION(Ext) get##Ext##PluginInfo().RegisterPassBuilderCallbacks(PB);; #include ""llvm/Support/Extension.def"". To make ``PassBuilder`` aware of dynamically linked pass plugins:. .. code-block:: c++. // Load plugin dynamically.; auto Plugin = PassPlugin::Load(PathToPlugin);; if (!Plugin); report_error();; // Register plugin extensions in PassBuilder.; Plugin.registerPassBuilderCallbacks(PB);; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst:8217,plugin,plugins,8217,interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,7,['plugin'],"['plugin', 'plugins']"
Modifiability,"nctionDecl(hasBody(compoundStmt())); matches 'void f() {}'; with compoundStmt(); matching '{}'; but does not match 'void f();'. Matcher<ForStmt>hasConditionMatcher<Expr> InnerMatcher; Matches the condition expression of an if statement, for loop,; switch statement or conditional operator. Example matches true (matcher = hasCondition(cxxBoolLiteral(equals(true)))); if (true) {}. Matcher<ForStmt>hasIncrementMatcher<Stmt> InnerMatcher; Matches the increment statement of a for loop. Example:; forStmt(hasIncrement(unaryOperator(hasOperatorName(""++"")))); matches '++x' in; for (x; x < N; ++x) { }. Matcher<ForStmt>hasLoopInitMatcher<Stmt> InnerMatcher; Matches the initialization statement of a for loop. Example:; forStmt(hasLoopInit(declStmt())); matches 'int x = 0' in; for (int x = 0; x < N; ++x) { }. Matcher<FriendDecl>hasTypeMatcher<Decl> InnerMatcher; Overloaded to match the declaration of the expression's or value; declaration's type. In case of a value declaration (for example a variable declaration),; this resolves one layer of indirection. For example, in the value; declaration ""X x;"", cxxRecordDecl(hasName(""X"")) matches the declaration of; X, while varDecl(hasType(cxxRecordDecl(hasName(""X"")))) matches the; declaration of x. Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(""X""))))); and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(""X""))))); and friend class X (matcher = friendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; cxxRecordDecl(hasName(""X"")))); class X {};; void y(X &x) { x; X z; }; class Y { friend class X; };; class Z : public virtual X {};. Example matches class Derived; (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName(""Base"")))))); class Base {};; class Derived : Base {};. Usable as: Matcher<Expr>, Matcher<FriendDecl>, Matcher<ValueDecl>,; Matcher<CXXBaseSpecifier>. Matcher<FriendDecl>hasTypeMatcher<QualType> InnerMatcher; Matches if the expression's or declaration's type matches a typ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:199943,variab,variable,199943,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['variab'],['variable']
Modifiability,"nctionalities in every classifier; the PDF is used (i.e., also for the MVA PDFs). The reading of these variables; was removed from MethodBase and MethodLikelihood. This also allows improved ; (full) PDF configuration of MVA output via the ""CreateMvaPdf"" option.; (Work by Or Cohen, CERN & Weizmann); ; New generalisation methods:. ; MethodCompositeBase: combines more than one; classifier within one. MethodBoost: boosts/bags any classifier; type. A special booking procedure for it was added to; Factory class. MethodDT: a classifier composed of a single; decision tree, boosted using MethodBoost. Results are; compatible with BDT, but BDT remains the default for boosted; decision trees, because it has pruning (among other; additional features). . Other improvements . Improved handling of small Likelihood values such that; Likelihood performance increases in analyses with many variables; (~>10). Thanks to Ralph Schaefer (Bonn U.) for reporting this. Nicer plotting: custom variable titles and units can be; assigned in ""AddVariable"" call. Introduced the inverse transformation InverseTransform for; the variable transformations into the framework. While this is; not necessary for classification, it is necessary for; regression. The inverse transformation of the normalization; transformation has been implemented. Started to extend the variable transformations to the; regression targets as well. MethodCuts now produces the 'optimal-cut' histograms needed; by macro mvaeffs.C. (macro 5a of TMVAGui.C); ; MsgLogger can be silenced in order to prevent excess output; during boosting. Third dataset type added centrally (Training, Validation; and Testing). The validation data is split off the original; training data set. Update of GUI and other Macros according to the new; features of PDF and the addition of MethodBoost.; ; Updates in TMVA 4.0.1. ""Spectator"" variables can be defined now which are computed; just as the input variables and which are written out into the; TestTree, but whic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v524/index.html:5251,variab,variable,5251,tmva/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v524/index.html,2,['variab'],['variable']
Modifiability,"nctionality that we want to build. A lexer; is also the first part of building a parser for a language, and we; use a simple C++ lexer which is easy to understand.; - `Chapter #2: Implementing a Parser and AST <LangImpl02.html>`_ -; With the lexer in place, we can talk about parsing techniques and; basic AST construction. This tutorial describes recursive descent; parsing and operator precedence parsing.; - `Chapter #3: Code generation to LLVM IR <LangImpl03.html>`_ - with; the AST ready, we show how easy it is to generate LLVM IR, and show; a simple way to incorporate LLVM into your project.; - `Chapter #4: Adding JIT and Optimizer Support <LangImpl04.html>`_ -; One great thing about LLVM is its support for JIT compilation, so; we'll dive right into it and show you the 3 lines it takes to add JIT; support. Later chapters show how to generate .o files.; - `Chapter #5: Extending the Language: Control Flow <LangImpl05.html>`_ - With; the basic language up and running, we show how to extend; it with control flow operations ('if' statement and a 'for' loop). This; gives us a chance to talk about SSA construction and control; flow.; - `Chapter #6: Extending the Language: User-defined Operators; <LangImpl06.html>`_ - This chapter extends the language to let; users define arbitrary unary and binary operators - with assignable; precedence! This allows us to build a significant piece of the; ""language"" as library routines.; - `Chapter #7: Extending the Language: Mutable Variables; <LangImpl07.html>`_ - This chapter talks about adding user-defined local; variables along with an assignment operator. This shows how easy it is; to construct SSA form in LLVM: LLVM does *not* require your front-end; to construct SSA form in order to use it!; - `Chapter #8: Compiling to Object Files <LangImpl08.html>`_ - This; chapter explains how to take LLVM IR and compile it down to object; files, like a static compiler does.; - `Chapter #9: Debug Information <LangImpl09.html>`_ - A real languag",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst:2724,extend,extend,2724,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,1,['extend'],['extend']
Modifiability,"nctions, either by providing them; explicitly or by using a C++ standard library that does. libstdc++; added these functions in version 5.0, and libc++ added them in; version 3.7. C++11 implementation status; Clang 3.3 and later implement all of the ISO; C++ 2011 standard.; You can use Clang in C++11 mode with the -std=c++11; option. Clang's C++11 mode can be used with; libc++ or with gcc's libstdc++. List of features and minimum Clang version with support. Language Feature; C++11 Proposal; Available in Clang?. Rvalue references; N2118; Clang 2.9; ; P1825R0 (DR); Clang 13.     Rvalue references for *this; N2439; Clang 2.9. Initialization of class objects by rvalues; N1610; Clang 2.9. Non-static data member initializers; N2756; Clang 3.0. Variadic templates; N2242; Clang 2.9.     Extending variadic template template parameters; N2555; Clang 2.9. Initializer lists; N2672; Clang 3.1. ; P1009R2 (DR); Clang 9. ; P1957R2 (DR); Clang 11. Static assertions; N1720; Clang 2.9. auto-typed variables; N1984; Clang 2.9.     Multi-declarator auto; N1737; Clang 2.9.     Removal of auto as a storage-class specifier; N2546; Clang 2.9.     New function declarator syntax; N2541; Clang 2.9. Lambda expressions; N2927; Clang 3.1. P0588R1 (DR); No. Declared type of an expression; N2343; Clang 2.9.     Incomplete return types; N3276; Clang 3.1. Right angle brackets; N1757; Clang 2.9. Default template arguments for function templates; DR226; Clang 2.9. Solving the SFINAE problem for expressions; DR339; Clang 2.9. Alias templates; N2258; Clang 3.0. Extern templates; N1987; Clang 2.9. Null pointer constant; N2431; Clang 3.0. Strongly-typed enums; N2347; Clang 2.9. Forward declarations for enums; N2764; DR1206; Clang 3.1. Standardized attribute syntax; N2761; Clang 3.3 (1). Generalized constant expressions; N2235; Clang 3.1. P0859R0 (DR); Clang 8. Alignment support; N2341; Clang 3.3. Conditionally-support behavior; N1627; Clang 2.9. Changing undefined behavior into diagnosable errors; N1727; Cl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:15403,variab,variables,15403,interpreter/llvm-project/clang/www/cxx_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html,2,['variab'],['variables']
Modifiability,"nctions, you can store it in other variables, etc. In our example; above, we could rewrite the example to use the alloca technique to avoid; using a PHI node:. .. code-block:: llvm. @G = weak global i32 0 ; type of @G is i32*; @H = weak global i32 0 ; type of @H is i32*. define i32 @test(i1 %Condition) {; entry:; %X = alloca i32 ; type of %X is i32*.; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; store i32 %X.0, i32* %X ; Update X; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; store i32 %X.1, i32* %X ; Update X; br label %cond_next. cond_next:; %X.2 = load i32, i32* %X ; Read X; ret i32 %X.2; }. With this, we have discovered a way to handle arbitrary mutable; variables without the need to create Phi nodes at all:. #. Each mutable variable becomes a stack allocation.; #. Each read of the variable becomes a load from the stack.; #. Each update of the variable becomes a store to the stack.; #. Taking the address of a variable just uses the stack address; directly. While this solution has solved our immediate problem, it introduced; another one: we have now apparently introduced a lot of stack traffic; for very simple and common operations, a major performance problem.; Fortunately for us, the LLVM optimizer has a highly-tuned optimization; pass named ""mem2reg"" that handles this case, promoting allocas like this; into SSA registers, inserting Phi nodes as appropriate. If you run this; example through the pass, for example, you'll get:. .. code-block:: bash. $ llvm-as < example.ll | opt -passes=mem2reg | llvm-dis; @G = weak global i32 0; @H = weak global i32 0. define i32 @test(i1 %Condition) {; entry:; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; br label %cond_next. cond_next:; %X.01 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]; ret i32 %X.01; }. The mem2reg pass implements the standard ""iterat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:6404,variab,variable,6404,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"ncy [BradburyConcern]_ [AminiInconsistent]_.; * Inconsistency means it will be hard to know at a guess what name a variable; will have [DasInconsistent]_ [CarruthInconsistent]_.; * Some large-scale renaming may happen anyway, leading to its disadvantages; without any mitigations. Big bang; --------. With this approach, variables will be renamed by an automated script in a series; of large commits. The principle advantage of this approach is that it minimises the cost of; inconsistency [BradburyTransition]_ [RobinsonTransition]_. It goes against a policy of avoiding large-scale reformatting of existing code; [GreeneDistinguish]_. It has been suggested that LLD would be a good starter project for the renaming; [Ueyama]_. Keeping git blame usable; ************************. ``git blame`` (or ``git annotate``) permits quickly identifying the commit that; changed a given line in a file. After renaming variables, many lines will show; as being changed by that one commit, requiring a further invocation of ``git; blame`` to identify prior, more interesting commits [GreeneGitBlame]_; [RicciAcronyms]_. **Mitigation**: `git-hyper-blame; <https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/git-hyper-blame.html>`_; can ignore or ""look through"" a given set of commits.; A ``.git-blame-ignore-revs`` file identifying the variable renaming commits; could be added to the LLVM git repository root directory.; It is being `investigated; <https://public-inbox.org/git/20190324235020.49706-1-michael@platin.gs/>`_; whether similar functionality could be added to ``git blame`` itself. Minimising cost of downstream merges; ************************************. There are many forks of LLVM with downstream changes. Merging a large-scale; renaming change could be difficult for the fork maintainers. **Mitigation**: A large-scale renaming would be automated. A fork maintainer can; merge from the commit immediately before the renaming, then apply the renaming; script ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:9149,variab,variables,9149,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['variab'],['variables']
Modifiability,"nd C::f, but not B, C, or B::f. Matcher<CXXMethodDecl>isMoveAssignmentOperator; Matches if the given method declaration declares a move assignment; operator. Given; struct A {; A &operator=(const A &);; A &operator=(A &&);; };. cxxMethodDecl(isMoveAssignmentOperator()) matches the second method but not; the first one. Matcher<CXXMethodDecl>isOverride; Matches if the given method declaration overrides another method. Given; class A {; public:; virtual void x();; };; class B : public A {; public:; virtual void x();; };; matches B::x. Matcher<CXXMethodDecl>isPure; Matches if the given method declaration is pure. Given; class A {; public:; virtual void x() = 0;; };; matches A::x. Matcher<CXXMethodDecl>isUserProvided; Matches method declarations that are user-provided. Given; struct S {; S(); // #1; S(const S &) = default; // #2; S(S &&) = delete; // #3; };; cxxConstructorDecl(isUserProvided()) will match #1, but not #2 or #3. Matcher<CXXMethodDecl>isVirtual; Matches declarations of virtual methods and C++ base specifers that specify; virtual inheritance. Example:; class A {; public:; virtual void x(); // matches x; };. Example:; class Base {};; class DirectlyDerived : virtual Base {}; // matches Base; class IndirectlyDerived : DirectlyDerived, Base {}; // matches Base. Usable as: Matcher<CXXMethodDecl>, Matcher<CXXBaseSpecifier>. Matcher<CXXMethodDecl>isVirtualAsWritten; Matches if the given method declaration has an explicit ""virtual"". Given; class A {; public:; virtual void x();; };; class B : public A {; public:; void x();; };; matches A::x but not B::x. Matcher<CXXNewExpr>isArray; Matches array new expressions. Given:; MyClass *p1 = new MyClass[10];; cxxNewExpr(isArray()); matches the expression 'new MyClass[10]'. Matcher<CXXOperatorCallExpr>hasAnyOperatorNameStringRef, ..., StringRef; Matches operator expressions (binary or unary) that have any of the; specified names. hasAnyOperatorName(""+"", ""-""); Is equivalent to; anyOf(hasOperatorName(""+""), hasOperatorName(""-"")).",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:70041,inherit,inheritance,70041,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['inherit'],['inheritance']
Modifiability,"nd classes the user has defined. Other; values are ""regression"", ""classification"" and ""multiclass"" for; the forthcoming multiclass classification.; Missing regression evaluation plots for training sample were; added. On Cut method:. Removed obsolete option ""FVerySmart"" from Cuts method. On MLP method:; ; Display of convergence information in the progress bar for MLP during training. Creation of animated gifs for MLP convergence monitoring (please; contact authors if you want to do this). On Datasets: . Checks are performed if events are unvoluntarily cut by using a; non-filled array entry (e.g. ""arr[4]"" is used, when the array; has not always at least 5 entries). A warning is given in that; case.; Bug fixes. Spectators and Targets could not be used with by-hand assignment of events.; Corrected types (training/testing) for assigning single events.; Changed message from FATAL to WARNING when the user requests more events for ; training or testing than available.; Fixed bug which caused TMVA to crash if the number of input variables exceeded ; the allowed maximum for generating scatter plots.; Prevent TMVA from crashing when running with an empty TTree or TChain.; A variable expression like ""Alt$(arr[3],0)"" can now be used; to give a default value for a variable if for some events the; array don't contain enough elements (e.g. in two jet events,; sometimes only one jet is found and thus, the array jetPt[] has; only one entry in that cases).; Plot ranges for scatter-plots showing the transformed events are now correct.; User defined training/testing-trees are now handled correctly.; Fix bug in correlation computation for regression.; Consistent use of variable labels (for the log output) and variable titles (in histograms).; Drawing of variable labels in network architecture display for regression mode has been added.; Bug fixes to Cuts which improves performance on datasets with many variables.; Bug fix in GaussTransformation which improves handling of gaussian tails. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html:3178,variab,variables,3178,tmva/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html,14,['variab'],"['variable', 'variables']"
Modifiability,"nd drawing objects.; One also can load some special components directly like:. ```javascript; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; ```. After script loading one can configure different parameters in `gStyle` object.; It is instance of the `TStyle` object and behaves like `gStyle` variable in ROOT. For instance,; to change stat format using to display value in stats box:. ```javascript; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; ```. There is also `settings` object which contains all other JSROOT settings. For instance,; one can configure custom format for different axes:. ```javascript; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; ```. One also can use `build/jsroot.js` bundle to load all functionality at one and access it via `JSROOT` global handle:. ```javascript; <script src=""https://root.cern/js/latest/build/jsroot.js""></script>; <script>; // getting json string from somewhere; let obj = JSROOT.parse(root_json);; JSROOT.draw('plain', obj, 'colz');; </script>; ```. ### Use of JSON. It is strongly recommended to use JSON when communicating with ROOT application.; THttpServer provides a JSON representation for every registered object with an url address like:. http://your_root_server:8080/Canvases/c1/root.json. Such JSON representation generated using the [TBufferJSON](https://root.cern/doc/master/classTBufferJSON.html) class. One could create JSON file for any ROOT object directly, just writing in the code:. ```cpp; obj->",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:36030,config,configure,36030,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['config'],['configure']
Modifiability,"nd graph types have been added in the histogram library (libHist) and graph library:; ; ROOT::Fit::FillData( BinData & , const TH1 *, TF1 * ) for histograms (in libHist); ROOT::Fit::FillData( BinData & , const TGraph2D *, TF1 * ) for 2D graphs (in libHist); ROOT::Fit::FillData( BinData & , const TGraph *, TF1 * ) for all 1D graphs (in libGraf); ROOT::Fit::FillData( BinData & , const TMultiGraph *, TF1 * ) for multi-graphs (in libGraf); . MathCore Numerical Algorithms. Classes implementing numerical methods which can be used by all the other ROOT library have been added in MathCore. These originate mainly from methods present previously in the implementation of the TF1 class. Now they can be used also outside this class. In addition, in order to have a common entry point, interfaces classes for these numerical algorithms have been; included.; These interfaces are as well implemented by classes using the GSL library and located in the MathMore library. The library can be loaded automatically using the ROOT plug-in manager.; In detail, the new classes containing implementations present previously in TF1 are:. ; GaussIntegrator and GaussLegendreIntegrator for numerical integration of one-dimensional functions. The first class uses Gaussian 8 and 16 point quadrature approximation, it provides the translation of the CERNLIB algorithm; DGAUSS by Sigfried Kolbig, and it is used by the TF1::Integral method. The second one uses the Gauss Legendre quadrature formula. It is used by the TF1::IntegralFast method.; These classes implement both the same virtual interface as the adaptive integration methods provided by the MathMore library. They can all be created and used easily via the common class ROOT::Math::IntegratorOneDim providing the interfaces for numerical integration.; New template methods have been also included in the common Integration class in order to be able to integrate automatically any C++ callable object. ROOT::Math::RichardsonDerivator implementing numerical d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:6539,plug-in,plug-in,6539,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['plug-in'],['plug-in']
Modifiability,"nd leave out the x-points, the diagram will look like this:. ## 3D Graphics Libraries. ## Geometry Libraries. - Support with web geometry viewer image production in batch mode. Just do:; ```; ROOT::Experimental::RGeomViewer viewer(geom);; viewer.SaveImage(""rootgeom.jpeg"", 800, 600);; ```; This runs normal WebGL rendering in headless web browser (Chrome or Firefox) and; creates png or jpeg image out of it. ## Database Libraries. ## Networking Libraries. ### THttpServer. - upgrade civetweb code to version 1.15, supports SSL version 3.0; - resolve problem with symbolic links usage on Windows; - let disable/enable directory files listing via THttpServer (default is off); - enable usage of unix sockets, used by `rootssh` script for tunnel to remote session. ## GUI Libraries. - Provide web-based TTree viewer, integrated with RBrowser; - Support Edge browser on Windows for all kinds of web widgets; - Provide `rootssh` shell script to simplify use of web-based widgets on remote nodes:; ```; [localnode] rootssh user@remotenode; [remotenode] root --web -e 'new TBrowser'; ```; Script automatically configures ssh tunnel between local and remote nodes, one the remote node; unix socket with strict 0700 mode is used. When ROOT running on remote node wants to display; new web widget, script will automatically start web browser on local node with appropriate URL,; accessing widget via configured ssh tunnel. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. - Major JSROOT upgrade to version 7, using ES6 modules and classes. ## Tutorials. - Several new tutorials have been added in both C++ and Python in the `tutorial/tmva` directory.; Tutorials like `TMVA_Higgs_Classification.py` shows the new pythonizations available in TMVA and; new `TMVA_SOFIE_...` tutorials show th eusage of SOFIE in both C++ or Python. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. - Building external applications that use ROOT oftentimes fail if ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:32429,config,configures,32429,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['config'],['configures']
Modifiability,"nd not invalid as before. This makes also the function minimum valid when a matrix was decleared pos def.; Improvements in the Minuit2Minimizer class:; . implement the new methods defined in the base class: Hess() using MnHess and CovMatrixStatus();; ; improve the switch-off of the info message according to the print level;; ; define the variables passed with zero step-size as constant (as is done in F77 Minuit); . Fix a problem in building the parallel version of Minuit2. The parallel version is built if the environment variables USE_PARALLEL_MINUIT2 and USE_OPENMP are set before compiling Minuit2 on a compiler which supports openMP (for example gcc version >= 4.2); ; Add, thanks to Alfio Lazzaro, support for running Minuit2 using multi-process by using MPI. A new class MPIProcess deals with starting and terminating the MPI process. Each process calculates independently the derivatives for a given set of parameters.; A Minuit2 library with MPI support can be built by defining before compilation the environment variables USE_PARALLEL_MINUIT2 and USE_MPI. Unuran; Add constructor of Tunuran distributions using function objects defined using the mathcore interfaces:. TUnuranContDist (const ROOT::Math::IGenFunction & pdf, const ROOT::Math::IGenFunction * dpdf, bool isLogPdf);; TUnuranMultiContDist (const ROOT::Math::IMultiGenFunction & pdf, bool isLogPdf );; TUnuranDiscrDist (const ROOT::Math::IGenFunction & func );. TRolke; New version of TRolke from J. Lundberg. The interface of the class has been changed. The old user interface was very hard to use, and the documentation in the source was also not on par with the correct usage. The old interface was a single get-function with 12 arguments, and the user was supposed to figure out which ~ 5 arguments were relevant for a specific model (1 out of 7 models).; ; The new user interface is is easy to use correctly and hard to use incorrectly (TM). It's a single set-method for each method:. SetPoissonBkgBinomialEff(Int_t x,In",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html:7817,variab,variables,7817,math/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html,2,['variab'],['variables']
Modifiability,"nd punting extra comparisons to the callback. In any case, we can start building this sub-matcher. We can require that; the increment step be a unary increment like this:. .. code-block:: c++. hasIncrement(unaryOperator(hasOperatorName(""++""))). Specifying what is incremented introduces another quirk of Clang's AST:; Usages of variables are represented as ``DeclRefExpr``'s (""declaration; reference expressions"") because they are expressions which refer to; variable declarations. To find a ``unaryOperator`` that refers to a; specific declaration, we can simply add a second condition to it:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr()))). Furthermore, we can restrict our matcher to only match if the; incremented variable is an integer:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(varDecl(hasType(isInteger()))))))). And the last step will be to attach an identifier to this variable, so; that we can retrieve it in the callback:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(; varDecl(hasType(isInteger())).bind(""incrementVariable"")))))). We can add this code to the definition of ``LoopMatcher`` and make sure; that our program, outfitted with the new matcher, only prints out loops; that declare a single variable initialized to zero and have an increment; step consisting of a unary increment of some variable. Now, we just need to add a matcher to check if the condition part of the; ``for`` loop compares a variable against the size of the array. There is; only one problem - we don't know which array we're iterating over; without looking at the body of the loop! We are again restricted to; approximating the result we want with matchers, filling in the details; in the callback. So we start with:. .. code-block:: c++. hasCondition(binaryOperator(hasOperatorName(""<""))). It makes sense to ensure that the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:12676,variab,variable,12676,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['variab'],['variable']
Modifiability,"nd purpose: they; establish the substitution order so that both ``%{check}`` and its parameters; expand as desired. There's a simple way to remember the required definition; order in a test file: define a substitution before any substitution that might; refer to it. In general, substitution expansion behaves as follows:. - Upon arriving at each ``RUN:`` line, lit expands all substitutions in that; ``RUN:`` line using their current values from the substitution list. No; substitution expansion is performed immediately at ``DEFINE:`` and; ``REDEFINE:`` directives except ``%(line)``, ``%(line+<number>)``, and; ``%(line-<number>)``.; - When expanding substitutions in a ``RUN:`` line, lit makes only one pass; through the substitution list by default. In this case, a substitution must; have been inserted earlier in the substitution list than any substitution; appearing in its value in order for the latter to expand. (For greater; flexibility, you can enable multiple passes through the substitution list by; setting `recursiveExpansionLimit`_ in a lit configuration file.); - While lit configuration files can insert anywhere in the substitution list,; the insertion behavior of the ``DEFINE:`` and ``REDEFINE:`` directives is; specified below and is designed specifically for the use case presented in the; example above.; - Defining a substitution in terms of itself, whether directly or via other; substitutions, should be avoided. It usually produces an infinitely recursive; definition that cannot be fully expanded. It does *not* define the; substitution in terms of its previous value, even when using ``REDEFINE:``. The relationship between the ``DEFINE:`` and ``REDEFINE:`` directive is; analogous to the relationship between a variable declaration and variable; assignment in many programming languages:. - ``DEFINE: %{name} = value``. This directive assigns the specified value to a new substitution whose; pattern is ``%{name}``, or it reports an error if there is already a; subst",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:31766,config,configuration,31766,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['config'],['configuration']
Modifiability,"nd save the tree. The code below adds a simple; branch to an existing tree. Note that the `kOverwrite` option in the; `Write` method overwrites the existing tree. If it is not specified, two; copies of the tree headers are saved. ``` {.cpp}; void tree3AddBranch() {; TFile f(""tree3.root"",""update"");; Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3-> Branch(""new_v"",&new_v,""new_v/F"");; //read the number of entries in the t3; Int_t nentries = (Int_t)t3->GetEntries();; for (Int_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0,1);; newBranch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the tree; }; ```. Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk loosing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is may also be corrupted. In addition, adding a branch to; a tree enlarges the tree and increases the amount of memory needed to; read an entry, and therefore decreases the performance. For these; reasons, ROOT offers the concept of friends for trees (and chains). We; encourage you to use `TTree::AddFriend` rather than adding a branch; manually. ### TTree::AddFriend. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way it; is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the; `TTree::AddFriend` method. The **`TTree`** (`tree`) below has two; friends (`ft1` and `ft2`) and now has access to the variables; `a,b,c,i,j,k,l` and `m`. ![](pictures/02000101.jpg). The `AddFriend` method has two parameters, the fir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:52280,extend,extend,52280,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['extend'],['extend']
Modifiability,"nd the default ROOT tree name; in the file (as specified in the dataset staging request from ROOT). An example:. dsmgrd.stagecmd /path/to/afdsmgrd-xrd-stage-verify.sh ""$URLTOSTAGE"" ""$TREENAME"". Return value of the command is ignored: standard output is; considered, as explained here. Defaults to `/bin/false`. dsmgrd.cmdtimeoutsecs *secs*; : Timeout on staging command, expressed in seconds: after this; timeout, the command is considered failed and it is killed (in first; place with `SIGSTOP`, then if it is unresponsive with `SIGKILL`).; Defaults to **0 (no timeout)**. dsmgrd.corruptafterfails *n*; : Set this to a number above zero to tell the daemon to mark files as; corrupted after a certain number of either download or verification; failures. A value of **0 (default)** tells the daemon to retry; forever. Configuring the MonALISA monitoring plugin; ------------------------------------------. The Dataset Stager supports generic monitoring plugins. The only plugin; distributed with the stager is the MonALISA monitoring plugin. dsmgrd.notifyplugin */path/to/libafdsmgrd\_notify\_apmon.so*; : Set it to the path of the MonALISA plugin shared object. By default,; notification plugin is disabled. dsmgrd.apmonurl *apmon://apmon.cern.ch*; : This variable tells the ApMon notification plugin how to contact one; or more MonALISA server(s) to activate monitoring via ApMon. It; supports two kinds of URLs:. - `http[s]://host/path/configuration_file.conf` (a remote file; where to fetch the list of servers from). - `apmon://[:password@]monalisahost[:8884]` (a single server to; contact directly). If the variable is not set, yet the plugin is loaded, MonALISA; monitoring is inhibited until a valid configuration variable is; provided. dsmgrd.apmonprefix *MY::CLUSTER::PREFIX*; : Since MonALISA organizes information in ""clusters"" and ""hosts"", here; you can specify what to use as cluster prefix for monitoring; datasets information and daemon status. If this variable is not set,; MonALISA m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md:4870,plugin,plugin,4870,proof/doc/confman/DatasetStager.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md,2,['plugin'],['plugin']
Modifiability,"nd the following ``switch``/``case`` statements:. .. code-block:: c++. switch (Desc->TSFlags & X86::FormMask) {; case X86II::Pseudo: // for not yet implemented instructions; ... // or pseudo-instructions; break;; case X86II::RawFrm: // for instructions with a fixed opcode value; ...; break;; case X86II::AddRegFrm: // for instructions that have one register operand; ... // added to their opcode; break;; case X86II::MRMDestReg:// for instructions that use the Mod/RM byte; ... // to specify a destination (register); break;; case X86II::MRMDestMem:// for instructions that use the Mod/RM byte; ... // to specify a destination (memory); break;; case X86II::MRMSrcReg: // for instructions that use the Mod/RM byte; ... // to specify a source (register); break;; case X86II::MRMSrcMem: // for instructions that use the Mod/RM byte; ... // to specify a source (memory); break;; case X86II::MRM0r: case X86II::MRM1r: // for instructions that operate on; case X86II::MRM2r: case X86II::MRM3r: // a REGISTER r/m operand and; case X86II::MRM4r: case X86II::MRM5r: // use the Mod/RM byte and a field; case X86II::MRM6r: case X86II::MRM7r: // to hold extended opcode data; ...; break;; case X86II::MRM0m: case X86II::MRM1m: // for instructions that operate on; case X86II::MRM2m: case X86II::MRM3m: // a MEMORY r/m operand and; case X86II::MRM4m: case X86II::MRM5m: // use the Mod/RM byte and a field; case X86II::MRM6m: case X86II::MRM7m: // to hold extended opcode data; ...; break;; case X86II::MRMInitReg: // for instructions whose source and; ... // destination are the same register; break;; }. The implementations of these case statements often first emit the opcode and; then get the operand(s). Then depending upon the operand, helper methods may; be called to process the operand(s). For example, in ``X86CodeEmitter.cpp``,; for the ``X86II::AddRegFrm`` case, the first data emitted (by ``emitByte``) is; the opcode added to the register operand. Then an object representing the; machine operand, `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:78691,extend,extended,78691,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['extend'],['extended']
Modifiability,"nd then verify that it occurs again; later in the file. For codegen tests, this can be useful to allow any; register, but verify that that register is used consistently later. To do; this, :program:`FileCheck` supports string substitution blocks that allow; string variables to be defined and substituted into patterns. Here is a simple; example:. .. code-block:: llvm. ; CHECK: test5:; ; CHECK: notw	[[REGISTER:%[a-z]+]]; ; CHECK: andw	{{.*}}[[REGISTER]]. The first check line matches a regex ``%[a-z]+`` and captures it into the; string variable ``REGISTER``. The second line verifies that whatever is in; ``REGISTER`` occurs later in the file after an ""``andw``"". :program:`FileCheck`; string substitution blocks are always contained in ``[[ ]]`` pairs, and string; variable names can be formed with the regex ``[a-zA-Z_][a-zA-Z0-9_]*``. If a; colon follows the name, then it is a definition of the variable; otherwise, it; is a substitution. :program:`FileCheck` variables can be defined multiple times, and substitutions; always get the latest value. Variables can also be substituted later on the; same line they were defined on. For example:. .. code-block:: llvm. ; CHECK: op [[REG:r[0-9]+]], [[REG]]. Can be useful if you want the operands of ``op`` to be the same register,; and don't care exactly which register it is. If ``--enable-var-scope`` is in effect, variables with names that; start with ``$`` are considered to be global. All others variables are; local. All local variables get undefined at the beginning of each; CHECK-LABEL block. Global variables are not affected by CHECK-LABEL.; This makes it easier to ensure that individual tests are not affected; by variables set in preceding tests. FileCheck Numeric Substitution Blocks; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. :program:`FileCheck` also supports numeric substitution blocks that allow; defining numeric variables and checking for numeric values that satisfy a; numeric expression constraint based on those variables via",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:27110,variab,variables,27110,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variables']
Modifiability,"nd these chapters; useful: see ""Networking"", ""Writing a Graphical User Interface"",; ""Threads"", and ""PROOF: Parallel Processing"". ## Conventions Used in This Book. We tried to follow a style convention for the sake of clarity. The; styles in used are described below. To show source code in scripts or source files:. ``` {.cpp}; {; cout << "" Hello"" << endl;; float x = 3.;; float y = 5.;; int i = 101;; cout <<"" x = ""<<x<<"" y = ""<<y<<"" i = ""<<i<< endl;; }; ```. To show the ROOT command line, we show the ROOT prompt without numbers.; In the interactive system, the ROOT prompt has a line number; (`root[12]`); for the sake of simplicity, the line numbers are left; off. ``` {.cpp}; root[] TLine l; root[] l.Print(); TLine X1=0.000000 Y1=0.000000 X2=0.000000 Y2=0.000000; ```. Italic bold monotype font indicates a global variable, for example; ***`gDirectory`***. When a variable term is used, it is shown between angled brackets. In; the example below the variable term \<library\> can be replaced with; any library in the `$ROOTSYS` directory: `$ROOTSYS/<library>/inc.`. ## The Framework. ROOT is an object-oriented framework aimed at solving the data; analysis challenges of high-energy physics. There are two key words in; this definition, object oriented and framework. First, we explain what; we mean by a framework and then why it is an object-oriented; framework. ### What Is a Framework?. Programming inside a framework is a little like living in a city.; Plumbing, electricity, telephone, and transportation are services; provided by the city. In your house, you have interfaces to the; services such as light switches, electrical outlets, and telephones.; The details, for example, the routing algorithm of the phone switching; system, are transparent to you as the user. You do not care; you are; only interested in using the phone to communicate with your; collaborators to solve your domain specific problems. Programming outside of a framework may be compared to living in the; country",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:4417,variab,variable,4417,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['variab'],['variable']
Modifiability,"nd*, they'll be substituted; respectively with the destination URL and the default ROOT tree name; in the file (as specified in the dataset staging request from ROOT). An example:. dsmgrd.stagecmd /path/to/afdsmgrd-xrd-stage-verify.sh ""$URLTOSTAGE"" ""$TREENAME"". Return value of the command is ignored: standard output is; considered, as explained here. Defaults to `/bin/false`. dsmgrd.cmdtimeoutsecs *secs*; : Timeout on staging command, expressed in seconds: after this; timeout, the command is considered failed and it is killed (in first; place with `SIGSTOP`, then if it is unresponsive with `SIGKILL`).; Defaults to **0 (no timeout)**. dsmgrd.corruptafterfails *n*; : Set this to a number above zero to tell the daemon to mark files as; corrupted after a certain number of either download or verification; failures. A value of **0 (default)** tells the daemon to retry; forever. Configuring the MonALISA monitoring plugin; ------------------------------------------. The Dataset Stager supports generic monitoring plugins. The only plugin; distributed with the stager is the MonALISA monitoring plugin. dsmgrd.notifyplugin */path/to/libafdsmgrd\_notify\_apmon.so*; : Set it to the path of the MonALISA plugin shared object. By default,; notification plugin is disabled. dsmgrd.apmonurl *apmon://apmon.cern.ch*; : This variable tells the ApMon notification plugin how to contact one; or more MonALISA server(s) to activate monitoring via ApMon. It; supports two kinds of URLs:. - `http[s]://host/path/configuration_file.conf` (a remote file; where to fetch the list of servers from). - `apmon://[:password@]monalisahost[:8884]` (a single server to; contact directly). If the variable is not set, yet the plugin is loaded, MonALISA; monitoring is inhibited until a valid configuration variable is; provided. dsmgrd.apmonprefix *MY::CLUSTER::PREFIX*; : Since MonALISA organizes information in ""clusters"" and ""hosts"", here; you can specify what to use as cluster prefix for monitoring; datasets inf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md:4852,plugin,plugins,4852,proof/doc/confman/DatasetStager.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DatasetStager.md,1,['plugin'],['plugins']
Modifiability,"nd:. .. code-block:: c. ^ { printf(""hello world\n""); }. are exactly equivalent constructs for the same expression. The type_expression extends C expression parsing to accommodate Block; reference declarations as it accommodates function pointer; declarations. Given:. .. code-block:: c. typedef int (*pointerToFunctionThatReturnsIntWithCharArg)(char);; pointerToFunctionThatReturnsIntWithCharArg functionPointer;; ^ pointerToFunctionThatReturnsIntWithCharArg (float x) { return functionPointer; }. and:. .. code-block:: c. ^ int ((*)(float x))(char) { return functionPointer; }. are equivalent expressions, as is:. .. code-block:: c. ^(float x) { return functionPointer; }. [returnfunctionptr.c]. The compound statement body establishes a new lexical scope within; that of its parent. Variables used within the scope of the compound; statement are bound to the Block in the normal manner with the; exception of those in automatic (stack) storage. Thus one may access; functions and global variables as one would expect, as well as static; local variables. [testme]. Local automatic (stack) variables referenced within the compound; statement of a Block are imported and captured by the Block as const; copies. The capture (binding) is performed at the time of the Block; literal expression evaluation. The compiler is not required to capture a variable if it can prove; that no references to the variable will actually be evaluated.; Programmers can force a variable to be captured by referencing it in a; statement at the beginning of the Block, like so:. .. code-block:: c. (void) foo;. This matters when capturing the variable has side-effects, as it can; in Objective-C or C++. The lifetime of variables declared in a Block is that of a function;; each activation frame contains a new copy of variables declared within; the local scope of the Block. Such variable declarations should be; allowed anywhere [testme] rather than only when C99 parsing is; requested, including for statements. [testme]",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:4449,variab,variables,4449,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,2,['variab'],['variables']
Modifiability,"nd; dead after its deallocation.; It is undefined behavior to access a memory object that isn't alive, but; operations that don't dereference it such as; :ref:`getelementptr <i_getelementptr>`, :ref:`ptrtoint <i_ptrtoint>` and; :ref:`icmp <i_icmp>` return a valid result.; This explains code motion of these instructions across operations that; impact the object's lifetime.; A stack object's lifetime can be explicitly specified using; :ref:`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>` intrinsic function calls. .. _pointeraliasing:. Pointer Aliasing Rules; ----------------------. Any memory access must be done through a pointer value associated with; an address range of the memory access, otherwise the behavior is; undefined. Pointer values are associated with address ranges according; to the following rules:. - A pointer value is associated with the addresses associated with any; value it is *based* on.; - An address of a global variable is associated with the address range; of the variable's storage.; - The result value of an allocation instruction is associated with the; address range of the allocated storage.; - A null pointer in the default address-space is associated with no; address.; - An :ref:`undef value <undefvalues>` in *any* address-space is; associated with no address.; - An integer constant other than zero or a pointer value returned from; a function not defined within LLVM may be associated with address; ranges allocated through mechanisms other than those provided by; LLVM. Such ranges shall not overlap with any ranges of addresses; allocated by mechanisms provided by LLVM. A pointer value is *based* on another pointer value according to the; following rules:. - A pointer value formed from a scalar ``getelementptr`` operation is *based* on; the pointer-typed operand of the ``getelementptr``.; - The pointer in lane *l* of the result of a vector ``getelementptr`` operation; is *based* on the pointer in lane *l* of the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:141740,variab,variable,141740,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['variab'],['variable']
Modifiability,"nd; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E.g.:. .. code-block:: c++. Error foo() {; // Do something.; // Return success.; return Error::success();; }. Success values are very cheap to construct and return - they have minimal; impact on program performance. Failure values are constructed using ``make_error<T>``, where ``T`` is any class; that inherits from the ErrorInfo utility, E.g.:. .. code-block:: c++. class BadFileFormat : public ErrorInfo<BadFileFormat> {; public:; static char ID;; std::string Path;. BadFileFormat(StringRef Path) : Path(Path.str()) {}. void log(raw_ostream &OS) const override {; OS << Path << "" is malformed"";; }. std::error_code convertToErrorCode() const override {; return make_error_code(object_error::parse_failed);; }; };. char BadFileFormat::ID; // This should be declared in the C++ file. Error printFormattedFile(StringRef Path) {; if (<check for valid format>); return make_error<BadFileFormat>(Path);; // print file contents.; return Error::success();; }. Error values can be implicitly converted to bool: true for error, false for; success, enabling the following idiom:. .. code-block:: c++. Error mayFail();. Error foo() {; if (auto Err = mayFail()); return Err;; // Success! We can proceed.; ... For functions that can fail but need to return a value the ``Expected<T>``; util",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:19262,inherit,inherits,19262,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['inherit'],['inherits']
Modifiability,"ndValueVeryVeryVeryVeryLong;. .. _BreakConstructorInitializers:. **BreakConstructorInitializers** (``BreakConstructorInitializersStyle``) :versionbadge:`clang-format 5` :ref:`¶ <BreakConstructorInitializers>`; The break constructor initializers style to use. Possible values:. * ``BCIS_BeforeColon`` (in configuration: ``BeforeColon``); Break constructor initializers before the colon and after the commas. .. code-block:: c++. Constructor(); : initializer1(),; initializer2(). * ``BCIS_BeforeComma`` (in configuration: ``BeforeComma``); Break constructor initializers before the colon and commas, and align; the commas with the colon. .. code-block:: c++. Constructor(); : initializer1(); , initializer2(). * ``BCIS_AfterColon`` (in configuration: ``AfterColon``); Break constructor initializers after the colon and commas. .. code-block:: c++. Constructor() :; initializer1(),; initializer2(). .. _BreakInheritanceList:. **BreakInheritanceList** (``BreakInheritanceListStyle``) :versionbadge:`clang-format 7` :ref:`¶ <BreakInheritanceList>`; The inheritance list style to use. Possible values:. * ``BILS_BeforeColon`` (in configuration: ``BeforeColon``); Break inheritance list before the colon and after the commas. .. code-block:: c++. class Foo; : Base1,; Base2; {};. * ``BILS_BeforeComma`` (in configuration: ``BeforeComma``); Break inheritance list before the colon and commas, and align; the commas with the colon. .. code-block:: c++. class Foo; : Base1; , Base2; {};. * ``BILS_AfterColon`` (in configuration: ``AfterColon``); Break inheritance list after the colon and commas. .. code-block:: c++. class Foo :; Base1,; Base2; {};. * ``BILS_AfterComma`` (in configuration: ``AfterComma``); Break inheritance list only after the commas. .. code-block:: c++. class Foo : Base1,; Base2; {};. .. _BreakStringLiterals:. **BreakStringLiterals** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <BreakStringLiterals>`; Allow breaking string literals when formatting. In C, C++, and Objective-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:55093,inherit,inheritance,55093,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['inherit'],['inheritance']
Modifiability,"nded likelihood fit by passing the optional; *extended* boolean flag as *true*. This method is implemented using the class `LogLikelihoodFCN`; * **Linear Fit**: A linear fit can be selected (no iterative minimization is needed in this case, but using linear algebra algorithms from the *Matrix* library), if the model function is linear in the; parameters. #### Customised Fit methods. Above we described the pre-defined methods used for fitting. A user can also implement its own fitting methods, thus its version of the chi-square or likelihood function he wants to minimize.; In this case, the user does not really need to build as input a `ROOT::Fit` data set and model function as we described before. He can implements its own version of the method function using on its own; data set objects and functions. In this case `ROOT::Fit::Fitter::SetFCN` is used to set the method function and `ROOT::Fit::FitFCN` is used for fitting. The method function can be passed also in `ROOT::Fit::FitFCN`, but in this; case a previously defined fitting configuration is used. The possible type of method functions that are based in `ROOT::Fit::Fitter::SetFCN` are:. * A generic functor object implementing `operator()(const double * p)` where **`p`** is the parameter vectors. In this case one needs to pass the number of parameters,; the function object and optionally a vector of initial parameter values. Other optional parameter include the size of the data sets and a flag specifying if it is a chi2 (least-square fit).; In the last two parameters are given, the `chi2/ndf` can be computed after fitting the data.; ``` {.cpp}; template <class Function>; bool Fitter::SetFCN(unsigned int npar, Function & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. * A function object implementing the `ROOT::Math::IBaseFunctionMultiDim` interface:; ``` {.cpp}; bool Fitter::SetFCN(const ROOT::Math::IBaseFunctionMultiDim & f,; const double * initialParameters = 0,; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:47699,config,configuration,47699,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['config'],['configuration']
Modifiability,"nded to provide a guide to anyone either writing a frontend; for LLVM or working on optimization passes for LLVM with a guide for how to deal; with instructions with special semantics in the presence of concurrency. This; is not intended to be a precise guide to the semantics; the details can get; extremely complicated and unreadable, and are not usually necessary. .. _Optimization outside atomic:. Optimization outside atomic; ===========================. The basic ``'load'`` and ``'store'`` allow a variety of optimizations, but can; lead to undefined results in a concurrent environment; see `NotAtomic`_. This; section specifically goes into the one optimizer restriction which applies in; concurrent environments, which gets a bit more of an extended description; because any optimization dealing with stores needs to be aware of it. From the optimizer's point of view, the rule is that if there are not any; instructions with atomic ordering involved, concurrency does not matter, with; one exception: if a variable might be visible to another thread or signal; handler, a store cannot be inserted along a path where it might not execute; otherwise. Take the following example:. .. code-block:: c. /* C code, for readability; run through clang -O2 -S -emit-llvm to get; equivalent IR */; int x;; void f(int* a) {; for (int i = 0; i < 100; i++) {; if (a[i]); x += 1;; }; }. The following is equivalent in non-concurrent situations:. .. code-block:: c. int x;; void f(int* a) {; int xtemp = x;; for (int i = 0; i < 100; i++) {; if (a[i]); xtemp += 1;; }; x = xtemp;; }. However, LLVM is not allowed to transform the former to the latter: it could; indirectly introduce undefined behavior if another thread can access ``x`` at; the same time. That thread would read `undef` instead of the value it was; expecting, which can lead to undefined behavior down the line. (This example is; particularly of interest because before the concurrency model was implemented,; LLVM would perform this transf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:3019,variab,variable,3019,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['variab'],['variable']
Modifiability,"ndentWidth** (``Integer``) :versionbadge:`clang-format 13` :ref:`¶ <PPIndentWidth>`; The number of columns to use for indentation of preprocessor statements.; When set to -1 (default) ``IndentWidth`` is used also for preprocessor; statements. .. code-block:: c++. PPIndentWidth: 1. #ifdef __linux__; # define FOO; #else; # define BAR; #endif. .. _PackConstructorInitializers:. **PackConstructorInitializers** (``PackConstructorInitializersStyle``) :versionbadge:`clang-format 14` :ref:`¶ <PackConstructorInitializers>`; The pack constructor initializers style to use. Possible values:. * ``PCIS_Never`` (in configuration: ``Never``); Always put each constructor initializer on its own line. .. code-block:: c++. Constructor(); : a(),; b(). * ``PCIS_BinPack`` (in configuration: ``BinPack``); Bin-pack constructor initializers. .. code-block:: c++. Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). * ``PCIS_CurrentLine`` (in configuration: ``CurrentLine``); Put all constructor initializers on the current line if they fit.; Otherwise, put each one on its own line. .. code-block:: c++. Constructor() : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; ddddddddddddd(). * ``PCIS_NextLine`` (in configuration: ``NextLine``); Same as ``PCIS_CurrentLine`` except that if all constructor initializers; do not fit on the current line, try to fit them on the next line. .. code-block:: c++. Constructor() : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). * ``PCIS_NextLineOnly`` (in configuration: ``NextLineOnly``); Put all constructor initializers on the next line if they fit.; Otherwise, put each one on its own line. .. code-block:: c++. Constructor(); : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbb",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:92560,config,configuration,92560,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"nderstand* the LLVM code generated; by the compiler in the demo page, consider using ``printf()`` instead of; ``iostream``\s to print values. Where did all of my code go??; -----------------------------; If you are using the LLVM demo page, you may often wonder what happened to; all of the code that you typed in. Remember that the demo script is running; the code through the LLVM optimizers, so if your code doesn't actually do; anything useful, it might all be deleted. To prevent this, make sure that the code is actually needed. For example, if; you are computing some expression, return the value from the function instead; of leaving it in a local variable. If you really want to constrain the; optimizer, you can read from and assign to ``volatile`` global variables. What is this ""``undef``"" thing that shows up in my code?; --------------------------------------------------------; ``undef`` is the LLVM way of representing a value that is not defined. You; can get these if you do not initialize a variable before you use it. For; example, the C function:. .. code-block:: c. int X() { int i; return i; }. Is compiled to ""``ret i32 undef``"" because ""``i``"" never has a value specified; for it. Why does instcombine + simplifycfg turn a call to a function with a mismatched calling convention into ""unreachable""? Why not make the verifier reject it?; ----------------------------------------------------------------------------------------------------------------------------------------------------------; This is a common problem run into by authors of front-ends that are using; custom calling conventions: you need to make sure to set the right calling; convention on both the function and on each call to the function. For; example, this code:. .. code-block:: llvm. define fastcc void @foo() {; ret void; }; define void @bar() {; call void @foo(); ret void; }. Is optimized to:. .. code-block:: llvm. define fastcc void @foo() {; ret void; }; define void @bar() {; unreachable; }. ..",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst:8827,variab,variable,8827,interpreter/llvm-project/llvm/docs/FAQ.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst,1,['variab'],['variable']
Modifiability,"nderstanding of and contains the data associated with it.; class Grokable {; ...; public:; explicit Grokable() { ... }; virtual ~Grokable() = 0;. ... };. } // namespace knowledge; } // namespace llvm. Feel free to skip the closing comment when the namespace being closed is; obvious for any reason. For example, the outer-most namespace in a header file; is rarely a source of confusion. But namespaces both anonymous and named in; source files that are being closed half way through the file probably could use; clarification. .. _static:. Anonymous Namespaces; ^^^^^^^^^^^^^^^^^^^^. After talking about namespaces in general, you may be wondering about anonymous; namespaces in particular. Anonymous namespaces are a great language feature; that tells the C++ compiler that the contents of the namespace are only visible; within the current translation unit, allowing more aggressive optimization and; eliminating the possibility of symbol name collisions. Anonymous namespaces are; to C++ as ""static"" is to C functions and global variables. While ""``static``""; is available in C++, anonymous namespaces are more general: they can make entire; classes private to a file. The problem with anonymous namespaces is that they naturally want to encourage; indentation of their body, and they reduce locality of reference: if you see a; random function definition in a C++ file, it is easy to see if it is marked; static, but seeing if it is in an anonymous namespace requires scanning a big; chunk of the file. Because of this, we have a simple guideline: make anonymous namespaces as small; as possible, and only use them for class declarations. For example:. .. code-block:: c++. namespace {; class StringSort {; ...; public:; StringSort(...); bool operator<(const char *RHS) const;; };; } // namespace. static void runHelper() {; ...; }. bool StringSort::operator<(const char *RHS) const {; ...; }. Avoid putting declarations other than classes into anonymous namespaces:. .. code-block:: c++. namespa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:60080,variab,variables,60080,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['variab'],['variables']
Modifiability,"ndif. .. _arc.misc.self:. ``self``; --------. The ``self`` parameter variable of an non-init Objective-C method is considered; :ref:`externally-retained <arc.misc.externally_retained>` by the implementation.; It is undefined behavior, or at least dangerous, to cause an object to be; deallocated during a message send to that object. In an init method, ``self``; follows the :ref:``init family rules <arc.family.semantics.init>``. .. admonition:: Rationale. The cost of retaining ``self`` in all methods was found to be prohibitive, as; it tends to be live across calls, preventing the optimizer from proving that; the retain and release are unnecessary --- for good reason, as it's quite; possible in theory to cause an object to be deallocated during its execution; without this retain and release. Since it's extremely uncommon to actually; do so, even unintentionally, and since there's no natural way for the; programmer to remove this retain/release pair otherwise (as there is for; other parameters by, say, making the variable ``objc_externally_retained`` or; qualifying it with ``__unsafe_unretained``), we chose to make this optimizing; assumption and shift some amount of risk to the user. .. _arc.misc.enumeration:. Fast enumeration iteration variables; ------------------------------------. If a variable is declared in the condition of an Objective-C fast enumeration; loop, and the variable has no explicit ownership qualifier, then it is; implicitly :ref:`externally-retained <arc.misc.externally_retained>` so that; objects encountered during the enumeration are not actually retained and; released. .. admonition:: Rationale. This is an optimization made possible because fast enumeration loops promise; to keep the objects retained during enumeration, and the collection itself; cannot be synchronously modified. It can be overridden by explicitly; qualifying the variable with ``__strong``, which will make the variable; mutable again and cause the loop to retain the objects it e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:95170,variab,variable,95170,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variable']
Modifiability,"nding the Language: Mutable Variables; =======================================================. .. contents::; :local:. Chapter 7 Introduction; ======================. Welcome to Chapter 7 of the ""`Implementing a language with; LLVM <index.html>`_"" tutorial. In chapters 1 through 6, we've built a; very respectable, albeit simple, `functional programming; language <http://en.wikipedia.org/wiki/Functional_programming>`_. In our; journey, we learned some parsing techniques, how to build and represent; an AST, how to build LLVM IR, and how to optimize the resultant code as; well as JIT compile it. While Kaleidoscope is interesting as a functional language, the fact; that it is functional makes it ""too easy"" to generate LLVM IR for it. In; particular, a functional language makes it very easy to build LLVM IR; directly in `SSA; form <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_.; Since LLVM requires that the input code be in SSA form, this is a very; nice property and it is often unclear to newcomers how to generate code; for an imperative language with mutable variables. The short (and happy) summary of this chapter is that there is no need; for your front-end to build SSA form: LLVM provides highly tuned and; well tested support for this, though the way it works is a bit; unexpected for some. Why is this a hard problem?; ===========================. To understand why mutable variables cause complexities in SSA; construction, consider this extremely simple C example:. .. code-block:: c. int G, H;; int test(_Bool Condition) {; int X;; if (Condition); X = G;; else; X = H;; return X;; }. In this case, we have the variable ""X"", whose value depends on the path; executed in the program. Because there are two different possible values; for X before the return instruction, a PHI node is inserted to merge the; two values. The LLVM IR that we want for this example looks like this:. .. code-block:: llvm. @G = weak global i32 0 ; type of @G is i32*; @H = weak global ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:1164,variab,variables,1164,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability,"nding, enhancing, or bug fixing already implemented code,; use the style that is already being used so that the source is uniform and; easy to follow.**. Note that some code bases (e.g. ``libc++``) have special reasons to deviate; from the coding standards. For example, in the case of ``libc++``, this is; because the naming and other conventions are dictated by the C++ standard. There are some conventions that are not uniformly followed in the code base; (e.g. the naming convention). This is because they are relatively new, and a; lot of code was written before they were put in place. Our long term goal is; for the entire codebase to follow the convention, but we explicitly *do not*; want patches that do large-scale reformatting of existing code. On the other; hand, it is reasonable to rename the methods of a class if you're about to; change it in some other way. Please commit such changes separately to; make code review easier. The ultimate goal of these guidelines is to increase the readability and; maintainability of our common source base. Languages, Libraries, and Standards; ===================================. Most source code in LLVM and other LLVM projects using these coding standards; is C++ code. There are some places where C code is used either due to; environment restrictions, historical restrictions, or due to third-party source; code imported into the tree. Generally, our preference is for standards; conforming, modern, and portable C++ code as the implementation language of; choice. For automation, build-systems and utility scripts Python is preferred and; is widely used in the LLVM repository already. C++ Standard Versions; ---------------------. Unless otherwise documented, LLVM subprojects are written using standard C++17; code and avoid unnecessary vendor-specific extensions. Nevertheless, we restrict ourselves to features which are available in the; major toolchains supported as host compilers (see :doc:`GettingStarted` page,; section `Software`).",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:1667,maintainab,maintainability,1667,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['maintainab'],['maintainability']
Modifiability,"ndition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; br label %cond_next. cond_next:; %X.2 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]; ret i32 %X.2; }. In this example, the loads from the G and H global variables are; explicit in the LLVM IR, and they live in the then/else branches of the; if statement (cond\_true/cond\_false). In order to merge the incoming; values, the X.2 phi node in the cond\_next block selects the right value; to use based on where control flow is coming from: if control flow comes; from the cond\_false block, X.2 gets the value of X.1. Alternatively, if; control flow comes from cond\_true, it gets the value of X.0. The intent; of this chapter is not to explain the details of SSA form. For more; information, see one of the many `online; references <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_. The question for this article is ""who places the phi nodes when lowering; assignments to mutable variables?"". The issue here is that LLVM; *requires* that its IR be in SSA form: there is no ""non-ssa"" mode for; it. However, SSA construction requires non-trivial algorithms and data; structures, so it is inconvenient and wasteful for every front-end to; have to reproduce this logic. Memory in LLVM; ==============. The 'trick' here is that while LLVM does require all register values to; be in SSA form, it does not require (or permit) memory objects to be in; SSA form. In the example above, note that the loads from G and H are; direct accesses to G and H: they are not renamed or versioned. This; differs from some other compiler systems, which do try to version memory; objects. In LLVM, instead of encoding dataflow analysis of memory into; the LLVM IR, it is handled with `Analysis; Passes <../../WritingAnLLVMPass.html>`_ which are computed on demand. With this in mind, the high-level idea is that we want to make a stack; variable (which lives i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:3199,variab,variables,3199,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability,"nditional-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. IfMacros: ['IF']. For example: `KJ_IF_MAYBE; <https://github.com/capnproto/capnproto/blob/master/kjdoc/tour.md#maybes>`_. .. _IncludeBlocks:. **IncludeBlocks** (``IncludeBlocksStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IncludeBlocks>`; Dependent on the value, multiple ``#include`` blocks can be sorted; as one and divided based on category. Possible values:. * ``IBS_Preserve`` (in configuration: ``Preserve``); Sort each ``#include`` block separately. .. code-block:: c++. #include ""b.h"" into #include ""b.h"". #include <lib/main.h> #include ""a.h""; #include ""a.h"" #include <lib/main.h>. * ``IBS_Merge`` (in configuration: ``Merge``); Merge multiple ``#include`` blocks together and sort as one. .. code-block:: c++. #include ""b.h"" into #include ""a.h""; #include ""b.h""; #include <lib/main.h> #include <lib/main.h>; #include ""a.h"". * ``IBS_Regroup`` (in configuration: ``Regroup``); Merge multiple ``#include`` blocks together and sort as one.; Then split into groups based on category priority. See; ``IncludeCategories``. .. code-block:: c++. #include ""b.h"" into #include ""a.h""; #include ""b.h""; #include <lib/main.h>; #include ""a.h"" #include <lib/main.h>. .. _IncludeCategories:. **IncludeCategories** (``List of IncludeCategories``) :versionbadge:`clang-format 3.8` :ref:`¶ <IncludeCategories>`; Regular expressions denoting the different ``#include`` categories; used for ordering ``#includes``. `POSIX extended; <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html>`_; regular expressions are supported. These regular expressions are matched against the filename of an include; (including the <> or """") in order. The value belonging to the first; matching regular expression is assigned and ``#includes`` are sorted first; according to increasing category number and then alphabetically within; each category. If none of the regular expressions match, INT_MAX i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:65837,config,configuration,65837,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ndle keyboard navigation/selection.; For example:; TGLBContainer *lbc = (TGLBContainer *)fListBox->GetContainer();; lbc->Connect(""CurrentChanged(TGFrame*)"", ""MyGuiClass"", this, ""CurrentChanged(TGFrame*)"");. void MyGuiClass::CurrentChanged(TGFrame *f); {; TGTextLBEntry *lbe = (TGTextLBEntry *)f;; printf(""\nMyGuiClass::CurrentChanged() : Id = %d, Text = %s\n"", lbe->EntryId(), lbe->GetTitle());; }. TGSlider. Added SetEnabled(Bool_t) and SetState(Bool_t), allowing to disable or enable the TGSlider widgets (will be greyed if disabled). TGToolTip. Use a better way of positionning tooltips when they go out of screen; Avoid to overlap the mouse pointer when repositioning it (flickering effect!). TRootBrowser. Implemented the alphabetical sorting mechanism in the file browser.; The sorting is applied only in the current directory and the browser remembers every sorted directory.; For this purpose, a new picture button has been added to the file browser plug-in (the status of this button reflects the sorting status of each directory); Another button has been added to the file browser plug-in, used for refreshing the current directory in the list tree.; Refreshing now checks also if files still exist in the current directory; (for the case where files have been deleted by the user or by another application); Allow to change graphic properties of an object (e.g. a histogram) in a Root file via the context menu from the browser (by opening a ged editor); Size of directories, trees, and objects associated to keys inside Root files, or any kind of browsable object can be displayed in their associated tooltip, as soon as their GetObjectInfo() method returns their size as a long long int formatted in a const char * (""%lld""). TRootContextMenu. Close the context menu if the selected object is being deleted in the RecursiveRemove() operation. TRootCanvas/TRootEmbeddedCanvas. Drag and drop improvements for images (don't add margins between the canvas/pad border and the picture itself). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v528/index.html:1294,plug-in,plug-in,1294,gui/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v528/index.html,4,['plug-in'],['plug-in']
Modifiability,"ndow; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_prompt_shortcuts>`_; or call a `developer command file; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_file_locations>`_; to set the environment variables appropriately. Now you can run CMake with the Ninja generator to export a compilation; database:. .. code-block:: console. C:\> mkdir build-ninja; C:\> cd build-ninja; C:\build-ninja> cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. It is best to keep your Visual Studio IDE build folder separate from the; Ninja build folder. This prevents the two build systems from negatively; interacting with each other. Once the ``compile_commands.json`` file has been created by Ninja, you can; use that compilation database with Clang Tooling. One caveat is that because; there are indirect settings obtained through the environment variables,; you may need to run any Clang Tooling executables through a command prompt; window created for use with Visual Studio as described above. An; alternative, e.g. for using the Visual Studio debugger on a Clang Tooling; executable, is to ensure that the environment variables are also visible; to the debugger settings. This can be done locally in Visual Studio's; debugger configuration locally or globally by launching the Visual Studio; IDE from a suitable command-prompt window. Using Clang Tools; =================. After you completed the previous steps, you are ready to run clang tools. If; you have a recent clang installed, you should have ``clang-check`` in; ``$PATH``. Try to run it on any ``.cpp`` file inside the LLVM source tree:. .. code-block:: console. $ clang-check tools/clang/lib/Tooling/CompilationDatabase.cpp. If you're using vim, it's convenient to have clang-check integrated. Put; this into your ``.vimrc``:. ::. function! ClangCheckImpl(cmd); if &autowrite | wall | endif; echo ""Running "" . a:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:4017,variab,variables,4017,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,1,['variab'],['variables']
Modifiability,"nds give the execution count that each of the respective prior target; functions was called. .. _md_annotation:. '``annotation``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^. The ``annotation`` metadata can be used to attach a tuple of annotation strings; or a tuple of a tuple of annotation strings to any instruction. This metadata does; not impact the semantics of the program and may only be used to provide additional; insight about the program and transformations to users. Example:. .. code-block:: text. %a.addr = alloca ptr, align 8, !annotation !0; !0 = !{!""auto-init""}. Embedding tuple of strings example:. .. code-block:: text. %a.ptr = getelementptr ptr, ptr %base, i64 0. !annotation !0; !0 = !{!1}; !1 = !{!""gep offset"", !""0""}. '``func_sanitize``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``func_sanitize`` metadata is used to attach two values for the function; sanitizer instrumentation. The first value is the ubsan function signature.; The second value is the address of the proxy variable which stores the address; of the RTTI descriptor. If :ref:`prologue <prologuedata>` and '``func_sanitize``'; are used at the same time, :ref:`prologue <prologuedata>` is emitted before; '``func_sanitize``' in the output. Example:. .. code-block:: text. @__llvm_rtti_proxy = private unnamed_addr constant ptr @_ZTIFvvE; define void @_Z3funv() !func_sanitize !0 {; return void; }; !0 = !{i32 846595819, ptr @__llvm_rtti_proxy}. .. _md_kcfi_type:. '``kcfi_type``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^. The ``kcfi_type`` metadata can be used to attach a type identifier to; functions that can be called indirectly. The type data is emitted before the; function entry in the assembly. Indirect calls with the :ref:`kcfi operand; bundle<ob_kcfi>` will emit a check that compares the type identifier to the; metadata. Example:. .. code-block:: text. define dso_local i32 @f() !kcfi_type !0 {; ret i32 0; }; !0 = !{i32 12345678}. Clang emits ``kcfi_type`` metadata nodes for address-taken functions with; ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:322939,variab,variable,322939,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"nds.; .. TODO: Describe the syntax of the machine memory operands. Comments; ^^^^^^^^. Machine operands can have C/C++ style comments, which are annotations enclosed; between ``/*`` and ``*/`` to improve readability of e.g. immediate operands.; In the example below, ARM instructions EOR and BCC and immediate operands; ``14`` and ``0`` have been annotated with their condition codes (CC); definitions, i.e. the ``always`` and ``eq`` condition codes:. .. code-block:: text. dead renamable $r2, $cpsr = tEOR killed renamable $r2, renamable $r1, 14 /* CC::always */, $noreg; t2Bcc %bb.4, 0 /* CC:eq */, killed $cpsr. As these annotations are comments, they are ignored by the MI parser.; Comments can be added or customized by overriding InstrInfo's hook; ``createMIROperandComment()``. Debug-Info constructs; ---------------------. Most of the debugging information in a MIR file is to be found in the metadata; of the embedded module. Within a machine function, that metadata is referred to; by various constructs to describe source locations and variable locations. Source locations; ^^^^^^^^^^^^^^^^. Every MIR instruction may optionally have a trailing reference to a; ``DILocation`` metadata node, after all operands and symbols, but before; memory operands:. .. code-block:: text. $rbp = MOV64rr $rdi, debug-location !12. The source location attachment is synonymous with the ``!dbg`` metadata; attachment in LLVM-IR. The absence of a source location attachment will be; represented by an empty ``DebugLoc`` object in the machine instruction. Fixed variable locations; ^^^^^^^^^^^^^^^^^^^^^^^^. There are several ways of specifying variable locations. The simplest is; describing a variable that is permanently located on the stack. In the stack; or fixedStack attribute of the machine function, the variable, scope, and; any qualifying location modifier are provided:. .. code-block:: text. - { id: 0, name: offset.addr, offset: -24, size: 8, alignment: 8, stack-id: default,; 4 debug-info-vari",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:23988,variab,variable,23988,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['variab'],['variable']
Modifiability,"ne: 2, type: !12); !12 = !DIBasicType(name: ""int"", size: 32, align: 32, encoding: DW_ATE_signed); !13 = !DIExpression(); !14 = !DILocation(line: 2, column: 9, scope: !4); !15 = !DILocalVariable(name: ""Y"", scope: !4, file: !1, line: 3, type: !12); !16 = !DILocation(line: 3, column: 9, scope: !4); !17 = !DILocalVariable(name: ""Z"", scope: !18, file: !1, line: 5, type: !12); !18 = distinct !DILexicalBlock(scope: !4, file: !1, line: 4, column: 5); !19 = !DILocation(line: 5, column: 11, scope: !18); !20 = !DILocation(line: 6, column: 11, scope: !18); !21 = !DILocation(line: 6, column: 9, scope: !18); !22 = !DILocation(line: 8, column: 9, scope: !4); !23 = !DILocation(line: 8, column: 7, scope: !4); !24 = !DILocation(line: 9, column: 3, scope: !4). This example illustrates a few important details about LLVM debugging; information. In particular, it shows how the ``llvm.dbg.declare`` intrinsic and; location information, which are attached to an instruction, are applied; together to allow a debugger to analyze the relationship between statements,; variable definitions, and the code used to implement the function. .. code-block:: llvm. call void @llvm.dbg.declare(metadata i32* %X, metadata !11, metadata !13), !dbg !14; ; [debug line = 2:7] [debug variable = X]. The first intrinsic ``%llvm.dbg.declare`` encodes debugging information for the; variable ``X``. The metadata ``!dbg !14`` attached to the intrinsic provides; scope information for the variable ``X``. .. code-block:: text. !14 = !DILocation(line: 2, column: 9, scope: !4); !4 = distinct !DISubprogram(name: ""foo"", scope: !1, file: !1, line: 1, type: !5,; isLocal: false, isDefinition: true, scopeLine: 1,; isOptimized: false, retainedNodes: !2). Here ``!14`` is metadata providing `location information; <LangRef.html#dilocation>`_. In this example, scope is encoded by ``!4``, a; `subprogram descriptor <LangRef.html#disubprogram>`_. This way the location; information attached to the intrinsics indicates that the variable ``X",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:15920,variab,variable,15920,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"ne`` (in configuration: ``MultiLine``); Force break after template declaration only when the following; declaration spans multiple lines. .. code-block:: c++. template <typename T> T foo() {; }; template <typename T>; T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. * ``BTDS_Yes`` (in configuration: ``Yes``); Always break after template declaration. .. code-block:: c++. template <typename T>; T foo() {; }; template <typename T>; T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. .. _AttributeMacros:. **AttributeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <AttributeMacros>`; A vector of strings that should be interpreted as attributes/qualifiers; instead of identifiers. This can be useful for language extensions or; static analyzer annotations. For example:. .. code-block:: c++. x = (char *__capability)&y;; int function(void) __unused;; void only_writes_to_buffer(char *__output buffer);. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. AttributeMacros: ['__capability', '__output', '__unused']. .. _BinPackArguments:. **BinPackArguments** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BinPackArguments>`; If ``false``, a function call's arguments will either be all on the; same line or will have one line each. .. code-block:: c++. true:; void f() {; f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);; }. false:; void f() {; f(aaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);; }. .. _BinPackParameters:. **BinPackParameters** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BinPackParameters>`; If ``false``, a function declaration's or function definition's; parameters will either all be on the same line or will have one line each. .. code-block:: c++. true:; void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:36319,config,configuration,36319,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,2,['config'],"['configuration', 'configured']"
Modifiability,"near to; the left (**`TGDoubleHSlider`**) or bottom (**`TGDoubleHSlider`**) edge; of the slider. Alternatively, to change the `max` value you need to; press the mouse near to the right (**`TGDoubleHSlider`**) or top; (**`TGDoubleHSlider`**) edge of the slider. To change both values; simultaneously you should press the left mouse button near to the center; of the slider. ![](pictures/0200021C.jpg). **`TGDoubleSlider`** is an abstract base class that creates the main; slider parameters. The concrete class to use for a vertical double; slider is **`TGDoubleVSlider`** and **`TGDoubleHSlider`** for a; horizontal one. The double slider constructors are similar to those of; the other sliders. If you set `kDoubleScaleNo` as a scale parameter no; scale will be drawn. Here is an example:. ``` {.cpp}; vDslider = new TGDoubleVSlider(p,100,kDoubleScaleNo,dsliderID);; vDslider->SetRange(-10,10);; ```. ### Triple Slider. The new **`TGTripleHSlider`** and **`TGTripleVSlider`** classes inherit; from the double slider widgets and allow easy selection of a range and a; pointer value. The pointer position can be constrained into the selected; range or can be relative to it. ![](pictures/0300021D.png). To change the slider range value press the left mouse button near to the; left/right (top/bottom) edges of the slider. To change both values; simultaneously press the mouse button near to the slider center. To; change pointer value press the mouse on the pointer and drag it to the; desired position. ``` {.cpp}; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; ```. ### Progress Bars. A progress bar is a widget that shows that an operation is in progress; and how much time is left. It is a long rectangular bar, initially; empty, that fills with a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:86902,inherit,inherit,86902,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['inherit'],['inherit']
Modifiability,"ned Allocator; ========================. .. contents::; :local:; :depth: 2. Introduction; ============. The Scudo Hardened Allocator is a user-mode allocator, originally based on LLVM; Sanitizers'; `CombinedAllocator <https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/sanitizer_common/sanitizer_allocator_combined.h>`_.; It aims at providing additional mitigation against heap based vulnerabilities,; while maintaining good performance. Scudo is currently the default allocator in; `Fuchsia <https://fuchsia.dev/>`_, and in `Android <https://www.android.com/>`_; since Android 11. The name ""Scudo"" comes from the Italian word for; `shield <https://www.collinsdictionary.com/dictionary/italian-english/scudo>`_; (and Escudo in Spanish). Design; ======. Allocator; ---------; Scudo was designed with security in mind, but aims at striking a good balance; between security and performance. It was designed to be highly tunable and; configurable, and while we provide some default configurations, we encourage; consumers to come up with the parameters that will work best for their use; cases. The allocator combines several components that serve distinct purposes:. - the Primary allocator: fast and efficient, it services smaller allocation; sizes by carving reserved memory regions into blocks of identical size. There; are currently two Primary allocators implemented, specific to 32 and 64 bit; architectures. It is configurable via compile time options. - the Secondary allocator: slower, it services larger allocation sizes via the; memory mapping primitives of the underlying operating system. Secondary backed; allocations are surrounded by Guard Pages. It is also configurable via compile; time options. - the thread specific data Registry: defines how local caches operate for each; thread. There are currently two models implemented: the exclusive model where; each thread holds its own caches (using the ELF TLS); or the shared model; where threads share a fixed size pool of cac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:979,config,configurable,979,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,2,['config'],"['configurable', 'configurations']"
Modifiability,"ned integer; - `G`: a long signed integer, stored as 64 bit; - `g`: a long unsigned integer, stored as 64 bit; - `F`: a 32 bit floating point; - `D`: a 64 bit floating point; - `O`: [the letter 'o', not a zero] a boolean (Bool\_t). The type is used for a byte count to decide how much space to allocate.; The variable written is simply the block of bytes starting at the; starting address given in the second parameter. It may or may not match; the leaf list depending on whether or not the programmer is being; careful when choosing the leaf address, name, and type. By default, a variable will be copied with the number of bytes specified; in the type descriptor symbol. However, if the type consists of two; characters, the number specifies the number of bytes to be used when; copying the variable to the output buffer. The line below describes; `ntrack` to be written as a 16-bit integer (rather than a 32-bit; integer). ``` {.cpp}; ""ntrack/I2""; ```. With this Branch method, you can also add a leaf that holds an entire; array of variables. To add an array of floats use the `f[n]` notation; when describing the leaf. ``` {.cpp}; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; ```. You can also add an array of variable length:. ``` {.cpp}; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; ```. See ""Example 2: A Tree with a C Structure"" below; (`$ROOTSYS/tutorials/tree/tree2.C`) and `staff.C` at the beginning of; this chapter. ## Adding a TBranch to Hold an Object. To write a branch to hold an event object, we need to load the; definition of the `Event` class, which is in `$ROOTSYS/test/libEvent.so`; (if it doesn't exist type make in `$ROOTSYS/test`). An object can be; saved in a tree if a ROOT dictionary for its class has been generated; and loaded. ``` {.cpp}; root[] .L libEvent.so; ```. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:22489,variab,variables,22489,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"ned to a named value.; #. By default, unnamed temporaries are numbered sequentially (using a; per-function incrementing counter, starting with 0). However, when explicitly; specifying temporary numbers, it is allowed to skip over numbers. Note that basic blocks and unnamed function parameters are included in this; numbering. For example, if the entry basic block is not given a label name; and all function parameters are named, then it will get number 0. It also shows a convention that we follow in this document. When; demonstrating instructions, we will follow an instruction with a comment; that defines the type and name of value produced. High Level Structure; ====================. Module Structure; ----------------. LLVM programs are composed of ``Module``'s, each of which is a; translation unit of the input programs. Each module consists of; functions, global variables, and symbol table entries. Modules may be; combined together with the LLVM linker, which merges function (and; global variable) definitions, resolves forward declarations, and merges; symbol table entries. Here is an example of the ""hello world"" module:. .. code-block:: llvm. ; Declare the string constant as a global constant.; @.str = private unnamed_addr constant [13 x i8] c""hello world\0A\00"". ; External declaration of the puts function; declare i32 @puts(ptr nocapture) nounwind. ; Definition of main function; define i32 @main() {; ; Call puts function to write out the string to stdout.; call i32 @puts(ptr @.str); ret i32 0; }. ; Named metadata; !0 = !{i32 42, null, !""string""}; !foo = !{!0}. This example is made up of a :ref:`global variable <globalvars>` named; ""``.str``"", an external declaration of the ""``puts``"" function, a; :ref:`function definition <functionstructure>` for ""``main``"" and; :ref:`named metadata <namedmetadatastructure>` ""``foo``"". In general, a module is made up of a list of global values (where both; functions and global variables are global values). Global values are; repres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:6063,variab,variable,6063,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"nel function calling a device function in LLVM IR. The; function ``@my_kernel`` is callable from host code, but ``@my_fmad`` is not. .. code-block:: llvm. define float @my_fmad(float %x, float %y, float %z) {; %mul = fmul float %x, %y; %add = fadd float %mul, %z; ret float %add; }. define void @my_kernel(float* %ptr) {; %val = load float, float* %ptr; %ret = call float @my_fmad(float %val, float %val, float %val); store float %ret, float* %ptr; ret void; }. !nvvm.annotations = !{!1}; !1 = !{void (float*)* @my_kernel, !""kernel"", i32 1}. When compiled, the PTX kernel functions are callable by host-side code. .. _address_spaces:. Address Spaces; --------------. The NVPTX back-end uses the following address space mapping:. ============= ======================; Address Space Memory Space; ============= ======================; 0 Generic; 1 Global; 2 Internal Use; 3 Shared; 4 Constant; 5 Local; ============= ======================. Every global variable and pointer type is assigned to one of these address; spaces, with 0 being the default address space. Intrinsics are provided which; can be used to convert pointers between the generic and non-generic address; spaces. As an example, the following IR will define an array ``@g`` that resides in; global device memory. .. code-block:: llvm. @g = internal addrspace(1) global [4 x i32] [ i32 0, i32 1, i32 2, i32 3 ]. LLVM IR functions can read and write to this array, and host-side code can; copy data to it by name with the CUDA Driver API. Note that since address space 0 is the generic space, it is illegal to have; global variables in address space 0. Address space 0 is the default address; space in LLVM, so the ``addrspace(N)`` annotation is *required* for global; variables. Triples; -------. The NVPTX target uses the module triple to select between 32/64-bit code; generation and the driver-compiler interface to use. The triple architecture; can be one of ``nvptx`` (32-bit PTX) or ``nvptx64`` (64-bit PTX). The; operating system",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:2313,variab,variable,2313,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['variab'],['variable']
Modifiability,"nerCamelBack]_.; Approval for ``lower_case`` was expressed by [CarruthLower]_; [CarruthCamelBack]_ [TurnerLLDB]_.; Opposition to ``lower_case`` was expressed by [LattnerLower]_. Differentiating variable kinds; ------------------------------. An additional requested change is to distinguish between different kinds of; variables [RobinsonDistinguish]_ [RobinsonDistinguish2]_ [JonesDistinguish]_; [IvanovicDistinguish]_ [CarruthDistinguish]_ [MalyutinDistinguish]_. Others oppose this idea [HähnleDistinguish]_ [GreeneDistinguish]_; [HendersonPrefix]_. A possibility is for member variables to be prefixed with ``m_`` and for global; variables to be prefixed with ``g_`` to distinguish them from local variables.; This is consistent with [LLDB]_. The ``m_`` prefix is consistent with [WebKit]_. A variation is for member variables to be prefixed with ``m``; [IvanovicDistinguish]_ [BeylsDistinguish]_. This is consistent with [Mozilla]_. Another option is for member variables to be suffixed with ``_`` which is; consistent with [Google]_ and similar to [Python]_. Opposed by; [ParzyszekDistinguish]_. Reducing the number of acronyms; ===============================. While switching coding standard will make it easier to use non-acronym names for; new code, it doesn't improve the existing large body of code that uses acronyms; extensively to the detriment of its readability. Further, it is natural and; generally encouraged that new code be written in the style of the surrounding; code. Therefore it is likely that much newly written code will also use; acronyms despite what the coding standard says, much as it is today. As well as changing the case of variable names, they could also be expanded to; their non-acronym form e.g. ``Triple T`` → ``Triple triple``. There is support for expanding many acronyms [CarruthAcronym]_ [PicusAcronym]_; but there is a preference that expanding acronyms be deferred; [ParzyszekAcronym]_ [CarruthAcronym]_. The consensus within the community seems to be t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:4459,variab,variables,4459,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['variab'],['variables']
Modifiability,"neral improvements; ====================; - New collapse clause scheme to avoid expensive remainder operations.; Compute loop index variables after collapsing a loop nest via the; collapse clause by replacing the expensive remainder operation with; multiplications and additions. - When using the collapse clause on a loop nest the default behavior; is to automatically extend the representation of the loop counter to; 64 bits for the cases where the sizes of the collapsed loops are not; known at compile time. To prevent this conservative choice and use; at most 32 bits, compile your program with the; `-fopenmp-optimistic-collapse`. GPU devices support; ===================. Data-sharing modes; ------------------. Clang supports two data-sharing models for Cuda devices: `Generic` and `Cuda`; modes. The default mode is `Generic`. `Cuda` mode can give an additional; performance and can be activated using the `-fopenmp-cuda-mode` flag. In; `Generic` mode all local variables that can be shared in the parallel regions; are stored in the global memory. In `Cuda` mode local variables are not shared; between the threads and it is user responsibility to share the required data; between the threads in the parallel regions. Often, the optimizer is able to; reduce the cost of `Generic` mode to the level of `Cuda` mode, but the flag,; as well as other assumption flags, can be used for tuning. Features not supported or with limited support for Cuda devices; ---------------------------------------------------------------. - Cancellation constructs are not supported. - Doacross loop nest is not supported. - User-defined reductions are supported only for trivial types. - Nested parallelism: inner parallel regions are executed sequentially. - Debug information for OpenMP target regions is supported, but sometimes it may; be required to manually specify the address class of the inspected variables.; In some cases the local variables are actually allocated in the global memory,; but the de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:1777,variab,variables,1777,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['variab'],['variables']
Modifiability,"neral, insert new dynamic; occurrences of such casts. If a new cast is inserted, the optimizer would; need to either ensure that a) all possible values are valid, or b); appropriate fencing is inserted. Since the appropriate fencing is; implementation defined, the optimizer can't do the latter. The former is; challenging as many commonly expected properties, such as; ``ptrtoint(v)-ptrtoint(v) == 0``, don't hold for non-integral types.; Similar restrictions apply to intrinsics that might examine the pointer bits,; such as :ref:`llvm.ptrmask<int_ptrmask>`. . The alignment information provided by the frontend for a non-integral pointer; (typically using attributes or metadata) must be valid for every possible ; representation of the pointer. .. _globalvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be initialized. Global variables in other translation units can also be declared, in which; case they don't have an initializer. Global variables can optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:30537,variab,variables,30537,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"nerally; # preferred. They perform better, they perform more consistently across; # different compilers, and they build more quickly."". if (CAN_USE_ASSEMBLER); if (MSVC); check_symbol_exists(_M_X64 """" IS_X64); if (IS_X64); enable_language(ASM_MASM); list(APPEND LLVM_BLAKE3_FILES; blake3_sse2_x86-64_windows_msvc.asm; blake3_sse41_x86-64_windows_msvc.asm; blake3_avx2_x86-64_windows_msvc.asm; blake3_avx512_x86-64_windows_msvc.asm; ); else(); disable_blake3_x86_simd(); endif(); elseif(WIN32 OR CYGWIN); check_symbol_exists(__x86_64__ """" IS_X64); if (IS_X64); list(APPEND LLVM_BLAKE3_FILES; blake3_sse2_x86-64_windows_gnu.S; blake3_sse41_x86-64_windows_gnu.S; blake3_avx2_x86-64_windows_gnu.S; blake3_avx512_x86-64_windows_gnu.S; ); # Clang before 7 needs -mavx512vl to assemble some instructions.; set_source_files_properties(blake3_avx512_x86-64_windows_gnu.S; PROPERTIES COMPILE_OPTIONS ""-mavx512vl""); else(); disable_blake3_x86_simd(); endif(); else(); check_symbol_exists(__x86_64__ """" IS_X64); if (IS_X64 OR CMAKE_OSX_ARCHITECTURES MATCHES ""x86_64""); # In a macOS Universal build (setting CMAKE_OSX_ARCHITECTURES to multiple; # values), compilation of the source files will target multiple architectures; # (each source file is internally compiled once for each architecture).; # To accomodate this configuration we include these assembly files without a; # CMake check but their source is guarded with architecture ""#ifdef"" checks.; list(APPEND LLVM_BLAKE3_FILES; blake3_sse2_x86-64_unix.S; blake3_sse41_x86-64_unix.S; blake3_avx2_x86-64_unix.S; blake3_avx512_x86-64_unix.S; ); # Clang before 7 needs -mavx512vl to assemble some instructions.; set_source_files_properties(blake3_avx512_x86-64_unix.S; PROPERTIES COMPILE_OPTIONS ""-mavx512vl""); else(); disable_blake3_x86_simd(); endif(); endif(); else(); # CAN_USE_ASSEMBLER == FALSE; disable_blake3_x86_simd(); endif(). add_library(LLVMSupportBlake3 OBJECT EXCLUDE_FROM_ALL ${LLVM_BLAKE3_FILES}); llvm_update_compile_flags(LLVMSupportBlake3); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/CMakeLists.txt:1925,config,configuration,1925,interpreter/llvm-project/llvm/lib/Support/BLAKE3/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/CMakeLists.txt,2,['config'],['configuration']
Modifiability,"nerate exactly one call to ``llvm.dbg.declare`` at the point; of declaration of a source variable. Optimization passes that fully promote the; variable from memory to SSA values will replace this call with possibly multiple; calls to `llvm.dbg.value`. Passes that delete stores are effectively partial; promotion, and they will insert a mix of calls to ``llvm.dbg.value`` to track; the source variable value when it is available. After optimization, there may be; multiple calls to ``llvm.dbg.declare`` describing the program points where the; variables lives in memory. All calls for the same concrete source variable must; agree on the memory location. ``llvm.dbg.value``; ^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. void @llvm.dbg.value(metadata, metadata, metadata). This intrinsic provides information when a user source variable is set to a new; value. The first argument is the new value (wrapped as metadata). The second; argument is a `local variable <LangRef.html#dilocalvariable>`_ containing a; description of the variable. The third argument is a `complex expression; <LangRef.html#diexpression>`_. An `llvm.dbg.value` intrinsic describes the *value* of a source variable; directly, not its address. Note that the value operand of this intrinsic may; be indirect (i.e, a pointer to the source variable), provided that interpreting; the complex expression derives the direct value. ``llvm.dbg.assign``; ^^^^^^^^^^^^^^^^^^^; .. toctree::; :hidden:. AssignmentTracking. .. code-block:: llvm. void @llvm.dbg.assign(Value *Value,; DIExpression *ValueExpression,; DILocalVariable *Variable,; DIAssignID *ID,; Value *Address,; DIExpression *AddressExpression). This intrinsic marks the position in IR where a source assignment occurred. It; encodes the value of the variable. It references the store, if any, that; performs the assignment, and the destination address. The first three arguments are the same as for an ``llvm.dbg.value``. The fourth; argument is a ``DIAssignID`` used to reference",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:10521,variab,variable,10521,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"nerated object files and calls a special function; ``__jit_debug_register_code`` that the debugger knows about. When the debugger; attaches to a process, it puts a breakpoint in this function and associates a; special handler with it. Once MCJIT calls the registration function, the; debugger catches the breakpoint signal, loads the new object file from the; inferior's memory and resumes execution. This way it can obtain debug; information for pure in-memory object files. GDB Version; ===========. In order to debug code JIT-ed by LLVM, you need GDB 7.0 or newer, which is; available on most modern distributions of Linux. The version of GDB that; Apple ships with Xcode has been frozen at 6.3 for a while. LLDB Version; ============. Due to a regression in release 6.0, LLDB didn't support JITed code debugging for; a while. The bug was fixed in mainline recently, so that debugging JITed ELF; objects should be possible again from the upcoming release 12.0 on. On macOS the; feature must be enabled explicitly using the ``plugin.jit-loader.gdb.enable``; setting. Debugging MCJIT-ed code; =======================. The emerging MCJIT component of LLVM allows full debugging of JIT-ed code with; GDB. This is due to MCJIT's ability to use the MC emitter to provide full; DWARF debugging information to GDB. Note that lli has to be passed the ``--jit-kind=mcjit`` flag to JIT the code; with MCJIT instead of the newer ORC JIT. Example; -------. Consider the following C code (with line numbers added to make the example; easier to follow):. ..; FIXME:; Sphinx has the ability to automatically number these lines by adding; :linenos: on the line immediately following the `.. code-block:: c`, but; it looks like garbage; the line numbers don't even line up with the; lines. Is this a Sphinx bug, or is it a CSS problem?. .. code-block:: c. 1 int compute_factorial(int n); 2 {; 3 if (n <= 1); 4 return 1;; 5; 6 int f = n;; 7 while (--n > 1); 8 f *= n;; 9 return f;; 10 }; 11; 12; 13 int main(int argc,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DebuggingJITedCode.rst:1887,plugin,plugin,1887,interpreter/llvm-project/llvm/docs/DebuggingJITedCode.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DebuggingJITedCode.rst,1,['plugin'],['plugin']
Modifiability,"neration of binned data in generate(). RooFit will; now automatically generate binned pdf shapes. Binned pdfs shapes are fundamentally RooHistPdf and RooHistFuncs; (with interpolation order set to zero). Products and sums of exclusively binned shapes are also recognized; as binned shapes. For such binned shapes generate() will now by default follow the 'binned' strategy ; -- that is, take the expectation value in each bin and sample a Poisson distribution from that -- rather; than follow the unbinned strategy. The rationale is that such datasets result in much faster likelihood; calculations (for nbin smaller than nevent). The optimization is also exact: the likelihood of a binned ; data using a binned pdf is identical to that of an unbinned dataset with a binned pdf. Nevertheless you can ; switch off this feature by passing AutoBinned(false) to RooAbsPdf::generate(). Mixed binned/unbinned generation from simultaneous pdf. For a RooSimultaneous consisting of exclusively; extended terms it is now possible to generate a mixed binned/unbinned datasets. Components defined; by a binned pdf at the top level are automatically generated binned (unless AutoBinned(false) is set); but it is also possible to generate other component pdfs forcibly binned by adding GenBinned(tagname); to generate(). In that case all component pdfs labeled with pdf->setAttribute(tagname) will be generated; binned. To generate all component binned, the shorthand method AllBinned() can be used. All binned; datasets made by generate are represented as weighted unbinned datasets (of type RooDataSet) rather; than binned datasets of type RooDataHist so that mixed binned/unbinned data is always represented; through a uniform interface. Fix in the optimization strategy of likelihoods constructed from simultaneous pdf. In the parameter; dependency analysis of the components of a simultaneous pdfs parameters originating from 'irrelevant'; constraint terms (i.e. those that don't relate to any of the parameter",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html:5424,extend,extended,5424,roofit/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html,2,['extend'],['extended']
Modifiability,"ness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the content of a n-tuple:; after loading the n-tuple, its branches are assigned to variables and; `GetEntry(long)` automatically fills them with the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file_advanced.C; ```. The `Branch()` function requires a pointer to a variable and a; definition of the variable type. The following table lists some of the possible; values.; Please note that ROOT is not checking the input and mistakes are likely; to result in serious problems. This holds especially if values are read; as another type than they have been written, e.g. when storing a; variable as float and reading it as double. List of variable types that can be used to define the type of a branch in ROOT:. type size C++ identifier; ------------------ -------- --------------- ------------; signed integer 32 bit int I; 64 bit long L; unsigned integer 32 bit unsigned int i; 64 bit unsigned long l; floating point 32 bit float F; 64 bit double D; boolean - bool O. ### Processing N-tuples Spanning over Several Files ###. Usually n-tuples or trees span over many files and it would be difficult; to add them manually. ROOT thus kindly provides a helper class in the; form of `TChain`. Its usage is shown in the following macro which is; very similar to the previou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:5006,variab,variable,5006,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,2,['variab'],['variable']
Modifiability,"new kinds of false positives. We'd like to know about; these, and any other problems you encounter. When you encounter an issue, please file a bug report.; checker-267; built: June 1, 2012; highlights:; Adds basic interprocedural analysis support for blocks.; checker-266; built: May 23, 2012; highlights:; Contains numerous stability fixes over checker-266, especially when analyzing C++11 code.; checker-265; built: May 8, 2012; highlights:; This release contains a fix for a major crasher introduced in checker-264, and various refinements to; improve the precision and reduce the false positive rate of the analyzer. It also enables a new unix.MallocSizeof check, which reports; inconsistencies between the casted type of the return value of a 'malloc/calloc/realloc' call and the operand; of sizeof expressions contained within its argument(s).; checker-264; built: April 26, 2012; highlights:; This release contains misc. bug fixes and performance enhancements over checker-263, including; a reduction of some kinds of false positives related to the malloc() checker.; checker-263; built: March 22, 2012; highlights:. Fixes several serious bugs with inter-procedural analysis, including a case where retain/releases would be ""double-counted"". checker-262; built: March 15, 2012; highlights:. Enables experimental interprocedural analysis (within a file), which greatly amplifies the analyzer's ability to find issues.; Many bug fixes to the malloc/free checker.; Support for new Objective-C NSArray/NSDictionary/NSNumber literals syntax, and Objective-C container subscripting. NOTE: This build contains new interprocedural analysis that allows the analyzer to find more complicated bugs that span function boundaries. It may have problems, performance issues, etc. We'd like to hear about them. checker-261; built: February 22, 2012; highlights:. Contains a new experimental malloc/free checker.; Better support for projects using ARC.; Warns about null pointers passed as arguments to C strin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html:7928,enhance,enhancements,7928,interpreter/llvm-project/clang/www/analyzer/release_notes.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html,2,['enhance'],['enhancements']
Modifiability,"newly introduced tuple-initialization; ```python; myHisto = myTdf.Histo1D(('histName', 'histTitle', 64, 0, 128), 'myColumn'); ```; - Add support for friend trees and chains. Just add the friends before passing the tree/chain to TDataFrame's constructor and refer to friend branches as usual. #### Fixes; - Fixed race condition: concurrent deletion of TTreeReader/TTreeReaderValue; - Fixed reading of c-style arrays from jitted transformations and actions; - Fixed writing of c-style arrays with `Snapshot`; - Improved checks for column name validity (throw if column does not exist and if `Define`d column overrides an already existing column). #### Other changes; - Improved documentation; - TDF now avoids performing virtual calls for parts of the analysis that are not jitted; - Removed ""custom column"" nodes from the internal functional graph therewith optimising its traversal; - Improvements in Cling drastically enhanced scaling and performance of TDF jitted code; - Test coverage has been increased with the introduction of google tests; - Interface change: users must now use TDF::TArrayBranch rather than std::array\_view to specify that the column being read is a c-style array TTree branch; - Interface change: `Min` and `Max` now return results as the same type specified as template parameter, or double if no template parameter was specified. ## Histogram Libraries; - Histogram-based fits are implicitly parallelized.; - Added new options to the histogram fitting interfaces to support explicit parallelization of the fit as well.; - `TF1` gradient evaluation supports vectorization.; - Refactor of `TF1` constructors, default initialization of its data members and fixed ambiguous TF1::operator().; - Extend `TFormula` parsing capabilities.; - The parsing of arguments for defining parametric function is improved. For example a Gaussian function in y can be defined as `gaus( y , [A], [Mean], [Sigma])`.; - One can define the function variables or parameters using another function o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:15335,enhance,enhanced,15335,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['enhance'],['enhanced']
Modifiability,"nfigure the three LLVM configuration header files.; configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/config.h.cmake; ${LLVM_INCLUDE_DIR}/llvm/Config/config.h); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/llvm-config.h.cmake; ${LLVM_INCLUDE_DIR}/llvm/Config/llvm-config.h); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/abi-breaking.h.cmake; ${LLVM_INCLUDE_DIR}/llvm/Config/abi-breaking.h). # Add target for generating source rpm package.; set(LLVM_SRPM_USER_BINARY_SPECFILE ${CMAKE_CURRENT_SOURCE_DIR}/llvm.spec.in; CACHE FILEPATH "".spec file to use for srpm generation""); set(LLVM_SRPM_BINARY_SPECFILE ${CMAKE_CURRENT_BINARY_DIR}/llvm.spec); set(LLVM_SRPM_DIR ""${CMAKE_CURRENT_BINARY_DIR}/srpm""). get_source_info(${CMAKE_CURRENT_SOURCE_DIR} revision repository); string(LENGTH ""${revision}"" revision_length); set(LLVM_RPM_SPEC_REVISION ""${revision}""). configure_file(; ${LLVM_SRPM_USER_BINARY_SPECFILE}; ${LLVM_SRPM_BINARY_SPECFILE} @ONLY). add_custom_target(srpm; COMMAND cpack -G TGZ --config CPackSourceConfig.cmake -B ${LLVM_SRPM_DIR}/SOURCES; COMMAND rpmbuild -bs --define '_topdir ${LLVM_SRPM_DIR}' ${LLVM_SRPM_BINARY_SPECFILE}); set_target_properties(srpm PROPERTIES FOLDER ""Misc""). if(APPLE AND DARWIN_LTO_LIBRARY); set(CMAKE_EXE_LINKER_FLAGS; ""${CMAKE_EXE_LINKER_FLAGS} -Wl,-lto_library -Wl,${DARWIN_LTO_LIBRARY}""); set(CMAKE_SHARED_LINKER_FLAGS; ""${CMAKE_SHARED_LINKER_FLAGS} -Wl,-lto_library -Wl,${DARWIN_LTO_LIBRARY}""); set(CMAKE_MODULE_LINKER_FLAGS; ""${CMAKE_MODULE_LINKER_FLAGS} -Wl,-lto_library -Wl,${DARWIN_LTO_LIBRARY}""); endif(). # Build with _XOPEN_SOURCE on AIX, as stray macros in _ALL_SOURCE mode tend to; # break things. In this case we need to enable the large-file API as well.; if (UNIX AND ${CMAKE_SYSTEM_NAME} MATCHES ""AIX""); add_compile_definitions(_XOPEN_SOURCE=700); add_compile_definitions(_LARGE_FILE_API). # Modules should be built with -shared -Wl,-G, so we can use runtime linking; # with plugins.; string(APPEND CMAKE_MODULE_LINKER_FLAGS "" ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:45819,config,config,45819,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['config'],['config']
Modifiability,"nformation to be directly accessible at runtime. There is also no need; at runtime for any logic intended to compute human-readable presentation of; information, such as C++ symbol demangling. Instead, logging must include markup; elements that give the contextual information necessary to make sense of the raw; data, such as memory layout details. This format identifies markup elements with a syntax that is both simple and; distinctive. It's simple enough to be matched and parsed with straightforward; code. It's distinctive enough that character sequences that look like the start; or end of a markup element should rarely if ever appear incidentally in logging; text. It's specifically intended not to require sanitizing plain text, such as; the HTML/XML requirement to replace ``<`` with ``&lt;`` and the like. :doc:`llvm-symbolizer <CommandGuide/llvm-symbolizer>` includes a symbolizing; filter via its ``--filter-markup`` option. Also, LLVM utilites emit stack; traces as markup when the ``LLVM_ENABLE_SYMBOLIZER_MARKUP`` environment; variable is set. Scope and assumptions; =====================. A symbolizing filter implementation will be independent both of the target; operating system and machine architecture where the logs are generated and of; the host operating system and machine architecture where the filter runs. This format assumes that the symbolizing filter processes intact whole lines. If; long lines might be split during some stage of a logging pipeline, they must be; reassembled to restore the original line breaks before feeding lines into the; symbolizing filter. Most markup elements must appear entirely on a single line; (often with other text before and/or after the markup element). There are some; markup elements that are specified to span lines, with line breaks in the middle; of the element. Even in those cases, the filter is not expected to handle line; breaks in arbitrary places inside a markup element, but only inside certain; fields. This format as",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:1949,variab,variable,1949,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,1,['variab'],['variable']
Modifiability,"nfortunately, using GDB with dynamically loaded passes is not as easy as it; should be. First of all, you can't set a breakpoint in a shared object that; has not been loaded yet, and second of all there are problems with inlined; functions in shared objects. Here are some suggestions to debugging your pass; with GDB. For sake of discussion, I'm going to assume that you are debugging a; transformation invoked by :program:`opt`, although nothing described here; depends on that. Setting a breakpoint in your pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. First thing you do is start gdb on the opt process:. .. code-block:: console. $ gdb opt; GNU gdb 5.0; Copyright 2000 Free Software Foundation, Inc.; GDB is free software, covered by the GNU General Public License, and you are; welcome to change it and/or distribute copies of it under certain conditions.; Type ""show copying"" to see the conditions.; There is absolutely no warranty for GDB. Type ""show warranty"" for details.; This GDB was configured as ""sparc-sun-solaris2.6""...; (gdb). Note that :program:`opt` has a lot of debugging information in it, so it takes; time to load. Be patient. Since we cannot set a breakpoint in our pass yet; (the shared object isn't loaded until runtime), we must execute the process,; and have it stop before it invokes our pass, but after it has loaded the shared; object. The most foolproof way of doing this is to set a breakpoint in; ``PassManager::run`` and then run the process with the arguments you want:. .. code-block:: console. $ (gdb) break llvm::PassManager::run; Breakpoint 1 at 0x2413bc: file Pass.cpp, line 70.; (gdb) run test.bc -load $(LLVMTOP)/llvm/Debug+Asserts/lib/[libname].so -[passoption]; Starting program: opt test.bc -load $(LLVMTOP)/llvm/Debug+Asserts/lib/[libname].so -[passoption]; Breakpoint 1, PassManager::run (this=0xffbef174, M=@0x70b298) at Pass.cpp:70; 70 bool PassManager::run(Module &M) { return PM->run(M); }; (gdb). Once the :program:`opt` stops in the ``PassManager::run`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:53063,config,configured,53063,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['config'],['configured']
Modifiability,"nfrastructure comprises RooAbsCached; the base class for all caching p.d.fs, RooAbsSelfCachedPdf a base class for end-user; caching p.d.f implementations that simply cache the result of evaluate() and RooCachedPdf; that can wrap and cache any input p.d.f specified in its constructor. . By default a p.d.f is sampled and cached in all observables in any; given use context, with no need to specify what those are in advance.; The internal code has also been changed such that all cache; histograms now store pre-normalized p.d.f, which is more efficient; than 'raw' p.d.f histograms that are explicitly post-normalized; through integration. Multiple different use cases (e.g. definitions; of what are observables vs parameters) can be cached; simultaneously. Now it is also possible to specify that p.d.f.s; should be sampled and cached in one or more parameter dimensions; in addition to the automatically determined set of observables.; as well. Also a complete new line of classes with similar functionality has been added inheriting from RooAbsReal.; These are RooAbsCachedReal,RooAbsSelfCachedReal and RooCachedReal. A newly; added class RooHistFunc presents these shapes and is capable of handling negative entries. New PDF error handling structure. New infrastructure has been put into place to propagate and process p.d.f evaluation errors during fitting.; Previously evaluation errors were marked with a zero p.d.f value and propagated as a special condition; in RooAddPdf, RooProdPdf etc to result in a zero top-level p.d.f value that was caught by the RooFit minuit; interface as a special condition. Summary information on the value of the parameters and the observables; was printed for the first 10 occurrences of such conditions. . Now, each p.d.f component that generates an error; in its evaluation logs the error into a separate facility during fitting and the RooFit minuit interface; polls this error logging facility for problems. This allows much more detailed and accurate warn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:14784,inherit,inheriting,14784,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,2,['inherit'],['inheriting']
Modifiability,"ng 2.9. Range-based for; N2930; Clang 3.0. P0962R1 (DR); Clang 8. Explicit virtual overrides; N2928; N3206; N3272; Clang 3.0. Minimal support for garbage collection and reachability-based leak detection; N2670; N/A (2). Allowing move constructors to throw [noexcept]; N3050; Clang 3.0. Defining move special member functions; N3053; Clang 3.0. Concurrency. Sequence points; N2239; Clang 3.3. Atomic operations; N2427; Clang 3.1. Strong Compare and Exchange; N2748; Clang 3.1 (3). Bidirectional Fences; N2752; Clang 3.1. Memory model; N2429; Clang 3.2. Data-dependency ordering: atomics and memory model; N2664; Clang 3.2 (4). Propagating exceptions; N2179; Clang 2.9. Allow atomics use in signal handlers; N2547; Clang 3.1. Thread-local storage; N2659; Clang 3.3 (5). Dynamic initialization and destruction with concurrency; N2660; Clang 2.9. C99 Features in C++11. __func__ predefined identifier; N2340; Clang 2.9. C99 preprocessor; N1653; Clang 2.9. long long; N1811; Clang 2.9. Extended integral types; N1988; N/A (6). (1): The [[carries_dependency]] attribute; has no effect.; (2): No compiler changes are required for an implementation; such as Clang that does not provide garbage collection.; (3): All compare-exchange operations are emitted as; strong compare-exchanges.; (4): memory_order_consume is lowered to; memory_order_acquire.; (5): thread_local support; requires a C++ runtime library providing __cxa_thread_atexit, such; as libc++abi 3.6 or later,; or libsupc++ 4.8 or later.; (6): No compiler changes are required for an implementation; such as Clang that does not provide any extended integer types.; __int128 is not treated as an extended integer type,; because changing intmax_t would be an ABI-incompatible; change. C++98 implementation status; Clang implements all of the ISO C++ 1998 standard; (including the defects addressed in the ISO C++ 2003 standard); except for export (which was removed in C++11). Defect reports; Clang generally aims to implement resolutions to Defect",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:18145,Extend,Extended,18145,interpreter/llvm-project/clang/www/cxx_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html,1,['Extend'],['Extended']
Modifiability,ng 3.9. 1942; CD4; Incorrect reference to trailing-return-type; Unknown. 1943; CD5; Unspecified meaning of “bit”; Unknown. 1944; open; New C incompatibilities; Not resolved. 1945; open; Friend declarations naming members of class templates in non-templates; Not resolved. 1946; CD4; exception-specifications vs pointer dereference; Unknown. 1947; NAD; Digit separators following non-octal prefix; Clang 3.5. 1948; NAD; exception-specification of replacement global new; Clang 3.5. 1949; CD4; “sequenced after” instead of “sequenced before”; Unknown. 1950; NAD; Restructuring description of ranks of conversion sequences; Unknown. 1951; CD4; Cv-qualification and literal types; Unknown. 1952; CD4; Constant expressions and library undefined behavior; Unknown. 1953; open; Data races and common initial sequence; Not resolved. 1954; tentatively ready; typeid null dereference check in subexpressions; Unknown. 1955; CD4; #elif with invalid controlling expression; Unknown. 1956; CD4; Reuse of storage of automatic variables; Unknown. 1957; NAD; decltype(auto) with direct-list-initialization; Unknown. 1958; CD4; decltype(auto) with parenthesized initializer; Unknown. 1959; CD4; Inadvertently inherited copy constructor; Clang 3.9. 1960; NAD; Visibility of entity named in class-scope using-declaration; No. 1961; C++17; Potentially-concurrent actions within a signal handler; Unknown. 1962; open; Type of __func__; Not resolved. 1963; CD4; Implementation-defined identifier characters; Unknown. 1964; NAD; opaque-enum-declaration in alias-declaration?; Unknown. 1965; drafting; Explicit casts to reference types; Not resolved. 1966; CD4; Colon following enumeration elaborated-type-specifier; Clang 11. 1967; CD4; Temporary lifetime and move-elision; Unknown. 1968; NAD; Address of typeid in constant expressions; No. 1969; CD6; Missing exclusion of ~S as an ordinary function name; Unknown. 1970; NAD; Ambiguity resolution for (T())*x; Unknown. 1971; CD4; Unclear disambiguation of destructor and ope,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:132873,variab,variables,132873,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['variab'],['variables']
Modifiability,ng 7. 1673; C++14; Clarifying overload resolution for the second step of copy-initialization; Unknown. 1674; C++14; Return type deduction for address of function; Unknown. 1675; NAD; Size limit for automatic array object; Unknown. 1676; drafting; auto return type for allocation and deallocation functions; Not resolved. 1677; C++17; Constant initialization via aggregate initialization; Unknown. 1678; NAD; Naming the type of an array of runtime bound; Unknown. 1679; NAD; Range-based for and array of runtime bound; Unknown. 1680; drafting; Including <initializer_list> for range-based for; Not resolved. 1681; C++14; init-captures and nested lambdas; Unknown. 1682; open; Overly-restrictive rules on function templates as allocation functions; Not resolved. 1683; CD4; Incorrect example after constexpr changes; Unknown. 1684; C++14; Static constexpr member functions for non-literal classes; Clang 3.6. 1685; NAD; Value category of noexcept expression; Unknown. 1686; CD4; Which variables are “explicitly declared const?”; Unknown. 1687; C++14; Conversions of operands of built-in operators; Clang 7. 1688; NAD; Volatile constexpr variables; Unknown. 1689; C++14; Syntactic nonterminal for operand of alignas; Unknown. 1690; C++14; Associated namespace for local type; Clang 9. 1691; C++14; Argument-dependent lookup and opaque enumerations; Clang 9. 1692; C++14; Associated namespaces of doubly-nested classes; Clang 9. 1693; C++14; Superfluous semicolons in class definitions; Unknown. 1694; CD4; Restriction on reference to temporary as a constant expression; Unknown. 1695; NAD; Lifetime extension via init-capture; Unknown. 1696; CD4; Temporary lifetime and non-static data member initializers; Clang 7. 1697; CD4; Lifetime extension and copy elision; Unknown. 1698; DR; Files ending in \; Unknown. 1699; open; Does befriending a class befriend its friends?; Not resolved. 1700; NAD; Does the special rvalue-reference deduction apply to alias templates?; Unknown. 1701; drafting; Array vs se,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:114096,variab,variables,114096,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['variab'],['variables']
Modifiability,"ng Cephes function.; TMath::Prob (the upper chi2 probability) is implemented also using ROOT::Math::chisquared_cdf_c which uses ROOT::Math::inc_gamma_c based on a corresponding Cephes function. Now the implementation does not suffer anymore from large numerical error present when the result of TMath::Prob was approaching zero.; TMath::LnGamma(z) is implemented using ROOT::Math::lgamma. This affects also TMath::Beta which is implemented using the log of the gamma function.; TMath::BetaIncomplete is implemented using ROOT::Math::beta_inc.; TMath::GammaDist is implemented using ROOT::Math::gamma_pdf.; TMath::LogNormal is implemented using ROOT::Math::lognormal_pdf.; TMath::PoissonI: fixed a problem for large values and is implemented using directly TMath::Poisson with integer values. Fit; Mathcore include now new classes for performing fits and minimization of multi-dimensional functions. The aim of these classes is to extend and improve the fitting functionality provided in ROOT via the TVirtualFitter classes and the fitting methods present in many data analysis object, such as TH1::Fit.; ; The fit data are decoupled from the fitter class and described by the dedicated fit data classes like the ROOT::Fit::BinData for bin data containing coordinate values of any dimensions, bin content values and optionally errors in coordinate and bin content, and ROOT::Fit::UnBinData classes for any dimension un-bin data.; The fitter class, ROOT::Fit::Fitter, provides the functionality for fitting those data with any model function implementing the parametric function interface, ROOT::Math::IParamMultiFunction. Fit methods such as least square, bin and un-bin likelihood are supported. The fit solution is then found by using the ROOT::Math::Minimizer interface class and the results are stored in the ROOT::Fit::FitResult class. Fit parameter can be configured individually using the ROOT::Fit::FitParameterSettings class.; ; Various implementation of the minimizer interface can be used a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:4123,extend,extend,4123,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['extend'],['extend']
Modifiability,"ng WebAssembly applications that use the WASI ABI. Rust provides WebAssembly support integrated into Cargo. There are two; main options:; - wasm32-unknown-unknown, which provides a relatively minimal environment; that has an emphasis on being ""native""; - wasm32-unknown-emscripten, which uses Emscripten internally and; provides standard C/C++ libraries, filesystem emulation, GL and SDL; bindings; For more information, see:; * https://www.hellorust.com/. The following documents contain some information on the semantics and binary; encoding of WebAssembly itself:; * https://github.com/WebAssembly/design/blob/main/Semantics.md; * https://github.com/WebAssembly/design/blob/main/BinaryEncoding.md. Some notes on ways that the generated code could be improved follow:. //===---------------------------------------------------------------------===//. Br, br_if, and br_table instructions can support having a value on the value; stack across the jump (sometimes). We should (a) model this, and (b) extend; the stackifier to utilize it. //===---------------------------------------------------------------------===//. The min/max instructions aren't exactly a<b?a:b because of NaN and negative zero; behavior. The ARM target has the same kind of min/max instructions and has; implemented optimizations for them; we should do similar optimizations for; WebAssembly. //===---------------------------------------------------------------------===//. AArch64 runs SeparateConstOffsetFromGEPPass, followed by EarlyCSE and LICM.; Would these be useful to run for WebAssembly too? Also, it has an option to; run SimplifyCFG after running the AtomicExpand pass. Would this be useful for; us too?. //===---------------------------------------------------------------------===//. Register stackification uses the VALUE_STACK physical register to impose; ordering dependencies on instructions with stack operands. This is pessimistic;; we should consider alternate ways to model stack dependencies. //===--------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt:1739,extend,extend,1739,interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt,2,['extend'],['extend']
Modifiability,"ng instructions. The _CONVERGENT variant corresponds to an LLVM IR intrinsic marked `convergent`. .. note::. Unlike SelectionDAG, there is no _VOID variant. Both of these are permitted; to have zero, one, or multiple results. Variadic Arguments; ------------------. G_VASTART; ^^^^^^^^^. .. caution::. I found no documentation for this instruction at the time of writing. G_VAARG; ^^^^^^^. .. caution::. I found no documentation for this instruction at the time of writing. Other Operations; ----------------. G_DYN_STACKALLOC; ^^^^^^^^^^^^^^^^. Dynamically realigns the stack pointer to the specified size and alignment.; An alignment value of `0` or `1` means no specific alignment. .. code-block:: none. %8:_(p0) = G_DYN_STACKALLOC %7(s64), 32. Optimization Hints; ------------------. These instructions do not correspond to any target instructions. They act as; hints for various combines. G_ASSERT_SEXT, G_ASSERT_ZEXT; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This signifies that the contents of a register were previously extended from a; smaller type. The smaller type is denoted using an immediate operand. For scalars, this is the; width of the entire smaller type. For vectors, this is the width of the smaller; element type. .. code-block:: none. %x_was_zexted:_(s32) = G_ASSERT_ZEXT %x(s32), 16; %y_was_zexted:_(<2 x s32>) = G_ASSERT_ZEXT %y(<2 x s32>), 16. %z_was_sexted:_(s32) = G_ASSERT_SEXT %z(s32), 8. G_ASSERT_SEXT and G_ASSERT_ZEXT act like copies, albeit with some restrictions. The source and destination registers must. - Be virtual; - Belong to the same register class; - Belong to the same register bank. It should always be safe to. - Look through the source register; - Replace the destination register with the source register. Miscellaneous; -------------. G_CONSTANT_FOLD_BARRIER; ^^^^^^^^^^^^^^^^^^^^^^^. This operation is used as an opaque barrier to prevent constant folding. Combines; and other transformations should not look through this. These have no other; semantics and ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst:21849,extend,extended,21849,interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,1,['extend'],['extended']
Modifiability,"ng link-time to determine; which COMDAT groups get selected depending on the selection kind.; Because the name of the object must match the name of the COMDAT group, the; linkage of the global object must not be local; local symbols can get renamed; if a collision occurs in the symbol table. The combined use of COMDATS and section attributes may yield surprising results.; For example:. .. code-block:: llvm. $foo = comdat any; $bar = comdat any; @g1 = global i32 42, section ""sec"", comdat($foo); @g2 = global i32 42, section ""sec"", comdat($bar). From the object file perspective, this requires the creation of two sections; with the same name. This is necessary because both globals belong to different; COMDAT groups and COMDATs, at the object file level, are represented by; sections. Note that certain IR constructs like global variables and functions may; create COMDATs in the object file in addition to any which are specified using; COMDAT IR. This arises when the code generator is configured to emit globals; in individual sections (e.g. when `-data-sections` or `-function-sections`; is supplied to `llc`). .. _namedmetadatastructure:. Named Metadata; --------------. Named metadata is a collection of metadata. :ref:`Metadata; nodes <metadata>` (but not metadata strings) are the only valid; operands for a named metadata. #. Named metadata are represented as a string of characters with the; metadata prefix. The rules for metadata names are the same as for; identifiers, but quoted names are not allowed. ``""\xx""`` type escapes; are still valid, which allows any character to be part of a name. Syntax::. ; Some unnamed metadata nodes, which are referenced by the named metadata.; !0 = !{!""zero""}; !1 = !{!""one""}; !2 = !{!""two""}; ; A named metadata.; !name = !{!0, !1, !2}. .. _paramattrs:. Parameter Attributes; --------------------. The return type and each parameter of a function type may have a set of; *parameter attributes* associated with them. Parameter attributes are; used ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:48816,config,configured,48816,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['config'],['configured']
Modifiability,"ng of; the <proof.conf> file via the keyword; 'reload:1'/'reload:0'; in the xpd.resource directive.; Move the validation of <proof.conf> at the; moment of use; this allows to specify a file path and to dynamically; create/modify/destroy the file; used by PoD.; Improve displaying speed of large log files. Fixes. Fix two severe; bugs in the way TTreeCache; was used in PROOF: one bug was de facto disactivating the cache; the; other was causing a std::bad_alloc exception to be thrown on workers; when opening a remote file after a local one.    ; Fix several problems in TChain::Draw including. drawing into an existing histogram, i.e.; chain->Draw(""var>>myhist"");. treatment of histogram merging in case of small; statistics, i.e. when; the autobinning is not or only partially active;. usage of existing canvases when different histogram; names are specified;. Fix a problem causing a duplication of the final feedback; object. Fix problem with determining the subdir name in; TFileMerger::MergeRecursive on Windows; Make sure that the default sandbox is under $HOME/.proof; Fix a problem with dataset validation in multi-level; master setups; Fix a problem with ordinal numbers in multi-master setups; Fix a problem with defining the internal paths for; executables when configuring with '--prefix'; Fix backward-incompatibility issue giving the error; message  ""unknown action code: 5112""; Fix a few problems with file retrieval from the cache; Fix a problem with iteration of a std::list occasionally; causing seg-violations in TXSocket; Fix a few problems preventing correct usage of entry; lists in PROOF; Fix a problem with the permissions of the credentials; files created under <sandbox>/.creds; Fix a potential problem while determining the log paths; in log retrieval. Do not use vnsprintf in the XrdProofd plug-in, potential; source of deadlocks.; Fix a problem overwriting the local environment settings; for the xrootd sec modules; In XrdProofdProofServMgr::Destroy, fix segv in messag",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:9381,sandbox,sandbox,9381,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,2,['sandbox'],['sandbox']
Modifiability,"ng or a list. Rather oddly, but consistent with the; previous case, if the *right-hand-side* operand is an undefined name or a; global name, it is treated as a verbatim string of characters. The; left-hand-side operand is treated normally. Values can have a trailing paste operator, in which case the left-hand-side ; operand is concatenated to an empty string. `Appendix B: Paste Operator Examples`_ presents examples of the behavior of; the paste operator. Statements; ==========. The following statements may appear at the top level of TableGen source; files. .. productionlist::; TableGenFile: (`Statement` | `IncludeDirective`; :| `PreprocessorDirective`)*; Statement: `Assert` | `Class` | `Def` | `Defm` | `Defset` | `Defvar`; :| `Dump` | `Foreach` | `If` | `Let` | `MultiClass`. The following sections describe each of these top-level statements. ``class`` --- define an abstract record class; ---------------------------------------------. A ``class`` statement defines an abstract record class from which other; classes and records can inherit. .. productionlist::; Class: ""class"" `ClassID` [`TemplateArgList`] `RecordBody`; TemplateArgList: ""<"" `TemplateArgDecl` ("","" `TemplateArgDecl`)* "">""; TemplateArgDecl: `Type` `TokIdentifier` [""="" `Value`]. A class can be parameterized by a list of ""template arguments,"" whose values; can be used in the class's record body. These template arguments are; specified each time the class is inherited by another class or record. If a template argument is not assigned a default value with ``=``, it is; uninitialized (has the ""value"" ``?``) and must be specified in the template; argument list when the class is inherited (required argument). If an; argument is assigned a default value, then it need not be specified in the; argument list (optional argument). In the declaration, all required template; arguments must precede any optional arguments. The template argument default; values are evaluated from left to right. The :token:`RecordBody` is de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:21819,inherit,inherit,21819,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inherit']
Modifiability,"ng plugins. Once you're ready to switch to using gold, backup your existing; ``/usr/bin/ld`` then replace it with ``ld-new``. Alternatively, install; in ``/usr/bin/ld.gold`` and use ``-fuse-ld=gold`` as described earlier. Optionally, add ``--enable-gold=default`` to the above configure invocation; to automatically install the newly built gold as the default linker with; ``make install``. * Build the LLVMgold plugin. Run CMake with; ``-DLLVM_BINUTILS_INCDIR=/path/to/binutils/include``. The correct include; path will contain the file ``plugin-api.h``. Usage; =====. You should produce bitcode files from ``clang`` with the option; ``-flto``. This flag will also cause ``clang`` to look for the gold plugin in; the ``lib`` directory under its prefix and pass the ``-plugin`` option to; ``ld``. It will not look for an alternate linker without ``-fuse-ld=gold``,; which is why you otherwise need gold to be the installed system linker in; your path. ``ar`` and ``nm`` also accept the ``-plugin`` option and it's possible to; to install ``LLVMgold.so`` to ``/usr/lib/bfd-plugins`` for a seamless setup.; If you built your own gold, be sure to install the ``ar`` and ``nm-new`` you; built to ``/usr/bin``. Example of link time optimization; ---------------------------------. The following example shows a worked example of the gold plugin mixing LLVM; bitcode and native code. .. code-block:: c. --- a.c ---; #include <stdio.h>. extern void foo1(void);; extern void foo4(void);. void foo2(void) {; printf(""Foo2\n"");; }. void foo3(void) {; foo4();; }. int main(void) {; foo1();; }. --- b.c ---; #include <stdio.h>. extern void foo2(void);. void foo1(void) {; foo2();; }. void foo4(void) {; printf(""Foo4"");; }. .. code-block:: bash. --- command lines ---; $ clang -flto a.c -c -o a.o # <-- a.o is LLVM bitcode file; $ ar q a.a a.o # <-- a.a is an archive with LLVM bitcode; $ clang b.c -c -o b.o # <-- b.o is native object file; $ clang -flto a.a b.o -o main # <-- link with LLVMgold plugin. Gold info",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:3492,plugin,plugin,3492,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['plugin'],['plugin']
Modifiability,"ng pointers to objects as one-element arrays; Unknown. 2420; dup; Exception specifications in explicit instantiation; Unknown. 2421; drafting; Explicit instantiation of constrained member functions; Not resolved. 2422; C++20; Incorrect grammar for deduction-guide; Unknown. 2423; NAD; Typedefs, names, and entities; Unknown. 2424; C++20; constexpr initialization requirements for variant members; Unknown. 2425; open; Confusing wording for deduction from a type; Not resolved. 2426; C++20; Reference to destructor that cannot be invoked; Unknown. 2427; C++20; Deprecation of volatile operands and unevaluated contexts; Unknown. 2428; C++23; Deprecating a concept; Unknown. 2429; C++20; Initialization of thread_local variables referenced by lambdas; Unknown. 2430; C++20; Completeness of return and parameter types of member functions; Unknown. 2431; C++20; Full-expressions and temporaries bound to references; Unknown. 2432; C++20; Return types for defaulted <=>; Unknown. 2433; C++20; Variable templates in the ODR; Unknown. 2434; open; Mandatory copy elision vs non-class objects; Not resolved. 2435; open; Alias template specializations; Not resolved. 2436; C++20; Copy semantics of coroutine parameters; Unknown. 2437; C++20; Conversion of std::strong_ordering in a defaulted operator<=>; Unknown. 2438; open; Problems in the specification of qualification conversions; Not resolved. 2439; C++20; Undefined term in definition of “usable in constant expressions”; Unknown. 2440; C++23; Allocation in core constant expressions; Unknown. 2441; C++20; Inline function parameters; Unknown. 2442; C++20; Incorrect requirement for default arguments; Unknown. 2443; C++23; Meaningless template exports; Unknown. 2444; drafting; Constant expressions in initialization odr-use; Not resolved. 2445; C++20; Partial ordering with rewritten candidates; Unknown. 2446; C++20; Questionable type-dependency of concept-ids; Unknown. 2447; C++20; Unintended description of abbreviated function templates; Unknown. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:166536,Variab,Variable,166536,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Variab'],['Variable']
Modifiability,"ng rendered into. It also is much better optimized for; sessions where the user is forwarding X11 windows through an `ssh` connection. For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; and COLZ options. There is one major difference and that concerns the treatment of; bins with zero content. The COL2 and COLZ2 options color these bins the color of zero. This has been implemented by Jeromy Tompkins <Tompkins@nscl.msu.edu>. ## Geometry Libraries; A new module geom/vecgeom was introduced to give transparent access to VecGeom ; solid primitives. VecGeom is a high performance geometry package (link) providing ; SIMD vectorization for the CPU-intensive geometry algorithms used for geometry; navigation. The module creates a new library libConverterVG.so depending on the; VecGeom main library and loaded using the ROOT plug-in mechanism. The main functionality provided by the new vecgeom module is to make a conversion ; in memory of all the shapes in a loaded TGeo geometry into a special adapter; shape TGeoVGShape, redirecting all navigation calls to the corresponding VecGeom ; solid. The library loading and geometry conversion can be done with a single call ; `TVirtualGeoConverter::Instance()->ConvertGeometry()`; . After the conversion is done, all existing TGeo functionality is available as for; a native geometry, only that most of the converted solids provide better navigation ; performance, despite the overhead introduced by the new adapter shape. Prerequisites: installation of VecGeom. ; The installation instructions are available at <http://geant.web.cern.ch/content/installation>; Due to the fact that VecGeom provides for the moment static libraries ; and depends on ROOT, is is advised to compile first ROOT without VecGeom support, ; then compile VecGeom against this ROOT version, then re-configure ROOT to enable ; VecGeom and Vc support, using the flags -Dvc=ON -Dvecgeom=on; ; This has been implemented by Mihaela Gheata <Mihaela.Gheat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:23592,adapt,adapter,23592,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['adapt'],['adapter']
Modifiability,"ng that a call instruction is longer than one byte on all; supported machines, applying the ""subtract one byte"" adjustment a second time; still results in an address somewhere in the call instruction, so a little; sloppiness here often does little or no harm. Examples::. {{{bt:0:0x12345678:pc}}}; {{{bt:1:0xffffffff9abcdef0:ra}}}. ``{{{hexdict:...}}}`` [#not_yet_implemented]_. This element can span multiple lines. Here ``...`` is a sequence of key-value; pairs where a single ``:`` separates each key from its value, and arbitrary; whitespace separates the pairs. The value (right-hand side) of each pair; either is one or more ``0`` digits, or is ``0x`` followed by hexadecimal; digits. Each value might be a memory address or might be some other integer; (including an integer that looks like a likely memory address but actually has; an unrelated purpose). When the contextual information about the memory layout; suggests that a given value could be a code location or a global variable data; address, it might be presented as a source location or variable name or with; active UI that makes such interpretation optionally visible. The intended use is for things like register dumps, where the emitter doesn't; know which values might have a symbolic interpretation but a presentation that; makes plausible symbolic interpretations available might be very useful to; someone reading the log. At the same time, a flat text presentation should; usually avoid interfering too much with the original contents and formatting; of the dump. For example, it might use footnotes with source locations for; values that appear to be code locations. An active UI presentation might show; the dump text as is, but highlight values with symbolic information available; and pop up a presentation of symbolic details when a value is selected. Example::. {{{hexdict:; CS: 0 RIP: 0x6ee17076fb80 EFL: 0x10246 CR2: 0; RAX: 0xc53d0acbcf0 RBX: 0x1e659ea7e0d0 RCX: 0 RDX: 0x6ee1708300cc; RSI: 0 RDI: 0x6ee170830040 R",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:14094,variab,variable,14094,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,2,['variab'],['variable']
Modifiability,"ng the approach (2) - it should be possible to avoid; performance overhead, and clarity seems nice. **Gabor:**. At this point, I am a bit wondering about two questions. * When should something belong to a checker and when should something belong to the engine?; Sometimes we model library aspects in the engine and model language constructs in checkers. * What is the checker programming model that we are aiming for? Maximum freedom or more easy checker development?. I think if we aim for maximum freedom, we do not need to worry about the; potential stress on checkers, and we can introduce abstractions to mitigate that; later on.; If we want to simplify the API, then maybe it makes more sense to move language; construct modeling to the engine when the checker API is not sufficient instead; of complicating the API. Right now I have no preference or objections between the alternatives but there; are some random thoughts:. * Maybe it would be great to have a guideline how to evolve the analyzer and; follow it, so it can help us to decide in similar situations. * I do care about performance in this case. The reason is that we have a; limited performance budget. And I think we should not expect most of the checker; writers to add modeling of language constructs. So, in my opinion, it is ok to; have less nice/more verbose API for language modeling if we can have better; performance this way, since it only needs to be done once, and is done by the; framework developers. **Artem:** These are some great questions, i guess it'd be better to discuss; them more openly. As a quick dump of my current mood:. * To me it seems obvious that we need to aim for a checker API that is both; simple and powerful. This can probably by keeping the API as powerful as; necessary while providing a layer of simple ready-made solutions on top of it.; Probably a few reusable components for assembling checkers. And this layer; should ideally be pleasant enough to work with, so that people would prefer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:5516,evolve,evolve,5516,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['evolve'],['evolve']
Modifiability,"ng the starting point \f$\vec{r_0}\f$; and direction \f$\vec{n_0}\f$ .; There are several ways of doing that. \anchor GP02a; ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ~~~{.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ~~~. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ~~~{.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ~~~. A navigator holds several variables describing the current navigation; state: current point position, current direction distance to next; boundary, isotropic safety, pointer to current and next nods as well as; several tracking flags related to volume boundary conditions or other; properties required for track propagation in geometry. Each geometry; query affects these variables, so the only way in testing several; navigation alternatives and remembering the active navigation state is; to use parallel navigation. The following paragraphs will describe the; usage of a single navigator. All setters/getters for navigation state; parameters as well as navigation queries provided by TGeoNavigator; are interfaced by TGeoManager and will act on the current; navigator. \anchor GP02b; ### Initializing the Starting Point. The current point (`x,y,z`) known by the modeller is stored as; `Double_t fCurrentPoint[3]` by the navigator class. This array of the; three coordinates is defined in the current global reference system and; can be retrieved any time:. ~~~{.cpp}; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; ~~~. Initializing this point can be don",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:63616,variab,variables,63616,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['variab'],['variables']
Modifiability,"ng type are discarded. Note that if discarding; the low order bits leads to an all-0 payload, this cannot be represented as a; signaling NaN (it would represent an infinity instead), so in that case; ""Unchanged NaN propagation"" is not possible. Example:; """""""""""""""". .. code-block:: llvm. %X = fptrunc double 16777217.0 to float ; yields float:16777216.0; %Y = fptrunc double 1.0E+300 to half ; yields half:+infinity. '``fpext .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fpext <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``fpext``' extends a floating-point ``value`` to a larger floating-point; value. Arguments:; """""""""""""""""""". The '``fpext``' instruction takes a :ref:`floating-point <t_floating>`; ``value`` to cast, and a :ref:`floating-point <t_floating>` type to cast it; to. The source type must be smaller than the destination type. Semantics:; """""""""""""""""""". The '``fpext``' instruction extends the ``value`` from a smaller; :ref:`floating-point <t_floating>` type to a larger :ref:`floating-point; <t_floating>` type. The ``fpext`` cannot be used to make a; *no-op cast* because it always changes bits. Use ``bitcast`` to make a; *no-op cast* for a floating-point cast. NaN values follow the usual :ref:`NaN behaviors <floatnan>`, except that _if_ a; NaN payload is propagated from the input (""Quieting NaN propagation"" or; ""Unchanged NaN propagation"" cases), then it is copied to the high order bits of; the resulting payload, and the remaining low order bits are zero. Example:; """""""""""""""". .. code-block:: llvm. %X = fpext float 3.125 to double ; yields double:3.125000e+00; %Y = fpext double %X to fp128 ; yields fp128:0xL00000000000000004000900000000000. '``fptoui .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fptoui <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``fptoui``' converts a floating-point ``value`` to its unsigned; integer equivalent of type ``ty2``. Arguments:;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:447515,extend,extends,447515,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['extend'],['extends']
Modifiability,"ng** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <DeriveLineEnding>`; This option is **deprecated**. See ``DeriveLF`` and ``DeriveCRLF`` of; ``LineEnding``. .. _DerivePointerAlignment:. **DerivePointerAlignment** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DerivePointerAlignment>`; If ``true``, analyze the formatted file for the most common; alignment of ``&`` and ``*``.; Pointer and reference alignment styles are going to be updated according; to the preferences found in the file.; ``PointerAlignment`` is then used only as fallback. .. _DisableFormat:. **DisableFormat** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DisableFormat>`; Disables formatting completely. .. _EmptyLineAfterAccessModifier:. **EmptyLineAfterAccessModifier** (``EmptyLineAfterAccessModifierStyle``) :versionbadge:`clang-format 13` :ref:`¶ <EmptyLineAfterAccessModifier>`; Defines when to put an empty line after access modifiers.; ``EmptyLineBeforeAccessModifier`` configuration handles the number of; empty lines between two access modifiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:60828,config,configuration,60828,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,ng-tools-extra/clang-tidy/performance/NoexceptMoveConstructorCheck.cpp; clang-tools-extra/clang-tidy/performance/NoexceptMoveConstructorCheck.h; clang-tools-extra/clang-tidy/performance/NoIntToPtrCheck.cpp; clang-tools-extra/clang-tidy/performance/NoIntToPtrCheck.h; clang-tools-extra/clang-tidy/performance/PerformanceTidyModule.cpp; clang-tools-extra/clang-tidy/performance/TriviallyDestructibleCheck.cpp; clang-tools-extra/clang-tidy/performance/TriviallyDestructibleCheck.h; clang-tools-extra/clang-tidy/performance/TypePromotionInMathFnCheck.cpp; clang-tools-extra/clang-tidy/performance/TypePromotionInMathFnCheck.h; clang-tools-extra/clang-tidy/performance/UnnecessaryCopyInitialization.cpp; clang-tools-extra/clang-tidy/performance/UnnecessaryValueParamCheck.cpp; clang-tools-extra/clang-tidy/performance/UnnecessaryValueParamCheck.h; clang-tools-extra/clang-tidy/plugin/ClangTidyPlugin.cpp; clang-tools-extra/clang-tidy/portability/PortabilityTidyModule.cpp; clang-tools-extra/clang-tidy/portability/RestrictSystemIncludesCheck.cpp; clang-tools-extra/clang-tidy/portability/SIMDIntrinsicsCheck.cpp; clang-tools-extra/clang-tidy/readability/AvoidConstParamsInDecls.h; clang-tools-extra/clang-tidy/readability/BracesAroundStatementsCheck.cpp; clang-tools-extra/clang-tidy/readability/BracesAroundStatementsCheck.h; clang-tools-extra/clang-tidy/readability/ConstReturnTypeCheck.cpp; clang-tools-extra/clang-tidy/readability/ContainerContainsCheck.cpp; clang-tools-extra/clang-tidy/readability/ContainerContainsCheck.h; clang-tools-extra/clang-tidy/readability/ContainerDataPointerCheck.cpp; clang-tools-extra/clang-tidy/readability/ContainerDataPointerCheck.h; clang-tools-extra/clang-tidy/readability/ContainerSizeEmptyCheck.h; clang-tools-extra/clang-tidy/readability/ConvertMemberFunctionsToStatic.cpp; clang-tools-extra/clang-tidy/readability/ConvertMemberFunctionsToStatic.h; clang-tools-extra/clang-tidy/readability/DeleteNullPointerCheck.cpp; clang-tools-extra/clang-tidy/readability/Del,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:66510,portab,portability,66510,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['portab'],['portability']
Modifiability,"ng. Not all; benchmarking functionality is guaranteed to work on every platform.; :program:`llvm-exegesis` also has a separate analysis mode that is supported; on every platform that LLVM is. SNIPPET ANNOTATIONS; -------------------. :program:`llvm-exegesis` supports benchmarking arbitrary snippets of assembly.; However, benchmarking these snippets often requires some setup so that they; can execute properly. :program:`llvm-exegesis` has five annotations and some; additional utilities to help with setup so that snippets can be benchmarked; properly. * `LLVM-EXEGESIS-DEFREG <register name>` - Adding this annotation to the text; assembly snippet to be benchmarked marks the register as requiring a definition.; A value will automatically be provided unless a second parameter, a hex value,; is passed in. This is done with the `LLVM-EXEGESIS-DEFREG <register name> <hex value>`; format. `<hex value>` is a bit pattern used to fill the register. If it is a; value smaller than the register, it is sign extended to match the size of the; register.; * `LLVM-EXEGESIS-LIVEIN <register name>` - This annotation allows specifying; registers that should keep their value upon starting the benchmark. Values; can be passed through registers from the benchmarking setup in some cases.; The registers and the values assigned to them that can be utilized in the; benchmarking script with a `LLVM-EXEGESIS-LIVEIN` are as follows:. * Scratch memory register - The specific register that this value is put in; is platform dependent (e.g., it is the RDI register on X86 Linux). Setting; this register as a live in ensures that a pointer to a block of memory (1MB); is placed within this register that can be used by the snippet.; * `LLVM-EXEGESIS-MEM-DEF <value name> <size> <value>` - This annotation allows; specifying memory definitions that can later be mapped into the execution; process of a snippet with the `LLVM-EXEGESIS-MEM-MAP` annotation. Each; value is named using the `<value name>` argument so t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst:2348,extend,extended,2348,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,1,['extend'],['extended']
Modifiability,"ng.html>`_. It is; explicitly aimed at people who are new to Clang, so all you should need; is a working knowledge of C++ and the command line. In order to work on the compiler, you need some basic knowledge of the; abstract syntax tree (AST). To this end, the reader is encouraged to; skim the :doc:`Introduction to the Clang; AST <IntroductionToTheClangAST>`. Step 0: Obtaining Clang; =======================. As Clang is part of the LLVM project, you'll need to download LLVM's; source code first. Both Clang and LLVM are in the same git repository,; under different directories. For further information, see the `getting; started guide <https://llvm.org/docs/GettingStarted.html>`_. .. code-block:: console. mkdir ~/clang-llvm && cd ~/clang-llvm; git clone https://github.com/llvm/llvm-project.git. Next you need to obtain the CMake build system and Ninja build tool. .. code-block:: console. cd ~/clang-llvm; git clone https://github.com/martine/ninja.git; cd ninja; git checkout release; ./configure.py --bootstrap; sudo cp ninja /usr/bin/. cd ~/clang-llvm; git clone https://gitlab.kitware.com/cmake/cmake.git; cd cmake; git checkout next; ./bootstrap; make; sudo make install. Okay. Now we'll build Clang!. .. code-block:: console. cd ~/clang-llvm; mkdir build && cd build; cmake -G Ninja ../llvm-project/llvm -DLLVM_ENABLE_PROJECTS=""clang;clang-tools-extra"" -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TESTS=ON; ninja; ninja check # Test LLVM only.; ninja clang-test # Test Clang only.; ninja install. And we're live. All of the tests should pass. Finally, we want to set Clang as its own compiler. .. code-block:: console. cd ~/clang-llvm/build; ccmake ../llvm-project/llvm. The second command will bring up a GUI for configuring Clang. You need; to set the entry for ``CMAKE_CXX_COMPILER``. Press ``'t'`` to turn on; advanced mode. Scroll down to ``CMAKE_CXX_COMPILER``, and set it to; ``/usr/bin/clang++``, or wherever you installed it. Press ``'c'`` to; configure, then ``'g'`` to generate CM",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:1320,config,configure,1320,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['config'],['configure']
Modifiability,ng/Syntax/Pseudo/LRTable.cpp; clang/lib/Tooling/Syntax/Pseudo/LRTableBuild.cpp; clang/lib/Tooling/Syntax/Pseudo/Preprocess.cpp; clang/lib/Tooling/Syntax/Pseudo/Token.cpp; clang/lib/Tooling/Transformer/Parsing.cpp; clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp; clang/lib/Tooling/Transformer/Stencil.cpp; clang/lib/Tooling/Transformer/Transformer.cpp; clang/tools/amdgpu-arch/AMDGPUArch.cpp; clang/tools/apinotes-test/APINotesTest.cpp; clang/tools/clang-format/ClangFormat.cpp; clang/tools/clang-fuzzer/ClangFuzzer.cpp; clang/tools/clang-fuzzer/DummyClangFuzzer.cpp; clang/tools/clang-fuzzer/ExampleClangLLVMProtoFuzzer.cpp; clang/tools/clang-fuzzer/ExampleClangLoopProtoFuzzer.cpp; clang/tools/clang-fuzzer/handle-llvm/handle_llvm.h; clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp; clang/tools/clang-linker-wrapper/OffloadWrapper.cpp; clang/tools/clang-pseudo/ClangPseudo.cpp; clang/tools/clang-refactor/ClangRefactor.cpp; clang/tools/clang-refactor/TestSupport.cpp; clang/tools/clang-refactor/TestSupport.h; clang/tools/clang-refactor/ToolRefactoringResultConsumer.h; clang/tools/clang-rename/ClangRename.cpp; clang/tools/clang-repl/ClangRepl.cpp; clang/tools/clang-scan-deps/ClangScanDeps.cpp; clang/tools/clang-shlib/clang-shlib.cpp; clang/tools/driver/cc1gen_reproducer_main.cpp; clang/tools/libclang/CIndex.cpp; clang/tools/libclang/CIndexUSRs.cpp; clang/tools/libclang/CursorVisitor.h; clang/tools/libclang/CXCursor.cpp; clang/tools/libclang/CXCursor.h; clang/tools/scan-build-py/tests/functional/src/include/clean-one.h; clang/unittests/Analysis/CFGBuildResult.h; clang/unittests/Analysis/MacroExpansionContextTest.cpp; clang/unittests/Analysis/FlowSensitive/DataflowAnalysisContextTest.cpp; clang/unittests/Analysis/FlowSensitive/DataflowEnvironmentTest.cpp; clang/unittests/Analysis/FlowSensitive/MapLatticeTest.cpp; clang/unittests/Analysis/FlowSensitive/MatchSwitchTest.cpp; clang/unittests/Analysis/FlowSensitive/MultiVarConstantPropagationTest.cpp; clang/unittests/Analys,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:28073,refactor,refactor,28073,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,"ngComments>`; The number of spaces before trailing line comments; (``//`` - comments). This does not affect trailing block comments (``/*`` - comments) as those; commonly have different usage patterns and a number of special cases. In; the case of Verilog, it doesn't affect a comment right after the opening; parenthesis in the port or parameter list in a module header, because it; is probably for the port on the following line instead of the parenthesis; it follows. .. code-block:: c++. SpacesBeforeTrailingComments: 3; void f() {; if (true) { // foo1; f(); // bar; } // foo; }. .. _SpacesInAngles:. **SpacesInAngles** (``SpacesInAnglesStyle``) :versionbadge:`clang-format 3.4` :ref:`¶ <SpacesInAngles>`; The SpacesInAnglesStyle to use for template argument lists. Possible values:. * ``SIAS_Never`` (in configuration: ``Never``); Remove spaces after ``<`` and before ``>``. .. code-block:: c++. static_cast<int>(arg);; std::function<void(int)> fct;. * ``SIAS_Always`` (in configuration: ``Always``); Add spaces after ``<`` and before ``>``. .. code-block:: c++. static_cast< int >(arg);; std::function< void(int) > fct;. * ``SIAS_Leave`` (in configuration: ``Leave``); Keep a single space after ``<`` and before ``>`` if any spaces were; present. Option ``Standard: Cpp03`` takes precedence. .. _SpacesInCStyleCastParentheses:. **SpacesInCStyleCastParentheses** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInCStyleCastParentheses>`; If ``true``, spaces may be inserted into C style casts.; This option is **deprecated**. See ``InCStyleCasts`` of; ``SpacesInParensOptions``. .. _SpacesInConditionalStatement:. **SpacesInConditionalStatement** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <SpacesInConditionalStatement>`; If ``true``, spaces will be inserted around if/for/switch/while; conditions.; This option is **deprecated**. See ``InConditionalStatements`` of; ``SpacesInParensOptions``. .. _SpacesInContainerLiterals:. **SpacesInContainerLiterals** (``Boolean``) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:123488,config,configuration,123488,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ngRef Path) {; // Try to open a formatted file; if (auto FileOrErr = openFormattedFile(Path)) {; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; } else; // On error, extract the Error value and return it.; return FileOrErr.takeError();; }. If an ``Expected<T>`` value is in success mode then the ``takeError()`` method; will return a success value. Using this fact, the above function can be; rewritten as:. .. code-block:: c++. Error processFormattedFile(StringRef Path) {; // Try to open a formatted file; auto FileOrErr = openFormattedFile(Path);; if (auto Err = FileOrErr.takeError()); // On error, extract the Error value and return it.; return Err;; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; }. This second form is often more readable for functions that involve multiple; ``Expected<T>`` values as it limits the indentation required. If an ``Expected<T>`` value will be moved into an existing variable then the; ``moveInto()`` method avoids the need to name an extra variable. This is; useful to enable ``operator->()`` the ``Expected<T>`` value has pointer-like; semantics. For example:. .. code-block:: c++. Expected<std::unique_ptr<MemoryBuffer>> openBuffer(StringRef Path);; Error processBuffer(StringRef Buffer);. Error processBufferAtPath(StringRef Path) {; // Try to open a buffer.; std::unique_ptr<MemoryBuffer> MB;; if (auto Err = openBuffer(Path).moveInto(MB)); // On error, return the Error value.; return Err;; // On success, use MB.; return processBuffer(MB->getBuffer());; }. This third form works with any type that can be assigned to from ``T&&``. This; can be useful if the ``Expected<T>`` value needs to be stored an already-declared; ``Optional<T>``. For example:. .. code-block:: c++. Expected<StringRef> extractClassName(StringRef Definition);; struct ClassData {; StringRef Definition;; Optional<StringRef> LazyName;; ...; Error initialize() {; if (auto Err = extractClassName(Path).",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:21949,variab,variable,21949,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,2,['variab'],['variable']
Modifiability,ngd/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/benchmarks/CompletionModel; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clangd/fuzzer; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index; - `39`; - `36`; - `3`; - :part:`92%`; * - clang-tools-extra/clangd/index/dex; - `9`; - `7`; - `2`; - :part:`77%`; * - clang-tools-extra/clangd/index/dex/dexp; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/marshalling; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/monitor; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/server; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/unimplemented; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/indexer; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/refactor; - `6`; - `5`; - `1`; - :part:`83%`; * - clang-tools-extra/clangd/refactor/tweaks; - `14`; - `10`; - `4`; - :part:`71%`; * - clang-tools-extra/clangd/support; - `25`; - `24`; - `1`; - :part:`96%`; * - clang-tools-extra/clangd/tool; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests; - `79`; - `66`; - `13`; - :part:`83%`; * - clang-tools-extra/clangd/unittests/decision_forest_model; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests/remote; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests/support; - `11`; - `11`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests/tweaks; - `20`; - `19`; - `1`; - :part:`95%`; * - clang-tools-extra/clangd/unittests/xpc; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/xpc; - `3`; - `3`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/xpc/framework; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/xpc/test-client; - `1`; - `1`; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:19771,refactor,refactor,19771,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['refactor'],['refactor']
Modifiability,"nging to one of the following types:. - Freely variable: allowed to take on any value. - Variable with double sided limits: allowed to vary only between two; limits specified by the user. - Variable with single sided limits: allowed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external para",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:6054,variab,variable,6054,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability,"ngle sided limits on parameters are provided by M ,; with their transformation being:. Lower bound $a$:. $$\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(P_{\mathrm{ext}} - a + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& a - 1 + \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}$$. Upper bound $b$:. $$\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(b - P_{\mathrm{ext}} + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& b + 1 - \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}$$. The transformation of course also affects the parameter error matrix, so; M does a transformation of the error matrix (and the ""parabolic""; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very; close to a limit, where; $\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0$.; Therefore, it is recommended that:. - Limits on variable parameters should be used only when needed in; order to prevent the parameter from taking on unphysical values. - When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or; re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in; the last chapter. ## M strategy ##. At many places in the analysis of the $\mbox{FCN}$ (the user; provided function), M must decide whether to be ""safe"" and waste a few; function calls in order to know where it is, or to be ""fast"" and attempt; to get the requested results with the fewest possible calls at a certain; risk of not obtaining the precision desired by the user. In order to; allow the user to influence these decisions, there is a M class; MnStrategy (see [api:strategy]) which the user can use to put different; settings. In the current release, this MnStrategy can be instantiated; with three different minimization quality levels for low (0), medium (1); and high (2) q",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:10558,variab,variable,10558,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability,"ngly leads to dangling pointers if the Block (or a copy) outlives; the lifetime of this object. In garbage collected environments, the ``__weak`` variable is set to; nil when the object it references is collected, as long as the; ``__block`` variable resides in the heap (either by default or via; ``Block_copy()``). The initial Apple implementation does in fact; start ``__block`` variables on the stack and migrate them to the heap; only as a result of a ``Block_copy()`` operation. It is a runtime error to attempt to assign a reference to a; stack-based Block into any storage marked ``__weak``, including; ``__weak`` ``__block`` variables. C++ Extensions; ==============. Block literal expressions within functions are extended to allow const; use of C++ objects, pointers, or references held in automatic storage. As usual, within the block, references to captured variables become; const-qualified, as if they were references to members of a const; object. Note that this does not change the type of a variable of; reference type. For example, given a class Foo:. .. code-block:: c. Foo foo;; Foo &fooRef = foo;; Foo *fooPtr = &foo;. A Block that referenced these variables would import the variables as; const variations:. .. code-block:: c. const Foo block_foo = foo;; Foo &block_fooRef = fooRef;; Foo *const block_fooPtr = fooPtr;. Captured variables are copied into the Block at the instant of; evaluating the Block literal expression. They are also copied when; calling ``Block_copy()`` on a Block allocated on the stack. In both; cases, they are copied as if the variable were const-qualified, and; it's an error if there's no such constructor. Captured variables in Blocks on the stack are destroyed when control; leaves the compound statement that contains the Block literal; expression. Captured variables in Blocks on the heap are destroyed; when the reference count of the Block drops to zero. Variables declared as residing in ``__block`` storage may be initially; allocated in the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:11342,variab,variable,11342,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['variab'],['variable']
Modifiability,"nguage: c. .. _core-NonNullParamChecker:. core.NonNullParamChecker (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for null pointers passed as arguments to a function whose arguments are references or marked with the 'nonnull' attribute. .. code-block:: cpp. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. .. _core-NullDereference:. core.NullDereference (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for dereferences of null pointers. This checker specifically does; not report null pointer dereferences for x86 and x86-64 targets when the; address space is 256 (x86 GS Segment), 257 (x86 FS Segment), or 258 (x86 SS; segment). See `X86/X86-64 Language Extensions; <https://clang.llvm.org/docs/LanguageExtensions.html#memory-references-to-specified-segments>`__; for reference. The ``SuppressAddressSpaces`` option suppresses; warnings for null dereferences of all pointers with address spaces. You can; disable this behavior with the option; ``-analyzer-config core.NullDereference:SuppressAddressSpaces=false``.; *Defaults to true*. .. code-block:: objc. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. .. _core-StackAddressEscape:. core.StackAddressEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function. .. code-block:: c. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. .. _core-UndefinedBinaryOperatorResult:. core.UndefinedBinaryOperatorResult (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for undefined results of binary ope",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:4202,config,config,4202,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['config'],['config']
Modifiability,"nicodeCaseFold.cpp; UnicodeNameToCodepoint.cpp; UnicodeNameToCodepointGenerated.cpp; VersionTuple.cpp; VirtualFileSystem.cpp; WithColor.cpp; YAMLParser.cpp; YAMLTraits.cpp; raw_os_ostream.cpp; raw_ostream.cpp; raw_socket_stream.cpp; regcomp.c; regerror.c; regexec.c; regfree.c; regstrlcpy.c; xxhash.cpp; Z3Solver.cpp. ${ALLOCATOR_FILES}; $<TARGET_OBJECTS:LLVMSupportBlake3>. # System; Atomic.cpp; DynamicLibrary.cpp; Errno.cpp; Memory.cpp; Path.cpp; Process.cpp; Program.cpp; RWMutex.cpp; Signals.cpp; Threading.cpp; Valgrind.cpp; Watchdog.cpp. ADDITIONAL_HEADER_DIRS; Unix; Windows; ${LLVM_MAIN_INCLUDE_DIR}/llvm/ADT; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Support; ${Backtrace_INCLUDE_DIRS}. LINK_LIBS; ${system_libs} ${imported_libs} ${delayload_flags}. LINK_COMPONENTS; Demangle; ). set(llvm_system_libs ${system_libs}). # This block is only needed for llvm-config. When we deprecate llvm-config and; # move to using CMake export, this block can be removed.; if(LLVM_ENABLE_ZLIB); # CMAKE_BUILD_TYPE is only meaningful to single-configuration generators.; if(CMAKE_BUILD_TYPE); string(TOUPPER ${CMAKE_BUILD_TYPE} build_type); get_property(zlib_library TARGET ZLIB::ZLIB PROPERTY LOCATION_${build_type}); endif(); if(NOT zlib_library); get_property(zlib_library TARGET ZLIB::ZLIB PROPERTY LOCATION); endif(); get_library_name(${zlib_library} zlib_library); set(llvm_system_libs ${llvm_system_libs} ""${zlib_library}""); endif(). if(LLVM_ENABLE_ZSTD); # CMAKE_BUILD_TYPE is only meaningful to single-configuration generators.; if(CMAKE_BUILD_TYPE); string(TOUPPER ${CMAKE_BUILD_TYPE} build_type); get_property(zstd_library TARGET ${zstd_target} PROPERTY LOCATION_${build_type}); endif(); if(NOT zstd_library); get_property(zstd_library TARGET ${zstd_target} PROPERTY LOCATION); endif(); get_library_name(${zstd_library} zstd_library); set(llvm_system_libs ${llvm_system_libs} ""${zstd_library}""); endif(). if(LLVM_ENABLE_TERMINFO); if(NOT terminfo_library); get_property(terminfo_library TARGET Terminfo::termin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt:8589,config,configuration,8589,interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt,1,['config'],['configuration']
Modifiability,"nience tool that sets up the; environment for your experiment's software both on your client and; on the PROOF worker nodes. > If you are the end user, you'll probably might skip the part that; > concerns how to configure the VAF client: your system administrator; > has probably and conveniently set it up for you. The Virtual Analysis Facility client; ------------------------------------. The Virtual Analysis Facility client takes care of setting the; environment for the end user required by your software's experiment. The; environment will both be set on the client and on each PROOF node. Technically it is a Bash shell script which provides shortcuts for PROOF; on Demand commands and ensures local and remote environment consistency:; by executing it you enter a new clean environment where all your; software dependencies have already been set up. Local and remote environment configuration is split into a series of; files, which give the possibility to:. - have a system-wide, sysadmin-provided experiment configuration. - execute user actions either *before* or *after* the execution of the; system-wide script (for instance, choosing the preferred version of; the experiment's software). - transfer a custom user **payload** on each PROOF worker (for instance,; user's client-generated Grid credentials to make PROOF workers; capable of accessing a remote authenticated storage). Configuration files are searched for in two different locations:. - a system-wide directory: `<client_install_dir>/etc`. - user's home directory: `~/.vaf`. > A system-wide configuration file always has precedence over user's; > configuration. It is thus possible for the sysadmin to enforce a; > policy where some scripts cannot ever be overridden. Thanks to this separation, users can maintain an uncluttered directory; with very simple configuration files that contain only what really needs; or is allowed to be customized: for instance, user might specify a single line; containing the needed ROOT ver",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:1343,config,configuration,1343,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['config'],['configuration']
Modifiability,"nimum along the line defined by the conjugate; gradient. Parameters are `Tau` and `Reset`, which defines the epochs; where the direction is reset to the steepest descent (estimated by; using the Fletcher-Reeves formula). #### The Broyden, Fletcher, Goldfarb, Shanno (BFGS) Method. It implies the computation of a `NxN` matrix, but seems more powerful; at least for less than 300 weights. Parameters are `Tau` and `Reset`,; which defines the epochs where the direction is reset to the steepest; descent. ### Using the Network. Neural network are build from a set of ""samples"". A sample is a set of; values defining the inputs and the corresponding output that the; network should ideally provide. In ROOT this is a **`TTree`** entry.; The first thing to be decided is the network layout. This layout is; described in a string where the layers are separated by semicolons.; The input/output layers are defined by giving the expression for each; neuron, separated by comas. Hidden layers are just described by the; number of neurons. In addition, input and output layer formulas can be preceded by '@'; (e.g. ""@out"") if one wants to normalize the corresponding value. Also,; if the string ends with '`!`', output neurons are set up for; classification, i.e. with a sigmoid (1 neuron) or softmax (more; neurons) activation function. Many questions on the good usage of neural network, including rules of; dumb to determine the best network topology are addressed at; <ftp://ftp.sas.com/pub/neural/FAQ.html>. ``` {.cpp}; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; ```. Expressions are evaluated as for `TTree::Draw()`. Input and outputs; are taken from the **`TTree`** associated with the network. This; **`TTree`** can be given as argument of the constructor or defined; later with `TMultiLayerPerceptron::SetData()`. Events can also be; weighted. The weight expression can be given in the constructor or set; later wit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:74539,layers,layers,74539,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['layers'],['layers']
Modifiability,"nimum_required(VERSION 3.20.0); project(HelloWorld); add_executable(HelloWorld HelloWorld.cpp); if(APPLE); target_compile_definitions(HelloWorld PUBLIC APPLE); endif(). Variables, Types, and Scope; ===========================. Dereferencing; -------------. In CMake variables are ""stringly"" typed. All variables are represented as; strings throughout evaluation. Wrapping a variable in ``${}`` dereferences it; and results in a literal substitution of the name for the value. CMake refers to; this as ""variable evaluation"" in their documentation. Dereferences are performed; *before* the command being called receives the arguments. This means; dereferencing a list results in multiple separate arguments being passed to the; command. Variable dereferences can be nested and be used to model complex data. For; example:. .. code-block:: cmake. set(var_name var1); set(${var_name} foo) # same as ""set(var1 foo)""; set(${${var_name}}_var bar) # same as ""set(foo_var bar)"". Dereferencing an unset variable results in an empty expansion. It is a common; pattern in CMake to conditionally set variables knowing that it will be used in; code paths that the variable isn't set. There are examples of this throughout; the LLVM CMake build system. An example of variable empty expansion is:. .. code-block:: cmake. if(APPLE); set(extra_sources Apple.cpp); endif(); add_executable(HelloWorld HelloWorld.cpp ${extra_sources}). In this example the ``extra_sources`` variable is only defined if you're; targeting an Apple platform. For all other targets the ``extra_sources`` will be; evaluated as empty before add_executable is given its arguments. Lists; -----. In CMake lists are semi-colon delimited strings, and it is strongly advised that; you avoid using semi-colons in lists; it doesn't go smoothly. A few examples of; defining lists:. .. code-block:: cmake. # Creates a list with members a, b, c, and d; set(my_list a b c d); set(my_list ""a;b;c;d""). # Creates a string ""a b c d""; set(my_string ""a b c d""). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:3582,variab,variable,3582,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['variab'],['variable']
Modifiability,"ning the; language of the raw string contents. If a canonical delimiter is specified, occurrences of other delimiters for; the same language will be updated to the canonical if possible. There should be at most one specification per language and each delimiter; and enclosing function should not occur in multiple specifications. To configure this in the .clang-format file, use:. .. code-block:: yaml. RawStringFormats:; - Language: TextProto; Delimiters:; - 'pb'; - 'proto'; EnclosingFunctions:; - 'PARSE_TEXT_PROTO'; BasedOnStyle: google; - Language: Cpp; Delimiters:; - 'cc'; - 'cpp'; BasedOnStyle: llvm; CanonicalDelimiter: 'cc'. .. _ReferenceAlignment:. **ReferenceAlignment** (``ReferenceAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <ReferenceAlignment>`; Reference alignment style (overrides ``PointerAlignment`` for; references). Possible values:. * ``RAS_Pointer`` (in configuration: ``Pointer``); Align reference like ``PointerAlignment``. * ``RAS_Left`` (in configuration: ``Left``); Align reference to the left. .. code-block:: c++. int& a;. * ``RAS_Right`` (in configuration: ``Right``); Align reference to the right. .. code-block:: c++. int &a;. * ``RAS_Middle`` (in configuration: ``Middle``); Align reference in the middle. .. code-block:: c++. int & a;. .. _ReflowComments:. **ReflowComments** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <ReflowComments>`; If ``true``, clang-format will attempt to re-flow comments. That is it; will touch a comment and *reflow* long comments into new lines, trying to; obey the ``ColumnLimit``. .. code-block:: c++. false:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information; /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */. true:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of; // information; /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of; * information */. .. _RemoveBraces",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:100039,config,configuration,100039,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"nits that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indicates; that the address is not significant, only the content. Constants marked; like this can be merged with other constants if they have the same; initializer. Note that a constant with significant address *can* be; merged with a ``unnamed_addr`` constant, the result being a constant; whose address is significant. If the ``local_unnamed_addr`` attribute is given, the address is known to; not be significant within the module. A global variable may be declared to reside in a target-specific; numbered address space. For targets that support them, address spaces; may affect how optimizations are performed and/or what target; instructions are used to access the variable. The default address space; is zero. The address space qualifier must precede any other attributes. LLVM allows an explicit section to be specified for globals. If the; target supports it, it will emit globals to the section specified.; Additionally, the global can placed in a comdat if the target has the necessary; support. External declarations may have an explicit section specified. Section; information is retained in LLVM IR for targets that make use of this; information. Attaching section information to an external declaration is an; assertion that its definition is located in the specified section. If the; definition is located in a different section, the behavior is undefined. LLVM allows an explicit code model to be specified for globals. If the; target supports it, it will emit globals in the code model specified,; overriding the code model used to compile the translation unit.; The allowed values ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:32820,variab,variable,32820,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,nittests/ExecutionEngine; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Interfaces; - `3`; - `3`; - `0`; - :good:`100%`; * - mlir/unittests/IR; - `7`; - `7`; - `0`; - :good:`100%`; * - mlir/unittests/Pass; - `3`; - `3`; - `0`; - :good:`100%`; * - mlir/unittests/Rewrite; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Support; - `5`; - `4`; - `1`; - :part:`80%`; * - mlir/unittests/TableGen; - `5`; - `3`; - `2`; - :part:`60%`; * - mlir/unittests/Transforms; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libompd/src; - `9`; - `9`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/include; - `8`; - `8`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122000,plugin,plugins,122000,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['plugin'],['plugins']
Modifiability,"nk the object file produced by our compiler. So far we have learned how to optimize and compile our LLVM IR, but we have; not focused on when compilation happens. Our current REPL optimizes and; compiles each function as soon as it is referenced by any other code,; regardless of whether it is ever called at runtime. In the next chapter we; will introduce a fully lazy compilation, in which functions are not compiled; until they are first called at run-time. At this point the trade-offs get much; more interesting: the lazier we are, the quicker we can start executing the; first function, but the more often we will have to pause to compile newly; encountered functions. If we only code-gen lazily, but optimize eagerly, we; will have a longer startup time (as everything is optimized at that time) but; relatively short pauses as each function just passes through code-gen. If we; both optimize and code-gen lazily we can start executing the first function; more quickly, but we will have longer pauses as each function has to be both; optimized and code-gen'd when it is first executed. Things become even more; interesting if we consider interprocedural optimizations like inlining, which; must be performed eagerly. These are complex trade-offs, and there is no; one-size-fits all solution to them, but by providing composable layers we leave; the decisions to the person implementing the JIT, and make it easy for them to; experiment with different configurations. `Next: Adding Per-function Lazy Compilation <BuildingAJIT3.html>`_. Full Code Listing; =================. Here is the complete code listing for our running example with an; IRTransformLayer added to enable optimization. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../examples/Kaleidoscope/BuildingAJIT/Chapter2/KaleidoscopeJIT.h; :language: c++; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:11646,layers,layers,11646,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,3,"['config', 'layers']","['config', 'configurations', 'layers']"
Modifiability,nknown. 1836; CD5; Use of class type being defined in trailing-return-type; Unknown. 1837; CD6; Use of this in friend and local class declarations; Clang 3.3. 1838; CD4; Definition via unqualified-id and using-declaration; Unknown. 1839; CD6; Lookup of block-scope extern declarations; Unknown. 1840; drafting; Non-deleted explicit specialization of deleted function template; Not resolved. 1841; CD6; < following template injected-class-name; Unknown. 1842; open; Unevaluated operands and “carries a dependency”; Not resolved. 1843; CD4; Bit-field in conditional operator with throw operand; Unknown. 1844; open; Defining “immediate context”; Not resolved. 1845; drafting; Point of instantiation of a variable template specialization; Not resolved. 1846; CD4; Declaring explicitly-defaulted implicitly-deleted functions; Unknown. 1847; CD4; Clarifying compatibility during partial ordering; Unknown. 1848; CD4; Parenthesized constructor and destructor declarators; Unknown. 1849; CD6; Variable templates and the ODR; Unknown. 1850; CD4; Differences between definition context and point of instantiation; Unknown. 1851; CD4; decltype(auto) in new-expressions; Unknown. 1852; CD4; Wording issues regarding decltype(auto); Unknown. 1853; dup; Defining “allocated storage”; Unknown. 1854; drafting; Disallowing use of implicitly-deleted functions; Not resolved. 1855; dup; Out-of-lifetime access to nonstatic data members; Unknown. 1856; open; Indirect nested classes of class templates; Not resolved. 1857; CD5; Additional questions about bits; Unknown. 1858; CD4; Comparing pointers to union members; Unknown. 1859; CD5; UTF-16 in char16_t string literals; Unknown. 1860; C++17; What is a “direct member?”; Unknown. 1861; CD4; Values of a bit-field; Unknown. 1862; CD5; Determining “corresponding members” for friendship; Unknown. 1863; CD4; Requirements on thrown object type to support std::current_exception(); Unknown. 1864; NAD; List-initialization of array objects; Unknown. 1865; CD4; Pointer a,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:125597,Variab,Variable,125597,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Variab'],['Variable']
Modifiability,nknown. 2290; CD5; Unclear specification for overload resolution and deleted special member functions; Unknown. 2291; dup; Implicit conversion sequences in non-call contexts; Unknown. 2292; CD5; simple-template-id is ambiguous between class-name and type-name; Clang 9. 2293; CD5; Requirements for simple-template-id used as a class-name; Unknown. 2294; CD5; Dependent auto static data members; Unknown. 2295; CD5; Aggregates with deleted defaulted constructors; Unknown. 2296; open; Are default argument instantiation failures in the “immediate context”?; Not resolved. 2297; open; Unclear specification of atomic operations; Not resolved. 2298; open; Actions and expression evaluation; Not resolved. 2299; CD5; constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address comparison between different member subobjects; Unknown. 2303; CD5; Partial ordering and recursive variadic inheritance; Clang 12. 2304; NAD; Incomplete type vs overload resolution; Unknown. 2305; CD5; Explicit instantiation of constexpr or inline variable template; Unknown. 2306; NAD; Nested friend templates of class templates; Unknown. 2307; CD5; Unclear definition of “equivalent to a nontype template parameter”; Unknown. 2308; NAD; Structured bindings and lambda capture; Unknown. 2309; CD5; Restrictions on nested statements within constexpr functions; Unknown. 2310; CD5; Type completeness and derived-to-base pointer conversions; Unknown. 2311; open; Missed case for guaranteed copy elision; Not resolved. 2312; CD6; Structured bindings and mutable; Unknown. 2313; CD5; Redeclaration of structured binding reference variables; Unknown. 2314; dup; Structured bindings and lambda capture; Unknown. 2315; CD5; What is the “corresponding special member” of a variant member?; Unknown. 2316; drafting; Simplifying class conversions in conditional expressions; Not resolved. 2317; CD5; Sel,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:157136,inherit,inheritance,157136,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['inherit'],['inheritance']
Modifiability,"nknown. 2416; C++20; Explicit specializations vs constexpr and consteval; Unknown. 2417; open; Explicit instantiation and exception specifications; Not resolved. 2418; CD5; Missing cases in definition of “usable in constant expressions”; Unknown. 2419; C++20; Loss of generality treating pointers to objects as one-element arrays; Unknown. 2420; dup; Exception specifications in explicit instantiation; Unknown. 2421; drafting; Explicit instantiation of constrained member functions; Not resolved. 2422; C++20; Incorrect grammar for deduction-guide; Unknown. 2423; NAD; Typedefs, names, and entities; Unknown. 2424; C++20; constexpr initialization requirements for variant members; Unknown. 2425; open; Confusing wording for deduction from a type; Not resolved. 2426; C++20; Reference to destructor that cannot be invoked; Unknown. 2427; C++20; Deprecation of volatile operands and unevaluated contexts; Unknown. 2428; C++23; Deprecating a concept; Unknown. 2429; C++20; Initialization of thread_local variables referenced by lambdas; Unknown. 2430; C++20; Completeness of return and parameter types of member functions; Unknown. 2431; C++20; Full-expressions and temporaries bound to references; Unknown. 2432; C++20; Return types for defaulted <=>; Unknown. 2433; C++20; Variable templates in the ODR; Unknown. 2434; open; Mandatory copy elision vs non-class objects; Not resolved. 2435; open; Alias template specializations; Not resolved. 2436; C++20; Copy semantics of coroutine parameters; Unknown. 2437; C++20; Conversion of std::strong_ordering in a defaulted operator<=>; Unknown. 2438; open; Problems in the specification of qualification conversions; Not resolved. 2439; C++20; Undefined term in definition of “usable in constant expressions”; Unknown. 2440; C++23; Allocation in core constant expressions; Unknown. 2441; C++20; Inline function parameters; Unknown. 2442; C++20; Incorrect requirement for default arguments; Unknown. 2443; C++23; Meaningless template exports; Unknown. 2444;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:166265,variab,variables,166265,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['variab'],['variables']
Modifiability,"nknown. 708; open; Partial specialization of member templates of class templates; Not resolved. 709; C++11; Enumeration names as nested-name-specifiers in deduction failure; Unknown. 710; CD2; Data races during construction; Unknown. 711; CD2; auto with braced-init-list; Unknown. 712; CD3; Are integer constant operands of a conditional-expression “used?”; Partial. 713; CD2; Unclear note about cv-qualified function types; Unknown. 714; CD2; Static const data members and braced-init-lists; Unknown. 715; CD2; Class member access constant expressions; Unknown. 716; CD2; Specifications that should apply only to non-static union data members; Unknown. 717; CD2; Unintentional restrictions on the use of thread_local; Unknown. 718; NAD; Non-class, non-function friend declarations; Unknown. 719; CD2; Specifications for operator-function-id that should also apply to literal-operator-id; Unknown. 720; CD2; Need examples of lambda-expressions; Unknown. 721; CD2; Where must a variable be initialized to be used in a constant expression?; Unknown. 722; CD2; Can nullptr be passed to an ellipsis?; Unknown. 726; CD2; Atomic and non-atomic objects in the memory model; Unknown. 727; C++17; In-class explicit specializations; Partial. 728; NAD; Restrictions on local classes; Unknown. 729; CD3; Qualification conversions and handlers of reference-to-pointer type; Unknown. 730; CD2; Explicit specializations of members of non-template classes; Unknown. 731; CD2; Omitted reference qualification of member function type; Unknown. 732; CD2; Late-specified return types in function definitions; Unknown. 733; NAD; Reference qualification of copy assignment operators; Unknown. 734; CD2; Are unique addresses required for namespace-scope variables?; Unknown. 735; CD2; Missing case in specification of safely-derived pointers; Unknown. 736; NAD; Is the & ref-qualifier needed?; Unknown. 737; CD2; Uninitialized trailing characters in string initialization; Unknown. 738; C++11; constexpr not permitted by th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:49601,variab,variable,49601,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['variab'],['variable']
Modifiability,"nment:. cplusplus.SelfAssignment (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks C++ copy and move assignment operators for self assignment. .. _cplusplus-StringChecker:. cplusplus.StringChecker (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks std::string operations. Checks if the cstring pointer from which the ``std::string`` object is; constructed is ``NULL`` or not.; If the checker cannot reason about the nullness of the pointer it will assume; that it was non-null to satisfy the precondition of the constructor. This checker is capable of checking the `SEI CERT C++ coding rule STR51-CPP.; Do not attempt to create a std::string from a null pointer; <https://wiki.sei.cmu.edu/confluence/x/E3s-BQ>`__. .. code-block:: cpp. #include <string>. void f(const char *p) {; if (!p) {; std::string msg(p); // warn: The parameter must not be null; }; }. .. _deadcode-checkers:. deadcode; ^^^^^^^^. Dead Code Checkers. .. _deadcode-DeadStores:. deadcode.DeadStores (C); """"""""""""""""""""""""""""""""""""""""""""""; Check for values stored to variables that are never read afterwards. .. code-block:: c. void test() {; int x;; x = 1; // warn; }. The ``WarnForDeadNestedAssignments`` option enables the checker to emit; warnings for nested dead assignments. You can disable with the; ``-analyzer-config deadcode.DeadStores:WarnForDeadNestedAssignments=false``.; *Defaults to true*. Would warn for this e.g.:; if ((y = make_int())) {; }. .. _nullability-checkers:. nullability; ^^^^^^^^^^^. Objective C checkers that warn for null pointer passing and dereferencing errors. .. _nullability-NullPassedToNonnull:. nullability.NullPassedToNonnull (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a null pointer is passed to a pointer which has a _Nonnull type. .. code-block:: objc. if (name != nil); return;; // Warning: nil passed to a callee that requires a non-null 1st parameter; NSString *greeting = [@""Hello "" stringByAppendingString:name];. .. _nullability-NullReturnedFromNonnull:. nullability.NullReturnedFromNonnull",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:10302,variab,variables,10302,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['variab'],['variables']
Modifiability,nmp/libomptarget/include/rtl.h; openmp/libomptarget/include/SourceInfo.h; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.cpp; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.h; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.cpp; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.h; openmp/libomptarget/plugins/amdgpu/impl/hsa_api.h; openmp/libomptarget/plugins/amdgpu/impl/impl.cpp; openmp/libomptarget/plugins/amdgpu/impl/impl_runtime.h; openmp/libomptarget/plugins/amdgpu/impl/internal.h; openmp/libomptarget/plugins/amdgpu/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/libomptarget/plugins/remote/include/Utils.h; openmp/libomptarget/plugins/remote/server/OffloadingServer.cpp; openmp/libomptarget/plugins/remote/server/Server.cpp; openmp/libomptarget/plugins/remote/server/Server.h; openmp/libomptarget/plugins/remote/src/Client.cpp; openmp/libomptarget/plugins/remote/src/Client.h; openmp/libomptarget/plugins/ve/src/rtl.cpp; openmp/libomptarget/src/api.cpp; openmp/libomptarget/src/interface.cpp; openmp/libomptarget/src/interop.cpp; openmp/libomptarget/src/omptarget.cpp; openmp/libomptarget/src/private.h; openmp/libomptarget/src/rtl.cpp; openmp/libomptarget/tools/deviceinfo/llvm-omp-device-info.cpp; openmp/runtime/doc/doxygen/libomp_interface.h; openmp/runtime/src/extractExternal.cpp; openmp/runtime/src/kmp.h; openmp/runtime/src/kmp_affinity.h; openmp/runtime/src/kmp_alloc.cpp; openmp/runtime/src/kmp_atomi,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:407748,plugin,plugins,407748,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,"nny pointer arithmetic is involved, the alloca will not be; promoted.; #. mem2reg only works on allocas of `first; class <../../LangRef.html#first-class-types>`_ values (such as pointers,; scalars and vectors), and only if the array size of the allocation is; 1 (or missing in the .ll file). mem2reg is not capable of promoting; structs or arrays to registers. Note that the ""sroa"" pass is; more powerful and can promote structs, ""unions"", and arrays in many; cases. All of these properties are easy to satisfy for most imperative; languages, and we'll illustrate it below with Kaleidoscope. The final; question you may be asking is: should I bother with this nonsense for my; front-end? Wouldn't it be better if I just did SSA construction; directly, avoiding use of the mem2reg optimization pass? In short, we; strongly recommend that you use this technique for building SSA form,; unless there is an extremely good reason not to. Using this technique; is:. - Proven and well tested: clang uses this technique; for local mutable variables. As such, the most common clients of LLVM; are using this to handle a bulk of their variables. You can be sure; that bugs are found fast and fixed early.; - Extremely Fast: mem2reg has a number of special cases that make it; fast in common cases as well as fully general. For example, it has; fast-paths for variables that are only used in a single block,; variables that only have one assignment point, good heuristics to; avoid insertion of unneeded phi nodes, etc.; - Needed for debug info generation: `Debug information in; LLVM <../../SourceLevelDebugging.html>`_ relies on having the address of; the variable exposed so that debug info can be attached to it. This; technique dovetails very naturally with this style of debug info. If nothing else, this makes it much easier to get your front-end up and; running, and is very simple to implement. Let's extend Kaleidoscope with; mutable variables now!. Mutable Variables in Kaleidoscope; ================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:9279,variab,variables,9279,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability,"noexcept(baz(arg2)));. * ``BBNSS_OnlyWithParen`` (in configuration: ``OnlyWithParen``); For a simple ``noexcept`` there is no line break allowed, but when we; have a condition it is. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. * ``BBNSS_Always`` (in configuration: ``Always``); Line breaks are allowed. But note that because of the associated; penalties ``clang-format`` often prefers not to break before the; ``noexcept``. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. .. _AllowShortBlocksOnASingleLine:. **AllowShortBlocksOnASingleLine** (``ShortBlockStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortBlocksOnASingleLine>`; Dependent on the value, ``while (true) { continue; }`` can be put on a; single line. Possible values:. * ``SBS_Never`` (in configuration: ``Never``); Never merge blocks into a single line. .. code-block:: c++. while (true) {; }; while (true) {; continue;; }. * ``SBS_Empty`` (in configuration: ``Empty``); Only merge empty blocks. .. code-block:: c++. while (true) {}; while (true) {; continue;; }. * ``SBS_Always`` (in configuration: ``Always``); Always merge short blocks into a single line. .. code-block:: c++. while (true) {}; while (true) { continue; }. .. _AllowShortCaseLabelsOnASingleLine:. **AllowShortCaseLabelsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 3.6` :ref:`¶ <AllowShortCaseLabelsOnASingleLine>`; If ``true``, short case labels will be contracted to a single line. .. code-block:: c++. true: false:; switch (a) { vs. switch (a) {; case 1: x = 1; break; case 1:; case 2: return; x = 1;; } break;; case 2:; return;; }. .. _AllowShortCompoundRequirementOnASingleLine:. **AllowShortCompoundRequirementOnASingleLine** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <AllowShortCompoundRequirementOnASingleLine>",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:27039,config,configuration,27039,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"non-static data members of Objective-C++ non-union class types; * Objective-C++ objects and arrays of dynamic storage duration created; with the ``new`` or ``new[]`` operators and destroyed with the; corresponding ``delete`` or ``delete[]`` operator. They are not followed automatically for these objects:. * objects of dynamic storage duration created in other memory, such as; that returned by ``malloc``; * union members. .. admonition:: Rationale. ARC must perform special operations when initializing an object and; when destroying it. In many common situations, ARC knows when an; object is created and when it is destroyed and can ensure that these; operations are performed correctly. Otherwise, however, ARC requires; programmer cooperation to establish its initialization invariants; because it is infeasible for ARC to dynamically infer whether they; are intact. For example, there is no syntactic difference in C between; an assignment that is intended by the programmer to initialize a variable; and one that is intended to replace the existing value stored there,; but ARC must perform one operation or the other. ARC chooses to always; assume that objects are initialized (except when it is in charge of; initializing them) because the only workable alternative would be to; ban all code patterns that could potentially be used to access; uninitialized memory, and that would be too limiting. In practice,; this is rarely a problem because programmers do not generally need to; work with objects for which the requirements are not handled; automatically. Note that dynamically-allocated Objective-C++ arrays of; nontrivially-ownership-qualified type are not ABI-compatible with non-ARC; code because the non-ARC code will consider the element type to be POD.; Such arrays that are ``new[]``'d in ARC translation units cannot be; ``delete[]``'d in non-ARC translation units and vice-versa. .. _arc.ownership.restrictions.pass_by_writeback:. Passing to an out parameter by writeback; ^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:47476,variab,variable,47476,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variable']
Modifiability,"nor ``stderr``; - 1 : close ``stdout``; - 2 : close ``stderr``; - 3 : close both ``stdout`` and ``stderr``. For the full list of flags run the fuzzer binary with ``-help=1``. Output; ======. During operation the fuzzer prints information to ``stderr``, for example::. INFO: Seed: 1523017872; INFO: Loaded 1 modules (16 guards): [0x744e60, 0x744ea0),; INFO: -max_len is not provided, using 64; INFO: A corpus is not provided, starting from an empty corpus; #0	READ units: 1; #1	INITED cov: 3 ft: 2 corp: 1/1b exec/s: 0 rss: 24Mb; #3811	NEW cov: 4 ft: 3 corp: 2/2b exec/s: 0 rss: 25Mb L: 1 MS: 5 ChangeBit-ChangeByte-ChangeBit-ShuffleBytes-ChangeByte-; #3827	NEW cov: 5 ft: 4 corp: 3/4b exec/s: 0 rss: 25Mb L: 2 MS: 1 CopyPart-; #3963	NEW cov: 6 ft: 5 corp: 4/6b exec/s: 0 rss: 25Mb L: 2 MS: 2 ShuffleBytes-ChangeBit-; #4167	NEW cov: 7 ft: 6 corp: 5/9b exec/s: 0 rss: 25Mb L: 3 MS: 1 InsertByte-; ... The early parts of the output include information about the fuzzer options and; configuration, including the current random seed (in the ``Seed:`` line; this; can be overridden with the ``-seed=N`` flag). Further output lines have the form of an event code and statistics. The; possible event codes are:. ``READ``; The fuzzer has read in all of the provided input samples from the corpus; directories.; ``INITED``; The fuzzer has completed initialization, which includes running each of; the initial input samples through the code under test.; ``NEW``; The fuzzer has created a test input that covers new areas of the code; under test. This input will be saved to the primary corpus directory.; ``REDUCE``; The fuzzer has found a better (smaller) input that triggers previously; discovered features (set ``-reduce_inputs=0`` to disable).; ``pulse``; The fuzzer has generated 2\ :sup:`n` inputs (generated periodically to reassure; the user that the fuzzer is still working).; ``DONE``; The fuzzer has completed operation because it has reached the specified; iteration limit (``-runs``) or time limit (",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:15391,config,configuration,15391,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['config'],['configuration']
Modifiability,"not part of the installer, but may be installed; separately from the; `Visual Studio Marketplace <https://marketplace.visualstudio.com/items?itemName=LLVMExtensions.llvm-toolchain>`_.; To use the toolset, select a project in Solution Explorer, open its Property; Page (Alt+F7), and in the ""General"" section of ""Configuration Properties""; change ""Platform Toolset"" to LLVM. Doing so enables an additional Property; Page for selecting the clang-cl executable to use for builds. To use the toolset with MSBuild directly, invoke it with e.g.; ``/p:PlatformToolset=LLVM``. This allows trying out the clang-cl toolchain; without modifying your project files. It's also possible to point MSBuild at clang-cl without changing toolset by; passing ``/p:CLToolPath=c:\llvm\bin /p:CLToolExe=clang-cl.exe``. When using CMake and the Visual Studio generators, the toolset can be set with the ``-T`` flag:. ::. cmake -G""Visual Studio 16 2019"" -T LLVM .. When using CMake with the Ninja generator, set the ``CMAKE_C_COMPILER`` and; ``CMAKE_CXX_COMPILER`` variables to clang-cl:. ::. cmake -GNinja -DCMAKE_C_COMPILER=""c:/Program Files (x86)/LLVM/bin/clang-cl.exe""; -DCMAKE_CXX_COMPILER=""c:/Program Files (x86)/LLVM/bin/clang-cl.exe"" .. Command-Line Options; --------------------. To be compatible with cl.exe, clang-cl supports most of the same command-line; options. Those options can start with either ``/`` or ``-``. It also supports; some of Clang's core options, such as the ``-W`` options. Options that are known to clang-cl, but not currently supported, are ignored; with a warning. For example:. ::. clang-cl.exe: warning: argument unused during compilation: '/AI'. To suppress warnings about unused arguments, use the ``-Qunused-arguments`` option. Options that are not known to clang-cl will be ignored by default. Use the; ``-Werror=unknown-argument`` option in order to treat them as errors. If these; options are spelled with a leading ``/``, they will be mistaken for a filename:. ::. clang-cl.exe: erro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:169993,variab,variables,169993,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variables']
Modifiability,"now supports CUDA SDK up to 12.3; - Added support for sm_90a. PowerPC Support; ^^^^^^^^^^^^^^^. - Added ``nmmintrin.h`` to intrinsics headers.; - Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for corresponding instruction.; - Supported ``__attribute__((target(""tune=cpu"")))``.; - Emit ``float-abi`` module flag on 64-bit ELFv2 PowerPC targets if; ``long double`` type is used in current module. AIX Support; ^^^^^^^^^^^. - Introduced the ``-maix-small-local-exec-tls`` option to produce a faster; access sequence for local-exec TLS variables where the offset from the TLS; base is encoded as an immediate operand.; This access sequence is not used for TLS variables larger than 32KB, and is; currently only supported on 64-bit mode.; - Inline assembler supports VSR register in pure digits.; - Enabled ThinLTO support. Requires AIX 7.2 TL5 SP7 or newer, or AIX 7.3 TL2; or newer. Similar to the LTO support on AIX, ThinLTO is implemented with; the libLTO.so plugin. SystemZ Support; ^^^^^^^^^^^^^^^; - Properly support 16 byte atomic int/fp types and ops. Atomic __int128 (and; long double) variables are now aligned to 16 bytes by default (like gcc 14). WebAssembly Support; ^^^^^^^^^^^^^^^^^^^. AVR Support; ^^^^^^^^^^^. DWARF Support in Clang; ----------------------. Floating Point Support in Clang; -------------------------------; - Add ``__builtin_elementwise_log`` builtin for floating point types only.; - Add ``__builtin_elementwise_log10`` builtin for floating point types only.; - Add ``__builtin_elementwise_log2`` builtin for floating point types only.; - Add ``__builtin_elementwise_exp`` builtin for floating point types only.; - Add ``__builtin_elementwise_exp2`` builtin for floating point types only.; - Add ``__builtin_set_flt_rounds`` builtin for X86, x86_64, Arm and AArch64 only.; - Add ``__builtin_elementwise_pow`` builtin for floating point types only.; - Add ``__builtin_elementwise_bitreverse`` builtin for integer types only.; - Ad",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:65772,plugin,plugin,65772,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['plugin'],['plugin']
Modifiability,"nrolling the code the Loop Vectorizer allows two or more execution ports; to be used simultaneously. .. code-block:: c++. int foo(int *A, int n) {; unsigned sum = 0;; for (int i = 0; i < n; ++i); sum += A[i];; return sum;; }. The Loop Vectorizer uses a cost model to decide when it is profitable to unroll loops.; The decision to unroll the loop depends on the register pressure and the generated code size. Epilogue Vectorization; ^^^^^^^^^^^^^^^^^^^^^^. When vectorizing a loop, often a scalar remainder (epilogue) loop is necessary; to execute tail iterations of the loop if the loop trip count is unknown or it; does not evenly divide the vectorization and unroll factors. When the; vectorization and unroll factors are large, it's possible for loops with smaller; trip counts to end up spending most of their time in the scalar (rather than; the vector) code. In order to address this issue, the inner loop vectorizer is; enhanced with a feature that allows it to vectorize epilogue loops with a; vectorization and unroll factor combination that makes it more likely for small; trip count loops to still execute in vectorized code. The diagram below shows; the CFG for a typical epilogue vectorized loop with runtime checks. As; illustrated the control flow is structured in a way that avoids duplicating the; runtime pointer checks and optimizes the path length for loops that have very; small trip counts. .. image:: epilogue-vectorization-cfg.png. Performance; -----------. This section shows the execution time of Clang on a simple benchmark:; `gcc-loops <https://github.com/llvm/llvm-test-suite/tree/main/SingleSource/UnitTests/Vectorizer>`_.; This benchmarks is a collection of loops from the GCC autovectorization; `page <http://gcc.gnu.org/projects/tree-ssa/vectorization.html>`_ by Dorit Nuzman. The chart below compares GCC-4.7, ICC-13, and Clang-SVN with and without loop vectorization at -O3, tuned for ""corei7-avx"", running on a Sandybridge iMac.; The Y-axis shows the time in msec.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst:11729,enhance,enhanced,11729,interpreter/llvm-project/llvm/docs/Vectorizers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst,1,['enhance'],['enhanced']
Modifiability,"ns `SetObjectFit/GetObjectFit` can be used inside the; `FCN` function to set/get a referenced object instead of using; global variables. - By default `fGraphicsMode` is true. When calling the `Minuit`; functions such as `mncont`, `mnscan`, or any `Minuit` command; invoking `mnplot`, `TMinuit::mnplot()` produces a **`TGraph`**; object pointed by `fPlot`. One can retrieve this object with; **`TMinuit`**`::GetPlot().` For example:. ``` {.cpp}; h->Fit(""gaus"");; gMinuit->Command(""SCAn 1"");; TGraph *gr = (TGraph*)gMinuit->GetPlot();; gr->SetMarkerStyle(21);; gr->Draw(""alp"");; ```. - To set `Minuit` in no graphics mode, call. ``` {.cpp}; gMinuit->SetGraphicsMode(kFALSE);; ```. ### Basic Concepts of Minuit. The `Minuit` package acts on a multi parameter FORTRAN function to; which one must give the generic name `FCN`. In the ROOT; implementation, the function `FCN` is defined via the `Minuit`; `SetFCN` member function when an histogram fitting is invoked. The; value of `FCN` will in general depend on one or more variable; parameters. ### The Transformation of Limited Parameters. For variable parameters with limits, `Minuit` uses the following; transformation:. `Pint = arcsin(2((Pext-a)/(b-a))-1) `. `Pext = a+((b-a)/(2))(sinPint+1)`. so that the internal value `Pint` can take on any value, while the; external value Pext can take on values only between the lower limit a; and the ext upper limit b. Since the transformation is necessarily; non-linear, it would transform a nice linear problem into a nasty; non-linear one, which is the reason why limits should be avoided if; not necessary. In addition, the transformation does require some; computer time, so it slows down the computation a little bit, and more; importantly, it introduces additional numerical inaccuracy into the; problem in addition to what is introduced in the numerical calculation; of the FCN value. The effects of non-linearity and numerical round off; both become more important as the external value gets closer t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:55364,variab,variable,55364,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['variab'],['variable']
Modifiability,"ns a Block reference of the same; type. The release operation, ``Block_release()``, is styled as a; function that takes an arbitrary Block reference and, if dynamically; matched to a Block copy operation, allows recovery of the referenced; allocated memory. The ``__block`` Storage Qualifier; =================================. In addition to the new Block type we also introduce a new storage; qualifier, :block-term:`__block`, for local variables. [testme: a; __block declaration within a block literal] The ``__block`` storage; qualifier is mutually exclusive to the existing local storage; qualifiers auto, register, and static. [testme] Variables qualified by; ``__block`` act as if they were in allocated storage and this storage; is automatically recovered after last use of said variable. An; implementation may choose an optimization where the storage is; initially automatic and only ""moved"" to allocated (heap) storage upon; a Block_copy of a referencing Block. Such variables may be mutated as; normal variables are. In the case where a ``__block`` variable is a Block one must assume; that the ``__block`` variable resides in allocated storage and as such; is assumed to reference a Block that is also in allocated storage; (that it is the result of a ``Block_copy`` operation). Despite this; there is no provision to do a ``Block_copy`` or a ``Block_release`` if; an implementation provides initial automatic storage for Blocks. This; is due to the inherent race condition of potentially several threads; trying to update the shared variable and the need for synchronization; around disposing of older values and copying new ones. Such; synchronization is beyond the scope of this language specification. Control Flow; ============. The compound statement of a Block is treated much like a function body; with respect to control flow in that goto, break, and continue do not; escape the Block. Exceptions are treated *normally* in that when; thrown they pop stack frames until a catch c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:7572,variab,variables,7572,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,2,['variab'],['variables']
Modifiability,"ns above, the ``-help`` option synopsis is now extended to:. ::. USAGE: compiler [options] <input file>. OPTIONS:; -h - Alias for -help; -help - display available options (-help-hidden for more); -o <filename> - Specify output filename. ... indicating that an input filename is expected. Boolean Arguments; -----------------. In addition to input and output filenames, we would like the compiler example to; support three boolean flags: ""``-f``"" to force writing binary output to a; terminal, ""``--quiet``"" to enable quiet mode, and ""``-q``"" for backwards; compatibility with some of our users. We can support these by declaring options; of boolean type like this:. .. code-block:: c++. cl::opt<bool> Force (""f"", cl::desc(""Enable binary output on terminals""));; cl::opt<bool> Quiet (""quiet"", cl::desc(""Don't print informational messages""));; cl::opt<bool> Quiet2(""q"", cl::desc(""Don't print informational messages""), cl::Hidden);. This does what you would expect: it declares three boolean variables; (""``Force``"", ""``Quiet``"", and ""``Quiet2``"") to recognize these options. Note; that the ""``-q``"" option is specified with the ""`cl::Hidden`_"" flag. This; modifier prevents it from being shown by the standard ""``-help``"" output (note; that it is still shown in the ""``-help-hidden``"" output). The CommandLine library uses a `different parser`_ for different data types.; For example, in the string case, the argument passed to the option is copied; literally into the content of the string variable... we obviously cannot do that; in the boolean case, however, so we must use a smarter parser. In the case of; the boolean parser, it allows no options (in which case it assigns the value of; true to the variable), or it allows the values ""``true``"" or ""``false``"" to be; specified, allowing any of the following inputs:. ::. compiler -f # No value, 'Force' == true; compiler -f=true # Value specified, 'Force' == true; compiler -f=TRUE # Value specified, 'Force' == true; compiler -f=FALSE # Value spec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:9491,variab,variables,9491,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variables']
Modifiability,"ns and do not know about Thread0; being a member function of a class. Thus, you have to pass this; information by hand, if you want to access all members of the `Myclass`; instance from the Thread0 function. Note: Method Thread0 cannot be a virtual member function, since the cast; of `Thread0` to `void(*)` in the **`TThread`** constructor may raise; problems with C++ virtual function table. However, Thread0 may call; another virtual member function virtual void `Myclass::Func0()` which; then can be overridden in a derived class of `Myclass`. (See example; `TMhs3`). Class `Myclass` may also provide a method to stop the running thread:. ``` {.cpp}; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; ```. Example `TMhs3:` Class **`TThreadframe`**; (`TThreadframe.h, TThreadframe.cxx`) is a simple example of a framework; class managing up to four threaded methods. Class `TMhs3`; (`TMhs3.h, TMhs3.cxx)` inherits from this base class, showing the `mhs3`; example 8.1 `(mhs3.h, mhs3.cxx) `within a class. The `Makefile` of this; example builds the shared libraries `libTThreadframe.so` and; `libTMhs3.so`. These are either loaded or executed by the ROOT script; `TMhs3demo.C,` or are linked against an executable: `TMhs3run.cxx`. ### Known Problems. Parts of the ROOT framework, like the interpreter, are not yet; thread-safe. Therefore, you should use this package with caution. If you; restrict your threads to distinct and \`simple' duties, you will able to; benefit from their use. The **`TThread`** class is available on all; platforms, which provide a POSIX compliant thread implementation. On; Linux, Xavier Leroy's Linux Threads implementation is widely used, but; the **`TThread`** implementation should be usable on all platforms that; provide `pthread`. **Linux Xlib on SMP machines** is not yet thread-safe. This may cause; crashes during threaded graphics operations; this problem is independent; of ROOT. **Object insta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:16611,inherit,inherits,16611,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['inherit'],['inherits']
Modifiability,"ns, operators, and; constructors/destructors. - ``hasType(functionType)``: Can be used to apply attributes to functions, C++; member functions, and variables/fields whose type is a function pointer. It; does not apply attributes to Objective-C methods or blocks. - ``type_alias``: Can be used to apply attributes to ``typedef`` declarations; and C++11 type aliases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. - ``objc_category``: Can be used to apply attributes to category declarations,; including class extensions. - ``objc_method``: Can be used to apply attributes to Objective-C methods,; including instance an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:183934,variab,variable,183934,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"ns. Compile with the; ``-fprofile-arcs`` and ``-ftest-coverage`` options to add the; instrumentation. (Alternatively, you can use the ``--coverage`` option, which; includes both of those other options.). At the time you compile the instrumented code, a ``.gcno`` data file will be; generated for each object file. These ``.gcno`` files contain half of the; coverage data. The other half of the data comes from ``.gcda`` files that are; generated when you run the instrumented program, with a separate ``.gcda``; file for each object file. Each time you run the program, the execution counts; are summed into any existing ``.gcda`` files, so be sure to remove any old; files if you do not want their contents to be included. By default, the ``.gcda`` files are written into the same directory as the; object files, but you can override that by setting the ``GCOV_PREFIX`` and; ``GCOV_PREFIX_STRIP`` environment variables. The ``GCOV_PREFIX_STRIP``; variable specifies a number of directory components to be removed from the; start of the absolute path to the object file directory. After stripping those; directories, the prefix from the ``GCOV_PREFIX`` variable is added. These; environment variables allow you to run the instrumented program on a machine; where the original object file directories are not accessible, but you will; then need to copy the ``.gcda`` files back to the object file directories; where :program:`llvm-cov gcov` expects to find them. Once you have generated the coverage data files, run :program:`llvm-cov gcov`; for each main source file where you want to examine the coverage results. This; should be run from the same directory where you previously ran the; compiler. The results for the specified source file are written to a file named; by appending a ``.gcov`` suffix. A separate output file is also created for; each file included by the main source file, also with a ``.gcov`` suffix added. The basic content of an ``.gcov`` output file is a copy of the source fil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst:2262,variab,variable,2262,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst,1,['variab'],['variable']
Modifiability,"ns.mjs, provide jsroot geometry build without three.js; 17. Fix - correctly draw only grids with AXIG draw option; 18. Fix - log scales on TH3 drawings #306; 19. Fix - draw geometry top node volume if all childs not visible #308; 20. Fix - properly process 206 server response without Accept-Ranges header https://root-forum.cern.ch/t/59426/. ## Changes in 7.6.1; 1. Remove source_dir output in node.js #296; 2. Fully integrate svg2pdf.js into jsroot repo; 3. Fix - support plain TRI option for TGraph2D; 4. Fix - let read object from ROOT file with empty name; 5. Fix - graph drawing fix custom labels on X axis #297; 6. Fix - draw at least line for TGraphErrors ROOT-8131; 7. Fix - preserve attributes and draw options when call drawingJSON() #307; 8. Fix - menu for text align selection typo. ## Changes in 7.6.0; 1. Implement ""tickz"" draw option, used for color palette ticks; 2. Implement skewness and kurtosis calculations for histogram stats box; 3. Introduce ""logv"" draw option for `TH3`, configures logarithmic scale for box volume; 4. Implement color palette drawing for `TH3`; 5. Implement cutg draw option for `TH2`/`TF2` surface plots; 6. Implement `TMath::Sq()` function and several others like SinH, ASinH, ...; 7. Implement histogram drawing build from `TGraph2D` using Delaunay interpolation; 8. Provide preliminary `TF3` support; 9. Support `TLinearGradient` and `TRadialGradient` colors; 10. Support LZMA decompression of ROOT files #272; 11. Include ZSTD decompression to repository #274; 12. Support opacity transfer function for `TH3`, see tutorials/gl/glvox2.C; 13. Upgrade three.js r155 -> r158; 14. Handle TCanvas IsEdiatable flag to disable some interactive features; 15. Support PDF creation using jsPDF and svg2pdf.js - in browser and node.js; 16. Implement custom fonts support in TWebCanvas; 17. List of ROOT/JSON files on server with `&dir=<path>` URL parameter #283; 18. Load TGaxis function from the file #282; 19. Let display progress messages in modal element #285;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:6036,config,configures,6036,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['config'],['configures']
Modifiability,"ns; that are already documented include: *LLVM_TARGETS_TO_BUILD*, *LLVM_ENABLE_PROJECTS*,; *LLVM_ENABLE_RUNTIMES*, *LLVM_BUILD_LLVM_DYLIB*, and *LLVM_LINK_LLVM_DYLIB*. **LLVM_ENABLE_RUNTIMES**:STRING; When building a distribution that includes LLVM runtime projects (i.e. libcxx,; compiler-rt, libcxxabi, libunwind...), it is important to build those projects; with the just-built compiler. **LLVM_DISTRIBUTION_COMPONENTS**:STRING; This variable can be set to a semi-colon separated list of LLVM build system; components to install. All LLVM-based tools are components, as well as most; of the libraries and runtimes. Component names match the names of the build; system targets. **LLVM_DISTRIBUTIONS**:STRING; This variable can be set to a semi-colon separated list of distributions. See; the :ref:`Multi-distribution configurations` section above for details on this; and other CMake variables to configure multiple distributions. **LLVM_RUNTIME_DISTRIBUTION_COMPONENTS**:STRING; This variable can be set to a semi-colon separated list of runtime library; components. This is used in conjunction with *LLVM_ENABLE_RUNTIMES* to specify; components of runtime libraries that you want to include in your distribution.; Just like with *LLVM_DISTRIBUTION_COMPONENTS*, component names match the names; of the build system targets. **LLVM_DYLIB_COMPONENTS**:STRING; This variable can be set to a semi-colon separated name of LLVM library; components. LLVM library components are either library names with the LLVM; prefix removed (i.e. Support, Demangle...), LLVM target names, or special; purpose component names. The special purpose component names are:. #. ``all`` - All LLVM available component libraries; #. ``Native`` - The LLVM target for the Native system; #. ``AllTargetsAsmParsers`` - All the included target ASM parsers libraries; #. ``AllTargetsDescs`` - All the included target descriptions libraries; #. ``AllTargetsDisassemblers`` - All the included target dissassemblers libraries; #. ``All",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:12062,variab,variable,12062,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['variab'],['variable']
Modifiability,"nsformed into simply ``return 3``. Whether or; not library calls are simplified is controlled by the; :ref:`-function-attrs <passes-function-attrs>` pass and LLVM's knowledge of; library calls on different targets. .. _passes-aggressive-instcombine:. ``aggressive-instcombine``: Combine expression patterns; --------------------------------------------------------. Combine expression patterns to form expressions with fewer, simple instructions. For example, this pass reduce width of expressions post-dominated by TruncInst; into smaller width when applicable. It differs from instcombine pass in that it can modify CFG and contains pattern; optimization that requires higher complexity than the O(1), thus, it should run fewer; times than instcombine pass. ``internalize``: Internalize Global Symbols; -------------------------------------------. This pass loops over all of the functions in the input module, looking for a; main function. If a main function is found, all other functions and all global; variables with initializers are marked as internal. ``ipsccp``: Interprocedural Sparse Conditional Constant Propagation; -------------------------------------------------------------------. An interprocedural variant of :ref:`Sparse Conditional Constant Propagation; <passes-sccp>`. ``jump-threading``: Jump Threading; ----------------------------------. Jump threading tries to find distinct threads of control flow running through a; basic block. This pass looks at blocks that have multiple predecessors and; multiple successors. If one or more of the predecessors of the block can be; proven to always cause a jump to one of the successors, we forward the edge; from the predecessor to the successor by duplicating the contents of this; block. An example of when this can occur is code like this:. .. code-block:: c++. if () { ...; X = 4;; }; if (X < 3) {. In this case, the unconditional branch at the end of the first if can be; revectored to the false side of the second if. .. _passes-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:21600,variab,variables,21600,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['variab'],['variables']
Modifiability,"nsic also lowers a specified; number of arguments according to its calling convention. This allows; patched code to make in-place function calls without marshaling. Each instance of one of these intrinsics generates a stack map record; in the :ref:`stackmap-section`. The record includes an ID, allowing; the runtime to uniquely identify the stack map, and the offset within; the code from the beginning of the enclosing function. '``llvm.experimental.stackmap``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void; @llvm.experimental.stackmap(i64 <id>, i32 <numShadowBytes>, ...). Overview:; """""""""""""""""". The '``llvm.experimental.stackmap``' intrinsic records the location of; specified values in the stack map without generating any code. Operands:; """""""""""""""""". The first operand is an ID to be encoded within the stack map. The; second operand is the number of shadow bytes following the; intrinsic. The variable number of operands that follow are the ``live; values`` for which locations will be recorded in the stack map. To use this intrinsic as a bare-bones stack map, with no code patching; support, the number of shadow bytes can be set to zero. Semantics:; """""""""""""""""""". The stack map intrinsic generates no code in place, unless nops are; needed to cover its shadow (see below). However, its offset from; function entry is stored in the stack map. This is the relative; instruction address immediately following the instructions that; precede the stack map. The stack map ID allows a runtime to locate the desired stack map; record. LLVM passes this ID through directly to the stack map; record without checking uniqueness. LLVM guarantees a shadow of instructions following the stack map's; instruction offset during which neither the end of the basic block nor; another call to ``llvm.experimental.stackmap`` or; ``llvm.experimental.patchpoint`` may occur. This allows the runtime to; patch the code at this point in response to an event triggered from;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:4942,variab,variable,4942,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['variab'],['variable']
Modifiability,"nsic. You can use ``llvm.sadd.with.overflow``; on any integer bit width or vectors of integers. ::. declare {i16, i1} @llvm.sadd.with.overflow.i16(i16 %a, i16 %b); declare {i32, i1} @llvm.sadd.with.overflow.i32(i32 %a, i32 %b); declare {i64, i1} @llvm.sadd.with.overflow.i64(i64 %a, i64 %b); declare {<4 x i32>, <4 x i1>} @llvm.sadd.with.overflow.v4i32(<4 x i32> %a, <4 x i32> %b). Overview:; """""""""""""""""". The '``llvm.sadd.with.overflow``' family of intrinsic functions perform; a signed addition of the two arguments, and indicate whether an overflow; occurred during the signed summation. Arguments:; """""""""""""""""""". The arguments (%a and %b) and the first element of the result structure; may be of integer types of any bit width, but they must have the same; bit width. The second element of the result structure must be of type; ``i1``. ``%a`` and ``%b`` are the two values that will undergo signed; addition. Semantics:; """""""""""""""""""". The '``llvm.sadd.with.overflow``' family of intrinsic functions perform; a signed addition of the two variables. They return a structure --- the; first element of which is the signed summation, and the second element; of which is a bit specifying if the signed summation resulted in an; overflow. Examples:; """""""""""""""""". .. code-block:: llvm. %res = call {i32, i1} @llvm.sadd.with.overflow.i32(i32 %a, i32 %b); %sum = extractvalue {i32, i1} %res, 0; %obit = extractvalue {i32, i1} %res, 1; br i1 %obit, label %overflow, label %normal. '``llvm.uadd.with.overflow.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.uadd.with.overflow``; on any integer bit width or vectors of integers. ::. declare {i16, i1} @llvm.uadd.with.overflow.i16(i16 %a, i16 %b); declare {i32, i1} @llvm.uadd.with.overflow.i32(i32 %a, i32 %b); declare {i64, i1} @llvm.uadd.with.overflow.i64(i64 %a, i64 %b); declare {<4 x i32>, <4 x i1>} @llvm.uadd.with.overflow.v4i32(<4 x i32> %a, <4 x i32> %b). Overview:; """"""""""""""""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:602062,variab,variables,602062,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"nsional input pdfs. One of the appealing features; is that no expensive calculations are required to calculate in the interpolated pdfs shapes after the pdf; initialization. An extension that allows morphing in two parameters is foreseen for the next root release.; Progress indication in plot projections; The RooAbsReal::plotOn() now accepts a new argument ShowProgress() that will print a dot for every; function evaluation performed in the process of creating the plot. This can be useful when plotting very expensive; functions such as profile likelihoods; Automatic handling of constraint terms; It is no longer necessary to add a Constrain() argument to fitTo() calls to have internal constraints; applied. Any pdf term appearing in a product that does not contain an observable and shares one or more parameters; with another pdf term in the same product that does contain an observable is automatically picked up as a constraint term.; For example given a dataset D(x) which defines variable x as observable, the default logic works out as follows. F(x,a,b)*G(a,a0,a1) --> G is constraint term (a also appears in F(x)); F(x,a,b)*G(y,c,d) --> G is dropped (factorizing term). A Constrain(y) term in the above example will still force term G(y,c,d) to be interpreted as constraint term; Automatic caching of numeric integral calculations; Integrals that require numeric integrations in two of more dimensions are now automatically cached in the expensive object store.; The expensive object store allows to cache such values between difference instance of integral objects that represent the; same configuration. If integrals are created from an object (function or pdf) that live in a RooWorkspace the ; expensive object cache of the workspace will be used instead of the global store instance, and values stored in the workspace; store will also be persisted if the workspace is persisted. The global caching behavior of integral objects can be ; controlled through RooRealIntegral::setCache",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:7373,variab,variable,7373,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,2,['variab'],['variable']
Modifiability,"nsity:. ``` {.cpp}; TGeoMixture(const char *name,Int_t nel,Double_t rho);; ```. Elements have to be further defined one by one:. ``` {.cpp}; void TGeoMixture::DefineElement(Int_t iel,Double_t a,Double_t z,; Double_t weigth);; void TGeoMixture::DefineElement(Int_t iel, TGeoElement *elem,; Double_t weight);; void TGeoMixture::DefineElement(Int_t iel, Int_t z, Int_t natoms);; ```. or:. ``` {.cpp}; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight); ```. - `iel:` index of the element` [0,nel-1]`; - `a` and `z:` the atomic mass and charge; - `weight:` proportion by mass of the elements; - `natoms`: number of atoms of the element in the molecule making the; mixture. The radiation length is automatically computed when all elements are; defined. Since tracking MC provide several other ways to create; materials/mixtures, the materials classes are likely to evolve as the; interfaces to these engines are being developed. Generally in the; process of tracking material properties are not enough and more specific; media properties have to be defined. These highly depend on the MC; performing tracking and sometimes allow the definition of different; media properties (e.g. energy or range cuts) for the same material. ### Radionuclides. A new class **`TGeoElementRN`** was introduced in this version to; provide support for radioactive nuclides and their decays. A database of; 3162 radionuclides can be loaded on demand via the table of elements; (**`TGeoElementTable`** class). One can make then materials/mixtures; based on these radionuclides and use them in a geometry. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:17116,evolve,evolve,17116,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['evolve'],['evolve']
Modifiability,"nst;; private:; Float_t fA;; Float_t fB;; Float_t fC;; };; ```. `Quad.cxx`:. ``` {.cpp}; #include <iostream.h>; #include <math.h>; #include ""Quad.h"". Quad::Quad(Float_t a, Float_t b, Float_t c) {; fA = a;; fB = b;; fC = c;; }; Quad::~Quad() {; Cout <<""deleting object with coeffts: ""<< fA << "","" << fB << "",""; << fC << endl;; }; Float_t Quad::Evaluate(Float_t x) const {; return fA*x*x + fB*x + fC;; }; void Quad::Solve() const {; Float_t temp = fB*fB - 4.*fA*fC;; if ( temp > 0. ) {; temp = sqrt( temp );; cout << ""There are two roots: "" << ( -fB - temp ) / (2.*fA); << "" and "" << ( -fB + temp ) / (2.*fA) << endl;; } else {; if ( temp == 0. ) {; cout << ""There are two equal roots: "" << -fB / (2.*fA); << endl;; } else {; cout << ""There are no roots"" << endl;; }; }; }; ```. Let us first look how we create an object. When we create an object; by:. ``` {.cpp}; root[] Quad my_object(1.,2.,-3.);; ```. We are creating an object on the stack. A FORTRAN programmer may be; familiar with the idea; it is not unlike a local variable in a; function or subroutine. Although there are still a few old timers who; do not know it, FORTRAN is under no obligation to save local variables; once the function or subroutine returns unless the SAVE statement is; used. If not then it is likely that FORTRAN will place them on the; stack and they will ""pop off"" when the RETURN statement is reached. To; give an object more permanence it has to be placed on the heap. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; ```. The second line declares a pointer to `Quad` called `my_objptr`. From; the syntax point of view, this is just like all the other declarations; we have seen so far, i.e. this is a stack variable. The value of the; pointer is set equal to. ``` {.cpp}; new Quad(1.,2.,-3.);; ```. `new`, despite its looks, is an operator and creates an object or; variable of the type that comes next, `Quad` in this case, on the; heap. Just as with stack objects it has to be initial",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:8883,variab,variable,8883,documentation/users-guide/ALittleC++.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md,1,['variab'],['variable']
Modifiability,"nst`` copies of other; variables, and variables marked ``__block``. In Objective-C, variables may; additionally be objects. When a ``Block`` literal expression is used as the initial value of a global; or ``static`` local variable, it is initialized as follows:. .. code-block:: c. struct __block_literal_1 __block_literal_1 = {; &_NSConcreteGlobalBlock,; (1<<28)|(1<<29), <uninitialized>,; __block_invoke_1,; &__block_descriptor_1; };. that is, a different address is provided as the first value and a particular; (1<<28) bit is set in the ``flags`` field, and otherwise it is the same as for; stack based ``Block`` literals. This is an optimization that can be used for; any ``Block`` literal that imports no ``const`` or ``__block`` storage; variables. Imported Variables; ==================. Variables of ``auto`` storage class are imported as ``const`` copies. Variables; of ``__block`` storage class are imported as a pointer to an enclosing data; structure. Global variables are simply referenced and not considered as; imported. Imported ``const`` copy variables; ---------------------------------. Automatic storage variables not marked with ``__block`` are imported as; ``const`` copies. The simplest example is that of importing a variable of type ``int``:. .. code-block:: c. int x = 10;; void (^vv)(void) = ^{ printf(""x is %d\n"", x); }; x = 11;; vv();. which would be compiled to:. .. code-block:: c. struct __block_literal_2 {; void *isa;; int flags;; int reserved;; void (*invoke)(struct __block_literal_2 *);; struct __block_descriptor_2 *descriptor;; const int x;; };. void __block_invoke_2(struct __block_literal_2 *_block) {; printf(""x is %d\n"", _block->x);; }. static struct __block_descriptor_2 {; unsigned long int reserved;; unsigned long int Block_size;; } __block_descriptor_2 = { 0, sizeof(struct __block_literal_2) };. and:. .. code-block:: c. struct __block_literal_2 __block_literal_2 = {; &_NSConcreteStackBlock,; (1<<29), <uninitialized>,; __block_invoke_2,; &__block_d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:6831,variab,variables,6831,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability,"nstallation; of Scientific Linux CERN which doesn't include OpenSSL development package. In such; a case, you should install ```openssl-devel```, re-compile Python and ```configure```; will automatically link against the required libraries and produce a binary with SSL; support. #### Ubuntu/Debian; On Debian, Ubuntu, Linux Mint, CrunchBang, or any other distro based on Debian; which supports APT package manager, you can install all the required packages by:; ```sh; sudo apt-get update; sudo apt-get install git g++ debhelper devscripts gnupg python; ```; You are not required to do this manually since CPT can do this for you automatically. ###### Setting up:; Make sure GnuPG is properly set up with your correct fingerprint. These; credentials are needed to sign the Debian package and create Debian changelogs.; On a build machine (Electric Commander), make sure the fingerprint is of the; user who is supposed to sign the official uploads. You might also want to; configure GnuPG to not ask for the passphrase while signing the Debian package. The [Ubuntu Packaging Guide] contains a quick guide on creating a GPG key on an; Ubuntu system. To test if you have successfully set up your GnuPG key, use the following command:; ```sh; gpg --fingerprint; ```; Again, all these checks are performed by default when you launch CPT with ```-c``` option.; [Ubuntu Packaging Guide]:http://packaging.ubuntu.com/html/getting-set-up.html#create-your-gpg-key. #### Windows; CPT is meant to be executed on cmd.exe prompt. Make sure you have set the; environment properly before continuing.; Below is a list of required packages for Windows (Win32-x86):. [MSYS Git] for Windows. [Python] for Windows. Microsoft Visual Studio 11 (2012), with Microsoft Visual C++ 2012. [MSYS Git]:http://msysgit.github.io/; [Python]:https://www.python.org/. ###### Setting Up:; Unlike other UNIX-like platforms, Windows requires you to follow some rules.; Do not ignore this section unless you want CPT to fail mid-way with w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md:3071,config,configure,3071,interpreter/cling/tools/packaging/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md,1,['config'],['configure']
Modifiability,"nstalled/enabled by setting ``xray_mode=xray-basic`` in the ``XRAY_OPTIONS``; environment variable. Combined with ``patch_premain=true`` this can allow for; tracing applications from start to end. Like all the other modes installed through ``__xray_log_select_mode(...)``, the; implementation can be configured through the ``__xray_log_init_mode(...)``; function, providing the mode string and the flag options. Basic-mode specific; defaults can be provided in the ``XRAY_BASIC_OPTIONS`` environment variable. Flight Data Recorder Mode; -------------------------. XRay supports a logging mode which allows the application to only capture a; fixed amount of memory's worth of events. Flight Data Recorder (FDR) mode works; very much like a plane's ""black box"" which keeps recording data to memory in a; fixed-size circular queue of buffers, and have the data available; programmatically until the buffers are finalized and flushed. To use FDR mode; on your application, you may set the ``xray_mode`` variable to ``xray-fdr`` in; the ``XRAY_OPTIONS`` environment variable. Additional options to the FDR mode; implementation can be provided in the ``XRAY_FDR_OPTIONS`` environment; variable. Programmatic configuration can be done by calling; ``__xray_log_init_mode(""xray-fdr"", <configuration string>)`` once it has been; selected/installed. When the buffers are flushed to disk, the result is a binary trace format; described by `XRay FDR format <XRayFDRFormat.html>`_. When FDR mode is on, it will keep writing and recycling memory buffers until; the logging implementation is finalized -- at which point it can be flushed and; re-initialised later. To do this programmatically, we follow the workflow; provided below:. .. code-block:: c++. // Patch the sleds, if we haven't yet.; auto patch_status = __xray_patch();. // Maybe handle the patch_status errors. // When we want to flush the log, we need to finalize it first, to give; // threads a chance to return buffers to the queue.; auto finalize_st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst:9248,variab,variable,9248,interpreter/llvm-project/llvm/docs/XRay.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst,2,['variab'],['variable']
Modifiability,"nstance. tree->Branch(""px"", &Category, ""px/F"");. becomes. auto px = model->MakeField<float>(""px"");; // px is std::shared_ptr<float>. The physical layout changes slightly from big endian to little endian so that it matches the in-memory layout on; most modern architectures. Combined with a clear separation of offset/index data and payload data for collections,; uncompressed RNTuple data can be directly mapped to memory without further copies. Goals; -----. RNTuple shall investigate improvements of the TTree I/O in the following ways. 1. More speed; * Improve mapping to vectorized and parallel hardware; * For types known at compile / JIT time: generate optimized code; * Optimized for simple types (float, int, and vectors of them); * Better memory control: work with a fixed budget of pre-defined I/O buffers; * Naturally thread-safe and asynchronous interfaces. 2. More robust interfaces; * Compile-time type safety by default; * Decomposition into layers: logical layer, primitives layer, storage layer; * Separation of data model and live data; * Self-contained I/O code to support creation of a standalone I/O library. Concepts; --------. At the **logical layer**, the user defines a data model using the RNTupleModel class.; The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree.; The data model can contain (nested) collections, e.g., a type can be `std::vector<std::vector<float>>`. Each serializable type is represented by a **field**, concretely by a templated version of RField,; e.g. `RField<double>`. A field can generate or adopt an associated **value**, which represents a memory location; storing a value of the given C++ type. These distinguished memory locations are the destinations and sources for the; deserialization and serialization. The (de-)serialization is a mapping from the C++ type to the more simple **column** type system. A column contains; an arbitrary number of fixed-sized elements of a well-defined se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md:1318,layers,layers,1318,tree/ntuple/v7/doc/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md,1,['layers'],['layers']
Modifiability,"nstead of ``git clone`` you may download a compressed source distribution; from the `releases page <https://github.com/llvm/llvm-project/releases>`_.; Select the last link: ``Source code (zip)`` and unpack the downloaded file using; Windows Explorer built-in zip support or any other unzip tool. 12. Finally, configure LLVM using CMake:. .. code-block:: bat. cmake -S llvm\llvm -B build -DLLVM_ENABLE_PROJECTS=clang -DLLVM_TARGETS_TO_BUILD=X86 -Thost=x64; exit. ``LLVM_ENABLE_PROJECTS`` specifies any additional LLVM projects you want to; build while ``LLVM_TARGETS_TO_BUILD`` selects the compiler targets. If; ``LLVM_TARGETS_TO_BUILD`` is omitted by default all targets are built; slowing compilation and using more disk space.; See the :doc:`LLVM CMake guide <CMake>` for detailed information about; how to configure the LLVM build. The ``cmake`` command line tool is bundled with Visual Studio but its GUI is; not. You may install `CMake <http://www.cmake.org/>`_ to use its GUI to change; CMake variables or modify the above command line. * Once CMake is installed then the simplest way is to just start the; CMake GUI, select the directory where you have LLVM extracted to, and; the default options should all be fine. One option you may really; want to change, regardless of anything else, might be the; ``CMAKE_INSTALL_PREFIX`` setting to select a directory to INSTALL to; once compiling is complete, although installation is not mandatory for; using LLVM. Another important option is ``LLVM_TARGETS_TO_BUILD``,; which controls the LLVM target architectures that are included on the; build.; * CMake generates project files for all build types. To select a specific; build type, use the Configuration manager from the VS IDE or the; ``/property:Configuration`` command line option when using MSBuild.; * By default, the Visual Studio project files generated by CMake use the; 32-bit toolset. If you are developing on a 64-bit version of Windows and; want to use the 64-bit toolset, pass the ``-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst:5625,variab,variables,5625,interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,1,['variab'],['variables']
Modifiability,"nstructed LLVMContext respectively. Now that our members have been initialized,; so the one thing that remains to do is to tweak the configuration of the; *JITDylib* that we will store our code in. We want to modify this dylib to; contain not only the symbols that we add to it, but also the symbols from our; REPL process as well. We do this by attaching a; ``DynamicLibrarySearchGenerator`` instance using the; ``DynamicLibrarySearchGenerator::GetForCurrentProcess`` method. .. code-block:: c++. static Expected<std::unique_ptr<KaleidoscopeJIT>> Create() {; auto JTMB = JITTargetMachineBuilder::detectHost();. if (!JTMB); return JTMB.takeError();. auto DL = JTMB->getDefaultDataLayoutForTarget();; if (!DL); return DL.takeError();. return std::make_unique<KaleidoscopeJIT>(std::move(*JTMB), std::move(*DL));; }. const DataLayout &getDataLayout() const { return DL; }. LLVMContext &getContext() { return *Ctx.getContext(); }. Next we have a named constructor, ``Create``, which will build a KaleidoscopeJIT; instance that is configured to generate code for our host process. It does this; by first generating a JITTargetMachineBuilder instance using that classes'; detectHost method and then using that instance to generate a datalayout for; the target process. Each of these operations can fail, so each returns its; result wrapped in an Expected value [3]_ that we must check for error before; continuing. If both operations succeed we can unwrap their results (using the; dereference operator) and pass them into KaleidoscopeJIT's constructor on the; last line of the function. Following the named constructor we have the ``getDataLayout()`` and; ``getContext()`` methods. These are used to make data structures created and; managed by the JIT (especially the LLVMContext) available to the REPL code that; will build our IR modules. .. code-block:: c++. void addModule(std::unique_ptr<Module> M) {; cantFail(CompileLayer.add(ES.getMainJITDylib(),; ThreadSafeModule(std::move(M), Ctx)));; }. Expect",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:9153,config,configured,9153,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,1,['config'],['configured']
Modifiability,"nstruction was, and replacing any uses of the old instruction with the; new instruction. The following example illustrates the replacement of one; ``AllocaInst`` with another. .. code-block:: c++. AllocaInst* instToReplace = ...;; BasicBlock::iterator ii(instToReplace);. ReplaceInstWithInst(instToReplace->getParent(), ii,; new AllocaInst(Type::Int32Ty, 0, ""ptrToReplacedInt""));. Replacing multiple uses of Users and Values; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". You can use ``Value::replaceAllUsesWith`` and ``User::replaceUsesOfWith`` to; change more than one use at a time. See the doxygen documentation for the; `Value Class <https://llvm.org/doxygen/classllvm_1_1Value.html>`_ and `User Class; <https://llvm.org/doxygen/classllvm_1_1User.html>`_, respectively, for more; information. .. _schanges_deletingGV:. Deleting GlobalVariables; ^^^^^^^^^^^^^^^^^^^^^^^^. Deleting a global variable from a module is just as easy as deleting an; Instruction. First, you must have a pointer to the global variable that you; wish to delete. You use this pointer to erase it from its parent, the module.; For example:. .. code-block:: c++. GlobalVariable *GV = .. ;. GV->eraseFromParent();. .. _threading:. Threads and LLVM; ================. This section describes the interaction of the LLVM APIs with multithreading,; both on the part of client applications, and in the JIT, in the hosted; application. Note that LLVM's support for multithreading is still relatively young. Up; through version 2.5, the execution of threaded hosted applications was; supported, but not threaded client access to the APIs. While this use case is; now supported, clients *must* adhere to the guidelines specified below to ensure; proper operation in multithreaded mode. Note that, on Unix-like platforms, LLVM requires the presence of GCC's atomic; intrinsics in order to support threaded operation. If you need a; multithreading-capable LLVM on a platform without a suitably modern system; compiler, consider compili",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:120651,variab,variable,120651,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['variab'],['variable']
Modifiability,"nstrument. These files can be provided through the ``-fxray-attr-list=`` flag to clang.; You may have multiple files loaded through multiple instances of the flag. XRay Runtime Library; --------------------. The XRay Runtime Library is part of the compiler-rt project, which implements; the runtime components that perform the patching and unpatching of inserted; instrumentation points. When you use ``clang`` to link your binaries and the; ``-fxray-instrument`` flag, it will automatically link in the XRay runtime. The default implementation of the XRay runtime will enable XRay instrumentation; before ``main`` starts, which works for applications that have a short; lifetime. This implementation also records all function entry and exit events; which may result in a lot of records in the resulting trace. Also by default the filename of the XRay trace is ``xray-log.XXXXXX`` where the; ``XXXXXX`` part is randomly generated. These options can be controlled through the ``XRAY_OPTIONS`` environment; variable, where we list down the options and their defaults below. +-------------------+-----------------+---------------+------------------------+; | Option | Type | Default | Description |; +===================+=================+===============+========================+; | patch_premain | ``bool`` | ``false`` | Whether to patch |; | | | | instrumentation points |; | | | | before main. |; +-------------------+-----------------+---------------+------------------------+; | xray_mode | ``const char*`` | ``""""`` | Default mode to |; | | | | install and initialize |; | | | | before ``main``. |; +-------------------+-----------------+---------------+------------------------+; | xray_logfile_base | ``const char*`` | ``xray-log.`` | Filename base for the |; | | | | XRay logfile. |; +-------------------+-----------------+---------------+------------------------+; | verbosity | ``int`` | ``0`` | Runtime verbosity |; | | | | level. |; +-------------------+-----------------+---------------+---",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst:5382,variab,variable,5382,interpreter/llvm-project/llvm/docs/XRay.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst,1,['variab'],['variable']
Modifiability,"nsupported vector types to; value of supported types: splitting vector types, multiple times if necessary,; until a legal type is found, and extending vector types by adding elements to; the end to round them out to legal types (""widening""). If a vector gets split; all the way down to single-element parts with no supported vector type being; found, the elements are converted to scalars (""scalarizing""). A target implementation tells the legalizer which types are supported (and which; register class to use for them) by calling the ``addRegisterClass`` method in; its ``TargetLowering`` constructor. .. _legalize operations:; .. _Legalizer:. SelectionDAG Legalize Phase; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. The Legalize phase is in charge of converting a DAG to only use the operations; that are natively supported by the target. Targets often have weird constraints, such as not supporting every operation on; every supported datatype (e.g. X86 does not support byte conditional moves and; PowerPC does not support sign-extending loads from a 16-bit memory location).; Legalize takes care of this by open-coding another sequence of operations to; emulate the operation (""expansion""), by promoting one type to a larger type that; supports the operation (""promotion""), or by using a target-specific hook to; implement the legalization (""custom""). A target implementation tells the legalizer which operations are not supported; (and which of the above three actions to take) by calling the; ``setOperationAction`` method in its ``TargetLowering`` constructor. If a target has legal vector types, it is expected to produce efficient machine; code for common forms of the shufflevector IR instruction using those types.; This may require custom legalization for SelectionDAG vector operations that; are created from the shufflevector IR. The shufflevector forms that should be; handled include:. * Vector select --- Each element of the vector is chosen from either of the; corresponding elements of the 2 inpu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:42708,extend,extending,42708,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['extend'],['extending']
Modifiability,"nt in the; sense that the re–write from to was done by its signification and not; literally (with minor exceptions). Applications such as; $\mbox{MIGRAD}$ have a corresponding class MnMigrad, M ""commands""; became classes or methods of classes according to their purpose. Users; familiar with the version of M , who have not yet used releases from the; version, should however read this manual, in order to adapt to the; changes as well as to discover the new features and easier ways of using; old features. ## Install M using autoconf/make ##. For each release of M a tar.gz file is provided for downloading from the; M homepage @bib-C++MINUIT. For non-UNIX platforms please refer to the M; homepage. The necessary steps to follow are:. 1. download the tar.gz by clicking on it from the release page. 2. unzip it:. $ unzip Minuit-x.x.x.tar.gz. 3. untar it:. $ tar xvf Minuit-x.x.x.tar. 4. step down to the created Minuit-x.x.x directory:. $ cd Minuit-x.x.x/. 5. run the ""configure"" script:. $ ./configure. 6. run ""make"" to compile the source code:. $ make. 7. run ""make check"" to create the executable example:. $ make check. 8. run the executable example:. $ tests/MnTutorial/Quad4FMain.C. The output should look like that:. Minuit did successfully converge. # of function calls: 74; minimum function value: 1.12392e-09; minimum edm: 1.12392e-09; minimum internal state vector: LAVector parameters:. -1.82079e-05; -1.20794e-05; 6.22382e-06; -3.0465e-05. minimum internal covariance matrix: LASymMatrix parameters:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. # ext. || name || type || value || error +/-. 0 || x || free ||-1.821e-05 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovariance:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. MnUserCovariance parameter correlations:. 1 0.223607 0.408248 1.35011e-18; 0.223607",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:22587,config,configure,22587,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['config'],['configure']
Modifiability,nt members of this; directory are the SPEC CPU benchmark suites.; See [External Suites](#external-suites). - `Bitcode/`. These tests are mostly written in LLVM bitcode. - `CTMark/`. Contains symbolic links to other benchmarks forming a representative sample; for compilation performance measurements. ### Benchmarks. Every program can work as a correctness test. Some programs are unsuitable for; performance measurements. Setting the `TEST_SUITE_BENCHMARKING_ONLY` CMake; option to `ON` will disable them. Configuration; -------------. The test-suite has configuration options to customize building and running the; benchmarks. CMake can print a list of them:. ```bash; % cd test-suite-build; # Print basic options:; % cmake -LH; # Print all options:; % cmake -LAH; ```. ### Common Configuration Options. - `CMAKE_C_FLAGS`. Specify extra flags to be passed to C compiler invocations. The flags are; also passed to the C++ compiler and linker invocations. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html). - `CMAKE_C_COMPILER`. Select the C compiler executable to be used. Note that the C++ compiler is; inferred automatically i.e. when specifying `path/to/clang` CMake will; automatically use `path/to/clang++` as the C++ compiler. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html). - `CMAKE_Fortran_COMPILER`. Select the Fortran compiler executable to be used. Not set by default and not; required unless running the Fortran Test Suite. - `CMAKE_BUILD_TYPE`. Select a build type like `OPTIMIZE` or `DEBUG` selecting a set of predefined; compiler flags. These flags are applied regardless of the `CMAKE_C_FLAGS`; option and may be changed by modifying `CMAKE_C_FLAGS_OPTIMIZE` etc. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html](https://cmake.org/cmake/help/latest/variable/CMAKE_B,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:4207,variab,variable,4207,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['variab'],['variable']
Modifiability,"nt of history (including, e.g., the glibc system; headers). GCC accepts anything its ""fold"" optimizer is capable of reducing to; an integer constant, which means that the definition of what it accepts changes; as its optimizer does. One example is that GCC accepts things like ""``case; X-X:``"" even when ``X`` is a variable, because it can fold this to 0. Another issue are how constants interact with the extensions we support, such; as ``__builtin_constant_p``, ``__builtin_inf``, ``__extension__`` and many; others. C99 obviously does not specify the semantics of any of these; extensions, and the definition of i-c-e does not include them. However, these; extensions are often used in real code, and we have to have a way to reason; about them. Finally, this is not just a problem for semantic analysis. The code generator; and other clients have to be able to fold constants (e.g., to initialize global; variables) and have to handle a superset of what C99 allows. Further, these; clients can benefit from extended information. For example, we know that; ""``foo() || 1``"" always evaluates to ``true``, but we can't replace the; expression with ``true`` because it has side effects. Implementation Approach; ^^^^^^^^^^^^^^^^^^^^^^^. After trying several different approaches, we've finally converged on a design; (Note, at the time of this writing, not all of this has been implemented,; consider this a design goal!). Our basic approach is to define a single; recursive evaluation method (``Expr::Evaluate``), which is implemented; in ``AST/ExprConstant.cpp``. Given an expression with ""scalar"" type (integer,; fp, complex, or pointer) this method returns the following information:. * Whether the expression is an integer constant expression, a general constant; that was folded but has no side effects, a general constant that was folded; but that does have side effects, or an uncomputable/unfoldable value.; * If the expression was computable in any way, this method returns the; ``APValue`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:120653,extend,extended,120653,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['extend'],['extended']
Modifiability,"nt of the array is represented in turn using these; same conventions. * ``bits`` values are also emitted as arrays. A ``bits`` array is; ordered from least-significant bit to most-significant. So the; element with index ``i`` corresponds to the bit described as; ``x{i}`` in TableGen source. However, note that this means that; scripting languages are likely to *display* the array in the; opposite order from the way it appears in the TableGen source or in; the diagnostic ``-print-records`` output. All other TableGen value types are emitted as a JSON object,; containing two standard fields: ``kind`` is a discriminator describing; which kind of value the object represents, and ``printable`` is a; string giving the same representation of the value that would appear; in ``-print-records``. * A reference to a ``def`` object has ``kind==""def""``, and has an; extra field ``def`` giving the name of the object referred to. * A reference to another variable in the same record has; ``kind==""var""``, and has an extra field ``var`` giving the name of; the variable referred to. * A reference to a specific bit of a ``bits``-typed variable in the; same record has ``kind==""varbit""``, and has two extra fields:; ``var`` gives the name of the variable referred to, and ``index``; gives the index of the bit. * A value of type ``dag`` has ``kind==""dag""``, and has two extra; fields. ``operator`` gives the initial value after the opening; parenthesis of the dag initializer; ``args`` is an array giving the; following arguments. The elements of ``args`` are arrays of length; 2, giving the value of each argument followed by its colon-suffixed; name (if any). For example, in the JSON representation of the dag; value ``(Op 22, ""hello"":$foo)`` (assuming that ``Op`` is the name of; a record defined elsewhere with a ``def`` statement):. * ``operator`` will be an object in which ``kind==""def""`` and; ``def==""Op""``. * ``args`` will be the array ``[[22, null], [""hello"", ""foo""]]``. * If any other kind of va",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst:18758,variab,variable,18758,interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,2,['variab'],['variable']
Modifiability,"nt or ""::attr"" if not.; * ``handleDeclAttribute``, which is the function that applies the attribute to; a declaration. It is responsible for checking that the attribute's arguments; are valid, and typically applies the attribute by adding an ``Attr`` to the; ``Decl``. It returns either ``AttributeApplied``, to indicate that the; attribute was successfully applied, or ``AttributeNotApplied`` if it wasn't. The members of ``ParsedAttrInfo`` that may need to be defined, depending on the; attribute, are:. * ``NumArgs`` and ``OptArgs``, which set the number of required and optional; arguments to the attribute.; * ``diagAppertainsToDecl``, which checks if the attribute has been used on the; right kind of declaration and issues a diagnostic if not.; * ``diagLangOpts``, which checks if the attribute is permitted for the current; language mode and issues a diagnostic if not.; * ``existsInTarget``, which checks if the attribute is permitted for the given; target. To see a working example of an attribute plugin, see `the Attribute.cpp example; <https://github.com/llvm/llvm-project/blob/main/clang/examples/Attribute/Attribute.cpp>`_. Putting it all together; =======================. Let's look at an example plugin that prints top-level function names. This; example is checked into the clang repository; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:3925,plugin,plugin,3925,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,1,['plugin'],['plugin']
Modifiability,"nt to describe. The instance variables for an ARC-compiled class will be destroyed at some; point after control enters the ``dealloc`` method for the root class of the; class. The ordering of the destruction of instance variables is unspecified,; both within a single class and between subclasses and superclasses. .. admonition:: Rationale. The traditional, non-ARC pattern for destroying instance variables is to; destroy them immediately before calling ``[super dealloc]``. Unfortunately,; message sends from the superclass are quite capable of reaching methods in; the subclass, and those methods may well read or write to those instance; variables. Making such message sends from dealloc is generally discouraged,; since the subclass may well rely on other invariants that were broken during; ``dealloc``, but it's not so inescapably dangerous that we felt comfortable; calling it undefined behavior. Therefore we chose to delay destroying the; instance variables to a point at which message sends are clearly disallowed:; the point at which the root class's deallocation routines take over. In most code, the difference is not observable. It can, however, be observed; if an instance variable holds a strong reference to an object whose; deallocation will trigger a side-effect which must be carefully ordered with; respect to the destruction of the super class. Such code violates the design; principle that semantically important behavior should be explicit. A simple; fix is to clear the instance variable manually during ``dealloc``; a more; holistic solution is to move semantically important side-effects out of; ``dealloc`` and into a separate teardown phase which can rely on working with; well-formed objects. .. _arc.misc.autoreleasepool:. ``@autoreleasepool``; --------------------. To simplify the use of autorelease pools, and to bring them under the control; of the compiler, a new kind of statement is available in Objective-C. It is; written ``@autoreleasepool`` followed by a *c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:89665,variab,variables,89665,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variables']
Modifiability,"nt() method should allocate space for one; more element (using default constructor if element is a C++ object) and returns; a reference to that new allocated space. Flow Sequence; -------------; A YAML ""flow sequence"" is a sequence that when written to YAML it uses the; inline notation (e.g [ foo, bar ] ). To specify that a sequence type should; be written in YAML as a flow sequence, your SequenceTraits specialization should; add ""static const bool flow = true;"". For instance:. .. code-block:: c++. template <>; struct SequenceTraits<MyList> {; static size_t size(IO &io, MyList &list) { ... }; static MyListEl &element(IO &io, MyList &list, size_t index) { ... }. // The existence of this member causes YAML I/O to use a flow sequence; static const bool flow = true;; };. With the above, if you used MyList as the data type in your native data; structures, then when converted to YAML, a flow sequence of integers; will be used (e.g. [ 10, -3, 4 ]). Flow sequences are subject to line wrapping according to the Output object; configuration. Utility Macros; --------------; Since a common source of sequences is std::vector<>, YAML I/O provides macros:; LLVM_YAML_IS_SEQUENCE_VECTOR() and LLVM_YAML_IS_FLOW_SEQUENCE_VECTOR() which; can be used to easily specify SequenceTraits<> on a std::vector type. YAML; I/O does not partial specialize SequenceTraits on std::vector<> because that; would force all vectors to be sequences. An example use of the macros:. .. code-block:: c++. std::vector<MyType1>;; std::vector<MyType2>;; LLVM_YAML_IS_SEQUENCE_VECTOR(MyType1); LLVM_YAML_IS_FLOW_SEQUENCE_VECTOR(MyType2). Document List; =============. YAML allows you to define multiple ""documents"" in a single YAML file. Each; new document starts with a left aligned ""---"" token. The end of all documents; is denoted with a left aligned ""..."" token. Many users of YAML will never; have need for multiple documents. The top level node in their YAML schema; will be a mapping or sequence. For those cases, the f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:26608,config,configuration,26608,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['config'],['configuration']
Modifiability,"nt(0, integerLiteral(equals(42)))); matches the expression in both doCall and doConstruct. Matcher<*>optionallyMatcher<*>; Matches any node regardless of the submatcher. However, optionally will retain any bindings generated by the submatcher.; Useful when additional information which may or may not present about a main; matching node is desired. For example, in:; class Foo {; int bar;; }; The matcher:; cxxRecordDecl(; optionally(has(; fieldDecl(hasName(""bar"")).bind(""var""); ))).bind(""record""); will produce a result binding for both ""record"" and ""var"".; The matcher will produce a ""record"" binding for even if there is no data; member named ""bar"" in that class. Usable as: Any Matcher. Matcher<*>traverseTraversalKind TK, Matcher<*> InnerMatcher; Causes all nested matchers to be matched with the specified traversal kind. Given; void foo(); {; int i = 3.0;; }; The matcher; traverse(TK_IgnoreUnlessSpelledInSource,; varDecl(hasInitializer(floatLiteral().bind(""init""))); ); matches the variable declaration with ""init"" bound to the ""3.0"". Matcher<AbstractConditionalOperator>hasConditionMatcher<Expr> InnerMatcher; Matches the condition expression of an if statement, for loop,; switch statement or conditional operator. Example matches true (matcher = hasCondition(cxxBoolLiteral(equals(true)))); if (true) {}. Matcher<AbstractConditionalOperator>hasFalseExpressionMatcher<Expr> InnerMatcher; Matches the false branch expression of a conditional operator; (binary or ternary). Example matches b; condition ? a : b; condition ?: b. Matcher<AbstractConditionalOperator>hasTrueExpressionMatcher<Expr> InnerMatcher; Matches the true branch expression of a conditional operator. Example 1 (conditional ternary operator): matches a; condition ? a : b. Example 2 (conditional binary operator): matches opaqueValueExpr(condition); condition ?: b. Matcher<AddrLabelExpr>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:136640,variab,variable,136640,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['variab'],['variable']
Modifiability,"nt. So the; element with index ``i`` corresponds to the bit described as; ``x{i}`` in TableGen source. However, note that this means that; scripting languages are likely to *display* the array in the; opposite order from the way it appears in the TableGen source or in; the diagnostic ``-print-records`` output. All other TableGen value types are emitted as a JSON object,; containing two standard fields: ``kind`` is a discriminator describing; which kind of value the object represents, and ``printable`` is a; string giving the same representation of the value that would appear; in ``-print-records``. * A reference to a ``def`` object has ``kind==""def""``, and has an; extra field ``def`` giving the name of the object referred to. * A reference to another variable in the same record has; ``kind==""var""``, and has an extra field ``var`` giving the name of; the variable referred to. * A reference to a specific bit of a ``bits``-typed variable in the; same record has ``kind==""varbit""``, and has two extra fields:; ``var`` gives the name of the variable referred to, and ``index``; gives the index of the bit. * A value of type ``dag`` has ``kind==""dag""``, and has two extra; fields. ``operator`` gives the initial value after the opening; parenthesis of the dag initializer; ``args`` is an array giving the; following arguments. The elements of ``args`` are arrays of length; 2, giving the value of each argument followed by its colon-suffixed; name (if any). For example, in the JSON representation of the dag; value ``(Op 22, ""hello"":$foo)`` (assuming that ``Op`` is the name of; a record defined elsewhere with a ``def`` statement):. * ``operator`` will be an object in which ``kind==""def""`` and; ``def==""Op""``. * ``args`` will be the array ``[[22, null], [""hello"", ""foo""]]``. * If any other kind of value or complicated expression appears in the; output, it will have ``kind==""complex""``, and no additional fields.; These values are not expected to be needed by backends. The standard; ``pri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst:18937,variab,variable,18937,interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,2,['variab'],['variable']
Modifiability,"nt. Switch statement body is always indented one level more than; case labels (except the first block following the case label, which; itself indents the code - unless IndentCaseBlocks is enabled). .. code-block:: c++. false: true:; switch (fool) { vs. switch (fool) {; case 1: case 1:; bar(); bar();; break; break;; default: default:; plop(); plop();; } }. .. _IndentExternBlock:. **IndentExternBlock** (``IndentExternBlockStyle``) :versionbadge:`clang-format 11` :ref:`¶ <IndentExternBlock>`; IndentExternBlockStyle is the type of indenting of extern blocks. Possible values:. * ``IEBS_AfterExternBlock`` (in configuration: ``AfterExternBlock``); Backwards compatible with AfterExternBlock's indenting. .. code-block:: c++. IndentExternBlock: AfterExternBlock; BraceWrapping.AfterExternBlock: true; extern ""C""; {; void foo();; }. .. code-block:: c++. IndentExternBlock: AfterExternBlock; BraceWrapping.AfterExternBlock: false; extern ""C"" {; void foo();; }. * ``IEBS_NoIndent`` (in configuration: ``NoIndent``); Does not indent extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. * ``IEBS_Indent`` (in configuration: ``Indent``); Indents extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. .. _IndentGotoLabels:. **IndentGotoLabels** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <IndentGotoLabels>`; Indent goto labels. When ``false``, goto labels are flushed left. .. code-block:: c++. true: false:; int f() { vs. int f() {; if (foo()) { if (foo()) {; label1: label1:; bar(); bar();; } }; label2: label2:; return 1; return 1;; } }. .. _IndentPPDirectives:. **IndentPPDirectives** (``PPDirectiveIndentStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IndentPPDirectives>`; The preprocessor directive indenting style to use. Possible values:. * ``PPDIS_None`` (in configuration: ``None``); Does not indent any directives. .. code-block:: c++. #if FOO; #if BAR; #include <foo>; #endif; #endif. * ``PPDIS_AfterHash`` (in configuration: ``AfterHash``); Indents directi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:72365,config,configuration,72365,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"nt_8 = 0 '\000'}}. In the above, the values of `v` and `a` are clearly expressed, as are the; temporary values for `await_counter` (`class_await_counter_1` and; `class_await_counter_2`) and `std::suspend_always` (; `struct_std__suspend_always_0` and `struct_std__suspend_always_3`). The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the first `co_await await_counter{};` in `coro_task`. Note that the; first initial suspend point is the compiler generated; `co_await promise_type::initial_suspend()`. However, when optimizations are enabled, the printed result changes drastically:. .. parsed-literal::. {__resume_fn = 0x401280 <coro_task(int)>, __destroy_fn = 0x401390 <coro_task(int)>, __promise = {count = 1}, __int_32_0 = 43, __coro_index = 1 '\001'}. Unused values are optimized out, as well as the name of the local variable `a`.; The only information remained is the value of a 32 bit integer. In this simple; case, it seems to be pretty clear that `__int_32_0` represents `a`. However, it; is not true. An important note with optimization is that the value of a variable may not; properly express the intended value in the source code. For example:. .. code-block:: c++. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++; // __int_32_0 is 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here; std::cout << a << ""\n"";; a++; // __int_32_0 is still 43 here!; std::cout << a << ""\n"";; co_await await_counter{};; a++; // __int_32_0 is still 43 here!!; std::cout << a << ""\n"";; a++; // Why is __int_32_0 still 43 here?; std::cout << a << ""\n"";; }. When debugging step-by-step, the value of `__int_32_0` seemingly does not; change, despite being frequently incremented, and instead is always `43`.; While this might be surprising, this is a result of t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:8623,variab,variable,8623,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['variab'],['variable']
Modifiability,"nt`` (in configuration: ``NoIndent``); Does not indent extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. * ``IEBS_Indent`` (in configuration: ``Indent``); Indents extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. .. _IndentGotoLabels:. **IndentGotoLabels** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <IndentGotoLabels>`; Indent goto labels. When ``false``, goto labels are flushed left. .. code-block:: c++. true: false:; int f() { vs. int f() {; if (foo()) { if (foo()) {; label1: label1:; bar(); bar();; } }; label2: label2:; return 1; return 1;; } }. .. _IndentPPDirectives:. **IndentPPDirectives** (``PPDirectiveIndentStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IndentPPDirectives>`; The preprocessor directive indenting style to use. Possible values:. * ``PPDIS_None`` (in configuration: ``None``); Does not indent any directives. .. code-block:: c++. #if FOO; #if BAR; #include <foo>; #endif; #endif. * ``PPDIS_AfterHash`` (in configuration: ``AfterHash``); Indents directives after the hash. .. code-block:: c++. #if FOO; # if BAR; # include <foo>; # endif; #endif. * ``PPDIS_BeforeHash`` (in configuration: ``BeforeHash``); Indents directives before the hash. .. code-block:: c++. #if FOO; #if BAR; #include <foo>; #endif; #endif. .. _IndentRequiresClause:. **IndentRequiresClause** (``Boolean``) :versionbadge:`clang-format 15` :ref:`¶ <IndentRequiresClause>`; Indent the requires clause in a template. This only applies when; ``RequiresClausePosition`` is ``OwnLine``, or ``WithFollowing``. In clang-format 12, 13 and 14 it was named ``IndentRequires``. .. code-block:: c++. true:; template <typename It>; requires Iterator<It>; void sort(It begin, It end) {; //....; }. false:; template <typename It>; requires Iterator<It>; void sort(It begin, It end) {; //....; }. .. _IndentWidth:. **IndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <IndentWidth>`; The number of columns to use for indentation. .. code-block:: c++. I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:73337,config,configuration,73337,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ntain; other required passes. An example of how a pass can be skipped is the ``optnone`` function; attribute, which specifies that optimizations should not be run on the; function. Required passes will still be run on ``optnone`` functions. For more implementation details, see; ``PassInstrumentation::runBeforePass()``. Registering passes as plugins; -----------------------------. LLVM provides a mechanism to register pass plugins within various tools like; ``clang`` or ``opt``. A pass plugin can add passes to default optimization; pipelines or to be manually run via tools like ``opt``. For more information,; see :doc:`NewPassManager`. Create a CMake project at the root of the repo alongside; other projects. This project must contain the following minimal; ``CMakeLists.txt``:. .. code-block:: cmake. add_llvm_pass_plugin(MyPassName source.cpp). See the definition of ``add_llvm_pass_plugin`` for more CMake details. The pass must provide at least one of two entry points for the new pass manager,; one for static registration and one for dynamically loaded plugins:. - ``llvm::PassPluginLibraryInfo get##Name##PluginInfo();``; - ``extern ""C"" ::llvm::PassPluginLibraryInfo llvmGetPassPluginInfo() LLVM_ATTRIBUTE_WEAK;``. Pass plugins are compiled and linked dynamically by default. Setting; ``LLVM_${NAME}_LINK_INTO_TOOLS`` to ``ON`` turns the project into a statically; linked extension. For an in-tree example, see ``llvm/examples/Bye/``. To make ``PassBuilder`` aware of statically linked pass plugins:. .. code-block:: c++. // Declare plugin extension function declarations.; #define HANDLE_EXTENSION(Ext) llvm::PassPluginLibraryInfo get##Ext##PluginInfo();; #include ""llvm/Support/Extension.def"". ... // Register plugin extensions in PassBuilder.; #define HANDLE_EXTENSION(Ext) get##Ext##PluginInfo().RegisterPassBuilderCallbacks(PB);; #include ""llvm/Support/Extension.def"". To make ``PassBuilder`` aware of dynamically linked pass plugins:. .. code-block:: c++. // Load plugin dynamical",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst:8049,plugin,plugins,8049,interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,1,['plugin'],['plugins']
Modifiability,"ntaining source code is opened in a ROOT; session that does not have the class code already loaded for the classes; contained in the workspace, the code in the workspace is written to file,; compiled and loaded into the ROOT session on the fly. The code repository of RooWorkspace is designed to handle classes that; have either their own implementation and header file, or are part of a group; of classes that share a common header and implementation file. More complicated; structuring of source code into files is not supported. ; ; Also new accessors have been added for discrete-valued functions catfunc(); and stored category functions are now also printed under their own heading in Print(); Parameterized ranges. It is now possible to use RooAbsReal derived functions as range definition for variables; to construct ranges that vary as function of another variable. For example. RooRealVar x(""x"",""x"",-10,10) ; // variable with fixed range [-10,10] ; RooRealVar y(""y"",""y"",0,20) ; // variable with fixed range [-10,10] ; ; RooFormulaVar x_lo(""x_lo"",""y-20"",y) ; ; RooFormulaVar x_hi(""x_hi"",""sin(y)*5"",y) ; ; x.setRange(x_lo,x_hi) ; // Change x to have variable range depending on y; ; It is also possible to define parameterized named ranges in the same way. x.setRange(""signalRegion"",x_lo,x_hi) ;. There are no fundamental limits to the complexity of the parameterized ranges; that can be defined as long as the problem is uniquely defined. For example, given three observables ; x, y and z, one can define a parameterized named range 'R' of x in terms of y and of y in terms of z; and ask to calculate the three dimensional integral of any function or p.d.f in terms of (x,y,z); over that range 'R' and it will be calculated correctly, taking recursive range dependencies into; account. A definition of a range 'R' on the other hand where the bounds of x depend on y and; the bounds of y depend on x is not allowed, and an error message will be printed to complain about; the ambiguity of the p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:3384,variab,variable,3384,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,4,['variab'],['variable']
Modifiability,"ntains the number of entries in the bin `j`. - `e[j]` or `s[j]` will be the resulting error depending on the; selected option. See ""Build Options"". ``` {.cpp}; E[j] = sum Y**2; L[j] = number of entries in bin J; H[j] = sum Y; h[j] = H[j] / L[j]; s[j] = sqrt[E[j] / L[j] - h[j]**2]; e[j] = s[j] / sqrt[L[j]]; ```. In the special case where `s[j]` is zero, when there is only one entry; per bin, `e[j]` is computed from the average of the `s[j]` for all; bins. This approximation is used to keep the bin during a fit; operation. The **`TProfile`** constructor takes up to eight arguments.; The first five parameters are similar to **`TH1D`** constructor. ``` {.cpp}; TProfile(const char *name,const char *title,Int_t nbinsx,; Double_t xlow, Double_t xup, Double_t ylow, Double_t yup,; Option_t *option); ```. All values of `y` are accepted at filling time. To fill a profile; histogram, you must use **`TProfile`**`::Fill` function. Note that; when filling the profile histogram the method **`TProfile`**`::Fill`; checks if the variable `y` is between `fYmin` and `fYmax`. If a; minimum or maximum value is set for the Y scale before filling, then; all values below `ylow` or above `yup` will be discarded. Setting the; minimum or maximum value for the Y scale before filling has the same; effect as calling the special **`TProfile`** constructor above where; `ylow` and `yup` are specified. ### Build Options. The last parameter is the build option. If a bin has N data points all; with the same value Y, which is the case when dealing with integers,; the spread in Y for that bin is zero, and the uncertainty assigned is; also zero, and the bin is ignored in making subsequent fits. If; `SQRT(Y)` was the correct error in the case above, then; `SQRT(Y)/SQRT(N)` would be the correct error here. In fact, any bin; with non-zero number of entries N but with zero spread; (`spread = s[j]`) should have an uncertainty `SQRT(Y)/SQRT(N)`. Now,; is `SQRT(Y)/SQRT(N)` really the correct uncertainty ? That it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:63166,variab,variable,63166,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['variab'],['variable']
Modifiability,"ntation are in :doc:`Block-ABI-Apple<Block-ABI-Apple>`. Query for this feature with ``__has_extension(blocks)``. ASM Goto with Output Constraints; ================================. Outputs may be used along any branches from the ``asm goto`` whether the; branches are taken or not. Query for this feature with ``__has_extension(gnu_asm_goto_with_outputs)``. Prior to clang-16, the output may only be used safely when the indirect; branches are not taken. Query for this difference with; ``__has_extension(gnu_asm_goto_with_outputs_full)``. When using tied-outputs (i.e. outputs that are inputs and outputs, not just; outputs) with the `+r` constraint, there is a hidden input that's created; before the label, so numeric references to operands must account for that. .. code-block:: c++. int foo(int x) {; // %0 and %1 both refer to x; // %l2 refers to err; asm goto(""# %0 %1 %l2"" : ""+r""(x) : : : err);; return x;; err:; return -1;; }. This was changed to match GCC in clang-13; for better portability, symbolic; references can be used instead of numeric references. .. code-block:: c++. int foo(int x) {; asm goto(""# %[x] %l[err]"" : [x]""+r""(x) : : : err);; return x;; err:; return -1;; }. Objective-C Features; ====================. Related result types; --------------------. According to Cocoa conventions, Objective-C methods with certain names; (""``init``"", ""``alloc``"", etc.) always return objects that are an instance of; the receiving class's type. Such methods are said to have a ""related result; type"", meaning that a message send to one of these methods will have the same; static type as an instance of the receiver class. For example, given the; following classes:. .. code-block:: objc. @interface NSObject; + (id)alloc;; - (id)init;; @end. @interface NSArray : NSObject; @end. and this common initialization pattern. .. code-block:: objc. NSArray *array = [[NSArray alloc] init];. the type of the expression ``[NSArray alloc]`` is ``NSArray*`` because; ``alloc`` implicitly has a relate",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:67852,portab,portability,67852,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['portab'],['portability']
Modifiability,"ntation. See; ``xray/xray_log_interface.h`` for details, part of the XRay compiler-rt; installation. Once a logging implementation has been initialized, it can be ""stopped"" by; finalizing the implementation through the ``__xray_log_finalize()`` function.; The finalization routine is the opposite of the initialization. When finalized,; an implementation's data can be cleared out through the; ``__xray_log_flushLog()`` function. For implementations that support in-memory; processing, these should register an iterator function to provide access to the; data via the ``__xray_log_set_buffer_iterator(...)`` which allows code calling; the ``__xray_log_process_buffers(...)`` function to deal with the data in; memory. All of this is better explained in the ``xray/xray_log_interface.h`` header. Basic Mode; ----------. XRay supports a basic logging mode which will trace the application's; execution, and periodically append to a single log. This mode can be; installed/enabled by setting ``xray_mode=xray-basic`` in the ``XRAY_OPTIONS``; environment variable. Combined with ``patch_premain=true`` this can allow for; tracing applications from start to end. Like all the other modes installed through ``__xray_log_select_mode(...)``, the; implementation can be configured through the ``__xray_log_init_mode(...)``; function, providing the mode string and the flag options. Basic-mode specific; defaults can be provided in the ``XRAY_BASIC_OPTIONS`` environment variable. Flight Data Recorder Mode; -------------------------. XRay supports a logging mode which allows the application to only capture a; fixed amount of memory's worth of events. Flight Data Recorder (FDR) mode works; very much like a plane's ""black box"" which keeps recording data to memory in a; fixed-size circular queue of buffers, and have the data available; programmatically until the buffers are finalized and flushed. To use FDR mode; on your application, you may set the ``xray_mode`` variable to ``xray-fdr`` in; the ``XRAY_O",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst:8339,variab,variable,8339,interpreter/llvm-project/llvm/docs/XRay.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst,1,['variab'],['variable']
Modifiability,"ntax (almost). ``` {.cpp}; root[] TBrowser *b = new TBrowser(); ```. ### Multi-line Commands. You can use the command line to execute multi-line commands. To begin; a multi-line command you must type a single left curly bracket `{`,; and to end it you must type a single right curly bracket `}`.; For example:. ``` {.cpp}; root[] {; end with '}'> Int_t j = 0;; end with '}'> for (Int_t i = 0; i < 3; i++); end with '}'> {; end with '}'> j= j + i;; end with '}'> cout << ""i = "" << i << "", j = "" << j << endl;; end with '}'> }; end with '}'> }; i = 0, j = 0; i = 1, j = 1; i = 2, j = 3; ```. It is more convenient to edit a script than the command line, and if; your multi line commands are getting unmanageable, you may want to; start with a script instead. ### Cling Extensions. We should say that some things are not standard C++. The Cling; interpreter has several extensions. See ""ROOT/Cling Extensions to C++"". ### Helpful Hints for Command Line Typing. The interpreter knows all the classes, functions, variables, and user; defined types. This enables ROOT to help users to complete the command; line. For example, if we do not know anything about the **`TLine`**; class, the Tab feature helps us to get a list of all classes starting; with **`TL`**(where `<TAB>` means type the Tab key). ``` {.cpp}; root[] l = new TLi<TAB>; TList; TListIter; TLink; TLine; TLimitDataSource; TLimit; ```. To list the different constructors and parameters for **`TLine`** use; the `<TAB>` key as follows:. ``` {.cpp}; root[] l = new TLine(<TAB>; TLine TLine(); TLine TLine(Double_t x1,Double_t y1,Double_t x2,Double_t y2); TLine TLine(const TLine& line); ```. ### Regular Expression. The meta-characters below can be used in a regular expression:. - '`^`' start-of-line anchor. - '`$`' end-of-line anchor. - '`.`' matches any character. - '`[`' start a character class. - '`]`'end a character class. - '`^`'negates character class if first character. - '`*`'`Kleene` closure (matches 0 or more). - '`+`'Positive ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:26726,variab,variables,26726,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['variab'],['variables']
Modifiability,"nted by extending the value caching originally designed; for constant terms to be usable for non-constant terms, with a check executed at the beginning of each; likelihood evaluation if selected columns need to be updated because parameters have changed. The speed gain; of this optimization depends much on the structure of the pdf: in models with many free parameters most of the; likelihood evaluations are executed when MINUIT calculates numerical likelihood derivatives which vary ; one parameter at a time and the speedup is potentially larger. In models with few free parameters the; effect will be smaller. The new per-component caching strategy is enabled by default for all pdfs that are a component of; a RooAddPdf or a RooRealSumPdf, unless that component is a RooProdPdf or a RooProduct, in that; case the components of the product are cached instead of the product itself. You can disable this; new optimization by adding Optimize(1) to the RooAbsPdf::fitTo() command line (0 = no caching,; 1 = cache constant terms only, 2 = cache also variable terms according to above mentioned strategy (DEFAULT)). It is also possible to tune this 'cache-and-track' optimization to perform a more fine-grained caching; of components than Optimize(2) implements: to do so, call arg->setAttribute(""CacheAndTrack"") on each; pdf component that you'd like to be cache-and-tracked individually. New pdf/data attach mechanism in likelihood objects (RooAbsOptTestStatistic). The new mechanism only; reattaches the dataset branch buffers and not the RooRealVars representing the data. This new designs; allows for a much faster RooAbsTestStatistic::setData() implementation, which changes the dataset in; an existing likelihood object. This will speed up RooStats tools based on 'simple' likelihood models; substantially. Automatic detections of 'binned' pdfs and automatic generation of binned data in generate(). RooFit will; now automatically generate binned pdf shapes. Binned pdfs shapes are fundamentall",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html:3621,variab,variable,3621,roofit/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html,2,['variab'],['variable']
Modifiability,"nted compilers."". `<https://github.com/eschulte/clang-mutate>`_; ""This tool performs a number of operations on C-language source files."". `<https://github.com/gmarpons/Crisp>`_; ""A coding rule validation add-on for LLVM/clang. Crisp rules are written; in Prolog. A high-level declarative DSL to easily write new rules is under; development. It will be called CRISP, an acronym for *Coding Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memory allocations to misusage of API, including fix-its for automatic; refactoring."". `<https://gerrit.libreoffice.org/gitweb?p=core.git;a=blob_plain;f=compilerplugins/README;hb=HEAD>`_; ""LibreOffice uses a Clang plugin infrastructu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:2943,variab,variables,2943,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,1,['variab'],['variables']
Modifiability,"nteger-overflow``: Signed integer overflow, where the; result of a signed integer computation cannot be represented in its type.; This includes all the checks covered by ``-ftrapv``, as well as checks for; signed division overflow (``INT_MIN/-1``), but not checks for; lossy implicit conversions performed before the computation; (see ``-fsanitize=implicit-conversion``). Both of these two issues are; handled by ``-fsanitize=implicit-conversion`` group of checks.; - ``-fsanitize=unreachable``: If control flow reaches an unreachable; program point.; - ``-fsanitize=unsigned-integer-overflow``: Unsigned integer overflow, where; the result of an unsigned integer computation cannot be represented in its; type. Unlike signed integer overflow, this is not undefined behavior, but; it is often unintentional. This sanitizer does not check for lossy implicit; conversions performed before such a computation; (see ``-fsanitize=implicit-conversion``).; - ``-fsanitize=vla-bound``: A variable-length array whose bound; does not evaluate to a positive value.; - ``-fsanitize=vptr``: Use of an object whose vptr indicates that it is of; the wrong dynamic type, or that its lifetime has not begun or has ended.; Incompatible with ``-fno-rtti``. Link must be performed by ``clang++``, not; ``clang``, to make sure C++-specific parts of the runtime library and C++; standard libraries are present. You can also use the following check groups:; - ``-fsanitize=undefined``: All of the checks listed above other than; ``float-divide-by-zero``, ``unsigned-integer-overflow``,; ``implicit-conversion``, ``local-bounds`` and the ``nullability-*`` group; of checks.; - ``-fsanitize=undefined-trap``: Deprecated alias of; ``-fsanitize=undefined``.; - ``-fsanitize=implicit-integer-truncation``: Catches lossy integral; conversions. Enables ``implicit-signed-integer-truncation`` and; ``implicit-unsigned-integer-truncation``.; - ``-fsanitize=implicit-integer-arithmetic-value-change``: Catches implicit; conversions th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:9638,variab,variable-length,9638,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['variab'],['variable-length']
Modifiability,"ntegrator2D` classes.; 6. The `RooRealAnalytic`, which was an implementation detail of the; `RooRealIntegral` class. ### Consistent default for `Extended()` command in RooAbsPdf::fitTo() and RooAbsPdf::chi2FitTo(). If no `RooFit::Extended()` command argument is passed, `RooAbsPdf::chi2FitTo()`; method now does an extended fit by default if the pdf is extendible. This makes; the behavior consistent with `RooAbsPdf::fitTo()`. Same applies to; `RooAbsPdf::createChi2()`. ## TMVA; ### SOFIE : Code generation for fast inference of Deep Learning models; TMVA SOFIE now supports parsing and further inference of Graph Neural Networks based on DeepMind's [graph_nets](https://github.com/google-deepmind/graph_nets). The list of all operators supported in the `RModel` class is the one provided below for the ONNX parser. #### SOFIE-GNN; 1. The SOFIE-GNN implementation brought a major change in SOFIE's architecture. Instead of having only the RModel class to store model information, now SOFIE has RModel, RModel_GNN and RModel_GraphIndependent classes which are inherited from RModel_Base.; 2. **RModel_GNN** is used to store a GNN model having nodes, edges, and globals with functions for their update and aggregate(for inter-relationships).; 3. **RModel_GraphIndependent** is used to store an independent Graph model with nodes, edges and globals with their individual update functions.; 4. **RFunctions** are used to declare update/aggregate operations over graph components. Currently supported RFunctions include:; - **Update Functions**; - RFunction_MLP; - **Aggregate Functions**; - RFunction_Mean; - RFunction_Sum; 5. Pythonized functions for parsing a Graphnets' model can be used to generate inference code; ```; import graph_nets as gn; from graph_nets import utils_tf. GraphModule = gn.modules.GraphNetwork(; edge_model_fn=lambda: snt.nets.MLP([2,2], activate_final=True),; node_model_fn=lambda: snt.nets.MLP([2,2], activate_final=True),; global_model_fn=lambda: snt.nets.MLP([2,2], activat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:17329,inherit,inherited,17329,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['inherit'],['inherited']
Modifiability,"ntent(3,3.);. c->cd(2); gPad->DrawFrame(4.,0., 10.,5.);; histo2->Draw(""same"");; }; ```; - In `TGraph2DPainter::PaintLevels` the colour levels used to paint; the triangles did not match the minimum and maximum set by the; user on the `TGraph2D`. This problem was reported; [here](http://root.cern.ch/phpBB3/viewtopic.php?f=3&t=16937&p=72314#p72314). ### TPaletteAxis. - The histogram Z axis title is now painted along the palette axis. ### TAxis. - The Axis has a new public bit `TAxis::kCanExtend`, which control the axis extensions (for example in case of time axis) and used to; replace the old bit `TH1::kCanRebin` (see below).; Note that this bit is automatically set when the axis has labels associated to each bin. In this case the axis becomes alphanumeric and; there is no more relation to the observed quantities. Note that when an axis is alphanumeric the mean and the rms of the histograms are not anymore; coputed and they are set to zero. ### TH1. - The bit `TH1::kCanRebin` used to extend the histogram axes is now deprecated. The bit exists still in ROOT 6.0 but it has no effect.; One should use now the new function `TH1::SetCanExtend(..)` passing the axis (using the appropriate enumeration), which needs to be extended.; In addition to extend each axis individually, the function can be used also to enable/disable extension for all axes.; For example `TH1::SetCanExtend(TH1::kXaxis)` will make extendable only the X axis; `TH1::SetCanExtend(TH1::kAllAxes)` will; make extendable all the axes (this is the same functionality of the previous function `SetBit(TH1::kCanRebin)` and; `TH1::SetCanExtend(TH1::kNoAxis)` will remove the extendable functionality to all the axes (equivalent to the old `ResetBit(TH1::kCanRebin)`).; The functionality of `TestBit(TH1::kCanRebin)` is now replaced by `TH1::CanExtendAllAxis()`. - An histogram filled with weights different than one has now automatically the sum of the weight squared stored inside, without the need to call anymore; `TH1::Sum",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md:7117,extend,extend,7117,hist/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md,1,['extend'],['extend']
Modifiability,"nterface which provides the user with more functionality; such as interaction with parameters. The core of the minimization functionality and related tools (the kernel; of M ) should be clearly separated from the user, who is interfacing via; defined user interfaces (the API). ## Internal and external parameters ##. Each of the parameters to the $\mbox{FCN}$ is defined by the user as; belonging to one of the following types:. - Freely variable: allowed to take on any value. - Variable with double sided limits: allowed to vary only between two; limits specified by the user. - Variable with single sided limits: allowed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely va",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:5714,variab,variable,5714,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability,"nteroperation between code using ``-fbounds-safety`` and code that does not. Default pointer types; ---------------------. ABI visibility and default annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Requiring ``-fbounds-safety`` adopters to add bounds annotations to all pointers; in the codebase would be a significant adoption burden. To avoid this and to; secure all pointers by default, ``-fbounds-safety`` applies default bounds; annotations to pointer types.; Default annotations apply to pointer types of declarations. ``-fbounds-safety`` applies default bounds annotations to pointer types used in; declarations. The default annotations are determined by the ABI visibility of; the pointer. A pointer type is ABI-visible if changing its size or; representation affects the ABI. For instance, changing the size of a type used; in a function parameter will affect the ABI and thus pointers used in function; parameters are ABI-visible pointers. On the other hand, changing the types of; local variables won't have such ABI implications. Hence, ``-fbounds-safety``; considers the outermost pointer types of local variables as non-ABI visible. The; rest of the pointers such as nested pointer types, pointer types of global; variables, struct fields, and function prototypes are considered ABI-visible. All ABI-visible pointers are treated as ``__single`` by default unless annotated; otherwise. This default both preserves ABI and makes these pointers safe by; default. This behavior can be controlled with macros, i.e.,; ``__ptrcheck_abi_assume_*ATTR*()``, to set the default annotation for; ABI-visible pointers to be either ``__single``, ``__bidi_indexable``,; ``__indexable``, or ``__unsafe_indexable``. For instance,; ``__ptrcheck_abi_assume_unsafe_indexable()`` will make all ABI-visible pointers; be ``__unsafe_indexable``. Non-ABI visible pointers — the outermost pointer; types of local variables — are ``__bidi_indexable`` by default, so that these; pointers have the bounds inform",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:20865,variab,variables,20865,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['variab'],['variables']
Modifiability,"ntials have not been established on both ends. Now stop the; worker and proceed to the next steps. #. Fill the buildbot-worker description and admin name/e-mail. Here is an; example of the buildbot-worker description::. Windows 7 x64; Core i7 (2.66GHz), 16GB of RAM. g++.exe (TDM-1 mingw32) 4.4.0; GNU Binutils 2.19.1; cmake version 2.8.4; Microsoft(R) 32-bit C/C++ Optimizing Compiler Version 16.00.40219.01 for 80x86. See `here <http://docs.buildbot.net/current/manual/installation/worker.html>`_; for which files to edit. #. Send a patch which adds your build worker and your builder to; `zorg <https://github.com/llvm/llvm-zorg>`_. Use the typical LLVM; `workflow <https://llvm.org/docs/Contributing.html#how-to-submit-a-patch>`_. * workers are added to ``buildbot/osuosl/master/config/workers.py``; * builders are added to ``buildbot/osuosl/master/config/builders.py``. Please make sure your builder name and its builddir are unique through the; file. All new builders should default to using the ""'collapseRequests': False""; configuration. This causes the builder to build each commit individually; and not merge build requests. To maximize quality of feedback to developers,; we *strongly prefer* builders to be configured not to collapse requests.; This flag should be removed only after all reasonable efforts have been; exhausted to improve build times such that the builder can keep up with; commit flow. It is possible to allow email addresses to unconditionally receive; notifications on build failure; for this you'll need to add an; ``InformativeMailNotifier`` to ``buildbot/osuosl/master/config/status.py``.; This is particularly useful for the staging buildmaster which is silent; otherwise. #. Send the buildbot-worker access name and the access password directly to; `Galina Kistanova <mailto:gkistanova@gmail.com>`_, and wait until she; lets you know that your changes are applied and buildmaster is; reconfigured. #. Make sure you can start the buildbot-worker and successfully co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:5582,config,configuration,5582,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['config'],['configuration']
Modifiability,"ntifier ('=' expression)?)* 'in' expression; static std::unique_ptr<ExprAST> ParseVarExpr() {; getNextToken(); // eat the var. std::vector<std::pair<std::string, std::unique_ptr<ExprAST>>> VarNames;. // At least one variable name is required.; if (CurTok != tok_identifier); return LogError(""expected identifier after var"");. The first part of this code parses the list of identifier/expr pairs; into the local ``VarNames`` vector. .. code-block:: c++. while (true) {; std::string Name = IdentifierStr;; getNextToken(); // eat identifier. // Read the optional initializer.; std::unique_ptr<ExprAST> Init;; if (CurTok == '=') {; getNextToken(); // eat the '='. Init = ParseExpression();; if (!Init) return nullptr;; }. VarNames.push_back(std::make_pair(Name, std::move(Init)));. // End of var list, exit loop.; if (CurTok != ',') break;; getNextToken(); // eat the ','. if (CurTok != tok_identifier); return LogError(""expected identifier list after var"");; }. Once all the variables are parsed, we then parse the body and create the; AST node:. .. code-block:: c++. // At this point, we have to have 'in'.; if (CurTok != tok_in); return LogError(""expected 'in' keyword after 'var'"");; getNextToken(); // eat 'in'. auto Body = ParseExpression();; if (!Body); return nullptr;. return std::make_unique<VarExprAST>(std::move(VarNames),; std::move(Body));; }. Now that we can parse and represent the code, we need to support; emission of LLVM IR for it. This code starts out with:. .. code-block:: c++. Value *VarExprAST::codegen() {; std::vector<AllocaInst *> OldBindings;. Function *TheFunction = Builder->GetInsertBlock()->getParent();. // Register all variables and emit their initializer.; for (unsigned i = 0, e = VarNames.size(); i != e; ++i) {; const std::string &VarName = VarNames[i].first;; ExprAST *Init = VarNames[i].second.get();. Basically it loops over all the variables, installing them one at a; time. For each variable we put into the symbol table, we remember the; previous value that we",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:26067,variab,variables,26067,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability,"ntifier is annotated as a pointer or reference token instead of a; binary operator. .. _TypenameMacros:. **TypenameMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <TypenameMacros>`; A vector of macros that should be interpreted as type declarations; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. STACK_OF(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. TypenameMacros: ['STACK_OF', 'LIST']. For example: OpenSSL STACK_OF, BSD LIST_ENTRY. .. _UseCRLF:. **UseCRLF** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <UseCRLF>`; This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``. .. _UseTab:. **UseTab** (``UseTabStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <UseTab>`; The way to use tab characters in the resulting file. Possible values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:132181,config,configuration,132181,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ntil the corresponding ``S_END`` record. Finally, there are three general categories of symbol record, grouped by where they are legal; to appear in a PDB file. Public Symbols (which appear only in the; :doc:`publics stream <PublicStream>`), Global Symbols (which appear only in the; :doc:`globals stream <GlobalStream>`) and module symbols (which appear in the; :doc:`module info stream <ModiStream>`). .. _public_symbols:. Public Symbols; --------------. Public symbols are the CodeView equivalent of DWARF ``.debug_pubnames``. There; is one public symbol record for every function or variable in the program that; has a mangled name. The :doc:`Publics Stream <PublicStream>`, which contains these; records, additionally contains a hash table that allows one to quickly locate a; record by mangled name. S_PUB32 (0x110e); ^^^^^^^^^^^^^^^^. There is only type of public symbol, an ``S_PUB32`` which describes a mangled; name, a flag indicating what kind of symbol it is (e.g. function, variable), and; the symbol's address. The :ref:`dbi_section_map_substream` of the; :doc:`DBI Stream <DbiStream>` can be consulted to determine what module this address; corresponds to, and from there that module's :doc:`module debug stream <ModiStream>`; can be consulted to locate full information for the symbol with the given address. .. _global_symbols:. Global Symbols; --------------. While there is one :ref:`public symbol <public_symbols>` for every symbol in the; program with `external` linkage, there is one global symbol for every symbol in the; program with linkage (including internal linkage). As a result, global symbols do; not describe a mangled name *or* an address, since symbols with internal linkage; need not have any mangling at all, and also may not have an address. Thus, all; global symbols simply refer directly to the full symbol record via a module/offset; combination. Similarly to :ref:`public symbols <public_symbols>`, all global symbols are contained; in a single :doc:`Globals ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewSymbols.rst:2945,variab,variable,2945,interpreter/llvm-project/llvm/docs/PDB/CodeViewSymbols.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewSymbols.rst,1,['variab'],['variable']
Modifiability,"ntire selector from ``.td`` file. .. _SSA-based Machine Code Optimizations:. SSA-based Machine Code Optimizations; ------------------------------------. To Be Written. Live Intervals; --------------. Live Intervals are the ranges (intervals) where a variable is *live*. They are; used by some `register allocator`_ passes to determine if two or more virtual; registers which require the same physical register are live at the same point in; the program (i.e., they conflict). When this situation occurs, one virtual; register must be *spilled*. Live Variable Analysis; ^^^^^^^^^^^^^^^^^^^^^^. The first step in determining the live intervals of variables is to calculate; the set of registers that are immediately dead after the instruction (i.e., the; instruction calculates the value, but it is never used) and the set of registers; that are used by the instruction, but are never used after the instruction; (i.e., they are killed). Live variable information is computed for; each *virtual* register and *register allocatable* physical register; in the function. This is done in a very efficient manner because it uses SSA to; sparsely compute lifetime information for virtual registers (which are in SSA; form) and only has to track physical registers within a block. Before register; allocation, LLVM can assume that physical registers are only live within a; single basic block. This allows it to do a single, local analysis to resolve; physical register lifetimes within each basic block. If a physical register is; not register allocatable (e.g., a stack pointer or condition codes), it is not; tracked. Physical registers may be live in to or out of a function. Live in values are; typically arguments in registers. Live out values are typically return values in; registers. Live in values are marked as such, and are given a dummy ""defining""; instruction during live intervals analysis. If the last basic block of a; function is a ``return``, then it's marked as using all live out values i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:55215,variab,variable,55215,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['variab'],['variable']
Modifiability,"ntly automatically link against libatomic when using; libgcc_s. You may need to manually add ``-latomic`` to support this; configuration when using non-native atomic operations (if you see link errors; referring to ``__atomic_*`` functions). Unwind library; --------------. The unwind library provides a family of ``_Unwind_*`` functions implementing; the language-neutral stack unwinding portion of the Itanium C++ ABI; (`Level I <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-abi>`_).; It is a dependency of the C++ ABI library, and sometimes is a dependency; of other runtimes. libunwind (LLVM); ^^^^^^^^^^^^^^^^. LLVM's unwinder library is part of the llvm-project git repository. To; build it, pass ``-DLLVM_ENABLE_RUNTIMES=libunwind`` to the cmake invocation. If using libc++abi, you may need to configure it to use libunwind; rather than libgcc_s by passing ``-DLIBCXXABI_USE_LLVM_UNWINDER=YES``; to ``cmake``. If libc++abi is configured to use some version of; libunwind, that library will be implicitly linked into binaries that; link to libc++abi. libgcc_s (GNU); ^^^^^^^^^^^^^^. libgcc_s has an integrated unwinder, and does not need an external unwind; library to be provided. libunwind (nongnu.org); ^^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (nongnu.org) <https://www.nongnu.org/libunwind>`_. libunwind (PathScale); ^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (pathscale) <https://github.com/pathscale/libunwind>`_. Sanitizer runtime; -----------------. The instrumentation added by Clang's sanitizers (``-fsanitize=...``) implicitly; makes calls to a runtime library, in order to maintain side state about the; execution of the program and to issue diagnostic messages when a problem is; detected. The only supported implementation of these runtimes is provided by LLVM's; compiler-rt, and the relevant portion of that library; (``libclang_rt.<sanitizer>",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:8970,config,configured,8970,interpreter/llvm-project/clang/docs/Toolchain.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst,1,['config'],['configured']
Modifiability,"ntrinsics. For these; cases, ``PassBuilder`` exposes callbacks that allow injecting passes into; certain parts of the pipeline. For example,. .. code-block:: c++. PassBuilder PB;; PB.registerPipelineStartEPCallback([&](ModulePassManager &MPM,; PassBuilder::OptimizationLevel Level) {; MPM.addPass(FooPass());; };. will add ``FooPass`` near the very beginning of the pipeline for pass; managers created by that ``PassBuilder``. See the documentation for; ``PassBuilder`` for the various places that passes can be added. If a ``PassBuilder`` has a corresponding ``TargetMachine`` for a backend, it; will call ``TargetMachine::registerPassBuilderCallbacks()`` to allow the; backend to inject passes into the pipeline. Clang's ``BackendUtil.cpp`` shows examples of a frontend adding (mostly; sanitizer) passes to various parts of the pipeline.; ``AMDGPUTargetMachine::registerPassBuilderCallbacks()`` is an example of a; backend adding passes to various parts of the pipeline. Pass plugins can also add passes into default pipelines. Different tools have; different ways of loading dynamic pass plugins. For example, ``opt; -load-pass-plugin=path/to/plugin.so`` loads a pass plugin into ``opt``. For; information on writing a pass plugin, see :doc:`WritingAnLLVMNewPMPass`. Using Analyses; ==============. LLVM provides many analyses that passes can use, such as a dominator tree.; Calculating these can be expensive, so the new pass manager has; infrastructure to cache analyses and reuse them when possible. When a pass runs on some IR, it also receives an analysis manager which it can; query for analyses. Querying for an analysis will cause the manager to check if; it has already computed the result for the requested IR. If it already has and; the result is still valid, it will return that. Otherwise it will construct a; new result by calling the analysis's ``run()`` method, cache it, and return it.; You can also ask the analysis manager to only return an analysis if it's; already cached. The ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:6475,plugin,plugins,6475,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['plugin'],['plugins']
Modifiability,"ntrol flow constructs you would expect in any; scripting language, but there are a few quirks because, as with everything in; CMake, control flow constructs are commands. If, ElseIf, Else; ----------------. .. note::; For the full documentation on the CMake if command go; `here <https://cmake.org/cmake/help/v3.4/command/if.html>`_. That resource is; far more complete. In general CMake if blocks work the way you'd expect:. .. code-block:: cmake. if(<condition>); message(""do stuff""); elseif(<condition>); message(""do other stuff""); else(); message(""do other other stuff""); endif(). The single most important thing to know about CMake's if blocks coming from a C; background is that they do not have their own scope. Variables set inside; conditional blocks persist after the ``endif()``. Loops; -----. The most common form of the CMake ``foreach`` block is:. .. code-block:: cmake. foreach(var ...); message(""do stuff""); endforeach(). The variable argument portion of the ``foreach`` block can contain dereferenced; lists, values to iterate, or a mix of both:. .. code-block:: cmake. foreach(var foo bar baz); message(${var}); endforeach(); # prints:; # foo; # bar; # baz. set(my_list 1 2 3); foreach(var ${my_list}); message(${var}); endforeach(); # prints:; # 1; # 2; # 3. foreach(var ${my_list} out_of_bounds); message(${var}); endforeach(); # prints:; # 1; # 2; # 3; # out_of_bounds. There is also a more modern CMake foreach syntax. The code below is equivalent; to the code above:. .. code-block:: cmake. foreach(var IN ITEMS foo bar baz); message(${var}); endforeach(); # prints:; # foo; # bar; # baz. set(my_list 1 2 3); foreach(var IN LISTS my_list); message(${var}); endforeach(); # prints:; # 1; # 2; # 3. foreach(var IN LISTS my_list ITEMS out_of_bounds); message(${var}); endforeach(); # prints:; # 1; # 2; # 3; # out_of_bounds. Similar to the conditional statements, these generally behave how you would; expect, and they do not have their own scope. CMake also supports ``while`` lo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:8347,variab,variable,8347,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['variab'],['variable']
Modifiability,"nts in a 2D space. At; each point `x[i]`, `y[i]` a marker is drawn. The list of marker types is; shown in the previous paragraph. The marker attributes are managed by; the class **`TAttMarker`** and are described in ""Graphical Objects; Attributes"". The **`TPolyMarker`** constructor is:. ``` {.cpp}; TPolyMarker(Int_t n,Double_t *x,Double_t *y,Option_t *option); ```. Where `x` and `y` are arrays of coordinates for the `n` points that form; the poly-marker. ### Curly and Wavy Lines for Feynman Diagrams. This is a peculiarity of particle physics, but we do need sometimes to; draw Feynman diagrams. Our friends working in banking can skip this; part. A set of classes implements curly or wavy poly-lines typically; used to draw Feynman diagrams. Amplitudes and wavelengths may be; specified in the constructors, via commands or interactively from; context menus. These classes are **`TCurlyLine`** and **`TCurlyArc`**.; These classes make use of **`TPolyLine`** by inheritance; `ExecuteEvent`; methods are highly inspired from the methods used in **`TPolyLine`** and; **`TArc`**. ![The picture generated by the tutorial macro; feynman.C](pictures/030000B4.png). The **`TCurlyLine`** constructor is:. ``` {.cpp}; TCurlyLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2,; Double_t wavelength, Double_t amplitude); ```. The coordinates `(x1`, `y1)` define the starting point, `(x2`, `y2)` -; the end-point. The `wavelength` and the `amplitude` are given in percent; of the pad height. The **`TCurlyArc`** constructor is:. ``` {.cpp}; TCurlyArc(Double_t x1, Double_t y1, Double_t rad,; Double_t phimin, Double_t phimax,; Double_t wavelength, Double_t amplitude); ```. The curly arc center is `(x1`, `y1)` and the radius is `rad`. The; wavelength and the amplitude are given in percent of the line length.; The parameters `phimin` and `phimax` are the starting and ending angle; of the arc (given in degrees). Refer to; `$ROOTSYS/tutorials/graphics/feynman.C` for the script that built the; figure ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:38574,inherit,inheritance,38574,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['inherit'],['inheritance']
Modifiability,"nts in; the application. Its environment provides an interface to the ROOT; graphics system and by calling the `Run()` method the event loop starts; and the application program is waiting for the user action. The; application exits only if the top level window is not closed. Two header; files are used in addition: `TApplication.h` - for the class; **`TApplication`** and `TGClient.h` that is used to make initial; connection to the graphics system. The class **`TApplication`** must be; instantiated only once in any given application. The original list of; argument options can be retrieved via the `Argc()` and `Argv()` methods. Note: to have signals/slots working we need to create a dictionary for; the class `MyMainFrame`, i.e. we create the file `ex2aLinkDef.h`; containing the line:. ``` {.cpp}; #pragma link C++ class MyMainFrame;; ```. We compile the example:. ``` {.cpp}; rootcling -f ex2aDict.cxx -c example2a.h ex2aLinkDef.h; g++ -o example2a example2a.cxx ex2aDict.cxx `root-config --cflags --glibs`; ```. `example2a.h`. ``` {.cpp}; #include <TQObject.h>; #include <RQ_OBJECT.h>. class TGWindow;; class TGMainFrame;; class TRootEmbeddedCanvas;. class MyMainFrame {; RQ_OBJECT(""MyMainFrame""); private:; TGMainFrame *fMain;; TRootEmbeddedCanvas *fEcanvas;; public:; MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h);; virtual ~MyMainFrame();; void DoDraw();; };; ```. `example2a.cxx`. ``` {.cpp}; #include <TApplication.h>; #include <TGClient.h>; #include <TCanvas.h>; #include <TF1.h>; #include <TRandom.h>; #include <TGButton.h>; #include <TRootEmbeddedCanvas.h>; #include ""example2a.h"". MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h) {...}; MyMainFrame::~MyMainFrame() { ... }; void MyMainFrame::DoDraw() { ... }; void example() { ... }. int main(int argc, char **argv) {; TApplication theApp(""App"",&argc,argv);; example();; theApp.Run();; return 0;; }; ```. The class `MyMainFrame` could derive from **`TGMainFrame`**. In that; case the `RQ_OBJECT` macro is not needed ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:17003,config,config,17003,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['config'],['config']
Modifiability,"nts to rely on them. Dependency does propagate through return values of pointer type.; The compelling source of need for this rule is a property accessor; which returns an un-autoreleased result; the calling function must; have the chance to operate on the value, e.g. to retain it, before; ARC releases the original pointer. Note again, however, that; dependence does not survive a store, so ARC does not guarantee the; continued validity of the return value past the end of the; full-expression. .. _arc.optimization.object_lifetime:. No object lifetime extension; ----------------------------. If, in the formal computation history of the program, an object ``X``; has been deallocated by the time of an observable side-effect, then; ARC must cause ``X`` to be deallocated by no later than the occurrence; of that side-effect, except as influenced by the re-ordering of the; destruction of objects. .. admonition:: Rationale. This rule is intended to prohibit ARC from observably extending the; lifetime of a retainable object, other than as specified in this; document. Together with the rule limiting the transformation of; releases, this rule requires ARC to eliminate retains and release; only in pairs. ARC's power to reorder the destruction of objects is critical to its; ability to do any optimization, for essentially the same reason that; it must retain the power to decrease the lifetime of an object.; Unfortunately, while it's generally poor style for the destruction; of objects to have arbitrary side-effects, it's certainly possible.; Hence the caveat. .. _arc.optimization.precise:. Precise lifetime semantics; --------------------------. In general, ARC maintains an invariant that a retainable object pointer held in; a ``__strong`` object will be retained for the full formal lifetime of the; object. Objects subject to this invariant have :arc-term:`precise lifetime; semantics`. By default, local variables of automatic storage duration do not have precise; lifetime semantics.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:82874,extend,extending,82874,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['extend'],['extending']
Modifiability,"nts()`; - `RooAbsArg::shapeClientMIterator()`: use `shapeClients()`; - `RooAbsArg::serverMIterator()`: use `servers()`. - `RooAbsCollection::createIterator()`: use `begin()`, `end()` and range-based for loops; - `RooAbsCollection::iterator()`: same; - `RooAbsCollection::fwdIterator()`: same. - `RooWorkspace::componentIterator()`: use `RooWorkspace::components()` with range-based loop. ### Deprecation of legacy test statistics classes in public interface. Instantiating the following classes and even including their header files is deprecated, and the headers will be removed in ROOT 6.34:. * RooAbsTestStatistic; * RooAbsOptTestStatistic; * RooNLLVar; * RooChi2Var; * RooXYChi2Var. Please use the higher-level functions `RooAbsPdf::createNLL()` and `RooAbsPdf::createChi2()` if you want to create objects that represent test statistics. ### Change of RooParamHistFunc. The `RooParamHistFunc` didn't take any observable `RooRealVar` as constructor; argument. It assumes as observable the internal variables in the passed; RooDataHist. This means it was in most contexts unusable, because the input; can't be changed, other than loading a different bin in the dataset. Furthermore, there was actually a constructor that took a `RooAbsArg x`, but it; was simply ignored. To fix all these problems, the existing constructors were replaced by a new one; that takes the observable explicitly. Since the old constructors resulted in wrong computation graphs that caused; trouble with the new CPU evaluation backend, they had to be removed without; deprecation. Please adapt your code if necessary. ### Renaming of some RooFit classes. The `RooPower` was renamed to `RooPowerSum`, and `RooExpPoly` was renamed to `RooLegacyExpPoly`. This was a necessary change, because the names of these classes introduced in ROOT 6.28 collided with some classes in CMS combine, which were around already long before. Therefore, the classes had to be renamed to not cause any problems for CMS. In the unlikeliy case wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:13304,variab,variables,13304,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['variab'],['variables']
Modifiability,"nts[0]); // There is no Direct binding for manyInts[0].; // Is there a Default binding for the entire array?; // There is not, but it is a stack variable, so we use; // ""uninitialized"" as the default value (and emit a; // diagnostic!). NOTE: The fact that bindings are stored as a base region plus an offset limits; the Default Binding strategy, because in C aggregates can contain other; aggregates. In the current implementation of RegionStore, there is no way to; distinguish a Default binding for an entire aggregate from a Default binding; for the sub-aggregate at offset 0. Lazy Bindings (LazyCompoundVal); -------------------------------. RegionStore implements an optimization for copying aggregates (structs and; arrays) called ""lazy bindings"", implemented using a special SVal called; LazyCompoundVal. When the store is asked for the ""binding"" for an entire; aggregate (i.e. for an lvalue-to-rvalue conversion), it returns a; LazyCompoundVal instead. When this value is then stored into a variable, it is; bound as a Default value. This makes copying arrays and structs much cheaper; than if they had required memberwise access. Under the hood, a LazyCompoundVal is implemented as a uniqued pair of (region,; store), representing ""the value of the region during this 'snapshot' of the; store"". This has important implications for any sort of liveness or; reachability analysis, which must take the bindings in the old store into; account. Retrieving a value from a lazy binding happens in the same way as any other; Default binding: since there is no direct binding, the store manager falls back; to super-regions to look for an appropriate default binding. LazyCompoundVal; differs from a normal default binding, however, in that it contains several; different values, instead of one value that will appear several times. Because; of this, the store manager has to reconstruct the subregion chain on top of the; LazyCompoundVal region, and look up *that* region in the previous store. Here'",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:6956,variab,variable,6956,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,1,['variab'],['variable']
Modifiability,"ntually (depending on the number of classes bound, across how many; modules, what use fraction, etc.), this initial cost is recouped when; compared to other binders.; As a rule of thumb, if about 10% of classes are used, it takes several; hundreds of bound classes before the cppyy-approach is beneficial.; In High Energy Physics, from which it originated, cppyy is regularly used in; software stacks of many thousands of classes, where this advantage is very; important. `Distributing headers`; ----------------------. cppyy requires C/C++ headers to be available at run-time, which was never a; problem in the developer-centric world from which it originated: software; always had supported C++ APIs already, made available through header files,; and Python simply piggy-backed onto those.; JIT-ing code in those headers, which potentially picked up system headers; that were configured differently, was thus also never a problem.; Or rather, the same problem exists for C++, and configuration for C++ to; resolve potential issues translates transparently to Python. There are only two alternatives: precompile headers into LLVM bitcode and; distribute those or provide a restricted set of headers.; Precompiled headers (and modules) were never designed to be portable and; relocatable, however, thus that may not be the panacea it seems.; A restricted set of headers is some work, but cppyy can operate on abstract; interface classes just fine (including Python-side cross-inheritance). `Large deployment`; ------------------. The single biggest headache in maintaining an installation of Python; extension modules is that Python patch releases can break them.; The two typical solutions are to either restrict the choice of Python; interpreter and version that are supported (common in HPC) or to provide; binaries (wheels) for a large range of different interpreters and versions; (as e.g. done for conda). In the case of cppyy, only CPython/CPyCppyy and PyPy/_cppyy (an internal; module) depend",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:10107,config,configuration,10107,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['config'],['configuration']
Modifiability,"nt}); add_custom_target(install-${component}-stripped); endforeach(); endif(); endif(). foreach(name ${LLVM_RUNTIME_TARGETS}); if(builtins_dep); if (LLVM_BUILTIN_TARGETS); set(builtins_dep_name ""${builtins_dep}-${name}""); else(); set(builtins_dep_name ${builtins_dep}); endif(); endif(). check_apple_target(${name} runtime). runtime_register_target(${name}; DEPENDS ${builtins_dep_name} ${hdrgen_deps}; CMAKE_ARGS -DLLVM_DEFAULT_TARGET_TRIPLE=${name} ${libc_cmake_args}; EXTRA_ARGS TARGET_TRIPLE ${name}); endforeach(). foreach(multilib ${LLVM_RUNTIME_MULTILIBS}); foreach(name ${LLVM_RUNTIME_MULTILIB_${multilib}_TARGETS}); runtime_register_target(${name}+${multilib}; DEPENDS runtimes-${name}; CMAKE_ARGS -DLLVM_DEFAULT_TARGET_TRIPLE=${name}; -DLLVM_RUNTIMES_PREFIX=${name}/; -DLLVM_RUNTIMES_LIBDIR_SUBDIR=${multilib}; BASE_NAME ${name}; EXTRA_ARGS TARGET_TRIPLE ${name}); endforeach(); endforeach(); endif(). if(NOT LLVM_BUILD_INSTRUMENTED AND CLANG_ENABLE_BOOTSTRAP); # TODO: This is a hack needed because the libcxx headers are copied into the; # build directory during configuration. Without that step the clang in the; # build directory cannot find the C++ headers in certain configurations.; # I need to build a mechanism for runtime projects to provide CMake code; # that executes at LLVM configuration time to handle this case.; add_dependencies(clang-bootstrap-deps runtimes-configure); # We need to add the runtimes as a dependency because compiler-rt can be; # built as part of runtimes and we need the profile runtime for PGO; add_dependencies(clang-bootstrap-deps runtimes); endif(). if(LLVM_INCLUDE_TESTS); set_property(GLOBAL APPEND PROPERTY LLVM_ALL_ADDITIONAL_TEST_DEPENDS runtimes-test-depends). set(RUNTIMES_TEST_DEPENDS; FileCheck; count; llvm-cov; llvm-lto; llvm-nm; llvm-objdump; llvm-profdata; llvm-size; llvm-xray; not; obj2yaml; opt; sancov; sanstats; llvm_gtest_main; llvm_gtest; split-file; ); foreach(target ${test_targets} ${SUB_CHECK_TARGETS}); add_dependencies(${targ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt:18351,config,configuration,18351,interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,1,['config'],['configuration']
Modifiability,"nu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; information via different options - for example,; ``--target=arm-none-eabi -march=armv7-m`` and; ``--target=armv7m-none-eabi`` are equivalent.; Clang normalizes the command line before passing them to the multilib system.; To see what flags are emitted for a given set of command line options, use; the ``-print-multi-flags-experimental`` command line option; along with the rest of the options you want to use.; #. Load ``multilib.yaml`` from sysroot.; #. Generate additional flags. ``multilib.yaml`` contains a ``Mappings`` section,; which specifies how to generate additional flags based on the flags derived; from command line options. Flags are matched using regular expressions.; These regular expressions shall use the POSIX extended regular expression; syntax.; #. Match flags against multilib variants. If the generated flags are a superset; of the flags specified for a multilib varian",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:2407,config,configuration,2407,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['config'],['configuration']
Modifiability,"nvalidation for free. As a metaphor, i'd probably compare it to body farms - the difference between; ghost member variables and metadata symbols seems to me like the difference; between body farms and evalCall. Both are nice to have, and body farms are very; pleasant to work with, even if not omnipotent. I think it's fine for a; FunctionDecl's body in a body farm to have a local variable, even if such; variable doesn't actually exist, even if it cannot be seen from outside the; function call. I'm not seeing immediate practical difference between ""it does; actually exist"" and ""it doesn't actually exist, just a handy abstraction"".; Similarly, i think it's fine if we have a ``CXXRecordDecl`` with; implementation-defined contents, and try to farm up a member variable as a handy; abstraction (we don't even need to know its name or offset, only that it's there; somewhere). **Artem:**. We've discussed it in person with Devin, and he provided more points to think; about:. * If the initializer list consists of non-POD data, constructors of list's; objects need to take the sub-region of the list's region as this-region In the; current (v2) version of this patch, these objects are constructed elsewhere and; then trivial-copied into the list's metadata pointer region, which may be; incorrect. This is our overall problem with C++ constructors, which manifests in; this case as well. Additionally, objects would need to be constructed in the; analyzer's core, which would not be able to predict that it needs to take a; checker-specific region as this-region, which makes it harder, though it might; be mitigated by sharing the checker state traits. * Because ""ghost variables"" are not material to the user, we need to somehow; make super sure that they don't make it into the diagnostic messages. So, because this needs further digging into overall C++ support and rises too; many questions, i'm delaying a better approach to this problem and will fall; back to the original trivial patch.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:17520,variab,variables,17520,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['variab'],['variables']
Modifiability,"nvas fXlowNDC=0 fYlowNDC=0 fWNDC=1 fHNDC=1; Name= c1 Title= c1; Option=TFrame X1= -4.000000 Y1=0.000000 X2=4.000000 Y2=19.384882; OBJ: TProfile hprof Profile of pz versus px : 0; TPaveText X1=-4.900000 Y1=20.475282 X2=-0.950000 Y2=21.686837 title; TPaveStats X1=2.800000 Y1=17.446395 X2=4.800000 Y2=21.323371 stats; ```. Lets proceed with our example and draw one more histogram, and we see; one more OBJ entry. ``` {.cpp}; root[] hpx->Draw(); root[] f->ls(); TFile** hsimple.root; TFile* hsimple.root; OBJ: TProfile hprof Profile of pz versus px : 0; OBJ: TH1F hpx This is the px distribution : 0; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; ```. `TFile::ls()` loops over the list of objects in memory and the list of; objects on disk. In both cases, it calls the `ls()` method of each; object. The implementation of the `ls` method is specific to the class; of the object, all of these objects are descendants of **`TObject`** and; inherit the **`TObject`**`::ls()` implementation. The histogram classes; are descendants of **`TNamed`** that in turn is a descent of; `TObject`. In this case, **`TNamed::ls()`** is executed, and; it prints the name of the class, and the name and title of the object.; Each directory keeps a list of its objects in the memory. You can get; this list by **`TDirectory::GetList()`**. To see the lists in memory; contents you can do:. ``` {.cpp}; root[]f->GetList()->ls(); OBJ: TProfile hprof Profile of pz versus px : 0; OBJ: TH1F hpx This is the px distribution : 0; ```. Since the file `f` is the current directory (***`gDirectory`***), this; will yield the same result:. ``` {.cpp}; root[] gDirectory->GetList()->ls(); OBJ: TProfile hprof Profile of pz versus px : 0; OBJ: TH1F hpx This is the px distribution : 0; ```. ### Saving Histograms to Disk. At this time, the objects in memory (OBJ) are identical to the objects; on disk (KEY). Let's change tha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:28283,inherit,inherit,28283,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['inherit'],['inherit']
Modifiability,"nverterPlot. These classes have been rewritten for using them with the new hypothesis test calculators. The HypoTestInverter; class can now be constructed by any generic HypoTestCalculator, and both the HybridCalculator and the new; FrequentistCalculator are supported. The HypoTestInverter class can be constructed in two ways: either passing an; HypoTestCalculator and a data set or by passing the model for the signal, for the background and a data set.; In the first case the user configure the HypoTestCalculator before passing to the HypoTestInverter.; It must be configured using as null model the signal plus background model as alternate model the background; model. Optionally the user can pass the parameter to scan, if it is not passed, the first parameter of interest of the; null model will be used. In the second case (when passing directly the model and the data) the HypoTestInverter; can be configured to use either the frequentist or the hybrid calculator. The user can then configure the class; afterwards. For example set the test statistic to use via the method SetTestStatistic, number of toys to run; for each hypothesis, by retrieving the contained HypoTestCalculator:. HypoTestInverter inverter(obsData, model_B, model_SB, parameterToScan, HypoTestInverter::kFrequentist);; ProfileLikelihoodRatioTestStat profLR( *model_SB->GetPdf() );; inverter.SetTestStatistic(&profLR);; FrequentistCalculator * htcalc = (FrequentistCalculator*) inverter.GetHypoTestCalculator();; htcalc->SetToys( ntoySB, ntoyB);. The Inverter can then run using a fixed grid of npoint between xmin and xmax or by using an automatic scan, where a; bisection algorithm is used.; For running a fixed grid one needs to call SetFixedScan(npoints, xmin, xmax), while for running an autoscan use; the function SetAutoScan. The result is returned in the GetInterval function as an; HypoTestInverterResult class. If a fixed grid is used the upper limit is obtained by using a interpolation on; the scanned points.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html:4318,config,configure,4318,roofit/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html,2,['config'],['configure']
Modifiability,"nvironments and non-C-based languages. .. _i_va_arg:. '``va_arg``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = va_arg <va_list*> <arglist>, <argty>. Overview:; """""""""""""""""". The '``va_arg``' instruction is used to access arguments passed through; the ""variable argument"" area of a function call. It is used to implement; the ``va_arg`` macro in C. Arguments:; """""""""""""""""""". This instruction takes a ``va_list*`` value and the type of the; argument. It returns a value of the specified argument type and; increments the ``va_list`` to point to the next argument. The actual; type of ``va_list`` is target specific. Semantics:; """""""""""""""""""". The '``va_arg``' instruction loads an argument of the specified type; from the specified ``va_list`` and causes the ``va_list`` to point to; the next argument. For more information, see the variable argument; handling :ref:`Intrinsic Functions <int_varargs>`. It is legal for this instruction to be called in a function which does; not take a variable number of arguments, for example, the ``vfprintf``; function. ``va_arg`` is an LLVM instruction instead of an :ref:`intrinsic; function <intrinsics>` because it takes a type as an argument. Example:; """""""""""""""". See the :ref:`variable argument processing <int_varargs>` section. Note that the code generator does not yet fully support va\_arg on many; targets. Also, it does not currently support va\_arg with aggregate; types on any target. .. _i_landingpad:. '``landingpad``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = landingpad <resultty> <clause>+; <resultval> = landingpad <resultty> cleanup <clause>*. <clause> := catch <type> <value>; <clause> := filter <array constant type> <array constant>. Overview:; """""""""""""""""". The '``landingpad``' instruction is used by `LLVM's exception handling; system <ExceptionHandling.html#overview>`_ to specify that a basic block; is a landing pad --- one where the exception lands, and corresponds to the; code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:479994,variab,variable,479994,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"ny RooFitResult object. RooAbsPdf* paramPdf = fitresult->createHessePdf(RooArgSet(a,b)) ;. The returned object is an instance of the newly added class RooMultiVarGaussian, that can; model correlated Gaussian distributions in an arbitrary number of dimensions, given a; vector of mean values and a covariance matrix. Class RooMultivarGaussian implements analytical; integration as well as analytical partial integrals over the first 31 dimensions (if you have; that many) and implements in effect internal generation strategy for its observables. A new tutorial macro rf608_fitresultaspdf.C has been added to illustrate the use MV Gaussians constructed from a RooFitResult; Improved functionality of RooFFTConvPdf; The FFT convolution operator p.d.f. class RooFFTConvPdf has been substantially upgraded; for improved performance has several new options. For the overflow buffering, which aims to reduce cylical spillover from the FFT convolution,; a choice of three algorithms is now provided:. Extend the p.d.f. somewhat beyond its original domain (the new default); Fill the buffer 50/50 with the value of the p.d.f at the upper/lower bound of the convolution observable (the previous default); Mirror the p.d.f. over the boundary. The new default algorithm provides a more sensible result for p.d.f.s with significant; spillover issues, provided that the p.d.f. can be continuated beyond its original domain.; Convolution in non-observables is also explicitly supported now. One can e.g. construct a p.d.f; of the form G(x) = Int[dy] ( F(x,y) (*) H(y) ). A new tutorial macro rf211_paramconv illustrates; how such convolutions can be constructed; It is now also possible to express FFT convolutions in terms of other observables than the; convolution observable itself. A common occurrence of that situation is a (circular) convolution a polar; angle theta, for a p.d.f. that is ultimately expressed in terms of cos(theta).; A new tutorial macro rf210_angularconv illustrates how to convolutions of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:11258,Extend,Extend,11258,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['Extend'],['Extend']
Modifiability,"ny debuggers [DenisovCamelBack]_. Variable Names Coding Standard Options; ======================================. There are two main options for variable names that begin with a lower case; letter: ``camelBack`` and ``lower_case``. (These are also known by other names; but here we use the terminology from clang-tidy). ``camelBack`` is consistent with [WebKit]_, [Qt]_ and [Swift]_ while; ``lower_case`` is consistent with [LLDB]_, [Google]_, [Rust]_ and [Python]_. ``camelBack`` is already used for function names, which may be considered an; advantage [LattnerFunction]_ or a disadvantage [CarruthFunction]_. Approval for ``camelBack`` was expressed by [DenisovCamelBack]_; [LattnerFunction]_ [IvanovicDistinguish]_.; Opposition to ``camelBack`` was expressed by [CarruthCamelBack]_; [TurnerCamelBack]_.; Approval for ``lower_case`` was expressed by [CarruthLower]_; [CarruthCamelBack]_ [TurnerLLDB]_.; Opposition to ``lower_case`` was expressed by [LattnerLower]_. Differentiating variable kinds; ------------------------------. An additional requested change is to distinguish between different kinds of; variables [RobinsonDistinguish]_ [RobinsonDistinguish2]_ [JonesDistinguish]_; [IvanovicDistinguish]_ [CarruthDistinguish]_ [MalyutinDistinguish]_. Others oppose this idea [HähnleDistinguish]_ [GreeneDistinguish]_; [HendersonPrefix]_. A possibility is for member variables to be prefixed with ``m_`` and for global; variables to be prefixed with ``g_`` to distinguish them from local variables.; This is consistent with [LLDB]_. The ``m_`` prefix is consistent with [WebKit]_. A variation is for member variables to be prefixed with ``m``; [IvanovicDistinguish]_ [BeylsDistinguish]_. This is consistent with [Mozilla]_. Another option is for member variables to be suffixed with ``_`` which is; consistent with [Google]_ and similar to [Python]_. Opposed by; [ParzyszekDistinguish]_. Reducing the number of acronyms; ===============================. While switching coding standard will make",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:3686,variab,variable,3686,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['variab'],['variable']
Modifiability,"ny other language frontends have; been written using LLVM, and an incomplete list is available at; `projects with LLVM <https://llvm.org/ProjectsWithLLVM/>`_. I'd like to write a self-hosting LLVM compiler. How should I interface with the LLVM middle-end optimizers and back-end code generators?; ----------------------------------------------------------------------------------------------------------------------------------------; Your compiler front-end will communicate with LLVM by creating a module in the; LLVM intermediate representation (IR) format. Assuming you want to write your; language's compiler in the language itself (rather than C++), there are 3; major ways to tackle generating LLVM IR from a front-end:. 1. **Call into the LLVM libraries code using your language's FFI (foreign; function interface).**. * *for:* best tracks changes to the LLVM IR, .ll syntax, and .bc format. * *for:* enables running LLVM optimization passes without a emit/parse; overhead. * *for:* adapts well to a JIT context. * *against:* lots of ugly glue code to write. 2. **Emit LLVM assembly from your compiler's native language.**. * *for:* very straightforward to get started. * *against:* the .ll parser is slower than the bitcode reader when; interfacing to the middle end. * *against:* it may be harder to track changes to the IR. 3. **Emit LLVM bitcode from your compiler's native language.**. * *for:* can use the more-efficient bitcode reader when interfacing to the; middle end. * *against:* you'll have to re-engineer the LLVM IR object model and bitcode; writer in your language. * *against:* it may be harder to track changes to the IR. If you go with the first option, the C bindings in include/llvm-c should help; a lot, since most languages have strong support for interfacing with C. The; most common hurdle with calling C from managed code is interfacing with the; garbage collector. The C interface was designed to require very little memory; management, and so is straightforward in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst:3879,adapt,adapts,3879,interpreter/llvm-project/llvm/docs/FAQ.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst,1,['adapt'],['adapts']
Modifiability,"o (and update) the list of files in the file browser (left panel) when opening a ROOT file from the ""Open File"" menu. TGListView. Keyboard navigation is now fully working in the list view. TGMainFrame. Allow to save a snapshot of the GUI in a picture file. The supported formats are gif, jpg, png, tiff, and xpm. TGFileDialog. Allow to change directory by typing its name in the text entry field of the dialog. TProofProgressDialog. Added a speedometer widget (TGSpeedo) to display the processing rate; Added a check button to enable/disable smooth update of the speedometer (enabled by default). This could be useful in the case of slow displays (e.g. when using it via ssh); Several layout improvements. TRecorder. Improvements and consolidation of the cross-platform interoperability, allowing to record and replay sessions between different platforms with less side effects. NB: Using different OS/WM (Window Managers) and using different ROOT GUI settings (via e.g. system.rootrc) between recording and replaying may still produce a wrong behavior of the recorder.; New tutorial guitest_playback.C replaying a recorded session showing and validating the GUI (using guitest.C). GUI Builder; New features, new user interface; Several important features have been added to the builder, and its user interface has been redesigned.; Editing modes are now clearly distinguished with enabled and disabled layout mode. Possibility to enable automatic layout fasten the interface development, as the positioning doesn't have to be done manually anymore; Major changes in the user interface:. Added a list tree displaying the complete structure of the GUI; The name of every element of the GUI is now editable; New, more intuitive interface for padding and layout hints; Color settings option was added to the widget editor; Extended commands in the top menu (open project, save project...); Added important warning dialogs, such as ""Save project"" dialog when closing the window; Added several tool tips. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v526/index.html:2390,Extend,Extended,2390,gui/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v526/index.html,1,['Extend'],['Extended']
Modifiability,"o = @(M_PI / 2); // [NSNumber numberWithDouble:(M_PI / 2)]. // enumerated types.; typedef enum { Red, Green, Blue } Color;; NSNumber *favoriteColor = @(Green); // [NSNumber numberWithInt:((int)Green)]. // strings.; NSString *path = @(getenv(""PATH"")); // [NSString stringWithUTF8String:(getenv(""PATH""))]; NSArray *pathComponents = [path componentsSeparatedByString:@"":""];. // structs.; NSValue *center = @(view.center); // Point p = view.center;; // [NSValue valueWithBytes:&p objCType:@encode(Point)];; NSValue *frame = @(view.frame); // Rect r = view.frame;; // [NSValue valueWithBytes:&r objCType:@encode(Rect)];. Boxed Enums; -----------. Cocoa frameworks frequently define constant values using *enums.*; Although enum values are integral, they may not be used directly as; boxed literals (this avoids conflicts with future ``'@'``-prefixed; Objective-C keywords). Instead, an enum value must be placed inside a; boxed expression. The following example demonstrates configuring an; ``AVAudioRecorder`` using a dictionary that contains a boxed enumeration; value:. .. code-block:: objc. enum {; AVAudioQualityMin = 0,; AVAudioQualityLow = 0x20,; AVAudioQualityMedium = 0x40,; AVAudioQualityHigh = 0x60,; AVAudioQualityMax = 0x7F; };. - (AVAudioRecorder *)recordToFile:(NSURL *)fileURL {; NSDictionary *settings = @{ AVEncoderAudioQualityKey : @(AVAudioQualityMax) };; return [[AVAudioRecorder alloc] initWithURL:fileURL settings:settings error:NULL];; }. The expression ``@(AVAudioQualityMax)`` converts ``AVAudioQualityMax``; to an integer type, and boxes the value accordingly. If the enum has a; :ref:`fixed underlying type <objc-fixed-enum>` as in:. .. code-block:: objc. typedef enum : unsigned char { Red, Green, Blue } Color;; NSNumber *red = @(Red), *green = @(Green), *blue = @(Blue); // => [NSNumber numberWithUnsignedChar:]. then the fixed underlying type will be used to select the correct; ``NSNumber`` creation method. Boxing a value of enum type will result in a ``NSNumber`` pointer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:5551,config,configuring,5551,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['config'],['configuring']
Modifiability,"o A and an address space equal to AS of the; corresponding SL. ``DW_ASPACE_LLVM_none`` is defined as the target architecture default address; space. See :ref:`amdgpu-dwarf-address-spaces`. If a stack entry is required to be a location description, but it is a value V; with the generic type, then it is implicitly converted to a location description; L with one memory location description SL. SL specifies the memory location; storage that corresponds to the target architecture default address space with a; bit offset equal to V scaled by 8 (the byte size). .. note::. If it is wanted to allow any integral type value to be implicitly converted to; a memory location description in the target architecture default address; space:. If a stack entry is required to be a location description, but is a value V; with an integral type, then it is implicitly converted to a location; description L with a one memory location description SL. If the type size of; V is less than the generic type size, then the value V is zero extended to; the size of the generic type. The least significant generic type size bits; are treated as an unsigned value to be used as an address A. SL specifies; memory location storage corresponding to the target architecture default; address space with a bit offset equal to A scaled by 8 (the byte size). The implicit conversion could also be defined as target architecture specific.; For example, GDB checks if V is an integral type. If it is not it gives an; error. Otherwise, GDB zero-extends V to 64 bits. If the GDB target defines a; hook function, then it is called. The target specific hook function can modify; the 64-bit value, possibly sign extending based on the original value type.; Finally, GDB treats the 64-bit value V as a memory location address. If a stack entry is required to be a location description, but it is an implicit; pointer value IPV with the target architecture default address space, then it is; implicitly converted to a location descriptio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:107124,extend,extended,107124,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['extend'],['extended']
Modifiability,"o avoid the (incorrect/unwanted) registration of the clone. Repaired writing Foreign class in XML files. Extend TDirectoryFile so it can now be derived from. In MakeProject; properly test whether a StreamerElement describe a base class (stl container were not handled correctly).; Remove requirement to have '.' in the PATH to execute the build. Add a new optional parameter to TDirectory::Append: replace.; If replace is true (the default is false), the Append will; first remove from the directory any existing object and; print the message:. Replacing existing OldClass: thename (Potential memory leak). Add a new option parameter to TDirectory::CloneObject: 'autoadd'; If autoadd is true (the default), CloneObject will call the; object 'DirectoryAutoAdd' function (if any). In TDirectory::CloneObject add support for multiple inheritance; from TObject where TObject is not the left most base class. Schema Evolution. Fix schema evolution problem in TTree::Draw by extending support in; TStreamerInfo::ReadValueAux to 'converted' numerical types, (; see issue in ROOT forum). When reading more than one TStreamerInfo for the same versioned; class, we now use the highest possible class version as the current; version of the class. Practically, we update the class version; when reading new (higher versioned) StreamerInfo until the Class; is actually used (i.e. TClass::GetClassVersion is call directly; or indirectly). In particular, if a file has several StreamerInfos for the same; versioned class, we will use the highest version number as the; 'current' class version (as opposed to the lowest until now). For backward compatibility TStreamerInfo::BuildCheck compares the checksum of; the on-file StreamerInfo not only to the current value of the class checksum; but also to the checksum calculated using the older algorithms. This patch extends this test to also be done when comparing 2 on-file StreamerInfos. This removes spurrious warning message when loading 2 older files which; were ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v520/index.html:1039,extend,extending,1039,io/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v520/index.html,2,['extend'],['extending']
Modifiability,"o copy. It returns nothing. .. code-block:: c++. static __externref_t tableSrc[0];; static __externref_t tableDst[0];. // Copy nelem elements from [src, src + nelem - 1] in tableSrc to; // [dst, dst + nelem - 1] in tableDst; void copy(int dst, int src, int nelem) {; __builtin_wasm_table_copy(tableDst, tableSrc, dst, src, nelem);; }. Builtin Functions; =================. Clang supports a number of builtin library functions with the same syntax as; GCC, including things like ``__builtin_nan``, ``__builtin_constant_p``,; ``__builtin_choose_expr``, ``__builtin_types_compatible_p``,; ``__builtin_assume_aligned``, ``__sync_fetch_and_add``, etc. In addition to; the GCC builtins, Clang supports a number of builtins that GCC does not, which; are listed here. Please note that Clang does not and will not support all of the GCC builtins; for vector operations. Instead of using builtins, you should use the functions; defined in target-specific header files like ``<xmmintrin.h>``, which define; portable wrappers for these. Many of the Clang versions of these functions are; implemented directly in terms of :ref:`extended vector support; <langext-vectors>` instead of builtins, in order to reduce the number of; builtins that we need to implement. ``__builtin_alloca``; --------------------. ``__builtin_alloca`` is used to dynamically allocate memory on the stack. Memory; is automatically freed upon function termination. **Syntax**:. .. code-block:: c++. __builtin_alloca(size_t n). **Example of Use**:. .. code-block:: c++. void init(float* data, size_t nbelems);; void process(float* data, size_t nbelems);; int foo(size_t n) {; auto mem = (float*)__builtin_alloca(n * sizeof(float));; init(mem, n);; process(mem, n);; /* mem is automatically freed at this point */; }. **Description**:. ``__builtin_alloca`` is meant to be used to allocate a dynamic amount of memory; on the stack. This amount is subject to stack allocation limits. Query for this feature with ``__has_builtin(__builtin_alloc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:96588,portab,portable,96588,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['portab'],['portable']
Modifiability,"o describe graphically a data distribution (D) with only; the five numbers. It was invented in 1977 by John Tukey. The five numbers are:. 1. The minimum value of the distribution D (Min).; 2. The lower quartile (Q1): 25% of the data points in D are less than Q1.; 3. The median (M): 50% of the data points in D are less than M.; 4. The upper quartile (Q3): 75% of the data points in D are less than Q3.; 5. The maximum value of the distribution D (Max). ![A box plot describes a distribution with only five numbers. ](pictures/bp1.png). In ROOT Box Plots (Candle Plots) can be produced from a TTree using the; “candle” option in TTree::Draw(). ``` {.cpp}; tree->Draw(“px:cos(py):sin(pz)”,””,”candle”);; ```. ### Using TTree::Scan; \index{tree!scan}. `TTree::Scan` can be used to print the content of the tree's entries; optional passing a selection. ``` {.cpp}; root[] MyTree->Scan();; ```. will print the first 8 variables of the tree. ``` {.cpp}; root[] MyTree->Scan(""*"");; ```. will print all the variable of the tree. Specific variables of the tree can be explicit selected by list them in; column separated list:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"");; ```. will print the values of `var1`, `var2` and `var3`. A selection can be; applied in the second argument:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"",""var1==0"");; ```. will print the values of `var1`, `var2` and `var3` for the entries where; var1 is exactly 0. `TTree::Scan` returns the number of entries passing the selection. By; default 50 rows are shown before `TTree::Scan` pauses and ask you to; press the Enter key to see the next 50 rows. You can change the default; number of rows to be shown before \<CR\> via; `mytree->SetScanfield(maxrows)` where maxrows is 50 by default. If; maxrows is set to 0 all rows of the **`Tree`** are shown. This option is; interesting when dumping the contents of a Tree to an ascii file, eg; from the command line:. ``` {.cpp}; root[] tree->SetScanField(0);; root[] tree->Scan(""*""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:104939,variab,variable,104939,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"o evaluate the model:. ```; using namespace TMVA::Experimental;; SOFIE::RModelParser_ONNX parser;; SOFIE::RModel model = parser.Parse(“./example_model.onnx”);; model.Generate();; model.OutputGenerated(“./example_output.hxx”);; ```; And an C++ header file will be generated. In addition also a text file, `example_output.dat` will be also generated. This file will contain the model weight values that will be used to initialize the model.; A full example for parsing an ONNX input file is given by the tutorial [`TMVA_SOFIE_ONNX.C`](https://root.cern/doc/master/TMVA__SOFIE__ONNX_8C.html). To use the generated inference code, you need to create a `Session` class and call the function `Session::inder(float *)`:. ```; #include ""example_output.hxx""; float input[INPUT_SIZE] = {.....}; // input data; TMVA_SOFIE_example_model::Session s(""example_output.dat"");; std::vector<float> out = s.infer(input);; ```. For using the ONNX parser you need to build ROOT with the configure option `tmva-sofie=ON`, which will be enabled when a Google Protocol Buffer library (`protobuf`, see https://developers.google.com/protocol-buffers) is found in your system. If you don't have `protobuf` and you don't want to install you can still use SOFIE, although with some more limited operator support parsing directly Keras `.h5` input files or PyTorch `.pt` files.; In tis case you can convert directly the model to a `RModel` representation which can be used as above to generate the header and the weight file. For parsing a Keras input file you need to do:; ```; SOFIE::RModel model = SOFIE::PyKeras::Parse(""KerasModel.h5"");; ```; See the tutorial [`TMVA_SOFIE_Keras.C`](https://root.cern/doc/master/TMVA__SOFIE__Keras_8C.html).; For parsing a PyTorch input file :; ```; SOFIE::RModel model = SOFIE::PyTorch::Parse(""PyTorchModel.pt"",inputShapes);; ```; where `inputShapes` is a `std::vector<std::vector<size_t>>` defining the inputs shape tensors. This information is required by PyTorch since it is not stored in th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:34037,config,configure,34037,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['config'],['configure']
Modifiability,"o get the config symbols into ROOT's executables; When linking a ROOT executable, the setup functions from the sanitiser config library might get ignored, because they are not used in any of our executables.; In `cmake/modules/SetUp{Linux|MacOS}.cmake`, the functions are therefore marked as ""undefined"" for the linker, so it starts copying; them into all ROOT executables.; This way, root.exe, cling, ... can start up with a sane default config. ### Use your own address/leak sanitizer configuration; The default configurations can be overridden using the environment variables `ASAN_OPTIONS` and `LSAN_OPTIONS`. Refer to the; [address sanitizer documentation](https://github.com/google/sanitizers/wiki/AddressSanitizer) or use `ASAN_OPTIONS=help=1` when starting; up a sanitised executable (e.g. `root.exe`). A template for a leak suppression file can be found in `$ROOTSYS/etc/lsan-root.supp`. ## Create your own sanitised executable; ROOT exports a library target called `ROOT::ROOTStaticSanitizerConfig` that can be used to create sanitised executables with ROOT's default; address sanitizer config. Linking against this target will add the above setup functions and also add the address sanitizer flags that; ROOT was built with. It should be sufficient to; - Link all executables against this target; - And have `-fsanitize=address` in the `CXXFLAGS`. ## Use sanitised ROOT libraries from a non-sanitised executable (e.g. `python`); When ROOT libraries are built with sanitizers, the address sanitizer runtime needs to be loaded at startup. However, when calling into ROOT; functions from python, that won't happen, since python is not sanitised. Therefore, the address sanitizer runtime has to be preloaded with; `LD_PRELOAD=<pathToRuntime>:libROOTSanitizerConfig.<so|dylib> pythonX ROOTScript.py`. Preloading the shared sanitizer config as above is optional, but recommended, because it adds leak sanitizer suppressions. On Mac, preloading is theoretically possible, but code signing and man",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md:2294,config,config,2294,core/sanitizer/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md,1,['config'],['config']
Modifiability,"o guide our design of the lattice and transfer; functions: lattice values can be symbolic expressions, and transfer functions; can construct more complex symbolic expressions from symbolic expressions that; represent arguments. See [this StackOverflow; discussion](https://cstheory.stackexchange.com/questions/19708/symbolic-execution-is-a-case-of-abstract-interpretation); for a further comparison of abstract interpretation and symbolic execution. ### Flow condition. A human can say about the previous example that the function returns `x` when; `x >= 0`, and `-x` when `x < 0`. We can make this conclusion programmatically by; tracking a flow condition. A flow condition is a predicate written in terms of; the program state that is true at a specific program point regardless of the; execution path that led to this statement. For example, the flow condition for; the program point right before evaluating `result = x` is `x >= 0`. If we enhance the lattice to be a set of pairs of values and predicates, the; dataflow analysis computes the following values:. ```c++; void PrintAbs(int x) {; int result;; if (x >= 0) {; // Flow condition: x >= 0.; result = x; // result is {x if x >= 0}; } else {; // Flow condition: x < 0.; result = -x; // result is {-x if x < 0}; }; print(result); // result is {x if x >= 0; -x if x < 0}; }; ```. Of course, in a program with loops, symbolic expressions for flow conditions can; grow unbounded. A practical static analysis system must control this growth to; keep the symbolic representations manageable and ensure that the data flow; analysis terminates. For example, it can use a constraint solver to prune; impossible flow conditions, and/or it can abstract them, losing precision, after; their symbolic representations grow beyond some threshold. This is similar to; how we had to limit the sizes of computed sets of possible values to 3 elements. ### Symbolic pointers. This approach proves to be particularly useful for modeling pointer values,; since w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:12950,enhance,enhance,12950,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['enhance'],['enhance']
Modifiability,"o histograms.\label{f52}][f52]. [f53]: figures/histo_ratio.png ""f53""; <a name=""f53""></a>. ![The ratio of two histograms.\label{f53}][f53]. Some lines now need a bit of clarification:. - line *3*: Cling, as we know, is also able to interpret more than one; function per file. In this case the function simply sets up some; parameters to conveniently set the line of histograms. - line *19* to *21*: Some `C++` syntax for conditional; statements is used to fill the histograms with different numbers of; entries inside the loop. - line *30*: The sum of two histograms. A weight, which can be negative, can; be assigned to the added histogram. - line *41*: The division of two histograms is rather straightforward. - line *44* to *62*: When you draw two quantities and their ratios, it; is much better if all the information is condensed in one single; plot. These lines provide a skeleton to perform this operation. ## Two-dimensional Histograms ##. Two-dimensional histograms are a very useful tool, for example to; inspect correlations between variables. You can exploit the; bi-dimensional histogram classes provided by ROOT in a simple way.; Let's see how in this macro:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro7.C; ```. Two kinds of plots are provided within the code, the first one; containing three-dimensional representations (Figure [5.4](#f54)) and the second one; projections and profiles (Figure [5.5](#f55)) of the bi-dimensional histogram. [f54]: figures/th2f.png ""f54""; <a name=""f54""></a>. ![Different ways of representing bi-dimensional; histograms.\label{f54}][f54]. [f55]: figures/proj_and_prof.png ""f55""; <a name=""f55""></a>. ![The projections and profiles of bi-dimensional; histograms.\label{f55}][f55]. When a projection is performed along the x (y) direction, for every bin; along the x (y) axis, all bin contents along the y (x) axis are summed; up (upper the plots of Figure [5.5](#f55)). When a profile is performed along the x (y); direction, for every bin along the x (y) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:3280,variab,variables,3280,documentation/primer/histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md,1,['variab'],['variables']
Modifiability,"o incorporate LLVM into your project.; - `Chapter #4: Adding JIT and Optimizer Support <LangImpl04.html>`_ -; One great thing about LLVM is its support for JIT compilation, so; we'll dive right into it and show you the 3 lines it takes to add JIT; support. Later chapters show how to generate .o files.; - `Chapter #5: Extending the Language: Control Flow <LangImpl05.html>`_ - With; the basic language up and running, we show how to extend; it with control flow operations ('if' statement and a 'for' loop). This; gives us a chance to talk about SSA construction and control; flow.; - `Chapter #6: Extending the Language: User-defined Operators; <LangImpl06.html>`_ - This chapter extends the language to let; users define arbitrary unary and binary operators - with assignable; precedence! This allows us to build a significant piece of the; ""language"" as library routines.; - `Chapter #7: Extending the Language: Mutable Variables; <LangImpl07.html>`_ - This chapter talks about adding user-defined local; variables along with an assignment operator. This shows how easy it is; to construct SSA form in LLVM: LLVM does *not* require your front-end; to construct SSA form in order to use it!; - `Chapter #8: Compiling to Object Files <LangImpl08.html>`_ - This; chapter explains how to take LLVM IR and compile it down to object; files, like a static compiler does.; - `Chapter #9: Debug Information <LangImpl09.html>`_ - A real language; needs to support debuggers, so we; add debug information that allows setting breakpoints in Kaleidoscope; functions, print out argument variables, and call functions!; - `Chapter #10: Conclusion and other tidbits <LangImpl10.html>`_ - This; chapter wraps up the series by discussing ways to extend the language; and includes pointers to info on ""special topics"" like adding garbage; collection support, exceptions, debugging, support for ""spaghetti; stacks"", etc. By the end of the tutorial, we'll have written a bit less than 1000 lines; of (non-comment, non",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst:3299,variab,variables,3299,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,1,['variab'],['variables']
Modifiability,"o is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:17355,config,config,17355,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,2,['config'],['config']
Modifiability,"o its language, ``-assume-filename=`` option can be; used to override the file name :program:`clang-format` uses to detect the; language. An example of a configuration file for multiple languages:. .. code-block:: yaml. ---; # We'll use defaults from the LLVM style, but with 4 columns indentation.; BasedOnStyle: LLVM; IndentWidth: 4; ---; Language: Cpp; # Force pointers to the type for C++.; DerivePointerAlignment: false; PointerAlignment: Left; ---; Language: JavaScript; # Use 100 columns for JS.; ColumnLimit: 100; ---; Language: Proto; # Don't format .proto files.; DisableFormat: true; ---; Language: CSharp; # Use 100 columns for C#.; ColumnLimit: 100; ... An easy way to get a valid ``.clang-format`` file containing all configuration; options of a certain predefined style is:. .. code-block:: console. clang-format -style=llvm -dump-config > .clang-format. When specifying configuration in the ``-style=`` option, the same configuration; is applied for all input files. The format of the configuration is:. .. code-block:: console. -style='{key1: value1, key2: value2, ...}'. Disabling Formatting on a Piece of Code; =======================================. Clang-format understands also special comments that switch formatting in a; delimited range. The code between a comment ``// clang-format off`` or; ``/* clang-format off */`` up to a comment ``// clang-format on`` or; ``/* clang-format on */`` will not be formatted. The comments themselves will be; formatted (aligned) normally. Also, a colon (``:``) and additional text may; follow ``// clang-format off`` or ``// clang-format on`` to explain why; clang-format is turned off or back on. .. code-block:: c++. int formatted_code;; // clang-format off; void unformatted_code ;; // clang-format on; void formatted_code_again;. Configuring Style in Code; =========================. When using ``clang::format::reformat(...)`` functions, the format is specified; by supplying the `clang::format::FormatStyle; <https://clang.llvm.org/d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:3638,config,configuration,3638,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"o launch tasks asynchronously whenever a; buffer is done processing. ## TTree Libraries. - Resolved O(N^2) scaling problem in ```TTree::Draw()``` observed when a branch that contains a; large TClonesArray where each element contains another small vector container.; - `TTree::TTree()` now takes the `TDirectory*` that the tree should be constructed in.; Defaults to `gDirectory`, i.e. the default behavior did not change.; - To prepare for multi-threaded workflows, a preloading and retaining clusters feature is introduced.; This change will prevent additional reads from occurring when reading events out of sequence.; By setting TTree::SetClusterPrefetch(), an entire clusters will be loaded into memory, rather than single baskets.; By setting the MaxVirtualSize of the tree to a negative value, previous clusters will be retained; (the absolute value of MaxVirtualSize indicates how many additional clusters will be kept in memory).; - Added ```TBranchProxy::GetEntries``` to support leaflist variable size array and added ```TBranchProxy::GetArrayLength```.; - In ```TBranch::Streamer``` insured that we never steam already basket already written to disk. ### TDataFrame. #### New features; - Add `Alias`, a facility to specify an alternative name for a given column: `auto histo = mytdf.Alias(""myAlias"", ""myColumn"").Histo1D(""myAlias"");`. Especially useful for pyROOT users to deal with column names that are not valid C++ identifiers (e.g. `Filter(""1branch > 0"") --> Alias(""1branch"", ""branch1"").Filter(""branch1 > 0"")`.; - Add `Cache`, a facility to cache `TDataFrame`s in memory. All or some columns can be cached. Two versions of the method are proposed: one which allows to explicitly list the types of the columns and another one allowing to let the system infer them (the same mechanism of the `Snapshot` method). Only columns containing instances of classes which have a copy constructor can be cached.; - Add `DefineSlot`, a `Define` transformation that is aware of the multi-threading s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:10420,variab,variable,10420,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['variab'],['variable']
Modifiability,"o not access or only read non-local memory, and marking them; ``readnone``/``readonly``. In addition, it marks function arguments (of; pointer type) ""``nocapture``"" if a call to the function does not create any; copies of the pointer value that outlive the call. This more or less means; that the pointer is only dereferenced, and not returned from the function or; stored in a global. This pass is implemented as a bottom-up traversal of the; call-graph. ``globaldce``: Dead Global Elimination; --------------------------------------. This transform is designed to eliminate unreachable internal globals from the; program. It uses an aggressive algorithm, searching out globals that are known; to be alive. After it finds all of the globals which are needed, it deletes; whatever is left over. This allows it to delete recursive chunks of the; program which are unreachable. ``globalopt``: Global Variable Optimizer; ----------------------------------------. This pass transforms simple global variables that never have their address; taken. If obviously true, it marks read/write globals as constant, deletes; variables only stored to, etc. ``gvn``: Global Value Numbering; -------------------------------. This pass performs global value numbering to eliminate fully and partially; redundant instructions. It also performs redundant load elimination. .. _passes-indvars:. ``indvars``: Canonicalize Induction Variables; ---------------------------------------------. This transformation analyzes and transforms the induction variables (and; computations derived from them) into simpler forms suitable for subsequent; analysis and transformation. This transformation makes the following changes to each loop with an; identifiable induction variable:. * All loops are transformed to have a *single* canonical induction variable; which starts at zero and steps by one.; * The canonical induction variable is guaranteed to be the first PHI node in; the loop header block.; * Any pointer arithmetic recur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:17157,variab,variables,17157,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['variab'],['variables']
Modifiability,"o not insert trailing commas. * ``TCS_Wrapped`` (in configuration: ``Wrapped``); Insert trailing commas in container literals that were wrapped over; multiple lines. Note that this is conceptually incompatible with; bin-packing, because the trailing comma is used as an indicator; that a container should be formatted one-per-line (i.e. not bin-packed).; So inserting a trailing comma counteracts bin-packing. .. _IntegerLiteralSeparator:. **IntegerLiteralSeparator** (``IntegerLiteralSeparatorStyle``) :versionbadge:`clang-format 16` :ref:`¶ <IntegerLiteralSeparator>`; Format integer literal separators (``'`` for C++ and ``_`` for C#, Java,; and JavaScript). Nested configuration flags:. Separator format of integer literals of different bases. If negative, remove separators. If ``0``, leave the literal as is. If; positive, insert separators between digits starting from the rightmost; digit. For example, the config below will leave separators in binary literals; alone, insert separators in decimal literals to separate the digits into; groups of 3, and remove separators in hexadecimal literals. .. code-block:: c++. IntegerLiteralSeparator:; Binary: 0; Decimal: 3; Hex: -1. You can also specify a minimum number of digits (``BinaryMinDigits``,; ``DecimalMinDigits``, and ``HexMinDigits``) the integer literal must; have in order for the separators to be inserted. * ``int8_t Binary`` Format separators in binary literals. .. code-block:: text. /* -1: */ b = 0b100111101101;; /* 0: */ b = 0b10011'11'0110'1;; /* 3: */ b = 0b100'111'101'101;; /* 4: */ b = 0b1001'1110'1101;. * ``int8_t BinaryMinDigits`` Format separators in binary literals with a minimum number of digits. .. code-block:: text. // Binary: 3; // BinaryMinDigits: 7; b1 = 0b101101;; b2 = 0b1'101'101;. * ``int8_t Decimal`` Format separators in decimal literals. .. code-block:: text. /* -1: */ d = 18446744073709550592ull;; /* 0: */ d = 184467'440737'0'95505'92ull;; /* 3: */ d = 18'446'744'073'709'550'592ull;. * ``int8_t Deci",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:77700,config,config,77700,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['config']
Modifiability,"o perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operation.; Although the rules in one action may have a number of different implementations,; they should strive to produce a similar result. It should be easy for users to; identify which refactoring action produced the result regardless of which; refactoring action rule was used. The distinction between actions and rules enables the creation of actions; that define a set of different rules that produce similar results. For example,; the ""add missing switch cases"" refactoring operation typically adds missing; cases to one switch at a time. However, it could be useful to have a; refactoring that works on all switches that operate on a particular enum, as; one could then automatically update all of them after adding a new enum; constant. To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:2150,refactor,refactoring,2150,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,3,['refactor'],['refactoring']
Modifiability,"o process the entries of a TTree in parallel. The user provides a function that receives one parameter, a TTreeReader, that can be used to iterate over a subrange of entries. Each subrange corresponds to a cluster in the TTree and is processed by a task, which can potentially be run in parallel with other tasks.; * Add a new implementation of a RW lock, `ROOT::TRWSpinLock`, which is based on a `ROOT::TSpinMutex`. `TRWSpinLock` tries to make faster the scenario when readers come and go but there is no writer, while still preventing starvation of writers. ## I/O Libraries. * Support I/O of `std::unique_ptr`s and STL collections thereof.; * Support I/O of `std::array`.; * Support I/O of `std::tuple`. The dictionary for those is never auto generated and thus requires explicit request of the dictionary for each std::tuple class template instantiation used, like most other class templates.; * Custom streamers need to #include TBuffer.h explicitly (see [section Core Libraries](#core-libs)); * Check and flag short reads as errors in the xroot plugins. This fixes [ROOT-3341].; * Added support for AWS temporary security credentials to TS3WebFile by allowing the security token to be given.; * Resolve an issue when space is freed in a large `ROOT` file and a TDirectory is updated and stored the lower (less than 2GB) freed portion of the file [ROOT-8055]. - ##### TBufferJSON:; + support data members with `//[fN]` comment; + preliminary support of STL containers; + JSON data can be produced with `TObject::SaveAs()` method. ## TTree Libraries. * TChains can now be histogrammed without any C++ code, using the command line tool `rootdrawtree`. It is based on the new class `TSimpleAnalysis`.; * Do not automatically setup read cache during `TTree::Fill()`. This fixes [ROOT-8031].; * Make sure the option ""PARA"" in `TTree::Draw` is used with at least tow variables [ROOT-8196].; * The with `goff` option one can use as many variables as needed. There no more; limitation, like with the opti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:8257,plugin,plugins,8257,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['plugin'],['plugins']
Modifiability,"o reason about, but; it is far too much to expect the compiler to accurately reason about control; dependencies between two calls. It is also very easy to accidentally forget; to drain an autorelease pool when using the manual API, and this can; significantly inflate the process's high-water-mark. The introduction of a; new scope is unfortunate but basically required for sane interaction with the; rest of the language. Not draining the pool during an unwind is apparently; required by the Objective-C exceptions implementation. .. _arc.misc.externally_retained:. Externally-Retained Variables; -----------------------------. In some situations, variables with strong ownership are considered; externally-retained by the implementation. This means that the variable is; retained elsewhere, and therefore the implementation can elide retaining and; releasing its value. Such a variable is implicitly ``const`` for safety. In; contrast with ``__unsafe_unretained``, an externally-retained variable still; behaves as a strong variable outside of initialization and destruction. For; instance, when an externally-retained variable is captured in a block the value; of the variable is retained and released on block capture and destruction. It; also affects C++ features such as lambda capture, ``decltype``, and template; argument deduction. Implicitly, the implementation assumes that the :ref:`self parameter in a; non-init method <arc.misc.self>` and the :ref:`variable in a for-in loop; <arc.misc.enumeration>` are externally-retained. Externally-retained semantics can also be opted into with the; ``objc_externally_retained`` attribute. This attribute can apply to strong local; variables, functions, methods, or blocks:. .. code-block:: objc. @class WobbleAmount;. @interface Widget : NSObject; -(void)wobble:(WobbleAmount *)amount;; @end. @implementation Widget. -(void)wobble:(WobbleAmount *)amount; __attribute__((objc_externally_retained)) {; // 'amount' and 'alias' aren't retained on entr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:92373,variab,variable,92373,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,['variab'],['variable']
Modifiability,"o that expansion order relative to other existing; substitutions is preserved. The following properties apply to both the ``DEFINE:`` and ``REDEFINE:``; directives:. - **Substitution name**: In the directive, whitespace immediately before or; after ``%{name}`` is optional and discarded. ``%{name}`` must start with; ``%{``, it must end with ``}``, and the rest must start with a letter or; underscore and contain only alphanumeric characters, hyphens, underscores, and; colons. This syntax has a few advantages:. - It is impossible for ``%{name}`` to contain sequences that are special in; python's ``re.sub`` patterns. Otherwise, attempting to specify; ``%{name}`` as a substitution pattern in a lit configuration file could; produce confusing expansions.; - The braces help avoid the possibility that another substitution's pattern; will match part of ``%{name}`` or vice-versa, producing confusing; expansions. However, the patterns of substitutions defined by lit; configuration files and by lit itself are not restricted to this form, so; overlaps are still theoretically possible. - **Substitution value**: The value includes all text from the first; non-whitespace character after ``=`` to the last non-whitespace character. If; there is no non-whitespace character after ``=``, the value is the empty; string. Escape sequences that can appear in python ``re.sub`` replacement; strings are treated as plain text in the value.; - **Line continuations**: If the last non-whitespace character on the line after; ``:`` is ``\``, then the next directive must use the same directive keyword; (e.g., ``DEFINE:``) , and it is an error if there is no additional directive.; That directive serves as a continuation. That is, before following the rules; above to parse the text after ``:`` in either directive, lit joins that text; together to form a single directive, replaces the ``\`` with a single space,; and removes any other whitespace that is now adjacent to that space. A; continuation can be co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:34481,config,configuration,34481,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['config'],['configuration']
Modifiability,"o the current object, this; will result in an infinite recursion and the abrupt end of the process. ``` {.cpp}; TClonesArray *fTracks; //->; TH1F *fH; //->; ```. ### Variable Length Array. When the `Streamer `comes across a pointer to a simple type, it assumes; it is an array. Somehow, it has to know how many elements are in the; array to reserve enough space in the buffer and write out the; appropriate number of elements. This is done in the class definition.; For example:. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; ...; Float_t *fClosestDistance; //[fNvertex]; ```. The array `fClosestDistance` is defined as a pointer of floating point; numbers. A comment mark (//), and the number in square brackets tell the; `Streamer `the length of the array for this object. In general the; syntax is:. ``` {.cpp}; <simple type> *<name>//[<length>]; ```. The length cannot be an expression. If a variable is used, it needs to; be an integer data member of the class. It must be defined ahead of its; use, or in a base class. The same notation also applies to variable length array of object and; variable length array of pointer to objects. ``` {.cpp}; MyObject *obj; //[fNojbs]; MyObject **objs; //[fDatas]; ```. ### Double32\_t. Math operations very often require double precision, but on saving; single usually precision is sufficient. For this purpose we support the; typedef Double32\_t which is stored in memory as a double and on disk as; a float or integer. The actual size of disk (before compression) is; determined by the parameter next to the data member declaration. For; example:. ``` {.cpp}; Double32_t m_data; //[min,max<,nbits>]; ```. If the comment is absent or does not contain `min`, `max`,; `nbits`, the member is saved as a `float`. If `min` and `max` are present, they are saved with 32 bits precision.; `min` and `max` can be explicit values or expressions of values known; to Cling (e.g. `pi`). If `nbit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:47474,variab,variable,47474,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['variab'],['variable']
Modifiability,"o the interpreter with all interpreter extensions disabled, i.e. as; ""proper"" C++ code. No autoloading or synamic lookup will be performed. A new R__LOAD_LIBRARY(libWhatever) will load libWhatever at parse time. This allows ROOT to resolve symbols from this library very early on. It is a work-around for the following code from ROOT 5:. ``` {.cpp}; // ROOT 5:; void func() {; gSystem->Load(""libEvent"");; Event* e = new Event;; }; ```. Instead, write:. ``` {.cpp}; // ROOT 6:; R__LOAD_LIBRARY(libEvent); #include ""Event.h"". void func() {; Event* e = new Event;; }; ```. #### TClass. Introduced new overload for calculating the TClass CheckSum:. ``` {.cpp}; UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const;; ```. which indicates via the 'isvalid' boolean whether the checksum could be; calculated correctly or not. ### TROOT. Implemented new gROOT->GetTutorialsDir() static method to return the actual location of the tutorials directory.; This is $ROOTSYS/tutorials when not configuring with --prefix or -Dgnuinstall for CMake. ### TColor. Add an enum to access the palette by name. Add new palettes with 255 colors. Names and colors' definitions have been taken from; [here](http://www.rcnp.osaka-u.ac.jp/~noji/colormap). Except for the `kBird` palette.; These palettes can be accessed with `gStyle->SetPalette(num)`. `num` can be taken; within the following enum:. * kDeepSea = 51; * kGreyScale = 52; * kDarkBodyRadiator = 53; * kBlueYellow = 54; * kRainBow = 55; * kInvertedDarkBodyRadiator = 56; * kBird = 57; * kCubehelix = 58; * kGreenRedViolet = 59; * kBlueRedYellow = 60; * kOcean = 61; * kColorPrintableOnGrey = 62; * kAlpine = 63; * kAquamarine = 64; * kArmy = 65; * kAtlantic = 66; * kAurora = 67; * kAvocado = 68; * kBeach = 69; * kBlackBody = 70; * kBlueGreenYellow = 71; * kBrownCyan = 72; * kCMYK = 73; * kCandy = 74; * kCherry = 75; * kCoffee = 76; * kDarkRainBow = 77; * kDarkTerrain = 78; * kFall = 79; * kFruitPunch = 80; * kFuchsia = 81; * kGreyYellow = 82; * kG",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:3793,config,configuring,3793,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['config'],['configuring']
Modifiability,"o the intrinsic provides; scope information for the variable ``X``. .. code-block:: text. !14 = !DILocation(line: 2, column: 9, scope: !4); !4 = distinct !DISubprogram(name: ""foo"", scope: !1, file: !1, line: 1, type: !5,; isLocal: false, isDefinition: true, scopeLine: 1,; isOptimized: false, retainedNodes: !2). Here ``!14`` is metadata providing `location information; <LangRef.html#dilocation>`_. In this example, scope is encoded by ``!4``, a; `subprogram descriptor <LangRef.html#disubprogram>`_. This way the location; information attached to the intrinsics indicates that the variable ``X`` is; declared at line number 2 at a function level scope in function ``foo``. Now lets take another example. .. code-block:: llvm. call void @llvm.dbg.declare(metadata i32* %Z, metadata !17, metadata !13), !dbg !19; ; [debug line = 5:9] [debug variable = Z]. The third intrinsic ``%llvm.dbg.declare`` encodes debugging information for; variable ``Z``. The metadata ``!dbg !19`` attached to the intrinsic provides; scope information for the variable ``Z``. .. code-block:: text. !18 = distinct !DILexicalBlock(scope: !4, file: !1, line: 4, column: 5); !19 = !DILocation(line: 5, column: 11, scope: !18). Here ``!19`` indicates that ``Z`` is declared at line number 5 and column; number 11 inside of lexical scope ``!18``. The lexical scope itself resides; inside of subprogram ``!4`` described above. The scope information attached with each instruction provides a straightforward; way to find instructions covered by a scope. Object lifetime in optimized code; =================================. In the example above, every variable assignment uniquely corresponds to a; memory store to the variable's position on the stack. However in heavily; optimized code LLVM promotes most variables into SSA values, which can; eventually be placed in physical registers or memory locations. To track SSA; values through compilation, when objects are promoted to SSA values an; ``llvm.dbg.value`` intrinsic is crea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:17307,variab,variable,17307,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"o the original size after boosting. SigToBkgFraction No 1 − Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost. PruneMethod No NoPruning NoPruning, ExpectedError, CostComplexity Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning: Pruning: Method used for pruning (removal) of statistically insignificant branches . PruneStrength No 0 − Pruning strength. PruningValFraction No 0.5 − Fraction of events to use for optimizing automatic pruning. nEventsMin No 0 − deprecated: Use MinNodeSize (in % of training events) instead. GradBaggingFraction No 0.6 − deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. . UseNTrainEvents No 0 − deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees. NNodesMax No 0 − deprecated: Use MaxDepth instead to limit the tree size. Configuration options for MVA method :. Configuration options reference for MVA method: Boost. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). Boost_Num No 100 − Number of times the classifier is bo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:15596,Config,Configuration,15596,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['Config'],['Configuration']
Modifiability,"o trap the signal and continue with the event loop,; using this method one can specify to exit with the signal number to the; shell, or to abort() which in addition generates a core dump. New command line argument -x which forces ROOT to exit on an exception.; Add TSystem::AddDynamicPath. Build. New option '-t' for rmkdepend to allow the caller to fully specify the name to be used as a target; This supersedes the name calculated from the input file name and the -p and -o option. ACLiC. Allow ACLiC to use a flat directory structure when a build directory is specified.; To use a flat structure do:. gSystem->SetBuildDir(whereIwant, kTRUE); // the default for the 2nd parameter is kFALSE. Or use '-' in the option of CompileMacro. gSystem->CompileMacro(myscript,""k-"",...);. Meta. Implement polymorphism for Emulated object (still not supporting polymorphism; of Emulated Object inheriting from compiled class).; This avoids memory leaks when the user data model relies on polymorphism; and does not the shared library defining the classes theand avoid splicing if the data is copied. TStreamerInfo::New inserts the address of the creating TStreamerInfo into; the object. This address is inserted in each emulated that does not inherit; from an emulated class and is positioned after all the base classes (which; are compiled classes). A derived class will set this value inside each; of its emulated base class.; TStreamerInfo::Destruct and the new method TStreamerInfo::GetActualClass; use this information to detect the TStreamerInfo actually used to create; the object and hence run the proper emulated destructor. Add a new function GenerateDictionary to TInterpreter which allows for the quick and easy creation of a dictionary; given one (or more) class name(s) and the name(s) of its header files. gInterpreter->GenerateDictionary(""vector<vector<float> >;list<vector<float> >"",""list;vector"");; gInterpreter->GenerateDictionary(""myclass"",""myclass.h;myhelper.h"");; This replaces the recommend",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html:2514,polymorphi,polymorphism,2514,core/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v528/index.html,2,['polymorphi'],['polymorphism']
Modifiability,"o use genreflex, call MakeProject with the ""genreflex"" option, for example:. file->MakeProject(libdir,""*"",""NEW+genreflex"");. To make sure the library created by MakeProject does not double delete an object,; tell the StreamerElement representing one of the pointers pointing to the object; to never delete the object. For example:. TClass::AddRule(""HepMC::GenVertex m_event attributes=NotOwner"");. MakeProject now implements a move constructor for each classes. For the implementation, we 'use' the 'copy constructor' until the C++ compilers properly support the official move constructor notation. Implementing a move constructor avoid having to delete and reconstruct resource during a std::vector resize and avoid the double delete induced by using the default copy constructor. MakeProject now adds dictionaries for auto_ptr. MakeProject no longer request the dictionary for std::pair instances that already have been loaded. Misc. TFile::Open now does variable expansion so that you can include the protocol in the variable (for example: export H1=""http://root.cern/files/h1""; ...; TFile::Open(""$H1/dstarmb.root"");; Added warning if the file does contain any StreamerInfo objects and was written with a different version of ROOT.; Implemented polymorphism for Emulated object (still not supporting polymorphism of Emulated Object inheriting from compiled class). See the Core/Meta section for details.; Add support for streaming auto_ptr when generating their dictionary via rootcint; Enable the use of the I/O customization rules on data members that are either a variable size array or a fixed size array. For example:. #pragma read sourceClass = ""ACache"" targetClass = ""ACache"" version = ""[8]"" \; source = ""Int_t *fArray; Int_t fN;"" \; target = ""fArray"" \; code = ""{ fArray = new Char_t[onfile.fN]; Char_t* gtc=fArray; Int_t* gti=onfile.fArray; \; for(Int_t i=0; i<onfile.fN; i++) *(gtc+i) = *(gti+i)+10; }""; #pragma read sourceClass = ""ACache"" targetClass = ""ACache"" version = ""[8]"" \; source",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html:9196,variab,variable,9196,io/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html,4,['variab'],['variable']
Modifiability,"o use with the ``gc`` function; attribute or, equivalently, with the ``setGC`` method of ``Function``. To implement a GC plugin, it is necessary to subclass ``llvm::GCStrategy``,; which can be accomplished in a few lines of boilerplate code. LLVM's; infrastructure provides access to several important algorithms. For an; uncontroversial collector, all that remains may be to compile LLVM's computed; stack map to assembly code (using the binary representation expected by the; runtime library). This can be accomplished in about 100 lines of code. This is not the appropriate place to implement a garbage collected heap or a; garbage collector itself. That code should exist in the language's runtime; library. The compiler plugin is responsible for generating code which conforms; to the binary interface defined by library, most essentially the :ref:`stack map; <stack-map>`. To subclass ``llvm::GCStrategy`` and register it with the compiler:. .. code-block:: c++. // lib/MyGC/MyGC.cpp - Example LLVM GC plugin. #include ""llvm/CodeGen/GCStrategy.h""; #include ""llvm/CodeGen/GCMetadata.h""; #include ""llvm/Support/Compiler.h"". using namespace llvm;. namespace {; class LLVM_LIBRARY_VISIBILITY MyGC : public GCStrategy {; public:; MyGC() {}; };. GCRegistry::Add<MyGC>; X(""mygc"", ""My bespoke garbage collector."");; }. This boilerplate collector does nothing. More specifically:. * ``llvm.gcread`` calls are replaced with the corresponding ``load``; instruction. * ``llvm.gcwrite`` calls are replaced with the corresponding ``store``; instruction. * No safe points are added to the code. * The stack map is not compiled into the executable. Using the LLVM makefiles, this code; can be compiled as a plugin using a simple makefile:. .. code-block:: make. # lib/MyGC/Makefile. LEVEL := ../..; LIBRARYNAME = MyGC; LOADABLE_MODULE = 1. include $(LEVEL)/Makefile.common. Once the plugin is compiled, code using it may be compiled using ``llc; -load=MyGC.so`` (though MyGC.so may have some other platform-spec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:24478,plugin,plugin,24478,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['plugin'],['plugin']
Modifiability,"o whats happen for TProof::Open("""").; Several; improvements in the handling of wild cards in the dataset manager; for; example, issuing a GetDataSet(...) on a dataset URI containign wild; cards will return a grand dataset sum of all the datasets matching the; URI.; Add options to get a list of all dataset registered names; from ScanDataSets (option kList; the result is a TMap of {TObjString,; TObjString} with the second TObjString empty).Improved version of the PQ2 scripts; the scripts now invoke a dedicated ROOT application (named pq2) available under $ROOTSYS/bin .Add; support for recursive reading of group config files via the 'include; sub-file' directive. This allows to have a common part and, for; example, customize differently the quotas.Fix an issue with TTreeFriends. New tutorial showing how to use friends in PROOF.Package; management: add support for arguments in the SETUP function: it is; possible now to pass a string or a list of objects. The; TProof::EnablePackage interface has been extended to support this.Optimize; the validation step in the case not all the entries are required. The; validation step is stopped as soon as the requested number of events is; reached. If the parameter ""PROOF_ValidateByFile"" is set to 1, the; number of files is exactly what needed; otherwise the number of files; may exceed the number of files needed by (Number_Of_Workers - 1) .; New directive 'xpd.datadir' to better control the user data directories and their permission settings. In TPacketizerUnit, add the possibility to exactly share the number of cycles between the workers.; See the parameter PROOF_PacketizerFixedNum.Implement; a timer to terminate idle sessions. The timeout value is controlled by; the variable ProofServ.IdleTimeout (value in seconds). This variable; can be set for all sessions in the xproofd config file via the 'xpd.putrc' directive.; Add the possibility to control the use of sub-mergers with; the ROOTrc variable Proof.SubMergers. It has the same mean",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:5845,extend,extended,5845,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,2,['extend'],['extended']
Modifiability,"o-called active pad. For; every day use, it is comfortable to be able to access the active pad,; whatever it is. For that purpose, there is a global pointer, called; ***`gPad`***. It is always pointing to the active pad. If you want to; change the fill color of the active pad to blue but you do not know its; name, do this. ``` {.cpp}; root[] gPad->SetFillColor(38); ```. To get the list of colors, go to the paragraph ""Color and color; palettes"" or if you have an opened canvas, click on the `View` menu,; selecting the `Colors` item. #### Finding an Object in a Pad. Now that we have a pointer to the active pad, ***`gPad`*** and that we; know this pad contains some objects, it is sometimes interesting to; access one of those objects. The method `GetPrimitive()` of **`TPad`**,; i.e. `TPad::GetPrimitive(const char* name)` does exactly this. Since; most of the objects that a pad contains derive from **`TObject`**, they; have a name. The following statement will return a pointer to the object; `myobjectname` and put that pointer into the variable `obj`. As you can; see, the type of returned pointer is `TObject*`. ``` {.cpp}; root[] obj = gPad->GetPrimitive(""myobjectname""); (class TObject*)0x1063cba8; ```. Even if your object is something more complicated, like a histogram; **`TH1F`**, this is normal. A function cannot return more than one type.; So the one chosen was the lowest common denominator to all possible; classes, the class from which everything derives, **`TObject`**. How do; we get the right pointer then? Simply do a cast of the function output; that will transform the output (pointer) into the right type. For; example if the object is a **`TPaveLabel`**:. ``` {.cpp}; root[] obj = (TPaveLabel*)(gPad->GetPrimitive(""myobjectname"")); (class TPaveLabel*)0x1063cba8; ```. This works for all objects deriving from **`TObject`**. However, a; question remains. An object has a name if it derives from **`TNamed`**,; not from **`TObject`**. For example, an arrow (**`TArrow`**)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:16226,variab,variable,16226,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['variab'],['variable']
Modifiability,"o. By default the; current working directory is used. .. option:: --rsp-quoting=<type>; This option selects the quoting style ``<type>`` for response files, either; ``posix`` or ``windows``. The default when on Windows is ``windows``, otherwise the; default is ``posix``. .. option:: --thin. When creating or modifying an archive, this option specifies that the; ``archive`` will be thin. By default, archives are not created as thin archives; and when modifying a thin archive, it will be converted to a regular archive. .. option:: --version. Display the version of the :program:`llvm-ar` executable. .. option:: -X mode. Specifies the type of object file :program:`llvm-ar` will recognise. The mode must be; one of the following:. 32; Process only 32-bit object files.; 64; Process only 64-bit object files.; 32_64; Process both 32-bit and 64-bit object files.; any; Process all object files. The default is to process 32-bit object files (ignore 64-bit objects). The mode can also; be set with the OBJECT_MODE environment variable. For example, OBJECT_MODE=64 causes ar to; process any 64-bit objects and ignore 32-bit objects. The -X flag overrides the OBJECT_MODE; variable. .. option:: @<FILE>. Read command-line options and commands from response file ``<FILE>``. MRI SCRIPTS; -----------. :program:`llvm-ar` understands a subset of the MRI scripting interface commonly; supported by archivers following in the ar tradition. An MRI script contains a; sequence of commands to be executed by the archiver. The :option:`-M` option; allows for an MRI script to be passed to :program:`llvm-ar` through the; standard input stream. Note that :program:`llvm-ar` has known limitations regarding the use of MRI; scripts:. * Each script can only create one archive.; * Existing archives can not be modified. MRI Script Commands; ~~~~~~~~~~~~~~~~~~~. Each command begins with the command's name and must appear on its own line.; Some commands have arguments, which must be separated from the name by; whit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst:11211,variab,variable,11211,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst,1,['variab'],['variable']
Modifiability,"o::registerSimpleStreamChecker(CheckerManager &mgr) {; mgr.registerChecker<SimpleStreamChecker>();; }. A package was selected for the checker and the checker was defined in the; table of checkers at include/clang/StaticAnalyzer/Checkers/Checkers.td.; Since all checkers should first be developed as ""alpha"", and the SimpleStreamChecker; performs UNIX API checks, the correct package is ""alpha.unix"", and the following; was added to the corresponding UnixAlpha section of Checkers.td:. let ParentPackage = UnixAlpha in {; ...; def SimpleStreamChecker : Checker<""SimpleStream"">,; HelpText<""Check for misuses of stream APIs"">,; DescFile<""SimpleStreamChecker.cpp"">;; ...; } // end ""alpha.unix"". The source code file was made visible to CMake by adding it to; lib/StaticAnalyzer/Checkers/CMakeLists.txt. After adding a new checker to the analyzer, one can verify that the new checker; was successfully added by seeing if it appears in the list of available checkers:; $clang -cc1 -analyzer-checker-help; Events, Callbacks, and Checker Class Structure; All checkers inherit from the ; Checker template class; the template parameter(s) describe the type of; events that the checker is interested in processing. The various types of events; that are available are described in the file ; CheckerDocumentation.cpp; For each event type requested, a corresponding callback function must be; defined in the checker class (; CheckerDocumentation.cpp shows the; correct function name and signature for each event type). As an example, consider SimpleStreamChecker. This checker needs to; take action at the following times:. Before making a call to a function, check if the function is fclose.; If so, check the parameter being passed.; After making a function call, check if the function is fopen. If; so, process the return value.; When values go out of scope, check whether they are still-open file; descriptors, and report a bug if so. In addition, remove any information about; them from the program state in o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:10127,inherit,inherit,10127,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,2,['inherit'],['inherit']
Modifiability,"o:; ```python; import ROOT. with ROOT.TFile.Open(""my_file.root"", ""RECREATE"") as my_file:. # Populate the TFile with simple objects.; my_file.WriteObject(ROOT.std.string(""hello world""), ""my_string""); my_file.WriteObject(ROOT.vector[""int""]([1, 2, 3]), ""my vector""). print(my_file[""my_string""]) # new syntax; print(my_file.my_string) # old deprecated syntax. # With the dictionary syntax, you can also use names that don't qualify as; # a Python variable:; print(my_file[""my vector""]); # print(my_file.my vector) # the old syntax would not work here!; ```. The old pythonization with the `__getattr__` syntax still works, but emits a deprecation warning and will be removed from ROOT 6.34. ### Removal of Python 2 support. ROOT does no longer support Python 2. The minimum Python version necessary to use ROOT in a Python application is 3.8.; As a consequence, any reference to Python 2 in ROOT code was removed and certain configuration options are no longer; usable, e.g. * `root-config --python2-version`; * cmake -Dpyroot-python2. The cmake build system now looks for the standard `Python3` package and previously custom Python-related cmake variables; are now just the ones automatically produced by cmake (see https://cmake.org/cmake/help/latest/module/FindPython.html). ### More usage of the public cppyy API. Many implementation details of the ROOT pythonizations were moved from C++ functions to pure Python bindings using the; public cppyy API. This helps in the integration with the tool but also improves code efficiency and memory usage. ## Class Reference Guide. - Define missing doxygen groups.; - Fix a few typos in the `THStack` documentation.; - Small fixes in the `THistPainter` documentation.; - Improve the `TColor` documentation: use modern C++ in the examples.; - Make sure the python examples do not generate wrong namespaces in the documentation.; - The dataframe tutorials json spec files were not displayed properly. Moreover there was; no direct correspondence between the cod",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:22703,config,config,22703,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['config'],['config']
Modifiability,"o; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10690,variab,variable,10690,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,2,['variab'],['variable']
Modifiability,"oFit. RooFit is an extensive toolkit.; The initiative to add AD support/ Code Generation has been started, but has; not yet achieved full coverage for the models defined/maintained in RooFit. ## How Clad enables AD support using Source Code Transformation. [Clad] is a C++ plugin for Clang. It implements a technique called Source Code; Transformation to enable AD support. Source Code Transformation takes the source code (that needs to be; differentiated) as the input and generates an output code that represents the; derivative of the input. This output code can be used instead of the input; code for more efficient compilation. For more technical details, please see the following paper:. > [Automatic Differentiation of Binned Likelihoods with RooFit and Clad](https://arxiv.org/abs/2304.02650). ## Overview on RooFit implementation details to access source code transformation AD. In RooFit jargon, what is meant by a ""RooFit class"" is a class inheriting from; RooAbsArg that represents a mathematical function, a PDF, or any other; transformation of inputs that are also represented by RooAbsArg objects.; Almost all final classes deriving from RooAbsArg have RooAbsReal as an; intermediate base class, which is the base class for all RooAbsArg that; represent real-valued nodes in the computation graph.; As such RooFit objects are so prevalent in practice, the names RooAbsArg and; RooAbsReal are used interchangeably in this guide. Users take these classes to build a computational graph that represents the; PDF (also called ""model"") that they want to use for fitting the data.; The user then passes his final PDF and a RooAbsData object to the; RooAbsPdf::fitTo() method, which implicitly creates a negative-log likelihood; (NLL) that RooFit minimizes for parameter estimation.; The NLL object, internally created by RooAbsPdf::createNLL(), is a RooAbsArg; itself.; In technical terms, it's another larger computation graph that encompasses the; computation graph representing the PDF. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:2983,inherit,inheriting,2983,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['inherit'],['inheriting']
Modifiability,"oManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume::Import(""file.root"", ""MOD1"");; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; ~~~. \anchor GP06a; ### GDML. Few lines above word GDML was used. GDML stands for Geometry; Description Markup Language. It is an application-independent; geometry description format based on XML. It is mainly used for geometry; interchange between %ROOT and Geant4 framework. More details about this; project can be found http://gdml.web.cern.ch. This feature; (importing/exporting from/to gdml file format) is disabled by default in; %ROOT installation. To enable this feature add `--enable-gdml` option to; `./configure` script call. \anchor GP07; ## Navigation Algorithms. This section will describe the main methods and algorithms used for; implementing the navigation features within the geometrical modeller.; This includes navigation queries at shape level, global geometrical; queries and optimization mechanisms. \anchor GP07a; ### Finding the State Corresponding to a Location (x,y,z). For reminder, a geometry state is a ‘touchable' object in the geometry; hierarchy. It is represented by a path like: `/TOP\_1/A\_1/B\_3/C\_1`,; where `B\_3` for instance is a copy of volume `B` positioned inside; volume `A`. A state is always associated to a transformation matrix; `M` of the touchable with respect to the global reference frame; (obtained by piling-up all local transformations of nodes in the branch; with respect to their containers). The current state and the; corresponding global matrix are updated whenever the geometry depth is; modified. The global transformations corresponding to all nodes in the; c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:115029,config,configure,115029,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['config'],['configure']
Modifiability,"oStream() has been deprecated in favor of a new; printStream() method which allows much greater control over the information printed. ; The printing of almost all RooFit objects has been reworked to present a more uniform look and feel.; The standard one-line result of the high-level Print() method without option now looks like. // Variable; x.Print() ;; RooRealVar::x = 0 L(-10 - 10) . // Function or p.d.f; gx.Print() ;; RooGaussian::gx[ x=x mean=m sigma=sx ] = 1. // Dataset; d.Print() ;; RooDataSet::gData[x,y] = 1000 entries. // RooPlot; frame.Print() ;; framex[x] = (RooHist::h_gData,RooCurve::g_Int[y]_Norm[x,y]_Comp[g]). Inside class RooPlot the default name of contained curves and histograms has been ; reworked in something more self descriptive as is shown in the above example. A usual,; a user supplied name can always be set by supplying the Name(const char*) argument; to plotOn(). Verbose printing with ""v"" options is mostly unchanged except for RooPlot. In addition; printing with the ""s"" option will show the 'old' standard printing mode, option ""t"" will show; tree structure printing (only for RooAbsArg), and option ""1"" will invoke inline printing, i.e; a one-line description without a trailing endl.; Data weighted projections of p.d.fs using the ProjWData() argument in RooAbsPdf::plotOn() are now calculated; with a new classes that derives from RooAbsOptTestStatistic and can thus implement the same evaluation; optimizations as are done for RooNLLVar and RooChi2Var. Specifically it is now possible to calculate projections; involving ProjWData() in parallel on multi-core hosts by adding the NumCPU(Int_t) argument to plotOn().; ; A new utility function has been added to allow cloning of entire tree expressions of; RooAbsArg objects, such as a composite p.d.f including component p.d.fs and; all its variables:. RooAbsArg* clonedTree = pdf.cloneTree() ;. All cloned leaf and branch nodes are owned by the returned head node of the expression.; Assorted minor fixes; ; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:20053,variab,variables,20053,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,2,['variab'],['variables']
Modifiability,"oad-arch=<target-id>``; Clang compilation options to specify the kind of code to generate. It is also used as part of the bundle entry ID to identify the code object. See; :ref:`clang-bundle-entry-id`. Target ID syntax is defined by the following BNF syntax:. .. code::. <target-id> ::== <processor> ( "":"" <target-feature> ( ""+"" | ""-"" ) )*. Where:. **processor**; Is a the target specific processor or any alternative processor name. **target-feature**; Is a target feature name that is supported by the processor. Each target; feature must appear at most once in a target ID and can have one of three; values:. *Any*; Specified by omitting the target feature from the target ID.; A code object compiled with a target ID specifying the default; value of a target feature can be loaded and executed on a processor; configured with the target feature on or off. *On*; Specified by ``+``, indicating the target feature is enabled. A code; object compiled with a target ID specifying a target feature on; can only be loaded on a processor configured with the target feature on. *Off*; specified by ``-``, indicating the target feature is disabled. A code; object compiled with a target ID specifying a target feature off; can only be loaded on a processor configured with the target feature off. .. _compatibility-target-id:. Compatibility Rules for Target ID; ---------------------------------. A code object compiled for a Target ID is considered compatible for a; target, if:. * Their processor is same.; * Their feature set is compatible as defined above. There are two forms of target ID:. *Non-Canonical Form*; The non-canonical form is used as the input to user commands to allow the user; greater convenience. It allows both the primary and alternative processor name; to be used and the target features may be specified in any order. *Canonical Form*; The canonical form is used for all generated output to allow greater; convenience for tools that consume the information. It is also used for; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:12324,config,configured,12324,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,1,['config'],['configured']
Modifiability,"oat`` has the capability of holding floating point; constants of Arbitrary Precision). This code basically just creates; and returns a ``ConstantFP``. Note that in the LLVM IR that constants; are all uniqued together and shared. For this reason, the API uses the; ""foo::get(...)"" idiom instead of ""new foo(..)"" or ""foo::Create(..)"". .. code-block:: c++. Value *VariableExprAST::codegen() {; // Look this variable up in the function.; Value *V = NamedValues[Name];; if (!V); LogErrorV(""Unknown variable name"");; return V;; }. References to variables are also quite simple using LLVM. In the simple; version of Kaleidoscope, we assume that the variable has already been; emitted somewhere and its value is available. In practice, the only; values that can be in the ``NamedValues`` map are function arguments.; This code simply checks to see that the specified name is in the map (if; not, an unknown variable is being referenced) and returns the value for; it. In future chapters, we'll add support for `loop induction; variables <LangImpl05.html#for-loop-expression>`_ in the symbol table, and for `local; variables <LangImpl07.html#user-defined-local-variables>`_. .. code-block:: c++. Value *BinaryExprAST::codegen() {; Value *L = LHS->codegen();; Value *R = RHS->codegen();; if (!L || !R); return nullptr;. switch (Op) {; case '+':; return Builder->CreateFAdd(L, R, ""addtmp"");; case '-':; return Builder->CreateFSub(L, R, ""subtmp"");; case '*':; return Builder->CreateFMul(L, R, ""multmp"");; case '<':; L = Builder->CreateFCmpULT(L, R, ""cmptmp"");; // Convert bool 0/1 to double 0.0 or 1.0; return Builder->CreateUIToFP(L, Type::getDoubleTy(TheContext),; ""booltmp"");; default:; return LogErrorV(""invalid binary operator"");; }; }. Binary operators start to get more interesting. The basic idea here is; that we recursively emit code for the left-hand side of the expression,; then the right-hand side, then we compute the result of the binary; expression. In this code, we do a simple switch on the op",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:6226,variab,variables,6226,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['variab'],['variables']
Modifiability,"obal variable; or function, the initializer function will only run if the associated; data from the current module is not discarded.; On ELF the referenced global variable or function must be in a comdat. .. _llvmglobaldtors:. The '``llvm.global_dtors``' Global Variable; -------------------------------------------. .. code-block:: llvm. %0 = type { i32, ptr, ptr }; @llvm.global_dtors = appending global [1 x %0] [%0 { i32 65535, ptr @dtor, ptr @data }]. The ``@llvm.global_dtors`` array contains a list of destructor; functions, priorities, and an associated global or function.; The functions referenced by this array will be called in descending; order of priority (i.e. highest first) when the module is unloaded. The; order of functions with the same priority is not defined. If the third field is non-null, and points to a global variable; or function, the destructor function will only run if the associated; data from the current module is not discarded.; On ELF the referenced global variable or function must be in a comdat. Instruction Reference; =====================. The LLVM instruction set consists of several different classifications; of instructions: :ref:`terminator instructions <terminators>`, :ref:`binary; instructions <binaryops>`, :ref:`bitwise binary; instructions <bitwiseops>`, :ref:`memory instructions <memoryops>`, and; :ref:`other instructions <otherops>`. .. _terminators:. Terminator Instructions; -----------------------. As mentioned :ref:`previously <functionstructure>`, every basic block in a; program ends with a ""Terminator"" instruction, which indicates which; block should be executed after the current block is finished. These; terminator instructions typically yield a '``void``' value: they produce; control flow, not values (the one exception being the; ':ref:`invoke <i_invoke>`' instruction). The terminator instructions are: ':ref:`ret <i_ret>`',; ':ref:`br <i_br>`', ':ref:`switch <i_switch>`',; ':ref:`indirectbr <i_indirectbr>`', ':ref:`invoke <",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:354156,variab,variable,354156,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"obal variables** - While global variables have questionable value; in modern software engineering, they are often useful when putting; together quick little hacks like the Kaleidoscope compiler itself.; Fortunately, our current setup makes it very easy to add global; variables: just have value lookup check to see if an unresolved; variable is in the global variable symbol table before rejecting it.; To create a new global variable, make an instance of the LLVM; ``GlobalVariable`` class.; - **typed variables** - Kaleidoscope currently only supports variables; of type double. This gives the language a very nice elegance, because; only supporting one type means that you never have to specify types.; Different languages have different ways of handling this. The easiest; way is to require the user to specify types for every variable; definition, and record the type of the variable in the symbol table; along with its Value\*.; - **arrays, structs, vectors, etc** - Once you add types, you can start; extending the type system in all sorts of interesting ways. Simple; arrays are very easy and are quite useful for many different; applications. Adding them is mostly an exercise in learning how the; LLVM `getelementptr <../../LangRef.html#getelementptr-instruction>`_ instruction; works: it is so nifty/unconventional, it `has its own; FAQ <../../GetElementPtr.html>`_!; - **standard runtime** - Our current language allows the user to access; arbitrary external functions, and we use it for things like ""printd""; and ""putchard"". As you extend the language to add higher-level; constructs, often these constructs make the most sense if they are; lowered to calls into a language-supplied runtime. For example, if; you add hash tables to the language, it would probably make sense to; add the routines to a runtime, instead of inlining them all the way.; - **memory management** - Currently we can only access the stack in; Kaleidoscope. It would also be useful to be able to allocate heap; me",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:2361,extend,extending,2361,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['extend'],['extending']
Modifiability,"object is linked.; class MyPlugin : public ObjectLinkingLayer::Plugin {; public:. // Add passes to print the set of defined symbols after dead-stripping.; void modifyPassConfig(MaterializationResponsibility &MR,; const Triple &TT,; jitlink::PassConfiguration &Config) override {; Config.PostPrunePasses.push_back([this](jitlink::LinkGraph &G) {; return printAllSymbols(G);; });; }. // Implement mandatory overrides:; Error notifyFailed(MaterializationResponsibility &MR) override {; return Error::success();; }; Error notifyRemovingResources(ResourceKey K) override {; return Error::success();; }; void notifyTransferringResources(ResourceKey DstKey,; ResourceKey SrcKey) override {}. // JITLink pass to print all defined symbols in G.; Error printAllSymbols(LinkGraph &G) {; for (auto *Sym : G.defined_symbols()); if (Sym->hasName()); dbgs() << Sym->getName() << ""\n"";; return Error::success();; }; };. // Create our LLJIT instance using a custom object linking layer setup.; // This gives us a chance to install our plugin.; auto J = ExitOnErr(LLJITBuilder(); .setObjectLinkingLayerCreator(; [](ExecutionSession &ES, const Triple &T) {; // Manually set up the ObjectLinkingLayer for our LLJIT; // instance.; auto OLL = std::make_unique<ObjectLinkingLayer>(; ES, std::make_unique<jitlink::InProcessMemoryManager>());. // Install our plugin:; OLL->addPlugin(std::make_unique<MyPlugin>());. return OLL;; }); .create());. // Add an object to the JIT. Nothing happens here: linking isn't triggered; // until we look up some symbol in our object.; ExitOnErr(J->addObject(loadFromDisk(""main.o"")));. // Plugin triggers here when our lookup of main triggers linking of main.o; auto MainSym = J->lookup(""main"");. LinkGraph; =========. JITLink maps all relocatable object formats to a generic ``LinkGraph`` type; that is designed to make linking fast and easy (``LinkGraph`` instances can; also be created manually. See :ref:`constructing_linkgraphs`). Relocatable object formats (e.g. COFF, ELF, MachO) diffe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:5891,plugin,plugin,5891,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['plugin'],['plugin']
Modifiability,"object were referenced.; 16->16 fName = Number of bytes in name of TObjArray object, followed by the; | name itself. (TCollection::fName). TObjArray objects in; | StreamerInfo record are unnamed, so byte contains 0.; 17->20 nObjects = Number of objects (derived from TStreamerElement) in array.; 21->24 fLowerBound = Lower bound of array. Will always be 0 in StreamerInfo record.; 25->.. objects = Sequentially, TStreamerElement objects in the array.; | In a TStreamerInfo object, the objects in the TObjArray are; | of various types (described below), all of which inherit; | directly from TStreamerElement objects. There will be one; | such object for every base class of the class that the; | TStreamerInfo object describes, and also one such object for; | each persistent non-static data member of the class that the; | TStreamerInfo object describes.; -End TObjArray object and TStreamerInfo object; -------; </pre></div>. The objects stored in the TObjectArray in TStreamerInfo are of various classes, each of; which inherits directly from the TStreamerElement class. The possible classes (which; we refer to collectively as TStreamer<XXX>) are:. <div style=""background-color: lightgrey; font-size: 0.9vw;""><pre>; TStreamerBase: Used for a base class. All others below used for data members.; TStreamerBasicType: For a basic type; TStreamerString: For type TString; TStreamerBasicPointer: For pointer to array of basic types; TStreamerObject: For an object derived from TObject; TStreamerObjectPointer: For pointer to an object derived from TObject; TStreamerLoop: For pointer to an array of objects; TStreamerObjectAny: For an object not derived from TObject; TStreamerSTL: For an STL container (not yet used??); TStreamerSTLString: For an STL string (not yet used??); -------; </pre></div>. Here is the format of a TStreamer<XXX> object in Release 3.02.06.; In description below,. <div style=""background-color: lightgrey; font-size: 0.9vw;""><pre>; 0->3 ByteCount = Number of remaining bytes i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/streamerinfo.md:6839,inherit,inherits,6839,io/doc/TFile/streamerinfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/streamerinfo.md,1,['inherit'],['inherits']
